AndVersion(), szIdVersion);

    szRDN= new WCHAR[3+wcslen(szIdVersion)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", szIdVersion);

    DNParentName = m_pMyEntry->getFullDNAlloc();

    DBGOUT(DIRSVC, "Trying to Delete Interface " << szRDN << "from the DS\n");

    hr = Delete(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()));

    delete DNParentName;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Interface " << szRDN << "from the DS \n\n");

    delete szRDN;

    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, PROFILE, PROFILE1, PRIORITY, INTERFACEID, ANNOTATION

HRESULT CProfileElement::AddToDS()
{
    HRESULT                 hr = S_OK;
    RPC_SYNTAX_IDENTIFIER   in;
    STRINGGUID              szGUID;
    STRINGGUIDVERSION       szIdVersion;
    WCHAR                 * szRDN=NULL;
    WCHAR                 * DNParentName = NULL, *szEntryName = NULL;
    ADS_ATTR_INFO           pAttr[5];
    DWORD                   i, cAttr = 4, cCreateAttr = 5, cTotalAttr = 5;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN = new WCHAR[3+wcslen((STRING_T)*EntryName.getEntryName())+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    PackStrToAttr(pAttr+0, CLASSNAME, RPCPROFILEELEMENTCLASS);
    // class

    PackStrToAttr(pAttr+1, PROFILE, szEntryName = EntryName.getFullDNWithDomainAlloc());
    // link to the real entry.

    PackIntToAttr(pAttr+2, PRIORITY, dwPriority);
    // priority

    SyntaxIdToString(Interface.myIdAndVersion(), szIdVersion);
    PackStrToAttr(pAttr+3, INTERFACEID, szIdVersion);
    // interface id

    if ((!pszAnnotation) || (!wcslen(pszAnnotation))) {
        cCreateAttr--;
        PackStrToAttr(pAttr+4, ANNOTATION, NULL);
    }
    else
        PackStrToAttr(pAttr+4, ANNOTATION, pszAnnotation);
    // annotation

    DNParentName = m_pMyEntry->getFullDNAlloc();

    wsprintf(szRDN, L"CN=%s", (STRING_T)*EntryName.getEntryName());

    DBGOUT(DIRSVC, "Trying to Store Profile Element " << szRDN << "in the DS\n");

    hr = UpdateOrCreate(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()),
			pAttr, cAttr, cCreateAttr);

    delete DNParentName;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Profile ELement " << szRDN << "in the DS\n\n");

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);

    delete szEntryName;
    delete szRDN;

    return hr;
}


HRESULT CProfileElement::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;
    WCHAR                  *DNParentName = NULL;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to delete from DS");

    szRDN = new WCHAR[3+wcslen((STRING_T)*EntryName.getEntryName())+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    DNParentName = m_pMyEntry->getFullDNAlloc();

    wsprintf(szRDN, L"CN=%s", (STRING_T)(*(EntryName.getEntryName())));

    DBGOUT(DIRSVC, "Trying to delete Profile Element " << szRDN << "from the DS\n");

    hr = Delete(DNParentName, szRDN, *(m_pMyEntry->getDomainNameDns()));

    delete DNParentName;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Profile Element " << szRDN << "from the DS \n\n");

    delete szRDN;
    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, GROUP, GROUP1, DESCRIPTION, GROUP
HRESULT CGroupEntry::AddToDS()
{
    HRESULT                 hr = S_OK;
    ULONG                   i, sz;
    CEntryName             *EntryName = NULL;
    WCHAR                 **pszGroupList = NULL;
    WCHAR                  *szRDN=NULL;
    ADS_ATTR_INFO           pAttr[3];
    DWORD                   cAttr = 2, cTotalAttr = 3, cCreateAttr = 3;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    PackStrToAttr(pAttr+0, CLASSNAME, RPCGROUPCLASS);
    // class

    PackStrToAttr(pAttr+1, DESCRIPTION, L"RPC Group Entry");
    // description

    // BUGBUG:: Object IDs.??

    pszGroupList = new LPWSTR[sz = GroupList.size()];
    if (!pszGroupList)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        TCSafeSkipListIterator<CEntryName> GroupIter(GroupList);

        for (i = 0; i < sz; i++) {
            EntryName = GroupIter.next();
            pszGroupList[i] = (EntryName->getFullDNWithDomainAlloc());
        }

        if (!sz)
            cCreateAttr--;
        PackStrArrToAttr(pAttr+2, GROUP, pszGroupList, sz);
        // links to group entries
    }
    // BUGBUG:: Hack waiting for schema changes.
    DBGOUT(DIRSVC, "Storing the Group Entry " << szRDN << "in the DS\n\n");


    if (SUCCEEDED(hr))
        hr = UpdateOrCreateEntry(*getRpcContainer(), szRDN, *getDomainNameDns(), pAttr, cAttr, cCreateAttr);

    if (pszGroupList)
       for (i = 0; i < GroupList.size(); i++)
	  delete pszGroupList[i];
    delete pszGroupList;

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Group Entry " << szRDN << "in the DS\n\n");

    delete szRDN;
    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);
    return hr;
}


HRESULT CGroupEntry::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Delete Group Entry " << szRDN << "from the DS\n");

    hr = Delete(*getRpcContainer(), szRDN, *getDomainNameDns());

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Group Entry " << szRDN << "from the DS \n\n");

    delete szRDN;

    return hr;
}

// Created entry is of type server entry and hence would not
// require to check whether the entry was created by create etc.

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, DESCRIPTION, OBJECTID

HRESULT CServerEntry::AddToDS()
{
    HRESULT                  hr = S_OK;
    ULONG                    i, sz;
    CGUID                   *Object;
    GUID                     ObjectGuid;
    WCHAR                   *szRDN=NULL;
    WCHAR                  **pszGuid=NULL;
    ADS_ATTR_INFO            pAttr[3];
    DWORD                    cAttr = 2, cCreateAttr = 3, cTotalAttr = 3;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Store Server Entry " << szRDN << "in the DS\n");

    PackStrToAttr(pAttr+0, CLASSNAME, RPCSERVERCONTAINERCLASS);
    // class

    PackStrToAttr(pAttr+1, DESCRIPTION, L"RPC Server Container");
    // description

    if (SUCCEEDED(hr)) {
        sz = ObjectList.size();
        pszGuid = new LPWSTR[sz];
        if (!pszGuid)
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr)) {
        TCSafeSkipListIterator<CGUID> ObjectIterator(ObjectList);

        for (i = 0; i < sz; i++) {
            Object = ObjectIterator.next();
            ObjectGuid = Object->myGUID();
            UuidToString(&ObjectGuid, &pszGuid[i]);
        }
        if (!sz)
            cCreateAttr--;
        PackStrArrToAttr(pAttr+2, OBJECTID, pszGuid, sz);
    }
    // convert and store object uuids.

    if (SUCCEEDED(hr))
        hr = UpdateOrCreate(*getRpcContainer(), szRDN, *getDomainNameDns(), pAttr, cAttr, cCreateAttr);

    for (i = 0; i < sz; i++)
        RpcStringFree(&pszGuid[i]);
    delete pszGuid;

    //BUGBUG::Codeset??

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Server Entry " << szRDN << "in the DS\n\n");

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);
    delete szRDN;
    return hr;
}

HRESULT CServerEntry::DeleteFromDS()
{
    HRESULT                 hr=S_OK;
    WCHAR                  *szRDN=NULL;
    int                     i, sz;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;
    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Delete Server Entry " << szRDN << "in the DS\n");

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);
    CInterface *pintf = NULL;

    sz = InterfaceList.size();
    for (i = 0; i < sz; i++) {
        pintf = IfIter.next();
        pintf->DeleteFromDS();
    }
    // Deleting all the interfaces listed under it from the DS.

    hr = Delete(*getRpcContainer(), szRDN, *getDomainNameDns());

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Server Entry " << szRDN << "in the DS\n\n");

    delete szRDN;
    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, DESCRIPTION

HRESULT CProfileEntry::AddToDS()
{
    HRESULT                 hr = S_OK;
    WCHAR                  *szRDN=NULL;
    ADS_ATTR_INFO           pAttr[2];
    DWORD                   i, cAttr = 1, cCreateAttr = 2, cTotalAttr = 2;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;
    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);
    DBGOUT(DIRSVC, "Trying to Store Profile Entry " << szRDN << "in the DS\n");

    PackStrToAttr(pAttr+0, CLASSNAME, RPCPROFILECONTAINERCLASS);
    PackStrToAttr(pAttr+1, DESCRIPTION, L"RPC Profile Container");

    hr = UpdateOrCreateEntry(*getRpcContainer(), szRDN, *getDomainNameDns(), pAttr, cAttr, cCreateAttr);

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Stored the Profile Entry " << szRDN << "in the DS\n\n");

    for (i = 0; i < cTotalAttr; i++)
        FreeAttr(pAttr[i]);

    delete szRDN;
    return hr;
}


HRESULT CProfileEntry::DeleteFromDS()
{
    HRESULT                 hr = S_OK;
    WCHAR                  *szRDN=NULL;
    DWORD                   i, sz;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    szRDN= new WCHAR[3+wcslen((STRING_T)*pswEntryName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pswEntryName);

    DBGOUT(DIRSVC, "Trying to Delete Profile Entry " << szRDN << "from the DS\n");

    if (pDefaultElt)
        pDefaultElt->DeleteFromDS();

    TCSafeSkipListIterator<CProfileElement> PEIter(EltList);
    CProfileElement *pProfileElement;
    sz = EltList.size();

    for (i = 0; i < sz; i++) {
        pProfileElement = PEIter.next();
        pProfileElement->DeleteFromDS();
    }
    // deleting all the profile elements under it.

    hr = Delete(*getRpcContainer(), szRDN, *getDomainNameDns());

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Deleted the Profile Entry " << szRDN << "from the DS \n\n");

    delete szRDN;
    return hr;
}

// This function modifies/fills in the following structure in the DS.
//
// CLASSNAME, DESCRIPTION

HRESULT
Locator::CreateEntryInDS(CEntryName *pEntryName)
{
    HRESULT                 hr = S_OK;
    WCHAR                  *szFullName=NULL, *szRDN=NULL;
    CStringW              * pLocalName;
    ADS_ATTR_INFO           pAttr[2];
    HANDLE                  hDSObject;
    DWORD                   i, cAttr = 0;

    ASSERT(myRpcLocator->fDSEnabled, "DS not enabled and trying to add in DS");

    pLocalName = pEntryName->getEntryName();
    szRDN = new WCHAR[3+wcslen((STRING_T)*pLocalName)+1];
    if (!szRDN)
        return E_OUTOFMEMORY;

    szFullName = new WCHAR[RPCCONTAINERPREFIXLEN+wcslen((STRING_T)(*(pEntryName->getDomainNameDns())))+1+
                           wcslen((STRING_T)(*(pEntryName->getRpcContainer())))+1];

    if (!szFullName) {
        delete szRDN;
        return E_OUTOFMEMORY;
    }

    wsprintf(szRDN, L"CN=%s", (STRING_T)*pLocalName);
    wsprintf(szFullName, L"%s%s/%s", RPCCONTAINERPREFIX, (STRING_T)(*(pEntryName->getDomainNameDns())),
                                     (STRING_T)(*(pEntryName->getRpcContainer())));

    DBGOUT(DIRSVC, "Trying to Create Entry " << szRDN << "in the DS\n");

    // Try to create the entry.

    DBGOUT(DIRSVC, "CreateEntryInDS Opening " << szFullName << "in the DS\n");
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hDSObject);
    if (SUCCEEDED(hr)) {
        PackStrToAttr(pAttr+cAttr, CLASSNAME, RPCSERVERCONTAINERCLASS); cAttr++;
        PackStrToAttr(pAttr+cAttr, DESCRIPTION, CREATED_DESCRIPTION); cAttr++;
        hr = ADSICreateDSObject(hDSObject, szRDN, pAttr, cAttr);
        ADSICloseDSObject(hDSObject);
    }

    if (SUCCEEDED(hr))
        DBGOUT(DIRSVC, "Created Entry " << szRDN << "in the DS\n\n");

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);

    delete szRDN;
    delete szFullName;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\locator.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    stubs.cxx

Abstract:

    This module contains stubs for unimplemented API functions.

Author:

    Satish Thatte (SatishT) 08/16/95  Created all the code below except where
                                      otherwise indicated.

--*/

#include <locator.hxx>

/***********                                                            **********/
/***********   constructor and utility operations in the Locator class  **********/
/***********                                                            **********/

// int fTriedConnectingToDS;


Locator::Locator()
/*++
Member Description:

    Constructor.  Initializes the state of the locator, including discovering whether
    it is running in a domain or workgroup, and the names of DCs, if any.  In a domain,
    if the PDC machine (not just the PDC locator) is down, the environment is initialized
    to workgroup instead of domain.

    It contacts the DS and gets the DNS name of the domain, gets the compatibilty
    flag for the domain before going any further.

--*/
{

    //    fTriedConnectingToDS = 0;
    NTSTATUS          Status;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pdsrole;

    // This contains various flags whether we are in workgroup, DNS name of the domain
    // etc.

    DBGOUT(DIRSVC, "Calling DsRoleGetPrimaryDomainInformation\n");

    Status = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *)&pdsrole);
    if (!NT_SUCCESS(Status) || (!pdsrole))
        Raise(NSI_S_INTERNAL_ERROR);

    DBGOUT(DIRSVC, "DsRoleGetPrimaryDomainInformation returned Status\n");

    // gets info abt. the DNS name of the m/c and
    // the compatibility flag

    SetConfigInfoFromDS(*pdsrole);

    srand( (unsigned)time( NULL ) );

    // all the info related with whether it is running in a domain,
    // the PDC name etc. is required only if we have to support
    // NT4 clients. In a pure NT5 Domain we do not need this.

    if (fNT4Compat)
        SetCompatConfigInfo(*pdsrole);

    DsRoleFreeMemory(pdsrole);
    SetSvcStatus();
}


Locator::~Locator()
/*++
Member Description:

    Destructor.

--*/
{
    delete pDomainName;
    delete pDomainNameDns;
    delete pRpcContainerDN;

    if (fNT4Compat) {
        delete pComputerName;
        delete pPrimaryDCName;
        SetSvcStatus();
        pInternalCache->wipeOut();
        delete pInternalCache;

        PCSBroadcastHistory.Enter();
        SetSvcStatus();
        psllBroadcastHistory->wipeOut();
        delete psllBroadcastHistory;

        SetSvcStatus();
        pAllMasters->wipeOut();
        delete pAllMasters;

        SetSvcStatus();
        delete pCacheInterfaceIndex;
        delete hMailslotForReplies;
        delete hMasterFinderSlot;
    }
    DBGOUT(BROADCAST, "Destroying locator structure\n");
}


CFullServerEntry *
Locator::GetEntryFromCache(
    IN UNSIGNED32    EntryNameSyntax,
    IN STRING_T      EntryName
    )
/*++
Member Description:

    Get the given entry locally.
    Raise exceptions if anything is wrong.

Arguments:

    EntryNameSyntax - Name syntax

    EntryName       - Name string of the entry to export

    Interface       - Interface to standardize

Returns:

    The entry found -- NULL if none.

--*/
{

    if (EntryNameSyntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!EntryName) Raise(NSI_S_INCOMPLETE_NAME);

    /* The constructor for CEntryName used below makes the name local if possible */

    CStringW * pswName = new CStringW(CEntryName(EntryName));
    CFullServerEntry * pFSEntry = NULL;

    __try {
        pFSEntry = pInternalCache->find(pswName);
    }

    __finally {
        delete pswName;
    }

    return pFSEntry;
}


/***********                                               **********/
/***********   primary API operations in the Locator class **********/
/***********                                               **********/

BOOL Locator::nsi_binding_export(
    IN UNSIGNED32                         EntryNameSyntax,
    IN STRING_T                           EntryName,
    IN NSI_INTERFACE_ID_T            *    Interface,
    IN NSI_SERVER_BINDING_VECTOR_T   *    BindingVector,
    IN NSI_UUID_VECTOR_P_T                ObjectVector,
    IN ExportType                         type
    )
/*++
Member Description:

    This is basically the API function for binding export.  The member version
    here does raise exception (often inside a try block) but they are all error
    situations and therefore acceptable for performance.  This member is also used
    for updating the locator's cache.

Arguments:

    EntryNameSyntax - Name syntax, optional

    EntryName       - (raw) Name of the entry to look up, optional

    Interface       - (raw) Interface+TransferSyntax to export

    BindingVector   - (raw) Vector of string bindings to export.

    ObjectVector    - (raw) Vector of object UUIDs to add to the entry

    type            - local or nonlocal (owned or imported information)

 Returns:

    true if there were changes to the entry, false o/w.

 Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_OUT_OF_MEMORY, NSI_S_INVALID_OBJECT, NSI_S_NOTHING_TO_EXPORT,
    NSI_S_ENTRY_TYPE_MISMATCH

Comments:
   Called when the export happens from a client
   or when we want to store a broadcast reply
   in the cache.

   If the export is happening directly
      1. add it to the DS.
      2. add it to the cache as an owned entry (only if NT4Compat flag is on)

   if the export is happening to store broadcast replies
      1. add it to the cache as non owned member
--*/
{
    int                fChanges = FALSE, fNewEntry = FALSE, fDSNewEntry = FALSE;
    CServerEntry     * pRealEntry = NULL;
    HRESULT            hr = S_OK;
    CFullServerEntry * pFSEntry = NULL;
    CEntry           * pDSEntry = NULL;

    // entries get into the DS, through this entry.
    // DS might have come up later and the old entry found
    // in the cache should still go to DS. Hence a seperate
    // fDSNewEntry flag.

    // validate
    if (Interface && IsNilIfId(&(Interface->Interface))) Interface = NULL;

    if (!ObjectVector && (!Interface || !BindingVector))
        Raise(NSI_S_NOTHING_TO_EXPORT);

    if (type == Local) {
        // get entry from the DS, whatever Compat flag is if export is Local.
        if (fDSEnabled)
            pDSEntry = GetEntryFromDS(EntryNameSyntax, EntryName);        

        if ((pDSEntry) && (pDSEntry->getType() != ServerEntryType))
        {
            // if there is an entry in the DS with a different type raise an exception.
            DBGOUT(TRACE, "Entry found and is not of the type FSEntryType\n");
            delete pDSEntry;
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
        }

        // if not found.
        if ((!pDSEntry) && (fDSEnabled)) {
            pDSEntry = new CServerEntry(EntryName);
            fDSNewEntry = TRUE;
        }
    }

    if (fNT4Compat) {
        // Look whether the entry exists in the local machine.

        pFSEntry = GetEntryFromCache(
            EntryNameSyntax,
            EntryName
            );

        ASSERT(!((pFSEntry) && (pFSEntry->getType() != FullServerEntryType)),
            "Wrong Entry type found in cache\n");

        if (!pFSEntry) {
            fNewEntry = fChanges = TRUE;

            // if entry doesn't exist, create a new Full Server entry.
            // NOTE: SECURITY: need extra check here

            pFSEntry = new CFullServerEntry(EntryName);

            if (!pFSEntry) 
                Raise (NSI_S_OUT_OF_MEMORY);

            pInternalCache->insert(pFSEntry);
        }

        switch (type) {
        case Local:
            pRealEntry = pFSEntry->getLocal();
            break;
        case NonLocal:
            pRealEntry = pFSEntry->getNonLocal();
        }
    }

    __try
    {
        DBGOUT(DIRSVC, "exporting now to the server entry\n");

        if (fNT4Compat) {
            // put it in the cache, local or NonLocal (depending on type)
            fChanges = pRealEntry->add_to_entry(
                Interface,
                BindingVector,
                ObjectVector,
                pCacheInterfaceIndex,
                FALSE
                )
                || fChanges;
            DBGOUT(DIRSVC, "exported to the local server entry\n");
        }

        if (pDSEntry) {
            ((CServerEntry *)pDSEntry)->add_changes_to_DS(
                Interface,
                BindingVector,
                ObjectVector,
                fDSNewEntry,
        		fNT4Compat
                );
            // return value not used.
        }

//        if ((pDSEntry) ** (!(pDSEntry->pswDomainName))) {
//        BUGBUG:: log an Event here.        
//        }
    }

    __except (
        (GetExceptionCode() == NSI_S_NOTHING_TO_EXPORT) && (fNewEntry || fDSNewEntry) ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        {
        /* BUGBUG:  This guard should really be here but it conflicts with
           the reader guard in isEmpty -- leave out for now.

           CriticalWriter me(rwEntryGuard);
         */
            DBGOUT(DIRSVC, "got an exception\n");

            if ((fNT4Compat) && (pFSEntry->isEmpty())) {
                pInternalCache->remove(pFSEntry);
                delete pFSEntry;
            }
        }

        Raise(NSI_S_NOTHING_TO_EXPORT);
    }

    delete pDSEntry;

    return fChanges;
}    // nsi_binding_export

void
Locator::nsi_mgmt_binding_unexport(
    UNSIGNED32          EntryNameSyntax,
    STRING_T            EntryName,
    NSI_IF_ID_P_T       Interface,
    UNSIGNED32          VersOption,
    NSI_UUID_VECTOR_P_T ObjectVector
    )
/*++

Member Description:

    unexport information from a server entry -- finer control than nsi_binding
    counterpart.

Arguments:

    EntryNameSyntax - name syntax

    EntryName       - (raw) Name string of the entry to unexport

    Interface       - (raw) Interface+TransferSyntax to unexport

    VersOption      - flag which controls in fine detail which interfaces to remove

    ObjectVector    - objects to remove from the entry

Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME,
    NSI_S_INVALID_VERS_OPTION, NSI_S_ENTRY_NOT_FOUND.
    NSI_S_NOTHING_TO_UNEXPORT, NSI_S_NOT_ALL_OBJS_UNEXPORTED,
    NSI_S_INTERFACE_NOT_FOUND, NSI_S_ENTRY_TYPE_MISMATCH
--*/
{
    int                fChanges = FALSE;
    CFullServerEntry * pFSEntry = NULL;
    CEntry           * pDSEntry = NULL;

    // validate
    if (Interface && IsNilIfId(Interface)) Interface = NULL;

    if (!ObjectVector && !Interface)
        Raise(NSI_S_NOTHING_TO_UNEXPORT);

    if (fNT4Compat) {
        pFSEntry = GetEntryFromCache(
            EntryNameSyntax,
            EntryName
            );
        // BUGBUG:: if compat flag is on, should it or not.
        if (!pFSEntry)
            Raise(NSI_S_ENTRY_NOT_FOUND);
    }

    // try getting the entry from the local cache.

    if (fDSEnabled)
       pDSEntry = GetEntryFromDS(
           EntryNameSyntax,
	   EntryName
	   );

    if ((!pDSEntry) && (!fNT4Compat))
        Raise(NSI_S_ENTRY_NOT_FOUND);

    if (fNT4Compat) {
        // if it has got it from the local cache then the type
        // must necessarily be FullServerEntryType.

        CServerEntry * pSEntry;

        if (pFSEntry->getType() != FullServerEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);

        // getting the local part.
        pSEntry = ((CFullServerEntry *) pFSEntry)->getLocal();

        fChanges = pSEntry->remove_from_entry(Interface, VersOption, ObjectVector, pCacheInterfaceIndex);
    }

    if ((pDSEntry) && (pDSEntry->getType() != ServerEntryType))
        // changes made after tests were started on all apns1
        Raise(NSI_S_ENTRY_TYPE_MISMATCH);

    if (pDSEntry)
        ((CServerEntry *)pDSEntry)->remove_changes_from_DS(Interface, VersOption, ObjectVector, fNT4Compat);

    delete pDSEntry;

} // nsi_mgmt_binding_unexport


CLookupHandle *
Locator::nsi_binding_lookup_begin_null(
            CGUIDVersion        * pGVinterface,
            CGUIDVersion        * pGVsyntax,
            CGUID               * pIDobject,
            UNSIGNED32            ulVectorSize,
            UNSIGNED32            MaxCacheAge,
            int                 * fTentativeStatus
            )
/*++

Member Description:

    lookup with a null entry name when the compatibility flag is
    on it first looks in the local cache, and then over the
    network when it is off it makes a lookup by querying in
    the DS. parameters are described in detail in tha actual
    api below.

Returns:
    the lookup handle.
--*/
{
    CLookupHandle       * pDSHandle = NULL;
    CLookupHandle       * pFinalHandle = NULL;

    *fTentativeStatus = NSI_S_OK;

    if (fNT4Compat) {
    /*
       it is important to do the index lookup before the net lookup so as
       to avoid duplication in the results returned.  If the net lookup uses
       a broadcast handle, the initialization will create both a private and a
       public cache (the former to avoid duplication), and the latter will be
       picked up by index lookup if it is done later.
     */

        CLookupHandle *pGLHindex = new CIndexLookupHandle(
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            );
        // lookup based on the interface id and object id in the local
        // data structure.

        CRemoteLookupHandle *prlhNetLookup =  NetLookup(
            RPC_C_NS_SYNTAX_DCE,
            NULL,
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            );

        // looking in other locators by contacting the PDC and broadcast.

        DBGOUT(MEM1,"Creating Complete Broadcast Handle for NULL Entry\n\n");

        pFinalHandle = new CCompleteHandle<NSI_BINDING_VECTOR_T>(
            pGLHindex,
            NULL,
            prlhNetLookup,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            );
    }
    else {
        // DS will necessarily be enabled if the compat flag has to be off.
	// no need to check.

        // searching in the DS. cache parameter is unused currently.
        // there is no cache maintained here.
        pFinalHandle =  new CDSNullLookupHandle(
            pGVinterface,
            pGVsyntax,
            pIDobject,
            ulVectorSize,
            MaxCacheAge? MaxCacheAge: ulMaxCacheAge
            // this is an unused parameter
            );

        DBGOUT(DIRSVC,"Creating Complete Lookup going only to DS Handle for NULL Entry\n\n");
    }
    return pFinalHandle;
}

CLookupHandle *
Locator::nsi_binding_lookup_begin_name(
                UNSIGNED32           EntryNameSyntax,
                STRING_T             EntryName,
                CGUIDVersion       * pGVinterface,
                CGUIDVersion       * pGVsyntax,
                CGUID              * pIDobject,
                UNSIGNED32           ulVectorSize,
                UNSIGNED32           MaxCacheAge,
                LookupType           type,
                int                * fTentativeStatus
               )
/*++
Member Description:

Lookup when the entry name is given.
DS takes precendence in this case even
when the compatibility flag is on.
--*/
{
    CFullServerEntry    * pFSEntry = NULL;
    CLookupHandle       * pDSHandle = NULL;
    CLookupHandle       * pFinalHandle = NULL;

    // if the lookup is made directly to this locator and not through
    // broadcast interface, look in the DS. Do no reply to broadcasts
    // with entries in the DS.
    *fTentativeStatus = NSI_S_OK;

    if ((type == LocalLookup) && (fDSEnabled))
        pDSHandle = DSLookup(
                EntryNameSyntax,
                EntryName,
                pGVinterface,
                pGVsyntax,
                pIDobject,
                ulVectorSize,
                MaxCacheAge? MaxCacheAge: ulMaxCacheAge
                );
    else
        pDSHandle = NULL;

    // if the entry exists in the DS it overides cache and the
    // network lookup

    if (pDSHandle && (((CDSLookupHandle *)pDSHandle)->FoundInDS()))
    {
        // if there was a DS and entry was found in the DS.
        pFinalHandle = pDSHandle;
        *fTentativeStatus = NSI_S_OK;
    }
    else
    {
        delete pDSHandle;

        if (fNT4Compat) {
            // try to see whether the entry exists locally.
            if (EntryName)
                pFSEntry = GetEntryFromCache(
                                        EntryNameSyntax,
                                        EntryName
                                        );

            // if it doesn't, assume that it is a server entry,
            // and do a lookup on that which will in turn do a
            // Broadcast for the entry name.

            if (!pFSEntry) {
                pFSEntry = new CFullServerEntry(EntryName);

                if (!pFSEntry)
                    Raise(NSI_S_OUT_OF_MEMORY);

                pInternalCache->insert(pFSEntry);

                *fTentativeStatus = NSI_S_ENTRY_NOT_FOUND;
                // lookup reply goes into the cache at this point.
                // for the time being put an empty entry into the cache.
            }

            DBGOUT(MEM1,"Creating Complete Handle for " << *pFSEntry << "\n\n");

            pFinalHandle = pFSEntry->lookup(
                                        pGVinterface,
                                        pGVsyntax,
                                        pIDobject,
                                        ulVectorSize,
                                        MaxCacheAge? MaxCacheAge: ulMaxCacheAge
                                        );

            if (*fTentativeStatus == NSI_S_ENTRY_NOT_FOUND) {
                *fTentativeStatus =
                    ((CCompleteHandle<NSI_BINDING_VECTOR_T>*) pFinalHandle)->netStatus();

                if ((*fTentativeStatus == NSI_S_ENTRY_NO_NEW_INFO) && pFSEntry->isEmpty())
                    *fTentativeStatus = NSI_S_ENTRY_NOT_FOUND;
                // Nothing was gained in the broadcast.

                /* BUGBUG:  This guard should really be here but it causes
                    deadlock -- leave out for now.
                    CriticalWriter me(rwEntryGuard);
                */

                if (*fTentativeStatus == NSI_S_ENTRY_NOT_FOUND) {
                    pInternalCache->remove(pFSEntry);
                    delete pFSEntry;
                }
            }
        }
        else
        {
            // do not attempt any broadcasts etc
            *fTentativeStatus = NSI_S_ENTRY_NOT_FOUND;
            pFinalHandle = NULL;
        }
    }
    return pFinalHandle;
}

NSI_NS_HANDLE_T
Locator::nsi_binding_lookup_begin(
    IN  UNSIGNED32           EntryNameSyntax,
    IN  STRING_T             EntryName,
    IN  NSI_INTERFACE_ID_T * Interface, OPT
    IN  NSI_UUID_P_T         Object, OPT
    IN  UNSIGNED32           VectorSize,
    IN  UNSIGNED32           MaxCacheAge,
    IN  LookupType           type
    )
/*++

Member Description:

    Perform a lookup operation, including all available information
    (owned, NonLocal and from the network).

Arguments:

    EntryNameSyntax - Name syntax

    EntryName        - Name string to lookup on.

    Interface        - Interface to search for

    Object           - Object UUID to search for

    VectorSize       - Size of return vector

Returns:

    A context handle for NS lookup.

Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_ENTRY_NOT_FOUND,
    NSI_S_OUT_OF_MEMORY, NSI_S_INVALID_OBJECT

    The broadcast lookup also calls the same handle.
    with the type set to broadcast

--*/
{
    int                   fTentativeStatus = NSI_S_OK;
    CGUIDVersion        * pGVinterface = NULL;
    CGUIDVersion        * pGVsyntax = NULL;
    CGUID               * pIDobject = NULL;
    int                   fDefaultEntry = FALSE;
    CLookupHandle       * pFinalHandle = NULL;

    if (!EntryName)
        fDefaultEntry = TRUE;
    // see whether the entry name is NULL.
    // if the entry name is null then the lookup has to be made based on other attributes.
    // like the interface id, object uuid etc.

    if (Interface && IsNilIfId(&(Interface->Interface))) Interface = NULL;

    __try {

        unsigned long ulVectorSize = (VectorSize) ? VectorSize : RPC_C_BINDING_MAX_COUNT;

        pGVinterface = (Interface)? new CGUIDVersion(Interface->Interface) : NULL;

        pGVsyntax = (Interface)? new CGUIDVersion(Interface->TransferSyntax) : NULL;

        RPC_STATUS dummyStatus;

        pIDobject = (!Object || UuidIsNil(Object,&dummyStatus)) ?
                            NULL : new CGUID(*Object) ;

        if (fDefaultEntry) {
            pFinalHandle = nsi_binding_lookup_begin_null(
                            pGVinterface,
                            pGVsyntax,
                            pIDobject,
                            ulVectorSize,
                            MaxCacheAge,
                            &fTentativeStatus
                            );

        }
        else {
            pFinalHandle = nsi_binding_lookup_begin_name(
                            EntryNameSyntax,
                            EntryName,
                            pGVinterface,
                            pGVsyntax,
                            pIDobject,
                            ulVectorSize,
                            MaxCacheAge,
                            type,
                            &fTentativeStatus
                            );

        }
    }

    __finally {

        delete pGVinterface;
        delete pGVsyntax;
        delete pIDobject;

    }

    if (fTentativeStatus != NSI_S_OK) {
        delete pFinalHandle;
        Raise(fTentativeStatus);
    }

    return (NSI_NS_HANDLE_T) pFinalHandle;
}



/* Note that there is no such thing as an object inquiry in the default entry */

NSI_NS_HANDLE_T
Locator::nsi_entry_object_inq_begin(
        UNSIGNED32          EntryNameSyntax,
        STRING_T            EntryName,
        LookupType          type
    )
/*++

Member Description:

    Perform an object inquiry, including all available information
    (owned, NonLocal and from the network).

Arguments:

    EntryNameSyntax  - Name syntax

    EntryName        - Name string to lookup on.

Returns:

    A context handle.

Exceptions:

    NSI_S_UNSUPPORTED_NAME_SYNTAX, NSI_S_INCOMPLETE_NAME, NSI_S_OUT_OF_MEMORY
--*/
{
    int                fFromDS = FALSE;
    CEntry           * pEntry = NULL;

    if (type == LocalLookup)
    {
        if (fDSEnabled)
	   pEntry = GetEntryFromDS(
                        EntryNameSyntax,
                        EntryName
                        );

        if (pEntry)
            fFromDS = TRUE;

        if ((pEntry) && (pEntry->getType() != ServerEntryType))
        {
            delete pEntry;
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
        }
    }

    if ((fNT4Compat) && (!pEntry)) {
        pEntry = GetEntryFromCache(
                        EntryNameSyntax,
                        EntryName
                        );

        if (!pEntry) {
            // if nothing was found in the DS for whatever reasons,
            // prepare for a broadcast.
            pEntry = new CFullServerEntry(EntryName);

            if (!pEntry)
                Raise(NSI_S_OUT_OF_MEMORY);

            pInternalCache->insert((CFullServerEntry *)pEntry);
            /* BUGBUG: in the following statement, we are assuming a server entry whereas
               the real entry may be a group or profile entry.  However, direct caching as
               a server entry is adequate for now.
             */
        }
    }

    if (!pEntry)
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CObjectInqHandle * InqContext = pEntry->objectInquiry(ulMaxCacheAge);

    if (fFromDS)
        delete pEntry;

    return (NSI_NS_HANDLE_T) InqContext;
}

void
Locator::nsi_group_mbr_add(
        IN UNSIGNED32       group_name_syntax,
        IN STRING_T         group_name,
        IN UNSIGNED32       member_name_syntax,
        IN STRING_T         member_name
    )
{

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
        Raise(NSI_S_GRP_ELT_NOT_ADDED);


    DBGOUT(API, "\nAdd to: " << group_name);
    DBGOUT(API, " Group Member:" << member_name);

    CEntry *pEntry = GetEntryFromDS(
        group_name_syntax,
        group_name
        );

    // getting the entry from the DS and making sure
    // that it is a group entry.
    if (pEntry)
    {
        if (pEntry->getType() != GroupEntryType)
        {
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
        }
    }
    else
    {
        // if not found creat a new entry.
        pEntry = new CGroupEntry(group_name);
        CGroupEntry *pGroup = (CGroupEntry*) pEntry;
    }

    CGroupEntry *pGroup = (CGroupEntry*) pEntry;
    // add the changes to the DS.
    pGroup->AddMember(member_name);
    delete pEntry;
}

void
Locator::nsi_group_mbr_remove(
        IN UNSIGNED32       group_name_syntax,
        IN STRING_T         group_name,
        IN UNSIGNED32       member_name_syntax,
        IN STRING_T         member_name
        )
{

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
       Raise(NSI_S_GRP_ELT_NOT_REMOVED);

    DBGOUT(API, "\nRemove from: " << group_name);
    DBGOUT(API, " Group Member:" << member_name);

    // getting the entry from the DS and making sure
    // that it is a group entry.
    CEntry *pEntry = GetEntryFromDS(
        group_name_syntax,
        group_name
        );

    if (pEntry)
    {
        // if not found create a new entry.
        if (pEntry->getType() != GroupEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CGroupEntry *pGroup = (CGroupEntry*) pEntry;
    // remove the changes from the DS.
    pGroup->RemoveMember(member_name);
    delete pEntry;
}


NSI_NS_HANDLE_T
Locator::nsi_group_mbr_inq_begin(
        IN UNSIGNED32       group_name_syntax,
        IN STRING_T         group_name,
        IN UNSIGNED32       member_name_syntax
        )
{
    CEntry            *pEntry = NULL;

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    DBGOUT(API, "\nnsi_group_mbr_inq_begin: " << group_name);

    if (fDSEnabled)
       pEntry = GetEntryFromDS(
                            group_name_syntax,
                            group_name
                            );

    if (pEntry) {
        if (pEntry->getType() != GroupEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CGroupEntry *pGroupEntry = (CGroupEntry*) pEntry;
    CGroupInqHandle * InqContext = pGroupEntry->GroupMbrInquiry();

    // deleted by the handle
    return (NSI_NS_HANDLE_T) InqContext;
}


void
Locator::nsi_profile_elt_add(
        IN UNSIGNED32       profile_name_syntax,
        IN STRING_T         profile_name,
        IN NSI_IF_ID_P_T    if_id,
        IN UNSIGNED32       member_name_syntax,
        IN STRING_T         member_name,
        IN UNSIGNED32       priority,
        IN STRING_T         annotation
    )

{
    HRESULT            hr = S_OK;

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
        Raise(NSI_S_PRF_ELT_NOT_ADDED);

    if (annotation == NULL)
        annotation = L"";

    DBGOUT(API, "\nAdd to: " << profile_name);
    DBGOUT(API, " Profile Member:" << member_name);
    if (if_id) DBGOUT(API, " Interface:" << if_id << "\n");
    DBGOUT(API, "Priority:" << priority);
    DBGOUT(API, " Annotation:" << annotation << "\n\n");

    CEntry *pEntry = GetEntryFromDS(
        profile_name_syntax,
        profile_name
        );

    if (pEntry)
    {
        if (pEntry->getType() != ProfileEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
    {
        pEntry = new CProfileEntry(profile_name);
        CProfileEntry *pProfile = (CProfileEntry*) pEntry;
        hr = pProfile->AddToDS();
        if (FAILED(hr)) {
           DWORD dwErr = RemapErrorCode(hr);
           if (dwErr == NSI_S_INTERNAL_ERROR)
               Raise(NSI_S_PROFILE_NOT_ADDED);
           else
               Raise(dwErr);
        }

        // creating a new profile entry in the DS.
    }

    CProfileEntry *pProfile = (CProfileEntry*) pEntry;

    pProfile->AddElement(
        if_id,
        member_name,
        priority,
        annotation
        );
    // reflecting the changes in the element in the DS.
    delete pEntry;
}


void
Locator::nsi_profile_elt_remove(
            IN UNSIGNED32       profile_name_syntax,
            IN STRING_T         profile_name,
            IN NSI_IF_ID_P_T    if_id,
            IN UNSIGNED32       member_name_syntax,
            IN STRING_T         member_name
            )
{

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!member_name)
        Raise(NSI_S_INCOMPLETE_NAME);

    if (!fDSEnabled)
       Raise(NSI_S_PRF_ELT_NOT_REMOVED);

    DBGOUT(API, "\nRemove From: " << profile_name);
    DBGOUT(API, " Profile Member:" << member_name);
    DBGOUT(API, " Interface:" << if_id << "\n");

    CEntry *pEntry = GetEntryFromDS(
        profile_name_syntax,
        profile_name
        );
    if (pEntry)
    {
        if (pEntry->getType() != ProfileEntryType)
            Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
        Raise(NSI_S_ENTRY_NOT_FOUND);

    CProfileEntry *pProfile = (CProfileEntry*) pEntry;
    pProfile->RemoveElement(if_id,member_name);
    // removing the element from the DS.
    delete pEntry;
}



NSI_NS_HANDLE_T
Locator::nsi_profile_elt_inq_begin(
            IN UNSIGNED32       profile_name_syntax,
            IN STRING_T         profile_name,
            IN UNSIGNED32       inquiry_type,
            IN NSI_IF_ID_P_T    if_id,
            IN UNSIGNED32       vers_option,
            IN UNSIGNED32       member_name_syntax,
            IN STRING_T         member_name
            )
{
    CEntry            *pEntry = NULL;

    if (member_name_syntax != RPC_C_NS_SYNTAX_DCE)
       Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (if_id && IsNilIfId(if_id)) if_id = NULL;

    DBGOUT(API, "\nInquire From: " << profile_name);
    DBGOUT(API, " Member Name:" << member_name);
    DBGOUT(API, " Interface:" << if_id << "\n");


    if (fDSEnabled)
       pEntry = GetEntryFromDS(
                        profile_name_syntax,
                        profile_name
                        );

    if (pEntry)
    {
       if (pEntry->getType() != ProfileEntryType)
      Raise(NSI_S_ENTRY_TYPE_MISMATCH);
    }
    else
       Raise(NSI_S_ENTRY_NOT_FOUND);

    CProfileEntry *pProfile = (CProfileEntry*) pEntry;

    return pProfile->ProfileEltInquiry(
                                inquiry_type,
                                if_id,
                                vers_option,
                                member_name
                                );
    // deleted by the handle
}


void
Locator::nsi_mgmt_entry_delete(
         UNSIGNED32     entry_name_syntax,
         STRING_T       entry_name,
         EntryType      entry_type
         )
{
    HRESULT      hr = S_OK;
    CEntry     * pEntry = NULL;

    if (fNT4Compat)
        pEntry = GetEntryFromCache(
        entry_name_syntax,
        entry_name
        );

    if (pEntry) {
        ASSERT(pEntry->getType() == FullServerEntryType,
            "Cache Entry is not full server entry\n");
        pInternalCache->remove((CFullServerEntry *)pEntry);
        // have to remove the interfaces from the interface index list
        // IfIndex->remove(pEntry, *);
        pCacheInterfaceIndex->removeServerEntry(((CFullServerEntry *)pEntry)->getLocal());
        pCacheInterfaceIndex->removeServerEntry(((CFullServerEntry *)pEntry)->getNonLocal());
    }

    // if it exists in the local copy, delete it.

    delete pEntry;

    pEntry = NULL;

    if (fDSEnabled)
       pEntry = GetEntryFromDS(
            RPC_C_NS_SYNTAX_DCE,
            entry_name
            );

    if (!pEntry)
        Raise(NSI_S_ENTRY_NOT_FOUND);

    hr = pEntry->DeleteFromDS();
    // This will raise not an rpc entry
    delete pEntry;

    // mapping error codes.
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            Raise(NSI_S_ENTRY_NOT_FOUND);

        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            Raise(NSI_S_NO_NS_PRIVILEGE);

        Raise(NSI_S_NAME_SERVICE_UNAVAILABLE);
    }
}


void
Locator::nsi_mgmt_entry_create(
         UNSIGNED32     entry_name_syntax,
         STRING_T       entry_name
         )
{
    HRESULT     hr = S_OK;

    if (entry_name_syntax != RPC_C_NS_SYNTAX_DCE)
        Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

    if (!fDSEnabled)
       Raise(NSI_S_NAME_SERVICE_UNAVAILABLE);

    CEntryName *pEntryName = new CEntryName(entry_name);

    hr = CreateEntryInDS(pEntryName);

    delete pEntryName;

    // mapping error codes.
    if (FAILED(hr))
    {
        if ((hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) ||
               (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)))
            Raise(NSI_S_ENTRY_ALREADY_EXISTS);

        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            Raise(NSI_S_NO_NS_PRIVILEGE);

        Raise(NSI_S_NAME_SERVICE_UNAVAILABLE);
    }
    return;
}

void
Locator::nsi_group_delete(
    /* [in] */ UNSIGNED32 group_name_syntax,
    /* [in] */ STRING_T group_name
    )
{
/*   nsi_mgmt_entry_delete(
          group_name_syntax,
          group_name,
          GroupEntryType);
          */

}

void
Locator::nsi_profile_delete(
    /* [in] */ UNSIGNED32 profile_name_syntax,
    /* [in] */ STRING_T profile_name
    )
{
/*   nsi_mgmt_entry_delete(
          profile_name_syntax,
          profile_name,
          ProfileEntryType);
          */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\nt4confg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    nt4confg.c


Abstract:

     this file provides the routine GetSystemType
     that returns an identifier for the system type
     i.e. NT on wrkgrp, domain or lMnt BDC, PDC.

Author:

    Michael Montague (mikemon) 18-Dec-1991
    Rearranged and modified the Lsa part. ushaji 3 Dec 97

Revision History:

--*/

#undef ASSERT

#include <locator.hxx>
#include <lmcons.h>     // LAN Manager basic definitions
#include <lmserver.h>   // NetServerEnum etc
#include <lmwksta.h>    // NetWkstaGetInfo etc
#include <lmaccess.h>   // NetGetDCName etc

void
Locator::InitializeDomainBasedLocator()
/*++
Member Description:

    Initialize the domain locator.  The list of masters is initialized to
    hold names of all BDCs.  The name of the PDC has already been initialized.

--*/
{
    if ((Role == Master) || (Role == Backup))

        pAllMasters = new TGSLString;    // DC locators don't use BDCs as masters

    else pAllMasters = EnumDCs(pDomainName,SV_TYPE_DOMAIN_BAKCTRL,100);
}


void
Locator::InitializeWorkgroupBasedLocator()
/*++
Member Description:

    Initialize the workgroup locator.  No masters are known to start with.

--*/
{
    pAllMasters = new TGSLString;   // initialize with empty list, and add
                                    // potential masters in QueryProcess

    Role = Backup;                  // always ready to serve, if called upon to do so
}




TGSLString *
Locator::EnumDCs(
             CStringW * pDomainName,
             DWORD ServerType,
             long lNumWanted
             )
/*++
Member Description:

    This is a static private helper operation for enumerating servers of
    a given type in a given domain.

Arguments:

    pDomainName - the Unicode string name of the domain

    ServerType - the mask bits defining server types of interest

    lNumWanted - the number of servers to ask for; it seems a good
                 idea to ask for a lot (say 100) to make sure you get all
                 because NetServerEnum can be stingy with names

Returns:

    A Guarded Skiplist of string names.

--*/
{
    char errmsg[1000];

    DWORD EntriesRead, TotalEntries, ResumeHandle;

    SERVER_INFO_100 * buffer;

    SetSvcStatus();

    NET_API_STATUS NetStatus = NetServerEnum (
                    NULL,    // local
                    100,     // info level
                    (LPBYTE *) &buffer,
                    lNumWanted*sizeof(SERVER_INFO_100),
                    &EntriesRead,
                    &TotalEntries,
                    ServerType,
                    *pDomainName,    // auto conversion to STRING_T
                    &ResumeHandle
                    );

    TGSLString *pResult = new TGSLString;

    if ((NetStatus == NO_ERROR) || (NetStatus == ERROR_MORE_DATA)) {

        for (DWORD i = 0; i < EntriesRead; i++) {
            pResult->insert(new CStringW(buffer->sv100_name));
            buffer++;
        }
    }
    else
    {
        sprintf(errmsg, "NetServerEnum Failed, DomainName %S, lNumWanted %l\n", STRING_T(pDomainName),
                                            lNumWanted);
        StopLocator(
                errmsg,
                NSI_S_INTERNAL_ERROR
                );
    }
    return pResult;
}

BOOL
Locator::SetRoleAndSystemType(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole)

/*

   Determine if we [locator] are being run on a Workgroup machine
   or a member machine or a PDC or a BDC
*/

{
  Role = Client;
  BOOL fSuccess = TRUE;

  switch (dsrole.MachineRole)
  {
       case DsRole_RoleStandaloneWorkstation:
       case DsRole_RoleStandaloneServer:
           System = Workgroup;
           Role = Backup;
           break;

       case DsRole_RoleMemberWorkstation:
           System = Domain;
           Role = Client;
           break;

       case DsRole_RoleMemberServer:
           System = Domain;
           Role = Backup;
           break;
           
       case DsRole_RoleBackupDomainController:
           System = Domain;
           Role = Backup;
           break;

       case DsRole_RolePrimaryDomainController:
           System = Domain;
           Role = Master;
           break;
       default:
           System = Workgroup;
           Role = Backup;   // this is the most adaptive configuration.
           fSuccess = FALSE;
  }
  return fSuccess;
}

void Locator::SetCompatConfigInfo(DSROLE_PRIMARY_DOMAIN_INFO_BASIC dsrole)
{
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD sz = MAX_COMPUTERNAME_LENGTH + 1;

    SetSvcStatus();

    pCacheInterfaceIndex = new CInterfaceIndex(this);
    pInternalCache = new TGSLEntryList;
    psllBroadcastHistory = new TSLLBroadcastQP;
    ulMaxCacheAge = MAX_CACHE_AGE;
    fDCsAreDown = FALSE;

    SetSvcStatus();

    hMailslotForReplies = new READ_MAIL_SLOT(PMAILNAME_C, sizeof(QueryReply));

    SetSvcStatus();

    hMasterFinderSlot = new READ_MAIL_SLOT(RESPONDERMSLOT_C, sizeof(QueryReply));

    if (!GetComputerName(szComputerName, &sz))
        Raise(NSI_S_INTERNAL_ERROR);

    pComputerName = new CStringW(szComputerName);

    if (!SetRoleAndSystemType(dsrole))
        StopLocator(
            "Failed to determine system type",
            NSI_S_INTERNAL_ERROR
            );

    switch (System) {

    case Domain:
        LPBYTE DCnameBuffer;
        NET_API_STATUS NetStatus;

        SetSvcStatus();

        NetStatus = NetGetDCName(NULL,NULL,&DCnameBuffer);

        if ((NetStatus == NO_ERROR) || (NetStatus == ERROR_MORE_DATA)) {
            pPrimaryDCName = new CStringW(((STRING_T) DCnameBuffer) + 2);  // skip over "\\"
            InitializeDomainBasedLocator();
        }
        else {    // in the absence of a PDC, we pretend to be in a workgroup
            pPrimaryDCName = NULL;
            System = Workgroup;
            InitializeWorkgroupBasedLocator();
        }
        break;

    case Workgroup:
        pPrimaryDCName = NULL;
        InitializeWorkgroupBasedLocator();
        break;

    default:
        StopLocator(
            "Unknown system type",
            NSI_S_INTERNAL_ERROR
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\mailslot.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    mailslot.cxx

Abstract:

    This file contains the implementations for non inline member functions
    of WRITE_MAIL_SLOT and READ_MAIL_SLOT, which are classes used for
    wrapping NT mailslot functionality.

Author:

    Satish Thatte (SatishT) 10/1/95  Created all the code below except where
                                      otherwise indicated.

--*/

#define NULL 0

#include <locator.hxx>


WRITE_MAIL_SLOT::WRITE_MAIL_SLOT(
    IN STRING_T Target,
    IN STRING_T MailSlot
    )
/*++

Routine Description:

    open an existing NT MailSlot for writing.

Arguments:

    MailSlot - name of the WRITE_MAIL_SLOT

    Target - the workstation/domain to write to
--*/
{
    STRING_T SlotName;

    hWriteHandle = NULL;

    // STRING_T TargetPart;

    if (!Target)     // this should only happen for broadcasts
        SlotName = catenate(TEXT("\\\\*"),MailSlot);

    else SlotName = catenate(Target,MailSlot);

    hWriteHandle = CreateFile(
                        SlotName,
                        GENERIC_WRITE, // | SYNCHRONIZE,  don't know if this is needed
                        FILE_SHARE_WRITE,
                        NULL,                // BUGBUG: punting on security
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (INVALID_HANDLE_VALUE == hWriteHandle) {
        hWriteHandle = NULL;
        DBGOUT(BROADCAST, "CreateFile for Mailslot" << SlotName <<  "returned" << GetLastError() << "\n");
        delete [] SlotName;
//        Raise(NSI_S_MAILSLOT_ERROR);  // no point in raisin an exception in a released prod.
    }

    else delete [] SlotName;

}


WRITE_MAIL_SLOT::~WRITE_MAIL_SLOT(
    )
/*++

Routine Description:

    Deallocate a WRITE_MAIL_SLOT.

--*/
{
    if (hWriteHandle) CloseHandle(hWriteHandle);
}


DWORD
WRITE_MAIL_SLOT::Write(
    IN char * lpBuffer,
    IN DWORD nNumberOfBytesToWrite
    )
/*++

Routine Description:

    Write data to a mailslot.   
    
    The following may not be true at the moment:

    The mailslot is created with sync attributes,
    so there is no need to wait for the operation.

Arguments:

    lpBuffer - buffer to write.

    nNumberOfBytesToWrite - size of buffer to write.

Returns:

    Number of bytes written if write went OK. FALSE, otherwise.

--*/
{

    DWORD NumberOfBytesWritten;

    if (!hWriteHandle)
        return FALSE;

    BOOL result = WriteFile(
                    hWriteHandle,            // handle of file to write to 
                    (LPCVOID) lpBuffer,        // address of data to write to file 
                    nNumberOfBytesToWrite,    // number of bytes to write 
                    &NumberOfBytesWritten,    // address of number of bytes written 
                    NULL
                    );

    if (result) return NumberOfBytesWritten;
    else return FALSE;
}



READ_MAIL_SLOT::READ_MAIL_SLOT(
    IN STRING_T MailSlot,
    IN DWORD nMaxMessageSize
    )
/*++

Routine Description:

    Create an NT mailslot.

Arguments:

    MailSlot - name of the READ_MAIL_SLOT

    nMaxMessageSize - the size of buffer to allocate for reads.

--*/
{
    STRING_T SlotName;

    Size = nMaxMessageSize;   // max buffer size for reads
    hReadHandle = NULL;

    // Form the name of the READ_MAIL_SLOT.

    SlotName = catenate(TEXT("\\\\."), MailSlot);

    hReadHandle = 
        CreateMailslot(
                SlotName,
                nMaxMessageSize,    // maximum message size
                NET_REPLY_INITIAL_TIMEOUT,    // milliseconds before read time-out
                NULL     // address of security structure
                );

    if (INVALID_HANDLE_VALUE == hReadHandle) {
        hReadHandle = NULL;
        DBGOUT(BROADCAST, "CreateFile for Mailslot" << SlotName <<  "returned " << GetLastError() << "\n");
        delete [] SlotName;
//        Raise(NSI_S_MAILSLOT_ERROR);  // no point in raisin an exception in a released prod.
    }

    else delete [] SlotName;
}


READ_MAIL_SLOT::~READ_MAIL_SLOT(
    )
/*++

Routine Description:

    Deallocate a READ_MAIL_SLOT.

--*/
{
    if (hReadHandle) CloseHandle(hReadHandle);
}



DWORD
READ_MAIL_SLOT::Read(
    IN OUT char * lpBuffer,    // info is filled in hence also OUT
    IN DWORD dwBufferSize,
    IN DWORD dwReadTimeout
    )
/*++

Routine Description:

    Read data from a mailslot.  The mailslot is created with async
    atrributes so that the read can be timed out.

Arguments:

    lpBuffer - buffer to read data into

    dwBufferSize - the size of the buffer

    dwReadTimeout - time to wait for a response.

Returns:

    Number of bytes actually read.

--*/
{
    if (!hReadHandle)
        return FALSE;

    DBGOUT(BROADCAST, "Before Entering critical section of Read\n");
    SerializeReaders.Enter();

    BOOL success = SetMailslotInfo(
                            hReadHandle,
                            dwReadTimeout
                            );    

    if (!success) {
        SerializeReaders.Leave();
        return FALSE;
    }

    DWORD NumberOfBytesRead;

    DBGOUT(BROADCAST, "Entered Critical section\n");

    BOOL result = ReadFile(
                    hReadHandle,    // handle of file to write to 
                    lpBuffer,        // address of data buffer for reading
                    dwBufferSize,    // number of bytes to read 
                    &NumberOfBytesRead,    // address of number of bytes read 
                    NULL            // no overlapping
                    );
    DBGOUT(BROADCAST, "Read Data\n");

    SerializeReaders.Leave();

    if (result) return NumberOfBytesRead;
    else return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\mutex.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    mutex.cxx

Abstract:

    This file contains the implementations for non inline member functions of
	CReadWriteSection and CPrivateSemaphore, which implement a readers/writers
	mutex and a multi-owner mutex, respectively.

Author:

    Satish Thatte (SatishT) 09/01/95  Created all the code below except where
									  otherwise indicated.

--*/

#define NULL 0

#include <locator.hxx>


int
CReadWriteSection::readerEnter()

/*++

Routine Description:

	Reader may enter if no writer is in the section or waiting to enter it.
	Readers keep count of themselves and when the count drops to zero
	they release PSemWriterBlock so writers may enter.

Results:

    Count of current readers.

--*/

{
	/* wait for writer if one is in or waiting, otherwise
	   bump up reader count and block writer if first reader */

	DBGOUT(SEM, "Entering readerEnter\n");

	SimpleCriticalSection me1(PCSReaderBlock);

	SimpleCriticalSection me2(PCSCountBlock);

	DBGOUT(SEM, "ulReaderCount = " << ulReaderCount << "\n"); 

	if (ulReaderCount++);			// other readers already in
	else PSemWriterBlock.Enter();		// otherwise, block writer's entry

	DBGOUT(SEM, "Leaving readerEnter\n");
	DBGOUT(SEM, "ulReaderCount = " << ulReaderCount << "\n"); 

	return ulReaderCount;
}


int
CReadWriteSection::readerLeave()

/*++

Routine Description:

	A reader leaves, decrementing the ulReaderCount and releasing PSemWriterBlock
	if appropriate.

Results:

    Count of current readers as seen during count update.

--*/

{
	DBGOUT(SEM, "Entering readerLeave\n");
	DBGOUT(SEM, "ulReaderCount = " << ulReaderCount << "\n"); 

	SimpleCriticalSection me(PCSCountBlock);

	if (--ulReaderCount);			// other readers still in
	else PSemWriterBlock.Leave();		// otherwise, release writer's entry

	return ulReaderCount;
}
 


CPrivateSemaphore::CPrivateSemaphore(
							long lMaxCount
							) 
/*++

Routine Description:

    create a semaphore and initialize the handle member pNTSem.

--*/
{
	// DBGOUT(SEM, "Creating Semaphore with counts =" << lMaxCount << "\n");
	
	pNTSem = CreateSemaphore(
							NULL,		// pointer to security attributes 
							lMaxCount,	// initial count 
							lMaxCount,	// maximum count 
							NULL	 	// pointer to semaphore-object name  
							);
}



CPrivateSemaphore::~CPrivateSemaphore() 
/*++

Routine Description:

    close the semaphore handle.

--*/
{
	CloseHandle(pNTSem);
}


void
CPrivateSemaphore::Enter() 
/*++

Routine Description:

    Wait for the semaphore count to become nonzero.

--*/
{
	WaitForSingleObject(pNTSem,INFINITE);
}


void
CPrivateSemaphore::Leave(long lIncrement) 
/*++

Routine Description:

    Increment the semaphore count by lIncrement to release lIncrement "slots".

--*/
{
	DBGOUT(SEM1, "Releasing Semaphore with Increment =" << lIncrement << "\n");

	ReleaseSemaphore(pNTSem,lIncrement,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\master.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    master.cxx

Abstract:

    This file contains the implementations for non inline member functions
    of CMasterLookupHandle and CMasterObjectInqHandle, which are classes used for
    interaction with a master locator for looking up binding handles and objects.

Things to improve in future revisions:

 1. The structure of the locator-to-locator RPC interface needs a complete redesign.
    The query to a master locator should be for a complete entry, not piecemeal
    and painfully repetitive as it is now.

 2. There is a suspicion that client locators don't release all the lookup handles
    they get from a master locator (about 1 in 200 in a random test), probably in
    exceptional circumstances.  This needs to be fixed if true.

Author:

    Satish Thatte (SatishT) 10/1/95  Created all the code below except where
                                      otherwise indicated.

--*/

#include <locator.hxx>


#if DBG
    ULONG CMasterLookupHandle::ulMasterLookupHandleCount = 0;
    ULONG CMasterLookupHandle::ulMasterLookupHandleNo = 0;
#endif

NSI_UUID_VECTOR_P_T
getObjectVector(
    IN RPC_BINDING_HANDLE hCurrentMaster,
    IN UNSIGNED32 EntryNameSyntax,
    IN STRING_T EntryName,
    OUT ULONG& StatusCode
    )
/*++

Routine Description:

    Broadcasts for the requested binding handles.

Arguments:

    hCurrentMaster        - the binding handle for the master locator

    EntryNameSyntax        - syntax of entry name

    EntryName            - entry name for object query

    StatusCode            - status of query returned here

Returns:

    A standard UUID vector containing the object UUIDs returned by the
    master locator.

--*/
{
    STATUS Status;

    NSI_UUID_VECTOR_P_T pUuidVector = NULL;

    HANDLE hObjectHandle = NULL;

//    RpcImpersonateClient(0);

    RpcTryExcept {

        CLIENT_I_nsi_entry_object_inq_begin(
              hCurrentMaster,
              EntryNameSyntax,
              EntryName,
              &hObjectHandle,
              &Status
              );
    }
    RpcExcept (EXCEPTION_EXECUTE_HANDLER) {
        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;

        StatusCode = RpcExceptionCode();

        if (StatusCode == RPC_S_ACCESS_DENIED)
            StatusCode = NSI_S_NO_NS_PRIVILEGE;

//        RpcRevertToSelf();
        return NULL;
    }
    RpcEndExcept;

    if ((StatusCode = Status) != NSI_S_OK) return NULL;

    CLIENT_I_nsi_entry_object_inq_next(
               hCurrentMaster,
               hObjectHandle,
               &pUuidVector,
               &Status
               );

    StatusCode = Status;

    CLIENT_I_nsi_entry_object_inq_done(
                       &hObjectHandle,
                       &Status
                       );

    StatusCode = Status;

//    RpcRevertToSelf();

    return pUuidVector;
}




void
CMasterLookupHandle::initialize()
/*++

Method Description:

    Establishes contact with the master locator and acquires a context handle
    for the lookup parameters stored as members in this object.

Remarks:

    The reason for separating initialization as a method separate from the
    constructor is that "lookupIfNecessary" may force reinitialization if
    the information is too stale.  This can happen if the user resets the
    expiration age for a specific context handle.

--*/
{
    DBGOUT(TRACE,"CMasterLookupHandle::initialize called for Handle#" << ulHandleNo << "\n\n");

    StatusCode = NSI_S_OK;

    RPC_SYNTAX_IDENTIFIER interfaceID;

    if (pgvInterface) interfaceID =    *pgvInterface;

    RPC_SYNTAX_IDENTIFIER xferSyntaxID;

    if (pgvTransferSyntax) xferSyntaxID = *pgvTransferSyntax;

    NSI_UUID_T objID;

    if (pidObject) objID = pidObject->myGUID();

    UNSIGNED16 status = 0;

    if (RpcMgmtSetCancelTimeout(CONNECTION_TIMEOUT) != RPC_S_OK)
        {
        StatusCode = NSI_S_OUT_OF_MEMORY;
        return;
        }

    DBGOUT(TRACE, "Connecting to Master Locator\n");

    hCurrentMaster = ConnectToMasterLocator(
                            StatusCode
                            );


    if (!hCurrentMaster || StatusCode) {
        StatusCode = NSI_S_NAME_SERVICE_UNAVAILABLE;
        myRpcLocator->SetDCsDown();

        return;
    }
    else myRpcLocator->SetDCsUp();

//    RpcImpersonateClient(0);

    lookupHandle = NULL;

    /* The following is a work around, because the compiler refuses to accept

           penEntryName ? (*penEntryName) : NULL

    */

    STRING_T szEntryName = NULL;
    if (penEntryName) szEntryName = *penEntryName;

    DBGOUT(TRACE, "Lookup begin called for master locator\n");
    RpcTryExcept {
        CLIENT_I_nsi_lookup_begin(
                hCurrentMaster,
                u32EntryNameSyntax,
                szEntryName,
                pgvInterface? &interfaceID : NULL,
                pgvTransferSyntax? &xferSyntaxID : NULL,
                pidObject? &objID : NULL,
                ulVS,
                ulCacheMax? ulCacheMax: ulCacheMax+CACHE_GRACE, // ensures that it is nonzero
                &lookupHandle,    // the above is wierd but necessary because ulCacheAge is frequently -1
                &status
                );
    }
    RpcExcept (EXCEPTION_EXECUTE_HANDLER) {

        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;

        StatusCode = RpcExceptionCode();

        if (StatusCode == RPC_S_ACCESS_DENIED)
            StatusCode = NSI_S_NO_NS_PRIVILEGE;

         // this is a copout to take care of NT vs NSI code conflicts

        else if (StatusCode < NSI_S_STATUS_MAX)
            StatusCode = NSI_S_NAME_SERVICE_UNAVAILABLE;

//        RpcRevertToSelf();
        return;
    }
    RpcEndExcept;

//    RpcRevertToSelf();

    StatusCode = status;    // hopefully, RPC_S_OK;

    fFinished = FALSE;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}



BOOL
CMasterLookupHandle::fetchNext()
/*++

Method Description:

    Fetches the next vector of binding handles from the master locator, along
    with associated object UUIDs.

Remarks:

    The process is inefficient in that each binding handle returned has an
    entry name associated with it and we must make a full fledged object query
    for every binding handle.  This is extremely expensive but the current structure
    of the locator-to-locator interface forces it upon us.

--*/
{
    DBGOUT(TRACE,"CMasterLookupHandle::fetchNext called for Handle#" << ulHandleNo << "\n\n");

    STATUS status;

    /* We only want to run down the info acquired in the last fetchNext.
       A full-scale rundown of the handle would also give up the context
       handle and binding to the master locator, which would ruin us.
       The only thing we have to fix is to reset the fNotInitialzed flag,
       so that we don't call initialize() again on this handle.
    */

    CRemoteLookupHandle::rundown();
    fNotInitialized = FALSE;

    psslNewCache = new TSSLEntryList;

    NSI_BINDING_VECTOR_T * pNextVector = NULL;

//    RpcImpersonateClient(0);

    RpcTryExcept {

        CLIENT_I_nsi_lookup_next(
                            hCurrentMaster,
                            lookupHandle,
                            &pNextVector,
                            &status
                            );
        }
    RpcExcept (EXCEPTION_EXECUTE_HANDLER) {

        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;

        StatusCode = RpcExceptionCode();

        if (StatusCode == RPC_S_ACCESS_DENIED)
            StatusCode = NSI_S_NO_NS_PRIVILEGE;

//        RpcRevertToSelf();
        return FALSE;
    }
    RpcEndExcept;

//    RpcRevertToSelf();

    StatusCode = status;

    if (status == NSI_S_NO_MORE_BINDINGS) return FALSE;

    else if (status != NSI_S_OK) Raise(status);

    else {

        NSI_UUID_VECTOR_P_T pUuidVector;

         for (unsigned int i = 0; i < pNextVector->count; i++)
           {

               pUuidVector = getObjectVector(
                                    hCurrentMaster,
                                    pNextVector->binding[i].entry_name_syntax,
                                    pNextVector->binding[i].entry_name,
                                    StatusCode
                                    );

              /* first update the central cache and, if there is anything new,
                 also update the temporary cache in psslNewCache
              */

               CGUIDVersion nullGV;    // standard initialization to null


               myRpcLocator->UpdateCache(
                          pNextVector->binding[i].entry_name,
                          pNextVector->binding[i].entry_name_syntax,
                          pgvInterface ? *pgvInterface : nullGV,
                          pgvTransferSyntax ? *pgvTransferSyntax : nullGV,
                          pNextVector->binding[i].string,
                          pUuidVector,
                          psslNewCache
                          );

               midl_user_free(pNextVector->binding[i].entry_name);
               midl_user_free(pNextVector->binding[i].string);

               if (pUuidVector) {
                   for (unsigned int j = 0; j < pUuidVector->count; j++)
                          midl_user_free(pUuidVector->uuid[j]);

                   midl_user_free(pUuidVector);
               }

               pUuidVector = NULL;
         }

         midl_user_free(pNextVector);
    }

    TEntryIterator *pCacheIter = new TSSLEntryListIterator(*psslNewCache);

    plhFetched = new CGroupLookupHandle(
                                    pCacheIter,
                                    pgvInterface,
                                    pgvTransferSyntax,
                                    pidObject,
                                    ulVS,
                                    ulCacheMax
                                    );

    /* do not delete psslNewCache -- it is done by the constructor above */

    return TRUE;
}


void
CMasterLookupHandle::rundown()
/*++

Method Description:

    Release the binding to the master and the context handle received from the master.

Remarks:

    The reason to separate this from the destructor is similar to the case of
    initialize(), i.e., finalization may happen due to reinitialization rather than
    destruction.

--*/{

    DBGOUT(TRACE,"CMasterLookupHandle::rundown called for Handle#" << ulHandleNo << "\n\n");

    STATUS status;

    // First do the standard rundown for remote handles

    CRemoteLookupHandle::rundown();

    //  Then try closing lookupHandle in master locator

    if (hCurrentMaster) {

//        RpcImpersonateClient(0);

        RpcTryExcept {

            CLIENT_I_nsi_lookup_done(
                                hCurrentMaster,
                                &lookupHandle,
                                &status
                                );

        }
        RpcExcept (EXCEPTION_EXECUTE_HANDLER) {
            DBGOUT(MEM1,"Could not close lookup handle in master\n\n");
        }
        RpcEndExcept;

        RpcBindingFree(&hCurrentMaster);
        hCurrentMaster = NULL;
//         RpcRevertToSelf();
    }

}




CMasterObjectInqHandle::CMasterObjectInqHandle(
        STRING_T szEntryName,
        ULONG ulCacheAge
        )
        : CRemoteObjectInqHandle(szEntryName,ulCacheAge)
{
}

void
CMasterObjectInqHandle::initialize() {

    ulIndex = 0;

    StatusCode = NSI_S_OK;

    if (RpcMgmtSetCancelTimeout(CONNECTION_TIMEOUT) != RPC_S_OK)
        {
        StatusCode = NSI_S_OUT_OF_MEMORY;
        return;
        }

    RPC_BINDING_HANDLE hCurrentMaster =
                        ConnectToMasterLocator(
                                StatusCode
                                );

    if (!hCurrentMaster || StatusCode) {
        myRpcLocator->SetDCsDown();
        return;
    }
    else myRpcLocator->SetDCsUp();

    /* The following is a work around, because the compiler refuses to accept

           penEntryName ? (*penEntryName) : NULL

    */

    STRING_T szEntryName = NULL;
    if (penEntryName) szEntryName = *penEntryName;

    pUuidVector = getObjectVector(
                    hCurrentMaster,
                    RPC_C_NS_SYNTAX_DCE,
                    szEntryName,
                    StatusCode
                    );

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\objects.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    objects.cxx

Abstract:

    This file contains the implementations for non inline member functions
    of all basic classes used the server, excluding the data structure classes
    and classes used for network interactions.

Author:

    Satish Thatte (SatishT) 08/21/95  Created all the code below except where
                                      otherwise indicated.

--*/

#include <locator.hxx>


/***********  CGUID Methods **********/

CStringW*
CGUID::ConvertToString() {
    STRING_T pszResult;

    RPC_STATUS Status = UuidToString(
                                &rep,
                                &pszResult
                                );

    if (Status == RPC_S_OK) {
        CStringW * pswResult = new CStringW(pszResult);
        RpcStringFree(&pszResult);
        return pswResult;
    }
    else Raise(NSI_S_OUT_OF_MEMORY);

    /* NOTE: the following is a dummy statement to get past the compiler. */

    return NULL;
}

/***********  CGUIDVersion Methods **********/

int
CGUIDVersion::isMatching(const CGUIDVersion& o, UNSIGNED32 vers_option) {

        /*  vers_option decides how we match -- this is useful in,
            for instance, RpcNsMgmtBindingUnexport */

        CidAndVersion self(idAndVersion);
        CidAndVersion other(o.idAndVersion);

        if (self.id != other.id) return FALSE;    // id must match

        switch (vers_option) {
            case RPC_C_VERS_ALL:
                return TRUE;

            case RPC_C_VERS_COMPATIBLE:
                return (self.major == other.major) &&
                       (self.minor >= other.minor);

            case RPC_C_VERS_EXACT:
                return (self.major == other.major) &&
                       (self.minor == other.minor);

            case RPC_C_VERS_MAJOR_ONLY:
                return self.major == other.major;

            case RPC_C_VERS_UPTO:
                return (self.major < other.major) ||
                       ((self.major == other.major) && (self.minor <= other.minor));

            default:
                Raise(NSI_S_INVALID_VERS_OPTION);
        }

        /* the following is a dummy statement to get past the compiler */

        return NULL;
}


/***********  CBVWrapper Methods **********/

void
CBVWrapper::rundown()
{
    if (pBVT)
    {
        for (ULONG i = 0; i < pBVT->count;i++) {
            midl_user_free(pBVT->binding[i].string);
            midl_user_free(pBVT->binding[i].entry_name);
        }

        midl_user_free(pBVT);
        pBVT = NULL;
    }
}


/***********  CBindingVector Methods **********/

CBindingVector::CBindingVector(
            NSI_SERVER_BINDING_VECTOR_T *pbvtInVector,
            CServerEntry *pEntry
            )
            : pMyEntry(pEntry)
{
    merge(pbvtInVector);
}

int
CBindingVector::merge(
                      NSI_SERVER_BINDING_VECTOR_T* pHandles
                     )
/*++
Routine Description:

    Add new binding handles to the vector.

Arguments:

    pHandles - vector of allegedly new handles

Returns:

    TRUE, FALSE

Remarks:

    We first strip any object part present in the handle strings.
    The return value FALSE signifies that there were no new binding handles.

--*/
{
    int fChanges = FALSE;
    CStringW *pTemp;

    for (ULONG i = 0; i < pHandles->count; i++)    {

        NSI_STRING_BINDING_T szNextHandle = pHandles->string[i];
        NSI_STRING_BINDING_T szFinalHandle = NULL;

        /* first strip any object part from binding handle */

        if (szNextHandle) szFinalHandle = makeBindingStringWithObject(szNextHandle,NULL);

        if (szFinalHandle) {
            pTemp = new CStringW(szFinalHandle);
            RpcStringFree(&szFinalHandle);
            if (Duplicate == insert(pTemp)) delete pTemp;
            else fChanges = TRUE;
        }
    }
    return fChanges;
}


TBVSafeLinkList *
CBindingVector::formObjBVT(
        TSLLString * pLLobjectStrings,
        long ulVS    // max BV size
        )
/*++
Routine Description:

       Makes a copy of this CBindingVector in list-of-vector form replacing the
       object IDs in those bindings which contain a different object and
       adding the object ID to those which contain none.

Arguments:

    pLLobjectStrings - the linked list of possible object ID strings

    ulVS - limit on the size of the vector to be returned

Returns:

    binding vector


--*/

{
    long ulBVtotal = size() * max(pLLobjectStrings->size(),1);

    TBVSafeLinkList * pbvsll = new TBVSafeLinkList;

    long ulBVcount;

    NSI_BINDING_VECTOR_T * pbvtCurrentVector;

    // preform a list of all the vectors we will fill later
    // better keep all counts signed for safety in comparison

    for (ulBVcount = min(ulBVtotal,ulVS);
         ulBVcount;
         ulBVtotal -= ulBVcount, ulBVcount = min(ulBVtotal,ulVS)
        )
    {
        // Remeber that we need to allocate a DWORD for 32 bit platforms and QWORD
        // for 64 bit ones due to structure alignment.
        pbvtCurrentVector =
            (NSI_BINDING_VECTOR_T *)
            midl_user_allocate(sizeof(UNSIGNED32*) + sizeof(NSI_BINDING_T)*ulBVcount);

        pbvtCurrentVector->count = ulBVcount;
        pbvsll->insert(new CBVWrapper(pbvtCurrentVector));
    }

    TBVSafeLinkListIterator BViter(*pbvsll);

    pbvtCurrentVector = BViter.next()->pBVT;
    ulBVcount = pbvtCurrentVector->count;

    TSLLStringIter ObjIter(*pLLobjectStrings);

    long i = 0;

    BOOL fNoneMade = TRUE;    // must make at least one binding string for each
                            // binding even if there are no object strings

    for (CStringW * pswObject = ObjIter.next();
         pswObject || fNoneMade;
         pswObject = ObjIter.next())
    {
        fNoneMade = FALSE;    // made one now

        TCSafeSkipListIterator<CStringW> BindingIter(*this);

        for ( CStringW * pswBinding = BindingIter.next();
              pswBinding;
              pswBinding = BindingIter.next(), i++
            )
        {

            STRING_T szObject;

            if (pswObject) szObject = *pswObject;
            else szObject = NULL;

            STRING_T tempBinding =
                makeBindingStringWithObject(
                            *pswBinding,    // current binding string
                            szObject
                            );

            if (i == ulBVcount) {                    // current vector full
                                                    // start the next one
                pbvtCurrentVector = BViter.next()->pBVT;
                ulBVcount = pbvtCurrentVector->count;
                i = 0;
            }

            pbvtCurrentVector->binding[i].string = CStringW::copyMIDLstring(
                                                                tempBinding
                                                                );
            pbvtCurrentVector->binding[i].entry_name = pMyEntry->copyAsMIDLstring();
            pbvtCurrentVector->binding[i].entry_name_syntax = pMyEntry->ulEntryNameSyntax;

            RpcStringFree(&tempBinding);    // comes from a different pool
        }
    }

    return pbvsll;
}



/***********  CEntryName Methods **********/

CEntryName::CEntryName(
            CONST_STRING_T fullName
            )     // disassembling constructor
            : CStringW(fullName)

// This constructor makes a local name if it can, and is the one that should
// be used whenever possible
{
    // Enforce the correct format of the name.

    WCHAR	*szRpcContainerDN=NULL;
    WCHAR	*szDomainNameDns=NULL;
    HRESULT hr = S_OK;

    parseEntryName(fullName, pswDomainName, pswEntryName);
    pswRpcContainerDN = NULL;
    pswDomainNameDns = NULL;

    if (isLocal()) changeToLocalName();
    else
       if (myRpcLocator->fDSEnabled) {
	        hr = GetRpcContainerForDomain(*pswDomainName, &szRpcContainerDN, &szDomainNameDns);
            if (SUCCEEDED(hr))
	            pswRpcContainerDN = new CStringW(szRpcContainerDN);
            else
	            pswRpcContainerDN = new CStringW(L"");

            if (szRpcContainerDN)
                delete szRpcContainerDN;

            if (szDomainNameDns) 
                pswDomainNameDns = new CStringW(szDomainNameDns);
            else
                pswDomainNameDns = NULL;
                
            if (szDomainNameDns)
                delete szDomainNameDns;
       }
}


CEntryName::CEntryName(               // assembling constructor
        CONST_STRING_T domainName,    // if NULL, assume relative name
        CONST_STRING_T entryName
        )
{
    WCHAR	*szRpcContainerDN=NULL;
    WCHAR	*szDomainNameDns=NULL;    
    HRESULT hr = S_OK;

    pswDomainName = domainName ? new CStringW(domainName) : NULL;
    pswEntryName = new CStringW(entryName);
    pswRpcContainerDN = NULL;
    pswDomainNameDns = NULL;

    pszVal = NULL;

    if (isLocal()) changeToLocalName();
    else pszVal = copyGlobalName();

    if (pswDomainName) {
       if (myRpcLocator->fDSEnabled) {
	        hr = GetRpcContainerForDomain(*pswDomainName, &szRpcContainerDN, &szDomainNameDns);
            if (SUCCEEDED(hr))
    	        pswRpcContainerDN = new CStringW(szRpcContainerDN);
            else
    	        pswRpcContainerDN = new CStringW(L"");

            if (szRpcContainerDN)
                delete szRpcContainerDN;

            if (szDomainNameDns) 
                pswDomainNameDns = new CStringW(szDomainNameDns);
            else
                pswDomainNameDns = NULL;
                
            if (szDomainNameDns)
                delete szDomainNameDns;
       }
    }
}

CEntryName::CEntryName(               // assembling constructor for DS
        CONST_STRING_T RpcContainerDN,
        CONST_STRING_T domainNameDns,    // if NULL, assume relative name
        DWORD          type,
        CONST_STRING_T entryName
        )
{
    pswDomainNameDns = domainNameDns ? new CStringW(domainNameDns) : NULL;
    pswEntryName = new CStringW(entryName);
    pswRpcContainerDN = new CStringW(RpcContainerDN);
    pswDomainName = NULL;
    
    pszVal = NULL;

    if (isLocal()) changeToLocalName();
    else {
    
        WCHAR *szDomainNameFlat=NULL;

        GetDomainFlatName(domainNameDns, &szDomainNameFlat);

        if (szDomainNameFlat) {
            pswDomainName = new CStringW(szDomainNameFlat);
            delete szDomainNameFlat;
        }
        else {
            pswDomainName = new CStringW(domainNameDns);
        }

        pszVal = copyGlobalName();
    }            
}


CEntryName::~CEntryName() {
    delete pswDomainName;
    delete pswEntryName;
    if (pswRpcContainerDN)
        delete pswRpcContainerDN;
    if (pswDomainNameDns) 
        delete pswDomainNameDns;
}


STRING_T
CEntryName::copyGlobalName() {

    CStringW * pswDomain = pswDomainName ? pswDomainName :
          myRpcLocator->getDomainName();

    if (!pswDomain) Raise(NSI_S_INTERNAL_ERROR);

    return makeGlobalName(*pswDomain,*pswEntryName);
}

STRING_T
CEntryName::getFullDNAlloc()
{
    WCHAR	*szDN = NULL;

    szDN = new WCHAR[DNNamePrefixLength+wcslen((*pswEntryName))+
    		 wcslen(*(getRpcContainer())) +1+1];

    wsprintf(szDN, L"%s%s,%s", DNNamePrefix, (STRING_T)(*pswEntryName),
    		(STRING_T)(*(getRpcContainer())));

    return szDN;
}

STRING_T
CEntryName::getFullDNWithDomainAlloc()
{
    WCHAR	*szDN = NULL;
   
    szDN = new WCHAR[DSDomainBeginLength+wcslen(*(getDomainNameDns()))+
    		 DSDomainEndLength+DNNamePrefixLength+wcslen((*pswEntryName))+1+
    		 wcslen(*(getRpcContainer()))+1];

    wsprintf(szDN, L"%s%s%c%s%s,%s", DSDomainBegin, (STRING_T)(*getDomainNameDns()), DSDomainEnd, 
                                     DNNamePrefix, (STRING_T)(*pswEntryName), 
                                     (STRING_T)(*(getRpcContainer())));

    return szDN;
}

CStringW*
CEntryName::getDomainName()
{
    return pswDomainName?pswDomainName:myRpcLocator->getDomainName();
}

CStringW*
CEntryName::getDomainNameDns()
{
    if (pswDomainNameDns)
        return pswDomainNameDns;
    else if (pswDomainName) // couldn't find DNS domain Name
        return pswDomainName;
    else 
        return myRpcLocator->getDomainNameDns();
}

CStringW*
CEntryName::getRpcContainer()
{
    return (pswRpcContainerDN?pswRpcContainerDN:
    	(myRpcLocator->pRpcContainerDN));
}

int
CEntryName::isLocal() {
    if ((!pswDomainName) && (!pswDomainNameDns))
        return TRUE;

    if ((pswDomainName) && (*pswDomainName == *myRpcLocator->getDomainName()))
        return TRUE;

    if ((pswDomainNameDns) && (*pswDomainNameDns == *myRpcLocator->getDomainNameDns()))
        return TRUE;

    return FALSE;
}

/***********  CInterface Methods **********/

CInterface::CInterface(
            NSI_INTERFACE_ID_T * lpInf,
            NSI_SERVER_BINDING_VECTOR_T *BindingVector,
            CServerEntry *pMyEntry
            )
            :    CGUIDVersion(lpInf->Interface),
                transferSyntax(lpInf->TransferSyntax),
                m_pMyEntry(pMyEntry)
{
    pBVhandles = new CBindingVector(BindingVector,pMyEntry);
}



/***********  CServerEntry Methods **********/

void
CServerEntry::flush() {

    CriticalWriter me(rwEntryGuard);

    DBGOUT(OBJECT, ObjectList.size() << " Objects Flushed\n");
    DBGOUT(OBJECT, InterfaceList.size() << " Interfaces Flushed\n\n");

    ObjectList.wipeOut();
    InterfaceList.wipeOut();

}



int CServerEntry::addObjects(
            NSI_UUID_VECTOR_P_T objectVector
            )
{
    CGUID *lpObject;
    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    for (unsigned long i = 0; i < objectVector->count; i++) {

        if (!objectVector->uuid[i])
            continue;

        lpObject = new CGUID(*(objectVector->uuid[i]));

        if (Duplicate == ObjectList.insert(lpObject)) delete lpObject;
        else fChanges = TRUE;
    }
    return fChanges;
}

int CServerEntry::removeObjects(
                NSI_UUID_VECTOR_P_T objectVector,
                int& fRemovedAll
                )
{
    int fChanges = FALSE;
    fRemovedAll = TRUE;

    CGUID *pRemovedObject;

    CriticalWriter me(rwEntryGuard);

    for (unsigned long i = 0; i < objectVector->count; i++) {

        if (!objectVector->uuid[i])
            continue;

        CGUID Object(*objectVector->uuid[i]);

        if (pRemovedObject = ObjectList.remove(&Object)) {
            fChanges = TRUE;
            delete pRemovedObject;
        }
        else fRemovedAll = FALSE;
    }

    return fChanges;
}

int CServerEntry::addToInterface(
        NSI_INTERFACE_ID_T *lpInf,
        NSI_SERVER_BINDING_VECTOR_T *lpBindingVector,
        CInterfaceIndex* IfIndex
        )
/*++
Routine Description:

    Add new binding handles to the given interface and
    insert as a new interface if necessary.

Arguments:

    lpInf - Interface

    lpBindingVector - Vector of string bindings to add

    IfIndex - the interface index to insert a new interface into (besides self)

Returns:

    TRUE or FALSE

Remarks:

    The return value signifies whether the binding handles were new
    or the interface was new, i.e., whether the entry was actually updated.
    FALSE means no change.

--*/
{
    CInterface     *pTargetInterface = NULL;

    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    pTargetInterface = InterfaceList.find(&CGUIDVersion(lpInf->Interface));

    if (pTargetInterface)
        fChanges = pTargetInterface->mergeHandles(lpBindingVector);

    else {
        pTargetInterface = new CInterface(lpInf,lpBindingVector,this);
        InterfaceList.insert(pTargetInterface);

        // add this server entry to the global interface list.
        IfIndex->insert(this, pTargetInterface);
        fChanges = TRUE;
    }
    return fChanges;
}

int CServerEntry::addInterfaceToDS(
        NSI_INTERFACE_ID_T *lpInf,
        NSI_SERVER_BINDING_VECTOR_T *lpBindingVector
        )
/*++
Routine Description:

    Add new binding handles to the given interface and
    insert as a new interface if necessary.

Arguments:

    lpInf - Interface

    lpBindingVector - Vector of string bindings to add

Returns:

    TRUE or FALSE

Remarks:

    The return value signifies whether the binding handles were new
    or the interface was new, i.e., whether the entry was actually updated.
    FALSE means no change.

--*/
{
    CInterface     *pTargetInterface;
    HRESULT         hr = S_OK;

    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    pTargetInterface = InterfaceList.find(&CGUIDVersion(lpInf->Interface));

    if (pTargetInterface)
        fChanges = pTargetInterface->mergeHandles(lpBindingVector);
    else {
        pTargetInterface = new CInterface(lpInf,lpBindingVector, this);
        InterfaceList.insert(pTargetInterface);
        fChanges = TRUE;
    }

    if (fChanges)
    hr = pTargetInterface->AddToDS();

    return (SUCCEEDED(hr));
}



int CServerEntry::removeInterfaces(
                NSI_IF_ID_P_T    lpInf,
                UNSIGNED32   VersOption,
                CInterfaceIndex* IfIndex
                )
/*++
Routine Description:

    Remove all matching interfaces from the entry.

Arguments:

    lpInf - Base Interface Spec

    VersOption - Compatibility spec that decides which interfaces
                 match the base spec, and should be removed

    IfIndex - the interface index to remove interfaces from (besides self)


Returns:

    TRUE, FALSE

Remarks:

    The return value signifies whether any interfaces were removed.

--*/
{
    int fChanges = FALSE;

    CriticalWriter me(rwEntryGuard);

    CGUIDVersion baseIf(*lpInf);

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
        if (pIf->isMatching(baseIf,VersOption)) {
            InterfaceList.remove(pIf);
            IfIndex->remove(this,pIf);
            delete pIf;
            fChanges = TRUE;
        }

    return fChanges;
}

int
CServerEntry::removeInterfacesFromDS(
                NSI_IF_ID_P_T lpInf,
                UNSIGNED32 VersOption
                )
/*++
Routine Description:

    Remove all matching interfaces from the entry.

Arguments:

    lpInf   - Base Interface Spec

    VersOption  - Compatibility spec that decides which interfaces
                  match the base spec, and should be removed

    IfIndex     - the interface index to remove interfaces from (besides self)


Returns:

    TRUE, FALSE

Remarks:

    The return value signifies whether any interfaces were removed.

--*/
{
    int fChanges = FALSE;
    HRESULT     hr = S_OK;

    CriticalWriter me(rwEntryGuard);

    CGUIDVersion baseIf(*lpInf);

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
        if (pIf->isMatching(baseIf,VersOption)) {
            InterfaceList.remove(pIf);
            hr = pIf->DeleteFromDS();
            delete pIf;

            if (SUCCEEDED(hr))
           fChanges = TRUE;
        }

    return fChanges;
}


TSLLString*
CServerEntry::formObjectStrings(
            CGUID            *    pIDobject
            )

/*++

Method Description:

        We form a list of object UUID strings.  The list is empty if there is
        no OID involved (the client specified none and the entry contains none).
        The list contains only the string form of pIDobject if pIDobject is not
        NULL, and contains all UUIDs in the entry in string form otherwise.

        This is a private method, and must be called only within a reader guard.

--*/

{
    TSLLString * pLLobjectStrings = new TSLLString;

    if (pIDobject)
        pLLobjectStrings->insert(pIDobject->ConvertToString());
    else
    {
        TCSafeSkipListIterator<CGUID> ObjIter(ObjectList);
        for (CGUID *pID = ObjIter.next(); pID != NULL; pID = ObjIter.next())
            pLLobjectStrings->insert(pID->ConvertToString());
    }

    return pLLobjectStrings;
}




CLookupHandle *
CServerEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge        // ignored in this case
        )
/*++
Method Description: CServerEntry::lookup

    lookup an entry and form a linked list of binding vectors corresponding
    to the interface and object specification given, then wrap it in a
    lookup handle to make it ready for iteration.

Arguments:

            pGVInterface        -    Interface (and version)
            pGVTransferSyntax    -    Transfer syntax (ignored)
            pIDobject            -    object UUID we want
            ulVectorSize        -    max size of BVs to be sent

Returns:

    a lookup handle

Remarks:

--*/
{
    if (pIDobject && !memberObject(pIDobject))         // object not found
            return new CServerLookupHandle(            // return empty handle
                    new TBVSafeLinkList
                    );

    /* better to put this after the memberObject call, which itself uses
       a lock on rwEntryGuard, although also as a reader */

    CriticalReader me(rwEntryGuard);

    // Object OK, now find compatible interfaces

    TCSafeSkipListIterator<CInterface> IfIter(InterfaceList);

    TBVSafeLinkList * pBVLLbindings = new TBVSafeLinkList;

    TSLLString * pLLobjectStrings = formObjectStrings(pIDobject);

    for (CInterface *pIf = IfIter.next(); pIf != NULL; pIf = IfIter.next())
        if (!pGVInterface ||
            pIf->isCompatibleWith(pGVInterface,pGVTransferSyntax)
           )
        {

            /* we randomize the BV list by randomly using  either push or enque
               to insert each BV into the list -- this is accomplished by using
               randomized initialization of the pointer-to-member-function "put"

               NOTE:  put should be an intrinsic on Linked Lists -- and
                        used in formObjBVT

                void (TBVSafeLinkList::*put)(NSI_BINDING_VECTOR_T*);

                put = ((rand() % 2) ? TBVSafeLinkList::push : TBVSafeLinkList::enque);
            */

            TBVSafeLinkList * pbvList =
                 pIf->pBVhandles->formObjBVT(
                        pLLobjectStrings,
                        ulVectorSize
                    );

            pBVLLbindings->catenate(*pbvList);

            delete pbvList;
        }

    /* finally, run down the object strings before returning the handle */

    TCSafeLinkListIterator<CStringW> runDownIter(*pLLobjectStrings);

    for (CStringW * psw = runDownIter.next(); psw; psw = runDownIter.next())
        delete psw;

    delete pLLobjectStrings;

    return new CServerLookupHandle(
            pBVLLbindings
            );
}

int
CServerEntry::add_to_entry(
    IN NSI_INTERFACE_ID_T              *    Interface,
    IN NSI_SERVER_BINDING_VECTOR_T     *    BindingVector,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    CInterfaceIndex            *    IfIndex,
    BOOL                            fCache
    )
/*++
Member Description:

    Add interfaces and objects to a server entry.

Arguments:

    Interface        - (raw) Interface+TransferSyntax to export

    BindingVector    - (raw) Vector of string bindings to export.

    ObjectVector     - (raw) Vector of object UUIDs to add to the entry

    IfIndex - the interface index to insert a new interface into (besides self)

Returns:

    TRUE    - if the export results in changes to the entry

    FALSE    - if the entry is unchanged

--*/
{
   int fChanges = FALSE;

   if (ObjectVector) fChanges = addObjects(ObjectVector);

   if ((!fCache) && (IsNilIfId(&(Interface->Interface))))
       return fChanges;

   if (Interface && BindingVector)
       fChanges = addToInterface(Interface,BindingVector,IfIndex) || fChanges;

   return fChanges;

} // add_to_entry

int
CServerEntry::remove_from_entry(
    IN NSI_IF_ID_P_T                        Interface,
    IN UNSIGNED32                   VersOption,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    CInterfaceIndex            *    IfIndex
    )
/*++
Member Description:

    remove interfaces and objects from a server entry.

Arguments:

    Interface        - (raw) Interface+TransferSyntax to unexport

    VersOption       - flag which controls in fine detail which interfaces to remove

    ObjectVector     - (raw) Vector of object UUIDs to remove from the entry

    IfIndex          - the interface index to remove a new interface into (besides self)

Returns:

    TRUE    - if the export results in changes to the entry

    FALSE   - if the entry is unchanged

--*/
{
   int fChanges = FALSE, fIntfChanges = TRUE; // safe
   int fRemovedAll = TRUE;

   if (ObjectVector) fChanges = removeObjects(ObjectVector, fRemovedAll);

   if (!fRemovedAll)
       Raise(NSI_S_NOT_ALL_OBJS_UNEXPORTED);

   if (Interface)
       fIntfChanges = removeInterfaces(Interface, VersOption, IfIndex);

   if (!fIntfChanges)
       Raise(NSI_S_INTERFACE_NOT_FOUND);

   return fChanges || fIntfChanges;

} // add_to_entry


int
CServerEntry::add_changes_to_DS(
    IN NSI_INTERFACE_ID_T              *    Interface,
    IN NSI_SERVER_BINDING_VECTOR_T     *    BindingVector,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    int                                     fNewEntry,
    BOOL				    fIgnoreErrors)
{
   int        fChanges = FALSE, fIntfChanges = TRUE;
   HRESULT    hr = S_OK;

   if (ObjectVector) fChanges = addObjects(ObjectVector);

   if (fChanges || fNewEntry)
       hr = AddToDS();

   if ((FAILED(hr)) && (!fIgnoreErrors))
       Raise(NSI_S_NOT_ALL_OBJS_EXPORTED);

   if (Interface && BindingVector)
       fIntfChanges = addInterfaceToDS(Interface,BindingVector);

   if ((!fIntfChanges) && (!fIgnoreErrors))
       Raise(NSI_S_INTERFACE_NOT_EXPORTED);

   return fChanges || fIntfChanges;
}


int
CServerEntry::remove_changes_from_DS(
    IN NSI_IF_ID_P_T                        Interface,
    UNSIGNED32                              VersOption,
    IN NSI_UUID_VECTOR_P_T                  ObjectVector,
    BOOL				    fIgnoreErrors
    )
{
   int fChanges = FALSE, fIntfChanges = TRUE;
   int fRemovedAll = TRUE;
   HRESULT hr = S_OK;

   if (ObjectVector) fChanges = removeObjects(ObjectVector, fRemovedAll);

   if (fChanges)
       hr = AddToDS();

   if (((!fRemovedAll) || (FAILED(hr))) && (!fIgnoreErrors))
       Raise(NSI_S_NOT_ALL_OBJS_UNEXPORTED);

   if (Interface)
       fIntfChanges = removeInterfacesFromDS(Interface, VersOption);

   if ((!fIntfChanges) && (!fIgnoreErrors))
       Raise(NSI_S_INTERFACE_NOT_FOUND);

   return fChanges || fIntfChanges;
}


/* BUGBUG: A CServerObjectInqHandle created by the following seems to be leaked in the
   master (PDC) locator in CT test#511, perhaps only when the test fails, which it does
   when the client locator is new and the server locator is old -- needs investigation */

CObjectInqHandle *
CServerEntry::objectInquiry(
        unsigned long        ulCacheAge
    )
{
    CriticalReader me(rwEntryGuard);

    TCSafeSkipListIterator<CGUID> ssli(ObjectList);

    TCSafeSkipList<CGUID> *pssl = new TCSafeSkipList<CGUID>;

    for (CGUID* pguid = ssli.next(); pguid; pguid = ssli.next())
    {
        CGUID * pGuidCopy = new CGUID(*pguid);
        pssl->insert(pGuidCopy);
    }

    TSSLGuidIterator *pGuidIter = new TSSLGuidIterator(*pssl);

    delete pssl;

    return new CServerObjectInqHandle(
                                    pGuidIter,
                                    ulCacheAge
                                    );
}


/***********  CRemoteLookupHandle Methods **********/


#if DBG
    ULONG CRemoteLookupHandle::ulHandleCount = 0;
    ULONG CRemoteObjectInqHandle::ulHandleCount = 0;
#endif

CRemoteLookupHandle::CRemoteLookupHandle(
        UNSIGNED32            EntryNameSyntax,
        STRING_T              EntryName,
        CGUIDVersion     *    pGVInterface,
        CGUIDVersion     *    pGVTransferSyntax,
        CGUID            *    pIDobject,
        unsigned long         ulVectorSize,
        unsigned long         ulCacheAge
    )
{
   DBGOUT(MEM2, "RemoteLookupHandle#" << (ulHandleNo = ++ulHandleCount)
        << " Created at" << CurrentTime() << "\n\n");

   u32EntryNameSyntax = EntryNameSyntax;
   penEntryName = EntryName ? new CEntryName(EntryName) : NULL;

   pgvInterface = pGVInterface ? new CGUIDVersion(*pGVInterface) : NULL;
   pgvTransferSyntax = pGVTransferSyntax ?
               new CGUIDVersion(*pGVTransferSyntax) :
               NULL;
   pidObject = pIDobject ? new CGUID(*pIDobject) : NULL;

   ulVS = ulVectorSize;
   ulCacheMax = ulCacheAge;

   fNotInitialized = TRUE;
   plhFetched = NULL;
   psslNewCache = NULL;
}


/***********  CNetLookupHandle Methods **********/

#if DBG
    ULONG CNetLookupHandle::ulNetLookupHandleCount = 0;
    ULONG CNetLookupHandle::ulNetLookupHandleNo = 0;
#endif

void
CNetLookupHandle::initialize()
{
    STRING_T szEntryName;

    if (penEntryName) szEntryName = *penEntryName;
    else szEntryName = NULL;

    DBGOUT(TRACE,"CNetLookupHandle::initialize called for Handle#" << ulHandleNo << "\n\n");
    if (!myRpcLocator->IsInMasterRole())
    {
        DBGOUT(TRACE, "Not a master locator, requesting for Broadcast\n");
        pRealHandle = new CMasterLookupHandle(
                                u32EntryNameSyntax,
                                szEntryName,
                                pgvInterface,
                                pgvTransferSyntax,
                                pidObject,
                                ulVS,
                                ulCacheMax
                                );

        // force initialization to make sure connection to master is OK

        pRealHandle->initialize();
    }



    if (myRpcLocator->IsInMasterRole() ||
        (!IsNormalCode(pRealHandle->StatusCode) && myRpcLocator->IsInBackupRole())
       )

    {
        if (myRpcLocator->IsInWorkgroup())    // we are in a workgroup, so become masterful
            myRpcLocator->becomeMasterLocator();

        if (pRealHandle) delete pRealHandle;

        DBGOUT(TRACE, "Finds that it is the master locator and sends broadcast\n");
        pRealHandle = new CBroadcastLookupHandle(
                                u32EntryNameSyntax,
                                szEntryName,
                                pgvInterface,
                                pgvTransferSyntax,
                                pidObject,
                                ulVS,
                                ulCacheMax
                                );
    }

    fNotInitialized = FALSE;
}




/***********  CNetObjectInqHandle Methods **********/

void
CNetObjectInqHandle::initialize()
{
    if (!myRpcLocator->IsInMasterRole())
    {
        pRealHandle = new CMasterObjectInqHandle(
                                *penEntryName,
                                ulCacheMax
                                );

        // force initialization to make sure connection to master is OK

         pRealHandle->initialize();
    }

    if (myRpcLocator->IsInMasterRole() ||
        (!IsNormalCode(pRealHandle->StatusCode) && myRpcLocator->IsInBackupRole())
       )
    {
        if (myRpcLocator->IsInWorkgroup())    // we are in a workgroup, so become masterful

            myRpcLocator->becomeMasterLocator();

        if (pRealHandle) delete pRealHandle;

        pRealHandle = new CBroadcastObjectInqHandle(
                                *penEntryName,
                                ulCacheMax
                                );
    }
}


/***********  CServerLookupHandle Methods **********/


void
CServerLookupHandle::rundown() {
    CBVWrapper *pbvw;

    if (pBVIterator)
    {
        for (pbvw = pBVIterator->next(); pbvw; pbvw = pBVIterator->next()) {
            pbvw->rundown();
            delete pbvw;
        }

        delete pBVIterator;
        pBVIterator = NULL;
    }
}



CServerLookupHandle::CServerLookupHandle(
            TBVSafeLinkList            *    pBVLL
            )
{
    pBVIterator = new TBVSafeLinkListIterator(*pBVLL);
    
    /* it seems bizarre to do the following, but reference counting and
       the fDeleteData flag in Link objects ensure that nothing is
       destroyed prematurely.  This just sets things up so that objects
       are automatically deleted as they are used up.  Note that the BV objects
       themselves are freed automatically by the stub as they are passed back.

       Unused BV objects will be reclaimed by rundown/done using middle_user_free.
    */

    delete pBVLL;
}


/***********  CServerObjectInqHandle Methods **********/

void
CServerObjectInqHandle::rundown()
{
    if (pcgIterSource)
    {
        for (CGUID* pg = pcgIterSource->next(); pg; pg = pcgIterSource->next())
            delete pg;

        delete pcgIterSource;
        pcgIterSource = NULL;
    }
}


GUID *
CServerObjectInqHandle::next() {

    CGUID* pg = pcgIterSource->next();

    GUID * result = NULL;

    if (pg) {
        result = (GUID*) midl_user_allocate(sizeof(GUID));
        *result = pg->myGUID();
        delete pg;
    }

    return result;
}



/***********  CNonLocalServerEntry Methods **********/

BOOL
CNonLocalServerEntry::isCurrent(ULONG ulTolerance) {

    CriticalReader me(rwNonLocalEntryGuard);

    return fHasNonLocalInfo && IsStillCurrent(ulCacheTime,ulTolerance);

}


CLookupHandle *
CNonLocalServerEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge
        )
{
    if (!isCurrent(ulCacheAge)) flush();

    CriticalReader me(rwNonLocalEntryGuard);

    DBGOUT(TRACE, "Forming new NonLocal handle for" << getCurrentName() << "\n");

    return new CNonLocalServerLookupHandle(
                        getCurrentName(),
                        pGVInterface,
                        pGVTransferSyntax,
                        pIDobject,
                        ulVectorSize,
                        ulCacheAge
                        );
}


CObjectInqHandle *
CNonLocalServerEntry::objectInquiry(
            unsigned long        ulCacheAge
        )
{
    CriticalReader me(rwNonLocalEntryGuard);

    return new CNonLocalServerObjectInqHandle(
                    getCurrentName(),
                    ulCacheAge
                    );
}




/***********  CFullServerEntry Methods **********/

void
CFullServerEntry::flushCacheIfNecessary(ULONG ulTolerance)
{
    CriticalReader me(rwFullEntryGuard);

    if (!pNonLocalEntry->isCurrent(ulTolerance))
    {
        pNonLocalEntry->flush();

        /*
           Note that the "flushing" may be spurious -- it may happen
           because the NonLocal entry has no cached info.
        */
    }
}


CLookupHandle *
CFullServerEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge
            )
{
    CriticalReader me(rwFullEntryGuard);

    CLookupHandle *
    pLocalHandle = pLocalEntry->lookup(
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    );

    flushCacheIfNecessary(ulCacheAge);

    /* it is important to do the cache lookup before the net lookup so as
       to avoid duplication in the results returned.  If the net lookup uses
       a broadcast handle, the initialization will create both a private and a
       public cache (the former to avoid duplication), and the latter will be
       picked up by cache lookup if it is done later.
    */

    CLookupHandle *
    pNonLocalHandle = pNonLocalEntry->lookup(
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    );


    CLookupHandle *
    pNetHandle = myRpcLocator->NetLookup(
                                    RPC_C_NS_SYNTAX_DCE,
                                    getCurrentName(),
                                    pGVInterface,
                                    pGVTransferSyntax,
                                    pIDobject,
                                    ulVectorSize,
                                    ulCacheAge
                                    );

    return new CCompleteHandle<NSI_BINDING_VECTOR_T>(
                                                pLocalHandle,
                                                pNonLocalHandle,
                                                pNetHandle,
                                                ulCacheAge
                                                );
}


CObjectInqHandle *
CFullServerEntry::objectInquiry(
            unsigned long        ulCacheAge
            )
{
    CriticalReader me(rwFullEntryGuard);

    CObjectInqHandle *
    pLocalHandle = pLocalEntry->objectInquiry(
                                        ulCacheAge
                                        );

    CObjectInqHandle *
    pNonLocalHandle = pNonLocalEntry->objectInquiry(
                                        ulCacheAge
                                        );

    CObjectInqHandle *
    pNetHandle = myRpcLocator->NetObjectInquiry(
                                        RPC_C_NS_SYNTAX_DCE,
                                        getCurrentName()
                                        );

    return new CCompleteHandle<GUID>(
                                     pLocalHandle,
                                     pNonLocalHandle,
                                     pNetHandle,
                                     ulCacheAge
                                     );
}




/***********  CNonLocalServerLookupHandle Methods **********/

void
CNonLocalServerLookupHandle::initialize()
{
    CEntry *pE = myRpcLocator->GetEntryFromCache(RPC_C_NS_SYNTAX_DCE,*penEntryName);

    CNonLocalServerEntry *pEntry;

    if ((pE) && (pE->getType() == FullServerEntryType))
        pEntry = ((CFullServerEntry*)pE)->getNonLocal();

    else if ((pE) && (pE->getType() == NonLocalServerEntryType))
        pEntry = (CNonLocalServerEntry*)pE;

    else pEntry = NULL;

    if (pEntry) {
        plhFetched = pEntry->CServerEntry::lookup(
                                                    pgvInterface,
                                                    pgvTransferSyntax,
                                                    pidObject,
                                                    ulVS,
                                                    ulCacheMax
                                                    );
        if (plhFetched)
        {
            DBGOUT(TRACE, "Found a NonLocal entry for" << *penEntryName << "\n");
        }
        else
        {
            DBGOUT(TRACE, "Entry Found, but handle couldn't be formed for"
                << *penEntryName << "\n");
        }
    }
    else  plhFetched = NULL;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


CNonLocalServerLookupHandle::CNonLocalServerLookupHandle(
                    STRING_T szEntryName,
                    CGUIDVersion *pGVInterface,
                    CGUIDVersion *pGVTransferSyntax,
                    CGUID *pIDobject,
                    ULONG ulVectorSize,
                    ULONG ulCacheAge
                    )
                : CRemoteLookupHandle(
                    RPC_C_NS_SYNTAX_DCE,
                    szEntryName,
                    pGVInterface,
                    pGVTransferSyntax,
                    pIDobject,
                    ulVectorSize,
                    ulCacheAge
                    )
{
}



/***********  CNonLocalServerObjectInqHandle Methods **********/

void
CNonLocalServerObjectInqHandle::initialize()
{
    ulIndex = 0;

    CNonLocalServerEntry *pEntry;

    // get the NonLocal entry again because it may have expired, been deleted and replaced

    CEntry *pE = myRpcLocator->GetEntryFromCache(RPC_C_NS_SYNTAX_DCE,*penEntryName);

    if ((pE) && (pE->getType() == FullServerEntryType))
        pEntry = ((CFullServerEntry*)pE)->getNonLocal();

    else if ((pE) && (pE->getType() == NonLocalServerEntryType))
        pEntry = (CNonLocalServerEntry*)pE;

    else pEntry = NULL;

    if (pEntry) {
        CObjectInqHandle *pTempHandle = pEntry->CServerEntry::objectInquiry(ulCacheMax);
        pUuidVector = getVector(pTempHandle);
        delete pTempHandle;
    }
    else pUuidVector = NULL;

    ulCreationTime = CurrentTime();
    fNotInitialized = FALSE;
}


CNonLocalServerObjectInqHandle::CNonLocalServerObjectInqHandle(
                    STRING_T szEntryName,
                    ULONG ulCacheAge
                    )
        : CRemoteObjectInqHandle(szEntryName,ulCacheAge)
{
}





/***************** CGroupLookupHandle Methods *****************/


CGroupLookupHandle::CGroupLookupHandle(
            TEntryIterator  *    pEI,
            CGUIDVersion    *    pGVInf,
            CGUIDVersion    *    pGVXferSyntax,
            CGUID           *    pIDobj,
            unsigned long        ulVectSize,
            unsigned long        ulCacheAge
        )
{
    ulCacheMax = ulCacheAge;

    pGVInterface = pGVInf ? new CGUIDVersion(*pGVInf) : NULL;
    pGVTransferSyntax = pGVXferSyntax ? new CGUIDVersion(*pGVXferSyntax) : NULL;
    pIDobject = pIDobj ? new CGUID(*pIDobj) : NULL;
    ulVectorSize = ulVectSize;
    pCurrentHandle = NULL;
    fUnusedHandle = TRUE;
    fRootHandle = TRUE; // presumption

    pEIterator = pEI;


    // The new TSSLEntryList set here may be deleted
    // if this handle is belongs to an entry that is part of a
    // larger group or profile lookup -- in that case the larger
    // lookup will send in its own list of visited entries
    pVisitedEntries = new TSSLVisitedList;
}


void
CGroupLookupHandle::advanceCurrentHandle()
{
    delete pCurrentHandle;
    pCurrentHandle = NULL;

    for (CEntry *pCurEntry = pEIterator->next(); pCurEntry; pCurEntry = pEIterator->next())
    {
        CVisitedEntry    *visited = new CVisitedEntry(pCurEntry->getCurrentName(), pCurEntry->getType());

        if (pVisitedEntries->find(visited)) {
            DBGOUT(TRACE, "Already visited this entry, size of VisitedEntries\n" << pVisitedEntries->size());
            DBGOUT(TRACE, "The current entry type (that is abt. to be skipped): " << pCurEntry->getType() << "\n");
            delete visited;
            continue; // been there
        }

        DBGOUT(TRACE, "The type of entry to be inserted CurEntry type: " << pCurEntry->getType() << "\n");

        pVisitedEntries->insert(visited);

        if (pCurEntry->getType() == MemberEntryType)
        {
            DBGOUT(TRACE, "TYpe is MemberEntryType\n");
            CMemberEntry *pMemberEntry = (CMemberEntry*) pCurEntry;
            pMemberEntry->setVisitedEntries(pVisitedEntries);
        }

        DBGOUT(TRACE, "Calling lookup on pCurEntry\n");
        pCurrentHandle = pCurEntry->lookup(     // INVARIANT:  lookup returns non-NULL
                                        pGVInterface,
                                        pGVTransferSyntax,
                                        pIDobject,
                                        ulVectorSize,
                                        ulCacheMax
                                        );

        if (pCurEntry->getType() == MemberEntryType)
        {
            delete pCurEntry;
        }

        ASSERT(pCurrentHandle,"advanceCurrentHandle got NULL handle\n");

        pCurrentHandle->setExpiryAge(ulCacheMax);

        if (!pCurrentHandle->finished()) break;
        else {
            delete pCurrentHandle;
            pCurrentHandle = NULL;
        }
    }
}




NSI_BINDING_VECTOR_T *
CGroupLookupHandle::next()
{
    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return NULL;    // no more entries
    else return pCurrentHandle->next();
}

int
CGroupLookupHandle::finished()
{
    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return TRUE;    // no more entries
    else return FALSE;
}

/***************** CDSNullLookupHandle Methods *****************/
CDSNullLookupHandle::CDSNullLookupHandle(
            CGUIDVersion    *    pGVInf,
            CGUIDVersion    *    pGVXferSyntax,
            CGUID           *    pIDobj,
            unsigned long        ulVectSize,
            unsigned long        ulCacheAge
        )
{
    pGVInterface = pGVInf ? new CGUIDVersion(*pGVInf) : NULL;
    pGVTransferSyntax = pGVXferSyntax ? new CGUIDVersion(*pGVXferSyntax) : NULL;
    pIDobject = pIDobj ? new CGUID(*pIDobj) : NULL;
    ulVectorSize = ulVectSize;
    pCurrentHandle = NULL;
    fUnusedHandle = TRUE;
    pDSQry = NULL;
    fNotInitialized = TRUE;
}


void
CDSNullLookupHandle::advanceCurrentHandle()
{
    delete pCurrentHandle;
    pCurrentHandle = NULL;

    if (!pDSQry) {
        return;
    }
    for (CEntry *pCurEntry = pDSQry->next(); pCurEntry; pCurEntry = pDSQry->next())
    {
        DBGOUT(TRACE, "Calling lookup on pCurEntry\n");
        pCurrentHandle = pCurEntry->lookup(     // INVARIANT:  lookup returns non-NULL
                                        pGVInterface,
                                        pGVTransferSyntax,
                                        pIDobject,
                                        ulVectorSize,
                                        ulCacheMax
                                        );

        delete pCurEntry;

        ASSERT(pCurrentHandle,"advanceCurrentHandle got NULL handle\n");

        if (!pCurrentHandle->finished()) break;
        else {
            delete pCurrentHandle;
            pCurrentHandle = NULL;
        }
    }
}

void CDSNullLookupHandle::initialize()
{
    WCHAR   szCommandText[MAX_DS_QUERY_LEN];
    WCHAR   szSubCommand[MAX_DS_QUERY_LEN];
    HRESULT     hr = S_OK;

    wsprintf(szCommandText, L"(& (%s=%s) ",
                            CLASSNAME, RPCSERVERCONTAINERCLASS);
    if (pIDobject) {
       GUID         guid;
       STRINGGUID   szGuid;

       guid = pIDobject->myGUID();
       UuidToStringEx(&guid, szGuid);
       wsprintf(szSubCommand, L"(%s=%s)", OBJECTID, szGuid);
       wcscat(szCommandText, szSubCommand);
    }

    wsprintf(szSubCommand, L")");
    wcscat(szCommandText, szSubCommand);

    DBGOUT(DIRSVC, L"Query string for NULL lookup Handle" << szCommandText);

    pDSQry = new CDSQry(szCommandText, &hr);
    if (FAILED(hr))
        delete pDSQry;

    fNotInitialized = FALSE;
}
// same as group entry lookup

NSI_BINDING_VECTOR_T *
CDSNullLookupHandle::next()
{
   if (fNotInitialized)
       initialize();

    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return NULL;    // no more entries
    else return pCurrentHandle->next();
}

// same as group entry lookup.
int
CDSNullLookupHandle::finished()
{
    if (!fNotInitialized)
        initialize();

    if (fUnusedHandle)
    {
        fUnusedHandle = FALSE;
        advanceCurrentHandle();
    }
    else if (pCurrentHandle && pCurrentHandle->finished())
    {
        advanceCurrentHandle();
    }

    if (!pCurrentHandle) return TRUE;    // no more entries
    else return FALSE;
}



/***************** CIndexLookupHandle Methods *****************/

void
CIndexLookupHandle::lookupIfNecessary() {    // client unhappy, start all over again
    rundown();
    delete pEIterator;
    pEIterator = myRpcLocator->IndexLookup(pGVInterface);
    advanceCurrentHandle();
}





CIndexLookupHandle::CIndexLookupHandle(
            CGUIDVersion    *    pGVInf,
            CGUIDVersion    *    pGVXferSyntax,
            CGUID           *    pIDobj,
            unsigned long        ulVectSize,
            unsigned long        ulCacheAge
        )
        : CGroupLookupHandle(
                    myRpcLocator->IndexLookup(pGVInf),
                    pGVInf,
                    pGVXferSyntax,
                    pIDobj,
                    ulVectSize,
                    ulCacheAge
                    )
{}
/********/


void CMemberEntry::materialize() // get the real entry now
{
     pRealEntry = GetEntryFromDS(
                  RPC_C_NS_SYNTAX_DCE,
                  getCurrentName()
                  );

}



CLookupHandle *
CMemberEntry::lookup(
            CGUIDVersion    *    pGVInterface,
            CGUIDVersion    *    pGVTransferSyntax,
            CGUID           *    pIDobject,
            unsigned long        ulVectorSize,
            unsigned long        ulCacheAge
            )
{
    materialize();

    if (pRealEntry == NULL) return new CNullLookupHandle;

    CLookupHandle *pHandle = pRealEntry->lookup(
                                            pGVInterface,
                                            pGVTransferSyntax,
                                            pIDobject,
                                            ulVectorSize,
                                            ulCacheAge
                                            );

    EntryType type = pRealEntry->getType();

    if (type == GroupEntryType || type == ProfileEntryType)
    {
        CGroupLookupHandle *pGroupHandle = (CGroupLookupHandle*) pHandle;
        pGroupHandle->setVisitedEntries(pVisitedEntries);
    }

    return pHandle;
}



/****************** CGroupEntry Methods ******************/


CLookupHandle * CGroupEntry::lookup(
        CGUIDVersion    *    pGVInterface,
        CGUIDVersion    *    pGVTransferSyntax,
        CGUID           *    pIDobject,
        unsigned long        ulVectorSize,
        unsigned long        ulCacheAge
        )
{
    TCSafeSkipListIterator<CEntryName> GroupListIter(GroupList);

    TSLLEntryList EntryList;
    CEntryName *pEntryName;

    while (pEntryName = GroupListIter.next())
    {
        CMemberEntry *pEntry =
            new CMemberEntry(pEntryName->getCurrentName());

        EntryList.enque(pEntry);
    }

    DWORD size = EntryList.size();
    if (size > 0) EntryList.rotate(GetTickCount() % size);  // randomize

    TSLLEntryListIterator *pSLLEntryIterator = new TSLLEntryListIterator(EntryList);

    return new CGroupLookupHandle(
                            pSLLEntryIterator,
                            pGVInterface,
                            pGVTransferSyntax,
                            pIDobject,
                            ulVectorSize,
                            ulCacheAge
                            );
}


CGroupInqHandle *
CGroupEntry::GroupMbrInquiry()
{
    return new CGroupInqHandle(
                    new TCSafeSkipListIterator<CEntryName>(GroupList), this
              );
}



/****************** CProfileEntry Methods ******************/



CProfileInqHandle *
CProfileEntry::ProfileEltInquiry(
            DWORD inquiry_type,
            NSI_IF_ID_P_T if_id,
            DWORD vers_option,
            STRING_T member_name
            )
{
    TCSafeSkipListIterator<CProfileElement> EltListIter(EltList);
    TCSafeLinkList<CProfileElement> ResultList;
    CProfileElement *pElt;

    if (inquiry_type == RPC_C_PROFILE_DEFAULT_ELT)
    {
        if (pDefaultElt != NULL)
        {
            ResultList.insert(pDefaultElt);
        }
    }
    else while (pElt = EltListIter.next())
    {
        BOOL fMatchesIf = TRUE, fMatchesName = TRUE;

        if (inquiry_type == RPC_C_PROFILE_MATCH_BY_IF ||
            inquiry_type == RPC_C_PROFILE_MATCH_BY_BOTH)
        {
            if (
                !if_id ||
                !pElt->Interface.isMatching(
                                    CGUIDVersion(*if_id),
                                    vers_option
                                    )
                )
            {
                fMatchesIf = FALSE;
            }
        }

        if (inquiry_type == RPC_C_PROFILE_MATCH_BY_MBR ||
            inquiry_type == RPC_C_PROFILE_MATCH_BY_BOTH)
        {
            if (
                !member_name ||
                pElt->EntryName != CEntryName(member_name)
               )
            {
                fMatchesName = FALSE;
            }
        }

        if (fMatchesIf && fMatchesName)
        {
            ResultList.insert(pElt);
        }
    }

    return new CProfileInqHandle(
            new TCSafeLinkListIterator<CProfileElement>(ResultList), this
            );
}



void CProfileEntry::AddElement(
            RPC_SYNTAX_IDENTIFIER    *  pInterface,
            STRING_T                    pEntryName,
            DWORD                       dwPriority,
            STRING_T                    pszAnnotation
            )
{
    HRESULT          hr=S_OK;
    BOOL         fChanges = FALSE;

    if (pInterface==NULL)
    {
        // replace default element
        if (pDefaultElt)
            delete pDefaultElt;

        pDefaultElt = new CProfileElement(
                                    NULL,
                                    pEntryName,
                                    0,             // fixed for default
                                    pszAnnotation,
                                    this
                                    );

        hr = pDefaultElt->AddToDS();
        if (FAILED(hr)) {
           DWORD dwErr = RemapErrorCode(hr);
           if (dwErr == NSI_S_INTERNAL_ERROR)
               Raise(NSI_S_PRF_ELT_NOT_ADDED);
           else
               Raise(dwErr);
        }
        return;
    }

    CProfileKey *pKey = new CProfileKey(pInterface,pEntryName);
    CProfileElement *pElt = EltList.find(pKey);
    delete pKey;

    if (pElt != 0)
    {
        // update case
    if (pElt->dwPriority != dwPriority) {
       pElt->dwPriority = dwPriority;
       fChanges = TRUE;
    }

    if (wcscmp(pElt->pszAnnotation, pszAnnotation) != 0) {
       pElt->pszAnnotation = pszAnnotation;
       fChanges = TRUE;
    }
    }
    else
    {
        // new profile element case
    fChanges = TRUE;

        pElt = new CProfileElement(
                                pInterface,
                                pEntryName,
                                dwPriority,
                                pszAnnotation,
                                this
                                );
    }


    if (fChanges)
        hr = pElt->AddToDS();

    if (FAILED(hr)) {
        DWORD dwErr = RemapErrorCode(hr);
        if (dwErr == NSI_S_INTERNAL_ERROR)
           Raise(NSI_S_PRF_ELT_NOT_ADDED);
        else
           Raise(dwErr);
    }
}


CLookupHandle * CProfileEntry::lookup(
        CGUIDVersion    *    pGVInterface,
        CGUIDVersion    *    pGVTransferSyntax,
        CGUID           *    pIDobject,
        unsigned long        ulVectorSize,
        unsigned long        ulCacheAge
        )
{
    // Traverse Profile lists in priority order, randomize the individual lists
    // and form a list of entry names from matching profile elements

    TCSafeSkipListIterator<CProfileSet> ProfileListIter(ProfileList);

    TSLLEntryList EntryList;

    if (pDefaultElt != NULL)  // Always add it in
    {
        CMemberEntry *pEntry =
            new CMemberEntry(pDefaultElt->EntryName.getCurrentName());

        EntryList.enque(pEntry);
    }

    CProfileSet *pSet;

    while (pSet = ProfileListIter.next())
    {
        ASSERT(pSet->size() > 0, "Empty priority set in profile\n");

        // randomize before searching
        pSet->rotate(GetTickCount() % pSet->size());

        TCSafeLinkListIterator<CProfileElement> EltListIter(*pSet);

        CProfileElement *pElt;

        while (pElt = EltListIter.next())
        {
            if ((!pGVInterface) || (pElt->Interface.isCompatibleGV(*pGVInterface)))
            {
                CMemberEntry *pEntry =
                    new CMemberEntry(pElt->EntryName.getCurrentName());

                EntryList.enque(pEntry);
            }
        }
    }

    TSLLEntryListIterator *pSLLEntryIterator = new TSLLEntryListIterator(EntryList);

    return new CGroupLookupHandle(
                            pSLLEntryIterator,
                            pGVInterface,
                            pGVTransferSyntax,
                            pIDobject,
                            ulVectorSize,
                            ulCacheAge
                            );
}


/***************** CInterfaceIndex Methods *****************/

void
CInterfaceIndex::insert(
            CServerEntry * pSElocation,
            CInterface * pInf)

/*++
Routine Description:

    Insert an interface into the interface index.  The interface is either new
    or has had some new binding handles inserted in it.  In the latter case,
    we do not need to reinsert it.

Arguments:

            pSElocation        -    The server entry where the interface occurs
            pInf            -    The new or changed interface

Returns:

    nothing

--*/
{
        CGUID InfID(pInf->myGUID());

        CriticalWriter me(rwLock);        // acquires writer lock

        CInterfaceIndexEntry *pCurrentIndex =
            InterfaceEntries.find(&InfID);

        if (!pCurrentIndex) {
            pCurrentIndex = new CInterfaceIndexEntry(InfID);
            InterfaceEntries.insert(pCurrentIndex);
        }

        pCurrentIndex->insert(pSElocation);
        pNullIndex->insert(pSElocation);
}

void
CInterfaceIndex::remove(
            CServerEntry * pSElocation,
            CInterface * pInf)

/*++

Routine Description:

    Remove an interface from the interface index.
Arguments:

            pSElocation        -    The server entry where the interface occurs
            pInf            -    The new or changed interface

Returns:

    nothing

Remarks:

    Currently, this routine does nothing since we don't know when ALL
    interfaces with a given GUID have been removed from an entry.
    This is harmless since it only means that we may search such an entry
    uselessly for this interface -- a performance problem only.

    N.B. It is a problem if we try to delete the entries in the brodcast
    cache and prevent bloating of locator. Presently this is not the case.

--*/
{
}

void
CInterfaceIndex::removeServerEntry(
            CServerEntry * pSElocation
            )
/*++

Routine Description:

    Remove an interface from the interface index.
Arguments:

            pSElocation        -    The server entry where the interface occurs

Returns:

    nothing

Remarks:

   We will delete all the interface entries in this structure that
   points to this server entry. We do not need to explicitly construct
   the interface structure.

   we can make this structure if we maintain a list of all the interfaces that
   points to this structure.

   N.B. Should change this if performance is a problem.
--*/
{
    CriticalWriter me(rwLock);

    TCSafeSkipListIterator<CInterfaceIndexEntry> iter(InterfaceEntries);
    // Make an iterator for the interfaces.

    for (CInterfaceIndexEntry *ifindx = iter.next(); ifindx;
                           ifindx = iter.next())
        ifindx->remove(pSElocation);
    // for each interface remove the server entry.
    pNullIndex->remove(pSElocation);
}


TSLLEntryList *
CInterfaceIndex::lookup(
            CGUIDVersion    *    pGVInterface
        )
{
    TSLLEntryList * pTrialEntries =  new TSLLEntryList;
    CInterfaceIndexEntry *pIndex = NULL;

    CriticalReader me(rwLock);

    if (!pGVInterface) pIndex = pNullIndex;

    else {
        CGUID InfID(pGVInterface->myGUID());
        pIndex = InterfaceEntries.find(&InfID);
    }

    if (pIndex) {
        TCSafeSkipListIterator<CStringW> iter(pIndex->PossibleEntries);

        /* the reason for splitting full entries and separately inserting NonLocal
           and local entries below is to avoid net lookup for these these
           entries.  Since Index lookup is used exclusively for default
           entry lookup, there is a separate net component to it already.
        */

        for (CStringW *pName = iter.next(); pName; pName = iter.next()) {
            CEntry * pEntry = pMyLocator->findEntry(pName);

            /* NOTE: only full server entries are indexed */

            CFullServerEntry *pfse = (CFullServerEntry *) pEntry;

            if (pfse) {

                ASSERT((pfse->getType() == FullServerEntryType),
                       "Wrong entry type in interface index\n"
                      );

                pTrialEntries->insert(pfse->getLocal());
                pTrialEntries->insert(pfse->getNonLocal());
            }
        }
    }

    return pTrialEntries;
}

/***********************LocToLocCompleteHandle methods*****************/

void
CLocToLocCompleteHandle::StripObjectsFromAndCompress(
        NSI_BINDING_VECTOR_P_T * BindingVectorOut)
/*++

Routine Description:

    The vector of binding handles normally returned from a lookup handle
    contains binding strings with objects (if objects are present).
    However, this is not usable in locator-to-locator communication
    because the old (Steve Zeck's) locator expects objectless
    strings and simply attaches objects in front of the strings it gets
    from a master.  We therefore strip the objects from these strings
    when they are meant to be returned to another locator.  This also
    gives us an opportunity to eliminate duplicates, which is important
    because an object inquiry must be done via RPC for every binding
    string returned to the inquiring locator as a result of the weakness
    of the current locator-to-locator interface.

    Duplicates where eliminated before only in the returned vector. Because
    only the string bindings are returned, there can be duplicates across the
    various binding vectors returned. But these duplicates come together. Hence
    the last returned binding is maintained and it is returned only if it
    doesn't match the prev binding.

  // N.B. Order is very important in the BindingVectorOut.

Arguments:

    StatusCode    - the code to test

Returns

    TRUE if normal, FALSE if internal error (such as failure to connect to master locator).

--*/
{
    if (!*BindingVectorOut) return;

    NSI_BINDING_VECTOR_P_T pbvtGivenVector = *BindingVectorOut;

    TCSafeSkipList<CNSBinding> SSLwinnow;

    for (ULONG i = 0; i < pbvtGivenVector->count; i++)
    {
        STRING_T pszOld = pbvtGivenVector->binding[i].string;
        STRING_T pszNew = makeBindingStringWithObject(pszOld,NULL);
        pbvtGivenVector->binding[i].string = CStringW::copyMIDLstring(pszNew);
        midl_user_free(pszOld);
        RpcStringFree(&pszNew);

        CNSBinding *pNSB = new CNSBinding(pbvtGivenVector->binding[i]);
        // checking for bindings that have been sent out before.

        if ((prevBinding) && (pNSB->compare(*prevBinding) == 0))
        {
            delete pNSB;
            continue;
        }

        if (Duplicate == SSLwinnow.insert(pNSB))
            delete pNSB;
        else
        {
            if (prevBinding)
            {
                delete prevBinding;
                prevBinding = NULL;
            }
            prevBinding = new CNSBinding(pbvtGivenVector->binding[i]);
        }
    }

    ULONG ulBVcount = SSLwinnow.size();

    // Remeber that we need to allocate a DWORD for 32 bit platforms and QWORD
    // for 64 bit ones due to structure alignment.
    NSI_BINDING_VECTOR_P_T pbvtNewVector =
            (NSI_BINDING_VECTOR_T *)
            midl_user_allocate(sizeof(UNSIGNED32*) + sizeof(NSI_BINDING_T)*ulBVcount);

   pbvtNewVector->count = ulBVcount;

   TCSafeSkipListIterator<CNSBinding> nsbIter(SSLwinnow);

   CNSBinding* pNSB = nsbIter.next();

   for (ULONG j=0; j < ulBVcount; j++)
   {
         pNSB->copyBinding(pbvtNewVector->binding[j]);
         pNSB = nsbIter.next();
   }

   CBVWrapper destructor(pbvtGivenVector);    // wrap to release
   destructor.rundown();            // run down the pbvtGivenVector

   SSLwinnow.wipeOut();                // release CNSBinding objects

   *BindingVectorOut = pbvtNewVector;
}



/*********************CDSLookupHandle methods*****************************/
#if DBG
    ULONG CDSLookupHandle::ulDSLookupHandleCount = 0;
    ULONG CDSLookupHandle::ulDSLookupHandleNo = 0;
#endif

void
CDSLookupHandle::initialize()
/*++
Method Description: CServerEntry::lookup
    Looks up in the DS for the entryName. If found it keeps in the cache
    and stores the lookup handle by calling the lookup function corresp.
    to the entryname.
Remarks:

--*/
{
    CEntry    *pEntry=NULL;

    fNotInitialized = FALSE;

    pEntry = GetEntryFromDS(
            RPC_C_NS_SYNTAX_DCE,
            (STRING_T)(*penEntryName)
            );
    if (pEntry)
    {
        pRealHandle = pEntry->lookup(pgvInterface, pgvTransferSyntax, pidObject,
                                ulVS, ulCacheMax);
    }
    else
        pRealHandle = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\respond.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    respond.cxx

Abstract:

	This file contains the code for responding to broadcasts from
	name service clients looking for a locator service.  This includes

    1.  implementations of two member functions of class Locator

    2.  a listener thread

Author:

    Satish Thatte (SatishT) 08/21/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>



void
Locator::respondToLocatorSeeker(
		IN QUERYLOCATOR		Query
		)
{

	// first see if we should reply at all

    // ignore messages to self. A request on a group mailslot
    // will be delivered to the local slot too.

	STRING_T szRequester;	  // name without whacks

	if (hasWhacksInMachineName(Query.RequesterName))
		szRequester = Query.RequesterName+2;
	else szRequester = Query.RequesterName;


	if (IsSelf(szRequester)) return;

    // closing a possible security hole.
    if (szRequester[0] == L'?') return;

	// OK, now see if the request fits our status

	switch (Query.MessageType) {

	  case QUERY_MASTER_LOCATOR:
		  if (!IsInMasterRole()) return;
		  else break;

	  case QUERY_BOUND_LOCATOR:
	  case QUERY_ANY_LOCATOR:
		  break;

	  case QUERY_DC_LOCATOR:
		  if (!(IsInDomain() && (IsInMasterRole() || IsInBackupRole())))
		     return;
		  else break;

	  default:
		  DBGOUT(BROADCAST, "Bogus Query MsgType=" << Query.MessageType << "\n\n");
		  return;
	};

	// OK, looks like we are going to reply

	QUERYLOCATORREPLY Reply;

   // fill in our name and other items

	wcscpy(Reply.SenderName,TEXT("\\\\"));
	wcscpy(Reply.SenderName+2,*myRpcLocator->getComputerName());

	Reply.Uptime = CurrentTime() - StartTime;

	if (IsInMasterRole())
	   Reply.Hint = REPLY_MASTER_LOCATOR;

	else if (IsInDomain() && IsInBackupRole())
		Reply.Hint = REPLY_DC_LOCATOR;

	else Reply.Hint = REPLY_OTHER_LOCATOR;

    // create the return Mailslot

	STRING_T sz = catenate(TEXT("\\\\"),szRequester);
	WRITE_MAIL_SLOT MSReply(sz, RESPONDERMSLOT_C);
 	delete [] sz;

	// and write the reply

	MSReply.Write((char *) &Reply, sizeof(Reply));

}


void
Locator::TryBroadcastingForMasterLocator(
                        )
{
	QUERYLOCATOR Query;
	QUERYLOCATORREPLY QueryReply;

	if (!hMasterFinderSlot) {
		return;
	}

	Query.SenderOsType = OS_NTWKGRP;
	Query.MessageType  = QUERY_MASTER_LOCATOR;

	STRING_T myName = catenate(TEXT("\\\\"),*myRpcLocator->getComputerName());
	wcscpy(Query.RequesterName,myName);
	delete [] myName;

    csMasterBroadcastGuard.Enter();

	__try {
	
		WRITE_MAIL_SLOT BSResponder(NULL,RESPONDERMSLOT_S);

		BSResponder.Write((char *) &Query, sizeof(Query));

		ULONG waitCur = INITIAL_MAILSLOT_READ_WAIT; // current wait time for replies

		long cbRead = 0;

		while (cbRead = hMasterFinderSlot->Read((char *) &QueryReply,
													  sizeof(QueryReply),
													  waitCur
													 )
			  )
		{
			if (
				(QueryReply.Hint == REPLY_MASTER_LOCATOR) ||
				(QueryReply.Hint == REPLY_DC_LOCATOR)
			   )
			{
				addMaster(QueryReply.SenderName + 2);
			}

				// halve the wait period everytime you get a response from the net

			waitCur >>= 1;
		}
	}

	__finally {
		csMasterBroadcastGuard.Leave();
	}
}


void
ResponderProcess(void*)		
/*++

Routine Description:

    This thread creates a mailslot and listens for requests for locators,
	responding if appropriate.

--*/
{
    QUERYLOCATOR LocatorQuery;

	DWORD dwMailSize;

    // create a server (s) mailslot

    READ_MAIL_SLOT hMailslotForQueries(RESPONDERMSLOT_S, sizeof(QUERYLOCATOR));

    while (1) {

		dwMailSize = hMailslotForQueries.Read(
								(char *) &LocatorQuery,
								sizeof(QUERYLOCATOR),
								MAILSLOT_WAIT_FOREVER
								);

		CriticalReader  me(rwLocatorGuard);
		// after mailslot recv's a message, take a locator
		// lock.
		if (dwMailSize != sizeof(QUERYLOCATOR))
			continue;	   // strange query, ignore it

		DBGOUT(BROADCAST, LocatorQuery.RequesterName  << " sent query for locator"  << "\n\n");

		myRpcLocator->respondToLocatorSeeker(LocatorQuery);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\service.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    locator.cxx

Abstract:

    This file contains server initialization and other RPC control
    functions.  It also supplies all the necessities for running the
    locator as a system service, including the main service thread
    and service control functionality.

Author:

    Satish R. Thatte -- 9/14/1995     Created all the code below except where
                                      otherwise indicated.

Adding code here to create a seperate thread informing scm that it is alive
to protect it from the vagaries of other processes.


--*/

#include <ntrtl.h>
#include <locator.hxx>

typedef long NTSTATUS;

ULONG StartTime;                        // time the locator started

unsigned long LocatorCount;
 
CReadWriteSection rwLocatorGuard;

SERVICE_STATUS ssServiceStatus;
SERVICE_STATUS_HANDLE sshServiceHandle;


Locator *myRpcLocator;                  // the primary state of the locator
CReadWriteSection rwEntryGuard;         // single shared guard for all local entries
CReadWriteSection rwNonLocalEntryGuard; // single shared guard for all NonLocal entries
CReadWriteSection rwFullEntryGuard;     // single shared guard for all full entries
CPrivateCriticalSection csBindingBroadcastGuard;
CPrivateCriticalSection csMasterBroadcastGuard;

CPrivateCriticalSection csLocatorInitGuard;
BOOL fLocatorInitialized;
BOOL fDC;

void QueryProcess(void*);
void ResponderProcess(void*);
void InformStatus(void*);


HANDLE hHeapHandle;

#if DBG
CDebugStream debugOut;       // this carries no state
#endif

unsigned char ** ppszDomainName; // name of current domain

/* this is used by Steve's switch processing code */

int fService = TRUE;                    // running as a service
long waitOnRead = 3000L;                // time to wait on reading reply back
int fNet = 1;                           // enable network functionality
DWORD maxCacheAge;                      // ignored for now -- look in class Locator
char * pszOtherDomain;                  // ASCII other domain to look.
char * pszDebugName = "locator.log";    // debug log file name
int debug = -1;                         // debug trace level

SwitchList aSwitchs = {

    {"/debug:*",               ProcessInt, &debug,},
    {"/logfile:*",             ProcessChar, &pszDebugName,},
    {"/expirationage:*",       ProcessLong, &maxCacheAge,},
    {"/querytimeout:*",        ProcessLong, &waitOnRead,},
    {"/noservice",             ProcessResetFlag, &fService,},
    {"/nonet",                 ProcessResetFlag, &fNet,},
    {"/otherdomain:*",         ProcessChar, &pszOtherDomain,},
    {0}
};

/* end of items for Steve's switch processing code */

void WaitForDomainChange()
{
	HANDLE hDomainChangeHandle = NULL;

	if (!NetRegisterDomainNameChangeNotification(&hDomainChangeHandle)) {
		// user is not informed of this.
		return;
	}

	while (1) {
		WaitForSingleObject(hDomainChangeHandle, INFINITE);
                DBGOUT(DIRSVC, "Domain Change Occured. Getting New global information\n");
		CriticalWriter  me(rwLocatorGuard);

		delete myRpcLocator;
		myRpcLocator = new Locator;
		LocatorCount++;
	}
}

void InitializeLocator()
/*++

Routine Description:

     non critical initialization code

--*/
{
    HANDLE pThreadHandle;
    unsigned long ThreadID;

    csLocatorInitGuard.Enter();

    if (!fLocatorInitialized)
    {
        // Initialize the global locator object, sets the fNT4Compat flag
        // used in StartServer

        myRpcLocator = new Locator;

        if (myRpcLocator->fNT4Compat) {
            RPC_STATUS result;

            // NT4 Mode is dangerous.  We should at least cause some debugger spew to
            // warn the user.
            OutputDebugString(TEXT("RPC: Security Warning: The locator service is initialized in NT4 mode. \
                              The service may be vulnerable while in compatibility mode.\n"));

            // register the LoctoLoc interface only if NT4Compat
            if (result = RpcServerRegisterIf2(LocToLoc_ServerIfHandle,
                                  0,
                                  0,
                                  0,
                                  RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                  LocToLoc_MaxRpcSize,
                                  NULL))
                StopLocator("RpcServerRegisterIf\n", result);
            
            pThreadHandle = CreateThread(0, 0,
                (LPTHREAD_START_ROUTINE) QueryProcess, NULL, 0, &ThreadID);
            
            if (!pThreadHandle)
                StopLocator("CreateThread Failed\n", 0);

            CloseHandle(pThreadHandle);
            
            pThreadHandle = CreateThread(0, 0,
                (LPTHREAD_START_ROUTINE) ResponderProcess, NULL, 0, &ThreadID);
            
            if (!pThreadHandle)
                StopLocator("CreateThread Failed\n", 0);

            CloseHandle(pThreadHandle);
        }
        
        pThreadHandle = CreateThread(0, 0,
            (LPTHREAD_START_ROUTINE) WaitForDomainChange, NULL, 0, &ThreadID);
        
        if (!pThreadHandle)
            StopLocator("CreateThread Failed\n", 0);
        
        CloseHandle(pThreadHandle);

        fLocatorInitialized = TRUE;
    }

    csLocatorInitGuard.Leave();
}

void
StopLocator(
    IN char * szReason,
    IN long code
    )
/*++

Routine Description:

    Die a graceful death

Arguments:

    szReason - Text message for death

    code - option error code

--*/
{
    ssServiceStatus.dwCurrentState = SERVICE_STOPPED;

    if (code) {
        ssServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        ssServiceStatus.dwServiceSpecificExitCode = code;
    }
    else ssServiceStatus.dwWin32ExitCode = GetLastError();

    if (fService && sshServiceHandle)
        SetSvcStatus();

    ExitProcess(code);
}

void
SetSvcStatus(
   )
/*++

Routine Description:

    Set the lanman service status.

--*/
{
    ASSERT(sshServiceHandle,"NT Service Handle Corrupted\n");

    if (! SetServiceStatus( sshServiceHandle, &ssServiceStatus))
        StopLocator("SetServiceStatus Failed\n", 0);
    ssServiceStatus.dwCheckPoint++;
}


void
StartServer(
    )

/*++

Routine Description:

    Call the runtime to create the server for the locator, the runtime
    will create it own threads to use to service calls.

Returns:

    Never returns.

--*/
{
    RPC_STATUS result;
    NT_PRODUCT_TYPE Type;
    BOOL b;

    //
    // The locator interfaces may only be called remotely
    // on a DC.  We will check for each call whether the call is local
    // if the machine is not a DC.
    //

    fDC = FALSE;

    b = RtlGetNtProductType(&Type);
    ASSERT(b, TEXT("RtlGetNtProductType failed"));
    if (!b)
        StopLocator("RtlGetNtProductType\n", GetLastError());

    if (Type == NtProductLanManNt)
        {
        fDC = TRUE;
        }

    if (result = RpcServerRegisterIf2(NsiS_ServerIfHandle,
                                  0,
                                  0,
                                  0,
                                  RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                  NsiS_MaxRpcSize,
                                  NULL))
        StopLocator("RpcServerRegisterIf\n", result);

    if (result = RpcServerRegisterIf2(NsiC_ServerIfHandle,
                                  0,
                                  0,
                                  0,
                                  RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                  NsiC_MaxRpcSize,
                                  NULL))
        StopLocator("RpcServerRegisterIf\n", result);

    if (result = RpcServerRegisterIf2(NsiM_ServerIfHandle,
                                  0,
                                  0,
                                  0,
                                  RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                  NsiM_MaxRpcSize,
                                  NULL))
        StopLocator("RpcServerRegisterIf\n", result);

    // setting the permissions to evryone read/write and owner full control, the default 
    // RPC secuiry for named pipes.

    if (result = RpcServerUseProtseqEp(TEXT("ncacn_np"),    // use named pipes for now
                                       RPC_NS_MAX_CALLS,
                                       TEXT("\\pipe\\locator"),
                                       NULL 
                                       ))
        {
        StopLocator("RpcServerUseProtseqEp Pipe\n", result);
        }


    if (result = RpcServerListen(
                1,                  // min call threads
                RPC_NS_MAX_THREADS, // max call threads
                1                   // don't wait yet
                ))
        StopLocator("RpcServerListen Failed\n", result);

    DBGOUT(BROADCAST, "Started up the server\n");
}



void __stdcall
LocatorControl(
    IN DWORD opCode      // function that we are to carry out.
   )
/*++

Routine Description:

    This function responses the service control requests.

Arguments:

    opCode - Function that we are to carry out.

--*/
{
    RPC_STATUS status;

    switch(opCode) {

        case SERVICE_CONTROL_STOP:

            // Announce that the service is shutting down
            DBGOUT(BROADCAST, "Rec'd Stop signal\n");
            ssServiceStatus.dwCheckPoint = 0;
            ssServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ssServiceStatus.dwWaitHint = 90000;
            SetSvcStatus();

            // we need to tell SCM that we are trying to shut down before doing so.
            status = RpcMgmtStopServerListening(0);
            DBGOUT(BROADCAST, "Stopped listening\n");
            return;


        case SERVICE_CONTROL_INTERROGATE:
            // Do nothing; the status gets announced below
            break ;

    }
    SetSvcStatus();
}

#define MAXCOUNTER 120

void
LocatorServiceMain(
    DWORD   argc,
    LPTSTR  *argv
   )
/*++

Routine Description:

    This is main function for the locator service.
    When we are started as a service, the service control creates a new
    thread and calls this function.

Arguments:

    argc - argument count

    argv - vector of argument pointers

--*/
{

    // Set up the service info structure to indicate the status.

    fLocatorInitialized = FALSE;

    ssServiceStatus.dwServiceType        = SERVICE_WIN32;
    ssServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    ssServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP;
    ssServiceStatus.dwWin32ExitCode      = 0;
    ssServiceStatus.dwCheckPoint         = 0;
    ssServiceStatus.dwWaitHint           = 30000;

    // Set up control handler

    LocatorCount = 0;

    if (! (sshServiceHandle = RegisterServiceCtrlHandler (
           TEXT("rpclocator"), LocatorControl)))
        StopLocator("RegisterServiceCtrlHandler Failed\n", 0);

    SetSvcStatus();
    myRpcLocator = NULL;

    // Start the RPC server
    SetSvcStatus();
    StartServer();

    ssServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetSvcStatus();

    RpcMgmtWaitServerListen();  // OK, wait now

    DBGOUT(BROADCAST, "Deleting myRpcLocator\n\n");
    delete myRpcLocator;

    DBGOUT(MEM2, CRemoteLookupHandle::ulHandleCount << " CRemoteLookupHandles Leaked\n\n");

    DBGOUT(MEM2, CRemoteObjectInqHandle::ulHandleCount << " CRemoteObjectInqHandles Leaked\n\n");

    DBGOUT(MEM1, CCompleteHandle<NSI_BINDING_VECTOR_T>::ulHandleCount
                << " Complete Binding Handles Leaked\n\n");

    DBGOUT(MEM1, CCompleteHandle<GUID>::ulHandleCount
                << " Complete Object Handles Leaked\n\n");


    DBGOUT(BROADCAST, "Calling CoUninitialize\n\n");

    ssServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ssServiceStatus.dwCheckPoint = 0;
    SetSvcStatus();
}

int __cdecl
main (
   IN int cArgs,
   IN char* *pszArgs
   )
/*++

Routine Description:

    Entry point for the locator server, Initialize data
    structures and start the various threads of excution.

Arguments:

    cArgs - number of argument.

    pszArgs - vector of arguments.

--*/
{
    int Status = 0;

    myRpcLocator = NULL;        // initialize the state later in LocatorServiceMain

    hHeapHandle = GetProcessHeap();

    static SERVICE_TABLE_ENTRY ServiceEntry [] = {
       {TEXT("rpclocator"), (LPSERVICE_MAIN_FUNCTION) LocatorServiceMain},  // only entry item
       {NULL,NULL}                                                          // end of table
    };

    StartTime = CurrentTime();

    char * badArg = ProcessArgs(aSwitchs, ++pszArgs);

    // Bail out on bad arguments.

    if (badArg) {
        char Buffer[200];
        fService = FALSE;
        strcpy(Buffer,"Command Line Error: ");
        strcat(Buffer, badArg);
        StopLocator(Buffer, 0);
    }

    if (!fService) {
        // Initialize the global locator object
        DBGOUT(BROADCAST, "Not running as a service\n");
        myRpcLocator = new Locator;
        StartServer();                  // this doesn't wait
        RpcMgmtWaitServerListen();      // OK, wait now
    }

    // else call (give this thread to) the service controller
    else StartServiceCtrlDispatcher(ServiceEntry);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\simplell.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    simpleLL.cxx

Abstract:

	This module contains definitions of non inline member functions for the
	CSimpleLinkList class, which is a linked list without reference counting.
	
Author:

    Satish Thatte (SatishT) 11/20/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>


void* 
CSimpleLinkList::pop() 

/*++
Routine Description:

	Delete first item in the CSimpleLinkList and return it
	
--*/

{
	if (!pLnkFirst) return NULL;
		
	void* result = pLnkFirst->data;
	Link* oldFirst = pLnkFirst;
	pLnkFirst = pLnkFirst->next;
	if (!pLnkFirst) pLnkLast = NULL;  // nothing left
	delete oldFirst;

	lCount--;
	return result;
}
		

void* 
CSimpleLinkList::nth(long lOrdinal)

/*++
Routine Description:

	Simply return the Nth data item -- starting the count at 0.
	
--*/

{
	if (!pLnkFirst) return NULL;			// empty list

	Link * pLnkCurr = pLnkFirst;
	long lCount = 0;

	while (pLnkCurr && (lCount++ < lOrdinal))
		pLnkCurr = pLnkCurr->next;

	if (!pLnkCurr) return NULL;			// not found
	else return pLnkCurr->data;
}

void 
CSimpleLinkList::rotate(long lDegree)

/*++
Routine Description:

	This routine imagines that the list is in fact circular and 
	rotates it by lDegree -- using pop and enque for modularity.  
	We could actually move links around, but this operation is
	not frequent enough (once for every NS lookup). Here we pay the
	price of not having a true circular list (we moved away from
	the true circular list for ref counting).
	
--*/

{
	if (!pLnkFirst) return;	// nothing to rotate;

	void *pCurr;

	for (long i = 0; i < (lDegree % lCount); i++) {
		pCurr = pop();
		enque(pCurr);
	}
}


	
void CSimpleLinkList::clear() {		// deletes all links but not the data

	Link * pLnkCurr = pLnkFirst; 

	while (pLnkCurr) 
	{
		Link * pLnkDel = pLnkCurr;
		pLnkCurr = pLnkCurr->next;
		delete pLnkDel;
	}

	pLnkFirst = pLnkLast = NULL; 
}



void* 
CSimpleLinkListIterator::next() {	// advance the iterator and return next void

		if (!ptr) return NULL;

		void* result = ptr->data;
		ptr = ptr->next;
		return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\switch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       switch.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
		   Copyright(c) Microsoft Corp., 1990

	This file contains a class definition for switch processing

		  This is taken practically unchanged from the RPC locator 
            written by Steven Zeck

-------------------------------------------------------------------- */

#include <locator.hxx>

#define RpcStrdup strdup
#define TRUE 1
#define FALSE 0


#define USED(arg) ((void)(arg))

int TailMatch( char * pszPatt, char * pszIn);

char *ProcessArgs(
SwitchList aSLCur,
char **aArgs

  // Process a list of arguments
) //-----------------------------------------------------------------------//
{
   char * pszArgCur, *pszParm;

    for (; *aArgs; aArgs++) {

	for (SWitch *pSW = aSLCur; pSW->name; pSW++) {

	   pszArgCur = *aArgs;
	   pszParm = pSW->name;

	   while (*pszParm) {

		if (*pszParm == '#') {

		    // optional space between flag and argument

		    if (!*pszArgCur) {
			pszArgCur = *(++aArgs);

			if (!pszArgCur)
			    return(aArgs[-1]);
		    }

		    if (TailMatch(pszParm, pszArgCur))
			goto found;
		}

		else if (*pszParm == '*') {

		   // no space allowed between flag and argument

		    if (*pszArgCur && TailMatch(pszParm, pszArgCur))
			goto found;

		    break;

		}
		else {

		     // do a case insensitive compare, pattern is always lower case

		      if (*pszArgCur >= 'A' && *pszArgCur <= 'Z') {
			 if ((*pszArgCur | 0x20) != *pszParm)
			    break;
		      }
		      else if (*pszArgCur != *pszParm)
			   break;

		    pszArgCur++; pszParm++;

		    if (! *pszArgCur && !*pszParm)
		       goto found;
		}
	    }
	}

	return(*aArgs);		// parm in error

found:
	if ((*pSW->pProcess)(pSW, pszArgCur))
	    return(*aArgs);

    }
    return(0);	// sucess all parms matched

}



int TailMatch(		// match substrings from right to left *^
char * pszPatt,		// pattern to match
char * pszIn			// input pszInint to match

 //compare a tail pszPatt (as in *.c) with a pszIning.  if there is no
 //tail, anything matches.  (null pszInings are detected elsewhere)
 //the current implementation only allows one wild card
)//-----------------------------------------------------------------------//
{
    register char * pszPattT = pszPatt;
    register char * pszInT = pszIn;

    if (pszPattT[1] == 0)  /* wild card is the last thing in the pszPatt, it matches */
	return(TRUE);

    while(pszPattT[1]) pszPattT++;    // find char in front of null in pszPatt

    while(pszInT[1]) pszInT++;	    // find char in front of null in pszIning to check

    while(1) {			    // check chars walking towards front

	// do a case insensitive compare, pattern is always lower case

	if (*pszInT >= 'A' && *pszInT <= 'Z') {
	    if ((*pszInT | 0x20) != *pszPattT)
		return (FALSE);
	}
	else if (*pszInT != *pszPattT)
	    return(FALSE);

	pszInT--;
	pszPattT--;

	/* if we're back at the beginning of the pszPatt and
	 * the pszIn is either at the beginning (but not before)
	 * or somewhere inside then we have a match. */

	if (pszPattT == pszPatt)
	    return(pszInT >= pszIn);

    }
    return(FALSE);
}

int ProcessInt(		// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    for (char * psz=pszText; *psz; ++psz)
	if (*psz < '0' || *psz > '9')
	    return(TRUE);

    *(int *)pSW->p = atoi(pszText);
    return(FALSE);
}


int ProcessLong(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    for (char * psz=pszText; *psz; ++psz)
	if (*psz < '0' || *psz > '9')
	    return(TRUE);

    *(long *)pSW->p = atol(pszText);
    return(FALSE);
}

int ProcessChar(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
//   if (*(char * *)pSW->p)	// can only set char *'s once
//	return(TRUE);

	int size = strlen(pszText) + 1;
	*(char * *)pSW->p = new char[size];
    strcpy(*(char * *)pSW->p,pszText);
    return(FALSE);
}


int ProcessSetFlag(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    USED(pszText);

    *(int *)pSW->p = TRUE;
    return(FALSE);
}


int ProcessResetFlag(	// Set a flag numeric value *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    USED(pszText);

    *(int *)pSW->p = FALSE;
    return(FALSE);
}


int ProcessYesNo(	// Set a flag numeric value, either Yes or No *^
SWitch *pSW,		// pSW to modify
char * pszText		// pointer to number to set
)/*-----------------------------------------------------------------------*/
{
    *(int *)pSW->p = (*pszText | 0x20) == 'y';
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\skiplist.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    skiplist.cxx

Abstract:

	This module contains definitions of non inline member functions for the
	CSkipList class, which implements skiplists with reference counted links.	
	
Author:

    Satish Thatte (SatishT) 08/16/95  Created all the code below except where
									  otherwise indicated.

--*/

#if DBG
char * CSListName = "CSkipList";
char * CSLinkName = "CSkipLink";
#endif

#include <locator.hxx>


// the regular constructor

CSkipList::CSkipLink::CSkipLink(IOrderedItem * d, short l) : data(d) {

			next = new CSkipLink* [levels = l];
			for (short i = 0; i < l; i++ ) next[i] = NULL;
			fDeleteData = FALSE;
}
		
// resizing constructor

CSkipList::CSkipLink::CSkipLink(CSkipLink * old, short newSize) {
	
			next = new CSkipLink* [levels = newSize];
			data = old->data;
			fDeleteData = old->fDeleteData;

			ASSERT((levels > old->levels), "Skip List Levels Incorrect\n");

			for (short i = 0; i < old->levels; i++ )
				next[i] = old->next[i];
			
			// if we are resizing, there had better be a next
			ASSERT(next[0], "Resizing a single-item Skip List\n");	
			next[0]->hold();	// to counteract the release in old

			for ( i = old->levels; i < levels; i++ ) next[i] = NULL;

			old->release();
}
		
CSkipList::CSkipLink::~CSkipLink() {

			if (next[0]) next[0]->release();

			delete [] next;

			if (fDeleteData)
				delete data;
}


	
CSkipList::CSkipList() {
	count = 0;
	maxlevel = 1;  // initial max level
	maxcount = 2;
	pLnkFirst = NULL;
}



void CSkipList::wipeOut()

/*++
Routine Description:

	release all SkipLinks and all data and reinitialize to empty list
	
--*/

{
	if (pLnkFirst) {

		CSkipLink *pLnkCurr = pLnkFirst;

		do {
		  pLnkCurr->fDeleteData = TRUE;
		  pLnkCurr = pLnkCurr->next[0];
		} while (pLnkCurr);

		releaseAll(pLnkFirst);	// release as many links as you can,
								// and do it iteratively for robustness
		pLnkFirst = NULL;
		count = 0;
	}
}



IOrderedItem *CSkipList::find(IOrderedItem * d)

/*++
Routine Description:

	Find a matching item in the CSkipList and return it
	An IOrderedItem given as argument is the key, and the item
	returned may be an object of a class derived from the key type.
	
	This routine uses a goto and uses the raw compare function,
	because the performance of this routine is important, and it is
	especially important to avoid unnecessary comparisons
	
--*/

{
	CSkipLink *temp = NULL, *pLink = pLnkFirst;
	
	if (!pLnkFirst) return NULL;	// empty list

	int comparison = pLnkFirst->data->compare(*d);

	if (comparison > 0) return NULL; // no chance
	if (comparison == 0) return pLnkFirst->data;
		
	for (short cLvl = maxlevel-1 ; cLvl >= 0 ; cLvl-- ) {
		while(temp = pLink->next[cLvl]) {
			int comparison = temp->data->compare(*d);
			if (comparison == 0) return temp->data;
			if (comparison > 0) goto cont;
			else pLink = temp;	// comparison < 0
		}
cont:;
	}
	
	return NULL;
}

IOrderedItem *CSkipList::pop()
/*++

Routine Description:

	Remove and return the first item in the CSkipList
		
	
Returns:  the removed item if any, NULL, otherwise.

--*/

{
	short cLvl;

	if (!pLnkFirst) return NULL;
	
	IOrderedItem *lpRetval = pLnkFirst->data;

	CSkipLink *temp = NULL;

	/* If there is a second item, we copy the second into the first
	   so as to preserve the max size of the first node, as well as
	   its links at higher levels which the second link may lack
	*/
		
	if (temp = pLnkFirst->next[0]) {
			pLnkFirst->data = temp->data;

			ASSERT((pLnkFirst->levels >= temp->levels), "First node in skip list not largest\n");

			/* the next pointers of the second link need to be copied
			   into the first as well, along with the data pointer
			*/
			
			for ( cLvl = temp->levels - 1; cLvl >= 0; cLvl-- ) {
				pLnkFirst->next[cLvl] = temp->next[cLvl];
			}

			if (temp->next[0])

			// this hold counteracts the following release

				temp->next[0]->hold();
			
			temp->release();
	}
	else {	// we are removing the only item in the list
			pLnkFirst->release();
			pLnkFirst = NULL;
	}
	
	count--;

	return lpRetval;
}

IOrderedItem *CSkipList::remove(IOrderedItem * d)

/*++
Routine Description:

	Remove and return a matching item in the CSkipList.
	An IOrderedItem given as argument is the key, and the item
	to be removed may be an object of a class derived from the key type.
	
	This routine uses ordinary relational operators.  It is
	not as efficient as it could be if it used the raw compare
	function, but relational operators make it more readable.
	Since remove operations are infrequent, the small extra
	cost in performance does not matter.
	
	RETURNS:  the removed item if any, NULL, otherwise
--*/

{
	ASSERT(d, "Attempt to remove a null object in skip list\n");

	if (!pLnkFirst || (*(pLnkFirst->data) > *d)) return NULL; // no chance

	ASSERT(pLnkFirst->levels == maxlevel, "Wrong size for first skiplist node\n");	// always holds

	/* Is this a special case: remove the first item? */

	if (*(pLnkFirst->data) == *d) return pop();	

	/* Otherwise our first task is to find the item to be removed.
	   pLink will track the link prior to the one being removed
	*/
	 		
	CSkipLink *temp = NULL, *pLink = pLnkFirst;
	
	short cLvl;

	IOrderedItem *lpRetval = NULL;
	
	for ( cLvl = maxlevel-1 ; cLvl >= 0 ; cLvl-- ) {
		
		while ((temp = pLink->next[cLvl]) && (*(temp->data) < *d))
			pLink = temp;
		
		if (temp && (*(temp->data) == *d)) {
			lpRetval = temp->data;
			break;
		}
	}

	/* Check if we found something, or came to the end of the rope */
			
	if (cLvl < 0) return NULL; // end of the rope, nothing found

	/* now we can allocate the threading array */

	CSkipLink **ppSLthreads = new CSkipLink* [maxlevel];
	ppSLthreads[cLvl] = pLink;

	short findLvl = cLvl;
	CSkipLink * pFindLink = temp;

	/* Now that we found the link to be removed, we need to find its
	   predecessors at every level, so that they can be relinked
	*/
	
	for ( cLvl-- ; cLvl >= 0 ; cLvl-- ) {

		while ((temp = pLink->next[cLvl]) && *(temp->data) < *d)
			pLink = temp;
		
		ppSLthreads[cLvl] = pLink;
	}

	/* relink, release, and be done */

	for ( cLvl = findLvl; cLvl >= 0; cLvl-- ) {
		ppSLthreads[cLvl]->next[cLvl] = pFindLink->next[cLvl];
	}

	if (pFindLink->next[0]) pFindLink->next[0]->hold();

	// the preceding hold counteracts the following release

	pFindLink->release();

	delete [] ppSLthreads;

	count--;

	return lpRetval;
}



SkipStatus CSkipList::insert(IOrderedItem * d)

/*++
Routine Description:

	Insert the IOrderedItem into the CSkipList.  The CSkipList will
	adjust its maxlevels member as necessary.  The algorithm is
	probabilistic -- the size of the new CSkipLink is decided
	by using a random number.
	
	This routine uses ordinary relational operators.  It is
	not as efficient as it could be if it used the raw compare
	function, but relational operators make it more readable.
	Since remove operations are infrequent, the small extra
	cost in performance does not matter.
	
	The routine assumes that srand has been called to initialize
	the random number generator.
	
--*/

{
	if (!pLnkFirst) {
			
	/* if this is the only data item in the list then we must use maxlevel for node
	   size which may be greater than 1 if the list had stuff which got removed */
		
		pLnkFirst = new CSkipLink(d,maxlevel);
	}
	
	else {

		ASSERT(pLnkFirst->levels == maxlevel, "Wrong size for first skiplist node\n");	// must always hold
	
		if (*(pLnkFirst->data) > *d)
			
		/*  new data is smallest -- swap with first
			and pretend we are inserting previous first.
			This is not the most efficient way, but for
			this special case, the extra code isn't worth it
		*/
		
			swapThem(pLnkFirst->data,d);
		
		CSkipLink *pLink = pLnkFirst, *temp = NULL;
	
		/*	The array below is used to hold the nodes that need to be
			threaded with the new CSkipLink	*/
	
		CSkipLink **ppSLthreads = new CSkipLink* [maxlevel];

		short cLvl;

		/*	We now find the threading points by a process very similar to
			the search process in find	*/
		
		for ( cLvl = maxlevel - 1 ; cLvl >= 0 ; cLvl-- ) {
		
			while((temp = pLink->next[cLvl]) && *(temp->data) <= *d)
				pLink = temp;
			
			if (*(pLink->data) == *d) {
				delete [] ppSLthreads;
				return Duplicate;
			}
			else ppSLthreads[cLvl] = pLink;
		}
		
		/* now create the new link */

		short size;
		
		ULONG dwRandState = GetTickCount();
		
		for (size = 1 ; size < maxlevel ; size++ )
			if (RandomBit(&dwRandState)) break;

	/*  We get a CSkipLink of the randomly chosen size -- the probability
		of choosing each larger size is half that of the previous size.
		Maxlevel has the residual probability, equal to that for the next
		smaller size.  This is not quite ideal, but good enough for us.
	*/
		
		CSkipLink *pNewLink = new CSkipLink(d,size);

		/*	now thread the new link in */
		
		for ( cLvl = size-1 ; cLvl >= 0 ; cLvl-- ) {
			temp = ppSLthreads[cLvl]->next[cLvl];
			ppSLthreads[cLvl]->next[cLvl] = pNewLink;
			pNewLink->next[cLvl] = temp;
		}
		
		delete [] ppSLthreads;
	}
	
	/*	bump up count and also maxlevel if necessary	*/
	
	if ( ++count > maxcount) {
		
		maxlevel++;

		maxcount <<= 1;	// double the maxcount

	/*  now we need to resize the first node to max size */
		
		pLnkFirst = new CSkipLink(pLnkFirst,maxlevel);

	}
	
	return OK;

}

// void printStats();

void
CSkipList::releaseAll(CSkipLink * pCurr)

/*  The reason why this method doesn't just release pLnkFirst is
    because we must avoid stack overflow caused by a runaway recursive
	release effect.  So we do this iteratively.  We must, however,
	make sure to stop if we hit a link that would not be deleted if
	released because we are releasing the next one only to simulate
    the release that would happen due to deletion of the current link.
*/

{
	CSkipLink *pPrev = NULL;

	/* The invariant for the loop below is that pCurr->ulRefCount
	   is 1 higher than it should be.
	*/

	while (pCurr && pCurr->willBeDeletedIfReleased()) {
		pPrev = pCurr;
		pCurr = pCurr->next[0];
		if (pCurr) pCurr->hold();
		pPrev->release();
	}

	if (pCurr)
		pCurr->release();

	// printStats();
}


IOrderedItem*
CSkipListIterator::next() {	
	
// advance the iterator and return next IDataItem
// continue to hold the link we expect to return next

		if (!ptr) return NULL;
			
		CSkipList::CSkipLink* tl = ptr;

		IOrderedItem* result = ptr->data;
		ptr = ptr->next[0];
		if (ptr) ptr->hold();
		tl->release();
		return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\locator\nsserver\src\utils.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    utils.cxx

Abstract:

	This module contains definitions of miscellaneous utility functions.	
	
Author:

    Satish Thatte (SatishT) 09/20/95  Created all the code below except where
									  otherwise indicated.

--*/

#include <locator.hxx>


BOOL
hasWhacksInMachineName(
	STRING_T szName
	)
/*++

Routine Description:

    Check if machine name has "\\" at the beginning.

Returns:

    TRUE if "\\" present, FALSE otherwise.

--*/
{
	if ((*szName == L'\\') && (*(szName+1) == L'\\'))	return TRUE;
	else return FALSE;
}



unsigned long
CurrentTime (
    )
/*++

Routine Description:

    Return the current time in seconds.

Returns:

    The time.

--*/
{
    ULONG time;

    // QUERY the current time; and return the time since service start in seconds.

    time = GetCurrentTime();

    return((time-StartTime)/1000);
}


BOOL
IsStillCurrent(
		ULONG ulCacheTime,
		ULONG ulTolerance
		)
/*++

Routine Description:

    Determines if a cache creation time is still "current" based on a tolerance
	level for staleness. All time values are in seconds.

Arguments:

	ulCacheTime	- cache creation time
	ulTolerance	- staleness tolerance

Returns:

    TRUE if current, FALSE otherwise

--*/
{

	ULONG ulCurrent = CurrentTime();

	DBGOUT(UTIL, "IsStillCurrent: ulCacheTime = " << ulCacheTime << WNL);
	DBGOUT(UTIL, "IsStillCurrent: ulTolerance = " << ulTolerance << WNL);
	DBGOUT(UTIL, "IsStillCurrent: ulCurrent = " << ulCurrent << "\n\n");

	/* the next statement is basically a kludge to get around the fact that
	   rpc_c_ns_default_exp_age is -1 which, as a ULONG is 0xffffffff
	   so that ulTolerance + CACHE_GRACE wraps around to CACHE_GRACE - 1
	   for the default tolerance!
	*/
	
	if (ulTolerance + CACHE_GRACE < CACHE_GRACE)	// ulTolerance wrap around
		return TRUE;

	if (
		(ulCurrent - ulCacheTime) > (ulTolerance + CACHE_GRACE)  ||
		((long)ulCurrent - (long)ulCacheTime) < 0				// ulCurrent wrap around
	   )
	
	   return FALSE;

	else {
		DBGOUT(UTIL, "IsStillCurrent: YES!\n\n");
		return TRUE;
	}
}


void
AssertHeap()

/*++

Routine Description:

    Checks the state of the current process heap, or of a single
	block in the heap if a non-null block address is provided.

--*/
{
	BOOL valid = HeapValidate(
					hHeapHandle,
					0,					// default: serialize heap access
					NULL				// default: validate the entire heap
					);

	if (!valid) Raise(NSI_S_HEAP_TRASHED);

}

RPC_BINDING_HANDLE
MakeDClocTolocHandle(
		STRING_T pszDCName
		)
/*++

Routine Description:

    Create an RPC binding handle for a locator on the given server

Arguments:

    pszDCName	- name of the server machine

Returns:

    A binding handle.

--*/
{
	RPC_STATUS Status;
	STRING_T pszNetworkAddr = catenate(TEXT("\\\\"),pszDCName);
	STRING_T pszTempBinding;
	RPC_BINDING_HANDLE hResult;

	Status = RpcStringBindingCompose(
					NULL,
					TEXT("ncacn_np"),
					pszNetworkAddr,
					TEXT("\\pipe\\locator"),
					NULL,
					&pszTempBinding
					);

    if (Status != RPC_S_OK)
        {
        delete pszNetworkAddr;
        Raise(NSI_S_DC_BINDING_FAILURE);
        }

	Status = RpcBindingFromStringBinding(
					pszTempBinding,
					&hResult
					);

	delete pszNetworkAddr;
	RpcStringFree(&pszTempBinding);

    if (Status != RPC_S_OK)
        {
        Raise(NSI_S_DC_BINDING_FAILURE);
        }

	return hResult;
}


		

STRING_T
catenate(
	STRING_T pszPrefix,
	STRING_T pszSuffix
	)
/*++

Routine Description:

    Concatenate the two given strings into a new string

Arguments:

	pszPrefix	- prefix of result
	
	pszSuffix	- suffix of result

Returns:

    A newly allocated string.

--*/
{
	long prefixLen = wcslen(pszPrefix);
	long suffixLen = wcslen(pszSuffix);

	STRING_T pszResult = new WCHAR[(prefixLen+suffixLen+1)*sizeof(WCHAR)];
    if (!pszResult)
        return NULL;

	wcscpy(pszResult,pszPrefix);
	wcscpy(pszResult+prefixLen,pszSuffix);
	return pszResult;
}


NSI_SERVER_BINDING_VECTOR_T *
BVTtoSBVT(
	NSI_BINDING_VECTOR_T * pbvt
	)
/*++

Routine Description:

	This function reformulates a NSI_BINDING_VECTOR_T as a
	NSI_SERVER_BINDING_VECTOR_T but does not make copies of
	the string bindings in the process.

--*/
{
	NSI_SERVER_BINDING_VECTOR_T *
		psbvt = (NSI_SERVER_BINDING_VECTOR_T *)
				new char [ sizeof(UNSIGNED32) +
						   sizeof(NSI_STRING_BINDING_T)*(pbvt->count)
						 ];

	psbvt->count = pbvt->count;
	for (UNSIGNED32 i = 0; i < pbvt->count; i++) {
		psbvt->string[i] = pbvt->binding[i].string;
	}

	return psbvt;
}



STRING_T
makeBindingStringWithObject(
			STRING_T binding,
			STRING_T object
			)
/*++

Routine Description:

	Take an existing binding string and replace the object part
	before returning.  The string returned is allocated by RPC
	and must be freed by calling RpcStringFree unless it is an
	out parameter for an RPC call (or a part of such a returned
	value) in which case it is freed by the RPC runtime.

--*/
{
	RPC_STATUS Status;

	/* variables to receive binding decomposition */

	STRING_T ProtSeq;
	STRING_T EndPoint;
	STRING_T NetworkAddr;
	STRING_T NetworkOptions;

	Status = RpcStringBindingParse(
				binding,
				NULL,			// don't need current Object ID
				&ProtSeq,
				&NetworkAddr,
				&EndPoint,			// Don't need endpoint
				&NetworkOptions);

	if (Status != RPC_S_OK)		// corrupted entry?
			Raise(NSI_S_INVALID_STRING_BINDING);

	// The following allocates and creates a new string

	// N.B.  for now we keep the endpoint to be compatible with
	// the old locator, but the endpoint really should be removed

	STRING_T tempBinding = NULL;
	
	Status = RpcStringBindingCompose(
						object,
						ProtSeq,
						NetworkAddr,
						EndPoint,			
						NetworkOptions,
						&tempBinding
						);

	RpcStringFree(&ProtSeq);
	RpcStringFree(&EndPoint);
	RpcStringFree(&NetworkAddr);
	RpcStringFree(&NetworkOptions);

    if (Status != RPC_S_OK)		// must be out of memory
        {
        Raise(NSI_S_OUT_OF_MEMORY);
        }

	return tempBinding;

}


void
I_NSI_NS_HANDLE_T_rundown(
    IN NSI_NS_HANDLE_T InqContext
    )
/*++

Routine Description:

    Cleanup after an a lookup operation.  Internal version.

Arguments:

    InqContext - Context to cleanup

--*/
{
    if (!InqContext) {
        DBGOUT(MEM1, "RunDown::InqContext is NULL\n");
        return;
    }

	CContextHandle *pHandle = (CContextHandle *) InqContext;

	__try {
		
		pHandle->rundown();
	}
	__finally {

		delete pHandle;
	}

}


void NSI_NS_HANDLE_T_done(
	/* [out][in] */ NSI_NS_HANDLE_T __RPC_FAR *inq_context,
    /* [out] */ UNSIGNED16 __RPC_FAR *status)
/*++

Routine Description:

    A generalized version of the "done" operation for NS context handles.

Arguments:

	inq_context	- context handle the client is done with
	
	status	- status is returned here

--*/
{
	*status = NSI_S_OK;

	if (*inq_context)

		__try {
			
		   I_NSI_NS_HANDLE_T_rundown(*inq_context);
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			*status = (UNSIGNED16) GetExceptionCode();
		}

	*inq_context = NULL;
}


void __RPC_API
NSI_NS_HANDLE_T_rundown(
    IN NSI_NS_HANDLE_T InqContext
    )
/*++

Routine Description:

    Cleanup after an aborted lookup operation.
	This is the one called directly by RPC runtime when needed.

Arguments:

    InqContext - Context to cleanup

--*/
{
	DBGOUT(MEM1,"RPC Called Rundown\n\n");

	I_NSI_NS_HANDLE_T_rundown(InqContext);
}



RPC_BINDING_HANDLE
ConnectToMasterLocator(
			ULONG& Status
			)
/*++

Routine Description:

    Contains the logic for connecting to a master locator, whether in a
	workgroup or domain.  Tries to use the cached list of masters in the
	locator object, and if there are none then in a workgroup environment
	tries a broadcast for master locators in the workgroup. When a name
	for a machine with a master is found, the locator is pinged to ensure
	that it is actually alive.

Returns:

    A binding handle to a live master locator, if any.  NULL otherwise.

--*/
{
	RPC_BINDING_HANDLE hCurrentMaster = NULL;

	int fHandleWorked = FALSE;

	TGSLString *pMasters = myRpcLocator->getMasters();
	
	DBGOUT(TRACE, "Finding the list of cached master locators\n");

	if ((pMasters->size() == 0) && (myRpcLocator->IsInWorkgroup()))
	{
		myRpcLocator->TryBroadcastingForMasterLocator();
		DBGOUT(TRACE, "Broadcasted for master locators\n");		
		pMasters = myRpcLocator->getMasters();
	}

	TGSLStringIter iterDCs(*pMasters);


	CStringW * pPrimaryDCName = myRpcLocator->getPDC();
    DBGOUT(TRACE, "Perceived Primary DC Name" << (pPrimaryDCName?(STRING_T)(*pPrimaryDCName):L"<NULL>") << "\n");

	for (CStringW * pSWcurrentDC = pPrimaryDCName ? pPrimaryDCName : iterDCs.next();
		 pSWcurrentDC != NULL;
		 pSWcurrentDC = iterDCs.next()
		)
	{

		RpcTryExcept {
			hCurrentMaster = MakeDClocTolocHandle(*pSWcurrentDC);

			DBGOUT(TRACE, "Pinging Locator on machine " << (STRING_T)(*pSWcurrentDC) << "\n");

			CLIENT_I_nsi_ping_locator(
								   hCurrentMaster,
								   &Status
								   );
		}

		RpcExcept (EXCEPTION_EXECUTE_HANDLER) {
					
			Status = RpcExceptionCode();
			if (Status != NSI_S_DC_BINDING_FAILURE)
				RpcBindingFree(&hCurrentMaster);
			hCurrentMaster = NULL;

			if (Status == RPC_S_ACCESS_DENIED)
				Status = NSI_S_NO_NS_PRIVILEGE;

			/*  Unnecessary to set it here

				if (Status == RPC_S_SERVER_TOO_BUSY)
					Status = NSI_S_NAME_SERVICE_UNAVAILABLE;
			*/
		}
		RpcEndExcept;

		if (Status != RPC_S_OK) continue;

		fHandleWorked = TRUE;
		break;
	}

	if (!fHandleWorked) {

		hCurrentMaster = NULL;

		if (Status != NSI_S_NO_NS_PRIVILEGE)
			Status = NSI_S_NAME_SERVICE_UNAVAILABLE;
	}

	return hCurrentMaster;
}



NSI_UUID_VECTOR_T *
getVector(CObjectInqHandle *pInqHandle)
/*++

Routine Description:

    Given a handle for object lookup, extract all the objects in it
	and format them into a standard object vector.  This function
	is always used in creating ObjectInqHandles

Arguments:

	pInqHandle	- a context handle for object inquiry
	
Returns:

    A standard object vector
--*/
{
	// we have no idea how many we will have, so we use a simple
	// linked list to gather the UUIDs before setting up the vector

	int fDone = FALSE;

	CSimpleLinkList GuidList;

	while (!fDone) {

		__try {
			GUID * pGUID = pInqHandle->next();
			if (pGUID) GuidList.insert(pGUID);
			else fDone = TRUE;
		}
		__except(EXCEPTION_EXECUTE_HANDLER) {
			fDone = TRUE;
		}
	}

	ULONG ulSize = GuidList.size();

	NSI_UUID_VECTOR_T *pUuidVector = (NSI_UUID_VECTOR_T *)
						midl_user_allocate(
									sizeof(UNSIGNED32) +
									sizeof(GUID*) * ulSize
									);

	pUuidVector->count = ulSize;

	for (ULONG i = 0; i < ulSize; i++)
		pUuidVector->uuid[i] = (GUID*) GuidList.pop();

	return pUuidVector;
}


void *new_handler(size_t)
/* this is just in case we use the standard "new" operation, which we don't */
{
	Raise(NSI_S_OUT_OF_MEMORY);

	return NULL;	// just to keep the compiler happy, never used
}

void
StripDomainFromDN(WCHAR *FullName, WCHAR **szDomainName, 
                  WCHAR **pszEntryName, WCHAR **pszRpcContainerDN)
{
    WCHAR *psz = NULL;

    *szDomainName = FullName+wcslen(DSDomainBegin);
    psz = wcschr(*szDomainName, DSDomainEnd);
    *psz = L'\0';

    *pszEntryName = psz+1+3;
    psz = wcschr(*pszEntryName, L',');
    *psz = L'\0';

    *pszRpcContainerDN = psz+1;
}

void 
GetDomainFlatName(CONST WCHAR *domainNameDns, WCHAR **szDomainNameFlat)
{
    DWORD dwResult;
    PDOMAIN_CONTROLLER_INFO pDCI;   

    *szDomainNameFlat = NULL;
    dwResult = DsGetDcName(NULL, domainNameDns, NULL, NULL,
                                       DS_IP_REQUIRED |
//                                       DS_IS_DNS_NAME |
                                       DS_RETURN_FLAT_NAME,
                                       &pDCI);

    if (dwResult == ERROR_SUCCESS) {

        if (pDCI->DomainName) {

            *szDomainNameFlat = new WCHAR [wcslen(pDCI->DomainName) + 1];

            if (*szDomainNameFlat) {
                wcscpy ((*szDomainNameFlat), pDCI->DomainName);
            }
        }

        NetApiBufferFree(pDCI);
    }
}

void
parseEntryName(
		CONST_STRING_T fullName,
		CStringW * &pswDomainName,
		CStringW * &pswEntryName
		)
/*++

Routine Description:

    Parses a given entry name into its domain and entry name parts.
	Deals with both global and relative (local) entry name syntax.

Arguments:

	fullName		- the name to parse

	pswDomainName	- the domain name (if the input was a global name) is
					  returned here.  For a local name, NULL is returned.

	pswEntryName	- the relative entry name is returned here.

    call from brodcast.cxx would not need the LDAP names at all.

Remarks:

    The returned values are newly allocated string objects.

--*/
{
	if (memcmp(RelativePrefix, fullName,
			   RelativePrefixLength * sizeof(WCHAR))
		== 0) {

		pswDomainName = NULL;
		pswEntryName = new CStringW(fullName + RelativePrefixLength);
	}

	else if (memcmp(GlobalPrefix, fullName,
			   GlobalPrefixLength * sizeof(WCHAR))
			 == 0) {

		// make a copy starting after the prefix

		STRING_T domainBegin = CStringW::copyString(fullName + GlobalPrefixLength);

		for (STRING_T psz = domainBegin;
			 (*psz != NSnameDelimiter) && (*psz != WStringTerminator);
			 psz++);

		if (*psz == WStringTerminator) {	// no entry name at all
			delete [] domainBegin;
			Raise(NSI_S_INCOMPLETE_NAME);
		}

		else
		{
			*psz = 0;	 // the NULL character
			pswDomainName = new CStringW(domainBegin);
			pswEntryName = new CStringW(psz+1);
			delete [] domainBegin;
		}

	}

	else				// neither relative nor global prefix found
		Raise(NSI_S_UNSUPPORTED_NAME_SYNTAX);

}

STRING_T
makeGlobalName(
		const STRING_T szDomainName,
		const STRING_T szEntryName
		)
/*++

Routine Description:

    Formats a global entry name from domain and relative name parts.

Arguments:

	szDomainName	- the domain name

	pswEntryName	- the relative entry name

Returns

    A newly allocated global name string

--*/
{
	STRING_T psz1, psz2;

	psz1 = catenate(TEXT("/"),szEntryName);
	psz2 = catenate(szDomainName,psz1);
	delete [] psz1;
	psz1 = catenate(GlobalPrefix,psz2);
	delete [] psz2;
	return psz1;					

}


int
IsNormalCode(
		IN ULONG StatusCode
		)
/*++

Routine Description:

    A test to see if a status code is a normal status to return or signifies
	some error of purely internal interest.

Arguments:

	StatusCode	- the code to test

Returns

    TRUE if normal, FALSE if internal error (such as failure to connect to master locator).

--*/
{
	return
		(StatusCode < NSI_S_STATUS_MAX) &&
		(StatusCode != NSI_S_NAME_SERVICE_UNAVAILABLE) &&
		(StatusCode != NSI_S_NO_NS_PRIVILEGE) &&
		(StatusCode != NSI_S_OUT_OF_MEMORY) &&
		(StatusCode != NSI_S_NO_MASTER_LOCATOR);
}



unsigned
RandomBit(
    unsigned long *pState
    )
/*++

Routine Description:

    Generates a "random" bit.

    Using the MASK32 polynomial this function will have a period of exactly
    2^32-1.

    A more complete description of this algorithm can be found in "Numerical
    Recipes In C: The Art of Scientific Computation"

    Never generates a sequence of the same value longer more then 31.  This
    doesn't affect the odds much since a more general algorithm would generate
    such a sequence only every 2^31*(32/2) sequences.

Arguments:

    pState - Pointer to a dword of State.  This should
            be initalized to a random value (GetTickCount())
            before the first call.  It should be unmodified
            between future calls.  Must not be zero.

Return Value:

    0 or 1

Author:  MarioGo

--*/
{
    #define B1  (1)
    #define B2  (1<<1)
    #define B3  (1<<2)
    #define B4  (1<<3)
    #define B5  (1<<4)
    #define B6  (1<<5)
    #define B7  (1<<6)
    #define B32 (1<<31)

    // Selected polynomial's from table in Numerical Recipes In C.

    #define MASK30 (B1 + B4 + B6)   // for 30,6,4,1,0 polynomial

    #define MASK32 (B1 + B2 + B3 + B5 + B7) // for 32,7,5,3,2,1,0 polynomial

    if (*pState & B32)
        {
        *pState = ((*pState ^ MASK32) << 1) | 1;
        return(1);
        }

    *pState <<= 1;
    return(0);
}


BOOL
IsClientLocal (
    void
    )
/*++

Routine Description:

    Returns TRUE if the current call is from a local client and
    FALSE otherwise.

Arguments:

    none

--*/
{
    RPC_STATUS Status;
    unsigned int ClientLocalFlag;

    Status = I_RpcBindingIsClientLocal(NULL, &ClientLocalFlag);

    ASSERT(Status == RPC_S_OK, TEXT("I_RpcBindingIsClientLocal failed"));

    if (Status != RPC_S_OK || ClientLocalFlag == 0)
        {
        return FALSE;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc
    
Note:

    Common MIDL sources file.   Put common MIDL options such as 
    compiler switches here.

!ENDIF

386_STDCALL=0
MSC_WARNING_LEVEL=/WX /W4
USE_MSVCRT=1
USE_RTTI=1

# Asserts are enabled on all builds
C_DEFINES= $(C_DEFINES) -DMIDL_ENABLE_ASSERTS

# Setup debug flags
!IF !$(FREEBUILD)
DEBUG_CRTS=1
C_DEFINES= $(C_DEFINES) -DMIDL_INTERNAL
!ENDIF

SUBSYSTEM_VERSION=4.00
UMTYPE=console

# Hacks to make new types work with old 
# format string code.  Remove before shipping
C_DEFINES= $(C_DEFINES) -DNDR64_ON_DCE_HACK



MIDL_DIR=$(_PROJECT_MK_PATH)\$(O)
MIDL_OBJ_DIR=$(_PROJECT_MK_PATH)\$(_OBJ_DIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\btana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	btana.cxx

 Abstract:

	implementation of analysis methods for base types.

 Notes:

 History:

 	Sep-01-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop
/****************************************************************************/
CG_STATUS
CG_BASETYPE::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{
    
        pAna;
	return CG_OK;
}

CG_STATUS
CG_BASETYPE::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{
        pAna;
	return CG_OK;
}

CG_STATUS
CG_BASETYPE::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform analysis for out params, allocated as locals on the server side.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
	CG_OK if all is well
	error otherwise.

 Notes:

 	Initialization for a pure base type is not needed.

----------------------------------------------------------------------------*/
{
	if( pAna->IsRefAllocDone() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNode( pName, GetType(), new expr_constant(0L) )
								   	   		));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\arrayana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	arrayana.cxx

 Abstract:

	Implementation of array marshall and unmarshall analysis.

 Notes:


 History:

 	Nov-13-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_FIXED_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform marshall analysis for a fixed array.

 Arguments:

	pAna	= The analysis block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	CG_NDR				*	pBasicCGClass	= GetBasicCGClass();
	ID_CG                   ID              = pBasicCGClass->GetCGID();
	BOOL                    fIsArrayOfUnion = FALSE;

	if((ID == ID_CG_UNION) || (ID == ID_CG_ENCAP_STRUCT))
	    fIsArrayOfUnion = TRUE;

	// Temp fix for varying arrays.

	if( IsVarying() || fIsArrayOfUnion )
		{
		return CG_OK;
		}

	pBasicCGClass->MarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_FIXED_ARRAY::FollowerMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform Follower (embedded pointer) marshall analysis on the fixed array 

 Arguments:

	pAna	- The analyser block.

 Return Value:

	CG_OK
	
 Notes:

	// For buffer size calculation, we trick the child cg into beleieving it
	// is the only element being marshalled, so that it gives us the real
	// size per element. Then based on the alignment property before and
	// after the analysis, we make the sizing decisions.

----------------------------------------------------------------------------*/
	{
	CG_NDR		*		pBasicCGClass	= GetBasicCGClass();
	pBasicCGClass->FollowerMarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::DimByDimMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	pAna->PushEmbeddingLevel();
	GetBasicCGClass()->MarshallAnalysis( pAna );
	pAna->PopEmbeddingLevel();

        return CG_OK;

	}

CG_STATUS
CG_ARRAY::DimByDimUnMarshallAnalysis(
	ANALYSIS_INFO* )
	{
	return CG_OK;
	}
CG_STATUS
CG_ARRAY::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	if( IsFixedArray() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( "A" );
			node_skl * pType= MakeIDNode( pName, GetType() );
			SetResource( pAna->AddLocalResource( pName, pType ));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
	}

CG_STATUS
CG_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ID_CG			MyID			= GetCGID();
	short			NoOfDimensions	= short( GetDimensions() - 1 );
	int				i;

	//
	// Depending upon the id, perform analysis. Basically declare the
	// needed local variables.
	//

	// If it has embedded pointers or if block copy is not possible, declare
	// an index variable for each dimension.

	if( !IsBlockCopyPossible() )
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetIndexResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "I" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetIndexResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource( GetIndexResource()->GetResourceName(),
										GetIndexResource()->GetType()
									  );
			}

		DimByDimMarshallAnalysis( pAna );

		}

	if( IsFixedArray() && !IsArrayOfRefPointers() )
		{
		CG_FIXED_ARRAY * pThis	= (CG_FIXED_ARRAY *)this;
		unsigned long TotalSize	= pThis->GetNumOfElements();

		for( i = 0;
			 i < NoOfDimensions;
			 i++, pThis = (CG_FIXED_ARRAY *)pThis->GetChild() )
			{
			TotalSize = TotalSize * pThis->GetNumOfElements();
			}

		TotalSize = TotalSize * pThis->GetBasicCGClass()->GetWireSize();
		}

	if( (MyID == ID_CG_CONF_ARRAY) || (MyID == ID_CG_CONF_VAR_ARRAY))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetSizeResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "S" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetSizeResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource(GetSizeResource()->GetResourceName(),
										   GetSizeResource()->GetType()
									  	  );
			}

		}

	//
	// If this has any form of variance, generate locals for variance stuff.
	//

	if( (MyID == ID_CG_VAR_ARRAY ) || (MyID == ID_CG_CONF_VAR_ARRAY ))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetFirstResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "F" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetFirstResource(pAna->AddTransientResource(pResName, pType));
				}
			else
			   pAna->AddTransientResource(GetFirstResource()->GetResourceName(),
										   GetFirstResource()->GetType()
									  	  );
			}

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetLengthResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "L" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetLengthResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
			  pAna->AddTransientResource(GetLengthResource()->GetResourceName(),
										 GetLengthResource()->GetType()
									    );
			}

		}

	if( pAna->IsPointeeDeferred() && HasPointer() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ID_CG			MyID			= GetCGID();
	short			NoOfDimensions	= short( GetDimensions() - 1 );
	int				i;

	//
	// Depending upon the id, perform analysis. Basically declare the
	// needed local variables.
	//

	// If it has embedded pointers or if block copy is not possible, declare
	// an index variable for each dimension.

	if( HasPointer() || !IsBlockCopyPossible() )
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetIndexResource() )
				{
				node_skl	*	pType;
				PNAME			pResName= pAna->GenTempResourceName( "I" );

				GetBaseTypeNode(&pType,SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetIndexResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource( pThis->GetIndexResource()->GetResourceName(),
										pThis->GetIndexResource()->GetType()
									  );
			}
		}

	if( (MyID == ID_CG_CONF_ARRAY) || (MyID == ID_CG_CONF_VAR_ARRAY))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetSizeResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "S" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetSizeResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
				pAna->AddTransientResource(pThis->GetSizeResource()->GetResourceName(),
										   pThis->GetSizeResource()->GetType()
									  	  );
			}

		}

	//
	// If this has any form of variance, generate locals for variance stuff.
	//

	if( (MyID == ID_CG_VAR_ARRAY ) || (MyID == ID_CG_CONF_VAR_ARRAY ))
		{
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetFirstResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "F" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetFirstResource(pAna->AddTransientResource(pResName, pType));
				}
			else
			   pAna->AddTransientResource(pThis->GetFirstResource()->GetResourceName(),
										   pThis->GetFirstResource()->GetType()
									  	  );
			}

		for( i = 0, pThis = this;
			 i <= NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetLengthResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "L" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetLengthResource( pAna->AddTransientResource( pResName, pType ));
				}
			else
			  pAna->AddTransientResource(pThis->GetLengthResource()->GetResourceName(),
										 pThis->GetLengthResource()->GetType()
									    );
			}
		}

	if( HasPointer() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}

	return CG_OK;
	}
CG_STATUS
CG_ARRAY::FollowerMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
        pAna;
	return CG_OK;
	}

CG_STATUS
CG_ARRAY::FollowerUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	node_skl	*	pType	= GetBasicCGClass()->GetType();
	PNAME			pName;

	// Declare a local variable for a member by member unmarshall of the
	// array elements.

	pName	= pAna->GenTempResourceName("PE");
	pType = MakePtrIDNode( pName, pType );
	SetPtrResource( pAna->AddTransientResource( pName, pType ) );

	GetBasicCGClass()->FollowerUnMarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::RefCheckAnalysis(
	ANALYSIS_INFO * pAna )
	{
	int	i;
	int NoOfDimensions = GetDimensions();

	if( IsArrayOfRefPointers() )
		{
		// Allocate an index resource per dimension.
		CG_ARRAY * pThis;

		for( i = 0, pThis = this;
			 i < NoOfDimensions;
			 i++, pThis = (CG_ARRAY *)pThis->GetChild() )
			{
			if( !pThis->GetIndexResource() )
				{
				node_skl	*	pType;
				PNAME			pResName	= pAna->GenTempResourceName( "I" );

				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT );
				pType	= MakeIDNode( pResName, pType );
				pThis->SetIndexResource( pAna->AddLocalResource( pResName, pType ));
				}
			else
				pAna->AddLocalResource(
								GetIndexResource()->GetResourceName(),
								GetIndexResource()->GetType()
									  );
			}

		}
	return CG_OK;
	}

CG_STATUS
CG_ARRAY::InLocalAnalysis(
	ANALYSIS_INFO * pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform Allocation of local resources on server side stub for an
 	array of ref pointers.

 Arguments:

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	if( IsArrayOfRefPointers() && IsFixedArray() )
		{
		if( !GetInLocalResource() )
			{
			node_skl	*	pType = GetType();
			PNAME			pResName	= pAna->GenTempResourceName( "A" );

			pType	= MakeIDNode( pResName, pType );
			SetInLocalResource(pAna->AddLocalResource(pResName,pType));
			}
		else
			{
			pAna->AddLocalResource(
						GetInLocalResource()->GetResourceName(),
						GetInLocalResource()->GetType()
									  );
			}
		}
	return CG_OK;
	}

/*****************************************************************************
 CG_STRING_ARRAY methods.
 *****************************************************************************/
CG_STATUS
CG_STRING_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform marshall analysis for a fixed string array.

 Arguments:

	pAna	= The analysis block.

 Return Value:

	CG_OK
	
 Notes:

 	For now this will work only for a single dimensional array on which 
 	[string] is applied.

----------------------------------------------------------------------------*/
	{
	CG_NDR				*	pBasicCGClass	= GetBasicCGClass();

	pBasicCGClass->MarshallAnalysis( pAna );

	return CG_OK;
	}

/*****************************************************************************
 CG_VARYING_ARRAY methods.
 *****************************************************************************/
CG_STATUS
CG_VARYING_ARRAY::MarshallAnalysis(
	ANALYSIS_INFO * pAna )
	{
        pAna;
	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\procana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	procana.cxx

 Abstract:

	This file provides analysis routines for a procedure code generation
	class.

 Notes:

 History:


	Aug-31-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop

#pragma warning ( disable :  4701 )

/****************************************************************************
 	Implementation of the proc code generator class.
 ****************************************************************************/

CG_STATUS
CG_PROC::C_BindingAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the binding analysis for the client side.

 Arguments:
	
 Return Value:
	
 Notes:

	If it is an auto handle procedure, make sure the global auto handle is
	registered as a global resource.
----------------------------------------------------------------------------*/
{
	node_id	*	pID;

	if( IsAutoHandle() )
		{
		pAna->AddStandardResource( ST_RES_AUTO_BH_VARIABLE );
		}
	else
		{
		SetBindingResource( pAna->AddStandardResource( ST_RES_BH_VARIABLE ) );

		// Initialize the binding resource to 0, so it gets printed out.

		pID	= (node_id *)GetBindingResource()->GetType();

		pID->SetExpr( new expr_constant( 0L ) );

		}
	return CG_OK;
}

CG_STATUS
CG_PROC::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;
	CG_PARAM	*	pS;
	CG_RETURN	*	pRT;
	SIDE			Side	= pAna->GetCurrentSide();
	expr_node	*	pSE		= 0;
	BOOL			fReturnNeedsMarshall = FALSE;

	if( Side == C_SIDE )
		GetInParamList( I );
	else
		GetOutParamList( I );

    pRT = GetReturnType();
	if ( Side == S_SIDE  && pRT != 0 ) 
		fReturnNeedsMarshall = TRUE;

	if( ITERATOR_GETCOUNT( I ) )
		{
		ITERATOR_INIT( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
            // The "invisible" fault or comm status param doesn't marshal.

			pS = (CG_PARAM *)ITERATOR_PEEKTHIS( I );

            if ( pCG->IsExtraStatusParam() )
                continue;

			pCG->MarshallAnalysis( pAna );

            // Add to the sizing expression.

			if( pSE )
				pSE	= new expr_b_arithmetic( OP_PLUS,
											  pSE,
											  pCG->GetSizeExpression()
											);
			else
				pSE	= pCG->GetSizeExpression();
			}
		}

	if(fReturnNeedsMarshall)
		{
                
                pRT->MarshallAnalysis( pAna );
		
                if( pSE )
			pSE	= new expr_b_arithmetic( OP_PLUS,
										  pSE,
										  pRT->GetSizeExpression()
										);
		else
			pSE	= pRT->GetSizeExpression();
		}

	if( pSE )
		SetSizeExpression( pSE );
	else
		SetSizeExpression( new expr_constant( 0L,VALUE_TYPE_NUMERIC_U ));

    if ( HasExtraStatusParam() )
        {
        GetMembers(I);

        while ( ITERATOR_GETNEXT( I, pCG ) )
            if ( pCG->IsExtraStatusParam() )
                break;

        node_skl *pType = pCG->GetType();

        pCG->SetResource( new RESOURCE( pType->GetSymName(), pType ) );
        }

	return CG_OK;
	}

CG_STATUS
CG_PROC::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;
	CG_PARAM	*	pS;
	CG_RETURN	*	pRT = 0;
	SIDE			Side = pAna->GetCurrentSide();
	BOOL			fReturnNeedsUnMarshall	= FALSE;

	if( Side == C_SIDE )
		GetOutParamList( I );
	else
		GetInParamList( I );
	
	if( (Side == C_SIDE ) && (pRT = GetReturnType() ) != 0 )
		fReturnNeedsUnMarshall = TRUE;

	if( ITERATOR_GETCOUNT(I) )
		{
		while( ITERATOR_GETNEXT( I, pCG ) )
			{
            // The "invisible" fault/comm status param doesn't unmarshal.

			pS = (CG_PARAM *)ITERATOR_PEEKTHIS( I );

            if ( pCG->IsExtraStatusParam() )
                continue;

			pCG->UnMarshallAnalysis( pAna );
			}

		}

	if( fReturnNeedsUnMarshall )
		{
		pRT->UnMarshallAnalysis( pAna );
		}
	

	return CG_OK;
	}


CG_STATUS
CG_PROC::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for all params which may be allocated as locals for
 	the server side stubs.

 Arguments:

 	pAna	- The analysis block.

	
 Return Value:
	
 	CG_OK	if all is well,
 	error	otherwise.

 Notes:

----------------------------------------------------------------------------*/
{

	ITERATOR		I;
	CG_PARAM	*	pParam = 0;

	GetOutParamList( I );

	while( ITERATOR_GETNEXT( I, pParam ) )
		{
		pParam->S_OutLocalAnalysis( pAna );
		}

	return CG_OK;
}


void
CG_PROC::RpcSsPackageAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for the need to invoke RpcSsm package at server.

 Arguments:

 	pAna	- The analysis block.

	
 Return Value:
	
 Notes:

   Note that we perform both sides analysis at once as the format string
   is generated usually at the client pass.

----------------------------------------------------------------------------*/
{
    //
    // In ms_ext mode:
    //    only if  Enable allocate is specified 
    // In osf mode:
    //    if( RpcSS is recommended by analysis || enable allocate specified )
    //
    SetMustInvokeRpcSSAllocate( 0 );

    if ( IsRpcSSSpecified() )
        SetMustInvokeRpcSSAllocate( 1 );

    if ( MustInvokeRpcSSAllocate()  ||  pAna->GetMode() != 0 )
        return;

    // We analyze parameters in osf to boost performance by skipping
    // unnecessary enable and disable operations.
    //
    
    ITERATOR        ParamList;
    CG_PARAM    *    pParam = 0;

    GetMembers( ParamList );

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            pParam->RpcSsPackageAnalysis( pAna );
            }
        }

    CG_RETURN * pReturn = GetReturnType();

    if ( pReturn )
        {
        if ( (pAna->GetOptimOption() & OPTIMIZE_INTERPRETER)  ||
             (pReturn->GetChild()  &&
                   ( ((CG_NDR *)pReturn->GetChild())->IsPointer()  ||
                     ((CG_NDR *)pReturn->GetChild())->HasPointer() ||
                     ((CG_NDR *)pReturn->GetChild())->GetCGID() == ID_CG_ENCAP_STRUCT ) )
           )
            {
            // We could do a better job for Oi2 if we watched its stack.
            // Encapsulated union is there as it was a hassle to make it
            // know about its pointers.

            pAna->SetRpcSSAllocateRecommended( 1 );
            }
        }

    if ( pAna->IsRpcSSAllocateRecommended() )
       SetMustInvokeRpcSSAllocate( 1 );
}


CG_STATUS
CG_PROC::RefCheckAnalysis(
    ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform ref pointer check analysis.

 Arguments:

 	pAna	- The analysis info block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;
	CG_RETURN	*	pRT = 0;
	SIDE			Side	= pAna->GetCurrentSide();
	BOOL			fReturnNeedsMarshall = FALSE;

    // generate ref check resources for both in and out params.
    GetMembers( I );
	if( (Side == S_SIDE ) && (pRT = GetReturnType() ) != 0 )
		fReturnNeedsMarshall = TRUE;

	if( ITERATOR_GETCOUNT( I ) )
		{
		ITERATOR_INIT( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
			pCG->RefCheckAnalysis( pAna );
			}
		}

	if(fReturnNeedsMarshall)
		{
		pRT->RefCheckAnalysis( pAna );
		}
	return CG_OK;
	}

CG_STATUS
CG_PROC::InLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for [in] params allocated as locals on server.

 Arguments:

 	pAna	- The analysis info block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	ITERATOR		I;
	CG_PARAM	*	pCG = 0;

	GetInParamList( I );

	if( ITERATOR_GETCOUNT( I ) )
		{
		ITERATOR_INIT( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
			pCG->InLocalAnalysis( pAna );
			}
		}
	return CG_OK;
	}

/****************************************************************************
 	Implementation of the parameter code generator class.
 ****************************************************************************/
CG_STATUS
CG_PARAM::MarshallAnalysis(
	 ANALYSIS_INFO * pAna )
{
	CG_STATUS				Status;

	//
	// Initialize the analysis block and the parameter for the current side
	// and analysis phase.
	//

	InitParamMarshallAnalysis( pAna );

	// Send the message to the lower cg nodes.

	Status = ((CG_NDR *)GetChild())->MarshallAnalysis( pAna );

	if( pAna->HasAtLeastOneDeferredPointee() )
		{
		pAna->ResetDeferPointee();
		((CG_NDR *)GetChild())->FollowerMarshallAnalysis( pAna );
		}


	ConsolidateParamMarshallAnalysis( pAna );


	// The analysis block will now have properties which are a combo of the
	// properties before this param and the properties of this param.

	return CG_OK;
}

CG_STATUS
CG_PARAM::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{

	InitParamUnMarshallAnalysis( pAna );

	// Send the message to the child to perform the same analysis for us
	// and then consolidate the results on return.

	((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	if( pAna->HasAtLeastOneDeferredPointee() )
		{
		pAna->ResetDeferPointee();
		((CG_NDR *)GetChild())->FollowerUnMarshallAnalysis( pAna );
		}

	// Consolidate the results of analysis from the lower nodes.

	ConsolidateParamUnMarshallAnalysis( pAna );

	return CG_OK;
}

void
CG_PARAM::InitParamMarshallAnalysis(
	ANALYSIS_INFO * pAna )
{

	node_skl	*	pType	= GetType();
	PNAME			pName	= pType->GetSymName();
	CG_NDR		*	pC		= (CG_NDR *)GetChild();

	// For all cases of generic handles, where the CG_GENERIC_HANDLE will
	// sit below the param, we want to bypass the generic handle class during
	// marshall analysis.

	if( pC->GetCGID() == ID_CG_GENERIC_HDL )
		{
		pC = (CG_NDR *)pC->GetChild();
		}

	//
	// Allocate the resource for this parameter. On the client side, this
	// parameter is a param resource, while on the server, this param is a local
	// resource. One the client side, the param has already been added to the
	// resource dictionary.

	if( pAna->GetCurrentSide() == C_SIDE )
		{
		if( (pC->IsArray()) &&
			(pAna->GetOptimOption() & OPTIMIZE_INTERPRETER )
		  )
		  	{
			pType	= MakePtrIDNode( pName, pType->GetChild() );
		  	}
		SetResource( new RESOURCE( pName, pType) );
		}
	else
		{
		node_skl	*	pActualType	= pType->GetChild();

		if( (pC->GetCGID() == ID_CG_CONTEXT_HDL ) ||
			(pC->GetChild() && (pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL)))
			{
			pActualType	= MakeIDNode( pName, new node_def ("NDR_SCONTEXT" ) );
			}
		else if( pC->IsArray() )
			pActualType	= MakePtrIDNode( pName, pActualType);
		else
			pActualType = MakeIDNode( pName, pActualType );

		SetResource( pAna->AddLocalResource( pName, pActualType ));
		}

	SetSizeResource( 0 );
	SetLengthResource( 0 );
	SetFirstResource( 0 );

	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->ResetIndirectionLevel();
	pAna->SetRefChainIntact();
	pAna->ResetDeferPointee();
	pAna->ResetHasAtLeastOneDeferredPointee();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );
}

void
CG_PARAM::ConsolidateParamMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{
	expr_node		*	pSE		= 0;
	

	// Consolidate the result of the analysis from lower nodes, first into
	// this node, and then into the analysis block.

	pSE	= new expr_constant( (long)0U, VALUE_TYPE_NUMERIC_U );

	SetSizeExpression( pSE );

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}
}

void
CG_PARAM::InitParamUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{

	node_skl	*	pType	= GetType();
	node_skl	*	pActualType = pType->GetBasicType();
	PNAME			pName	= pType->GetSymName();
	CG_NDR		*	pC		= (CG_NDR *)GetChild();

	// For all cases of generic handles, where the CG_GENERIC_HANDLE will
	// sit below the param, we want to bypass the generic handle class during
	// marshall analysis.

	if( pC->GetCGID() == ID_CG_GENERIC_HDL )
		{
		pC = (CG_NDR *)pC->GetChild();
		}

	//
	// Allocate resources. On the client side, a parameter resource is allocated
	// and on the server, a local resource is allocated.
	//

	SetSubstitutePtrResource( 0 );

	if( pAna->GetCurrentSide() == C_SIDE )
		{
		pAna->SetDontReUseBuffer();
		if( (pC->IsArray()) &&
			(pAna->GetOptimOption() & OPTIMIZE_INTERPRETER )
		  )
		  	{
			pType	= MakePtrIDNode( pName, pType->GetChild() /* GetBasicType() ????????? */ );
		  	}
		SetResource( new RESOURCE( pName, pType) ) ;
		}
	else if ( ! IsOmittedParam() )
		{
		pC->SetAllocatedOnStack( 1 );

		if( (pC->GetCGID() == ID_CG_CONTEXT_HDL ) ||
			(pC->GetChild() && (pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL)))
			{
			pActualType	= MakeIDNode( pName, new node_def ("NDR_SCONTEXT" ) );
			}
		else if( pC->IsArray() )
			{
			pActualType	= MakePtrIDNode( pName, pType->GetChild() );
			}
		else
			pActualType	= MakeIDNode( pName, pType->GetChild() );

		pAna->ResetDontReUseBuffer();
		SetResource( pAna->AddLocalResource( pName, pActualType ) );
		}

	SetSizeResource( 0 );
	SetLengthResource( 0 );
	SetFirstResource( 0 );

	// Reset for analysis.


	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->ResetIndirectionLevel();
	pAna->SetRefChainIntact();
	pAna->ResetDeferPointee();
	pAna->ResetHasAtLeastOneDeferredPointee();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );
}

void
CG_PARAM::ConsolidateParamUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
{

	// Consolidate the result of the analysis from lower nodes, first into
	// this node, and then into the analysis block.

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}
}
CG_STATUS
CG_PARAM::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for all params which may be allocated as locals for
 	server stub

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
 Notes:

	Ignore [in, out], since that would be done by the Unmarshall analysis.
----------------------------------------------------------------------------*/
{
	// If the param is [out] only, determine if there is a need for local
	// variables and if they need to be inited.
	
	if( IsParamOut() && !IsParamIn() )
		{
		InitParamMarshallAnalysis( pAna );

		((CG_NDR *)GetChild())->S_OutLocalAnalysis( pAna );

		}
	return CG_OK;
}


void
CG_PARAM::RpcSsPackageAnalysis(
    ANALYSIS_INFO    *    pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Perform analysis for rpcss package enabling.

 Arguments:
    
    pAna    - A pointer to the analysis block.

 Return Value:
    
 Notes:

    This routine should be called only in the osf mode.

----------------------------------------------------------------------------*/
{
    //
    // Package needs to be enabled (only is OSF mode) when the NDR engine
    // is going to do any allocations whatsoever at the server side.
    //
    // In Os this may happen on
    //    - anything other than simple type or pointer to simple type
    //    - with simple type, if this happens to be enum16
    // In Oi this may happen on
    //    - anything [out]
    //    - [in] like Os
    // In Oi2 this may happen on
    //    - anything [out] when lack of space on -Oi2 stack
    //    - [in] like Os
    //      (simple types and pointers to simple types are usually on
    //      the interpreter stack, if there is space there).
    //      However, this cannot be guaranteed.
    
    if( IsParamOut() &&
        ( pAna->GetOptimOption() & OPTIMIZE_INTERPRETER) )
        {
        // We could do a better job for Oi2 if we watched the its stack.

        pAna->SetRpcSSAllocateRecommended( 1 );
        return;
        }

    // We are here with
    //   [in] or [in,out] for Oi? 
    //   any              for Os
    // See if this is one of the simple cases mentioned above.
    // This is really a check for the buffer reusage.

    CG_NDR * pChild = (CG_NDR *)GetChild();

    if ( pChild->IsSimpleType() &&
         ( pChild->GetCGID() != ID_CG_ENUM  ||
           pChild->GetCGID() == ID_CG_ENUM  &&
                                     ((CG_ENUM*)pChild)->IsEnumLong() )
         &&  pChild->GetCGID() != ID_CG_INT3264 
       )
        {
        // An [in] arg in the buffer.

        return;
        }

    // Note that we don't have to check for allocate(allnodes) etc.
    // as this is not an osf attribute.
    // Also note that we handle top level pointers here.

    if ( pChild->IsPointer()  &&  ((CG_POINTER *)pChild)->IsRef() )
        {
        // In args would stay in the buffer,
        // out args would be on the Os stack.

        CG_NDR * pPointee = (CG_NDR *)pChild->GetChild();

        if ( ( pChild->GetCGID() == ID_CG_PTR  ||
               pChild->GetCGID() == ID_CG_STRING_PTR  || 
               pChild->GetCGID() == ID_CG_SIZE_PTR )
             &&
             pPointee->IsSimpleType()
             &&
             ( pPointee->GetCGID() != ID_CG_ENUM  ||
               pPointee->GetCGID() == ID_CG_ENUM  &&
                                      ((CG_ENUM*)pPointee)->IsEnumLong() )
             &&
             pPointee->GetCGID() != ID_CG_INT3264
           )
            return;
        }

    pAna->SetRpcSSAllocateRecommended( 1 );
}



/****************************************************************************
 	Implementation of the return type node.
 ****************************************************************************/
CG_STATUS
CG_RETURN::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the size analysis for the return type.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
 Notes:

	For the return type, the size analysis contributes nothing on the
	client side, yet we must declare a local variable for the return.
----------------------------------------------------------------------------*/
{

	node_skl			*	pType				= GetType();
	PNAME	   				pName				= RETURN_VALUE_VAR_NAME;
	CG_STATUS				Status;
	CG_NDR				*	pC	= (CG_NDR *)GetChild();

	//
	// Always allocate a local resource for the return type.
	//

	if( (pC->GetCGID() == ID_CG_CONTEXT_HDL ) ||
		(pC->GetChild() && (pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL)))
		{
		node_skl	*	pActualType = pType->GetBasicType();
		pActualType	= MakeIDNode( pName, new node_def ("NDR_SCONTEXT" ) );
		SetResource( pAna->AddLocalResource( pName, pActualType ));
		}
	else
		{
		pType	= MakeIDNode( pName, pType );
		SetResource( pAna->AddLocalResource( pName,  pType ));
		}


	SetSizeResource( 0 );

	// Reset the analysis block for marshalling.

	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->SetRefChainIntact();
	pAna->SetDontReUseBuffer();
	
	pAna->SetReturnContext();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );

	// Send the analysis message to the child nodes.

	Status	=  ((CG_NDR *)GetChild())->MarshallAnalysis( pAna );


	SetSizeExpression(
         new expr_constant( 0L, VALUE_TYPE_NUMERIC_U ) );
	
	pAna->ResetReturnContext();

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}

	return Status;
}

CG_STATUS
CG_RETURN::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the buffer analysis for the return type.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
 Notes:

	For the return type, the size analysis contributes nothing on the
	client side, yet we must declare a local variable for the return.
----------------------------------------------------------------------------*/
{
	node_skl	*	pType	= GetType();
	PNAME			pName	= RETURN_VALUE_VAR_NAME;
	CG_STATUS		Status;

	//
	// Always allocate a local resource for the return type.
	//

	pType	= MakeIDNode( pName, pType );
	SetResource( pAna->AddLocalResource( pName,  pType ));

	pAna->SetMemoryAllocDone();
	pAna->ResetRefAllocDone();
	pAna->ResetEmbeddingLevel();
	pAna->SetRefChainIntact();
	pAna->SetDontReUseBuffer();
	
	pAna->SetReturnContext();
	pAna->SetLastPlaceholderClass( (CG_NDR *)this );

	Status	= ((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	pAna->ResetReturnContext();

	if( pAna->GetOptimOption() & OPTIMIZE_SIZE )
		{
		pAna->ClearTransientResourceDict();
		}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\ptrana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	ptrana.cxx

 Abstract:

 	Contains implementations of analysis routines for pointer types.

 Notes:


 History:

 	Oct-10-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_POINTER::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS	Status;

	// Unmarshall the pointer body first. If the pointer needs to be deferred,
	// then dont perform the pointee unmarshall analysis. Just indicate that
	// there is a pointee that needs to be unmarshalled later.

	Status = PtrUnMarshallAnalysis( pAna );

	if( pAna->IsPointeeDeferred() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}
	else
		Status	= PteUnMarshallAnalysis( pAna );

	return Status;
	}

CG_STATUS
CG_POINTER::PtrUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	// Perform the analysis for the pointer body. For a [ref] pointer, nothing
	// needs to be done.
	
	if( IsRef() && !pAna->IsMemoryAllocDone() )
		{
		SetUAction( RecommendUAction( pAna->GetCurrentSide(),
								 	  pAna->IsMemoryAllocDone(),	
								 	  pAna->IsRefAllocDone(),
								 	  FALSE,		// no buffer re-use for ref.
								 	  UAFLAGS_NONE
							   	 	));

		}

	return CG_OK;
	}

CG_STATUS
CG_POINTER::PteUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS	Status;
	pAna->PushIndirectionLevel();

	Status = CorePteUnMarshallAnalysis( pAna );

	pAna->PopIndirectionLevel();

	return Status;
	}

CG_STATUS
CG_POINTER::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS	Status;
	short		EmbedLevel;

	// Marshall the pointer body first. If the pointee needs to be deferred,
	// dont perform marshall analysis on the pointee. Just indicate that a
	// pointee needs to be marshalled later.

	Status = PtrMarshallAnalysis( pAna );

	if( pAna->IsPointeeDeferred() )
		{
		pAna->SetHasAtLeastOneDeferredPointee();
		}
	else
		{
		EmbedLevel = pAna->GetCurrentEmbeddingLevel();
		pAna->ResetEmbeddingLevel();
		Status	= PteMarshallAnalysis( pAna );
		pAna->SetCurrentEmbeddingLevel( EmbedLevel );
		}

	return Status;
	}

CG_STATUS
CG_POINTER::PtrMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
        pAna;
	return CG_OK;
	}

CG_STATUS
CG_POINTER::PteMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	CG_STATUS			Status;

	pAna->PushIndirectionLevel();

	pAna->SetMemoryAllocDone();	// Needed ?
	Status = CorePteMarshallAnalysis( pAna );

	pAna->PopIndirectionLevel();

	return Status;
	}

CG_STATUS
CG_POINTER::FollowerMarshallAnalysis(
	ANALYSIS_INFO * pAna )
	{
	return PteMarshallAnalysis( pAna );
	}

CG_STATUS
CG_POINTER::FollowerUnMarshallAnalysis(
	ANALYSIS_INFO * pAna )
	{
	return PteUnMarshallAnalysis( pAna );
	}

CG_STATUS
CG_POINTER::S_OutLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform analysis for [out] params that need to be allocated as locals
 	on server stub.

 Arguments:

 	pAna	- The analysis block.
	
 Return Value:
	
	CG_OK	if all is well
	error	otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
	CG_STATUS		Status	= CG_OK;
	CG_NDR		*	pC		= (CG_NDR *)GetNonGenericHandleChild();

	if( !pAna->IsMemoryAllocDone() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNode( pName, GetType() )
								   	   	));
			}
		SetAllocatedOnStack( 1 );
		}

	// If it is a ref pointer, chase it further.

	if( IsRef() && !IsQualifiedPointer() )
		{
		pAna->ResetMemoryAllocDone();
		pAna->SetRefAllocDone();
		Status = pC->S_OutLocalAnalysis( pAna );

	    // If this is the server side, and the pointee is allocated on stack,
    	// then dont free the pointee, else free it.

	    if( pC->IsAllocatedOnStack() )
		    {
    		SetPointerShouldFree( 0 );
	    	}
		}

	return Status;
}
CG_STATUS
CG_POINTER::InLocalAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	if( IsRef() && GetChild() )
		{
		((CG_NDR *)GetChild())->InLocalAnalysis( pAna );
		}

	return CG_OK;
	}

/****************************************************************************
 *	CG_QUALIFIED_POINTER 
 ***************************************************************************/

CG_STATUS
CG_QUALIFIED_POINTER::CorePteMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform the core pointee marshall analysis for a conformant string

 Arguments:
	
	pAna	- The analysis block pointer.

 Return Value:

 	CG_OK	if all is well, error otherwise.

 Notes:

	The ndr for a conformant string (eg typedef [string] char *p ) is:
		- MaxCount
		- Offset from start of the valid character
		- Actual Count.

	We need to declare a local variable which will hold the length of the
	string, so that the length can be used in the actual marshall for memcopy.
----------------------------------------------------------------------------*/
{
	node_skl			*	pType;
	PNAME					pResName;
	BOOL					fNeedsCount;
	BOOL					fNeedsFirstAndLength;


	if( pAna->IsArrayContext() )
		{
		SetUsedInArray();
		}

	if ( ( fNeedsCount = NeedsMaxCountMarshall() ) == TRUE )
		{
		if( !GetSizeResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName	= pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );
			SetSizeResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			{
			pAna->AddTransientResource( GetSizeResource()->GetResourceName(),
										GetSizeResource()->GetType()
									  );
			}
		}

	if ( ( fNeedsFirstAndLength = NeedsFirstAndLengthMarshall() ) == TRUE )
		{
		if( !GetLengthResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName = pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );
			SetLengthResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			{
			pAna->AddTransientResource( GetLengthResource()->GetResourceName(),
										GetLengthResource()->GetType()
									  );
			}

		if( NeedsExplicitFirst() )
			{
			if( !GetFirstResource() )
				{
				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pResName = pAna->GenTempResourceName(0);
				pType	 = MakeIDNode( pResName, pType );
				SetFirstResource( pAna->AddTransientResource( pResName, pType ) );
				}
			else
				{
			  pAna->AddTransientResource(GetLengthResource()->GetResourceName(),
										 GetLengthResource()->GetType()
									  	);
				}
			}
		}

	return CG_OK;
}

CG_STATUS
CG_QUALIFIED_POINTER::CorePteUnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
	node_skl		*	pType;
	PNAME				pResName;
	BOOL				fNeedsMaxCount;
	BOOL				fNeedsFirstAndLength;


	// If a resource for the length has not already been allocated, allocate
	// one.

	if ( ( fNeedsMaxCount = NeedsMaxCountMarshall() ) == TRUE )
		{
		if( !GetSizeResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName	= pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );

			SetSizeResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			pAna->AddTransientResource( GetSizeResource()->GetResourceName(),
										GetSizeResource()->GetType()
									  );
		}

	if ( ( fNeedsFirstAndLength = NeedsFirstAndLengthMarshall() ) == TRUE )
		{
		if( !GetLengthResource() )
			{
			GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
			pResName	= pAna->GenTempResourceName(0);
			pType		= MakeIDNode( pResName, pType );

			SetLengthResource( pAna->AddTransientResource( pResName, pType ) );
			}
		else
			pAna->AddTransientResource( GetLengthResource()->GetResourceName(),
										GetLengthResource()->GetType()
									  );

		if( NeedsExplicitFirst() )
			{
			if( !GetFirstResource() )
				{
				GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
				pResName	= pAna->GenTempResourceName(0);
				pType		= MakeIDNode( pResName, pType );

				SetFirstResource( pAna->AddTransientResource( pResName, pType ) );
				}
			else
			  pAna->AddTransientResource(GetFirstResource()->GetResourceName(),
										 GetFirstResource()->GetType()
									  	);
			}
		}

	return CG_OK;
	}

CG_STATUS
CG_INTERFACE_POINTER::S_OutLocalAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform analysis for out params, allocated as locals on the server side.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
	CG_OK if all is well
	error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    if( pAna->IsRefAllocDone() )
        {
        if( pAna->GetCurrentSide() != C_SIDE )
            {
            PNAME       pName = pAna->GenTempResourceName( 0 );
            node_skl *  pType = GetType();

            node_skl *  pActualType;

            if ( pType->NodeKind() == NODE_DEF )
                pActualType = MakeIDNode( pName, pType );
            else
                pActualType = MakePtrIDNode( pName, pType );

            SetResource( pAna->AddLocalResource( pName,
                                                 pActualType ));
            }

        SetAllocatedOnStack( 1 );
        }
    return CG_OK;
}

CG_STATUS
CG_INTERFACE_POINTER::MarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Perform marshall analysis for interface ptr.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
    pAna;
    return CG_OK;
}

CG_STATUS
CG_IIDIS_INTERFACE_POINTER::S_OutLocalAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Perform analysis for out params, allocated as locals on the server side.

 Arguments:
	
	pAna	- A pointer to the analysis block.

 Return Value:
	
	CG_OK if all is well
	error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    if( pAna->IsRefAllocDone() )
        {
        if( pAna->GetCurrentSide() != C_SIDE )
            {
            PNAME       pName = pAna->GenTempResourceName( 0 );
            node_skl *  pType = GetType();

            node_skl *  pActualType;

            if ( pType->NodeKind() == NODE_DEF )
                pActualType = MakeIDNode( pName, pType );
            else
                pActualType = MakePtrIDNode( pName, pType );

            SetResource( pAna->AddLocalResource( pName,
                                                 pActualType ));
            }

        SetAllocatedOnStack( 1 );
        }
    return CG_OK;
}

CG_STATUS
CG_IIDIS_INTERFACE_POINTER::MarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Perform marshall analysis for interface ptr.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
    pAna;
    return CG_OK;
}




/****************************************************************************
 *	utility functions
 ***************************************************************************/
U_ACTION
CG_POINTER::RecommendUAction(
	SIDE		CurrentSide,
	BOOL		fMemoryAllocated,
	BOOL		fRefAllocated,
	BOOL		fBufferReUsePossible,
	UAFLAGS		AdditionalFlags )
{
	U_ACTION	UAction =  CG_NDR::RecommendUAction( CurrentSide,
									 					fMemoryAllocated,
									 					fRefAllocated,
									 					fBufferReUsePossible,
									 					AdditionalFlags );
	return UAction;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\analysis.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	anainfo.cxx

 Abstract:

	Implementation of the analysis classes.

 Notes:


 Author:


 History:

 	VibhasC		Jul-25-1993		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

short TempResourceCounter = 0;

/****************************************************************************
 *	externs
 ***************************************************************************/
#ifdef MIDL_INTERNAL

void
ANALYSIS_INFO::Dump(
	 ANAPHASE A )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Debug dump.

 Arguments:

	A	- The analysis phase to be dumped.

 Return Value:

 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	FILE	*		hFile	= stdout;
	char	*		pTemp;
	OPTIM_OPTION	Options	= OPTIMIZE_NONE;

static char Buffer[ 100 ];

	pTemp = ( A == ANA_PHASE_CLIENT_MARSHALL ) ? "Client Marshall"	:
			( A == ANA_PHASE_CLIENT_UNMARSHALL ) ? "Client UnMarshall":
			( A == ANA_PHASE_SERVER_UNMARSHALL ) ? "Server UnMarshall":
			"Server Marshal";

	sprintf( Buffer, "\nDump of phase :%s\n", pTemp );
	fprintf( hFile, "%s", Buffer );

	//
	// dump optimisation options.
	//

	fprintf( hFile, "\nOptimize Options: ( " );
	if( Options )
		{
			if( Options & OPTIMIZE_SIZE )
				{
				fprintf( hFile, "Size " );
				Options &= ~OPTIMIZE_SIZE;
				}

			if( Options & OPTIMIZE_INTERPRETER )
				{
				fprintf( hFile, "Interpret " );
				Options &= ~OPTIMIZE_INTERPRETER;
				}

			if( Options & OPTIMIZE_NO_REF_CHECK )
				{
				fprintf( hFile, "NoRef " );
				Options &= ~OPTIMIZE_NO_REF_CHECK;
				}

			if( Options & OPTIMIZE_NO_CTXT_CHECK )
				{
				fprintf( hFile, "NoCtxt " );
				Options &= ~OPTIMIZE_NO_CTXT_CHECK;
				}

			if( Options & OPTIMIZE_NO_GEN_HDL_CHECK )
				{
				fprintf( hFile, "NoGenHdl " );
				Options &= ~OPTIMIZE_NO_GEN_HDL_CHECK;
				}
		}
	else
		fprintf( hFile, "default( speed )" );

	fprintf( hFile, " )" );

	//
	// all done.
	//

	fprintf( hFile, "\n" );
}
#endif // MIDL_INTERNAL


void
ANALYSIS_INFO::Reset()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	The Master clear or reset.

 Arguments:

 	None.

 Return Value:

	NA.

 Notes:

 	Create an alignment state machine instance.

----------------------------------------------------------------------------*/
{

	//
	// Initialize the miscellaneous properties.
	//

	SetMiscProperties( DEFAULT_MISC_PROPERTIES );

	//
	// Set the default optimization options.
	//

	SetOptimOption( DEFAULT_OPTIM_OPTIONS );

	ResetArrayContext();

	SetRpcSSAllocateRecommended( 0 );
}

ANALYSIS_INFO::ANALYSIS_INFO()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:


 	Constructor for analysis information manager block.

 Arguments:


 	None.

 Return Value:


 	NA.

 Notes:

----------------------------------------------------------------------------*/
{

	//
	// Initialize and so on.
	//

	Reset();

	//
	// Set the analysis phase to be client side marshall by default.
	//

	SetCurrentPhase( ANA_PHASE_CLIENT_MARSHALL );

	//
	// Create a resource dictionary data base.
	//

	pResDictDatabase = new RESOURCE_DICT_DATABASE();

	OptimOptions	 = OPTIMIZE_NONE;

	SetLastPlaceholderClass(0);

	fRpcSSSwitchSet	 = 0;

}

RESOURCE *
ANALYSIS_INFO::DoAddResource(
	RESOURCE_DICT	*	pResDict,
	PNAME				pName,
	node_skl 		*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Add a resource to a dictionary.

 Arguments:

	pResDict	- A pointer to the resource dictionary.
	pName		- The resource name.
	pType		- The type of the resource.

 Return Value:

 Notes:

 	If the type of the resource does not indicate a param node, assume it
 	is an ID node and create an id node for it.

----------------------------------------------------------------------------*/
{
	RESOURCE	*	pRes;

	if( (pRes = pResDict->Search( pName )) == 0 )
		{
		pRes = pResDict->Insert( pName, pType );
		}

	return pRes;
}

RESOURCE *
ANALYSIS_INFO::AddStandardResource(
	STANDARD_RES_ID	ResID )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Add a standard resource to the appropriate dictionary.

 Arguments:

 	ResID	- The standard resource ID.

 Return Value:

 Notes:

	Depending upon the resource in question, locate the correct dictionary
	to insert into, generate the type and insert in the dictionary.

----------------------------------------------------------------------------*/
{
	RESOURCE_DICT	*	pResDict = 0;
	PNAME				pName = 0;
	RESOURCE		*	pResource;
	node_id			*	pType;
	PNAME				pTName = 0;

static struct
	{
	char * pName;
	char * pTypeName;
	} LocalResIDToResName[] =
	{
	 { RPC_MESSAGE_VAR_NAME, RPC_MESSAGE_TYPE_NAME }
	,{ STUB_MESSAGE_VAR_NAME, STUB_MESSAGE_TYPE_NAME }
	,{ STUB_DESC_STRUCT_VAR_NAME, STUB_DESC_STRUCT_TYPE_NAME }
	,{ BUFFER_POINTER_VAR_NAME, BUFFER_POINTER_TYPE_NAME }
	,{ RPC_STATUS_VAR_NAME, RPC_STATUS_TYPE_NAME }
	,{ LENGTH_VAR_NAME, LENGTH_VAR_TYPE_NAME }
	,{ BH_LOCAL_VAR_NAME, BH_LOCAL_VAR_TYPE_NAME }
	,{ PXMIT_VAR_NAME, PXMIT_VAR_TYPE_NAME }
	};

static struct
	{
	char * pName;
	char * pTypeName;
	}ParamResIDToResName[] =
	{
	 { PRPC_MESSAGE_VAR_NAME, PRPC_MESSAGE_TYPE_NAME }
	};

static struct
	{
	char * pName;
	char * pTypeName;
	} GlobalResIDToResName[] =
	{
	 { AUTO_BH_VAR_NAME, AUTO_BH_TYPE_NAME }
	};

	if( IS_STANDARD_LOCAL_RESOURCE( ResID ) )
		{
		pResDict= pResDictDatabase->GetLocalResourceDict();
		pName	= LocalResIDToResName[ ResID - ST_LOCAL_RESOURCE_START ].pName;
		pTName	= LocalResIDToResName[ ResID - ST_LOCAL_RESOURCE_START ].pTypeName;
		}
	else if( IS_STANDARD_PARAM_RESOURCE( ResID ) )
		{
		pResDict= pResDictDatabase->GetParamResourceDict();
		pName	= ParamResIDToResName[ ResID - ST_PARAM_RESOURCE_START ].pName;
		pTName	= ParamResIDToResName[ ResID - ST_PARAM_RESOURCE_START ].pTypeName;
		}
	else if( IS_STANDARD_GLOBAL_RESOURCE( ResID ) )
		{
		pResDict= pResDictDatabase->GetGlobalResourceDict();
		pName	= GlobalResIDToResName[ ResID - ST_GLOBAL_RESOURCE_START ].pName;
		pTName	= GlobalResIDToResName[ ResID - ST_GLOBAL_RESOURCE_START ].pTypeName;
		}
	else
		{
		MIDL_ASSERT( FALSE );
		}

	if( (pResource = pResDict->Search( pName )) == 0 )
		{
		pType		= new node_id( pName );
		pType->SetBasicType( new node_def( pTName ) );
//gaj		pType->SetEdgeType( EDGE_USE );
		pType->GetModifiers().SetModifier( ATTR_TAGREF );
		pResource = pResDict->Insert( pName, (node_skl *)pType );
		}

	return pResource;
}

PNAME
ANALYSIS_INFO::GenTempResourceName(
	char	*	pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the name for a temporary resource.

 Arguments:

	pPrefix	- A null terminated prefix string. If this is null, nothing is
			  added.

 Return Value:

	A freshly allocated resource name string.

 Notes:

----------------------------------------------------------------------------*/
{
	char	TempBuffer[ 30 ];

	sprintf( TempBuffer,
			 "_%sM%d",
			 pPrefix ? pPrefix : "",
			 GetTempResourceCounter()
		   );

	BumpTempResourceCounter();

	PNAME	pName	= (PNAME) new char [ strlen(TempBuffer) + 1 ];
	strcpy( pName, TempBuffer );
	return pName;
}

PNAME
ANALYSIS_INFO::GenTRNameOffLastParam(
	char	*	pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the name for a temporary resource.

 Arguments:

	pPrefix	- A null terminated prefix string. If this is null, nothing is
			  added.

 Return Value:

	A freshly allocated resource name string.

 Notes:

----------------------------------------------------------------------------*/
{
	char	TempBuffer[ 30 ];

	sprintf( TempBuffer,
			 "_%sM",
			 pPrefix ? pPrefix : ""
		   );

	PNAME	pName	= (PNAME) new char [ strlen(TempBuffer) + 1 ];
	strcpy( pName, TempBuffer );
	return pName;
}

/****************************************************************************
 	Utility functions.
 ****************************************************************************/
//
// This array defines the action taken when memory has been allocated for 
// a type.
//


static U_ACTION S_WhenMemoryAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_NONE,					// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_TYPE,		// Copy from source to type ( resource )
	   PR_TYPE					// Presented expression is the type / resource
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_NONE,					// No allocation needed.
	   RA_NONE,					// No action for reference.
	   UA_COPY_INTO_TYPE,		// No Unmarshalling action.
	   PR_TYPE					// Presented expression is deref of src.
	 }

	};

//
// This array defines the action taken when a reference has been allocated for
// a type.
//

static U_ACTION S_WhenRefAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_STACK,				// Explicit allocation needed.
	   RA_PATCH_TO_ADDR_OF_TYPE,// Patch ref to address of type.
	   UA_COPY_INTO_TYPE,		// Copy from source to type.
	   PR_NONE					// Presented expression tbd by caller.
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_NONE,					// No allocation needed.
	   RA_PATCH_INTO_BUFFER,	// Patch ref to position in buffer.
	   UA_NONE,					// No Unmarshalling action.
	   PR_NONE					// Presented expression is deref of src.
	 }

	};

static U_ACTION S_WhenMemoryAndRefAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_ERROR,				// Explicit allocation needed.
	   RA_ERROR,				// Patch ref to address of type.
	   UA_ERROR,				// Copy from source to type.
	   PR_ERROR					// Presented expression tbd by caller.
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// No allocation needed.
	   RA_ERROR,				// Patch ref to position in buffer.
	   UA_ERROR,				// No Unmarshalling action.
	   PR_ERROR					// Presented expression is deref of src.
	 }
	};

static U_ACTION C_WhenMemoryAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_EXISTS,				// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_DEREF_OF_REF,	// Copy from source to type ( resource )
	   PR_NONE					// Presented expression is the type / resource
	 }
#if 0
	 { AN_NONE,				// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_TYPE,		// Copy from source to type ( resource )
	   PR_NONE					// Presented expression is the type / resource
	 }
#endif // 0

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// This situation must never happen on client
	   RA_ERROR,
	   UA_ERROR,
	   PR_ERROR	
	 }

	};

//
// This array defines the action taken when a reference has been allocated for
// a type.
//

static U_ACTION C_WhenRefAllocated[ 2 ] = 
	{
	// Buffer re-use is not possible.

	 { AN_NONE,					// Explicit allocation needed.
	   RA_NONE,					// Patch ref to address of type.
	   UA_COPY_INTO_DEREF_OF_REF,// Copy from source to type.
	   PR_NONE					// Presented expression tbd by caller.
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// Must never happen on client
	   RA_ERROR,
	   UA_ERROR,
	   PR_ERROR
	 }

	};

static U_ACTION C_WhenMemoryAndRefAllocated[ 2 ] = 
	{

	// Buffer re-use is not possible.

	 { AN_EXISTS,				// No Allocation needed.
	   RA_NONE,					// No reference action.
	   UA_COPY_INTO_DEREF_OF_REF,// Copy from source to type ( resource )
	   PR_NONE					// Presented expression is the type / resource
	 }

	 // When Buffer reuse is possible.

	,{
	   AN_ERROR,				// Must never happen on client
	   RA_ERROR,
	   UA_ERROR,
	   PR_ERROR
	 }

	};

U_ACTION
CG_NDR::RecommendUAction(
	SIDE	Side,
	BOOL	fMemoryAllocated,
	BOOL	fRefAllocated,
	BOOL	fBufferReUsePossible,
	UAFLAGS  )
	{
	BOOL	fMemoryAndRefAllocated = (fMemoryAllocated && fRefAllocated);


	if( Side == C_SIDE )
		{
		if( fMemoryAndRefAllocated )
			return C_WhenMemoryAndRefAllocated[ fBufferReUsePossible ];
		else if( fMemoryAllocated )
			return C_WhenMemoryAllocated[ fBufferReUsePossible ];
		else
			return C_WhenRefAllocated[ fBufferReUsePossible ];
		}
	else
		{
		if( fMemoryAndRefAllocated )
			{
			MIDL_ASSERT( FALSE &&
		   		    !"Server analysis should never have mem and ref allocated");
			return S_WhenRefAllocated[ fBufferReUsePossible ];
			}
		else if( fMemoryAllocated )
			return S_WhenMemoryAllocated[ fBufferReUsePossible ];
		else
			return S_WhenRefAllocated[ fBufferReUsePossible ];
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\stana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	stana.cxx	

 Abstract:

	structure marshalling / unmarshalling analysis.

 Notes:


 History:

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_STRUCT::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{
        pAna;        

	return CG_OK;
	}

CG_STATUS
CG_STRUCT::UnMarshallAnalysis( ANALYSIS_INFO* )
	{
	return CG_OK;
	}

CG_STATUS
CG_COMP::S_OutLocalAnalysis(
	ANALYSIS_INFO * pAna )
	{
	if( pAna->IsRefAllocDone() )
		{
		if( pAna->GetCurrentSide() != C_SIDE )
			{
			char Buffer[ 256 ];
			CG_NDR	*	pLPC = pAna->GetLastPlaceholderClass();
	
			strcpy( Buffer, pLPC->GetType()->GetSymName() );

			PNAME	pName	= pAna->GenTRNameOffLastParam( Buffer );

			pAna->AddLocalResource( pName,
								MakeIDNode( pName, GetType() )
							  );
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\opinfo.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	opinfo.cxx

 Abstract:

	Contains the implementations of the optimisation analysis information
	classes.

 Notes:


 Author:

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/

/****************************************************************************
 *	SU_PROPERTY implementation
 ***************************************************************************/
USE_COUNT
SU_OPTIM_INFO::IncrInUsage()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Increment the [in] directional usage of this type.

 Arguments:

 	None.
	
 Return Value:
	
	The final incremented usage.

 Notes:

 	If the incremented usage is above the threshold, set it to the threshold
 	value itself.

----------------------------------------------------------------------------*/
	{
	if( ++InUsageCount >= USAGE_THRESHOLD )
		InUsageCount = USAGE_THRESHOLD;
	return InUsageCount;
	}

USE_COUNT
SU_OPTIM_INFO::IncrOutUsage()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Increment the [out] directional usage of this type.

 Arguments:

 	None.
	
 Return Value:
	
	The final incremented usage.

 Notes:

 	If the incremented usage is above the threshold, set it to the threshold
 	value itself.

----------------------------------------------------------------------------*/
	{
	if( ++InUsageCount >= USAGE_THRESHOLD )
		InUsageCount = USAGE_THRESHOLD;
	return InUsageCount;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\analysis\typeana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	typeana.cxx

 Abstract:

	transmit_as analysis stuff.

 Notes:


 History:

	Dec-08-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "allana.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_TRANSMIT_AS::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->MarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_TRANSMIT_AS::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	return CG_OK;

	}

CG_STATUS
CG_TRANSMIT_AS::S_OutLocalAnalysis(
	ANALYSIS_INFO * pAna )
{
	if( pAna->IsRefAllocDone() )
		{

		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNode( pName,
													    GetPresentedType()
													  )
								   	   		));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
}

CG_STATUS
CG_REPRESENT_AS::MarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->MarshallAnalysis( pAna );

	return CG_OK;
	}

CG_STATUS
CG_REPRESENT_AS::UnMarshallAnalysis(
	ANALYSIS_INFO	*	pAna )
	{

	((CG_NDR *)GetChild())->UnMarshallAnalysis( pAna );

	return CG_OK;

	}

CG_STATUS
CG_REPRESENT_AS::S_OutLocalAnalysis(
	ANALYSIS_INFO * pAna )
{
	if( pAna->IsRefAllocDone() )
		{

		if( pAna->GetCurrentSide() != C_SIDE )
			{
			PNAME	pName	= pAna->GenTempResourceName( 0 );
			SetResource( pAna->AddLocalResource( pName,
									 	 	MakeIDNodeFromTypeName(
													    pName,
													    GetRepAsTypeName()
													  )
								   	   		));
			}
		SetAllocatedOnStack( 1 );
		}
	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\bindcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    bindcls.cxx

 Abstract:

    This module provides implementation of the binding handle code generation
    classes.

 Notes:


 History:

    Sep-19-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/

PNAME
CG_CONTEXT_HANDLE::GetRundownRtnName()
{
    node_skl    *   pType   = GetHandleType();

    if ( ! pRundownRoutineName ) 
        {
        if( pType->NodeKind() == NODE_DEF )
            {
            pRundownRoutineName = new char[256];

            strcpy(pRundownRoutineName, pType->GetSymName());
            strcat(pRundownRoutineName, "_rundown");
            }
        else
            pRundownRoutineName = "0";
        }

    return pRundownRoutineName;
}

CG_STATUS
CG_CONTEXT_HANDLE::MarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
    {
    pAna;
    return CG_OK;
    }

CG_STATUS
CG_CONTEXT_HANDLE::UnMarshallAnalysis(
    ANALYSIS_INFO   *   pAna )
    {
    pAna;
    return CG_OK;
    }

CG_STATUS               
CG_CONTEXT_HANDLE::S_GenInitOutLocals( CCB * pCCB )
{
    ISTREAM *   pStream = pCCB->GetStream();
    CG_PARAM *  pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pStream->NewLine();

    if ( HasNewContextFlavor() )
        {
        // For new flavors generate an initialization call that knows about flags.
        //
        //   handle = NdrContextHandleInitialize( & StubMsg, & TypeFormatStr[i] );
        //

        char            Buf[80];
        unsigned short  Spaces;

        Spaces = (unsigned short)(strlen( pParam->GetResource()->GetResourceName() ) + 7);

        pStream->Write( pParam->GetResource()->GetResourceName() );
        pStream->Write( " = " );
        pStream->Write( "NdrContextHandleInitialize(" );
        pStream->NewLine();
        pStream->Spaces( Spaces );
        pStream->Write( "(PMIDL_STUB_MESSAGE)& "STUB_MESSAGE_VAR_NAME"," );
        pStream->NewLine();
        pStream->Spaces( Spaces );
        pStream->Write( "(PFORMAT_STRING) &" );
        pStream->Write( FORMAT_STRING_STRUCT_NAME );
        sprintf( Buf, ".Format[%d] );", GetFormatStringOffset() );
        pStream->Write( Buf );
        }
    else
        {
        // Old style optimized initialization call
        //
        //   handle = NDRSContextUnmarshall( 0, DataRep );
        //
        pStream->Write( pParam->GetResource()->GetResourceName() );
        pStream->Write( " = " );
        pStream->Write( CTXT_HDL_S_UNMARSHALL_RTN_NAME );
        pStream->Write( "( (char *)0, " );                      // pBuf
        pStream->Write( PRPC_MESSAGE_DATA_REP );                // Data rep
        pStream->Write( " ); " );
        }

    pStream->NewLine();
    return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\arraygen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	arraygen.cxx

 Abstract:

	Implementation of array marshall and unmarshall.

 Notes:


 History:

 	Nov-13-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


/*****************************************************************************
	utility
 *****************************************************************************/
BOOL
CG_ARRAY::IsBlockCopyPossible()
	{
	return GetBasicCGClass()->IsBlockCopyPossible();
	}
expr_node *
CG_ARRAY::FinalSizeExpression( CCB * pCCB )
	{
	CG_NDR	*	pC;
	expr_node	*	pFSExpr;

	if( (pC = (CG_NDR *)GetChild())->IsArray() )
		{
		pFSExpr = ((CG_ARRAY *)pC)->FinalSizeExpression( pCCB );
		pFSExpr = new expr_b_arithmetic(OP_STAR,
									 	pFSExpr,
									 	PresentedSizeExpression( pCCB ));
		}
	else
		pFSExpr = PresentedSizeExpression( pCCB );

	if( pFSExpr->IsConstant() )
		pFSExpr = new expr_constant( pFSExpr->Evaluate() );

	return pFSExpr;
	}

expr_node *
CG_ARRAY::FinalFirstExpression( CCB * pCCB )
	{
	CG_NDR	*	pC;
	expr_node	*	pFFExpr;

	// for an array a[ 0th ][ 1st]...[nth] the final first expression is:
	// ((First Of nth dim) * Size Nth dim ) + First N-1th dim) * Size N-1th dim
	// and so on.

	if( (pC = (CG_NDR *)GetChild())->IsArray() )
		{
		pFFExpr = ((CG_ARRAY *)pC)->FinalFirstExpression( pCCB );
		pFFExpr = new expr_b_arithmetic(OP_STAR,
									 	pFFExpr,
									 	((CG_ARRAY *)pC)->PresentedSizeExpression( pCCB ));
		pFFExpr	= new expr_b_arithmetic( OP_PLUS,
										  pFFExpr,
									 	((CG_ARRAY *)pC)->PresentedFirstExpression( pCCB ));
											
		}
	else
		pFFExpr = PresentedFirstExpression( pCCB );

	if( pFFExpr->IsConstant() )
		pFFExpr = new expr_constant( pFFExpr->Evaluate() );

	return pFFExpr;
	}
expr_node *
CG_ARRAY::FinalLengthExpression( CCB * pCCB )
	{
	CG_NDR	*	pC;
	expr_node	*	pFLExpr;

	if( (pC = (CG_NDR *)GetChild())->IsArray() )
		{
		pFLExpr = ((CG_ARRAY *)pC)->FinalLengthExpression( pCCB );
		pFLExpr = new expr_b_arithmetic(OP_STAR,
									 	pFLExpr,
									 	PresentedLengthExpression( pCCB ));
		}
	else
		pFLExpr = PresentedLengthExpression( pCCB );

	if( pFLExpr->IsConstant() )
		pFLExpr = new expr_constant( pFLExpr->Evaluate() );

	return pFLExpr;

	}

CG_NDR *
CG_ARRAY::GetBasicCGClass()
	{
	CG_NDR * pC	= (CG_NDR *)GetChild();

	while( pC->IsArray() && (pC->GetCGID() != ID_CG_STRING_ARRAY) )
		{
		pC = (CG_NDR *)pC->GetChild();
		}
	return pC;
	}
BOOL
CG_ARRAY::HasPointer()
	{
	CG_NDR * pBasicCGClass = (CG_NDR *)GetBasicCGClass();

	return ( ( pBasicCGClass->IsPointer() &&
               !pBasicCGClass->IsInterfacePointer() ) ||
             pBasicCGClass->HasPointer() );
	}

CG_STATUS
CG_ARRAY::S_GenInitOutLocals(
	CCB		*	pCCB )
	{
	BOOL		fFixedArrayOfXmitOrRepAs= FALSE;

	// If this is a fixed array, then the array would have been allocated
	// already. Remember, there is also a pointer associated with it.
	// Emit the initialization to the allocated array.

	// If this is a conformant array, then the size would have been
	// unmarshalled before this and so we need to allocate.

	if( IsFixedArray() )
		{
		if( ((CG_NDR *)GetChild())->IsXmitRepOrUserMarshal() )
			{
			fFixedArrayOfXmitOrRepAs = TRUE;
			}

		Out_Assign( pCCB,
                    pCCB->GetSourceExpression(),
                    MakeAddressExpressionNoMatterWhat( GetResource() ) );
		}
	else
		{
		CGPHASE	Phase = pCCB->GetCodeGenPhase();
		expr_node * pElementSizeExpr	=
					 new expr_constant( GetBasicCGClass()-> GetMemorySize() );
		expr_node * pFinalSizeExpr;
		BOOL        fIsSigned;

		// Get the final size expression.
		// Make array believe it is actually on the marshall side, so that the
		// presented expression comes out right.

		pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

		pFinalSizeExpr = FinalSizeExpression( pCCB );

                fIsSigned = !((node_base_type *)pFinalSizeExpr->AlwaysGetType()->GetBasicType())->IsUnsigned();

		pFinalSizeExpr = new expr_b_arithmetic( OP_STAR,
												 pFinalSizeExpr,
												 pElementSizeExpr );

		// Allocate the proper size.
		// If the size expression is signed and the value is less than 0, we
		// need to raise an exception.

		if( pCCB->MustCheckBounds() && fIsSigned )
		    {
		    expr_node * pCheckExpr;
		    pCheckExpr = new expr_op_binary( OP_LESS,
		                                     pFinalSizeExpr,
		                                     new expr_constant(0L));
		    Out_If( pCCB, pCheckExpr);
		    Out_RaiseException( pCCB, "RPC_X_INVALID_BOUND" );
		    Out_Endif( pCCB );
		    }

		Out_Alloc( pCCB,
				   pCCB->GetSourceExpression(),
				   0,
				   pFinalSizeExpr );

		pCCB->SetCodeGenPhase( Phase );
		}


	if( IsArrayOfRefPointers()	|| fFixedArrayOfXmitOrRepAs )
		{
		// Zero out this array of pointers.
		expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
		pProc->SetParam( new expr_param( pCCB->GetSourceExpression() ) );
		pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
		pProc->SetParam( new expr_param( new expr_sizeof( GetType())));
		pCCB->GetStream()->NewLine();
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}

	return CG_OK;
	}

expr_node *
CG_CONFORMANT_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();

		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_VARYING_ARRAY::PresentedLengthExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		expr_node * pExpr = GetLengthIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_VARYING_ARRAY::PresentedFirstExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		expr_node * pExpr = GetFirstIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_CONFORMANT_VARYING_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_CONFORMANT_VARYING_ARRAY::PresentedLengthExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		expr_node * pExpr = GetLengthIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

expr_node *
CG_CONFORMANT_VARYING_ARRAY::PresentedFirstExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		expr_node * pExpr = GetFirstIsExpr();
		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}
expr_node *
CG_FIXED_ARRAY::PresentedSizeExpression(
	CCB	*)
	{
	expr_node * pExpr =  new expr_constant( GetSizeIsExpr()->Evaluate() );

	return pExpr;
	}

expr_node *
CG_STRING_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();

		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}
expr_node *
CG_CONFORMANT_STRING_ARRAY::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		expr_node * pExpr = GetSizeIsExpr();

		if( pExpr->IsConstant() )
			pExpr =  new expr_constant( pExpr->Evaluate() );
		return pExpr;
		}
	}

BOOL
CG_ARRAY::IsArrayOfRefPointers()
	{
	CG_NDR * pCG	= GetBasicCGClass();
	return ( pCG->IsPointer() &&
			 !pCG->IsInterfacePointer() &&
			 ((CG_POINTER *)pCG)->IsRef() );
	}

BOOL
CG_ARRAY::MustBeAllocatedOnUnMarshall(
	CCB	*	pCCB )
	{
	BOOL	fIsTopLevelArray = (pCCB->GetCurrentEmbeddingLevel() == 0) &&
					   		   (pCCB->GetCurrentIndirectionLevel() == 0 );

	//
	// The array must be allocated if:
	// 	1. Not a top level array on client or server.
	//	2. On the server side, if it is an array of ref pointers.
	//	3. Is not fixed.

	if(!fIsTopLevelArray ||
	   ((pCCB->GetCodeGenSide() == CGSIDE_SERVER) && IsArrayOfRefPointers()) ||
	   !IsFixedArray()
	  )
	  	return TRUE;
	else
		return FALSE;
	}

CG_STATUS
CG_ARRAY::GenRefChecks(
	CCB	*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Perform ref pointer checks on an array of ref pointers.

 Arguments:

 	pCCB	- The code gen block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	if( IsArrayOfRefPointers() )
		{
		pCCB->SetSourceExpression(new expr_index(
										 pCCB->GetSourceExpression(),
								   		 GetIndexResource()));
        expr_node* pLenExpr     = PresentedLengthExpression( pCCB );
        expr_node* pFirstExpr   = PresentedFirstExpression( pCCB );
        expr_node* pFinalVal    = 0;

        if ( pLenExpr )
            {
            pFinalVal = new expr_b_arithmetic( OP_PLUS, pFirstExpr, pLenExpr );
            }
        else
            {
            pFinalVal = PresentedSizeExpression( pCCB );
            }

		Out_For( pCCB,
				  GetIndexResource(),
				  pFirstExpr,
				  pFinalVal,
				  new expr_constant( 1L )
			   );

		((CG_NDR *)GetChild())->GenRefChecks( pCCB );

		Out_EndFor( pCCB );
		}

	return CG_OK;
	}

CG_STATUS
CG_ARRAY::S_GenInitInLocals(
	CCB	*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Arguments:

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
	{
	if( IsArrayOfRefPointers() && IsFixedArray() )
		{
		expr_node	*	pSrc = pCCB->GetSourceExpression();
		expr_node	*	InLocalResource = GetInLocalResource();
		expr_node	*	pExpr = new expr_assign(
										pSrc,
										MakeAddressExpressionNoMatterWhat(
															 InLocalResource ));
		pCCB->GetStream()->NewLine();
		pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
		pCCB->GetStream()->Write(';');

		expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );

		pProc->SetParam( new expr_param( pSrc ) );
		pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
		pProc->SetParam( new expr_param( new expr_sizeof( GetType())));
		pCCB->GetStream()->NewLine();
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}

	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\btgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    btgen.cxx

 Abstract:

    code generation method implementations for the base type class.

 Notes:


 History:

    Sep-22-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/
extern CMD_ARG * pCommand;


CG_STATUS
CG_BASETYPE::GenMarshall(
    CCB     *   pCCB )
{
    pCCB;
    MIDL_ASSERT(0);
    return CG_OK;
}
CG_STATUS
CG_BASETYPE::GenUnMarshall(
    CCB     *   pCCB )
{
    pCCB;
    MIDL_ASSERT(0);
    return CG_OK;

}

CG_STATUS
CG_BASETYPE::S_GenInitOutLocals(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the init call for the locals.

 Arguments:

    pCCB    - The ptr to code gen block.
    
 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
{
    expr_node   *   pExpr;

    if( !pCCB->IsRefAllocDone() )
        {
        pExpr   = new expr_sizeof( GetType() );
        Out_Alloc( pCCB, pCCB->GetSourceExpression(), 0, pExpr );
        }
    else
        {
        pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
        Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
        }
    return CG_OK;
}

FORMAT_CHARACTER
CG_BASETYPE::GetFormatChar( CCB *)
{
    switch ( GetType()->GetBasicType()->NodeKind() )
        {
        case NODE_BYTE :
            return FC_BYTE;
        case NODE_CHAR :
            return FC_CHAR;
        case NODE_SMALL :
        case NODE_BOOLEAN :
            return FC_SMALL;
        case NODE_WCHAR_T :
            return FC_WCHAR;
        case NODE_SHORT :
            return FC_SHORT;
        case NODE_LONG :
        case NODE_INT32 :
        case NODE_INT :
            return FC_LONG;
        case NODE_FLOAT :
            return FC_FLOAT;
        case NODE_HYPER :
        case NODE_INT64 :
        case NODE_LONGLONG :
            return FC_HYPER;
        case NODE_DOUBLE :
            return FC_DOUBLE;
        case NODE_INT3264:
			{
		    BOOL    IsUnsigned;

		    IsUnsigned = ((node_base_type *)(GetType()->GetBasicType()))->IsUnsigned();

            if ( pCommand->IsNDR64Run() || pCommand->Is64BitEnv() )
	            return (IsUnsigned ? FC_UINT3264 : FC_INT3264);
            else
                return FC_LONG;
			}
            break;
        case NODE_INT128:
            return FC_INT128;
        case NODE_FLOAT80:
            return FC_FLOAT80;
        case NODE_FLOAT128:
            return FC_FLOAT128;
        default:
            // remove FC_BLKHOLE & HookOLE
            MIDL_ASSERT(0);
            return FC_ZERO;
        }

    // unreachable code
    // return FC_ZERO;
}

NDR64_FORMAT_CHARACTER
CG_BASETYPE::GetNDR64FormatChar( CCB *)
{
    switch ( GetType()->GetBasicType()->NodeKind() )
        {
        case NODE_BYTE :
            return FC64_INT8;
        case NODE_CHAR :
            return FC64_CHAR;
        case NODE_SMALL :
        case NODE_BOOLEAN :
            return FC64_INT8;
        case NODE_WCHAR_T :
            return FC64_WCHAR;
        case NODE_SHORT :
            return FC64_INT16;
        case NODE_LONG :
        case NODE_INT32 :
        case NODE_INT :
            return FC64_INT32;
        case NODE_FLOAT :
            return FC64_FLOAT32;
        case NODE_HYPER :
        case NODE_INT64 :
        case NODE_LONGLONG :
            return FC64_INT64;
        case NODE_DOUBLE :
            return FC64_FLOAT64;
        case NODE_INT3264:
            return pCommand->Is64BitEnv() ? FC64_INT64 : FC64_INT32;
        case NODE_INT128:
            return FC64_INT128;
        case NODE_FLOAT80:
            return FC64_FLOAT80;
        case NODE_FLOAT128:
            return FC64_FLOAT128;
        default:
            // remove FC_BLKHOLE & HookOLE
            MIDL_ASSERT(0);
            return FC64_ZERO;
        }

    // unreachable code
    // return FC_ZERO;
}

FORMAT_CHARACTER
CG_BASETYPE::GetSignedFormatChar()
{
    BOOL    IsUnsigned;

    IsUnsigned = ((node_base_type *)(GetType()->GetBasicType()))->IsUnsigned();

    switch ( GetFormatChar() )
        {
        case FC_BYTE :
            // return FC_USMALL;
        case FC_SMALL :
        case FC_CHAR :
            return (IsUnsigned ? FC_USMALL : FC_SMALL);
        case FC_WCHAR :
            // return FC_USHORT;
        case FC_SHORT :
            return (IsUnsigned ? FC_USHORT : FC_SHORT);
        case FC_LONG :
            return (IsUnsigned ? FC_ULONG : FC_LONG);
        case FC_INT3264 :
        case FC_UINT3264 :
            return (IsUnsigned ? FC_UINT3264 : FC_INT3264);
        case FC_HYPER :
            return (IsUnsigned ? FC_HYPER : FC_HYPER);
        case FC_INT128 :
            return (IsUnsigned ? FC_UINT128 : FC_INT128);
        default :
            MIDL_ASSERT(0);
        }

    return FC_ZERO;
}

NDR64_FORMAT_CHARACTER
CG_BASETYPE::GetNDR64SignedFormatChar()
{
    BOOL    IsUnsigned;

    IsUnsigned = ((node_base_type *)(GetType()->GetBasicType()))->IsUnsigned();

    switch ( GetNDR64FormatChar() )
        {
        case FC64_INT8 :
        case FC64_CHAR :
            return (IsUnsigned ? FC64_UINT8 : FC64_INT8);
        case FC64_WCHAR :
            // return FC_USHORT;
        case FC64_INT16 :
            return (IsUnsigned ? FC64_UINT16 : FC64_INT16 );
        case FC64_INT32 :
            return (IsUnsigned ? FC64_UINT32 : FC64_INT32 );
        case FC64_INT64 :
            return (IsUnsigned ? FC64_UINT64 : FC64_INT64);
        case FC64_INT128 :
            return (IsUnsigned ? FC64_UINT128 : FC64_INT128);
        default :
            MIDL_ASSERT(0);
        }

    return FC64_ZERO;
}

char *
CG_BASETYPE::GetTypeName()
{
    return GetType()->GetSymName();
}

void
CG_BASETYPE::IncrementStackOffset( long * pOffset )
{
    if ( pCommand->Is64BitEnv() )
        {
        *pOffset = (*pOffset + 7) & ~ 0x7;
        *pOffset += 8;
        }
    else
        {

        unsigned short Env;
    
        Env = pCommand->GetEnv();
    
        switch ( GetFormatChar() )
            {
            case FC_HYPER :
            case FC_DOUBLE :
                *pOffset = (*pOffset + 3) & ~ 0x3;
                *pOffset += 8;
                break;
    
            case FC_LONG :
            case FC_FLOAT :
                *pOffset = (*pOffset + 3) & ~ 0x3;
                *pOffset += 4;
                break;
            
            case FC_INT128:
            case FC_FLOAT80:
            case FC_FLOAT128:
                // Check calling convention for these
                // once VC implements them.
                *pOffset = (*pOffset + 3) & ~ 0x3;
                *pOffset += 16;
                break;

            default :
                *pOffset += 4;
                break;
            }
        }
}

FORMAT_CHARACTER
CG_ENUM::GetFormatChar( CCB * )
{
    return ( IsEnumLong() ? FC_ENUM32 : FC_ENUM16 );
}

NDR64_FORMAT_CHARACTER
CG_ENUM::GetNDR64FormatChar( CCB * )
{
    MIDL_ASSERT( IsEnumLong() );
    return FC64_INT32;
}

FORMAT_CHARACTER
CG_ENUM::GetSignedFormatChar()
{
    return ( IsEnumLong() ? FC_LONG : FC_SHORT );
}

NDR64_FORMAT_CHARACTER
CG_ENUM::GetNDR64SignedFormatChar()
{
    MIDL_ASSERT( IsEnumLong() );
    return FC64_INT32;
}

FORMAT_CHARACTER
CG_ERROR_STATUS_T::GetFormatChar( CCB * )
{
    return FC_ERROR_STATUS_T;
}

NDR64_FORMAT_CHARACTER
CG_ERROR_STATUS_T::GetNDR64FormatChar( CCB * )
{
    return FC64_ERROR_STATUS_T;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\bindndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    bindndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    the code generation bind classes.

 Notes:


 History:

    DKays     Dec-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG * pCommand;

void
CG_HANDLE::GenNdrParamDescription( CCB * )
{
    MIDL_ASSERT(0);
}

void
CG_HANDLE::GenNdrParamDescriptionOld( CCB * )
{
    MIDL_ASSERT(0);
}

unsigned char
CG_HANDLE::MakeExplicitHandleFlag(
    CG_PARAM *      pHandleParam )
/*++

Description:

    Produces a handle flag byte (actually, a nibble) that can keep the
    following simple flags:

        HANDLE_PARAM_IS_VIA_PTR - Bind param is a pointer to a handle type.

Note:

    Flags are set on the upper nibble (lower nibble is used for generic
    handle size).

--*/
{
    unsigned char  Flag = 0;

    if ( pHandleParam->GetChild()->IsPointer() )
        Flag |= HANDLE_PARAM_IS_VIA_PTR;

    return( Flag );
}

unsigned char
CG_CONTEXT_HANDLE::MakeExplicitHandleFlag(
    CG_PARAM *      pHandleParam )
/*++

Description:

    Produces a handle flag byte (actually, a nibble) that can keep the
    following simple flags:

        HANDLE_PARAM_IS_VIA_PTR - Bind param is a pointer to a handle type.
        HANDLE_PARAM_IS_IN -      Bind param is [in] (context handles only).
        HANDLE_PARAM_IS_OUT -     Bind param is [out] (context handles only).
        HANDLE_PARAM_IS_RETURN -  Bind param is return (context handles only).

Note:

    Flags are set on the upper nibble (lower nibble is used for generic
    handle size).

--*/
{
    unsigned char  Flag = CG_HANDLE::MakeExplicitHandleFlag( pHandleParam );

    if ( pHandleParam->IsParamIn() )
        Flag |= HANDLE_PARAM_IS_IN;
    if ( pHandleParam->IsParamOut() )
        Flag |= HANDLE_PARAM_IS_OUT;
    if ( pHandleParam->GetCGID() == ID_CG_RETURN )
        Flag |= HANDLE_PARAM_IS_RETURN;

    return ( Flag );
}

void
CG_PRIMITIVE_HANDLE::GetNdrHandleInfo( CCB * pCCB, NDR64_BINDINGS *pBinding )
{
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pBinding->Primitive.HandleType = (NDR64_FORMAT_CHAR)(pCommand->IsNDR64Run() ? FC64_BIND_PRIMITIVE :
                                                              FC_BIND_PRIMITIVE);
    pBinding->Primitive.Flags = MakeExplicitHandleFlag( pBindParam );
    pBinding->Primitive.Reserved = 0;    
    pBinding->Primitive.StackOffset = 0xBAAD;
    // StackOffset should be reset by the callee
}

void
CG_PRIMITIVE_HANDLE::GenNdrHandleFormat( CCB * pCCB )
/*++
    The layout is:

        FC_BIND_PRIMITIVE
        handle flag <1>
        stack offset<2>
--*/
{
    FORMAT_STRING *pProcFormatString = pCCB->GetProcFormatString();
    CG_PARAM      *pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    NDR64_BINDINGS binding;

    SetNdrBindDescriptionOffset( pProcFormatString->GetCurrentOffset() );
    GetNdrHandleInfo( pCCB, &binding );

    MIDL_ASSERT( FC_BIND_PRIMITIVE == binding.Primitive.HandleType );
    pProcFormatString->PushFormatChar( 
                            (FORMAT_CHARACTER ) binding.Primitive.HandleType );
    pProcFormatString->PushByte( binding.Primitive.Flags );

    pProcFormatString->PushUShortStackOffsetOrSize(
                    pBindParam->GetStackOffset( pCCB, I386_STACK_SIZING ));
}

void
CG_GENERIC_HANDLE::GetNdrHandleInfo( CCB * pCCB, NDR64_BINDINGS *pBinding )
{
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    NDR64_UINT8 Flags = MakeExplicitHandleFlag( pBindParam );

    NDR64_UINT8 RoutineIndex = (NDR64_UINT8) 
                               ( pCCB->LookupBindingRoutine(
                                                GetHandleTypeName() ) - 1 );

    pBinding->Generic.HandleType   = (NDR64_FORMAT_CHAR)(pCommand->IsNDR64Run() ? FC64_BIND_GENERIC :
                                                              FC_BIND_GENERIC);
    pBinding->Generic.Flags        = Flags;
    pBinding->Generic.RoutineIndex = RoutineIndex;
    pBinding->Generic.Size         = (NDR64_UINT8) GetMemorySize();
    pBinding->Generic.StackOffset  = 0xBAAD;
    // StackOffset should be reset by the callee

    // Make a note if the table would be actually used by the interpreter.

    if ( pCCB->GetOptimOption()  &  OPTIMIZE_INTERPRETER )
        pCCB->SetInterpretedRoutinesUseGenHandle();

    //
    // Register the handle.
    //
    pCCB->RegisterGenericHandleType( GetHandleType() );
}


void
CG_GENERIC_HANDLE::GenNdrHandleFormat( CCB * pCCB )
/*++
    The layout is:

        FC_BIND_GENERIC
        handle flag, handle size <high nibble, low nibble>
        stack offset <2>
        routine index<1>
        FC_PAD
--*/
{
    FORMAT_STRING * pProcFormatString = pCCB->GetProcFormatString();
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    NDR64_BINDINGS  binding;

    SetNdrBindDescriptionOffset( pProcFormatString->GetCurrentOffset() );
    GetNdrHandleInfo( pCCB, &binding );

    MIDL_ASSERT( FC_BIND_GENERIC == binding.Primitive.HandleType );
    pProcFormatString->PushFormatChar( 
                            (FORMAT_CHARACTER) binding.Generic.HandleType );
    pProcFormatString->PushByte(
                            binding.Generic.Flags | binding.Generic.Size );

    pProcFormatString->PushUShortStackOffsetOrSize(
                    pBindParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    pProcFormatString->PushByte( binding.Generic.RoutineIndex );
    pProcFormatString->PushFormatChar( FC_PAD );
}


void
CG_CONTEXT_HANDLE::GetNdrHandleInfo( CCB * pCCB, NDR64_BINDINGS *pBinding )
{
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    unsigned char   uFlags;

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    uFlags = MakeExplicitHandleFlag( pBindParam );
    if ( fStrictContext )
        {
        uFlags |= NDR_STRICT_CONTEXT_HANDLE;
        }
    if ( fNoSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_NOSERIALIZE;
        }
    else if ( fSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_SERIALIZE;
        }

    NDR64_UINT8 RoutineIndex = (NDR64_UINT8) 
                               ( pCCB->LookupRundownRoutine(
                                                GetRundownRtnName() ) - 1 );

    pBinding->Context.HandleType   = (NDR64_FORMAT_CHAR)(pCommand->IsNDR64Run() ? FC64_BIND_CONTEXT :
                                                              FC_BIND_CONTEXT);
    pBinding->Context.Flags        = uFlags;
    pBinding->Context.RoutineIndex = RoutineIndex;
    pBinding->Context.Ordinal      = 0;      // BUGBUG
    pBinding->Context.StackOffset  = 0xBAAD;
    // StackOffset should be reset by the callee

    if ( GetHandleType()->NodeKind() == NODE_DEF )
        {
        pCCB->RegisterContextHandleType( GetHandleType() );
        }
}

void
CG_CONTEXT_HANDLE::GenNdrHandleFormat( CCB * pCCB )
/*++
    The layout is:

        FC_BIND_CONTEXT
        handle flag  <1>  upper nibble ptr,in,out,ret, lower: strict,no,ser
        stack offset <2>
        routine index<1>
        FC_PAD
--*/
{
    FORMAT_STRING * pProcFormatString = pCCB->GetProcFormatString();
    CG_PARAM      * pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    NDR64_BINDINGS  binding;

    SetNdrBindDescriptionOffset( pProcFormatString->GetCurrentOffset() );
    GetNdrHandleInfo( pCCB, &binding );

    MIDL_ASSERT( FC_BIND_CONTEXT == binding.Context.HandleType );
    pProcFormatString->PushFormatChar( 
                            (FORMAT_CHARACTER) binding.Context.HandleType );
    pProcFormatString->PushContextHandleFlagsByte( binding.Context.Flags );
                  
    pProcFormatString->PushUShortStackOffsetOrSize(
                    pBindParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    pProcFormatString->PushByte( binding.Context.RoutineIndex );
    pProcFormatString->PushByte( binding.Context.Ordinal );
}


void
CG_PRIMITIVE_HANDLE::GenNdrFormat( CCB * )
/*++

Routine Description :
    
--*/
{
    // Do nothing.
}

void
CG_GENERIC_HANDLE::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :
    
    This routine is only called in the case of a pointer to a generic handle
    in which case the context handle just acts as an intermediary between the
    pointer and underlying user type.

--*/
{
    CG_NDR *    pChild;

    pChild = (CG_NDR *)GetChild();

    if ( GetFormatStringOffset() != -1 )
        return;

    pChild->GenNdrFormat( pCCB );

    SetFormatStringOffset( pChild->GetFormatStringOffset() );

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    //
    // Register the generic handle.
    //
    if ( ((CG_PROC *)pCCB->GetCGNodeContext())->GetHandleClassPtr() == this )
        pCCB->RegisterGenericHandleType( GetHandleType() );
}

void
CG_CONTEXT_HANDLE::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :
    
--*/
{
    FORMAT_STRING * pFormatString;
    CG_PARAM *      pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    CG_PROC *       pProc;
    
    pProc = (CG_PROC *) pCCB->GetCGNodeContext();
    MIDL_ASSERT( pProc->IsProc() );

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // Output an abbreviated description in the type format string.
    //
    pFormatString->PushFormatChar( FC_BIND_CONTEXT );

    //
    // Register the rundown routine always, even if the context handle is
    // not used as the binding paramter.
    //
    if ( GetHandleType()->NodeKind() == NODE_DEF )
        {
        pCCB->RegisterContextHandleType( GetHandleType() );
        }

    // Flags.
    unsigned char uFlags = MakeExplicitHandleFlag( pBindParam );
    if ( fStrictContext )
        {
        uFlags |= NDR_STRICT_CONTEXT_HANDLE;
        }
    if ( fNoSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_NOSERIALIZE;
        }
    else if ( fSerialize )
        {
        uFlags |= NDR_CONTEXT_HANDLE_SERIALIZE;
        }
    if ( GetCannotBeNull()  ||  
         pBindParam->IsParamIn() && !pBindParam->IsParamOut() )
        {
        uFlags |= NDR_CONTEXT_HANDLE_CANNOT_BE_NULL;
        }

    pFormatString->PushContextHandleFlagsByte( uFlags );
                  

    // Routine index.
    // IndexMgr keeps indexes 1..n, we use indexes 0..n-1

    pFormatString->PushByte(
            (char) (pCCB->LookupRundownRoutine(GetRundownRtnName()) - 1) );

    if ( pCCB->GetOptimOption() & OPTIMIZE_NON_NT351 )
        {
        // Context handle's parameter number.
        pFormatString->PushByte( pProc->GetContextHandleCount() );
        pProc->SetContextHandleCount( short(pProc->GetContextHandleCount() + 1) );
        }
    else
        {
        // Context handle's parameter number.  MIDL 2.00.102 and older stubs.
        pFormatString->PushByte( pBindParam->GetParamNumber() );
        }

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );

}

void
CG_PRIMITIVE_HANDLE::GenNdrParamOffline( CCB * )
{
    // Do nothing.
}

void
CG_GENERIC_HANDLE::GenNdrParamOffline( CCB * pCCB )
{
    ((CG_NDR *)GetChild())->GenNdrParamOffline( pCCB );

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    //
    // Register the generic handle.
    //
    if ( ((CG_PROC *)pCCB->GetCGNodeContext())->GetHandleClassPtr() == this )
        pCCB->RegisterGenericHandleType( GetHandleType() );
}

void
CG_CONTEXT_HANDLE::GenNdrParamOffline( CCB * pCCB )
{
    GenNdrFormat( pCCB );
}

void
CG_PRIMITIVE_HANDLE::GenNdrParamDescription( CCB * )
{
    // No description is emitted, handle_t is not marshalled.
}

void
CG_GENERIC_HANDLE::GetNdrParamAttributes( 
        CCB * pCCB, 
        PARAM_ATTRIBUTES *attributes )
{
    ((CG_NDR *)GetChild())->GetNdrParamAttributes( pCCB, attributes );
}

void
CG_GENERIC_HANDLE::GenNdrParamDescription( CCB * pCCB )
{
    ((CG_NDR *)GetChild())->GenNdrParamDescription( pCCB );
}

void
CG_CONTEXT_HANDLE::GetNdrParamAttributes(
        CCB * pCCB,
        PARAM_ATTRIBUTES *attributes )
{
    CG_NDR::GetNdrParamAttributes( pCCB, attributes );
}

void
CG_CONTEXT_HANDLE::GenNdrParamDescription( CCB * pCCB )
{
    CG_NDR::GenNdrParamDescription( pCCB );
}

//
// +++++++++++++++++++
// Old style parameter description routines.
// +++++++++++++++++++
//
void
CG_PRIMITIVE_HANDLE::GenNdrParamDescriptionOld( CCB * pCCB )
{
    FORMAT_STRING * pProcFormatString;

    pProcFormatString = pCCB->GetProcFormatString();

    pProcFormatString->PushFormatChar( FC_IGNORE );
}

void
CG_GENERIC_HANDLE::GenNdrParamDescriptionOld( CCB * pCCB )
{
    ((CG_NDR *)GetChild())->GenNdrParamDescriptionOld( pCCB );
}

void
CG_CONTEXT_HANDLE::GenNdrParamDescriptionOld( CCB * pCCB )
{
    CG_NDR::GenNdrParamDescriptionOld( pCCB );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ccb.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    ccb.cxx

 Abstract:

    Some method implementations of the ccb code generation class.

 Notes:


 History:

    Sep-20-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4505 )

 /****************************************************************************
 *      include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

extern  CMD_ARG *   pCommand;

/****************************************************************************
 *      local definitions
 ***************************************************************************/



/****************************************************************************
 *      local data
 ***************************************************************************/

/****************************************************************************
 *      externs
 ***************************************************************************/
/****************************************************************************/

CCB::CCB(
    PNAME           pGBRtnName,
    PNAME           pSRRtnName,
    PNAME           pFBRtnName,
    OPTIM_OPTION    OptimOption,
    BOOL            fManagerEpv,
    BOOL            fNoDefEpv,
    BOOL            fOldNames,
    unsigned long   Mode,
    BOOL            fRpcSSSwitchSetInCompiler,
    BOOL            fMustCheckAllocError,
    BOOL            fCheckRef,
    BOOL            fCheckEnum,
    BOOL            fCheckBounds,
    BOOL            fCheckStubData )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Arguments:

    pGBRtnName      - default get buffer routine name
    pSRRtnName      - default send receive routine name
    pFBRtnName      - default free buffer routine name
    OptimOption     - optimisation options.
    fManagerEpvFlag - manager epv flag.
    fOldNames       - Do we want MIDL 1.0 style names.
    fNoDefEpv       - we dont want a default epv generated.
    Mode            - Compiler mode : 0 for osf, 1 for ms_ext
    fRpcSSSwitchSetInCompiler - corresponds to -rpcss enabled
    fMustCheckAllocError - corresponds to -error allocation on command line
    fCheckRef       - Check ref pointers
    fCheckEnum      - Check enums
    fCheckBounds    - Check array bounds.
    fCheckStubData  - Check for bad stub data.

 Return Value:

 Notes:

    If the manager epv was set, then we generate the epv calls. Else produce
    statically linked stubs (default behaviour).
----------------------------------------------------------------------------*/
{
    SetStream( 0, NULL );
    SetOptimOption( OptimOption );

    // We can't use SetRuntimeRtnNames here because if any of the names
    // are NULL the member won't get initialized.  This also make the 
    // existing version of SetRuntimeRtnNames obsolete.

    pGetBufferRtnName = pGBRtnName;
    pSendReceiveRtnName = pSRRtnName;
    pFreeBufferRtnName = pFBRtnName;

    // These don't appear to be used

    pIUnknownCG = 0;
    pIClassfCG = 0;
    pStubDescResource = 0;

    // These all seem to be lazily initialized so strictly speaking they don't
    // need to be initialized here but it's lots safer
   
    EmbeddingLevel = 0;
    IndirectionLevel = 0;
    fDeferPointee = 0;
    fAtLeastOneDeferredPointee = 0;
    fMemoryAllocDone = 0;
    fRefAllocDone = 0;
    fReturnContext = 0;

    pInterfaceCG = 0;
    pFileCG = 0;
    pInterfaceName = 0;
    MajorVersion = 0;
    MinorVersion = 0;
    CurrentProcNum = 0;
    CurrentVarNum = 0;
    RpcFlags = 0;
    pAllocRtnName = 0;
    pFreeRtnName = 0;
    pResDictDatabase = 0;
    pCurrentSizePointer = 0;
    lcid = 0;

    // There is no "uninitialized" value to set CodeGenPhase and CodeGenSide
    // to nor any logical value to initialize them to at this point.  Manual
    // inspection seems to indicate that they are properly set as needed.

    // CodeGenPhase = ??
    // CodeGenSide = ??

    //
    // GetPtrToPtrInBuffer is used in CG_POINTER::PointerChecks but nobody
    // seems to call SetPtrInPtrInBuffer so this may be dead wood
    //

    PtrToPtrInBuffer = 0;

    pFormatString = NULL;
    pProcFormatString = NULL;
    pExprFormatString = NULL;

    pGenericHandleRegistry  = new TREGISTRY;
    pContextHandleRegistry  = new TREGISTRY;
    pPresentedTypeRegistry  = new TREGISTRY;
    pRepAsWireTypeRegistry  = new TREGISTRY;
    pQuintupleRegistry      = new TREGISTRY;
    pExprEvalRoutineRegistry= new TREGISTRY;
    pSizingRoutineRegistry  = new TREGISTRY;
    pMarshallRoutineRegistry= new TREGISTRY;
    pUnMarshallRoutineRegistry = new TREGISTRY;
    pFreeRoutineRegistry    = new TREGISTRY;
    pMemorySizingRoutineRegistry = new TREGISTRY;
    pTypeAlignSizeRegistry  = new TREGISTRY;
    pTypeEncodeRegistry     = new TREGISTRY;
    pTypeDecodeRegistry     = new TREGISTRY;
    pTypeFreeRegistry       = new TREGISTRY;
    pPickledTypeList        = new IndexedList;
    pProcEncodeDecodeRegistry= new TREGISTRY;
    pCallAsRoutineRegistry  = new TREGISTRY;

    pRecPointerFixupRegistry = NULL;

    SetImplicitHandleIDNode( 0 );

    SetCGNodeContext( NULL );
    pCurrentRegionField = NULL;
    SetLastPlaceholderClass( NULL );
    
    SetPrefix( 0 );

    pGenericIndexMgr = new CCB_RTN_INDEX_MGR();
    pContextIndexMgr = new CCB_RTN_INDEX_MGR();

    pExprEvalIndexMgr = new CCB_RTN_INDEX_MGR();

    pExprFrmtStrIndexMgr = NULL;

    pTransmitAsIndexMgr = new CCB_RTN_INDEX_MGR();
    pRepAsIndexMgr = new CCB_RTN_INDEX_MGR();

    pQuintupleDictionary = new QuintupleDict;
    pQuadrupleDictionary = new QuadrupleDict;

    pRepAsPadExprDictionary = new RepAsPadExprDict();
    pRepAsSizeDictionary    = new RepAsSizeDict();

    SetImbedingMemSize(0);
    SetImbedingBufSize(0);

    ClearInCallback();

    fMEpV   = fManagerEpv;
    fNoDefaultEpv = fNoDefEpv;
    fInterpretedRoutinesUseGenHandle = 0;

    ClearOptionalExternFlags();
    fSkipFormatStreamGeneration = 1;

    SetOldNames( (fOldNames == TRUE) ? 1 : 0 );

    SetMode( Mode );

    SetInObjectInterface( FALSE );

    SetRpcSSSwitchSet( fRpcSSSwitchSetInCompiler );
    SetMustCheckAllocationError( fMustCheckAllocError );
    SetMustCheckRef( fCheckRef );
    SetMustCheckEnum( fCheckEnum );
    SetMustCheckBounds( fCheckBounds );
    SetMustCheckStubData( fCheckStubData );
    pCreateTypeLib = NULL;
    pCreateTypeInfo = NULL;
    szDllName = NULL;
    SetInDispinterface(FALSE);

    SetCurrentParam( 0 );
    SetInterpreterOutSize( 0 );

    SetNdr64Format( NULL );
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 These routines simply bounce to the file level routines.  They really
 should be inline but the depencies between ccb.hxx and filecls.cxx are
 really ugly and I haven't figured them out yet

----------------------------------------------------------------------------*/

BOOL CCB::GetMallocAndFreeStructExternEmitted()
{
    return pFile->GetMallocAndFreeStructExternEmitted();
}

void CCB::SetMallocAndFreeStructExternEmitted()
{
    pFile->SetMallocAndFreeStructExternEmitted();
}



char *
CCB::GenMangledName()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Given an input name, mangle it with the interface name and version.

 Arguments:

 Return Value:

    A pointer to allocated string containing the complete mangled string.

 Notes:

    This is how the mangling takes place:

    <interface-name>_v<Major>_<Minor>_<pInputName>

    This is what is returned by the routine:

        "v<Major>_<Minor>"

        or

        ""
----------------------------------------------------------------------------*/
{
static  char    TempBuf[30];
    unsigned short  M,m;

    GetVersion( &M, &m );

    if( IsOldNames() )
        {
        TempBuf[ 0 ] = '\0';
        }
    else
        {
        sprintf( TempBuf,
            "_v%d_%d",
            M,
            m );
        }

    return TempBuf;
}

RESOURCE *
CCB::GetStandardResource(
    STANDARD_RES_ID ResID )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Search for a resource with a standard name.

 Arguments:

    ResID   - The standard resource ID.

 Return Value:

 Notes:

    Translate the enum to the name. Search in all dictionaries.
----------------------------------------------------------------------------*/
{
    PNAME       pName;
    RESOURCE *  pResource;

    static char * LocalResIDToResName[] =
        {
        RPC_MESSAGE_VAR_NAME
        ,STUB_MESSAGE_VAR_NAME
        ,GetInterfaceCG()->GetStubDescName()
        ,BUFFER_POINTER_VAR_NAME
        ,RPC_STATUS_VAR_NAME
        ,LENGTH_VAR_NAME
        ,BH_LOCAL_VAR_NAME
        ,PXMIT_VAR_NAME
        };

    static char * ParamResIDToResName[] =
        {
        PRPC_MESSAGE_VAR_NAME
        };

    static char * GlobalResIDToResName[] =
        {
        AUTO_BH_VAR_NAME
        };

    if( IS_STANDARD_LOCAL_RESOURCE( ResID ) )
        {
        pName = LocalResIDToResName[ ResID - ST_LOCAL_RESOURCE_START ];
        }
    else if( IS_STANDARD_PARAM_RESOURCE( ResID ) )
        {
        pName = ParamResIDToResName[ ResID - ST_PARAM_RESOURCE_START ];
        }
    else if( IS_STANDARD_GLOBAL_RESOURCE( ResID ) )
        {
        pName = GlobalResIDToResName[ ResID - ST_GLOBAL_RESOURCE_START ];
        }
#if defined(MIDL_ENABLE_ASSERTS)
    else MIDL_ASSERT(0);
#endif

    if ( ( pResource = GetResDictDatabase()->GetLocalResourceDict()->Search( pName ) ) == 0 )
        {
        if ( ( pResource = GetResDictDatabase()->GetParamResourceDict()->Search( pName ) ) == 0)
            {
            if ( (pResource = GetResDictDatabase()->GetTransientResourceDict()->Search(pName) ) == 0)
                {
                if ( ( pResource=GetResDictDatabase()->GetGlobalResourceDict()->Search(pName) ) == 0 )
                    return 0;
                }
            }
        }

    return pResource;
}

RESOURCE *
CCB::DoAddResource(
    RESOURCE_DICT   *   pResDict,
    PNAME               pName,
    node_skl        *   pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Add a resource to a dictionary.

 Arguments:

    pResDict - A pointer to the resource dictionary.
    pName    - The resource name.
    pType    - The type of the resource.

 Return Value:

 Notes:

    If the type of the resource does not indicate a param node, assume it
    is an ID node and create an id node for it.

----------------------------------------------------------------------------*/
{
    RESOURCE * pRes;

    if( (pRes = pResDict->Search( pName )) == 0 )
        {
        pRes = pResDict->Insert( pName, pType );
        }

    return pRes;
}

RESOURCE *
CCB::SetStubDescResource()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set up the stub descriptor resource.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    node_id * pStubDescVar = new node_id( GetInterfaceCG()->GetStubDescName() );

    pStubDescVar->SetBasicType( (node_skl *)
        new node_def( STUB_DESC_STRUCT_TYPE_NAME ) );

    pStubDescVar->SetEdgeType( EDGE_USE );

    pStubDescResource = new RESOURCE( GetInterfaceCG()->GetStubDescName(),
                                      (node_skl *)pStubDescVar );
    return pStubDescResource;
}


void
CCB::OutputRundownRoutineTable()
{
    OutputSimpleRoutineTable( pContextIndexMgr,
                              RUNDOWN_ROUTINE_TABLE_TYPE,
                              RUNDOWN_ROUTINE_TABLE_VAR );
}

void
CCB::OutputExprEvalRoutineTable()
{
    OutputSimpleRoutineTable( pExprEvalIndexMgr,
                              EXPR_EVAL_ROUTINE_TABLE_TYPE,
                              EXPR_EVAL_ROUTINE_TABLE_VAR );
}

void
CCB::OutputSimpleRoutineTable(
    CCB_RTN_INDEX_MGR * pIndexMgr,
    char *              pTableTypeName,
    char *              pTableVarName
    )
{
    long                        i;
    char *              pName;

    pStream->NewLine();
    pStream->Write( "static const " );
    pStream->Write( pTableTypeName );
    pStream->Write( ' ' );
    pStream->Write( pTableVarName );
    pStream->Write( "[] = ");

    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    for ( i = 1; ( pName = pIndexMgr->Lookup(i) ) != 0 ; i++ )
        {
        if ( i != 1 )
            pStream->Write( ',' );
        pStream->Write( pName );
        pStream->NewLine();
        }

    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->NewLine( 2 );
}

void 
CCB::OutputOldExprEvalRoutine(EXPR_EVAL_CONTEXT *pExprEvalContext)
{
    CG_NDR *        pContainer  = pExprEvalContext->pContainer;
    expr_node *     pMinExpr    = pExprEvalContext->pMinExpr;
    expr_node *     pSizeExpr   = pExprEvalContext->pSizeExpr;
    char *          pRoutineName= pExprEvalContext->pRoutineName;
    unsigned long   Displacement= pExprEvalContext->Displacement;
    pStream     =   GetStream();

    // generate the header of the evaluation routine

    pStream->NewLine();
    pStream->Write( "static void __RPC_USER " );
    pStream->Write( pRoutineName );
    pStream->Write( "( PMIDL_STUB_MESSAGE pStubMsg )" );
    pStream->NewLine();
    pStream->Write( '{');
    pStream->IndentInc();
    pStream->NewLine();

    //
    // Get the proper struct type.
    //
    char * pContainerTypeName = 0;

    MIDL_ASSERT( pContainer->IsStruct() || pContainer->IsProc() );

    if ( pContainer->IsProc() )
        {
        MIDL_ASSERT( GetOptimOption() | OPTIMIZE_INTERPRETER );

        SetCGNodeContext( pContainer );

        ((CG_PROC *)pContainer)->GenNdrInterpreterParamStruct( this );

        pContainerTypeName = PARAM_STRUCT_TYPE_NAME;
        }
    else
        {
        pContainerTypeName = ((CG_STRUCT *)pContainer)->
                                GetType()->GetSymName();
        }

    expr_node * pExpr = new expr_variable( "pStubMsg->StackTop" );

    if ( Displacement )
        {
        expr_constant * pConstExpr =
                            new expr_constant( (long) Displacement );
        expr_op_binary * pSubtrExpr = new expr_op_binary( OP_MINUS,
                                                          pExpr,
                                                          pConstExpr );
        pExpr = pSubtrExpr;
        }

    //
    // Don't change this call - Dave.
    //
    node_id * pId;

    if ( pContainer->IsProc() )
        {
        pId = MakePtrIDNodeFromTypeNameWithCastedExpr(
                "pS",
                pContainerTypeName,
                pExpr );
        }
    else
        {
        pId = MakePtrIDNodeWithCastedExpr(
                "pS",
                pContainer->GetType(),
                pExpr );
        }

    pId->PrintType( PRT_ID_DECLARATION, pStream );
    pStream->NewLine();

    // generate calculation for the Offset field
    char    TotalPrefix[256];

    strcpy( TotalPrefix, "pS->" );
    strcat( TotalPrefix, pExprEvalContext->pPrintPrefix );

    pStream->Write( "pStubMsg->Offset = " );
    if ( pMinExpr )
        {
        pMinExpr->PrintWithPrefix( pStream, TotalPrefix );
        pStream->Write( ';' );
        }
    else
        pStream->Write( "0;" );
    pStream->NewLine();

    // generate calculation for MaxCount.

    if ( pCommand->Is64BitEnv() )
        {
        // pStubMsg->MaxCount = (ULONG_PTR) ...
        pStream->Write( "pStubMsg->MaxCount = (ULONG_PTR) ( " );
        }
    else
        {
        // pStubMsg->MaxCount = ( unsigned long ) ...
        pStream->Write( "pStubMsg->MaxCount = ( unsigned long ) ( " );
        }
    pSizeExpr->PrintWithPrefix( pStream, TotalPrefix );

    pStream->Write( " );" );

/***
 *** Let's leave this out as the default for now.  This means first_is() with
     last_is() is broken, but first_is() with length_is() will work.

    if ( pMinExpr )
        {
        pStream->Write( " - pStubMsg->Offset;" );
        }
    else
        pStream->Write( ";" );

 ***
 ***/

    // generate the closing of the evaluation routine

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();
}

void
CCB::OutputRegisteredExprEvalRoutines()
{
    ITERATOR            RegisteredRoutines;
    EXPR_EVAL_CONTEXT * pExprEvalContext;

    GetListOfExprEvalRoutines( RegisteredRoutines);

    while ( ITERATOR_GETNEXT( RegisteredRoutines, pExprEvalContext ) )
        {
        OutputOldExprEvalRoutine(pExprEvalContext);
        }
}

void 
CCB::OutputExpressionFormatString()
{
    CCB_EXPR_INDEX_MGR * pIndexMgr = GetExprFrmtStrIndexMgr();
    char    Buf[200];
    
    pStream->NewLine();
    pStream->Write("static const unsigned short "EXPR_FORMAT_STRING_OFFSET_TABLE "[] =") ;
    pStream->NewLine();
    pStream->Write("{");
    pStream->NewLine();

    for (long i = 1; i < pIndexMgr->GetIndex(); i++)
        {
        pStream->Write( MIDL_ITOA(pIndexMgr->GetOffset(i), Buf, 10 ) );
        pStream->NewLine();
        }
    pStream->Write("};");
    pStream->NewLine();
    
    
//    GetExprFormatString()->OutputExprEvalFormatString(GetStream());       

}

// ========================================================================
//       user_marshall Quadruple table
// ========================================================================

void
CCB::OutputQuadrupleTable()
{

    static  char * QuadrupleNames[] =
        {
        USER_MARSHAL_SIZE,
        USER_MARSHAL_MARSHALL,
        USER_MARSHAL_UNMARSHALL,
        USER_MARSHAL_FREE
        };

    static  char * Ndr64QuadrupleNames[] =
        {
        NDR64_USER_MARSHAL_SIZE,
        NDR64_USER_MARSHAL_MARSHALL,
        NDR64_USER_MARSHAL_UNMARSHALL,
        NDR64_USER_MARSHAL_FREE
        };


    long NoOfEntries = GetQuadrupleDictionary()->GetCount();

    pStream->NewLine();
    pStream->Write("static const " USER_MARSHAL_ROUTINE_TABLE_TYPE );
    
    if ( pCommand->IsNDR64Run() )
        {
        pStream->Write( " " NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR 
                    "[ " WIRE_MARSHAL_TABLE_SIZE " ] = " );
        }
    else
        {
        pStream->Write( " " USER_MARSHAL_ROUTINE_TABLE_VAR 
                    "[ " WIRE_MARSHAL_TABLE_SIZE " ] = " );
        }
    pStream->IndentInc();
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    USER_MARSHAL_CONTEXT * * QuadrupleLookupTable;
    USER_MARSHAL_CONTEXT *   pQContext;
    int i;

    QuadrupleLookupTable = new USER_MARSHAL_CONTEXT *[ NoOfEntries ];

    ITERATOR  Quadruples;

    GetQuadrupleDictionary()->GetListOfItems( Quadruples );

    for ( i = 0;
          ITERATOR_GETNEXT( Quadruples, pQContext );
          i++ )
        {
        MIDL_ASSERT( pQContext->Index < NoOfEntries  &&  "look up index violation" );
        QuadrupleLookupTable[ pQContext->Index ] = pQContext;
        }

    MIDL_ASSERT( i == NoOfEntries );

    ISTREAM * pStream = GetStream();

    for ( i = 0; i < NoOfEntries; i++ )
        {
        pQContext = QuadrupleLookupTable[i];

        if ( i )
            pStream->Write( ',' );
        pStream->NewLine();
        pStream->Write( '{' );
        pStream->NewLine();
        for ( int FuncNo = 0;  FuncNo < 4; FuncNo++)
            {
            if ( FuncNo )
                pStream->Write( ',' );
            pStream->Write( pQContext->pTypeName );
            if ( pCommand->IsNDR64Run() )
                pStream->Write( Ndr64QuadrupleNames[ FuncNo ]  );
            else
                pStream->Write( QuadrupleNames[ FuncNo ]  );
            pStream->NewLine();
            }
        pStream->Write( '}' );
        }

    pStream->IndentDec();
    pStream->NewLine( 2 );
    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->NewLine( 2 );

    delete QuadrupleLookupTable;
}


// =======================================================================
//          International character sizing/conversion routine table
// =======================================================================

void CCB::OutputCsRoutineTables()
{
    char *pRoutineSuffix[4] = 
                {
                CS_NET_SIZE,
                CS_TO_NET_CS,
                CS_LOCAL_SIZE,
                CS_FROM_NET_CS
                };

    //
    // Output the sizing/conversion routines table
    //

    pStream->Write( CS_SIZE_CONVERT_ROUTINE_TABLE_TYPE );
    pStream->Write( ' ' );
    pStream->Write( CS_SIZE_CONVERT_ROUTINE_TABLE_VAR );
    pStream->Write( "[] =" );
    pStream->IndentInc();
    pStream->WriteOnNewLine( '{' );
    pStream->IndentInc();

    PNAME       pType;
    bool        fFirst = true;

    ITERATOR_INIT( CsTypes );

    while ( ITERATOR_GETNEXT( CsTypes, pType ) )
        {
        if ( ! fFirst )
            pStream->Write( ',' );

        pStream->WriteOnNewLine( '{' );

        for (int i = 0; i < 4; i++ )
            {
            pStream->WriteOnNewLine( pType );            
            pStream->Write( pRoutineSuffix[i] );
            pStream->Write( ',' );
            }

        pStream->WriteOnNewLine( '}' );

        fFirst = false;
        }
    
    pStream->IndentDec();
    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    //
    // Output the tag routines table
    //

    if ( 0 != CsTagRoutines.GetCount() )
        {
        pStream->WriteOnNewLine( CS_TAG_ROUTINE_TABLE_TYPE );
        pStream->Write( ' ' );
        pStream->Write( CS_TAG_ROUTINE_TABLE_VAR );
        pStream->Write( "[] =" );
        pStream->IndentInc();
        pStream->WriteOnNewLine( '{' );
        
        fFirst = true;

        ITERATOR_INIT( CsTagRoutines );

        while ( ITERATOR_GETNEXT( CsTagRoutines, pType ) )
            {
            if ( ! fFirst )
                pStream->Write( ',' );

            pStream->WriteOnNewLine( pType );

            fFirst = false;
            }

        pStream->WriteOnNewLine( "};" );
        pStream->IndentDec();
        pStream->NewLine();
        }

    //
    // Output the pointers-to-tables structure
    //

    pStream->WriteOnNewLine( CS_ROUTINE_TABLES_TYPE );
    pStream->Write( ' ' );
    pStream->Write( CS_ROUTINE_TABLES_VAR );
    pStream->Write( " =" );
    pStream->IndentInc();
    pStream->WriteOnNewLine( '{' );
    pStream->WriteOnNewLine( CS_SIZE_CONVERT_ROUTINE_TABLE_VAR );
    pStream->Write( ',' );
    pStream->WriteOnNewLine( ( 0 != CsTagRoutines.GetCount() )
                                    ? CS_TAG_ROUTINE_TABLE_VAR
                                    : "0" );
    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();
    pStream->NewLine();
}


// =======================================================================
//          Transmit as and Represent As tables.
// =======================================================================

char *
MakeAnXmitName(
    char *          pTypeName,
    char *          pRoutineName,
    unsigned short )
/*++
    makes the following name: <type_name>_<routine_name>_<index>
--*/
{
    MIDL_ASSERT( pTypeName  &&  pRoutineName );
    char * pXmitName = new char[ strlen(pTypeName) +
                                 strlen(pRoutineName) + 1 ];
    strcpy( pXmitName, pTypeName );
    strcat( pXmitName, pRoutineName );
    return( pXmitName );
}


#define QUINTUPLE_SIZE  4

typedef struct _QUINTUPLE_NAMES
    {
    char * TableType;
    char * TableVar;
    char * FuncName[ QUINTUPLE_SIZE ];
    } QUINTUPLE_NAMES;

void
CCB::OutputQuintupleTable()
{
    static  QUINTUPLE_NAMES TransmitNames =
        {
        XMIT_AS_ROUTINE_TABLE_TYPE,
        XMIT_AS_ROUTINE_TABLE_VAR,
        XMIT_TO_XMIT,
        XMIT_FROM_XMIT,
        XMIT_FREE_XMIT,
        XMIT_FREE_INST
        };

    static  QUINTUPLE_NAMES RepNames=
        {
        REP_AS_ROUTINE_TABLE_TYPE,
        REP_AS_ROUTINE_TABLE_VAR,
        REP_FROM_LOCAL,
        REP_TO_LOCAL,
        REP_FREE_INST,
        REP_FREE_LOCAL
        };

    long NoOfEntries = GetQuintupleDictionary()->GetCount();

    pStream->NewLine();
    pStream->Write("static const "XMIT_AS_ROUTINE_TABLE_TYPE );
    pStream->Write( " " XMIT_AS_ROUTINE_TABLE_VAR 
                    "[ " TRANSMIT_AS_TABLE_SIZE " ] = " );

    pStream->IndentInc();
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    // Now construct a lookup table with entries in the order of indexes.
    // (we have to keep index managers separate for rep_as and xmit_as
    //  and we still have a common table)

    XMIT_AS_CONTEXT * * QuintupleLookupTable;
    XMIT_AS_CONTEXT *   pQContext;
    int                 i;

    QuintupleLookupTable = new XMIT_AS_CONTEXT *[ NoOfEntries ];

    ITERATOR  Quintuples;

    GetListOfQuintuples( Quintuples );
    for ( i = 0;
          ITERATOR_GETNEXT( Quintuples, pQContext );
          i++ )
        {
        MIDL_ASSERT( pQContext->Index < NoOfEntries  &&  "look up index violation" );
        QuintupleLookupTable[ pQContext->Index ] = pQContext;
        }


    ISTREAM * pStream = GetStream();

    for ( i = 0; i < NoOfEntries; i++ )
        {
        pQContext = QuintupleLookupTable[i];

        char *  pName = pQContext->fXmit
                        ? pQContext->pTypeName
                        : ((CG_REPRESENT_AS *)pQContext->pXmitNode)->
                            GetTransmittedType()->GetSymName();
        unsigned short Index = pQContext->Index;

        MIDL_ASSERT( (i == Index)  && " xmit index violation" );

        QUINTUPLE_NAMES *   pQNames = pQContext->fXmit ?  & TransmitNames
                                                       :  & RepNames;
        if ( i )
            pStream->Write( ',' );
        pStream->NewLine();
        pStream->Write( '{' );
        pStream->NewLine();
        for ( int FuncNo = 0;  FuncNo < QUINTUPLE_SIZE; FuncNo++)
            {
            char * pTempName = MakeAnXmitName( pName,
                                               pQNames->FuncName[ FuncNo ],
                                               Index );
            if ( FuncNo )
                pStream->Write( ',' );
            pStream->Write( pTempName );
            pStream->NewLine();
            delete pTempName;
            }
        pStream->Write( '}' );
        }

    pStream->IndentDec();
    pStream->NewLine( 2 );
    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->NewLine( 2 );

    delete QuintupleLookupTable;
}


// =======================================================================
//   helpers for  Transmit as and Represent As routines
// =======================================================================

static void
OpenXmitOrRepRoutine(
    ISTREAM *   pStream,
    char *      pName )
/*++
Routine description:

    This routine emits the header of a *_as helper routine:

        void  __RPC_API
        <name>(  PMIDL_STUB_MESSAGE pStubMsg )
        {

Note:

    There is a side effect here that the name of the routine is deleted
    (this is always the name created by a call to MakeAnXmitName).

--*/
{
    pStream->Write  ( "NDR_SHAREABLE void __RPC_USER" );
    pStream->NewLine();
    pStream->Write  ( pName );
    pStream->Write  ( "( PMIDL_STUB_MESSAGE pStubMsg )" );
    pStream->NewLine();
    pStream->Write( '{');
    pStream->IndentInc();
    pStream->NewLine();

    delete pName;
}

static void
CloseXmitOrRepRoutine(
    ISTREAM *   pStream )
/*++
Routine description:

    Just a complement to the OpenXmitOrRepRoutine:

        }

--*/
{
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}');
    pStream->NewLine();
}

static void
OutputPresentedTypeInit(
    ISTREAM *   pStream,
    char *      pPresentedTypeName )
/*++
Routine description:

    Emits

        memset( pStubMsg->pPresentedType, 0, sizeof( <presented type> ));

--*/
{
    pStream->NewLine();
    pStream->Write( MIDL_MEMSET_RTN_NAME "( "PSTUB_MESSAGE_PAR_NAME"->pPresentedType, 0, sizeof(" );
    pStream->Write( pPresentedTypeName );
    pStream->Write( " ));" );
}

static void
OutputCastedPtr(
    ISTREAM *   pStream,
    char *      pTypeName,
    char *      pVarName )
{
    pStream->Write( '(' );
    pStream->Write( pTypeName );
    pStream->Write( " *) " );
    pStream->Write( pVarName );
}


// =======================================================================
//          Transmit as
// =======================================================================
//
// The presented type size problem.
// The engine doesn't use pStubMsg->PresentedTypeSize field anymore.
// The presented type size nowadays is passed within the format code.
//

static void
OutputToXmitCall(
    ISTREAM *   pStream,
    char *      pPresentedTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_to_xmit( " );
    OutputCastedPtr( pStream,
                     pPresentedTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pPresentedType, " );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '(' );
    pStream->Write( pTransmitTypeName );
    pStream->Write( " * *) &pStubMsg->pTransmitType );" );
    pStream->IndentDec();
//    pStream->NewLine();
}

static void
OutputFreeXmitCall(
    ISTREAM *   pStream,
    char *      pPresentedTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_free_xmit( " );
    OutputCastedPtr( pStream, pTransmitTypeName, "pStubMsg->pTransmitType );" );
}


void
CCB::OutputTransmitAsQuintuple(
    void *   pQuintupleContext
    )
/*++
Routine description:

    This routine emits the following helper routines for a transmit as type:

    static void  __RPC_API
    <pres_type>_Xmit_ToXmit_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_to_xmit( (<pres_type> *) pStubMsg->pPresentedType,
                             (<tran_type> * *) &pStubMsg->pTransmitType );
    }

    static void  __RPC_API
    <pres_type>_Xmit_FromXmit_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_from_xmit(
                        (<tran_type> *)  pStubMsg->pTransmitType,
                        (<pres_type> *)  pStubMsg->pPresentedType );

    }

    static void  __RPC_API
    <pres_type>_Xmit_FreeXmit_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_free_xmit(
                        (<tran_type> *)  pStubMsg-p>TransmitType );

    }

    static void  __RPC_API
    <pres_type>_Xmit_FreeInst_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <pres_type>_free_xmit(
                        (<pres_type> *) pStubMsg->pPresentedType );

    }

--*/
{
    XMIT_AS_CONTEXT * pTransmitAsContext = (XMIT_AS_CONTEXT*) pQuintupleContext;
    int i = pTransmitAsContext->Index;

    ISTREAM * pStream = GetStream();
    pStream->NewLine();

    CG_TRANSMIT_AS* pXmitNode = (CG_TRANSMIT_AS *)
                                pTransmitAsContext->pXmitNode;

    char * pPresentedTypeName = pXmitNode->GetPresentedType()->GetSymName();
    char * pTransmitTypeName = pXmitNode->GetTransmittedType()->
                                                           GetSymName();
    // *_XmitTranslateToXmit

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_TO_XMIT,
                                                   unsigned short(i) ) );
    OutputToXmitCall( pStream, pPresentedTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_XmitTranslateFromXmit

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_FROM_XMIT,
                                                   unsigned short(i) ) );
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_from_xmit( " );
    OutputCastedPtr( pStream, pTransmitTypeName, "pStubMsg->pTransmitType, " );
    pStream->IndentInc();
    pStream->NewLine();
    OutputCastedPtr( pStream, pPresentedTypeName, "pStubMsg->pPresentedType ); " );
    pStream->IndentDec();
    CloseXmitOrRepRoutine( pStream );

    // *_XmitFreeXmit

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_FREE_XMIT,
                                                   unsigned short(i) ) );
    OutputFreeXmitCall( pStream, pPresentedTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_XmitFreeInst

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pPresentedTypeName,
                                                   XMIT_FREE_INST,
                                                   unsigned short(i) ) );
    pStream->Write( pPresentedTypeName );
    pStream->Write( "_free_inst( " );
    OutputCastedPtr( pStream, pPresentedTypeName, "pStubMsg->pPresentedType ); " );
    CloseXmitOrRepRoutine( pStream );
}

void
CCB::OutputQuintupleRoutines()
/*++
--*/
{
    ITERATOR            Quintuples;
    XMIT_AS_CONTEXT *   pQuintupleContext;
    int                 i;

    // Multi-interface problem: This routine is only called after the last
        // interface.

    GetListOfQuintuples( Quintuples );
    for ( i = 1;
          ITERATOR_GETNEXT( Quintuples, pQuintupleContext );
          i++ )
        {
        if ( pQuintupleContext->fXmit )
            OutputTransmitAsQuintuple( pQuintupleContext );
        else
            OutputRepAsQuintuple( pQuintupleContext );
        }
}

// ========================================================================
//       Represent As
// ========================================================================
//
// There is a lot of symmetry between transmit as and represent as.
// We use that where possible. So, among other things there is the following
// mapping between represent as routines and the transmit as ones.
// (So called quintuple actually has 4 routines now.)
//
//  wrapers
//      pfnTranslateToXmit      *_to_xmit           *_from_local
//      pfnTranslateFromXmit    *_from_xmit         *_to_local
//      pfnFreeXmit             *_free_xmit         *_free_inst
//      pfnFreeInst             *_free_inst         *_free_local
//
// The presented type size problem.
//      This is either known and put into the format code explicitely,
//      or unknown and then put there via a C-compile macro.
//
// The presented type alignment problem.
//      There is a problem when there is a padding preceding a represent as
//      field. The engine needs to know what the alignment for the represent
//      as field is. As we may not know its type at the midl compile time,
//      the only way to deal with it is to use the parent structure name,
//      and the represent as field name.
//


static void
OutputToLocalCall(
    ISTREAM *   pStream,
    char *      pLocalTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_to_local( " );
    OutputCastedPtr( pStream, pTransmitTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pTransmitType, " );
    pStream->IndentInc();
    pStream->NewLine();
    OutputCastedPtr( pStream, pLocalTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pPresentedType ); " );
    pStream->IndentDec();
}

static void
OutputFromLocalCall(
    ISTREAM *   pStream,
    char *      pLocalTypeName,
    char *      pTransmitTypeName )
{
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_from_local( " );
    OutputCastedPtr( pStream, pLocalTypeName,
                     PSTUB_MESSAGE_PAR_NAME"->pPresentedType, " );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '(' );
    pStream->Write( pTransmitTypeName );
    pStream->Write( " * *) &pStubMsg->pTransmitType );" );
    pStream->IndentDec();
}

static void
OutputRepAsFreeInstCall(
    ISTREAM *   pStream,
    char *      pTransmitTypeName )
{
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_free_inst( " );
    OutputCastedPtr( pStream, pTransmitTypeName,
        PSTUB_MESSAGE_PAR_NAME"->pTransmitType );" );
}



void
CCB::OutputRepAsQuintuple(
    void *   pQuintupleContext
    )
/*++
Routine description:

    This routine emits the following helper routines for a transmit as type:

    static void  __RPC_API
    <trans_type>_RepAsFromLocal_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_from_local(
                        (<pres_type> *) pStubMsg->pPresentedType,
                        (<tran_type> * *) &pStubMsg->pTransmitType );
    }

    static void  __RPC_API
    <trans_type>_RepAsToLocal_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_to_local(
                        (<tran_type> *)  pStubMsg->pTransmitType,
                        (<pres_type> *)  pStubMsg->pPresentedType );

    }

    static void  __RPC_API
    <trans_type>_RepAsFreeInst_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_free_inst(
                        (<tran_type> *)  pStubMsg-p>TransmitType );

    }

    static void  __RPC_API
    <trans_type>_RepAsFreeLocal_<index>(  PMIDL_STUB_MESSAGE pStubMsg )
    {
        <trans_type>_free_local(
                        (<pres_type> *) pStubMsg->pPresentedType );

    }

--*/
{
    XMIT_AS_CONTEXT * pRepAsContext = (XMIT_AS_CONTEXT*) pQuintupleContext;
    int               i = pRepAsContext->Index;

    ISTREAM * pStream = GetStream();

    CG_REPRESENT_AS * pRepAsNode = (CG_REPRESENT_AS *)
                                      pRepAsContext->pXmitNode;

    char * pLocalTypeName = pRepAsNode->GetRepAsTypeName();
    char * pTransmitTypeName = pRepAsNode->GetTransmittedType()->
                                                           GetSymName();
    // *_RepAsTranslateToLocal

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_TO_LOCAL,
                                                   unsigned short(i) ) );
    OutputToLocalCall( pStream, pLocalTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_RepAsTranslateFromLocal

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_FROM_LOCAL,
                                                   unsigned short(i) ) );
    OutputFromLocalCall( pStream, pLocalTypeName, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_RepAsFreeInst

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_FREE_INST,
                                                   unsigned short(i) ) );
    OutputRepAsFreeInstCall( pStream, pTransmitTypeName );
    CloseXmitOrRepRoutine( pStream );

    // *_RepAsFreeLocal

    OpenXmitOrRepRoutine( pStream, MakeAnXmitName( pTransmitTypeName,
                                                   REP_FREE_LOCAL,
                                                   unsigned short(i) ) );
    pStream->Write( pTransmitTypeName );
    pStream->Write( "_free_local( " );
    OutputCastedPtr( pStream, pLocalTypeName, "pStubMsg->pPresentedType ); " );
    CloseXmitOrRepRoutine( pStream );

}

// ========================================================================
//       end of Transmit As and Represent As
// ========================================================================


BOOL
CCB::HasBindingRoutines( CG_HANDLE * pImplicitHandle )
{
    return  ! pGenericIndexMgr->IsEmpty() ||
        (pImplicitHandle &&
        pImplicitHandle->IsGenericHandle());
}

void
CCB::OutputBindingRoutines()
{
    long   i;
    char * pName;

    pStream->NewLine();
    pStream->Write( "static const " BINDING_ROUTINE_TABLE_TYPE );
    pStream->Write( " "  BINDING_ROUTINE_TABLE_VAR 
                    "[ " GENERIC_BINDING_TABLE_SIZE " ] = " );

    pStream->IndentInc();
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    for ( i = 1; ( pName = pGenericIndexMgr->Lookup(i) ) != 0 ; i++ )
        {
        if ( i != 1 )
            pStream->Write( ',' );
        pStream->Write( '{' );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( "(" GENERIC_BINDING_ROUTINE_TYPE ")" );
        pStream->Write( pName );
        pStream->Write( "_bind" );
        pStream->Write( ',' );
        pStream->NewLine();

        pStream->Write( "(" GENERIC_UNBINDING_ROUTINE_TYPE ")" );
        pStream->Write( pName );
        pStream->Write( "_unbind" );

        pStream->IndentDec();
        pStream->NewLine();

        pStream->Write( " }" );
        pStream->NewLine();
        }

    pStream->NewLine();
    pStream->Write( "};" );

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->NewLine();
    pStream->NewLine();
}


void
CCB::OutputMallocAndFreeStruct()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs the malloc and free struct for the RpcSsm connection.

    This is needed only at the client side and non object interfaces.

    If the [enable_allocate] affects a remote routine, the client side stub
    defaults to malloc and free when unmarshalling regardless of the
    compiler mode (osf vs. non-osf).

    Therefore, the structure gets generated:
        - always in the osf mode or
        - in non-osf when at least one routine is affected by the attribute.
    This is one-per-many-interfaces structure.

    Because of win16 DS register problems, malloc and free have to be
    accessed via wrappers with appropriate calling conventions.
    To simplify, we generate wrappers for every platform.

    REVIEW: win16 is gone, we should be able to get rid of the wrappers.

----------------------------------------------------------------------------*/
{
    // malloc and free wrappers.

    pStream->NewLine();
    pStream->Write( "static void * __RPC_USER" );
    pStream->NewLine();
    pStream->Write( GetInterfaceName() );
    pStream->Write( "_malloc_wrapper( size_t _Size )" );
    pStream->NewLine();
    pStream->Write( "{" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( "return( malloc( _Size ) );" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "}" );
    pStream->NewLine();

    pStream->NewLine();
    pStream->Write( "static void  __RPC_USER" );
    pStream->NewLine();
    pStream->Write( GetInterfaceName() );
    pStream->Write( "_free_wrapper( void * _p )" );
    pStream->NewLine();
    pStream->Write( "{" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( "free( _p );" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "}" );
    pStream->NewLine();

    // The structure.

    pStream->NewLine();
    pStream->Write( "static " MALLOC_FREE_STRUCT_TYPE_NAME );
    pStream->Write( " " MALLOC_FREE_STRUCT_VAR_NAME " = ");
    pStream->NewLine();
    pStream->Write( "{");
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( GetInterfaceName() );
    pStream->Write( "_malloc_wrapper," );
    pStream->NewLine();
    pStream->Write( GetInterfaceName() );
    pStream->Write( "_free_wrapper" );

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "};" );
    pStream->NewLine();
}

// ========================================================================


void
CCB::OutputExternsToMultipleInterfaceTables()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the tables that may be common to multiple interfaces.

 Arguments:

    pCCB - A pointer to the code gen controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    CGSIDE  Side = GetCodeGenSide();

    pStream->NewLine();

    //
    // Emit extern to the rundown routine table on the server Oi side,
    // if needed.
    //
    if ( (Side == CGSIDE_SERVER) &&
        ( GetOptimOption() & OPTIMIZE_INTERPRETER) &&
        HasRundownRoutines()  && ! GetRundownExternEmitted() )
        {
        pStream->Write( "extern const " RUNDOWN_ROUTINE_TABLE_TYPE );
        pStream->Write( " " RUNDOWN_ROUTINE_TABLE_VAR "[];" );
        pStream->NewLine();
        SetRundownExternEmitted();
        }

    //
    // Emit extern to the binding routine pair table on the client Oi stub
    // if needed.
    //
    if ( (Side == CGSIDE_CLIENT) &&
         GetInterpretedRoutinesUseGenHandle()  &&
         ! GetGenericHExternEmitted()
         )
        {
        pStream->Write( "extern const " BINDING_ROUTINE_TABLE_TYPE );
        pStream->Write( " "  BINDING_ROUTINE_TABLE_VAR 
                        "[ " GENERIC_BINDING_TABLE_SIZE " ];" );
        pStream->NewLine();
        SetGenericHExternEmitted();
        }

    //
    // Emit extern to the expr eval routine table on both sides.
    //
    if ( HasExprEvalRoutines()  &&  ! GetExprEvalExternEmitted() )
        {
        pStream->Write( "extern const " EXPR_EVAL_ROUTINE_TABLE_TYPE );
        pStream->Write( " " EXPR_EVAL_ROUTINE_TABLE_VAR "[];" );
        pStream->NewLine();
        SetExprEvalExternEmitted();
        }

    //
    // Emit extrn to the transmit as and rep as routine table on both sides.
    //
    if ( HasQuintupleRoutines()  &&  ! GetQuintupleExternEmitted() )
        {
        pStream->Write( "extern const " XMIT_AS_ROUTINE_TABLE_TYPE );
        pStream->Write( " " XMIT_AS_ROUTINE_TABLE_VAR 
                        "[ " TRANSMIT_AS_TABLE_SIZE " ];" );
        pStream->NewLine();
        SetQuintupleExternEmitted();
        }

    //
    // Emit extrn to the user_marshal routine table on both sides.
    //
    if ( HasQuadrupleRoutines()  &&  ! GetQuadrupleExternEmitted() )
        {
        if ( pCommand->NeedsNDR64Run() )
            {
            pStream->Write( "extern const " USER_MARSHAL_ROUTINE_TABLE_TYPE );
            pStream->Write( " " NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR 
                            "[ " WIRE_MARSHAL_TABLE_SIZE " ];" );
            pStream->NewLine();
            }
        if ( pCommand->NeedsNDRRun() )
            {
            pStream->Write( "extern const " USER_MARSHAL_ROUTINE_TABLE_TYPE );
            pStream->Write( " " USER_MARSHAL_ROUTINE_TABLE_VAR 
                            "[ " WIRE_MARSHAL_TABLE_SIZE " ];" );
            pStream->NewLine();
            }
        SetQuadrupleExternEmitted();
        }

    if ( HasCsTypes() )
        {
        //
        // Emit the international character sizing/conversion routine table
        //
        OutputCsRoutineTables();
        }
}

void
OutputPlatformCheck( ISTREAM * pStream )
/*++

Routine Description :

    Outputs an ifdef checking if the platform usage is as expected

Arguments :

    pStream - Stream to output the format string to.

 --*/
{
    pStream->NewLine();
    if ( pCommand->GetEnv() == ENV_WIN64 )
        {
        pStream->Write( "#if !defined(__RPC_WIN64__)" );
        }
    else
        pStream->Write( "#if !defined(__RPC_WIN32__)" );

    pStream->NewLine();
    pStream->Write( "#error  Invalid build platform for this stub." );
    pStream->NewLine();
    pStream->Write( "#endif" );
    pStream->NewLine();
}

const char * Nt51Guard[] =
    {
    "#if !(TARGET_IS_NT51_OR_LATER)",
    "#error You need a Windows XP or later to run this stub because it uses these features:",
    0
    };

const char * Nt50Guard[] =
    {
    "",
    "#if !(TARGET_IS_NT50_OR_LATER)",
    "#error You need a Windows 2000 or later to run this stub because it uses these features:",
    0
    };

const char * Nt40Guard[] =
    {
    "",
    "#if !(TARGET_IS_NT40_OR_LATER)",
    "#error You need a Windows NT 4.0 or later to run this stub because it uses these features:",
    0
    };

const char * Nt351win95Guard[] =
    {
    "",
    "#if !(TARGET_IS_NT351_OR_WIN95_OR_LATER)",
    "#error You need a Windows NT 3.51 or Windows95 or later to run this stub because it uses these features:",
    0
    };

const char * NtGuardClose[] =
    {
    "#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.",
    "#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.",
    "#endif",
    0
    };

void
OutputMultilineMessage(
    ISTREAM *       pStream,
    const char *    Message[] )
{
    for (int i = 0; Message[i]; i++)
        {
        pStream->Write( Message[i] );
        pStream->NewLine();
        }
}

// should be local OutputVersion Guard but it can't.

class   MessageSet
{
private:
    char      * Messages[10];
    int         MessageCount;
    ISTREAM   * pStream;

public:
                MessageSet( ISTREAM * pIStream )
                    : MessageCount(0),
                      pStream( pIStream )
                    {
                    }

    void        AddMessage( char * Message )
                    {
                    if ( MessageCount < 10 )
                        Messages[ MessageCount++ ] = Message;
                    }

    void        PrintMessages()
                    {
                    pStream->Write( "#error   " );
                    for (int i = 0; i < MessageCount; i++ )
                        {
                        pStream->Write( Messages[i] );
                        pStream->Write( (i < MessageCount -1) ? ", "
                                                              : ".\n" );
                        }
                    }
};


void
OutputNdrVersionGuard( ISTREAM * pStream )
/*++

Routine Description :

    Outputs  target release guards.

Arguments :

    pStream  - Stream to output the format string to.

 --*/
{
    MessageSet          Features( pStream );
    NdrVersionControl & VC = pCommand->GetNdrVersionControl();

    if ( VC.HasNdr60Feature() )
        {
        OutputMultilineMessage( pStream, Nt51Guard );
        if ( VC.HasStructPadN() )
            Features.AddMessage( "large structure padding" );
        if ( VC.HasForceAllocate() )
            Features.AddMessage( "The [force_allocate] attribte" );
        if ( VC.HasPartialIgnore() )
            Features.AddMessage( "The [partial_ignore] attribute" );
        if ( VC.HasMultiTransferSyntax() )
            Features.AddMessage( "Uses -protocol all or -protocol ndr64" );
        }
    else if ( VC.HasNdr50Feature() )
        {
        OutputMultilineMessage( pStream, Nt50Guard );
        if ( VC.HasAsyncHandleRpc() )
            Features.AddMessage( "[async] attribute" );
        if ( VC.HasNT5VTableSize() )
            Features.AddMessage( "more than 110 methods in the interface" );
        if ( VC.HasDOA() )
            Features.AddMessage( "/robust command line switch" );
        if ( VC.HasAsyncUUID() )
            Features.AddMessage( "[async_uuid] attribute" );
        if ( VC.HasInterpretedNotify() )
            Features.AddMessage( "[notify] or [notify_flag] attribute in interpreted mode" );
        if ( VC.HasContextSerialization() )
            Features.AddMessage( "[serialize] or [noserialize] attribute" );
        if ( VC.HasOicfPickling() )
            Features.AddMessage( "[encode] or [decode] with -Oicf" );
        }
    else if ( VC.HasNdr20Feature() )
        {
        OutputMultilineMessage( pStream, Nt40Guard );
        if ( VC.HasOi2() )
            Features.AddMessage( "-Oif or -Oicf" );
        if ( VC.HasUserMarshal() )
            Features.AddMessage( "[wire_marshal] or [user_marshal] attribute" );
        if ( VC.HasRawPipes() )
            Features.AddMessage( "idl pipes" );
        if ( VC.HasMoreThan64DelegatedProcs() )
            Features.AddMessage( "more than 64 delegated procs" );
        if ( VC.HasFloatOrDoubleInOi() )
            Features.AddMessage( "float, double or hyper in -Oif or -Oicf" );
        if ( VC.HasMessageAttr() )
            Features.AddMessage( "[message] attribute" );
        if ( VC.HasNT4VTableSize() )
            Features.AddMessage( "more than 32 methods in the interface" );
        }
    else if ( VC.HasNdr11Feature() )
        {
        OutputMultilineMessage( pStream, Nt351win95Guard );
        if ( VC.HasStublessProxies() )
            Features.AddMessage( "old (-Oic) stubless proxies" );
        if ( VC.HasCommFaultStatusInOi12() )
            Features.AddMessage( "[comm_status] or [fault_status] in an -Oi* mode" );
        }
    else
        return;

    Features.PrintMessages();
    OutputMultilineMessage( pStream, NtGuardClose );

    pStream->NewLine();
}



void
CCB::OutputMultipleInterfaceTables()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the tables that may be common to multiple interfaces.

 Arguments:

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    CGSIDE  Side = GetCodeGenSide();

    // First, output the platform consistency check.
    
    OutputPlatformCheck( pStream );
    
    // Now, the ndr version guard against usage on old platforms.

    if ( pCommand->GetEnv() == ENV_WIN32 )
        OutputNdrVersionGuard( pStream );


    MIDL_ASSERT( pCommand->IsNDRRun() || pCommand->IsNDR64Run() );

    if ( pCommand->IsNDRRun() )
        {
        
        if ( pCommand->IsNDRRun() )    
            GetProcFormatString()->Output( pStream,
                                       PROC_FORMAT_STRING_TYPE_NAME,
                                       PROC_FORMAT_STRING_STRUCT_NAME,
                                       GetRepAsPadExprDict(),
                                       GetRepAsSizeDict() );
        
        FixupRecPointers();
        
        GetFormatString()->Output( pStream,
                               FORMAT_STRING_TYPE_NAME,
                               FORMAT_STRING_STRUCT_NAME,
                               GetRepAsPadExprDict(),
                               GetRepAsSizeDict() );

        }
     else 
         {

         // If this is the 64bit transfer syntax run, then the proc and type format strings 
         // should be NULL.
         MIDL_ASSERT(  NULL == GetProcFormatString() );
         MIDL_ASSERT(  NULL == GetFormatString() );

         GetNdr64Format()->Output();

         }

        if ( HasQuadrupleRoutines() )
            {
            //
            // Emit the user_marshall table on both sides.
            //
            OutputQuadrupleTable();
            }
    //
    // Emit the rundown routine table on the server side, if needed.
    //
    SetNoOutputIn2ndCodegen( this );

    if ( (Side == CGSIDE_SERVER) &&
        (GetOptimOption() & OPTIMIZE_INTERPRETER) &&
        HasRundownRoutines()
        )
        {
        OutputRundownRoutineTable();
        }

    //
    // Emit the binding routine pair table on the client interpreted stub
    // if needed.
    //
    if ( (Side == CGSIDE_CLIENT) &&
        GetInterpretedRoutinesUseGenHandle() )
        {
        OutputBindingRoutines();
        }

    if ( HasExprEvalRoutines() )
        {
        //
        // Emit the expr eval routines both sides.
        //
        OutputRegisteredExprEvalRoutines();

        //
        // Emit the expr eval routine table on both sides.
        //
        OutputExprEvalRoutineTable();
        }

    if ( HasExprFormatString() )
        {
        OutputExpressionFormatString();
        }

    if ( HasQuintupleRoutines() )
        {
        //
        // Emit transmit as and represent as routines both sides.
        //
        OutputQuintupleRoutines();

        //
        // Emit the xmit as and rep as routine table on both sides.
        //
        OutputQuintupleTable();
        }


    if ( GetMallocAndFreeStructExternEmitted() )
        {
        // This is needed for the RpcSs support.

        OutputMallocAndFreeStruct();
        }

    ResetNoOutputIn2ndCodegen( this );
}

long
CCB_RTN_INDEX_MGR::Lookup( char * pName )
{
    long    i;

    for ( i = 1; i < NextIndex; i++ )
        if ( ! strcmp(NameId[i],pName) )
            return i;

    //
    // Insert a new entry
    //

    MIDL_ASSERT( NextIndex < MGR_INDEX_TABLE_SIZE );

    NameId[NextIndex] = new char[strlen(pName) + 1];
    strcpy(NameId[NextIndex],pName);
    NextIndex++;

    return NextIndex - 1;
}

char *
CCB_RTN_INDEX_MGR::Lookup( long Index )
{
    if ( Index >= NextIndex )
        return NULL;

    return NameId[Index];
}

long
CCB_EXPR_INDEX_MGR::Lookup( char * pName )
{
    long    i;

    for ( i = 1; i < NextIndex; i++ )
        if ( ! strcmp(NameId[i],pName) )
            return i;

    //
    // Insert a new entry
    //

    MIDL_ASSERT( NextIndex < MGR_INDEX_TABLE_SIZE );

    NameId[NextIndex] = new char[strlen(pName) + 1];
    strcpy(NameId[NextIndex],pName);
    NextIndex++;

    return NextIndex - 1;
}

char *
CCB_EXPR_INDEX_MGR::Lookup( long Index )
{
    if ( Index >= NextIndex )
        return NULL;

    return NameId[Index];
}



PNAME
CCB::GenTRNameOffLastParam( char * pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the name for a temporary resource.

 Arguments:

    pPrefix - A null terminated prefix string. If this is null, nothing is
              added.

 Return Value:

    A freshly allocated resource name string.

 Notes:

----------------------------------------------------------------------------*/
{
    char TempBuffer[ 30 ];

    sprintf( TempBuffer,
        "_%sM",
        pPrefix ? pPrefix : ""
        );

    PNAME   pName   = (PNAME) new char [ strlen(TempBuffer) + 1 ];
    strcpy( pName, TempBuffer );
    return pName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\btndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    btndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    base types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG * pCommand;

void
CG_BASETYPE::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a simple type.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    FORMAT_CHARACTER fc = GetFormatChar();
    // Generate the base type's description always.

    if ( GetRangeAttribute() )
        {
        if ( GetFormatStringOffset() == -1 )
            {
            SetFormatStringOffset( pFormatString->GetCurrentOffset() );
            GenRangeFormatString(
                                pFormatString,
                                GetRangeAttribute(),
                                0,  // flags
                                fc
                                );
            }
        }
    else
        {
        pFormatString->PushFormatChar( fc );
        }
}

void CG_BASETYPE::GetNdrParamAttributes(
        CCB * pCCB,
        PARAM_ATTRIBUTES *attributes )
{
    CG_PARAM *pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    attributes->MustSize = 0;
    attributes->MustFree = 0;
    attributes->IsPipe = 0;
    attributes->IsIn = (unsigned short) pParam->IsParamIn();
    attributes->IsOut = (unsigned short) pParam->IsParamOut();
    attributes->IsReturn = (pParam->GetCGID() == ID_CG_RETURN);
    attributes->IsBasetype = ( GetRangeAttribute() == 0 );
    attributes->IsByValue = ( GetRangeAttribute() != 0 );
    attributes->IsSimpleRef = 0;
    attributes->IsDontCallFreeInst = 0;
    attributes->ServerAllocSize = 0;
    attributes->SaveForAsyncFinish = pParam->IsSaveForAsyncFinish();
    attributes->IsPartialIgnore = pParam->IsParamPartialIgnore();
    attributes->IsForceAllocate = 0;
}

void                    
CG_BASETYPE::GenNdrParamDescription( CCB * pCCB )
{
    FORMAT_STRING *     pProcFormatString;
    PARAM_ATTRIBUTES    Attributes;
    CG_PARAM           *pParam;

    pProcFormatString = pCCB->GetProcFormatString();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    GetNdrParamAttributes( pCCB, &Attributes );

    // Attributes.
    pProcFormatString->PushParamFlagsShort( *((short *)&Attributes) );

    // Stack offset as number of ints.
    pProcFormatString->PushUShortStackOffsetOrSize(
            pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    if ( GetRangeAttribute() )
        {
        pProcFormatString->PushShort( GetFormatStringOffset() );
        }
    else
        {
        pProcFormatString->PushFormatChar( GetFormatChar() );
        pProcFormatString->PushByte( 0 );
        }
}

long                    
CG_BASETYPE::FixedBufferSize( CCB * )
{
    long    WireSize;

    WireSize = GetWireSize();

    //
    // Return twice the size of the basetype on the wire to cover alignment 
    // padding, plus the difference of it's size with a long if it is smaller
    // than a long.  The second value allows us to do a slightly optimized 
    // marshall/unmarshall of basetypes in the interpreter.
    //
    return (long)((WireSize * 2) + 
           ((WireSize < sizeof(long)) ? (sizeof(long) - WireSize) : 0));
}

void
GenRangeFormatString(
                    FORMAT_STRING*      pFormatString,
                    node_range_attr*    pRangeAttr,
                    unsigned char       uFlags,
                    FORMAT_CHARACTER    formatChar
                    )
{
    if ( pRangeAttr )
        {
        pFormatString->PushFormatChar( FC_RANGE );
        pFormatString->PushByte( ( uFlags & 0xF0 ) | unsigned char( formatChar & 0x0F ) );      // flags:type
// RKK64: TBD: full range on hypers
        pFormatString->PushLong( (ulong) pRangeAttr->GetMinExpr()->GetValue() );  // min.
        pFormatString->PushLong( (ulong) pRangeAttr->GetMaxExpr()->GetValue() );  // max.
        }
}


void
CG_CS_TAG::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a cs_tag type.

Arguments :

    pCCB        - pointer to the code control block.

Notes :

    FC_CS_TAG
    ndr_cs_tag_flags<1>         // Flags (this is cs_stag, etc)
    index_of_tag_routine<2>     // The tag routine index

--*/
{
    FORMAT_STRING *pFormatString = pCCB->GetFormatString();
    CG_PROC       *pProc = (CG_PROC *) pCCB->GetCGNodeContext();
    node_proc     *pTagRoutine;
    short          index;

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pTagRoutine = pProc->GetCSTagRoutine();

    if ( pTagRoutine )
        {
        index = pCCB->GetCsTagRoutineList().Insert( pTagRoutine->GetSymName() );
        MIDL_ASSERT( index != NDR_INVALID_TAG_ROUTINE_INDEX );
        }   
    else
        {
        index = NDR_INVALID_TAG_ROUTINE_INDEX;
        }

    pFormatString->PushFormatChar( FC_CS_TAG );
    pFormatString->PushByte( * (unsigned char * ) & Flags );
    pFormatString->PushShort( index );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\arrayndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    arrayndr.cxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    array types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

#define OUT_CORRELATION_DESC( x, y )    (x)->PushCorrelationFlagsShort(y)

//*************************************************************************
// CG_ARRAY
//*************************************************************************

BOOL
CG_ARRAY::GenNdrFormatArrayProlog( CCB * pCCB )
/*++

Routine Description :

    Handles some common tasks for array Ndr format string generation.

Arguments :

    pCCB    - pointer to code control block

Return :

    TRUE if format string generation should continue, FALSE if the format
    string for the array has already been generated.

 --*/
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pChild;

    if ( GetFormatStringOffset() != -1 )
        return FALSE;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    if ( pChild->IsArray() )
        {
        SetIsInMultiDim( TRUE );
        ((CG_ARRAY *)pChild)->SetIsInMultiDim( TRUE );
        }

    //
    // If the array's element type is a structure, pointer, or another array
    // then generate either it's description (structure/array) or it's
    // pointee's description (pointer).
    //
    if ( pChild->IsStruct() ||
         pChild->IsArray() ||
         pChild->IsUnion() ||
         pChild->IsInterfacePointer() ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        pChild->GenNdrFormat( pCCB );
        }

    if ( pChild->IsPointer() && 
        !pChild->IsInterfacePointer() )
        {
        // Only generate the pointee format string if the pointee is not a
        // base type or non-sized string pointer.
        if ( ! pChild->IsPointerToBaseType() &&
             (pChild->GetCGID() != ID_CG_STRING_PTR) )
            ((CG_POINTER *)pChild)->GenNdrFormatPointee( pCCB );
        }

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // If this is a cs_char array, generate the FC_CS_ARRAY prolog
    //
    GenNdrCSArrayProlog( pCCB );

    //
    // For an array which has [unique] or [ptr] applied to it, we generate
    // a format string description of a pointer to the array.
    //
    if ( GetPtrType() != PTR_REF )
        {
        pFormatString->PushFormatChar( GetPtrType() == PTR_UNIQUE ?
                                       FC_UP : FC_FP );
        pFormatString->PushByte( 0 );
        pFormatString->PushShortOffset( 2 );
        }

    //
    // Check if this is a complex array.
    //
    if ( IsComplex() ) 
        {
        GenNdrFormatComplex( pCCB );
        return FALSE;
        }

    // Push the type.
    switch ( GetCGID() )
        {
        case ID_CG_ARRAY :
        case ID_CG_VAR_ARRAY :
            //
            // Fixed and varying array's fill this in later when they know
            // their size.
            //
            pFormatString->PushByte( 0 );
            break;
        case ID_CG_CONF_ARRAY :
            pFormatString->PushFormatChar( FC_CARRAY );
            break;
        case ID_CG_CONF_VAR_ARRAY :
            pFormatString->PushFormatChar( FC_CVARRAY );
            break;
        }

    //
    // Push the correct alignment value.
    //
    pFormatString->PushByte( ( pChild->IsUnion() ? 1 : pChild->GetWireAlignment() ) - 1 );

    return TRUE;
}

BOOL
CG_ARRAY::GenNdrFormatArrayLayout( CCB * pCCB )
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pChild;
    BOOL                fCanOptimize = TRUE;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    //
    // See if we need to generate a pointer layout.
    //
    if ( (pChild->IsPointer() && 
          !pChild->IsInterfacePointer()  ) ||
         (pChild->IsStruct() && ((CG_STRUCT *)pChild)->HasPointer()) )
        {
        //
        // Not home free yet.  Even if the array has pointers, we only
        // output a pointer layout if one of the following is true :
        //   1. The array is a top level parameter.
        //   2. The array is really a fabrication of a size or size length
        //      pointer (of structures which contain pointers).
        //   3. The array is embedded in a complex or hard struct.
        // Otherwise the array's pointer description will be in its structure's
        // pointer layout.
        //
        // We also never generate a pointer layout for complex arrays.
        //
        // We know if it was fabricated from a size or size-length pointer
        // if IsDupedSizePtr() is TRUE.
        //
        // BUGBUG: Another case where we should generate the pointer layout
        //         is if our parent is a simple pointer.  One scenario where
        //         this occurs is a struct containing a pointer to an array.
        //         The simple scenario of a top-level pointer to an array is
        //         taken care of because then the node context is the proc.

        CG_NDR * pParent;

        pParent = pCCB->GetCGNodeContext();
        
        if ( pParent->IsProc() ||
             (pParent->GetCGID() == ID_CG_COMPLEX_STRUCT) ||
             (pParent->IsStruct() && 
              ((CG_STRUCT *)pParent)->IsHardStruct()) ||
             IsDupedSizePtr()
           )
            {
            if ( ! IsComplex() )
                GenNdrFormatArrayPointerLayout( pCCB,
                                                FALSE );
            }
        }

    SetElementDescriptionOffset( pFormatString->GetCurrentOffset() );

    //
    // Now generate the element description.
    //
    if ( pChild->IsStruct() || 
         pChild->IsArray() ||
         pChild->IsUnion() ||
         pChild->IsInterfacePointer() ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        pFormatString->PushFormatChar( FC_EMBEDDED_COMPLEX );

        // Not used.
        pFormatString->PushByte( 0 );

        // if embedded complex member has an offset zero, then it is a
        // recursive definition.  Register it for fixup later.

        if ( pChild->GetFormatStringOffset() == 0 )
            {   
            fCanOptimize = FALSE;
            pCCB->RegisterRecPointerForFixup( 
                            pChild, 
                            pFormatString->GetCurrentOffset() );
            }

        pFormatString->PushShortOffset( pChild->GetFormatStringOffset() - 
                                          pFormatString->GetCurrentOffset() );
        }

    if ( pChild->IsPointer() && 
         !pChild->IsInterfacePointer() )
        {
        // 
        // For complex arrays of pointers we put the actual pointer description
        // in the layout, otherwise we put a long.
        //
        if ( IsComplex() )
            {
            ((CG_POINTER *)pChild)->GenNdrFormatAlways( pCCB );
            // This may return zero when pointee is not generated yet. It would
            // need to be checked if we wanted to call the string optimizer.
            }
        else
            {
            pFormatString->PushFormatChar( FC_LONG );
            }
        }

    if ( pChild->IsSimpleType() )
        {
        pChild->GenNdrFormat( pCCB );
        }

    // Possibly align the format string and spit out the FC_END.
    if ( ! (pFormatString->GetCurrentOffset() % 2) )
        pFormatString->PushFormatChar( FC_PAD );

    pFormatString->PushFormatChar( FC_END );
    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );

    return fCanOptimize;
}

void
CG_ARRAY::GenNdrFormatArrayPointerLayout( CCB * pCCB,
                                          BOOL  fNoPP )
/*++

Routine Description :

    Generates the Ndr format string pointer layout for a conformant array.

Arguments :

    pCCB    - pointer to the code control block
    fNoPP   - TRUE if no FC_PP or FC_END should be generated

 --*/
{
    ITERATOR            Iterator;
    FORMAT_STRING *     pFormatString;
    CG_STRUCT *         pStruct;
    CG_NDR *            pImbedingNode;
    unsigned long       MemOffsetToArray;
    unsigned long       BufOffsetToArray;
    long                ImbedingMemSize;
    long                ImbedingBufSize;

    // Get the current imbeding sizes.
    ImbedingMemSize = pCCB->GetImbedingMemSize();
    ImbedingBufSize = pCCB->GetImbedingBufSize();

    pFormatString = pCCB->GetFormatString();

    pImbedingNode = pCCB->GetCGNodeContext();

    MemOffsetToArray = ImbedingMemSize;
    BufOffsetToArray = ImbedingBufSize;

    if ( pImbedingNode->IsStruct() )
        {
        pStruct = (CG_STRUCT *) pImbedingNode;

        if ( GetCGID() == ID_CG_CONF_ARRAY ||
             GetCGID() == ID_CG_CONF_VAR_ARRAY )
            {
            ; // Do nothing, imbeding sizes set offset right.
            }
        else // GetCGID() == ID_CG_ARRAY || ID_CG_VAR_ARRAY
            {
            CG_FIELD *      pField;

            //
            // If we're embedded in a complex struct then we do nothing - our
            // offset will end up being 0.
            //
            if ( pStruct->GetCGID() != ID_CG_COMPLEX_STRUCT )
                {
                pField = pStruct->GetArrayField( this );

                //
                // If we don't find the array's field, that's because the 
                // array must have been contained within a union which was
                // part of a Hard Structure.
                //
                if ( pField )
                    {
                    //
                    // What has to be done here is to actually subract the
                    // difference between the struct's sizes and the field's
                    // offsets, since the array appears somewhere inside the 
                    // struct whose size has already been added to the 
                    // imbeding sizes.
                    //
                    MemOffsetToArray -= pStruct->GetMemorySize() -
                                        pField->GetMemOffset();
                    BufOffsetToArray -= pStruct->GetWireSize() -
                                        pField->GetWireOffset();
                    }
                }
            }
        }

    if ( ! fNoPP )
        {
        pFormatString->PushFormatChar( FC_PP );
        pFormatString->PushFormatChar( FC_PAD );
        }

    //
    // Stuff for fixed arrays.
    //
    if ( GetCGID() == ID_CG_ARRAY )
        {
        pFormatString->PushFormatChar( FC_FIXED_REPEAT );
        pFormatString->PushFormatChar( FC_PAD );
        pFormatString->PushShort( (short)
            ((CG_FIXED_ARRAY *)this)->GetNumOfElements() );
        }

    //
    // Stuff for conformant arrays.
    //
    if ( GetCGID() == ID_CG_CONF_ARRAY )
        {
        pFormatString->PushFormatChar( FC_VARIABLE_REPEAT );
        pFormatString->PushFormatChar( FC_FIXED_OFFSET );
        }

    //
    // Stuff for conformant varying and varying arrays.
    //
    if ( GetCGID() == ID_CG_CONF_VAR_ARRAY ||
         GetCGID() == ID_CG_VAR_ARRAY )
        {
        pFormatString->PushFormatChar( FC_VARIABLE_REPEAT );
        pFormatString->PushFormatChar( FC_VARIABLE_OFFSET );
        }

    if ( GetChild()->IsPointer() && 
         !GetChild()->IsInterfacePointer() )
        {
        CG_POINTER *        pPointer;

        pPointer = (CG_POINTER *) GetChild();

        //
        // Push the increment amount between successive pointers.  In this
        // case it's always 4.
        //
        pFormatString->PushShort( (short) SIZEOF_MEM_PTR() );

        // offset_to_array<2>
        pFormatString->PushShort( (short) MemOffsetToArray );

        // number_of_pointers<2> 
        pFormatString->PushShort( (short) 1 );

        // offset_to_pointer_in_memory<2>
        pFormatString->PushShort( (short) MemOffsetToArray );

        // offset_to_pointer_in_buffer<2>
        pFormatString->PushShort( (short) BufOffsetToArray );

        // Push the pointer description.
        pPointer->GenNdrFormatEmbedded( pCCB );
        }

    if ( GetChild()->IsStruct() )
        {
        ITERATOR        Iterator;
        CG_STRUCT *     pStruct;

        long ImbBufSizeSave = pCCB->GetImbedingBufSize();

        pStruct = (CG_STRUCT *) GetChild();

        //
        // Increment between successive pointers is the memory size of
        // the structure.
        //
        pFormatString->PushShort( (short) pStruct->GetMemorySize() );

        // offset_to_array<2>
        pFormatString->PushShort( (short) MemOffsetToArray );

        // number_of_pointers<2>
        pFormatString->PushShort( (short) pStruct->GetNumberOfPointers() );

        if ( GetCGID() == ID_CG_CONF_VAR_ARRAY ||
             GetCGID() == ID_CG_VAR_ARRAY )
            {
            // Account for varying information in the buffer in front of the array.
            // It effectively makes the flat part of the struct bigger.
            // Imbedded size should be zero for top level and non-embedded arrays.
            if ( ImbBufSizeSave )
                pCCB->SetImbedingBufSize( ImbBufSizeSave + 8 );
            }

        pStruct->GenNdrStructurePointerLayout( pCCB, TRUE, TRUE );
        pCCB->SetImbedingBufSize( ImbBufSizeSave );
        } 

    MIDL_ASSERT( !GetChild()->IsUnion() && !GetChild()->IsArray() );

    if ( ! fNoPP )
        pFormatString->PushFormatChar( FC_END );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
}

void
CG_ARRAY::GenNdrFormatComplex( CCB * pCCB )
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pChild;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    pFormatString->PushFormatChar( FC_BOGUS_ARRAY );

    // Alignment.
    pFormatString->PushByte( ( pChild->IsUnion() ? 1 : pChild->GetWireAlignment() ) - 1 );

    //
    // Number of elements - 0 if conformant.
    //
    switch ( GetCGID() )
        {
        case ID_CG_ARRAY :
            pFormatString->PushShort( (short)
                    ((CG_FIXED_ARRAY *)this)->GetNumOfElements() );
            break;
        case ID_CG_VAR_ARRAY :
            pFormatString->PushShort( (short)
                    ((CG_VARYING_ARRAY *)this)->GetNumOfElements() );
            break;
        default :
            pFormatString->PushShort( (short) 0 );
            break;
        }

    //
    // Conformance description.
    //
    switch ( GetCGID() )
        {
        case ID_CG_CONF_ARRAY :
            ((CG_CONFORMANT_ARRAY *)this)->
              GenFormatStringConformanceDescription( pCCB, 
                                                     IsDupedSizePtr(),
                                                     IsInMultiDim() );
            break;
        case ID_CG_CONF_VAR_ARRAY :
            ((CG_CONFORMANT_VARYING_ARRAY *)this)->
              GenFormatStringConformanceDescription( pCCB, 
                                                     IsDupedSizePtr(),
                                                     IsInMultiDim() );
            break;
        default :
            pFormatString->PushLong( 0xffffffff );
            if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
                {
                OUT_CORRELATION_DESC( pFormatString, 0 );
                }

            break;
        }
    //
    // Variance description.
    //
    switch ( GetCGID() )
        {
        case ID_CG_CONF_VAR_ARRAY :
            ((CG_CONFORMANT_VARYING_ARRAY *)this)->
              GenFormatStringVarianceDescription( pCCB, 
                                                  IsDupedSizePtr(),
                                                  FALSE,
                                                  IsInMultiDim() );
            break;
        case ID_CG_VAR_ARRAY :
            ((CG_VARYING_ARRAY *)this)->
              GenFormatStringVarianceDescription( pCCB, 
                                                  FALSE,
                                                  TRUE,
                                                  IsInMultiDim() );
            break;
        default :
            pFormatString->PushLong( 0xffffffff );
            if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
                {
                OUT_CORRELATION_DESC( pFormatString, 0 );
                }

            break;
        }

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

    // This call needs some preparation that I have no time for.
//    FixupEmbeddedComplex( pCCB );
}

long
CG_ARRAY::GetElementSize()
{
    CG_NDR *            pChild;

    pChild = (CG_NDR *) GetChild();

    if ( pChild->IsSimpleType() )
        {
        // Cheat a little.  Size is equal to wire alignment value.
        return pChild->GetWireAlignment();
        }

    if ( pChild->IsPointer() )
        return SIZEOF_MEM_PTR();

    if ( pChild->IsStruct() )
        return ((CG_STRUCT *)pChild)->GetMemorySize();

    if ( pChild->IsArray() )
        {
        MIDL_ASSERT ( pChild->GetCGID() == ID_CG_ARRAY );

        CG_FIXED_ARRAY * pArray = (CG_FIXED_ARRAY *) pChild;

        return pArray->GetElementSize() * pArray->GetNumOfElements();
        }

    if ( pChild->IsInterfacePointer()  )
        return SIZEOF_MEM_PTR();

    MIDL_ASSERT( !"Shouldn't be able to get here" );

    return 0;   // for the compiler
}

BOOL                    
CG_ARRAY::IsComplex()
{
    if ( IsForcedComplex() )
        {
        return TRUE;
        }
    //
    // If this is a conformant and/or varying array, then it becomes
    // complex if it is part of a multidimensional array (but not a multi
    // level sized pointer).
    //
    if ( (GetCGID() == ID_CG_CONF_ARRAY) ||
         (GetCGID() == ID_CG_CONF_VAR_ARRAY) ||
         (GetCGID() == ID_CG_VAR_ARRAY) )
        {
        if ( IsInMultiDim() && ! IsDupedSizePtr() )
            return TRUE;
        }

    // multi dimensional array of struct embedding pointers needs to be
    // marked complex.
    if ( IsFixedArray() && IsInMultiDim() && HasPointer() )
         return TRUE;

    CG_NDR* pChild = ( CG_NDR* ) GetChild();

    // [range] on an element of an array makes the array complex
    if ( pChild->GetRangeAttribute() )
        {
        return TRUE;
        }

    //
    // Is the array complex by Ndr Engine standards.  Any array of complex
    // or hard structs, encapsulated unions, transmit_as or represent_as, 
    // enums, ref pointers, or another complex array, is complex.
    //
    // Any multidimensional array with at least one dimension with conformance 
    // or variance is complex as well.
    //
    // On 64bit platforms array of pointers are also complex.
    //
    switch ( pChild->GetCGID() )
        {
        case ID_CG_STRUCT :
            return( ((CG_STRUCT *)GetChild())->IsComplexStruct() ||
                    ((CG_STRUCT *)GetChild())->IsHardStruct()    ||
                    GetWireSize() != GetMemorySize() ); 

        case ID_CG_ARRAY :
            switch ( GetCGID() )
                {
                case ID_CG_CONF_ARRAY :
                case ID_CG_CONF_VAR_ARRAY :
                case ID_CG_VAR_ARRAY :
                    return TRUE;
                default :
                    //
                    // The array is complex if the next lower fixed array 
                    // dimension is complex.
                    //
                    return ((CG_ARRAY *) GetChild())->IsComplex();
                }

        case ID_CG_COMPLEX_STRUCT :
        case ID_CG_ENCAP_STRUCT :
        case ID_CG_CONF_ARRAY :
        case ID_CG_CONF_VAR_ARRAY :
        case ID_CG_VAR_ARRAY :
        case ID_CG_STRING_ARRAY :
        case ID_CG_CONF_STRING_ARRAY :
        case ID_CG_TRANSMIT_AS :
        case ID_CG_REPRESENT_AS :
        case ID_CG_USER_MARSHAL :
        case ID_CG_INTERFACE_PTR :
        case ID_CG_IIDIS_INTERFACE_PTR :
        case ID_CG_INT3264 :
            return TRUE;

        case ID_CG_ENUM :
            //
            // The array is complex if it is an array of enum16 or __int3264,
            //  and for a similar reason, bigger in memory than on wire.
            //
            return ! ((CG_ENUM *)GetChild())->IsEnumLong();

        case ID_CG_CONF_STRUCT :
        case ID_CG_CONF_VAR_STRUCT :
            return TRUE;

        default :
            //
            // Make a final check for an array of ref pointers.
            //
            if ( GetChild()->IsPointer() )
                {
                if ( pCommand->Is64BitEnv() )
                    return TRUE;
                else
                    return (((CG_POINTER *)GetChild())->GetPtrType() == PTR_REF);

                }

            return FALSE;
        }
}

BOOL                    
CG_ARRAY::IsMultiConfOrVar()
{
    CG_NDR * pNdr;

    switch ( GetCGID() )
        {
        case ID_CG_CONF_ARRAY :
        case ID_CG_CONF_VAR_ARRAY :
        case ID_CG_VAR_ARRAY :
            break;
        default :
            return FALSE;
        }

    //
    // Search for an inner dimension array other than fixed.
    //
    pNdr = (CG_NDR *) GetChild();

    for ( ; pNdr && pNdr->IsArray(); pNdr = (CG_NDR *) pNdr->GetChild() )
        {   
        if ( pNdr->GetCGID() == ID_CG_ARRAY )
            continue;
        else
            return TRUE;
        }

    return FALSE;
}

BOOL
CG_ARRAY::ShouldFreeOffline()
{
    CG_NDR *    pChild;

    pChild = (CG_NDR *) GetChild();

    switch ( GetCGID() )
        {
        case ID_CG_STRING_ARRAY :
        case ID_CG_CONF_STRING_ARRAY :
            return FALSE;

        default :
            if ( pChild->IsSimpleType() )
                return FALSE;

            if ( pChild->IsStruct() )
                return ((CG_STRUCT *)pChild)->ShouldFreeOffline();

            if ( pChild->IsArray() )
                return ((CG_ARRAY *)pChild)->ShouldFreeOffline();
                
            return TRUE;
        }
}

void
CG_ARRAY::GenFreeInline( CCB * pCCB )
{
    CG_PARAM *  pParam;
    BOOL        fFree;

    fFree = FALSE;

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    //
    // Don't free a [unique] or [ptr] array inline.
    //
    if ( GetPtrType() != PTR_REF )
        return;

    if ( IsComplex() )
        {
        //
        // If the array is complex then we must free it unless it is a
        // fixed or varying array of ref pointers or an [out] fixed or varying 
        // array.
        // Pointer in 64 bit env is already complex
        if ( ! pParam->IsParamIn() || 
              GetBasicCGClass()->IsPointer()  )
            fFree = (GetCGID() == ID_CG_CONF_ARRAY) ||
                    (GetCGID() == ID_CG_CONF_VAR_ARRAY) ;
        else
            fFree = TRUE;
        }
    else
        {
        //
        // For non complex arrays the rules are :
        //  Fixed - never free, we use the buffer.
        //  Conformant - free if [out] only.
        //  Conformant Varying - always free.
        //  Varying - free if [in] or [in,out].
        // 
        //  String array - free always.
        //  Conformant string array - free if sized.
        //
        switch ( GetCGID() )
            {
            case ID_CG_ARRAY :
                break; 

            case ID_CG_CONF_ARRAY :
                fFree = ! pParam->IsParamIn();
                break;

            case ID_CG_CONF_VAR_ARRAY :
                fFree = TRUE;
                break;

            case ID_CG_VAR_ARRAY :
                fFree = pParam->IsParamIn();
                break;

            case ID_CG_STRING_ARRAY :
                fFree = TRUE;
                break;
            
            case ID_CG_CONF_STRING_ARRAY :
                fFree = GetSizeIsExpr() != 0;
                break;
            }
        }

    if ( fFree )
        Out_FreeParamInline( pCCB );
}

//*************************************************************************
// CG_FIXED_ARRAY
//*************************************************************************

void 
CG_FIXED_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a fixed array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    unsigned long       ArraySize;

    if ( GenNdrFormatArrayProlog( pCCB ) )
        {
        MIDL_ASSERT( GetSizeIsExpr()->IsConstant() );

        ArraySize = GetNumOfElements() * GetElementSize();

        //
        // If the array size is >= 64K then the format is different.
        //
        if ( ArraySize >= (64 * 1024) )
            {
            pFormatString->PushFormatChar( FC_LGFARRAY,
                                           pFormatString->GetCurrentOffset() - 2 );
            pFormatString->PushLong( ArraySize );
            }
        else
            {
            pFormatString->PushFormatChar( FC_SMFARRAY,
                                           pFormatString->GetCurrentOffset() - 2 );
            pFormatString->PushShort( (short) ArraySize );
            }

        if ( GenNdrFormatArrayLayout( pCCB ) )
            pFormatString->OptimizeFragment( this );
        }
}

long
CG_FIXED_ARRAY::FixedBufferSize( CCB * pCCB )
{
    CG_NDR *    pNdr;
    long        BufSize;
    long        TotalSize;

    pNdr = (CG_NDR *)GetChild();

    // skip these nodes to get to the transmitted element type.

    if ( pNdr->IsXmitRepOrUserMarshal() )
        pNdr = (CG_NDR *)pNdr->GetChild();

    if ( pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsPointerToBaseType() )
        {
        CG_POINTER * pPointer;

        //
        // Special case arrays of pointers to base types so that we 
        // don't grossly overestimate the buffer size.
        //

        pPointer = (CG_POINTER *) pNdr;
        pNdr = (CG_NDR *) pNdr->GetChild();

        // If this is the 64bit transfer syntax, include 
        // the size of ref pointers in the buffer size.

        BufSize = ( ( pPointer->GetPtrType() == PTR_REF ) &&
                    !pCommand->IsNDR64Run() ) ? 0 : SIZEOF_WIRE_PTR();
        
        BufSize += pNdr->GetWireSize(); 

        return MAX_WIRE_ALIGNMENT + (GetNumOfElements() * BufSize);
        }

    if ( pNdr->IsStruct() || pNdr->IsArray() || pNdr->IsPointer() 
         || pNdr->IsUnion() )
        {
        BufSize = pNdr->FixedBufferSize( pCCB );

        if ( BufSize == -1 ) 
            return -1;

        // Success!
        TotalSize = GetNumOfElements() * BufSize;
        }
    else
        {
        // Fixed array of basetypes.
        TotalSize = MAX_WIRE_ALIGNMENT + GetWireSize();
        }

    return TotalSize;
}



//*************************************************************************
// CG_CONFORMANT_ARRAY
//*************************************************************************

void
CG_CONFORMANT_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a conformant or array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                ElementSize;

    if ( ! GenNdrFormatArrayProlog( pCCB ) )
        return;

    ElementSize = GetElementSize();

    if ( ElementSize >= (64 * 1024) )
        {
        RpcError(NULL, 0, ARRAY_ELEMENT_TOO_BIG, GetSymName());
        exit(ARRAY_ELEMENT_TOO_BIG);
        }

    pFormatString->PushShort( ElementSize );

    GenFormatStringConformanceDescription( pCCB, 
                                           IsDupedSizePtr(),
                                           IsInMultiDim() );

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

}

//*************************************************************************
// CG_CONFORMANT_VARYING_ARRAY
//*************************************************************************

void CG_CONFORMANT_VARYING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a conformant varying array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                ElementSize;

    if ( ! GenNdrFormatArrayProlog( pCCB ) )
        return;

    ElementSize = GetElementSize();

    if ( ElementSize >= (64 * 1024) )
        {
        RpcError(NULL, 0, ARRAY_ELEMENT_TOO_BIG, GetSymName());
        exit(ARRAY_ELEMENT_TOO_BIG);
        }

    pFormatString->PushShort( ElementSize );

    GenFormatStringConformanceDescription( pCCB, 
                                           IsDupedSizePtr(),
                                           IsInMultiDim() );

    GenFormatStringVarianceDescription( pCCB,
                                        IsDupedSizePtr(),
                                        FALSE,
                                        IsInMultiDim() );

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

}

void CG_VARYING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a varying array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                Elements;
    long                ElementSize;
    long                ArraySize;

    if ( ! GenNdrFormatArrayProlog( pCCB ) )
        return;

    //
    // Size must be constant.
    //
    MIDL_ASSERT( GetSizeIsExpr()->IsConstant() );

    Elements = GetNumOfElements();
    ElementSize = GetElementSize();

    ArraySize = Elements * ElementSize;

    //
    // Check if this is a large varying array.
    //
    if ( ArraySize >= (64 * 1024) )
        {
        pFormatString->PushFormatChar( FC_LGVARRAY,
                                       pFormatString->GetCurrentOffset() - 2 );
        pFormatString->PushLong( ArraySize );
        pFormatString->PushLong( Elements );
        }
    else
        {
        pFormatString->PushFormatChar( FC_SMVARRAY,
                                       pFormatString->GetCurrentOffset() - 2 );
        pFormatString->PushShort( ArraySize );
        pFormatString->PushShort( Elements );
        }

    pFormatString->PushShort( ElementSize );

    GenFormatStringVarianceDescription( pCCB,
                                        FALSE,
                                        TRUE,
                                        FALSE );

    if ( GenNdrFormatArrayLayout( pCCB ) )
        pFormatString->OptimizeFragment( this );

}

//*************************************************************************
// CG_STRING_ARRAY
//*************************************************************************

void CG_STRING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a string array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING * pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    GenNdrCSArrayProlog( pCCB );

    if ( IsStringableStruct() )
        {
        pFormatString->PushFormatChar( FC_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );
        }
    else
        {
        switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
            {
            case FC_CHAR :
            case FC_BYTE :
                pFormatString->PushFormatChar( FC_CSTRING );
                break;
            case FC_WCHAR :
                pFormatString->PushFormatChar( FC_WSTRING );
                break;
            default :
                MIDL_ASSERT(0);
            }

        pFormatString->PushFormatChar( FC_PAD );
        }

    MIDL_ASSERT( GetSizeIsExpr()->IsConstant() );

    __int64 SizeIs = GetSizeIsExpr()->GetValue();

    if ( _UI16_MAX <= SizeIs )
        {
        RpcError(NULL, 0, ARRAY_SIZE_EXCEEDS_64K, GetSymName());
        exit(ARRAY_SIZE_EXCEEDS_64K);
        }

    pFormatString->PushShort( (short) SizeIs );

    // optimize away duplicates
    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );

    pFormatString->OptimizeFragment( this );

}

void CG_CONFORMANT_STRING_ARRAY::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the Ndr format string for a conformant string array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    FORMAT_STRING * pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    GenNdrCSArrayProlog( pCCB );

    if ( IsStringableStruct() )
        {
        pFormatString->PushFormatChar( FC_C_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );
        }
    else
        {
        switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
            {
            case FC_CHAR :
            case FC_BYTE :
                pFormatString->PushFormatChar( FC_C_CSTRING );
                break;
            case FC_WCHAR :
                pFormatString->PushFormatChar( FC_C_WSTRING );
                break;
            default :
                MIDL_ASSERT(0);
            }
        }

    if ( GetSizeIsExpr() )
        {
        pFormatString->PushFormatChar( FC_STRING_SIZED );

        if ( IsStringableStruct() )
            pFormatString->PushFormatChar( FC_PAD );

        //
        // Set the IsPointer parameter to FALSE.
        //
        GenFormatStringConformanceDescription( pCCB, FALSE, IsInMultiDim() );
        }
    else
        {
        if ( ! IsStringableStruct() )
            pFormatString->PushFormatChar( FC_PAD );
        }

    // optimize away duplicates
    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );

    pFormatString->OptimizeFragment( this );

}

//*************************************************************************
// CG_CONF_ATTRIBUTE
//*************************************************************************

void
CG_CONF_ATTRIBUTE::GenFormatStringConformanceDescription( 
    CCB * pCCB,
    BOOL  IsPointer,
    BOOL  IsMultiDArray )
/*++

Routine Description :

    Generates the conformace description field for a conformant (varying)
    array.

Arguments :

    pCCB    - pointer to the code control block

 --*/
{
    GenNdrFormatAttributeDescription( pCCB,
                                      GetMinIsExpr(),
                                      GetSizeIsExpr(),
                                      IsPointer,
                                      FALSE,
                                      FALSE,
                                      IsMultiDArray,
                                      pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
}

//*************************************************************************
// CG_VARY_ATTRIBUTE
//*************************************************************************

void
CG_VARY_ATTRIBUTE::GenFormatStringVarianceDescription( 
    CCB *   pCCB,
    BOOL    IsPointer,
    BOOL    IsVaryingArray,
    BOOL    IsMultiDArray )
/*++

Routine Description :

    Generates the variance description for a (conformant) varying array.

Arguments :

    pCCB    - pointer to the code control block
    IsPointer   - TRUE if the array is actually a length_is pointer
    IsVaryingArray  - TRUE if the array is varying only

 --*/
{
    GenNdrFormatAttributeDescription( pCCB,
                                      GetFirstIsExpr(),
                                      GetLengthIsExpr(),
                                      IsPointer,
                                      FALSE,
                                      IsVaryingArray,
                                      IsMultiDArray,
                                      pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
}

void
GenNdrFormatAttributeDescription( CCB *         pCCB,
                                  expr_node *   pMinExpr,
                                  expr_node *   pSizeExpr,
                                  BOOL          IsPointer,
                                  BOOL          IsUnion,
                                  BOOL          IsVaryingArray,
                                  BOOL          IsMultiDArray,
                                  BOOL          fGenCorrelationDesc,
                                  unsigned char uFlags
                                  )
/*++

Routine Description :

    Generates the conformance, variance, switch_is, or iid_is description for
    an array, pointer, union, or interface pointer.

Arguments :

    pCCB        - Pointer to code control block.
    pMinExpr    - Either the min_is expression (conformance), first_is
                  expression (variance), or 0 for a switch_is (union)
                  or iid_is (interface pointer).
    pSizeExpr   - Either the size_is (conformance), length_is (variance), 
                  switch_is (union), or iid_is (interface pointer) expression.
    IsPointer   - Is the conformance or variance a pointer attribute.
    IsUnion     - Are we generating a switch_is description.

--*/
{
    FORMAT_STRING *     pFormatString;
    node_skl *          pAttributeNodeType;
    long                Offset;
    FORMAT_CHARACTER    Op;
    unsigned char       Type;
    unsigned char       uConfFlags = uFlags;
    pFormatString = pCCB->GetFormatString();

    //
    // Make sure the min_is() or first_is() is constant 0.
    // The pMinExpr is NULL if we're handling a union's switch_is.
    //
    if ( pMinExpr )
        {
        if ( ! pMinExpr->IsConstant() ) 
            goto ComplexAttribute;
        else
            if ( ((expr_constant *)pMinExpr)->GetValue() != 0 )  
                goto ComplexAttribute;
        }

    if ( pSizeExpr->IsConstant() )
        {
        __int64    Size;

        pFormatString->PushCorrelationTypeByte( FC_CONSTANT_CONFORMANCE );

        Size = ((expr_constant *)pSizeExpr)->GetValue();

        //
        // We push the lower 24 bits of the constant size.
        //
        pFormatString->PushByte( (char) ((Size & 0x00ff0000) >> 16) );
        pFormatString->PushShort( (short) (Size & 0x0000ffff) );
        if ( fGenCorrelationDesc )
            {
            OUT_CORRELATION_DESC( pFormatString, uConfFlags );
            }
        return;
        }

    if ( pSizeExpr->IsAVariable() )
        {
        Op = FC_ZERO;
        pAttributeNodeType = pSizeExpr->GetType();
        }
    else
        {
        expr_node * pLeftExpr;
        expr_node * pRightExpr;
        OPERATOR        Operator;

        if ( pSizeExpr->IsBinaryOperator() )
            {
            pLeftExpr = ((expr_op_binary *)pSizeExpr)->GetLeft();
            pRightExpr = ((expr_op_binary *)pSizeExpr)->GetRight();
            }
        else
            if ( pSizeExpr->IsUnaryOperator() )
                pLeftExpr = ((expr_op_unary *)pSizeExpr)->GetLeft();
            else
                goto ComplexAttribute;

        switch ( Operator = ((expr_operator *)pSizeExpr)->GetOperator() )
            {
            case OP_SLASH :
            case OP_STAR :
                if ( pLeftExpr->IsAVariable() &&
                     pRightExpr->IsConstant() &&
                     ((expr_constant *)pRightExpr)->GetValue() == 2 )
                    {
                    Op = ((Operator == OP_SLASH) ? FC_DIV_2 : FC_MULT_2);

                    pAttributeNodeType = pLeftExpr->GetType();
                    }
                else
                    {
                    goto ComplexAttribute;
                    }
                break;

            case OP_PLUS :
            case OP_MINUS :
                if ( ( pLeftExpr->IsAVariable() &&
                       pRightExpr->IsConstant() &&
                       ((expr_constant *)pRightExpr)->GetValue() == 1 ) ||
                     ( pRightExpr->IsAVariable() &&
                       pLeftExpr->IsConstant() &&
                       ((expr_constant *)pLeftExpr)->GetValue() == 1 ) )
                    {
                    Op = ((Operator == OP_PLUS) ? FC_ADD_1 : FC_SUB_1);

                    pAttributeNodeType = pLeftExpr->GetType();
                    }
                else
                    {
                    goto ComplexAttribute;
                    }
                break;

            case OP_UNARY_INDIRECTION :
                if ( ! pLeftExpr->IsAVariable() )
                    goto ComplexAttribute;

                pAttributeNodeType = pLeftExpr->GetType();

                Op = FC_DEREFERENCE;

                break;

            default :
                goto ComplexAttribute;
            }
        }

    // Will hold the switch_is node.
    CG_NDR *        pSwitchNode;

    //
    // Check if this is top level conformance.
    //
    if (  pCCB->GetCGNodeContext()->IsProc() )
        {
        CG_PROC *       pProc       = (CG_PROC *) pCCB->GetCGNodeContext();
        CG_PARAM *      pParam      = 0;
        CG_PARAM*       pCurrParam  = ( CG_PARAM*) pCCB->GetCurrentParam();
        CG_NDR*         pFirst      = 0;

        CG_ITERATOR     Iterator;

        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_SIZE) &&
             IsMultiDArray )
            Type = FC_TOP_LEVEL_MULTID_CONFORMANCE;
        else
            Type = FC_TOP_LEVEL_CONFORMANCE;

        pProc->GetMembers( Iterator );
        //
        // Find out the type of the attribute descriptor.
        //
        while ( ITERATOR_GETNEXT( Iterator, pParam ) )
            {
            // determine early/late correlation
            if ( pFirst == 0 )
                {
                if ( pCurrParam == pParam )
                    {
                    pFirst = pParam;
                    }
                }
            if ( pParam->GetType() == pAttributeNodeType )
                {
                // determine early/late correlation
                if ( pFirst == 0 )
                    {
                    pFirst = pParam;
                    // this check is enough for param level 
                    uConfFlags |= FC_EARLY_CORRELATION;
                    }
                break;
                }
            }

        if ( ( ( node_param* ) pAttributeNodeType )->IsSaveForAsyncFinish() )
            {
            uConfFlags |= FC_SPLIT_CORRELATION;
            Op = ( FORMAT_CHARACTER ) ( ( ( unsigned char ) Op ) | 0x20 );
            }

        pParam = ( ( node_param* ) pAttributeNodeType )->GetCG();
        pSwitchNode = (CG_NDR*) pParam->GetChild();
        //
        // Get the actual base type if the attribute is a dereference.
        //
        if ( Op == FC_DEREFERENCE || Op == FC_SPLIT_DEREFERENCE )
            {
            pSwitchNode = (CG_NDR *) pSwitchNode->GetChild();
            }

        // Code the type of the size_is etc. expression.

        if ( pCommand->Is64BitEnv() )
            {
            if ( pSwitchNode->IsPointer() )
                {
                // iid_is
                Type |= FC_HYPER;
                }
            else
                {
                // Special treatment for __int3264.
                // hyper is here till the front end prevents it.

				// Note that to support __int3264 in sizing expressions etc., for robust
				// we would need to know the real size of memory variable.
				// Hence at that point we need a mapping from FC_*3264 to a type in <0..f>.
				// It looks like the only tokens that are left are these
				//     FC_INT3264 -> FC_WCHAR, 
				//	   FC_UINT3264 -> FC_FLOAT
				//     FC_UHYPER -> FC_DOUBLE
				// Please compare Xxx_Is_Type_OK in fldattr.cxx.

                FORMAT_CHARACTER  fc = ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();
        
                if ( fc == FC_INT3264  ||  fc == FC_UINT3264  ||  fc == FC_HYPER )
                    {
                    if ( fc == FC_INT3264 )
                        fc = FC_LONG;
                    else
                        fc = FC_ULONG;
                    }
                Type |= fc;
                }
            }
        else
            {
            if ( pSwitchNode->IsPointer() )
                {
                // iid_is
                Type |= FC_LONG;
                }
            else
                Type |= ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();
            }

        pFormatString->PushCorrelationTypeByte( Type );
        pFormatString->PushFormatChar( Op );

        if ( IsPointer && IsMultiDArray &&
             (pProc->GetOptimizationFlags() & OPTIMIZE_SIZE) )
            {
            CG_QUALIFIED_POINTER* pSizePointer = pCCB->GetCurrentSizePointer();
            pFormatString->PushShort( pSizePointer->GetDimension() ); 
            }
        else
            {
            CG_NDR* pOld = 0;
            if ( ( uConfFlags & FC_SPLIT_CORRELATION ) && pProc->IsFinishProc() )
                {
                pOld = pCCB->SetCGNodeContext( pProc->GetAsyncRelative() );
                }

            pFormatString->PushShortStackOffset( 
                            pParam->GetStackOffset( pCCB, I386_STACK_SIZING )
                            );
            if ( ( uConfFlags & FC_SPLIT_CORRELATION ) && pProc->IsFinishProc() )
                {
                pCCB->SetCGNodeContext( pOld );
                }
            }
        }
    else // structure cg class
        {
        CG_STRUCT *         pStruct;
        CG_FIELD *          pField;
        CG_ITERATOR         Iterator;
        CG_NDR*             pFirst = 0;
        CG_NDR*             pCurrentField = pCCB->GetLastPlaceholderClass();

        if ( IsPointer )
            Type = FC_POINTER_CONFORMANCE;
        else
            Type = FC_NORMAL_CONFORMANCE;

        pStruct = (CG_STRUCT *) pCCB->GetCGNodeContext();

        pStruct->GetMembers( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pField ) )
            {
            pSwitchNode = (CG_NDR *) pField->GetChild();

            if ( pCurrentField == pField )
                {
                if ( pFirst == 0 )
                    {
                    pFirst = pField;
                    uConfFlags = 0; // late correlation
                    }
                }

            if ( pField->GetType() == pAttributeNodeType  &&
                 ! pField->GetSizeIsDone() )
                {
                if ( pFirst == 0 )
                    {
                    pFirst = pField;
                    // it's still late correlation if attribute node is pointer and conformant is not. 
                    if ( ! pField->GetChild()->IsPointer() ||pCurrentField->GetChild()->IsPointer() ) 
                        uConfFlags = FC_EARLY_CORRELATION; // early correlation
                    }
                pField->SetSizeIsDone( TRUE );

                //
                // Get the actual base type if the attribute is a dereference.
                //
                if ( Op == FC_DEREFERENCE )
                    pSwitchNode = (CG_NDR *) pSwitchNode->GetChild();

                // Code the type of the size etc. expression.

                if ( pSwitchNode->IsPointer() )
                    {
                    // Iid_is check.
                    //
                    if ( pCommand->Is64BitEnv() )
                        Type |= FC_HYPER;
                    else
                        Type |= FC_LONG;

                    break;
                    }

                if ( pCommand->Is64BitEnv() )
                    {
                    // Special treatment for __int3264.
                    // hyper is here till the front end prevents it.

                    FORMAT_CHARACTER  fc = ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();
        
                    if ( fc == FC_INT3264  ||  fc == FC_UINT3264  || fc == FC_HYPER )
                        {
                        if ( fc == FC_INT3264 )
                            fc = FC_LONG;
                        else
                            fc = FC_ULONG;
                        }
                    Type |= fc;
                    }
                else
                    Type |= ((CG_BASETYPE *)pSwitchNode)->GetSignedFormatChar();

                break;
                }
            }

            //
            // Offset to the attribute field in the structure.  Below are
            // the three possible ways to compute the offset, with the order
            // of precedence.
            //
            // For pointers (either sized pointers, or a pointer to a union)
            // this is a positive offset from the beginning of the structure.
            // For imbeded unions this is the offset from the union's position
            // in the structure to the attribute's position.
            // For conformant (varying) arrays it's a negative offset from the
            // end of the structure.
            //
            if ( IsPointer )
                Offset = pField->GetMemOffset();
            else
                {
                if ( IsUnion || IsVaryingArray )
                    {
                    CG_FIELD * pUnionField;

                    pUnionField = (CG_FIELD *) pCCB->GetLastPlaceholderClass();

                    Offset = pField->GetMemOffset() -
                             pUnionField->GetMemOffset();
                    }
                else
                    {
                    Offset = pField->GetMemOffset() -
                             pStruct->GetMemorySize();
                    }
                }

        pFormatString->PushCorrelationTypeByte( Type );
        pFormatString->PushFormatChar( Op );
        pFormatString->PushShort( Offset );
        }

    if ( fGenCorrelationDesc )
        {
        OUT_CORRELATION_DESC( pFormatString, uConfFlags );
        }

    return;

ComplexAttribute:

    char *      PrintPrefix = "";
    CG_NDR *    pNdr;

    pNdr = pCCB->GetCGNodeContext();

    //
    // If this is a top level attribute and we're compiling /Os then we 
    // don't need the callback since the expression is computed inline in 
    // the stub.
    //
    if ( pNdr->IsProc() &&
         (((CG_PROC *)pNdr)->GetOptimizationFlags() & OPTIMIZE_SIZE) )
        {
        pFormatString->PushCorrelationTypeByte( 
                IsMultiDArray ? 
                FC_TOP_LEVEL_MULTID_CONFORMANCE : FC_TOP_LEVEL_CONFORMANCE );
        pFormatString->PushByte( 0 );
        pFormatString->PushShort( (short) 0 );
        }
    else
        {
        long    Displacement;

        if ( pCCB->GetCGNodeContext()->IsProc() )
            Displacement = 0;
        else
            {
            CG_STRUCT *     pStruct;
            CG_FIELD *      pField;
            CG_NDR *        pNdr;

            // Get the imbeding struct.
            pStruct = (CG_STRUCT *) pCCB->GetCGNodeContext();

            // Get the field whose attribute we're handling.
            pField = (CG_FIELD *) pCCB->GetLastPlaceholderClass();

            //
            // Set the PrintPrefix string correctly.
            //
            PrintPrefix = pField->GetPrintPrefix();

            pNdr = (CG_NDR *) pField->GetChild();

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_CONF_ARRAY :
                case ID_CG_CONF_VAR_ARRAY :
                case ID_CG_CONF_STRING_ARRAY :
                    // Displacement is imbeding struct's size.
                    Displacement = pStruct->GetMemorySize();
                    break;

                case ID_CG_VAR_ARRAY :
                case ID_CG_STRING_ARRAY :
                case ID_CG_ENCAP_STRUCT :
                case ID_CG_UNION :
                    // Displacement is imbeded node's offset in the struct.
                    Displacement = pField->GetMemOffset();
                    break;

                default :
                    Displacement = 0;
                    break;
                }
            }

        GenNdrFormatComplexAttributeDescription( pCCB,
                                                 pMinExpr,
                                                 pSizeExpr,
                                                 Displacement,
                                                 PrintPrefix,
                                                 IsPointer );
        }

    if ( fGenCorrelationDesc )
        {
        OUT_CORRELATION_DESC( pFormatString, uConfFlags );
        }

}


void
GenNdrFormatComplexAttributeDescription( CCB *          pCCB,
                                         expr_node *    pMinExpr,
                                         expr_node *    pSizeExpr,
                                         long           StackTopDisplacement,
                                         char *         PrintPrefix,
                                         BOOL           IsPointer )
/*++

Routine description:

    This routine generates
     - an auxuliary routine that evaluates a complicated expression.
     - a description of the callback call into the current code stream.

    The routine has the following signature:

        void  <name>( PMIDL_STUB_MESSAGE pStubMsg );

    The description is as follows (takes 4 bytes):

        0, FC_CALLBACK, <<routine_index>>

    The naming convention for the routine is currently as follows

        <name> is  <proc_or_struct_name>exprEval_<routine_index>

    Routine generation is postponed by using a Registry object.

Arguments:

    pCCB        - ptr to the code control block
    pMinExpr    - pointer to an expression tree, relates to min_is, first_is
    pSizeExpr   - pointer to an expression tree, relates to size_is, max_is etc.
    StackTopDisplacement    - For an attribute expression on a field in a 
                              a structure, this is the number of bytes to 
                              subtract from StackTop to get the proper 
                              structure pointer.
    PrinfPrefix - The prefix to print after "pS->" when accessing a field. 
    IsPointer   - Is this a description for an attribute on a pointer

    The interpretation of the two input expressions (pMinExpr and pSizeExpr)
    is such that when both of them are present, it is enough to take
    the difference to come up with the proper sizing.

    The algorithm used here is thus as follows:
        pMin    pSize

        NULL    NULL    impossible (assert)
        !=NULL  NULL    impossible (assert)

        NULL    !=NULL  Generate a routine that evaluates the following:
                          pStubMsg->Offset = 0
                          pStubMsg->MaxCount = eval(pSize)

        !=NULL  !=NULL  Generate a routine that evaluates the following:
                          pStubMsg->Offset = eval(pMin)
                          pStubMsg->MaxCount  = eval(pSize) - pStubMsg->Offset
Returns:


--*/
{
    MIDL_ASSERT( pSizeExpr != NULL );

    // Make the name of the routine and put it into the table.
    // Each call to the routine we are in right now will create a new entry
    // in the ExprEval routine table.

    CG_NDR *  pContainer = pCCB->GetCGNodeContext();
    unsigned short Index = (unsigned short)
                           (pCCB->GetExprEvalIndexMgr()->GetIndex() - 1);

    char * pContainerName = pContainer->GetType()->GetSymName();
    char * pName = new char[ strlen(pCCB->GetInterfaceName()) +
                             1 +  // "_"
                             strlen(pContainerName) +
                             sizeof("ExprEval_0000") + 1 ];
    strcpy( pName, pCCB->GetInterfaceName() );
    strcat( pName, "_" );
    strcat( pName, pContainerName );
    strcat( pName, "ExprEval_" );

    char * pBuf = pName + strlen(pName);
    sprintf( pBuf, "%04x", Index );

    pCCB->GetExprEvalIndexMgr()->Lookup( pName );

    // generate the description of the callback

    // If this is a top level attribute we note that in the description.
    if ( pCCB->GetCGNodeContext()->IsProc() )
        pCCB->GetFormatString()->PushCorrelationTypeByte(FC_TOP_LEVEL_CONFORMANCE);
    else
        if ( IsPointer ) 
            pCCB->GetFormatString()->PushCorrelationTypeByte(FC_POINTER_CONFORMANCE);
        else
            pCCB->GetFormatString()->PushCorrelationTypeByte(0);

    pCCB->GetFormatString()->PushFormatChar( FC_CALLBACK );
    pCCB->GetFormatString()->PushShort( (short) Index );

    // Register the routine to be generated for future use.

    EXPR_EVAL_CONTEXT * pExprEvalContext = new EXPR_EVAL_CONTEXT;
    pExprEvalContext->pContainer = pContainer;
    pExprEvalContext->pMinExpr = pMinExpr;
    pExprEvalContext->pSizeExpr = pSizeExpr;
    pExprEvalContext->pRoutineName = pName;
    pExprEvalContext->pPrintPrefix = PrintPrefix;
    pExprEvalContext->Displacement = StackTopDisplacement;

    pCCB->RegisterExprEvalRoutine( (node_skl *) pExprEvalContext );

}



void
CG_ARRAY::GenNdrCSArrayProlog( CCB * pCCB )
/*++

Routine description:

    Generate the format string for an array of international characters
    (if necessary).

Arguments:

    pCCB    - pointer to the code control block

Notes:

    This function also inserts the name of the user type and the name of the
    tag routines used (if any) into their respective lists so that the 
    prototypes can be emitted later.
   
    The FC_CSARRAY format:

        FC_CSARRAY
        FC_PAD
        reserved<2>                     // reserved
        element_size<2>                 // size of the user type
        index_of_cs_routines<2>         // offset of sizing/conversion routine
        offset_to_array_or_string<4>    // offset to the underlying type
        
--*/
{
    PNAME   pUserTypeName = GetCSUserTypeName();

    // If there's no CS user type name, this is not a cs array and we can quit.

    if ( ! pUserTypeName )
        return;

    FORMAT_STRING *pFormatString = pCCB->GetFormatString();
    short          TypeIndex = pCCB->GetCsTypeList().Insert( pUserTypeName );

    pFormatString->PushFormatChar( FC_CSARRAY );
    pFormatString->PushByte( 0 );
    pFormatString->PushShort( GetCSElementSize() );
    pFormatString->PushShort( TypeIndex );    
    pFormatString->PushShort( (short) 0 );      // reserved

    // Push the offset to the underlying array/string descriptor.  For now
    // it will always be immediately after the FC_CSARRAY so we can push a
    // constant value

    pFormatString->PushLong( 12 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\cgcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	cgcls.cxx

 Abstract:

	Routines for the cgcls code generation class.

 Notes:


 History:

	Aug-31-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

short
CG_CLASS::GetMembers(
	ITERATOR&	I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	GetMembers (list of child+its siblings) of the code generation class.

 Arguments:

 	I	- An iterator for the member list.
	
 Return Value:

 	Count of number of members.
	
 Notes:

----------------------------------------------------------------------------*/
{
	CG_CLASS	*	pC;
	short			Count = 0;

	if( ( pC = GetChild() ) != 0 )
		{
		ITERATOR_INSERT( I, pC );

		Count++;
		while( ( pC = pC->GetSibling() ) != 0 )
			{
			ITERATOR_INSERT( I, pC );
			Count++;
			}
		}

	return Count;
}

CG_CLASS *
CG_CLASS::GetLastSibling()
	{
	CG_CLASS * pLast = this;
	CG_CLASS * pS;

	while ( ( pS = pLast->GetSibling() ) != 0 )
		 pLast = pS;
	return pLast;
	}

// Set the member list on a class

void CG_CLASS::SetMembers( ITERATOR & I )
{
    CG_CLASS *pHead = NULL;
    ITERATOR_INIT( I );
    ITERATOR_GETNEXT( I, pHead );

    if (pHead)
        {

        CG_CLASS *pCurrent = pHead;
        CG_CLASS *pNext = NULL;
       
        while( ITERATOR_GETNEXT( I, pNext ) )
		    {
            pCurrent->SetSibling( pNext );
            pCurrent = pNext;
            }
        pCurrent->SetSibling( NULL );

        }

    SetChild( pHead );
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\cgmain.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	cgmain.cxx

 Abstract:

	The main entry point for the code generator.

 Notes:


 History:

	VibhasC		Aug-13-1993		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"

#pragma hdrstop

#include "control.hxx"
#include "ilreg.hxx"

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/

extern node_interface	*	pBaseInterfaceNode;
extern CMD_ARG			*	pCommand;
extern ccontrol			*	pCompiler;

extern CG_CLASS			*	Transform( node_skl * pIL );
extern	void				print_memstats();

/****************************************************************************/



void
CGMain(
	node_skl	*	pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	The main code generator entry point.

 Arguments:
	
	pNode	- A pointer to the type graph source node.

 Return Value:

 	Code generation status.
	
 Notes:

----------------------------------------------------------------------------*/
{
	CG_CLASS		*	pCGSource;

	//
	// Transform the type graph into the Code generation IL.
	//

    pCompiler->SetPassNumber( ILXLAT_PASS );

	pCGSource		= Transform( pNode );


#ifdef MIDL_INTERNAL
	printf("ILxlate done\n");
	if(pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
		print_memstats();
		};
#endif // MIDL_INTERNAL

	//
	// This is temporary initialization code. The final code may differ.
	//

	
	CCB					CCB( DEFAULT_GB_RTN_NAME,
							 DEFAULT_SR_RTN_NAME,
							 DEFAULT_FB_RTN_NAME,
							 pCommand->GetOptimizationFlags(),
							 pCommand->IsSwitchDefined( SWITCH_USE_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_OLDNAMES ),
							 pCommand->IsSwitchDefined( SWITCH_MS_EXT ) ? 1 : 0,
							 pCommand->IsRpcSSAllocateEnabled(),
							 ((pCommand->GetErrorOption() & ERROR_ALLOCATION) == ERROR_ALLOCATION),
							 ((pCommand->GetErrorOption() & ERROR_REF) == ERROR_REF),
							 ((pCommand->GetErrorOption() & ERROR_ENUM) == ERROR_ENUM),
							 ((pCommand->GetErrorOption() & ERROR_BOUNDS_CHECK) == ERROR_BOUNDS_CHECK),
							 ((pCommand->GetErrorOption() & ERROR_STUB_DATA) == ERROR_STUB_DATA)
						  );

	//
	// Do the code generation.
	//

#ifdef MIDL_INTERNAL
	if( pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
		printf("dumping IL\n");
		pCGSource->Dump(0);
		}
#endif // MIDL_INTERNAL



	pCompiler->SetPassNumber( CODEGEN_PASS );


// define NO_CODEGEN to stop after IL translation
#ifndef NO_CODEGEN
	pCGSource->GenCode( &CCB );
#endif



}

CG_CLASS* ILSecondGenTransform( CG_CLASS *pClass );

void
Ndr64CGMain(
	node_skl	*	pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	The main code generator entry point.

 Arguments:
	
	pNode	- A pointer to the type graph source node.

 Return Value:

 	Code generation status.
	
 Notes:

----------------------------------------------------------------------------*/
{
	CG_CLASS		*	pCGSource;

	//
	// Transform the type graph into the Code generation IL.
	//

    pCompiler->SetPassNumber( NDR64_ILXLAT_PASS );

	pCGSource		= Transform( pNode );


#ifdef MIDL_INTERNAL
	printf("\nStage1 of ILxlate done\n");
	if(pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
        printf("\n");
        printf("dumping stage 1 IL\n");
        pCGSource->Dump();
		};
#endif // MIDL_INTERNAL

    pCGSource = ILSecondGenTransform( pCGSource );

#ifdef MIDL_INTERNAL
	printf("\nStage2 of ILxlate done\n");
	if(pCommand->IsSwitchDefined( SWITCH_DUMP ) )
		{
        printf("\n");
        printf("dumping stage 2 IL\n");
        pCGSource->Dump();
		};
#endif // MIDL_INTERNAL
	//
	// This is temporary initialization code. The final code may differ.
	//

	
	CCB					CCB( DEFAULT_GB_RTN_NAME,
							 DEFAULT_SR_RTN_NAME,
							 DEFAULT_FB_RTN_NAME,
							 pCommand->GetOptimizationFlags(),
							 pCommand->IsSwitchDefined( SWITCH_USE_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ),
							 pCommand->IsSwitchDefined( SWITCH_OLDNAMES ),
							 pCommand->IsSwitchDefined( SWITCH_MS_EXT ) ? 1 : 0,
							 pCommand->IsRpcSSAllocateEnabled(),
							 ((pCommand->GetErrorOption() & ERROR_ALLOCATION) == ERROR_ALLOCATION),
							 ((pCommand->GetErrorOption() & ERROR_REF) == ERROR_REF),
							 ((pCommand->GetErrorOption() & ERROR_ENUM) == ERROR_ENUM),
							 ((pCommand->GetErrorOption() & ERROR_BOUNDS_CHECK) == ERROR_BOUNDS_CHECK),
							 ((pCommand->GetErrorOption() & ERROR_STUB_DATA) == ERROR_STUB_DATA)
						  );

	//
	// Do the code generation.
	//

	pCompiler->SetPassNumber( NDR64_CODEGEN_PASS );


// define NO_CODEGEN to stop after IL translation
#ifndef NO_CODEGEN
	pCGSource->GenCode( &CCB );
#endif



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\cgdump.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	cgdump.cxx

 Abstract:

	A debug code generation object dumper.

 Notes:


 History:

	VibhasC		Aug-13-1993		Created.
    mzoran      Nov-15-1999     Modified to print tree.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

//
//  Characters for class graph dumper
//
#if defined(WIN32)

const char CharElbow         = '';
const char CharTee           = '';
const char CharVLine         = '';
const char StringTeeLine[]   = "";
const char StringElbowLine[] = "";

#else

const char CharElbow         = '\\';
const char CharTee           = '>';
const char CharVLine         = '|';
const char StringTeeLine[]   = ">---";
const char StringElbowLine[] = "\\---";


#endif

#ifdef MIDL_INTERNAL

typedef PTR_SET<CG_CLASS> CG_DUMP_SET;
typedef MAP<CG_CLASS*, unsigned long> CG_DUMP_MAP;

const char * DoGetAdditionalDumpInfo( CG_CLASS *pClass )
{
    if ( ( dynamic_cast<CG_FILE*>( pClass ) != NULL ) && 
         ( static_cast<CG_FILE*>( pClass )->GetFileName() != NULL ) )
        {
        return static_cast<CG_FILE*>( pClass )->GetFileName();
        }
    else if ( ( dynamic_cast<CG_HANDLE*>( pClass ) != NULL ) &&
              ( static_cast<CG_HANDLE*>( pClass )->GetHandleType() != NULL ) &&
              ( static_cast<CG_HANDLE*>( pClass )->GetHandleType()->GetSymName() != NULL ) )
        {
        return static_cast<CG_HANDLE*>( pClass )->GetHandleType()->GetSymName();
        }
    else if ( dynamic_cast<CG_FIELD*>( pClass ) != NULL )
        {
        CG_FIELD *pField = dynamic_cast<CG_FIELD*>( pClass );
        size_t Length = strlen(pField->GetSymName()) + 
                        strlen(pField->GetPrintPrefix()) + 1;
        char *p = new char[Length];
        strcpy( p, pField->GetPrintPrefix() );
        strcat( p, pField->GetSymName() );
        return p;
        }
    else if ( ( pClass->GetType() != NULL ) &&
              ( pClass->GetType()->GetSymName() != NULL ) )
        {
        return pClass->GetType()->GetSymName();
        }
    else 
        {
        return "";
        }
}

unsigned long DoDumpCGClassList( CG_CLASS *pClass, CG_DUMP_MAP  & DumpMap, unsigned long  & LastNodeNum )
{

    if ( pClass == NULL )
        return 0;

    // See if this node has already been printed
    unsigned long Me;
    if ( DumpMap.Lookup( pClass, &Me ) )
        return Me;

    Me = ++LastNodeNum;
    DumpMap.Insert( pClass, Me );

    CG_CLASS	*	pChild	= pClass->GetChild();
	CG_CLASS	*	pSibling= pClass->GetSibling();

    CG_CLASS *pReturnType;
    if ( ( dynamic_cast<CG_PROC*>( pClass ) != NULL ) && 
         ( ( pReturnType = static_cast<CG_PROC*>( pClass )->GetReturnType()  ) != NULL ) )
        {
        DoDumpCGClassList( pReturnType, DumpMap, LastNodeNum );
        }

    unsigned long Ch = DoDumpCGClassList( pChild,   DumpMap, LastNodeNum );    
    unsigned long Si = DoDumpCGClassList( pSibling, DumpMap, LastNodeNum );
    const char *pName = typeid( *pClass ).name();
    const char *pAdditionalInfo = DoGetAdditionalDumpInfo( pClass );

    fprintf( stderr,
			 "%30s : %.4d(0x%p) : Ch = %.4d, Si = %.4d %s\n", 
			 pName,
			 Me,
             pClass,
			 Ch,
			 Si,
			 pAdditionalInfo
		   );
    
    return Me;
                             
}

void DoDumpCGClassList( CG_CLASS *pClass, CG_DUMP_MAP *pDumpMap = NULL )
{
    
    unsigned long NodeNum = 0;
    if ( NULL == pDumpMap )
        {
        CG_DUMP_MAP DumpMap;
        DoDumpCGClassList( pClass, DumpMap, NodeNum );
        }
    else
        DoDumpCGClassList( pClass, *pDumpMap, NodeNum );
    fprintf( stderr, "\n" );   
}

void DoDumpCGClassGraph( CG_CLASS *pClass, CG_DUMP_MAP  * pDumpMap, CG_DUMP_SET & DumpSet, 
                         const char *pPrefixString )
{
    if ( pClass == NULL )
        return;
    
    //
    // Print Myself
    //
    unsigned long Me;
    BOOL LookupResult = pDumpMap->Lookup( pClass, &Me );
    MIDL_ASSERT( LookupResult );

    fprintf( stderr, "%s%s, %.4d(0x%p), %s\n",
        pPrefixString, 
        typeid( *pClass ).name(),
        Me,
        pClass,
        DoGetAdditionalDumpInfo( pClass ) ); 

    //
    // If this node has already been printed, do not print children.
    //
    if ( DumpSet.Lookup( pClass ) )
        return;

    DumpSet.Insert( pClass );

    //
    // Copy old prefix
    //
    const size_t PrevStrLen = strlen( pPrefixString );
    const size_t NewStringLength = PrevStrLen + 4 + sizeof('\0');
    char *pNewPrefix = new char[ NewStringLength ];
    char *pNewPrefixTail = pNewPrefix + PrevStrLen;
    memset( pNewPrefix, 0xBD, NewStringLength );
    memcpy( pNewPrefix, pPrefixString, PrevStrLen + 1 );

    //
    // Modify the previous characters.   If this was the last child,
    // convert previous 4 characters to spaces, otherwise convert
    // to a line with spaces.
    // 
    if ( PrevStrLen >= 4 )
        {
        pNewPrefix[PrevStrLen - 3] = ' ';
        pNewPrefix[PrevStrLen - 2] = ' ';                              
        pNewPrefix[PrevStrLen - 1] = ' ';                              
        if (pNewPrefix[PrevStrLen - 4] == CharElbow)                         
            pNewPrefix[PrevStrLen - 4] = ' ';                          
        else if ( pNewPrefix[PrevStrLen - 4] == CharTee )                  
            pNewPrefix[PrevStrLen - 4] = CharVLine;
        else MIDL_ASSERT( false );
        }

    gplistmgr Children;
    pClass->GetMembers( Children );
    
    //
    // Add return type for procs
    //
    CG_CLASS *pReturnType;
    if ( ( dynamic_cast<CG_PROC*>( pClass ) != NULL ) && 
         ( ( pReturnType = static_cast<CG_PROC*>( pClass )->GetReturnType()  ) != NULL ) )
        {
        Children.InsertHead( pReturnType );
        }

    CG_CLASS *pChild;
    CG_CLASS *pNext;
    ITERATOR_INIT( Children );
    if ( ITERATOR_GETNEXT( Children, pChild ) )
        {
        for(;;)
            {
            if ( ITERATOR_GETNEXT( Children, pNext ) )
                {
                //
                // Additional children follow
                //
                memcpy( pNewPrefixTail, StringTeeLine, sizeof(StringTeeLine));
                DoDumpCGClassGraph( pChild, pDumpMap, DumpSet, pNewPrefix );
                pChild = pNext;
                }
            else 
                {
                //
                // No more children
                //
                memcpy( pNewPrefixTail, StringElbowLine, sizeof(StringElbowLine) );
                DoDumpCGClassGraph( pChild, pDumpMap, DumpSet, pNewPrefix );
                break;
                }
            }
        }

    delete[] pNewPrefix;

}

void DoDumpCGClassGraph( CG_CLASS *pClass, CG_DUMP_MAP * pDumpMap = NULL )
{
    CG_DUMP_SET DumpSet;
    DoDumpCGClassGraph( pClass, pDumpMap, DumpSet, "");
    fprintf( stderr, "\n" );
}

void CG_CLASS::Dump( const char *pTitle )
{
    if ( pTitle )
        {
        fprintf( stderr, pTitle );
        fprintf( stderr, "\n" );        
        }

    CG_DUMP_MAP DumpMap;
    DoDumpCGClassList( this, &DumpMap );
    DoDumpCGClassGraph( this, &DumpMap );
}

#endif // MIDL_INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\cgobject.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    cgobject.cxx

 Abstract:

    code generation for object interfaces.
    CG_OBJECT_INTERFACE
    CG_OBJECT_PROC


 Notes:


 History:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "buffer.hxx"
extern "C"
{
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <errno.h>
}
#include "szbuffer.h"

// Needed to time out a synchronize write to dlldata.c
void MidlSleep( int time_in_sec);

// number of times (1 sec delay per attempt) before quitting.
#define DLLDATA_OPEN_ATTEMPT_MAX    25

/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;
char* GetRpcProxyHVersionGuard( char* );

/****************************************************************************
 *  global flags
 ***************************************************************************/
BOOL            fDllDataDelegating  = FALSE;





CG_OBJECT_INTERFACE::CG_OBJECT_INTERFACE(
    node_interface *pI,
    GUID_STRS       GStrs,
    BOOL            fCallbacks,
    BOOL            fMopInfo,
    CG_OBJECT_INTERFACE *   pBaseIF
    ) : CG_INTERFACE(pI, GStrs, fCallbacks, fMopInfo, 0, pBaseIF)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    The constructor for the code generation file node.

 Arguments:

    pI          - A pointer to the interface node in type graph.
    GStrs       - guid strings
    fCallbacks  - Does the interface have any callbacks ?
    fMopInfo    - Does the interface have any mops ?
    
 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
{
    SetBaseInterfaceCG( pBaseIF );
    pThisDeclarator = MakePtrIDNodeFromTypeName( "This",
                                                 GetType()->GetSymName() );
    // all object interfaces use the same stub desc name

    pStubDescName     = "Object" STUB_DESC_STRUCT_VAR_NAME;
    
    fLocal            = GetType()->FInSummary( ATTR_LOCAL );
    fForcedDelegation = FALSE;
    fVisited          = FALSE;

}

//--------------------------------------------------------------------
//
// CountMemberFunctions
//
// Notes: This function counts the member functions in an interface,
//        including inherited member functions.
//
//
//
//--------------------------------------------------------------------
unsigned long 
CG_OBJECT_INTERFACE::CountMemberFunctions() 
{
    return ((node_interface*)GetType())->GetProcCount();
}

BOOL                        
CG_OBJECT_INTERFACE::IsLastObjectInterface()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Return TRUE if there are no more object interfaces after us.

 Arguments:
    
    none.

 Return Value:

    TRUE if there are no more non-local object interfaces.
    
 Notes:

----------------------------------------------------------------------------*/
{
    CG_INTERFACE    *   pNext = (CG_INTERFACE *) GetSibling();

    while ( pNext )
        {
        if ( pNext->IsObject() && !( (CG_OBJECT_INTERFACE*)pNext)->IsLocal() )
            return FALSE;

        pNext = (CG_INTERFACE *) pNext->GetSibling();
        } 

    return TRUE;
}


CG_STATUS
CG_OBJECT_INTERFACE::GenProxy(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    CG_PROC         *   pCG;
    ISTREAM         *   pStream = pCCB->GetStream();

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // do nothing for local interfaces and types-only base interfaces


    if( IsLocal() || !( GetMembers( I ) || GetBaseInterfaceCG() ) )
        {
        return CG_OK;
        }
    
    Out_StubDescriptorExtern( pCCB );

    // Check for use of [enable_allocate]

    if ( GetUsesRpcSS() )
        pCCB->SetMallocAndFreeStructExternEmitted();

    Out_InterpreterServerInfoExtern( pCCB );

    pStream->NewLine();
    pStream->WriteFormat( 
                    "extern const MIDL_STUBLESS_PROXY_INFO %s_ProxyInfo;",
                    GetSymName() );
    pStream->NewLine();

    //
    // for all procedure in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCCB->SetCodeGenSide( CGSIDE_CLIENT );
        pCG->GenClientStub( pCCB );

        pCCB->SetCodeGenSide( CGSIDE_SERVER );
        pCG->GenServerStub( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::OutputProxy(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    ISTREAM         *   pStream = pCCB->GetStream();

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // do nothing for local interfaces and types-only base interfaces

    if( IsLocal() || !( GetMembers( I ) || GetBaseInterfaceCG() ) )
        {
        return CG_OK;
        }

    pStream->NewLine();

    pStream->Write("#pragma code_seg(\".orpc\")");

    Out_ProcOffsetTable( pCCB );

    if ( pCommand->NeedsNDR64Run() )
        Out_ProxyInfo( pCCB, FALSE );
    else
        GenProxyInfo( pCCB, FALSE );

        Out_InterpreterServerInfo( pCCB, CGSIDE_SERVER );

    return CG_OK;
}

unsigned long 
CG_OBJECT_INTERFACE::PrintProxyMemberFunctions(
    ISTREAM *   pStream,
    BOOL        fForcesDelegation ) 
/*++

Routine Description:

    This function prints out the member functions of an interface proxy.
    The function calls itself recursively to print out inherited member functions.

Arguments:

    pStream - Specifies the destination stream for output.

--*/
{
    CG_OBJECT_PROC      *   pProc;
    CG_ITERATOR             I;
    CG_OBJECT_INTERFACE *   pBaseInterface  = (CG_OBJECT_INTERFACE  *)GetBaseInterfaceCG();

    if(pBaseInterface)
        pBaseInterface->PrintProxyMemberFunctions(pStream, fForcesDelegation );
    else    // special stuff for IUnknown
        {
#ifdef OK_TO_HAVE_0_IN_VTABLES
        pStream->NewLine();
        pStream->Write( "0 /* QueryInterface */ ," );
        pStream->NewLine();
        pStream->Write( "0 /* AddRef */ ," );
        pStream->NewLine();
        pStream->Write( "0 /* Release */" );
#else
        pStream->NewLine();
        pStream->Write( "IUnknown_QueryInterface_Proxy," );
        pStream->NewLine();
        pStream->Write( "IUnknown_AddRef_Proxy," );
        pStream->NewLine();
        pStream->Write( "IUnknown_Release_Proxy" );
#endif
        return 0;
        }

    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pProc )  )
        {
        pStream->Write( " ," );

        pStream->NewLine();
        pProc->OutProxyRoutineName( pStream, fForcesDelegation );
        }
    return 0;
}

/*
This routine is used to see if we need to force proxies with a thunk for static
linking. We need a thunk if the proc number is too big for the engine to handle.
Method limits apply only to stubless proxies. /Oicf and /Oic but not /Oi or /Os.

The engine was capable of supporting different number of methods depending on
the size of the stubless client routine vtable. This is the size of the stubless 
client vtbl over releases:

            < 32        Windows NT 3.51-
            32 - 110    Windows NT 4.0
            110 - 512   Windows NT 4.0 SP3
            128         Windows NT 5 beta2
            infinity    Windows 2000

In NT5 beta2 we put a new support for stubless client vtbl that removed any 
limitations. At the same time we decreased the size of the default vtbl to 128.
However, we had a bug, and the support for unlimited methods didn't work, so 
effectively we, we are doing the same thing again with NT5 beta3 (2000 beta 3).
 
*/
BOOL CG_OBJECT_PROC::IsStublessProxy()
{
    BOOL res = TRUE;

    if ( ! GetCallAsName() &&
         ( GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT ) &&
         ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) )
        {
        if (pCommand->GetNdrVersionControl().HasNdr50Feature())
            {
            // Temporary till we deploy a fix in NT5 beta3.
            // With beta3 fix, this branch should simply say
            //    res = TRUE;
            res = GetProcNum() < 128;
            }
        else
            {
            unsigned int lMaxProcNumAllowed;

            // NT4 engine had the NDR version 2.0
            if (pCommand->GetNdrVersionControl().HasNdr20Feature())
                lMaxProcNumAllowed = 110;
            else
                lMaxProcNumAllowed = 32; // NT3.51

            res = GetProcNum() < lMaxProcNumAllowed;
            }
        }
    else
        res = FALSE;

    return res;
}

void                    
CG_OBJECT_PROC::OutProxyRoutineName( 
    ISTREAM *   pStream,
    BOOL        fForcesDelegation ) 
{
    char    *   pszProcName;
    BOOL        fIsStublessProxy;

    // In NT5, we can fill in -1 for all the non-delegation methods, and generate 
    // a stubless proxy. For older platforms, due to limits of the support for
    // stubless proxies we have to generate actual name for static linking.
    // The name corrsponds to a thunk, or a mini-stub, calling into interpreter.
    // See IsStublessProxy() for vtbl limits.
    // Later during proxy creation in ndr engine, we'll fill in ObjectStublessProxy
    // vtbl with entries that we take from the default table or that we generate on fly.
    // In fact, for 2000 final, we don't have any limits and we could do it for all 
    // interfaces but we do have a backward compatibility problem due to the above 
    // limitations on old platforms.
    // Also, midl has been issuing a warning that NT4SP3 doesn't support more than 512
    // methods etc.,  although that's applicable to late-binding only. We are removing
    // this warning.

    fIsStublessProxy = IsStublessProxy(); 

    //
    // Delegated and interpreted proxies have their Vtables filled in 
    // at proxy creation time (see ndr20\factory.c).
    //
    if ( IsDelegated () )
        pStream->Write( "0 /* " );

    if ( fIsStublessProxy )
        {
        if ( fForcesDelegation  &&  ! IsDelegated() )
            pStream->Write( "0 /* forced delegation " );
        else
            pStream->Write( "(void *) (INT_PTR) -1 /* " );
        }

    if ( GetCallAsName() )
        pszProcName = GetCallAsName();
    else 
        pszProcName = GetSymName();

    if ( fIsStublessProxy )
        {
        // Just a nitpicky different comment for the stubless guys.
        pStream->Write( GetInterfaceName() );
        pStream->Write( "::" );
        pStream->Write( pszProcName );
        }
    else
        {
        pStream->Write( GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( pszProcName );
        pStream->Write( "_Proxy" );
        }

    if ( IsDelegated () || fIsStublessProxy )
        pStream->Write(  " */" );
}

CG_STATUS
CG_INTERFACE::GenProxyInfo( CCB *pCCB,
                            BOOL IsForCallback )
{
    ISTREAM         *   pStream             = pCCB->GetStream();
    
    pStream->Write( "static const MIDL_STUBLESS_PROXY_INFO " );
    pStream->Write( GetSymName() );
    pStream->Write( "_ProxyInfo =" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( "{" );
    pStream->NewLine();

    // Stub descriptor.
    pStream->Write( '&' );
    pStream->Write( GetStubDescName() );
    pStream->Write( ',' );
    pStream->NewLine();

    // Proc format string.
    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
    else
        pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
    pStream->Write( ',' );
    pStream->NewLine();

    // Proc format string offset table.
    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "(unsigned short *) " );

    if ( IsObject() )
        pStream->Write( '&' );

    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
        
    pStream->Write( GetSymName() );

    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "_Ndr64ProcTable" );
    else
        pStream->Write( FORMAT_STRING_OFFSET_TABLE_NAME );

    if ( IsObject() )
        pStream->Write( "[-3]," );
    else
        pStream->Write( ',' );
        
    pStream->NewLine();

            
    if ( !pCommand->NeedsNDR64Run() )
        {
        pStream->Write( "0," );
        pStream->NewLine();        
        pStream->Write( "0,");
        pStream->NewLine();
        pStream->Write( "0");
        }
    else
        {
        // BUGBUG: what if we let ndr64 as default?
        pStream->Write( '&' );
        if ( pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
            pStream->Write( NDR64_TRANSFER_SYNTAX_VAR_NAME );
        else
            pStream->Write( NDR_TRANSFER_SYNTAX_VAR_NAME );
        
        pStream->Write( ',' );
        pStream->NewLine();
        // SyntaxInfo is only generated when NDR64 is required.
        // MIDL_SYNTAX_INFO will be generated for each transfer syntax supported.
        if ( pCommand->NeedsNDRRun() )
            pStream->Write( "2," );
        else
            pStream->Write( "1," );
        pStream->NewLine();
        if ( IsForCallback )
            pStream->Write( MIDL_CALLBACK_VAR_NAME );
        pStream->Write( GetMulSyntaxInfoName() );
        pStream->NewLine();
        }

    pStream->NewLine();
    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->NewLine();

    return CG_OK;

}

CG_STATUS
CG_INTERFACE::GenSyntaxInfo( CCB * pCCB,
                             BOOL IsForCallback)
{
    if ( !pCommand->NeedsNDR64Run() || !pCommand->IsFinalProtocolRun() )
        return CG_OK;

    long nCount = pCommand->NeedsNDRRun() ? 2 : 1 ;
    ISTREAM *pStream = pCCB->GetStream();

    pStream->WriteOnNewLine("static " MIDL_SYNTAX_INFO_TYPE_NAME " ");
    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );

    pStream->Write( GetSymName() );      
    pStream->Write( MIDL_SYNTAX_INFO_VAR_NAME " [ ");
    pStream->WriteNumber(" %d ] = ", nCount );
    pStream->IndentInc();
    
    pStream->WriteOnNewLine( "{" );
    pStream->NewLine();

    if ( pCommand->NeedsNDRRun() )
        Out_OneSyntaxInfo( pCCB, IsForCallback, SYNTAX_DCE );

    if ( nCount > 1 )
        pStream->Write( "," );
        
    if ( pCommand->NeedsNDR64Run() )
        Out_OneSyntaxInfo( pCCB, IsForCallback, SYNTAX_NDR64 );
        
    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine(2);

    return CG_OK;
}

CG_STATUS
CG_OBJECT_INTERFACE::GenInterfaceProxy( 
    CCB *pCCB, 
    unsigned long )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return CG_OK;

    char            *   pszInterfaceName    = GetSymName();
    ISTREAM         *   pStream             = pCCB->GetStream();
    BOOL                fDelegates          = (NULL != GetDelegatedInterface());

    //
    // Output the interface proxy.
    //

    //
    // If we have to delegate or if we have interpreted methods, then we
    // can not emit the const because in both of these instances the proxy
    // Vtable must be modified during proxy creation time (see 
    // ndr20\factory.c).
    //

    if ( ! fDelegates && ! HasStublessProxies() )
        pStream->Write("const ");

    char TmpBuff[10];
    long Count = CountMemberFunctions();

    // Use a struct macro for Ansi [] compatibility.

    pStream->Write("CINTERFACE_PROXY_VTABLE(" );
    sprintf( TmpBuff, "%ld%", Count );
    pStream->Write( TmpBuff );
    pStream->Write(") _");
    pStream->Write(pszInterfaceName);
    pStream->Write("ProxyVtbl = ");
    pStream->NewLine();
    pStream->Write("{");
    pStream->IndentInc();

    //
    // Emit ProxyInfo field for stubless proxies
    // (NT 3.5 incompatible).
    //

    BOOL    fForcesDelegation = HasStublessProxies()  &&
                                ! HasItsOwnStublessProxies()  &&
                                CountMemberFunctions() > 3;

    if ( fForcesDelegation )
        SetHasForcedDelegation();

    if ( HasStublessProxies() ) 
        {
        // The ProxyInfo.
        pStream->NewLine();

        if ( HasItsOwnStublessProxies() )   
            {
            pStream->Write( '&' );
            pStream->Write( pszInterfaceName );
            pStream->Write( "_ProxyInfo" );
            }
        else
            {
            // In fact, we delegate for empty interfaces or interfaces
            // with os methods only.

            pStream->Write( '0' );
            }

        pStream->Write( ',' );
        }
    else if ( pCommand->GetNdrVersionControl().HasStublessProxies() )
        {
        // Add a dummy 0 for proxy info pointer for a proxy that is
        // oi or os in the file that has stubles proxies

        pStream->NewLine();
        pStream->Write( "0,    /* dummy for table ver 2 */" );
        }
    
    //Write the IID
    pStream->NewLine();
    pStream->Write( "&IID_" );
    pStream->Write( pszInterfaceName );
    pStream->Write( ',' );

    //initialize the vtable
    PrintProxyMemberFunctions( pStream, fForcesDelegation );

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();

    return CG_OK;
}

unsigned long 
CG_OBJECT_INTERFACE::PrintStubMemberFunctions(
    ISTREAM       * pStream) 
/*++

Routine Description:

    This function prints out the member functions of an interface stub dispatch table
    The function calls itself recursively to print out inherited member functions.

Arguments:

    pInterface - Specifies the interface node.

    pStream - Specifies the destination stream for output.

--*/
{
    unsigned long           count           = 0;
    CG_OBJECT_PROC *        pProc;
    CG_ITERATOR             I;
    CG_OBJECT_INTERFACE *   pBaseInterface  = (CG_OBJECT_INTERFACE  *)GetBaseInterfaceCG();

    if ( IsIUnknown() )
        return 0;

    if ( pBaseInterface )
        count = pBaseInterface->PrintStubMemberFunctions(pStream);

    GetMembers( I );

    for( ; ITERATOR_GETNEXT( I, pProc ); count++ )
        {
        if ( ((node_proc*) (pProc->GetType()))->IsFinishProc() )
            {
            continue;
            }
        if( count != 0 )
            pStream->Write(',');

        pStream->NewLine();
        pProc->OutStubRoutineName( pStream );

        }
    return count;
}

void                    
CG_OBJECT_PROC::OutStubRoutineName( 
    ISTREAM * pStream )
{
    node_proc* pProc = (node_proc*) GetType();

    if ( IsDelegated() )
        {
        pStream->Write( "STUB_FORWARDING_FUNCTION" );
        return;
        }

    // local procs don't need proxys and stubs
    if ( IsLocal() )
        {
        pStream->Write( '0' );
        return;
        }

    if ( pProc->IsBeginProc() )
        {
        pStream->Write( S_NDR_CALL_RTN_NAME_DCOM_ASYNC );
        return;
        }

#ifndef TEMPORARY_OI_SERVER_STUBS

    if ( (GetOptimizationFlags() &
            (OPTIMIZE_INTERPRETER_V2 | OPTIMIZE_INTERPRETER)) ==
            (OPTIMIZE_INTERPRETER_V2 | OPTIMIZE_INTERPRETER) )
        {
        if ( HasAsyncHandle() )
            pStream->Write( S_OBJECT_NDR_CALL_RTN_NAME_ASYNC );
        else
            {
            if ( pCommand->NeedsNDR64Run() )
                pStream->Write( S_OBJECT_NDR64_CALL_RTN_NAME );
            else
                pStream->Write( S_OBJECT_NDR_CALL_RTN_NAME_V2 );
            }
        return;
        }
    if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {
        pStream->Write( S_OBJECT_NDR_CALL_RTN_NAME );
        return;
        }
#endif // TEMPORARY_OI_SERVER_STUBS

    pStream->Write( GetInterfaceName() );
    pStream->Write( '_' );
    pStream->Write( GetSymName() );
    pStream->Write( "_Stub" );

}


CG_STATUS
CG_OBJECT_INTERFACE::GenInterfaceStub( 
    CCB *pCCB, 
    unsigned long )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return CG_OK;


    node_interface  *       pInterface          = (node_interface *) GetType();
    char *                  pszInterfaceName    = pInterface->GetSymName();

    ISTREAM             *   pStream             = pCCB->GetStream();
    unsigned long           count;

#ifdef TEMPORARY_OI_SERVER_STUBS
    BOOL                    fPureInterpreted    = FALSE;
#else // TEMPORARY_OI_SERVER_STUBS
    BOOL                    fPureInterpreted    = HasOnlyInterpretedMethods();
#endif // TEMPORARY_OI_SERVER_STUBS

    BOOL                    fDelegates          = (NULL != GetDelegatedInterface()) || fForcedDelegation;

    // if any of our base interfaces are delegated, we can't be pure interpreted

    if ( fDelegates )
        fPureInterpreted = FALSE;

    // pure interpreted uses no dispatch table, special invoke function instead
    if ( !fPureInterpreted )
        {
        // Generate the dispatch table
        pStream->NewLine(2);
        pStream->Write( "static const PRPC_STUB_FUNCTION " );
        pStream->Write( pszInterfaceName );
        pStream->Write( "_table[] =" );
        pStream->NewLine();
        pStream->Write('{');
        pStream->IndentInc();

        // Print out the names of all the procedures.
        count = PrintStubMemberFunctions(pStream);

        if ( count == 0 )
            {
            // This is possible for an empty interface inheriting
            // directly from IUnknown. As we don't print first three
            // entries, the table would be empty.
            // We add a zero to simplify references.

            pStream->NewLine();
            pStream->Write( "0    /* a dummy for an empty interface */" );
            }

        pStream->IndentDec();
        pStream->NewLine();
        pStream->Write( "};" );
        pStream->NewLine();
        }

    count = CountMemberFunctions();

    //initialize an interface stub
    pStream->NewLine();
    if ( !fDelegates && !( ( node_interface* ) GetType() )->IsAsyncClone() )
        pStream->Write( "const " );
    pStream->Write( "CInterfaceStubVtbl _" );
    pStream->Write( pszInterfaceName );
    pStream->Write( "StubVtbl =" );
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //Write the IID
    pStream->NewLine();
    pStream->Write( "&IID_" );
    pStream->Write( pszInterfaceName );
    pStream->Write( "," );

    //
    // Interpreter server info fits in the middle here.
    //
    pStream->NewLine();

        pStream->Write( '&' );
        pStream->Write( pszInterfaceName );
        pStream->Write( SERVER_INFO_VAR_NAME );
    pStream->Write( ',' );

    //Write the count
    pStream->NewLine();
    pStream->WriteNumber( "%d", count );
    pStream->Write(',');

    //Write the pointer to dispatch table.
    pStream->NewLine();
    if ( fPureInterpreted )
        pStream->Write( "0, /* pure interpreted */" );
    else
        {
        pStream->Write( '&' );
        pStream->Write( pszInterfaceName );
        pStream->Write( "_table[-3]," );
        }

    //initialize the vtable
    pStream->NewLine();
    if ( ( ( node_interface* ) GetType() )->IsAsyncClone() )
        {
        if ( fDelegates )
            pStream->Write("CStdAsyncStubBuffer_DELEGATING_METHODS");
        else
            pStream->Write("CStdAsyncStubBuffer_METHODS");
        }
    else
        {
        if ( fDelegates )
            pStream->Write("CStdStubBuffer_DELEGATING_METHODS");
        else
            pStream->Write("CStdStubBuffer_METHODS");
        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();

    return CG_OK;
}

CG_STATUS
CG_INHERITED_OBJECT_INTERFACE::GenProxy(
    CCB *   )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
/*
    ITERATOR            I;
    CG_PROC         *   pProc;

    // Initialize the CCB for this interface.
    InitializeCCB( pCCB );

    if( IsLocal() || !GetMembers( I ) )
        {
        return CG_OK;
        }

    //
    // Send the message to the children to emit code.
    //

    //
    // for all procedures in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pProc ) )
        {
        if ( pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
            {
            pProc->GenNdrFormat( pCCB );

            if ( pProc->NeedsServerThunk( pCCB, CGSIDE_SERVER ) )
                {
                CG_ITERATOR    Iterator;
                CG_PARAM *  pParam;
                CG_RETURN * pReturn;
                CG_NDR *    pChild;
                node_skl *  pType;  
                node_skl *  pActualType;
                PNAME       pName;

                pProc->GetMembers( Iterator );

                while ( ITERATOR_GETNEXT( Iterator, pParam ) )
                    {
                    pType = pParam->GetType();
                    pActualType = pType->GetChild();
                    pName = pType->GetSymName();

                    pChild = (CG_NDR *) pParam->GetChild();

                    if( pChild->IsArray() )
                        pActualType = MakePtrIDNode( pName, pActualType );
                    else
                        pActualType = MakeIDNode( pName, pActualType );

                    pParam->SetResource( new RESOURCE( pName, pActualType ) );
                    }

                if ( ( pReturn = pProc->GetReturnType() ) != 0 )
                    {
                    pReturn->SetResource( 
                        new RESOURCE( RETURN_VALUE_VAR_NAME, 
                                      MakeIDNode( RETURN_VALUE_VAR_NAME,
                                                  pReturn->GetType() ) ) );
                    }

                pProc->GenNdrThunkInterpretedServerStub( pCCB );
                }
            }
        }
*/
    return CG_OK;
}

CG_STATUS
CG_INHERITED_OBJECT_INTERFACE::OutputProxy(
    CCB *   )
{
    return CG_OK;
}


STATUS_T
CG_OBJECT_INTERFACE::PrintVtableEntries( CCB * pCCB  )
/*++

Routine Description:

    This routine prints the vtable entries for an interface.  


--*/
{
    CG_OBJECT_PROC      *   pC;
    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();

    if( pBaseCG )
        pBaseCG->PrintVtableEntries( pCCB );

    pC = (CG_OBJECT_PROC *) GetChild();
    while ( pC )
        {
        pC->PrintVtableEntry( pCCB );

        pC = (CG_OBJECT_PROC *) pC->GetSibling();
        }

    return STATUS_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenProlog(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the procedure prolog for the stub procedure.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    CG_OK   if all is well
    error   Otherwise

 Notes:

    Increment the stream indentation at the end of the prolog.
    Although we register params as param resources, we dont generate the
    procedure signature using the PrintType/Decl facility.

    We have added an explicit "this" pointer as the first parameter.
----------------------------------------------------------------------------*/
{

    ITERATOR        I;
    ITERATOR        T;
    ISTREAM *   pStream = pCCB->GetStream();
    BufferManager Buffer(10);


    // Output the bare procedure declaration
    pStream->NewLine();
    Out_ProxyFunctionPrototype(pCCB, 0);
    pStream->IndentDec();

    //
    // Write the opening brace on a new line.
    //

    pStream->WriteOnNewLine( "{" );

    pStream->NewLine();



    // Generate declarations for pre-allocated and analyser-determined locals.

    pCCB->GetListOfLocalResources( I );
    Out_ClientLocalVariables( pCCB, I );

    pCCB->GetListOfTransientResources( T );
    Out_ClientLocalVariables( pCCB, T );


        // If the rpc ss package is to be enabled, do so.
    // It would need to be enabled explicitely on the client side when
    // in non-osf mode, with the attribute on the operation AND
    //      - the routine is a callback, 
    //      - the routine is not a callback and the interface doesn't
    //        have the attribute (if it does, we optimized via stub descr.)

    if( pCCB->GetMode()  &&  MustInvokeRpcSSAllocate()
        &&
        (  GetCGID() == ID_CG_CALLBACK_PROC  ||
           GetCGID() != ID_CG_CALLBACK_PROC  &&
                            !pCCB->GetInterfaceCG()->IsAllRpcSS())
      )
        {
        Out_RpcSSSetClientToOsf( pCCB );
        }


    // Increment the indentation of the output stream. Reset at epilog time.

    Out_IndentInc( pCCB );

    //
    // Initialize all [out] unique and interface pointers to 0.
    //

    CG_ITERATOR     Iterator;
    CG_PARAM *      pParam;
    CG_NDR *        pNdr;
    CG_NDR  *       pTopPtr = 0;
    long            Derefs;
    expr_node *      pSizeof;

    GetMembers( Iterator );

    for ( ; ITERATOR_GETNEXT(Iterator, pParam); )
        {
        if ( pParam->IsParamIn() )
            continue;

        pNdr = (CG_NDR *) pParam->GetChild();

        if ( ! pNdr->IsPointer()  &&  ! pNdr->IsArray() )
            continue;

        Derefs = 0;

        //
        // Skip the ref pointer(s) to the pointee.
        //
        for ( ; 
              pNdr->IsPointer() && 
              ((CG_POINTER *)pNdr)->GetPtrType() == PTR_REF &&
              !pNdr->IsInterfacePointer();
              Derefs++, pNdr = (CG_NDR *) pNdr->GetChild() )
            {
            if( Derefs == 0 )
                pTopPtr = pNdr;
            }

        // No ref, no service.

        if ( ! Derefs  &&  ! pNdr->IsArray() )
            continue;

        // Ready to zero out.
        // Note, however, that in case where the ref checks are required,
        // we need to be careful and skip zeroing if ref pointers are null.
        // This is because we cannot raise exception immediately
        // as then some of the variables may not be zeroed out yet.

        //
        // Memset a struct, union or an array in case there are
        // embedded unique, full or interface pointers.
        // Same for user types of transmit_as, represent_as, user_marshal.
        //

        if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
            {
            pSizeof = new expr_sizeof( ((CG_TRANSMIT_AS*)pNdr)->GetPresentedType() );
            }
        else if ( pNdr->GetCGID() == ID_CG_USER_MARSHAL  &&
                    ((CG_USER_MARSHAL*)pNdr)->IsFromXmit() )
            {
            pSizeof = new expr_sizeof( ((CG_USER_MARSHAL*)pNdr)->GetRepAsType() );
            }
        else
            pSizeof = new expr_sizeof( pNdr->GetType() );


        if ( pNdr->IsStruct() || pNdr->IsUnion() || pNdr->IsArray() ||
             pNdr->IsXmitRepOrUserMarshal() || pNdr->IsInterfacePointer() )
            {
            if ( pCCB->MustCheckRef() )
                {
                Out_If( pCCB,
                        new expr_variable( pParam->GetType()->GetSymName() ));
                }

            expr_proc_call *   pCall;

            pStream->NewLine();

            pCall = new expr_proc_call( MIDL_MEMSET_RTN_NAME );

            pCall->SetParam( 
                    new expr_param( 
                    new expr_variable( pParam->GetType()->GetSymName() ) ) );

            pCall->SetParam(
                    new expr_param( 
                    new expr_variable( "0" ) ) );

            if ( pNdr->IsInterfacePointer() )
                {
                pSizeof = new expr_sizeof( pParam->GetChild()->GetType() );
                }

            if( pTopPtr && ((CG_POINTER *)pTopPtr)->IsQualifiedPointer() &&
                !(pTopPtr->GetCGID() == ID_CG_STRING_PTR ) )
                {
                _expr_node * pFinalExpr;
                CGPHASE Ph = pCCB->GetCodeGenPhase();
                pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

                pFinalExpr = ((CG_POINTER *)pTopPtr)->FinalSizeExpression( pCCB );
                pSizeof = new expr_op_binary( OP_STAR, pFinalExpr, pSizeof );
                pCCB->SetCodeGenPhase( Ph );
                }

            pCall->SetParam(
                    new expr_param( pSizeof ) );

            pCall->PrintCall( pStream, 0, 0 );

            if ( pCCB->MustCheckRef() )
                Out_Endif( pCCB );

            continue;
            }

        //
        // Are we at a non ref pointer now?
        //
        if ( ( pNdr->IsPointer() && 
                 (((CG_POINTER *)pNdr)->GetPtrType() != PTR_REF) ) ||
             pNdr->IsInterfacePointer() ) 
            {
            if ( pCCB->MustCheckRef() )
                {
                Out_If( pCCB,
                        new expr_variable( pParam->GetType()->GetSymName() ));
                }

            pStream->NewLine();

            for ( ; Derefs--; )
                pStream->Write( '*' );

            pStream->Write( pParam->GetResource()->GetResourceName() );
            pStream->Write( " = 0;" );

            if ( pCCB->MustCheckRef() )
                Out_Endif( pCCB );
            }
        }

    return CG_OK;
}



CG_STATUS
CG_OBJECT_PROC::C_GenBind(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to bind to server.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream         = pCCB->GetStream();
    ITERATOR            BindingParamList;
    expr_node      *   pExpr;
    expr_proc_call *   pProcCall;

    //
    // collect standard arguments to the init procedure.
    //
    
    // The implicit "this" pointer.  
    pExpr   = new RESOURCE( "This",
                            (node_skl *)0 );

    pExpr   = MakeExpressionOfCastToTypeName( "void *",
                                              pExpr );

    ITERATOR_INSERT( BindingParamList, pExpr );

    // The rpc message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_RPC_MESSAGE_VARIABLE );
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PRPC_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE);
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub descriptor structure variable. This is not allocated as
    // a resource explicitly.

    pExpr   = new RESOURCE( pCCB->GetInterfaceCG()->GetStubDescName(),
                            (node_skl *)0 );

    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_DESC_STRUCT_TYPE_NAME,
                                              pExpr );

    ITERATOR_INSERT( BindingParamList, pExpr );

    //
    // Proc num.
    //
    ITERATOR_INSERT( BindingParamList,
                     new expr_constant( (long) GetProcNum() ) );


    //Build the procedure call expression.
    pProcCall   = MakeProcCallOutOfParamExprList("NdrProxyInitialize", 0, BindingParamList);

    pStream->NewLine();
    pProcCall->PrintCall( pCCB->GetStream(), 0, 0 );
    pStream->NewLine();

    Out_SetOperationBits(pCCB, GetOperationBits());

    pStream->NewLine();


    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::GenGetBuffer(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the message buffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();
    CGSIDE Side = pCCB->GetCodeGenSide();

    pStream->NewLine();
    
    if(Side == CGSIDE_SERVER)
        pStream->Write("NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);");
    else
        pStream->Write("NdrProxyGetBuffer(This, &_StubMsg);");

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenSendReceive(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call IRpcChannelBuffer::SendReceive.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:
----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("NdrProxySendReceive(This, &_StubMsg);");
    pStream->NewLine();

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenFreeBuffer(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call IRpcChannelBuffer::FreeBuffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:
----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("NdrProxyFreeBuffer(This, &_StubMsg);");
    pStream->NewLine();

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::C_GenUnBind( CCB* )
{
    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::S_GenProlog(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side stub prolog.

 Arguments:

    pCCB    - A pointer to the code generation controller block.
    
 Return Value:

    CG_OK   if all is well
    error   Otherwise.
    
 Notes:

    Print out the signature, locals, the stub descriptor if needed and the
    adjust indent in anticipation of code.
----------------------------------------------------------------------------*/
{

    ITERATOR    LocalsList;
    ITERATOR    TransientList;
    expr_proc_call *   pCall;

    // Collect all the params and locals into lists ready to print.

    pCCB->GetListOfLocalResources( LocalsList );
    pCCB->GetListOfTransientResources( TransientList );

    // Print out the procedure signature and the local variables. This
    // procedure will also print out the stub descriptor.

    Out_ServerStubProlog( pCCB,
                               LocalsList,
                               TransientList
                             );

    //
    // Done for interpretation op.  No indent needed either.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return CG_OK;

    // Start a new indent for code.

    Out_IndentInc( pCCB );

    //
    // Call the NdrStubInitialize routine.
    //

    pCall = new expr_proc_call( "NdrStubInitialize" );

    pCall->SetParam( new expr_param (
                     new expr_variable( PRPC_MESSAGE_VAR_NAME ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( 
                            pCCB->GetInterfaceCG()->GetStubDescName() ) ) ) );

    pCall->SetParam( new expr_param (
                     new expr_variable( "_pRpcChannelBuffer" ) ) );

    pCall->PrintCall( pCCB->GetStream(), 0, 0 );

    // if the rpc ss package is to be enabled, do so.

    if( MustInvokeRpcSSAllocate() )
        {
        Out_RpcSSEnableAllocate( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_OBJECT_PROC::S_GenInitMarshall( CCB* )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side marshall init.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    return CG_OK;
}


void
CG_OBJECT_PROC::S_PreAllocateResources(
    ANALYSIS_INFO   *   pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Pre-allocate variables that are needed on the server side.

 Arguments:

    pAna            - A pointer to the analysis block.
    
 Return Value:
    
    None.

 Notes:

    1. The rpc message is a parameter resource allocated on the server side.
    2. All other local variables, are decided during/after the analysis phase.
    
----------------------------------------------------------------------------*/
{
    node_param  *   pInterfaceStubType  = new node_param();
    node_param  *   pChannelType    = new node_param();

    //pointer to interface stub

    pInterfaceStubType->SetSymName( "This" );
    pInterfaceStubType->SetBasicType( (node_skl *)
                                    new node_def ("IRpcStubBuffer *") );
    pInterfaceStubType->SetEdgeType( EDGE_USE );

    pAna->AddParamResource( "This",
                            (node_skl *) pInterfaceStubType
                          );

    //The pointer to IRpcChannelBuffer
    pChannelType->SetSymName( "_pRpcChannelBuffer" );
    pChannelType->SetBasicType( (node_skl *)
                                    new node_def ("IRpcChannelBuffer *") );
    pChannelType->SetEdgeType( EDGE_USE );

    pAna->AddParamResource( "_pRpcChannelBuffer",
                            (node_skl *) pChannelType
                          );

    CG_PROC::S_PreAllocateResources( pAna );

}



CG_STATUS
CG_OBJECT_PROC::S_GenCallManager(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    CG_OK   if all is well
    error   otherwise.

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    PNAME               pName;
    expr_proc_call  *   pProc;
    CG_PARAM        *   pParam;
    expr_node       *   pExpr;
    expr_node       *   pReturnExpr = 0;
    CG_RETURN       *   pRT;
    CSzBuffer Buffer;
    ISTREAM         *   pStream = pCCB->GetStream();

    if ( GetCallAsName() )
        {
        pName   = (PNAME ) new char[ strlen(GetCallAsName()) + 
                                     strlen( pCCB->GetInterfaceName() )
                                     + 7 ];
        strcpy( pName, pCCB->GetInterfaceName() );
        strcat( pName, "_" );
        strcat( pName, GetCallAsName() );
        strcat( pName, "_Stub" );
        }
    else
        pName   = (PNAME ) GetType()->GetSymName();

    pProc   = new expr_proc_call( pName );



    //implicit this pointer.
    Buffer.Append("(");
    Buffer.Append(pCCB->GetInterfaceName());
    Buffer.Append(" *) ((CStdStubBuffer *)This)->pvServerObject");

    pProc->SetParam( 
        new expr_param( 
        new expr_variable(Buffer)));


    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        if ( ( pExpr = pParam->GetFinalExpression() ) != 0 )
            {
            CG_NDR * pChild = (CG_NDR *)pParam->GetChild();

            //
            // We have to dereference arrays because of how they are defined
            // in the stub.
            //
            if ( pChild->IsArray() )
                pExpr = new expr_u_deref( pExpr );

            pProc->SetParam( new expr_param( pExpr ) );
            }
        }

    if ( ( pRT = GetReturnType() ) != 0 )
        {
        pReturnExpr = pRT->GetFinalExpression();
        }


    //Set flag before calling server object.
    pStream->NewLine();
    if ( ReturnsHRESULT() )
        pStream->WriteOnNewLine("*_pdwStubPhase = STUB_CALL_SERVER;");
    else
        pStream->WriteOnNewLine("*_pdwStubPhase = STUB_CALL_SERVER_NO_HRESULT;");
    pStream->NewLine();

    // stubs with call_as must call the user routine, instead of the
    // member function.  The user function must then call the member function

    if ( GetCallAsName() )
        Out_CallManager( pCCB, pProc, pReturnExpr, FALSE );
    else
        Out_CallMemberFunction( pCCB, pProc, pReturnExpr, FALSE );

    //Set flag before marshalling.
    pStream->NewLine();
    pStream->WriteOnNewLine("*_pdwStubPhase = STUB_MARSHAL;");

    return CG_OK;

}


void
CG_OBJECT_PROC::GenNdrInterpretedManagerCall(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the interpreted manager routine.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    none

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    PNAME               pName;
    expr_proc_call  *   pProc;
    CG_PARAM        *   pParam;
    expr_node       *   pReturnExpr = 0;
    CG_RETURN       *   pRT;
    CSzBuffer Buffer;
    ISTREAM         *   pStream = pCCB->GetStream();

    if ( GetCallAsName() )
        {
        pName   = (PNAME ) new char[ strlen(GetCallAsName()) + 
                                     strlen( pCCB->GetInterfaceName() )
                                     + 7 ];
        strcpy( pName, pCCB->GetInterfaceName() );
        strcat( pName, "_" );
        strcat( pName, GetCallAsName() );
        strcat( pName, "_Stub" );
        }
    else
        pName   = (PNAME ) GetType()->GetSymName();

    pProc   = new expr_proc_call( pName );



    //implicit this pointer.
    Buffer.Append("(");
    Buffer.Append(pCCB->GetInterfaceName());
    Buffer.Append(" *) pParamStruct->This");
    
    pProc->SetParam( 
        new expr_param( 
        new expr_variable(Buffer)));


    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        CG_NDR *        pNdr;
        char *          pTempName;
        expr_node *     pExpr;
        char *          pPlainName  = pParam->GetResource()->GetResourceName();

        pNdr = (CG_NDR *) pParam->GetChild();

        pTempName = new char[strlen(pPlainName) + strlen("pParamStruct->")+1 ];

        strcpy( pTempName, "pParamStruct->" );
        strcat( pTempName, pPlainName );

        pExpr = new expr_variable( pTempName );

        pProc->SetParam( new expr_param ( pExpr ) );
        }

    if( ( pRT = GetReturnType() ) != 0 && !HasAsyncHandle() )
        {
        pReturnExpr = new expr_variable( 
                            "pParamStruct->" RETURN_VALUE_VAR_NAME );
        }


    pStream->WriteOnNewLine("/* Call the server */");

    // stubs with call_as must call the user routine, instead of the
    // member function.  The user function must then call the member function
    if ( GetCallAsName() )
        Out_CallManager( pCCB, pProc, pReturnExpr, FALSE );
    else
        Out_CallMemberFunction( pCCB, pProc, pReturnExpr, TRUE );

    pStream->NewLine();

    return;

}

void
Out_CallCMacroFunction(
    CCB         *   pCCB,
    expr_proc_call *   pProcExpr)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pProcExpr   - A pointer to the complete procedure expression.
    pRet        - An optional pointer to ther return variable.

 Return Value:

    None.

 Notes:

    //call proxy
    (*(This)->lpVtbl -> LockServer)( This, fLock);

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

    // allocate the nodes on the stack
    expr_variable   VtblExpr( "(This)->lpVtbl" );
    expr_pointsto   VtblEntExpr( &VtblExpr, pProcExpr );
    // expr_op_unary    VtblEntExprCall( OP_UNARY_INDIRECTION, &VtblEntExpr ); 

    pStream->IndentInc();
    pStream->NewLine();

    VtblEntExpr.Print( pStream );

    pStream->IndentDec();


}


CG_STATUS
CG_OBJECT_PROC::GenCMacro(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the proxy routine.

 Arguments:
    
    pCCB    - A pointer to the code generation controller block.

 Return Value:
    
    CG_OK   if all is well
    error   otherwise.

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    node_param      *   pParam;
    ISTREAM         *   pStream = pCCB->GetStream();
    node_proc       *   pProc   = (node_proc *) GetType();

    if ( SupressHeader())
        return CG_OK;

    if ( GetCallAsName() )
        {
        node_call_as    *   pCallAs =   (node_call_as *)
                                            pProc->GetAttribute( ATTR_CALL_AS );

        pProc = (node_proc *) pCallAs->GetCallAsType();

        MIDL_ASSERT ( pProc );
        }

    // construct all these on the stack...
    MEM_ITER            MemIter( pProc );

    expr_proc_call     Proc( pProc->GetSymName() );
    expr_variable      ThisVar( "This" );
    expr_param         ThisParam( &ThisVar );

    Proc.SetParam( &ThisParam );


    while ( ( pParam = (node_param *) MemIter.GetNext() ) != 0 )
        {
        Proc.SetParam( new expr_param( 
                            new expr_variable( pParam->GetSymName() ) ) );
        }

    // print out the #define line
    pStream->NewLine();
    pStream->Write("#define ");
    pStream->Write( pCCB->GetInterfaceName() );
    pStream->Write( '_' );

    Proc.Print( pStream );

    pStream->Write( "\t\\" );

    Out_CallCMacroFunction( pCCB, &Proc );

    return CG_OK;

}

void
CG_PROXY_FILE::Out_ProxyBuffer(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a CStdProxyBuffer for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE *   pCG;
    ISTREAM *               pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("const CInterfaceProxyVtbl * _");
    pStream->Write(pFName);
    pStream->Write("_ProxyVtblList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        pStream->Write("( CInterfaceProxyVtbl *) &_");
        pStream->Write(pCG->GetSymName());
        pStream->Write("ProxyVtbl,");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

void
CG_PROXY_FILE::Out_StubBuffer(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a CStdStubBuffer for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE *   pCG;
    ISTREAM *               pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("const CInterfaceStubVtbl * _");
    pStream->Write(pFName);
    pStream->Write("_StubVtblList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        pStream->Write("( CInterfaceStubVtbl *) &_");
        pStream->Write( pCG->GetSymName() );
        pStream->Write("StubVtbl,");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

void
CG_PROXY_FILE::Out_InterfaceNamesList(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate an interface name list for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE *   pCG;
    ISTREAM *               pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("PCInterfaceName const _");
    pStream->Write(pFName);
    pStream->Write("_InterfaceNamesList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        pStream->Write('\"');
        pStream->Write(pCG->GetSymName());
        pStream->Write("\",");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

void
CG_PROXY_FILE::Out_AsyncInterfaceTable  (
                                        CCB*    pCCB,
                                        char*
                                        )
    {
    ITERATOR&               I = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE*    pCG;
    ISTREAM*                pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("static const IID * _AsyncInterfaceTable[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        if ( ((node_interface*)pCG->GetType())->GetAsyncInterface() == 0 )
            {
            if ( ((node_interface*)pCG->GetType())->IsAsyncClone() )
                {
                pStream->Write( "(IID*) -1" );
                }
            else
                {
                pStream->Write( "(IID*) 0" );
                }
            }
        else
            {
            pStream->Write( "(IID*) &IID_" );
            pStream->Write(((node_interface*)pCG->GetType())->GetAsyncInterface()->GetSymName());
            }
        pStream->Write(",");
        }
    pStream->NewLine();
    pStream->Write( "(IID*) 0" );
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
    }

void
CG_PROXY_FILE::Out_BaseIntfsList(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a base interface list for the [object] interfaces defined
    in the IDL file that need delegation

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR                &   I       = GetImplementedInterfacesList();
    CG_OBJECT_INTERFACE     *   pCG;
    CG_OBJECT_INTERFACE     *   pBaseCG;
    ISTREAM *                   pStream = pCCB->GetStream();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        
        // if we needed delegation, add it to the list
        if ( ( (pBaseCG = pCG->GetDelegatedInterface() ) != 0 ) || pCG->HasForcedDelegation())
            {
            fDllDataDelegating = TRUE;
            break;
            }
        }

    ITERATOR_INIT( I );

    // if there is no delegating, we don't need this table
    if ( !fDllDataDelegating )
        return;

    pStream->NewLine();
    pStream->Write("const IID *  _");
    pStream->Write(pFName);
    pStream->Write("_BaseIIDList[] = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //list of interface proxies.
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pStream->NewLine();
        
        // if we needed delegation, add it to the list
        if ( ( pBaseCG = pCG->GetDelegatedInterface() ) != 0 )
            {
            fDllDataDelegating = TRUE;
            pStream->Write("&IID_");
            pStream->Write( pBaseCG->GetSymName() );
            pStream->Write(',');
            }
        else if ( pCG->HasForcedDelegation() )
            {
            fDllDataDelegating = TRUE;
            pStream->Write("&IID_");
            pStream->Write( pCG->GetBaseInterfaceCG()->GetSymName() );
            pStream->Write(',');
            pStream->Write("   /* forced */");
            }
        else
            pStream->Write("0,");
        }
    pStream->NewLine();
    pStream->Write('0');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

inline 
unsigned char
log2( unsigned long ulVal )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Compute the log base 2 (rounded down to integral) of a number
    Returns 0 for 0 or 1

 Arguments:
    
    ulVal        - the value to check on.

 Notes:
    uses binary search to find the highest set bit

    to find the smallest power of 2 >= a number, use 1 << log2( 2n-1 )

----------------------------------------------------------------------------*/
{
    unsigned char   result = 0;

    if ( ( ulVal >>16 ) > 0 )
        {
        ulVal >>= 16;
        result = 16;
        }

    if ( ( ulVal >>8 ) > 0 )
        {
        ulVal >>= 8;
        result += 8;
        }

    if ( ( ulVal >>4 ) > 0 )
        {
        ulVal >>= 4;
        result += 4;
        }

    if ( ( ulVal >>2 ) > 0 )
        {
        ulVal >>= 2;
        result += 2;
        }

    if ( ulVal > 1 )
        {
        result++;
        }

    return result;
}

void
CG_PROXY_FILE::Out_InfoSearchRoutine(
    CCB *pCCB,
    char * pFName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a search function for the interfaces defined in this proxy file

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR                &   I       = GetImplementedInterfacesList();
    ISTREAM *        pStream    = pCCB->GetStream();
    unsigned long    ListSize = I.GetCount();
    CSzBuffer        CheckIIDName;
    unsigned long    CurIndex;

    
    CheckIIDName.Append("_");
    CheckIIDName.Append( pFName );
    CheckIIDName.Append( "_CHECK_IID" );

    pStream->NewLine(2);
    pStream->Write( "#define " );
    pStream->Write( CheckIIDName );
    pStream->Write( "(n)\tIID_GENERIC_CHECK_IID( _");
    pStream->Write( pFName );
    pStream->Write( ", pIID, n)");


    pStream->NewLine( 2 );
    pStream->Write( "int __stdcall _" );
    pStream->Write( pFName );
    pStream->Write( "_IID_Lookup( const IID * pIID, int * pIndex )" );
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    if ( ListSize == 0 )
        {
        pStream->Write( "return 0;" );
        }
    else if ( ListSize < 2 )
        {

        expr_variable       SetValue( "*pIndex" );

        expr_param          IndexParam( NULL );
        expr_proc_call      CheckIIDExpr( CheckIIDName );

        CheckIIDExpr.SetParam( &IndexParam );

        expr_u_not          TopExpr( &CheckIIDExpr );

        for ( CurIndex = 0; CurIndex < ListSize; CurIndex++ )
            {
            expr_constant       IndexNode( CurIndex );

            IndexParam.SetLeft( &IndexNode );

            Out_If( pCCB, &TopExpr );
            Out_Assign( pCCB, &SetValue, &IndexNode );
            pStream->NewLine();
            pStream->Write( "return 1;" );
            Out_Endif( pCCB );
            }
        
        pStream->NewLine(2);
        pStream->Write( "return 0;" );
        }
    else
        {
        unsigned long       curStep = 1 << log2( ListSize - 1 );

        pStream->Write( "IID_BS_LOOKUP_SETUP" );
        pStream->NewLine(2);
        
        pStream->Write( "IID_BS_LOOKUP_INITIAL_TEST( _" );
        pStream->Write( pFName );
        pStream->Write( ", " );
        pStream->WriteNumber( "%d", ListSize );
        pStream->Write( ", " );
        pStream->WriteNumber( "%d", curStep );
        pStream->Write( " )" );
        pStream->NewLine();

        for ( curStep >>= 1 ; curStep > 0 ; curStep >>= 1 )
            {
            pStream->Write( "IID_BS_LOOKUP_NEXT_TEST( _" );
            pStream->Write( pFName );
            pStream->Write( ", " );
            pStream->WriteNumber( "%d", curStep );
            pStream->Write( " )" );
            pStream->NewLine();
            }
        
        pStream->Write( "IID_BS_LOOKUP_RETURN_RESULT( _" );
        pStream->Write( pFName );
        pStream->Write( ", " );
        pStream->WriteNumber( "%d", ListSize );
        pStream->Write( ", *pIndex )" );
        pStream->NewLine();

        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

}


void
CG_PROXY_FILE::Out_ProxyFileInfo(
    CCB *pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a ProxyFileInfo structure for the [object] interfaces defined
    in the IDL file.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR        &   I       = GetImplementedInterfacesList();
    char                BaseName[ _MAX_FNAME ];
    char                Name[ _MAX_FNAME ];
    ISTREAM *           pStream = pCCB->GetStream();
    unsigned long       count   = 0;

    //Get the IDL file name.
    pCommand->GetInputFileNameComponents(NULL, NULL, BaseName, NULL );
    NormalizeString( BaseName, Name);

    //////////////////////////////////////////
    // put out the ancilliary data structures    
    Out_ProxyBuffer(pCCB, Name );
    Out_StubBuffer(pCCB, Name );
    Out_InterfaceNamesList(pCCB, Name );
    Out_BaseIntfsList(pCCB, Name);
    Out_InfoSearchRoutine( pCCB, Name );
    // AsyncIFTable
    if ( pCommand->GetNdrVersionControl().HasAsyncUUID() )
        {
        Out_AsyncInterfaceTable( pCCB, Name );
        }

    //////////////////////////////////////////
    // put out the ProxyFileInfo struct

    //list of interface proxies.
    count = ITERATOR_GETCOUNT( I );

    pStream->NewLine();
    pStream->Write("const ExtendedProxyFileInfo ");
    pStream->Write(Name);
    pStream->Write("_ProxyFileInfo = ");
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();

    //pointer to the proxy buffer
    pStream->NewLine();
    pStream->Write("(PCInterfaceProxyVtblList *) & _");
    pStream->Write(Name);
    pStream->Write("_ProxyVtblList,");


    //pointer to the stub buffer
    pStream->NewLine();
    pStream->Write("(PCInterfaceStubVtblList *) & _");
    pStream->Write(Name);
    pStream->Write("_StubVtblList,");

    //pointer to the interface names list
    pStream->NewLine();
    pStream->Write("(const PCInterfaceName * ) & _");
    pStream->Write(Name);
    pStream->Write("_InterfaceNamesList,");

    //pointer to the base iids list
    pStream->NewLine();
    // no table if no delegation
    if ( fDllDataDelegating )
        {
        pStream->Write("(const IID ** ) & _");
        pStream->Write(Name);
        pStream->Write("_BaseIIDList,");
        }
    else
        {
        pStream->Write( "0, // no delegation" );
        }

    // IID lookup routine
    pStream->NewLine();
    pStream->Write( "& _" );
    pStream->Write( Name );
    pStream->Write( "_IID_Lookup, ");

    // table size
    pStream->NewLine();
    pStream->WriteNumber( "%d", count );
    pStream->Write( ',' );
    pStream->NewLine();

    // table version
    unsigned short uTableVer = 1;
    if ( pCommand->GetNdrVersionControl().HasStublessProxies() )
        {
        uTableVer = 2;
        }
    if ( pCommand->GetNdrVersionControl().HasAsyncUUID() )
        {
        uTableVer |= 4;
        }
    pStream->WriteNumber( "%d", uTableVer );
    pStream->Write( ',' );
    pStream->NewLine();

    // AsyncIFTable
    if ( pCommand->GetNdrVersionControl().HasAsyncUUID() )
        {
        pStream->Write( "(const IID**) &_AsyncInterfaceTable[0],");
        }
    else
        {
        pStream->Write( "0,");
        }
    pStream->Write( " /* table of [async_uuid] interfaces */" );

    pStream->NewLine();
    pStream->Write( "0, /* Filler1 */" );
    pStream->NewLine();
    pStream->Write( "0, /* Filler2 */" );
    pStream->NewLine();
    pStream->Write( "0  /* Filler3 */" );

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  String constants for the DllData file

----------------------------------------------------------------------------*/

#define DLLDATA_LIST_START  "/* Start of list */\n"
#define DLLDATA_LIST_END    "/* End of list */\n"

#define DLLDATA_HEADER_COMMENT  \
    "/*********************************************************\n"  \
    "   DllData file -- generated by MIDL compiler \n\n"    \
    "        DO NOT ALTER THIS FILE\n\n"    \
    "   This file is regenerated by MIDL on every IDL file compile.\n\n"    \
    "   To completely reconstruct this file, delete it and rerun MIDL\n"    \
    "   on all the IDL files in this DLL, specifying this file for the\n"   \
    "   /dlldata command line option\n\n"   \
    "*********************************************************/\n\n"

#define DLLDATA_HAS_DELEGATION  "#define PROXY_DELEGATION\n"
    
#define DLLDATA_HEADER_INCLUDES     \
    "\n#include <rpcproxy.h>\n\n" \
    "#ifdef __cplusplus\n"  \
    "extern \"C\"   {\n" \
    "#endif\n"  \
    "\n"

#define DLLDATA_EXTERN_CALL "EXTERN_PROXY_FILE( %s )\n"
#define DLLDATA_REFERENCE   "  REFERENCE_PROXY_FILE( %s ),\n"
#define DLLDATA_START       "\n\nPROXYFILE_LIST_START\n" DLLDATA_LIST_START
#define DLLDATA_END         DLLDATA_LIST_END "PROXYFILE_LIST_END\n"

#define DLLDATA_TRAILER     \
    "\n\nDLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )\n"   \
    "\n"    \
    "#ifdef __cplusplus\n"  \
    "}  /*extern \"C\" */\n" \
    "#endif\n"  \
    "\n/* end of generated dlldata file */\n"

void
DllDataParse(
    FILE * pDllData,
    STRING_DICT & Dict )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Parse the "dlldata" file, extracting info on all the included files.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    const char *    pStart  = DLLDATA_LIST_START;
    const char *    pEnd    = DLLDATA_LIST_END;
    const char *    pDelegating = DLLDATA_HAS_DELEGATION;

    char Input[100];

    // skip everything up to (and including) pStart
    while ( !feof( pDllData ) )
        {
        if ( !fgets(    Input, 100, pDllData ) )
            break;
        if ( !strcmp( Input, pDelegating ) )
            {
            fDllDataDelegating = TRUE;
            continue;
            }
        if ( !strcmp( Input, pStart ) )
            break;
        }

    // parse list (looking for pEnd)
    while ( !feof( pDllData ) &&
             fgets( Input, 100, pDllData ) &&
             strcmp( Input, pEnd ) )
        {
        char    *   pOpenParen = strchr( Input, '(' );
        char    *   pCloseParen = strchr( Input, ')' );
        char    *   pSave;

        if ( !pOpenParen || !pCloseParen )
            {
            // formatting error on this line
            continue;
            }

        // chop off the close paren, and skip the open paren
        *(pCloseParen--) = '\0';
        pOpenParen++;
        // delete leading and trailing spaces
        while ( isspace( *pOpenParen ) )
            pOpenParen++;
        while ( isspace( *pCloseParen ) )
            *(pCloseParen--) = '\0';
        pSave = new char[ strlen( pOpenParen ) + 1 ];
        
        strcpy( pSave, pOpenParen );

        // add file name to dictionary
        Dict.Dict_Insert( pSave );
        }

}

void
DllDataEmit(
    FILE * pDllData,
    STRING_DICT & Dict )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit a new "dlldata" file, including info on all the included files.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    Dict_Status     Status;
    char    *       pCur;
    char            Normalized[ _MAX_FNAME ];
    BOOL            fFirst = TRUE;

    // emit header

    fputs( DLLDATA_HEADER_COMMENT, pDllData );

    if ( fDllDataDelegating )
        fputs( DLLDATA_HAS_DELEGATION, pDllData );

    // rpcproxy.h version guard
    // do not generate the version guard in dlldata.c for now because
    // MIDL does not regenerate the file. It adds to the existing
    // dlldata.c This causes problems when the old compiler has
    // generated the existing dlldata.c and vice-versa.
    /*
    fputs( "\n\n", pDllData  );
    char sz[192];
    fputs( GetRpcProxyHVersionGuard( sz ), pDllData  );
    fputs( "\n", pDllData  );
    */

    fputs( DLLDATA_HEADER_INCLUDES, pDllData );

    // emit extern definitions
    Status = Dict.Dict_Init();

    while( SUCCESS == Status )
        {
        pCur    = (char *) Dict.Dict_Curr_Item();
        NormalizeString( pCur, Normalized ); 
        fprintf( pDllData, DLLDATA_EXTERN_CALL, Normalized );
        Status = Dict.Dict_Next( (pUserType)pCur );
        }

    // emit header for type

    fputs( DLLDATA_START, pDllData );

    // emit extern references, adding comma on all but the first
    Status = Dict.Dict_Init();

    while( SUCCESS == Status )
        {
        pCur    = (char *) Dict.Dict_Curr_Item();
        NormalizeString( pCur, Normalized );
        fprintf( pDllData,
                 DLLDATA_REFERENCE, 
                 Normalized );
        fFirst = FALSE;
        Status = Dict.Dict_Next( (pUserType)pCur );
        }

    // emit trailer for type

    fputs( DLLDATA_END, pDllData );

    // emit trailer

    fputs( DLLDATA_TRAILER, pDllData );
}




void                        
CG_PROXY_FILE::UpdateDLLDataFile( CCB* )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Update the "dlldata" file, adding info for this file if needed.

    If no changes at all are required, leave the file untouched.

 Arguments:
    
    pCCB        - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    char        *   pszDllDataName = pCommand->GetDllDataFName();
    FILE        *   pDllData;
    STRING_DICT     ProxyFileList;
    char            BaseName[ _MAX_FNAME ];
    char            Name[ _MAX_FNAME ];

    // Use sopen to make sure there always is a file to process.
    // (fsopen with "r+" requires an existing file).

    int DllDataHandle = _sopen( pszDllDataName,
                                (_O_CREAT | _O_RDWR | _O_TEXT),
                                _SH_DENYRW,
                                (_S_IREAD | _S_IWRITE ) );

    // if the file exists already and/or is busy, it's ok.

    if ( DllDataHandle == -1  &&
         (errno != EEXIST  &&  errno != EACCES) )
        {
        // unexpected error
        RpcError((char *)NULL, 0, INPUT_OPEN, pszDllDataName );
        return;
        }

    if ( DllDataHandle != -1 )
        {
        _close(DllDataHandle);
        }

    // Attempt to open the file for reading and writing.
    // Because we can have a race condition when updating this file,
    // we try several times before quitting.

    for ( int i = 0;
          (i < DLLDATA_OPEN_ATTEMPT_MAX)  &&
          ( ( pDllData = _fsopen( pszDllDataName, "r+t", _SH_DENYRW ) ) == 0 );
          i++ )
        {
        printf("waiting for %s ...\n", pszDllDataName);
        MidlSleep(1);
        }

    if ( !pDllData )
        {
        RpcError((char *)NULL, 0, INPUT_OPEN, pszDllDataName );
        return;
        }

    //Get the IDL file name.
    pCommand->GetInputFileNameComponents(NULL, NULL, BaseName, NULL );
    NormalizeString( BaseName, Name );

    // If file is empty, the following is a no op.
    // skip up to the proxyfileinfo stuff and read/make sorted list of files

    DllDataParse( pDllData, ProxyFileList );

    // insert our file name
    ProxyFileList.Dict_Insert( Name ); 
    
    // re-emit everything

    rewind( pDllData );
    DllDataEmit( pDllData, ProxyFileList );

    // close the file to give others a chance

    if ( fclose( pDllData ))
        {
        RpcError((char *)NULL, 0, ERROR_WRITING_FILE, pszDllDataName );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\dtable.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	dtable.cxx

 Abstract:

	Dispatch table class implementation.

 Notes:


 History:

 	Oct-01-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

void
DISPATCH_TABLE::RegisterProcedure(
	node_skl			*	pProc,
	DISPATCH_TABLE_FLAGS	Flags )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a procedure into the dispatch table.

 Arguments:

 	pProc		-	The procedure node to be registered.
 	Flags		-	Additional information flags.
	
 Return Value:
	
 	None.

 Notes:

    if the flags field indicates a pure interpreter procedure, then
    the node pointer is really a pointer to a name, and not a node_skl

----------------------------------------------------------------------------*/
{
	PNAME						pProcName;
	node_skl                *   pN          = pProc;
	DISPATCH_TABLE_ENTRY	*	pDEntry;

	pProcName = pProc->GetSymName();
	pN = pProc;

	//
	// Allocate a dispatch table entry.
	//

	pDEntry	= new DISPATCH_TABLE_ENTRY;

	pDEntry->pName	= pProcName;
	pDEntry->Flags	= Flags;
	pDEntry->pNode	= pN;

	AddElement( (IDICTELEMENT) pDEntry );

}

DISPATCH_TABLE::~DISPATCH_TABLE()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	The destructor.

 Arguments:
	
 	None.

 Return Value:
	
	NA.

 Notes:

----------------------------------------------------------------------------*/
{
	short						i		= 0;
	short						Count	= GetNumberOfElements();
	DISPATCH_TABLE_ENTRY	*	pDEntry;

	//
	// remove the dispatch table entries. The procedure name is NOT
	// owned by the dipatch table, DO NOT delete it. Just delete the
	// dispatch table entry.
	//

	for( i = 0; i < Count; ++i )
		{
		pDEntry	= (DISPATCH_TABLE_ENTRY *)GetElement( (IDICTKEY)i );
		delete pDEntry;
		}
	
}

unsigned short
DISPATCH_TABLE::GetProcList(
	ITERATOR&				DTableEntryList,
	DISPATCH_TABLE_FLAGS	Flags )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Return a list of all procedures which conform to the specified dispatch
 	table flags.

 Arguments:
	
	DTableEntryList	- A pre-allocated iterator for receiving the list of
                      dispatch table entries.
	Flags		    - flags which determine what entries will be picked up.

 Return Value:
	
	A count of the number of procedures in the list.

 Notes:

 	The flags field is a filter for the dispatch table entries. Only those
 	dispatch table entries which have conforming properties are returned in 
 	the list.
    There are 2 types of entries:
      normal (call with DTF_NONE) and interpreter (call with DTF_INTERPRETER).
    The way it works is that 
    - call with DTF_NONE        returns DTF_NONEs        or DTF_PICKLING_PROCs
    - call with DTF_INTERPRETER returns DTF_INTERPRETERs or DTF_PICKLING_PROCs

----------------------------------------------------------------------------*/
{

	short						ListCount,
								i,
								Count;

	DISPATCH_TABLE_ENTRY	*	pDEntry;

	for( ListCount = 0, i = 0, Count = GetNumberOfElements();
		 i < Count;
		 ++i
	   )
	   	{
	   	pDEntry	= (DISPATCH_TABLE_ENTRY *)GetElement( (IDICTKEY)i );
	   	if( (pDEntry->Flags & Flags ) == Flags )
	   		{
	   		ITERATOR_INSERT( DTableEntryList, pDEntry );
	   		ListCount++;
	   		}
	   }

	return ListCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\frmtreg.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    frmtreg.cxx

 Abstract:

    Registry for format string reuse.

 Notes:

     This file defines reuse registry for format string fragments which may
     be reused later. 

 History:

     Mar-14-1993        GregJen        Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *    include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/***********************************************************************
 * global data
 **********************************************************************/


FRMTREG_DICT::FRMTREG_DICT( FORMAT_STRING * pOurs)
        : Dictionary()
    {
    pOurFormatString = pOurs;
    }

SSIZE_T
FRMTREG_DICT::Compare( pUserType pL, pUserType pR )
    {

     FRMTREG_ENTRY *  pLeft  = (FRMTREG_ENTRY *) pL;
     FRMTREG_ENTRY *  pRight = (FRMTREG_ENTRY *) pR;

    // first, sort by string length

    int  Result = ( pLeft->EndOffset - pLeft->StartOffset ) -
                   ( pRight->EndOffset - pRight->StartOffset );

    if ( Result )
        return Result;

    long   LeftOffset   = pLeft->StartOffset;
    long   RightOffset  = pRight->StartOffset;

    unsigned char * pBuffer     = pOurFormatString->pBuffer;
    unsigned char * pBufferType = pOurFormatString->pBufferType;

    // the same format string is, of course identical
    if ( LeftOffset == RightOffset )
        return 0;

    // There is a tricky situation when the strings are apart by more than 32k.
    // In the proc format string there is no problem with that, we can optize.
    // With type format string, we optimize as this is our best bet for the
    // final accessability of fragments.

    // Sort by values of format characters

    while ( ( Result == 0 ) && ( LeftOffset < pLeft->EndOffset) )
        {

        if ( pBufferType[ LeftOffset ] != pBufferType[ RightOffset ] )
            {
            // Types don't match, force the result to be unequal.
            Result = pBufferType[ LeftOffset ] - pBufferType[ RightOffset ];
            continue;
            }

        switch ( pBufferType[ LeftOffset ] )
            {
            case FS_SHORT_TYPE_OFFSET:
                // This is a comparison for the absolute type offset.
                {
                    TypeOffsetDictElem  *pLeftTO, *pRightTO;
        
                    pLeftTO  = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( LeftOffset );
                    pRightTO = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( RightOffset );

                    Result = pLeftTO->TypeOffset - pRightTO->TypeOffset;

                    LeftOffset++; RightOffset++;
                }
                break;

            case FS_SHORT_OFFSET:
                // This is a comparison for the relative type offset.
                //
                {
                    TypeOffsetDictElem  *pLeftTO, *pRightTO;
        
                    pLeftTO  = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( LeftOffset );
                    pRightTO = pOurFormatString->TypeOffsetDict.
                                                   LookupOffset( RightOffset );

                    if ( ( pLeftTO->TypeOffset == 0 ) && 
                         ( pRightTO->TypeOffset == 0 ) )
                        Result = 0;
                    else
                        // compare absolute offsets
                        Result = ( LeftOffset + pLeftTO->TypeOffset ) -
                                 ( RightOffset + pRightTO->TypeOffset );
        
                    LeftOffset++; RightOffset++;
                }
                break;

            case FS_SHORT_STACK_OFFSET:
                // Compare stack offset - multiplatform issue.
                {
                    Result = *((short UNALIGNED *)(pBuffer + LeftOffset)) -
                             *((short UNALIGNED *)(pBuffer + RightOffset));
        
                    if ( Result == 0 )
                        {
                        BOOL f32bitServer = pCommand->Is32BitEnv();
        
                        if ( f32bitServer )
                            {
                            OffsetDictElem  *pLeftStackOffsets, *pRightStackOffsets;
        
                            pLeftStackOffsets  = pOurFormatString->OffsetDict.
                                                   LookupOffset( LeftOffset );
                            pRightStackOffsets = pOurFormatString->OffsetDict.
                                                   LookupOffset( RightOffset );
        
                            long Ilo = pLeftStackOffsets->X86Offset;
                            long Iro = pRightStackOffsets->X86Offset;
                            Result = Ilo - Iro;
                            }
                        }
        
                    LeftOffset++; RightOffset++;
                }
                break;

            case FS_PAD_MACRO:
            case FS_SIZE_MACRO:
            case FS_UNKNOWN_STACK_SIZE:
                // Can't compare those, so force the result to be unequal.
                //
                Result = LeftOffset - RightOffset;
                break;

            case FS_LONG:
                // Compare longs
                //
                Result = *((long UNALIGNED *)(pBuffer + LeftOffset)) -
                         *((long UNALIGNED *)(pBuffer + RightOffset));
        
                LeftOffset += 3; RightOffset += 3;
                break;

            case FS_SHORT:
            case FS_PARAM_FLAG_SHORT:
            case FS_MAGIC_UNION_SHORT:
            case FS_CORR_FLAG_SHORT:
                // Compare plain shorts.
                //
                Result = *((short UNALIGNED *)(pBuffer + LeftOffset)) -
                         *((short UNALIGNED *)(pBuffer + RightOffset));
        
                LeftOffset++; RightOffset++;
                break;

            case FS_FORMAT_CHARACTER:
            case FS_POINTER_FORMAT_CHARACTER:
            case FS_SMALL:
            case FS_SMALL_STACK_SIZE:
            case FS_OLD_PROC_FLAG_BYTE:
            case FS_Oi2_PROC_FLAG_BYTE:
            case FS_EXT_PROC_FLAG_BYTE:
            case FS_CORR_TYPE_BYTE:
            case FS_CONTEXT_HANDLE_FLAG_BYTE:
            default:
                // Compare bytes, format chars, bytes decorated for comments,
                //
                Result = pBuffer[ LeftOffset ] - pBuffer[ RightOffset ];
                break;
            }

        LeftOffset++; RightOffset++;
        }

    return Result;
    }


FRMTREG_ENTRY *
FRMTREG_DICT::IsRegistered(
    FRMTREG_ENTRY    *    pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Search for a type with the reuse registry.

 Arguments:

     pInfo    - A pointer to the type being registered.
    
 Return Value:

     The node that gets registered.
    
 Notes:

----------------------------------------------------------------------------*/
{
    Dict_Status    Status    = Dict_Find( pInfo );

    switch( Status )
        {
        case EMPTY_DICTIONARY:
        case ITEM_NOT_FOUND:
            return (FRMTREG_ENTRY *)0;
        default:
            return (FRMTREG_ENTRY *)Dict_Curr_Item();
        }
}

FRMTREG_ENTRY *
FRMTREG_DICT::Register(
    FRMTREG_ENTRY    *    pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Register a type with the dictionary.

 Arguments:
    
     pType    - A pointer to the type node.

 Return Value:

     The final inserted type.
    
 Notes:

----------------------------------------------------------------------------*/
{
        Dict_Insert( (pUserType) pInfo );
        return pInfo;
}

BOOL                
FRMTREG_DICT::GetReUseEntry( 
    FRMTREG_ENTRY * & pOut, 
    FRMTREG_ENTRY * pIn )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Register a type with the dictionary.

 Arguments:
    
     pRI      - A pointer to the returned FRMTREG_ENTRY block
     pNode    - A pointer to the type node.

 Return Value:

     True if the entry was already in the table,
     False if the entry is new.
    
 Notes:

----------------------------------------------------------------------------*/
{
    FRMTREG_ENTRY    *    pRealEntry;

    if ( ( pRealEntry = IsRegistered( pIn ) ) == 0 )
        {
        pRealEntry = new FRMTREG_ENTRY( pIn->StartOffset, pIn->EndOffset );
        Register( pRealEntry );
        pOut = pRealEntry;
        return FALSE;
        }

    pOut = pRealEntry;
    pOut->UseCount++;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\frmtstr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    frmtstr.hxx

 Abstract:


 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG          *   pCommand;

const char * pExprFormatCharNames[] = 
{
    ""
    ,"FC_EXPR_CONST32"
    ,"FC_EXPR_CONST64"
    ,"FC_EXPR_VAR"
    ,"FC_EXPR_OPER"
    ,"FC_EXPR_PAD"
};


const char * pFormatCharNames[] =
                {
                "",                         // FC_ZERO
                "FC_BYTE",
                "FC_CHAR",
                "FC_SMALL",
                "FC_USMALL",
                "FC_WCHAR",
                "FC_SHORT",
                "FC_USHORT",
                "FC_LONG",
                "FC_ULONG",
                "FC_FLOAT",
                "FC_HYPER",
                "FC_DOUBLE",

                "FC_ENUM16",
                "FC_ENUM32",
                "FC_IGNORE",
                "FC_ERROR_STATUS_T",

                "FC_RP",                    // 11
                "FC_UP",
                "FC_OP",
                "FC_FP",                    

                "FC_STRUCT",
                "FC_PSTRUCT",
                "FC_CSTRUCT",
                "FC_CPSTRUCT",
                "FC_CVSTRUCT",
                "FC_BOGUS_STRUCT",

                "FC_CARRAY",
                "FC_CVARRAY",
                "FC_SMFARRAY",
                "FC_LGFARRAY",
                "FC_SMVARRAY",
                "FC_LGVARRAY or FC_SPLIT",  // 20
                "FC_BOGUS_ARRAY",           

                "FC_C_CSTRING",
                "FC_C_BSTRING",
                "FC_C_SSTRING",
                "FC_C_WSTRING",
        
                "FC_CSTRING",
                "FC_BSTRING",
                "FC_SSTRING",
                "FC_WSTRING",               

                "FC_ENCAPSULATED_UNION",
                "FC_NON_ENCAPSULATED_UNION",

                "FC_BYTE_COUNT_POINTER",
    
                "FC_TRANSMIT_AS",
                "FC_REPRESENT_AS",

                "FC_IP",

                "FC_BIND_CONTEXT",          // 30
                "FC_BIND_GENERIC",
                "FC_BIND_PRIMITIVE",
                "FC_AUTO_HANDLE",
                "FC_CALLBACK_HANDLE",
                "FC_UNUSED1",
    
                "FC_POINTER",

                "FC_ALIGNM2",
                "FC_ALIGNM4",
                "FC_ALIGNM8",
                "FC_UNUSED2",
                "FC_UNUSED3",
                "FC_UNUSED4",           
        
                "FC_STRUCTPAD1",
                "FC_STRUCTPAD2",
                "FC_STRUCTPAD3",
                "FC_STRUCTPAD4",            // 40
                "FC_STRUCTPAD5",
                "FC_STRUCTPAD6",
                "FC_STRUCTPAD7",

                "FC_STRING_SIZED",
                "FC_UNUSED5",       

                "FC_NO_REPEAT",
                "FC_FIXED_REPEAT",
                "FC_VARIABLE_REPEAT",
                "FC_FIXED_OFFSET",
                "FC_VARIABLE_OFFSET",       
    
                "FC_PP",

                "FC_EMBEDDED_COMPLEX",

                "FC_IN_PARAM",
                "FC_IN_PARAM_BASETYPE",
                "FC_IN_PARAM_NO_FREE_INST",
                "FC_IN_OUT_PARAM",          // 50
                "FC_OUT_PARAM",
                "FC_RETURN_PARAM",          
                "FC_RETURN_PARAM_BASETYPE",

                "FC_DEREFERENCE",           // 54
                "FC_DIV_2",                 // 55
                "FC_MULT_2",                // 56
                "FC_ADD_1",                 // 57
                "FC_SUB_1",                 // 58
                "FC_CALLBACK",              // 59

                "FC_CONSTANT_IID",          // 5a

                "FC_END",                   // 5b
                "FC_PAD",                   // 5c

                "FC_EXPR",                  // 5d
                "FC_PARTIAL_IGNORE_PARAM",  // 5e, 
                "?",                        // 5f

                "?", "?", "?", "?", "?", "?", "?", "?",    // 60-67
                "?", "?", "?", "?", "?", "?", "?", "?",    // 68-6f

                "?", "?", "?", "?",         //  70-73
                "FC_SPLIT_DEREFERENCE",     // 74
                "FC_SPLIT_DIV_2",           // 75
                "FC_SPLIT_MULT_2",          // 76
                "FC_SPLIT_ADD_1",           // 77
                "FC_SPLIT_SUB_1",           // 78
                "FC_SPLIT_CALLBACK",        // 79
                "?", "?", "?", "?", "?", "?",  //  7a-7f

                "?", "?", "?", "?", "?", "?", "?", "?",    // 80-87
                "?", "?", "?", "?", "?", "?", "?", "?",    // 88-8f
                "?", "?", "?", "?", "?", "?", "?", "?",    // 90-97
                "?", "?", "?", "?", "?", "?", "?", "?",    // 98-9f
                "?", "?", "?", "?", "?", "?", "?", "?",    // a0-a7
                "?", "?", "?", "?", "?", "?", "?", "?",    // a8-af
            
                "?",                        // b0

                "FC_HARD_STRUCT",           

                "FC_TRANSMIT_AS_PTR",
                "FC_REPRESENT_AS_PTR",

                "FC_USER_MARSHAL",

                "FC_PIPE",

                "?",               // FC_BLKHOLE. obselete

                "FC_RANGE",                 // b7
                "FC_INT3264",               // b8
                "FC_UINT3264",              // b9

                // Post NT5.0

                "FC_CSARRAY",               // ba
                "FC_CS_TAG",                // bb

                "FC_STRUCTPADN",            // bc
                "FC_INT128",                // 0xbd
                "FC_UINT128",               // 0xbe
                "FC_FLOAT80",               // 0xbf
                "FC_FLOAT128",              // 0xc0
                "FC_BUFFER_ALIGN",          // 0xc1

                "FC_ENCAP_UNION",           // 0xc2
                
                // new 64bit array types
                "FC_FIX_ARRAY",             // 0xc3
                "FC_CONF_ARRAY",            // 0xc4
                "FC_VAR_ARRAY",             // 0xc5 
                "FC_CONFVAR_ARRAY",         // 0xc6 
                "FC_FIX_FORCED_BOGUS_ARRAY",// 0xc7  
                "FC_FIX_BOGUS_ARRAY",       // 0xc8 
                "FC_FORCED_BOGUS_ARRAY",    // 0xc9  

                "FC_CHAR_STRING",           // 0xca
                "FC_WCHAR_STRING",          // 0xcb
                "FC_STRUCT_STRING",         // 0xcc

                "FC_CONF_CHAR_STRING",      // 0xcd
                "FC_CONF_WCHAR_STRING",     // 0xce
                "FC_CONF_STRUCT_STRING",    // 0xcf

                // new structure types
                "FC_CONF_STRUCT",           // 0xd0
                "FC_CONF_PSTRUCT",          // 0xd1
                "FC_CONFVAR_STRUCT",        // 0xd2
                "FC_CONFVAR_PSTRUCT",       // 0xd3
                "FC_FORCED_BOGUS_STRUCT",   // 0xd4
                "FC_CONF_BOGUS_STRUCT",     // 0xd5
                "FC_FORCED_CONF_BOGUS_STRUCT",// 0xd7
                
                "FC_END_OF_UNIVERSE"        // 0xd8
                };


const char * pExprOpFormatCharNames[] = 
                {
                "",
                "OP_UNARY_PLUS",
                "OP_UNARY_MINUS",
                "OP_UNARY_NOT",
                "OP_UNARY_COMPLEMENT",
                "OP_UNARY_INDIRECTION",
                "OP_UNARY_CAST",
                "OP_UNARY_AND",
                "OP_UNARY_SIZEOF",
                "OP_UNARY_ALIGNOF",
                "OP_PRE_INCR",
                "OP_PRE_DECR",
                "OP_POST_INCR",
                "OP_POST_DECR",
                "OP_PLUS",
                "OP_MINUS",
                "OP_STAR",
                "OP_SLASH",
                "OP_MOD",
                "OP_LEFT_SHIFT",
                "OP_RIGHT_SHIFT",
                "OP_LESS",
                "OP_LESS_EQUAL",
                "OP_GREATER_EQUAL",
                "OP_GREATER",
                "OP_EQUAL",
                "OP_NOT_EQUAL",

                "OP_AND",
                "OP_OR",
                "OP_XOR",

                "OP_LOGICAL_AND",
                "OP_LOGICAL_OR",
                "OP_EXPRESSION",
                "",
                "",
                "", // function
                "", // param
                "", // pointsto
                "", // dot
                "", // index
                "", // comma
                "", // stmt
                "", // assign
                "OP_ASYNCSPLIT", // asyncsplit
                "OP_CORR_POINTER", // corr_pointer
                "OP_CORR_TOP_LEVEL", // corr_toplevel

                };

//
// This table is indexed by FORMAT_CHARACTER (see ndrtypes.h).
// To construct the correct name concatenate the name in this table with
// "Marshall", "Unmarshall", "BufferSize" etc.
//
char *      pNdrRoutineNames[] =
            {
            "",                             // FC_ZERO
            "NdrSimpleType",                // FC_BYTE
            "NdrSimpleType",                // FC_CHAR
            "NdrSimpleType",                // FC_SMALL
            "NdrSimpleType",                // FC_USMALL
            "NdrSimpleType",                // FC_WCHAR
            "NdrSimpleType",                // FC_SHORT
            "NdrSimpleType",                // FC_USHORT
            "NdrSimpleType",                // FC_LONG
            "NdrSimpleType",                // FC_ULONG
            "NdrSimpleType",                // FC_FLOAT
            "NdrSimpleType",                // FC_HYPER
            "NdrSimpleType",                // FC_DOUBLE

            "NdrSimpleType",                // FC_ENUM16
            "NdrSimpleType",                // FC_ENUM32
            "NdrSimpleType",                // FC_IGNORE
            "NdrSimpleType",                // FC_ERROR_STATUS_T

            "NdrPointer",                   // FC_RP
            "NdrPointer",                   // FC_UP
            "NdrPointer",                   // FC_OP
            "NdrPointer",                   // FC_FP

            "NdrSimpleStruct",              // FC_STRUCT
            "NdrSimpleStruct",              // FC_PSTRUCT
            "NdrConformantStruct",          // FC_CSTRUCT
            "NdrConformantStruct",          // FC_CPSTRUCT
            "NdrConformantVaryingStruct",   // FC_CVSTRUCT

            "NdrComplexStruct",             // FC_BOGUS_STRUCT

            "NdrConformantArray",           // FC_CARRAY
            "NdrConformantVaryingArray",    // FC_CVARRAY
            "NdrFixedArray",                // FC_SMFARRAY
            "NdrFixedArray",                // FC_LGFARRAY
            "NdrVaryingArray",              // FC_SMVARRAY
            "NdrVaryingArray",              // FC_LGVARRAY

            "NdrComplexArray",              // FC_BOGUS_ARRAY

            "NdrConformantString",          // FC_C_CSTRING
            "NdrConformantString",          // FC_C_BSTRING
            "NdrConformantString",          // FC_C_SSTRING
            "NdrConformantString",          // FC_C_WSTRING

            "NdrNonConformantString",       // FC_CSTRING
            "NdrNonConformantString",       // FC_BSTRING
            "NdrNonConformantString",       // FC_SSTRING
            "NdrNonConformantString",       // FC_WSTRING
        
            "NdrEncapsulatedUnion",         // FC_ENCAPSULATED_UNION
            "NdrNonEncapsulatedUnion",      // FC_NON_ENCAPSULATED_UNION

            "NdrByteCountPointer",          // FC_BYTE_COUNT_POINTER

            "NdrXmitOrRepAs",               // FC_TRANSMIT_AS
            "NdrXmitOrRepAs",               // FC_REPRESENT_AS

            "NdrInterfacePointer",          // FC_INTERFACE_POINTER

            "NdrContextHandle",             // FC_BIND_CONTEXT
            
            "?", "?", "?", "?", "?", "?", "?",         // 31-37
            "?", "?", "?", "?", "?", "?", "?", "?",    // 38-3f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 40-47
            "?", "?", "?", "?", "?", "?", "?", "?",    // 48-4f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 50-57

            "?", "?", "?",                             // 58-5a
            "?", "?",                        // FC_END & FC_PAD
            "?", "?", "?",                             // 5d-5f

            "?", "?", "?", "?", "?", "?", "?", "?",    // 60-67
            "?", "?", "?", "?", "?", "?", "?", "?",    // 68-6f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 70-77
            "?", "?", "?", "?", "?", "?", "?", "?",    // 78-7f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 80-87
            "?", "?", "?", "?", "?", "?", "?", "?",    // 88-8f
            "?", "?", "?", "?", "?", "?", "?", "?",    // 90-97
            "?", "?", "?", "?", "?", "?", "?", "?",    // 98-9f
            "?", "?", "?", "?", "?", "?", "?", "?",    // a0-a7
            "?", "?", "?", "?", "?", "?", "?", "?",    // a8-af

            "?",                                       // 0xb0

            "NdrHardStruct",                // FC_HARD_STRUCT

            "NdrXmitOrRepAs",               // FC_TRANSMIT_AS_PTR
            "NdrXmitOrRepAs",               // FC_REPRESENT_AS_PTR

            "NdrUserMarshal",               // FC_USER_MARSHAL

            "NdrPipe",                      // FC_PIPE

            0,                              // FC_BLKHOLE

            0,                              // FC_RANGE
            "NdrSimpleType",                // FC_INT3264
            "NdrSimpleType",                // FC_UINT3264

            "NdrCsArray",                   // FC_CSARRAY
            "NdrCsTag",                     // FC_CS_TAG

            0
            };

// ============================================================================
//
//   FORMAT_STRING class, general comments on fragment optimization.
//
//   There are 3 type of offsets that matter a lot when format string fragments
//   are optimized. These are absolute type offsets, relative type offsets and
//   stack (or field) offsets.
//
//   - Absolute type offsets are offsets from the proc format string to type 
//   format string. For 32b implementation they are limited to ushort32 range.
//   An absolute type offset indicates a type of a parameter.
//   Note that there is only one absolute type offset for a parameter regardless
//   of the platform.
//
//   - Relative type offsets are offsets within the type format string. 
//   For 32b implementation they are limited to short32 range.
//   A relative type offset indicates a type of a component for a compund type.
//   Note that there is only one relative type offset for a field or element 
//   regardless of the platform.
//
//   - Stack offset is a stack offset to a parameter within a proc stack or 
//   a field offset to a field within a struct.
//   For a 32b implementation stack offsets are limited to a short32 range. This
//   is because some of these offsets are relative to a current position within
//   a struct or union. They have been clampd together because of correlation
//   descriptors may have stack or field offsets.
//   Proper stack offsets actually come in a ushort and usmall range variaty. 
//   Proper field offsets come in as shorts. 
//   For a given position in the format string, there is a set of stack offsets
//   as in general a x86 stack offset is different from other platform offsets
//   and a field offset may be different as well.
//   
//   Proc format string uses only absolute type offsets and stack offsets.
//

// the constructor
FORMAT_STRING::FORMAT_STRING()
{
    // Allocate the buffer and align it on a short boundary.
    pBuffer = (unsigned char *) new short[ DEFAULT_FORMAT_STRING_SIZE / 2 ];

    // Allocate the cousin buffer type array.  This does not need to
    // be aligned.
    pBufferType = new unsigned char[ DEFAULT_FORMAT_STRING_SIZE ];

    memset( pBuffer,     0,                   DEFAULT_FORMAT_STRING_SIZE );
    memset( pBufferType, FS_FORMAT_CHARACTER, DEFAULT_FORMAT_STRING_SIZE );

    BufferSize = DEFAULT_FORMAT_STRING_SIZE;
    CurrentOffset = 0;
    LastOffset = 0;
    pReuseDict = new FRMTREG_DICT( this );
}

void
FORMAT_STRING::CheckSize()
/*++

Routine Description :
    
    Reallocates a new format string buffer if the current buffer is within
    4 bytes of overflowing.

Arguments :
    
    None.

 --*/
{
    //
    // Allocate a new buffer if we're within 4 bytes of
    // overflowing the current buffer.
    //
    if ( CurrentOffset + 3 > BufferSize )
        {
        unsigned char * pBufferNew;

        // double the Buffer size
        pBufferNew = (unsigned char *) new short[ BufferSize ];

        memcpy( pBufferNew,
                pBuffer,
                (unsigned int) BufferSize );
        memset( pBufferNew + BufferSize, 0, BufferSize );

        delete pBuffer;
        pBuffer = pBufferNew;

        // double the BufferType size
        pBufferNew = (unsigned char *) new short[ BufferSize ];

        memcpy( pBufferNew,
                pBufferType,
                (unsigned int) BufferSize );
        memset( pBufferNew + BufferSize, FS_FORMAT_CHARACTER, BufferSize );

        delete pBufferType;
        pBufferType = pBufferNew;
        
        BufferSize *= 2;
        }
}

//
// Push a short type-fmt-string offset at the current offset.
// This is used as the offset from a parameter into type format string.
// For 32b code, this needs to be a value within an unsigned short.
// We use a long value internally for better fragment optimization.
//
void    
FORMAT_STRING::PushShortTypeOffset( long s )
{
    CheckSize();

    if ( s < 0  ||  s > _UI16_MAX )
        {
//        CG_NDR * pNdr = pCCB->GetLastPlaceholderClass();
        CG_NDR * pNdr = 0;
        char *   pName = pNdr ? pNdr->GetSymName() 
                              : "";
        RpcError(NULL, 0, FORMAT_STRING_LIMITS, pName );
        exit( FORMAT_STRING_LIMITS );
        }

    pBufferType[CurrentOffset] = FS_SHORT_TYPE_OFFSET;
    pBufferType[CurrentOffset+1] = FS_SMALL;
    *((unsigned short UNALIGNED *)(pBuffer + CurrentOffset)) = (unsigned short)s;

    TypeOffsetDict.Insert( (long) CurrentOffset, s );

    IncrementOffset(2);
}

//
// Push a short offset at the current offset.
// This is the relative type offset within the type string.
// For 32b code, this needs to be a value within a signed short, eventually.
// We use a long value internally for better fragment optimization.
//
void    
FORMAT_STRING::PushShortOffset( long TypeOffset )
{
    CheckSize();

    // We don't check the range for the offset here for better optimization.

    pBufferType[ CurrentOffset     ] = FS_SHORT_OFFSET;
    pBufferType[ CurrentOffset + 1 ] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + CurrentOffset)) = (short)TypeOffset;

    TypeOffsetDict.Insert( (long) CurrentOffset, TypeOffset );

    IncrementOffset(2);
}

// This an auxilary method to handle relative offsets.
// It is used when we need to write out an offset temporarily and then fix it 
// later, for example in pointers, structs etc.
// 
void    
FORMAT_STRING::PushShortOffset( long TypeOffset, long Position )
{
    // We don't check the range for the offset here for better optimization.

    pBufferType[ Position     ] = FS_SHORT_OFFSET;
    pBufferType[ Position + 1 ] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + Position)) = (short)TypeOffset;

    TypeOffsetDict.Insert( Position, TypeOffset );
}


//
// Push a stack size or an absolute offset.
//
void
FORMAT_STRING::PushUShortStackOffsetOrSize( 
    long X86Offset )
{
    CheckSize();

    if ( X86Offset   < 0  ||  X86Offset   > _UI16_MAX )
        {
        //  Make it a warning with a name.

//        CG_NDR * pNdr = pCCB->GetLastPlaceholderClass();
        CG_NDR * pNdr = 0;
        char *   pName = pNdr ? pNdr->GetSymName() 
                              : "";
        RpcError(NULL, 0, STACK_SIZE_TOO_BIG, pName );
        exit( FORMAT_STRING_LIMITS );
        }

    pBufferType[CurrentOffset] = FS_SHORT_STACK_OFFSET;
    pBufferType[CurrentOffset+1] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + CurrentOffset)) = (short) X86Offset;

#if defined(RKK_FRAG_OPT)
        {
        printf("PushShortStackOffset CurrentOffset %d\n", CurrentOffset );
        int offLow = CurrentOffset - 10; if (offLow < 0) offLow = 0;
        int offHig = CurrentOffset + 10;
        printf("    off=%d ", offLow );
        for (int off = offLow; off < offHig; off++)
            printf("%02x ", pBuffer[ off ]);
        printf( "\n" );
        printf("    off=%d ", offLow );
        for (    off = offLow; off < offHig; off++)
            printf("%02x ", pBufferType[ off ]);
        printf( "\n" );
    }
#endif

    OffsetDict.Insert( (long) CurrentOffset, 
                       X86Offset );

    IncrementOffset(2);
}

//
// Push a stack offset. 
// Needs to be relative because of offsets in structs etc.
//
void
FORMAT_STRING::PushShortStackOffset( 
    long X86Offset )
{
    CheckSize();

    if ( X86Offset   < _I16_MIN  ||  X86Offset   > _I16_MAX )
        {
        //  Make it a warning with a name.

//        CG_NDR * pNdr = pCCB->GetLastPlaceholderClass();
        CG_NDR * pNdr = 0;
        char *   pName = pNdr ? pNdr->GetSymName() 
                              : "";
        RpcError(NULL, 0, FORMAT_STRING_LIMITS, pName );
        exit( FORMAT_STRING_LIMITS );
        }

    pBufferType[CurrentOffset] = FS_SHORT_STACK_OFFSET;
    pBufferType[CurrentOffset+1] = FS_SMALL;
    *((short UNALIGNED *)(pBuffer + CurrentOffset)) = (short) X86Offset;

#if defined(RKK_FRAG_OPT)
        {
        printf("PushShortStackOffset CurrentOffset %d\n", CurrentOffset );
        int offLow = CurrentOffset - 10; if (offLow < 0) offLow = 0;
        int offHig = CurrentOffset + 10;
        printf("    off=%d ", offLow );
        for (int off = offLow; off < offHig; off++)
            printf("%02x ", pBuffer[ off ]);
        printf( "\n" );
        printf("    off=%d ", offLow );
        for (    off = offLow; off < offHig; off++)
            printf("%02x ", pBufferType[ off ]);
        printf( "\n" );
    }
#endif

    OffsetDict.Insert( (long) CurrentOffset, 
                       X86Offset );

    IncrementOffset(2);
}

// =============================================================================
//
//  Helper routines writing comments about some tokens.
//

__inline void
Out_PointerFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    if ( *pFlags & FC_ALLOCATE_ALL_NODES )
        pStream->Write( " [all_nodes]");
    if ( *pFlags & FC_DONT_FREE )
        pStream->Write( " [dont_free]");
    if ( *pFlags & FC_ALLOCED_ON_STACK )
        pStream->Write( " [alloced_on_stack]");
    if ( *pFlags & FC_SIMPLE_POINTER )
        pStream->Write( " [simple_pointer]");
    if ( *pFlags & FC_POINTER_DEREF )
        pStream->Write( " [pointer_deref]");
}

__inline void
Out_OldProcFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    INTERPRETER_FLAGS * pOiFlags = (INTERPRETER_FLAGS *)pFlags;

    if ( pOiFlags->FullPtrUsed )
        pStream->Write( " full ptr,");
    if ( pOiFlags->RpcSsAllocUsed )
        pStream->Write( " DCE mem package,");
    if ( pOiFlags->ObjectProc )
        {
        pStream->Write( " object,");
        if ( pOiFlags->IgnoreObjectException )
            pStream->Write( " ignore obj exc,");
        if ( pOiFlags->HasCommOrFault )
            pStream->Write( " Oi2");
        }
    else
        {
        if ( pOiFlags->IgnoreObjectException )
            pStream->Write( " encode,");
        if ( pOiFlags->HasCommOrFault )
            pStream->Write( " comm or fault/decode");
        }
}

__inline void
Out_Oi2ProcFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    INTERPRETER_OPT_FLAGS * pOi2Flags = (INTERPRETER_OPT_FLAGS *)pFlags;

    if ( pOi2Flags->ServerMustSize )
        pStream->Write( " srv must size,");
    if ( pOi2Flags->ClientMustSize )
        pStream->Write( " clt must size,");
    if ( pOi2Flags->HasReturn )
        pStream->Write( " has return,");
    if ( pOi2Flags->HasPipes )
        pStream->Write( " has pipes,");
    if ( pOi2Flags->HasAsyncUuid )
        pStream->Write( " has async uuid,");
    if ( pOi2Flags->HasExtensions )
        pStream->Write( " has ext,");
    if ( pOi2Flags->HasAsyncHandle )
        pStream->Write( " has async handle");
}

__inline void
Out_ExtProcFlags(
    ISTREAM *           pStream,
    unsigned char *     pFlags
    )
{
    INTERPRETER_OPT_FLAGS2 * pExtFlags = (INTERPRETER_OPT_FLAGS2 *)pFlags;

    if ( pExtFlags->HasNewCorrDesc )
        pStream->Write( " new corr desc,");
    if ( pExtFlags->ClientCorrCheck )
        pStream->Write( " clt corr check,");
    if ( pExtFlags->ServerCorrCheck )
        pStream->Write( " srv corr check,");
    if ( pExtFlags->HasNotify )
        pStream->Write( " has notify");
    if ( pExtFlags->HasNotify2 )
        pStream->Write( " has notify_flag");
    if ( pExtFlags->HasComplexReturn )
        pStream->Write( " has complex return");
}

__inline void
Out_ParameterFlags(
    ISTREAM *           pStream,
    PARAM_ATTRIBUTES *  pParamAttr
    )
{
    char Buf[8];

    if ( pParamAttr->MustSize )
        pStream->Write( " must size,");
    if ( pParamAttr->MustFree )
        pStream->Write( " must free,");
    if ( pParamAttr->IsPipe )
        pStream->Write( " pipe,");
    if ( pParamAttr->IsIn )
        pStream->Write( " in,");
    if ( pParamAttr->IsOut )
        pStream->Write( " out,");
    if ( pParamAttr->IsReturn )
        pStream->Write( " return,");
    if ( pParamAttr->IsBasetype )
        pStream->Write( " base type,");
    if ( pParamAttr->IsByValue )
        pStream->Write( " by val,");
    if ( pParamAttr->IsSimpleRef )
        pStream->Write( " simple ref,");
    if ( pParamAttr->IsDontCallFreeInst )
        pStream->Write( " dont call free inst,");
    if ( pParamAttr->IsForceAllocate )
        pStream->Write( " force allocate," );
    if ( pParamAttr->SaveForAsyncFinish )
        pStream->Write( " split async,");
    if ( pParamAttr->ServerAllocSize )
        {
        pStream->Write( " srv alloc size=");
        pStream->Write( MIDL_ITOA( 8 * pParamAttr->ServerAllocSize, Buf, 10) );
        }
}

__inline void
Out_CorrelationType(
    ISTREAM *           pStream,
    unsigned char *     pCorrType
    )
{
    unsigned char   CorrType = *pCorrType;

    if ( CorrType & FC_NORMAL_CONFORMANCE )
        pStream->Write( " field, ");
    if ( CorrType & FC_POINTER_CONFORMANCE )
        pStream->Write( " field pointer, ");
    if ( CorrType & FC_TOP_LEVEL_CONFORMANCE )
        pStream->Write( " parameter, ");
    if ( CorrType & FC_TOP_LEVEL_MULTID_CONFORMANCE )
        pStream->Write( " multidim parameter, ");

    if ( CorrType & FC_CONSTANT_CONFORMANCE )
        {
        unsigned long    ConstVal;
                 char    Buf[12];

        pStream->Write( " constant, val=");
        // next three bytes: just a weird way of generating it
        ConstVal = (ulong) pCorrType[1] << 16;
        ConstVal |= *(unsigned short UNALIGNED *)( pCorrType + 2);
        pStream->Write( MIDL_ITOA( ConstVal, Buf, 10) );
        }
    else
        {
        pStream->Write( pFormatCharNames[ CorrType & 0xf ] );
        }
}

__inline void
Out_CorrelationFlags(
    ISTREAM *           pStream,
    unsigned char *     pNewCorrFlags
    )
{
    NDR_CORRELATION_FLAGS *  pCorrFlags = (NDR_CORRELATION_FLAGS *)pNewCorrFlags;

    if ( pCorrFlags->Early )
        pStream->Write( " early," );
    if ( pCorrFlags->Split )
        pStream->Write( " split," );
    if ( pCorrFlags->IsIidIs )
        pStream->Write( " iid_is," );
    if ( pCorrFlags->DontCheck )
        pStream->Write( " dont check" );
}

__inline void
Out_ContextHandleFlags(
    ISTREAM *           pStream,
    unsigned char *     pContextFlags
    )
{
    PNDR_CONTEXT_HANDLE_FLAGS   pFlags = (PNDR_CONTEXT_HANDLE_FLAGS)pContextFlags;

    if ( pFlags->IsViaPtr )
        pStream->Write( " via ptr," );
    if ( pFlags->IsIn )
        pStream->Write( " in," );
    if ( pFlags->IsOut )
        pStream->Write( " out," );
    if ( pFlags->IsReturn )
        pStream->Write( " ret," );
    if ( pFlags->IsStrict )
        pStream->Write( " strict," );
    if ( pFlags->NoSerialize )
        pStream->Write( " no serialize," );
    if ( pFlags->Serialize )
        pStream->Write( " serialize," );
    if ( pFlags->CannotBeNull)
        pStream->Write( " can't be null" );
}


__inline void
Out_SmallStackSize(
    ISTREAM *   pStream,
    long        StackSize,
    char *      pEnvComment
    )
{
    char    Buf[102];
    
    //
    // Non-Alpha stack size.
    //
    pStream->Write( "0x" );
    pStream->Write( MIDL_ITOA(StackSize, Buf, 16) );
    pStream->Write( ",\t\t/* ");
    pStream->Write( pEnvComment );
    pStream->Write( " stack size = ");
    pStream->Write( MIDL_ITOA(StackSize, Buf, 10) );
    pStream->Write( " */");

}

// The comment table is initialized in FORMAT_STRING::Output as appropriate 
// for a given environment { 64b, 32b, others }.
// The comments correspond to the ifdef situation described below.

static char *  Env64Comment = "ia64";
static char *  Env32Comment = "x86";
static char *  OtherEnvComment = "";


__inline void
Out_ShortStackOffset(
    ISTREAM *           pStream,
    OffsetDictElem *    pStackOffsets,
    char *              EnvComment
    )
{
    char    Buf[102];

    //
    // Emit the main (x86 or ia64) offset.
    //

    unsigned long  OffsetValue = pStackOffsets->X86Offset;

    pStream->Write( "NdrFcShort( 0x" );
    pStream->Write( MIDL_ITOA( OffsetValue, Buf, 16) );
    pStream->Write( " ),\t/* " );
    pStream->Write( EnvComment );
    pStream->Write( " Stack size/offset = " );
    pStream->Write( MIDL_ITOA( OffsetValue, Buf, 10) );
    pStream->Write( " */");
}


void
FORMAT_STRING::Output(
    ISTREAM *           pStream,
    char *              pTypeName,
    char *              pName,
    RepAsPadExprDict *  pPadDict,
    RepAsSizeDict    *  pSizeDict )
/*++

Routine Description :
    
    Outputs the format string structure.

Arguments :
    
    pStream             - Stream to output the format string to.

 --*/
{
    long                    Offset;
    long                    LastPrinted = 0;
    char                    Buf[102];
    BOOL                    InPP = FALSE;
    REP_AS_PAD_EXPR_DESC *  pPadExprDesc;
    REP_AS_SIZE_DESC     *  pSizeDesc;
    char *                  pComment;
    BOOL                    fLimitErr = FALSE;

    pStream->NewLine();
    pStream->Write( "static const " );
    pStream->Write( pTypeName );
    pStream->Write( ' ' );
    pStream->Write( pName );
    pStream->Write( " =");
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( "0," );
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();

    // Reset the pad and size macro dictionaries

    pPadExprDesc = pPadDict->GetFirst();
    pSizeDesc    = pSizeDict->GetFirst();

    pStream->IndentDec();
    pStream->IndentDec();
    pStream->IndentDec();

    BOOL f32 = pCommand->GetEnv() == ENV_WIN32;
    BOOL f64 = pCommand->GetEnv() == ENV_WIN64;

    char * EnvComment;

    if ( f32 )
        {
        EnvComment   = Env32Comment;
        }
    else if ( f64 )
        {
        EnvComment   = Env64Comment;
        }
    else
        {
        EnvComment   = OtherEnvComment;
        }


    for ( Offset = 0; Offset < (long)LastOffset; )
        {
        pStream->NewLine();

        pComment = CommentDict.GetComments( Offset );

        if ( pComment )
            pStream->Write( pComment );

        if ( ! (Offset % 2) && ( Offset != LastPrinted ) )
            {
            sprintf(Buf,"/* %2d */\t",Offset);
            LastPrinted = Offset;
            pStream->Write(Buf);
            }
        else
            {
            pStream->Write("\t\t\t");
            }

        switch ( pBufferType[Offset] )
            {
            case FS_FORMAT_CHARACTER :
                // Make the format string readable.
                switch ( pBuffer[Offset] )
                    {
                    case FC_IN_PARAM :
                    case FC_IN_OUT_PARAM :
                    case FC_PARTIAL_IGNORE_PARAM :
                    case FC_OUT_PARAM :
                    case FC_RETURN_PARAM :
                    case FC_STRUCT :
                    case FC_PSTRUCT :
                    case FC_CSTRUCT :
                    case FC_CPSTRUCT :
                    case FC_CVSTRUCT :
                    case FC_BOGUS_STRUCT :
                    case FC_NO_REPEAT :
                    case FC_FIXED_REPEAT :
                    case FC_VARIABLE_REPEAT :
                    case FC_CARRAY :
                    case FC_CVARRAY :
                    case FC_SMFARRAY :
                    case FC_LGFARRAY :
                    case FC_SMVARRAY :
                    case FC_LGVARRAY :
                    case FC_BOGUS_ARRAY :
                    case FC_C_CSTRING :
                    case FC_C_SSTRING :
                    case FC_C_WSTRING :
                    case FC_CSTRING :
                    case FC_SSTRING :
                    case FC_WSTRING :
                    case FC_ENCAPSULATED_UNION :
                    case FC_NON_ENCAPSULATED_UNION :
                    case FC_IP :
                        pStream->NewLine();
                        pStream->Write("\t\t\t");
                        break;

                    case FC_RP :
                    case FC_UP :
                    case FC_OP :
                    case FC_FP :
                        //
                        // If we're not in a pointer layout, and the previous
                        // format char was not a param/result char then print
                        // a new line.
                        //
                        if  ( ! InPP &&
                              ( Offset &&
                                pBuffer[Offset - 1] != FC_IN_PARAM &&
                                pBuffer[Offset - 1] != FC_IN_OUT_PARAM &&
                                pBuffer[Offset - 1] != FC_PARTIAL_IGNORE_PARAM &&
                                pBuffer[Offset - 1] != FC_OUT_PARAM &&
                                pBuffer[Offset - 1] != FC_IN_PARAM_NO_FREE_INST &&
                                pBuffer[Offset - 1] != FC_RETURN_PARAM    )
                            )
                            {
                            pStream->NewLine();
                            pStream->Write("\t\t\t");
                            }
                        break;

                    case FC_PP :
                        InPP = TRUE;
                        pStream->NewLine();
                        pStream->Write("\t\t\t");
                        break;

                    case FC_END :
                        if ( InPP )
                            {
                            pStream->NewLine();
                            pStream->Write("\t\t\t");
                            }
                        break;

                    default:
                        break;
                    }

                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset], Buf, 16 ) );
                pStream->Write( ",\t\t/* ");
                pStream->Write( pFormatCharNames[pBuffer[Offset]] );
                pStream->Write( " */");

                if ( (pBuffer[Offset] == FC_END) && InPP )
                    {
                    pStream->NewLine();
                    InPP = FALSE;
                    }

                Offset++;
                break;

            case FS_POINTER_FORMAT_CHARACTER :
                //
                // If we're not in a pointer layout, and the previous
                // format char was not a param/result char then print
                // a new line.
                //
                if  ( ! InPP &&
                      ( Offset &&
                        pBuffer[Offset - 1] != FC_IN_PARAM &&
                        pBuffer[Offset - 1] != FC_IN_OUT_PARAM &&
                        pBuffer[Offset - 1] != FC_PARTIAL_IGNORE_PARAM &&
                        pBuffer[Offset - 1] != FC_OUT_PARAM &&
                        pBuffer[Offset - 1] != FC_RETURN_PARAM    )
                    )
                    {
                    pStream->NewLine();
                    pStream->Write("\t\t\t");
                    }

                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset], Buf, 16 ) );
                pStream->Write( ", 0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset + 1] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t/* ");
                pStream->Write( pFormatCharNames[pBuffer[Offset]] );
                Out_PointerFlags( pStream, pBuffer + Offset + 1 );
                pStream->Write( " */");

                Offset += 2;
                break;

            case FS_SMALL :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* ");
                pStream->Write( MIDL_ITOA( pBuffer[Offset], Buf, 10 ) );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_OLD_PROC_FLAG_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* Old Flags: ");
                Out_OldProcFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_Oi2_PROC_FLAG_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* Oi2 Flags: ");
                Out_Oi2ProcFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_EXT_PROC_FLAG_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );
                pStream->Write( ",\t\t/* Ext Flags: ");
                Out_ExtProcFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_CORR_TYPE_BYTE :
                pStream->Write( "0x" );
                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );                
                pStream->Write( ",\t\t/* Corr desc: ");
                Out_CorrelationType( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_CONTEXT_HANDLE_FLAG_BYTE :
                pStream->Write( "0x" );

                pStream->Write( MIDL_ITOA( pBuffer[Offset] & 0x00ff, Buf, 16 ) );                
                pStream->Write( ",\t\t/* Ctxt flags: ");
                Out_ContextHandleFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset++;
                break;

            case FS_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                sprintf(Buf, "%hx",*((unsigned short UNALIGNED *)(pBuffer + Offset)) );
                pStream->Write( Buf );
                pStream->Write( " ),\t/* ");
                pStream->Write(
                    MIDL_ITOA(*((short UNALIGNED *)(pBuffer+Offset)), Buf, 10));
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_MAGIC_UNION_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                    sprintf(Buf, "%hx",*((unsigned short UNALIGNED *)(pBuffer + Offset)) );
                pStream->Write( Buf );
                pStream->Write( " ),\t/* Simple arm type: ");
                pStream->Write( pFormatCharNames[ pBuffer[Offset] ]  
                                    ?  pFormatCharNames[ pBuffer[Offset] ]
                                    : "" );
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_PARAM_FLAG_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                sprintf(Buf, "%hx",*((unsigned short UNALIGNED *)(pBuffer + Offset)) );
                pStream->Write( Buf );
                pStream->Write( " ),\t/* Flags: ");
                Out_ParameterFlags( pStream, (PARAM_ATTRIBUTES *)(pBuffer + Offset) );
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_CORR_FLAG_SHORT :
                pStream->Write( "NdrFcShort( 0x" );
                sprintf(Buf, "%hx",*((unsigned short UNALIGNED *)(pBuffer + Offset)) );
                pStream->Write( Buf );
                pStream->Write( " ),\t/* Corr flags: ");
                Out_CorrelationFlags( pStream, pBuffer + Offset );
                pStream->Write( " */");

                Offset += 2;
                break;
        
            case FS_SHORT_OFFSET :
                {
                // The relative type offset.

                TypeOffsetDictElem  *   pTO;
                long                    ItsOffset; 
                    
                ItsOffset = *((short UNALIGNED *)(pBuffer + Offset));
        
                pTO = TypeOffsetDict.LookupOffset( Offset );

                if ( pTO->TypeOffset != ItsOffset  ||
                     pTO->TypeOffset < UNION_OFFSET16_MIN )
                    {
                    pStream->Write( "Relative type offset out of range" );
                    pStream->NewLine();
                    RpcError(NULL, 0, FORMAT_STRING_LIMITS, "" );
                    fLimitErr = TRUE;
                    }
                
                if ( 0 == ( pTO->TypeOffset + Offset )  ||
                    -1 == ( pTO->TypeOffset + Offset ) )
                    {
                    fprintf( stdout, "  MIDL_fixup: Invalid offset at %d\n", Offset );
                    RpcError( NULL, 0, FORMAT_STRING_OFFSET_IS_ZERO, "" );
                    }

                pStream->Write( "NdrFcShort( 0x" );
                sprintf(Buf, "%hx",ItsOffset );
                pStream->Write( Buf );
                pStream->Write( " ),\t/* Offset= ");
                pStream->Write( MIDL_ITOA( pTO->TypeOffset, Buf, 10 ) );
                pStream->Write( " (");
                pStream->Write( MIDL_ITOA( pTO->TypeOffset + Offset, Buf, 10 ) );
                pStream->Write( ") */");

                Offset += 2;
                }
                break;

            case FS_SHORT_TYPE_OFFSET :
                {
                // The absolute type offset.

                TypeOffsetDictElem  *   pTO;
                long                    ItsOffset; 
                    
                ItsOffset = *((unsigned short UNALIGNED *)(pBuffer + Offset));

                pTO = TypeOffsetDict.LookupOffset( Offset );

                if ( pTO->TypeOffset != ItsOffset )
                    {
                    pStream->Write( "Type offset out of range" );
                    pStream->NewLine();
                    RpcError(NULL, 0, FORMAT_STRING_LIMITS, "" );
                    fLimitErr = TRUE;
                    }
                
                if ( 0 == pTO->TypeOffset  ||  -1 == pTO->TypeOffset )
                    {
                    fprintf( stdout, "  MIDL_fixup: Invalid type offset at %d\n", Offset );
                    RpcError( NULL, 0, TYPE_OFFSET_IS_ZERO, "" );
                    }

                pStream->Write( "NdrFcShort( 0x" );
                sprintf(Buf, "%hx",ItsOffset );
                pStream->Write( Buf );
                pStream->Write( " ),\t/* Type Offset=");
                pStream->Write( MIDL_ITOA( pTO->TypeOffset, Buf, 10 ) );
                pStream->Write( " */");

                Offset += 2;
                }
                break;

            case FS_SHORT_STACK_OFFSET :
                {
                Out_ShortStackOffset( pStream, 
                                      OffsetDict.LookupOffset( Offset ), 
                                      EnvComment );
                Offset += 2;

                break;
                }
            case FS_SMALL_STACK_SIZE :
                {
                Out_SmallStackSize( pStream, 
                                    pBuffer[Offset], 
                                    EnvComment );
                Offset++;

                break;
                }

            case FS_LONG :
                pStream->Write( "NdrFcLong( 0x" );
                pStream->Write(
                    MIDL_LTOA( *((long UNALIGNED *)(pBuffer+Offset)), Buf, 16));
                pStream->Write( " ),\t/* ");
                pStream->Write(
                    MIDL_LTOA(*((long UNALIGNED *)(pBuffer+Offset)), Buf, 10));
                pStream->Write( " */");
        
                Offset += 4;
                break;

            case FS_PAD_MACRO :

                if ( pPadExprDesc )
                    {
                    MIDL_ASSERT( Offset == (long)pPadExprDesc->KeyOffset );

                    pPadDict->WriteCurrentPadDesc( pStream );
                    pPadExprDesc = pPadDict->GetNext();
                    }
                else
                    {
                    pStream->Write( "0x0,\t\t/* macro */" );
                    MIDL_ASSERT( 0  &&  "Pad macro missing" );
                    }

                Offset++;
                break;

            case FS_SIZE_MACRO :

                if ( pSizeDesc )
                    {
                    MIDL_ASSERT( Offset == (long)pSizeDesc->KeyOffset );

                    pSizeDict->WriteCurrentSizeDesc( pStream );
                    pSizeDesc = pSizeDict->GetNext();
                    }
                else
                    {
                    pStream->Write( "0x0, 0x0,\t\t//  macro" );
                    MIDL_ASSERT( 0  &&  "Size macro missing" );
                    }

                Offset += 2;
                break;

            case FS_UNKNOWN_STACK_SIZE :
                {
                char * LongBuf = Buf;
                long   NameLen = (long) strlen(
                                 UnknownStackSizeDict.LookupTypeName( (long) Offset ));
                if ( NameLen > 25 )
                    LongBuf = new char[ 75 + NameLen ];

                sprintf(
                    LongBuf,
                    "%s ( (sizeof(%s) + %s) & ~ (%s) ),",
                    "(unsigned char)",
                    UnknownStackSizeDict.LookupTypeName( (long) Offset ),
                    "sizeof(int) - 1",
                    "sizeof(int) - 1" );

                pStream->Write( LongBuf );
                }
                Offset++;
                break;
            }
        }

    pStream->NewLine( 2 );

    //
    // Spit out a terminating 0 so we don't ever fall off the end
    // of the world.
    //
    pStream->Write( "\t\t\t0x0" );

    pStream->IndentInc();
    pStream->IndentInc();
    pStream->IndentInc();

    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( '}' );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    if ( LastOffset > _UI16_MAX )
        {
        pStream->Write( "Total Format String size is too big." );
        pStream->NewLine();
        fprintf(stdout, "Total Format String size = %d\n", LastOffset );
        RpcError(NULL, 0, FORMAT_STRING_LIMITS, "" );
        fLimitErr = TRUE;
        }

    if ( fLimitErr )
        exit( FORMAT_STRING_LIMITS );
}


long  
FORMAT_STRING::OptimizeFragment(
    CG_NDR  *       pNode )
/*++

Routine Description :
    
    Optimize a format string fragment away.

Arguments :
    
    pNode               - CG_NDR node, with format string start
                            and end offsets already set.

 --*/
{
    long      StartOffset = pNode->GetFormatStringOffset();
    long      EndOffset   = pNode->GetFormatStringEndOffset();

    FRMTREG_ENTRY       NewFragment( StartOffset, EndOffset );
    FRMTREG_ENTRY   *   pOldFragment;

    // perform format string optimization

#if defined(RKK_FRAG_OPT)
    {
            printf("Optimizing: start=%d, end=%d\n", StartOffset, EndOffset);

            printf("    off str=%d ", StartOffset );
            for (int off = StartOffset; off <= EndOffset; off++)
                printf("%02x ", pBuffer[ off ]);
            printf( "\n" );
            printf("    off typ=%d ", StartOffset );
            for ( off = StartOffset; off <= EndOffset; off++)
                printf("%02x ", pBufferType[ off ]);
            printf( "\n" );
    }
#endif

    if ( pCommand->IsSwitchDefined( SWITCH_NO_FMT_OPT ) )
        return StartOffset;

    // We attempt to optimize fragments even if they are apart by more than 32k.

    MIDL_ASSERT ( EndOffset <= (long)LastOffset );

    // add to dictionary

    // if match found, reset format string offset back to our start
    if ( GetReuseDict()->GetReUseEntry( pOldFragment, &NewFragment ) )
        {
        long  OldStartOffset = pOldFragment->GetStartOffset();

        // if we are not the end, we can't do anything about ourselves
        // similarly, if we match ourselves, don't do anything
        if ( ( GetCurrentOffset() == EndOffset ) &&
             ( OldStartOffset != StartOffset ) )
            {
            // move format string offset back
            SetCurrentOffset( StartOffset );
            pNode->SetFormatStringOffset( OldStartOffset );
            pNode->SetFormatStringEndOffset( pOldFragment->GetEndOffset() );
            return OldStartOffset;
            }

#if defined(RKK_FRAG_OPT)
        else if ( GetCurrentOffset() != EndOffset )
            {
            printf( "OptimizeFragment fragment not at the end End=%d, frag End=%d\n",
                    GetCurrentOffset(), EndOffset );
            }
#endif

        }   // duplicate found

    return StartOffset;

}


unsigned short  
FORMAT_STRING::RegisterFragment(
    CG_NDR  *       pNode )
/*++

Routine Description :
    
    Register, but do not remove, a format string fragment.

Arguments :
    
    pNode               - CG_NDR node, with format string start offset already set.
    EndOffset           - end offset of format string fragment

 --*/
{
    unsigned short      StartOffset     = (unsigned short)
                                                pNode->GetFormatStringOffset();
    unsigned short      EndOffset       = (unsigned short)
                                                pNode->GetFormatStringEndOffset();
    FRMTREG_ENTRY       NewFragment( StartOffset, EndOffset );
    FRMTREG_ENTRY   *   pOldFragment;

    // perform format string optimization
    if ( pCommand->IsSwitchDefined( SWITCH_NO_FMT_OPT ) )
        return StartOffset;

    MIDL_ASSERT( ( ((short) StartOffset) != -1 ) &&
            ( ((short) EndOffset) != -1 ) );
    MIDL_ASSERT ( EndOffset <= LastOffset );

    // add to dictionary, or return pointer to old entry
    GetReuseDict()->GetReUseEntry( pOldFragment, &NewFragment );

    return StartOffset;

}

char *
CommentDictionary::GetComments(
    long    Offset
    )
{
    CommentDictElem     Elem;
    CommentDictElem *   pHead;
    CommentDictElem *   pElem;
    Dict_Status         DictStatus;
    char *              Comments;
    long                Length;

    Elem.FormatStringOffset = Offset;

    DictStatus = Dict_Find( &Elem );

    if ( DictStatus != SUCCESS )
        return 0;

    pHead = (CommentDictElem *) Dict_Item();

    Length = 0;

    for ( pElem = pHead; pElem; pElem = pElem->Next )
        Length += (long) strlen( pElem->Comment );

    Comments = new char[Length+1];
    Comments[0] = 0;

    for ( pElem = pHead; pElem; pElem = pElem->Next )
        strcat( Comments, pElem->Comment );

    return Comments;
}

void
CommentDictionary::Insert(
    long    FormatStringOffset,
    char *  Comment
    )
{
    CommentDictElem     Elem;
    CommentDictElem *   pHead;
    CommentDictElem *   pElem;
    Dict_Status         DictStatus;

    Elem.FormatStringOffset = FormatStringOffset;

    DictStatus = Dict_Find( &Elem );

    if ( DictStatus == SUCCESS )
        pHead = (CommentDictElem *) Dict_Item();
    else
        pHead = 0;

    pElem = new CommentDictElem;

    pElem->Next = pHead;
    pElem->FormatStringOffset = FormatStringOffset;
    pElem->Comment = Comment;

    //
    // We delete any current entry and add a new entry so that comments
    // are always prepended to the list.
    //
    if ( pHead )
        Dict_Delete( (pUserType *) &pHead );

    Dict_Insert( pElem  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\header.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    header.cxx

 Abstract:
    
    Generates header file.

 Notes:


 History:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "buffer.hxx"

/****************************************************************************
 *  local definitions
 ***************************************************************************/


/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;


CG_STATUS
CG_OBJECT_INTERFACE::GenHeader(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate interface header file.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes: The interface header file has the following structure:
        Forward declaration
        TypeDeclarations
        #if defined(__cplusplus) && !defined(CINTERFACE)
            CPlusPlusLanguageBinding
        #else 
            CLanguageBinding
        #endif

----------------------------------------------------------------------------*/
{
    node_interface *    pInterface = (node_interface *) GetType();
    ISTREAM *           pStream = pCCB->GetStream();
	char			*	pName	= pInterface->GetSymName();

    if (!pInterface->PrintedDef())
    {
        //Initialize the CCB for this interface.
        InitializeCCB(pCCB);

	    // put out the interface guards
	    pStream->Write("\n#ifndef __");
	    pStream->Write( pName );
	    pStream->Write( "_INTERFACE_DEFINED__\n" );

	    pStream->Write( "#define __");
	    pStream->Write( pName );
	    pStream->Write( "_INTERFACE_DEFINED__\n" );

        // Print out the declarations of the types
        pStream->NewLine();
        pInterface->PrintType( PRT_INTERFACE | PRT_OMIT_PROTOTYPE, pStream, 0);
        Out_IID(pCCB);
    
	    // print out the vtable/class definitions
        pStream->NewLine();
        pStream->Write("#if defined(__cplusplus) && !defined(CINTERFACE)");

        pStream->IndentInc();
        CPlusPlusLanguageBinding(pCCB);
        pStream->IndentDec();

        pStream->NewLine();
        pStream->Write("#else \t/* C style interface */");

        pStream->IndentInc();
        CLanguageBinding(pCCB);
        pStream->IndentDec();

	    // print out the C Macros
	    CLanguageMacros( pCCB );
        pStream->NewLine( 2 );

        pStream->Write("#endif \t/* C style interface */");
        pStream->NewLine( 2 );
    
	    // print out the prototypes for the proxy and stub routines

        ProxyPrototypes(pCCB);
        pStream->NewLine();

	    // put out the trailing interface guard
	    pStream->Write( "\n#endif \t/* __");
	    pStream->Write( pName );
	    pStream->Write( "_INTERFACE_DEFINED__ */\n" );

        pStream->NewLine();
        pInterface->SetPrintedDef();
    }
    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::CPlusPlusLanguageBinding(CCB *pCCB)
{
    ISTREAM *pStream = pCCB->GetStream();
    char *pName;

    pStream->NewLine();
    pName = GetType()->GetSymName();
    MIDL_ASSERT (pName != (char *)0);

    pStream->NewLine();

    // put out the declspec for the uuid
    if ( pCommand->GetMSCVer() >= 1100 )
        {
        pStream->Write("MIDL_INTERFACE(\"");
        pStream->Write(GuidStrs.str1);
        pStream->Write('-');
        pStream->Write(GuidStrs.str2);
        pStream->Write('-');
        pStream->Write(GuidStrs.str3);
        pStream->Write('-');
        pStream->Write(GuidStrs.str4);
        pStream->Write('-');
        pStream->Write(GuidStrs.str5);
        pStream->Write("\")");
        }
    else
        {
        pStream->Write(" struct ");
        }
    
    pStream->NewLine();
    pStream->Write(pName);

    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();
    //Check if this interface was derived from a base interface.
    if(pBaseCG)
    {
        pStream->Write(" : public ");
        pStream->Write(pBaseCG->GetType()->GetSymName());
    }

    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();
    pStream->Write("public:");
    pStream->IndentInc();

    // REVIEW: BEGIN/END_INTERFACE were only need for PowerMac.  Maybe we
    //         should stop emitting them?  -- MikeW 26-Jul-99

    if( ! pBaseCG )
        {
        pStream->NewLine();
        pStream->Write("BEGIN_INTERFACE");
        }

    PrintMemberFunctions( pStream, TRUE );

    if( ! pBaseCG )
        {
        pStream->NewLine();
        pStream->Write("END_INTERFACE");
        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();

    return CG_OK;
}

STATUS_T 
CG_OBJECT_INTERFACE::PrintMemberFunctions(
    ISTREAM       * pStream,
    BOOL			fAbstract) 
/*++

Routine Description:

    This routine prints C++ function prototypes for the interface member functions.
    We assume that all of the procedure nodes are pure virtual functions.

Arguments:

    pStream 	- Specifies the output stream.
	fAbstract	- Specifies whether the methods should be abstract ( = 0 ).

--*/
{
    CG_OBJECT_PROC  *   pProc = (CG_OBJECT_PROC *) GetChild();

    MIDL_ASSERT (GetType()->GetSymName() != (char *)0);

    while( pProc )
        {
        if ( !pProc->SupressHeader() )
            {
            node_skl* pN = pProc->GetType();

            //Assume this is a pure virtual function.
            // use the call_as form, if any
            pStream->NewLine();
            pStream->Write("virtual ");
            pN->PrintType( PRT_PROTOTYPE | PRT_CALL_AS | PRT_FORCE_CALL_CONV | PRT_CPP_PROTOTYPE, 
				           pStream, 
						   0 );
            if ( fAbstract) 
        	    pStream->Write(" = 0;");
		    else
			    pStream->Write(";");
            pStream->NewLine();
            }
 
        pProc = (CG_OBJECT_PROC *) pProc->GetSibling();
        }
    return STATUS_OK;
}


CG_STATUS
CG_OBJECT_PROC::PrintVtableEntry(
    CCB *       pCCB)
{
    ISTREAM *   pStream = pCCB->GetStream();
    node_id *   pTempID;
    char    *   pName   = GetType()->GetSymName();

    if (SupressHeader())
    {
        return CG_OK;
    }

    if ( GetCallAsName() )
        {
        pName = GetCallAsName();
        }

    pTempID = MakePtrIDNode( pName, GetType() );

    pStream->NewLine();
    pTempID->PrintType( PRT_PROC_PTR_PROTOTYPE | PRT_THIS_POINTER | PRT_CALL_AS | PRT_FORCE_CALL_CONV,
                        pStream,
                        NULL ,
                        pCCB->GetInterfaceCG()->GetType() );
                         
    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::CLanguageBinding(CCB *pCCB)
{
#ifndef DISABLE_C_OUTPUT
    ISTREAM *           pStream = pCCB->GetStream();
	char	*			pName	= pCCB->GetInterfaceName();

    pStream->NewLine( 2 );
    pStream->Write("typedef struct ");
    pStream->Write(pName);
    pStream->Write("Vtbl");
    pStream->NewLine();
    pStream->Write('{');

    
    pStream->IndentInc();
    pStream->NewLine();

    // REVIEW: BEGIN/END_INTERFACE were only need for PowerMac.  Maybe we
    //         should stop emitting them?  -- MikeW 26-Jul-99

    pStream->Write("BEGIN_INTERFACE");
    pStream->NewLine();

    // Now the regular entries.

    PrintVtableEntries( pCCB );

    // This is a match for the other macro.

    pStream->NewLine();
    pStream->Write("END_INTERFACE");

    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write("} ");
    pStream->Write(pName);
    pStream->Write("Vtbl;");
    pStream->NewLine( 2 );
    pStream->Write("interface ");
    pStream->Write(pName);
    pStream->NewLine();
    pStream->Write('{');
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("CONST_VTBL struct ");
    pStream->Write(pName);
    pStream->Write("Vtbl *lpVtbl;");
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine( 2 );
#endif
    return CG_OK;
}



CG_STATUS
CG_OBJECT_INTERFACE::ProxyPrototypes(CCB *pCCB)
/*++

Routine Description:

    This routine generates function prototypes for the interface proxy.
    For each procedure, we generate a proxy prototype and a 
    stub prototype.

Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

--*/
{
    ISTREAM             *   pStream = pCCB->GetStream();
    CG_OBJECT_PROC      *   pProcCG = 0;
    char *                  pszName;
    CG_ITERATOR				I;

    pszName = GetType()->GetSymName();
    MIDL_ASSERT (pszName != (char *)0);

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pProcCG ) )
        {
        if (!pProcCG->SupressHeader())
            {
            //print proxy function prototype
            pStream->NewLine();
            pProcCG->Out_ProxyFunctionPrototype(pCCB, 
                                       PRT_TRAILING_SEMI );

            //print stub function prototype
            pStream->NewLine();
            pProcCG->Out_StubFunctionPrototype( pCCB );
            pStream->Write(';');
    
            pStream->NewLine();
            }
        }
    pStream->NewLine();

    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::PrintCMacros(CCB *pCCB)
/*++

Routine Description:

    This routine generates C macros for an interface

Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

--*/
{
#ifndef DISABLE_C_OUTPUT
    ISTREAM             *   pStream = pCCB->GetStream();
    CG_OBJECT_PROC      *   pProcCG = 0;
    CG_ITERATOR        		I;

	// print inherited methods ( with our current ccb intf name )
	if ( GetBaseInterfaceCG() )                    
		((CG_OBJECT_INTERFACE *)GetBaseInterfaceCG())->PrintCMacros( pCCB );

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pProcCG ) )
        {
        //print proxy function prototype
        pStream->NewLine();
        pProcCG->GenCMacro(pCCB);

        }
    pStream->NewLine();
#endif    
    return CG_OK;
}


CG_STATUS
CG_OBJECT_INTERFACE::CLanguageMacros(CCB *pCCB)
{
#ifndef DISABLE_C_OUTPUT
    ISTREAM *           pStream = pCCB->GetStream();

    pStream->NewLine( 2 );
    pStream->Write("#ifdef COBJMACROS");
    pStream->NewLine();

    PrintCMacros( pCCB );

    pStream->NewLine();
    pStream->Write("#endif /* COBJMACROS */");
    pStream->NewLine();
#endif
    return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\filecls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    filecls.hxx

 Abstract:

    Code generation methods for file cg classes.

 Notes:


 History:

    Sep-01-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4238 4239 )

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  local definitions
 ***************************************************************************/

/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
extern CMD_ARG * pCommand;
char* GetRpcNdrHVersionGuard( char* );
char* GetRpcProxyHVersionGuard( char* );

extern BOOL                     IsTempName( char * );


/****************************************************************************/

void
CG_FILE::EmitFileHeadingBlock(
    CCB *   pCCB,
    char *  CommentStr,
    char *  CommentStr2,
    bool    fDualFile )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit double platform ifdef as needed and the opening comment to the file.

 Arguments:

    pCCB        - a pointer to the code generation control block.
    CommentStr  - a comment customizing the file.
    CommentStr2 - optional comment used in *_i.c
    fDualFile   - true for client stub, server stub and froxy file
                  false for the header file

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
 
    // Comment customizing the file.

    pStream->NewLine(2);
    pStream->Write( "/* this ALWAYS GENERATED file contains " );
    pStream->Write( CommentStr );
    pStream->Write( " */" );
    pStream->NewLine(2);
    if ( CommentStr2 )
        {
        pStream->Write( "/* " );
        pStream->Write( CommentStr2 );
        pStream->Write( " */" );
        pStream->NewLine(2);
        }

    EmitStandardHeadingBlock( pCCB );

    if ( fDualFile )
        {
        pStream->NewLine();
        if ( pCommand->Is64BitEnv() )
            pStream->Write( "#if defined(_M_IA64) || defined(_M_AMD64)" );
        else if ( pCommand->Is32BitEnv() )
            {
            pStream->Write( "#if !defined(_M_IA64) && !defined(_M_AMD64)" );
            }
        pStream->NewLine(2);
        }


    // A guard for double, i.e. 32b-64b, files.
    pStream->NewLine();
    pStream->Write( "#pragma warning( disable: 4049 )  /* more than 64k source lines */");
    pStream->NewLine(1);
// we dont want to push & pop in header file as there might be cpp_quote warning() by user and that'll break users code if we pop it.
#pragma prefast(suppress:537, dynamic cast checking problem in prefast)
    if ( dynamic_cast<CG_PROXY_FILE *>(this)  || dynamic_cast<CG_SSTUB_FILE *>(this) || dynamic_cast<CG_CSTUB_FILE *>(this ) )
        {
        pStream->Write("#if _MSC_VER >= 1200" );
        pStream->NewLine(1);
        pStream->Write("#pragma warning(push)");
        pStream->NewLine(1);
        pStream->Write("#endif" );
        pStream->NewLine(1);
            if ( pCommand->Is32BitEnv() && 
             pCommand->GetOptimizationFlags() == OPTIMIZE_ALL_I2_FLAGS )
            {
            pStream->Write( "#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */");
            }
            pStream->NewLine(1);
            pStream->Write( "#pragma warning( disable: 4211 )  /* redefine extent to static */");
            pStream->NewLine(1);
            pStream->Write( "#pragma warning( disable: 4232 )  /* dllimport identity*/");
        }

    
}

void
CG_FILE::EmitFileClosingBlock(
    CCB *   pCCB,
    bool    fDualFile )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit an endif matching the one emitted in EmitFileHeadingBlock

 Arguments:

    pCCB        - a pointer to the code generation control block.
    CommentStr  - a comment customizing the file.
    fDualFile   - true for client stub, server stub and froxy file
                  false for the header file

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

#pragma prefast(suppress:537, dynamic cast checking problem in prefast)
    if ( dynamic_cast<CG_PROXY_FILE *>(this)  || dynamic_cast<CG_SSTUB_FILE *>(this) || dynamic_cast<CG_CSTUB_FILE *>(this ) )
        {
        pStream->Write("#if _MSC_VER >= 1200" );
        pStream->NewLine(1);
        pStream->Write("#pragma warning(pop)");
        pStream->NewLine(1);
        pStream->Write("#endif" );
        pStream->NewLine(1);
        }
    
    if ( fDualFile )
        {
        pStream->NewLine(2);
        if ( pCommand->Is64BitEnv() )
            pStream->Write( "#endif /* defined(_M_IA64) || defined(_M_AMD64)*/" );
        else if ( pCommand->Is32BitEnv() )
            {
            pStream->Write( "#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/" );
            }
        }

    pStream->NewLine(2);


}

void
CG_FILE::EmitStandardHeadingBlock(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit standard block comment file heading portion.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write(" /* File created by MIDL compiler version ");
    pStream->Write( pCommand->GetCompilerVersion() );
    pStream->Write(" */");

    pStream->NewLine();

    if ( !pCommand->IsSwitchDefined( SWITCH_NO_STAMP ) )
        {
        pStream->Write("/* at ");
        pStream->Write( pCommand->GetCompileTime() );
        pStream->Write(" */");
        pStream->NewLine();
        }

    // Emit command line switches information.

    pCommand->EmitConfirm( pStream );

    // Write this remnant of the reparsing scheme for our testers.
    pStream->Write( "//@@MIDL_FILE_HEADING(  )" );

    pStream->NewLine();

}

void
CG_FILE::Out_TransferSyntaxDefs(
    CCB     * pCCB )
{
    ISTREAM *pStream = pCCB->GetStream();

    // NDR transfer syntax id is needed for
    if ( pCommand->NeedsNDRRun() )
        {
        // BUGBUG: transfer syntax guids should be in rpcrt4.lib or something
        pStream->WriteOnNewLine("static " TRANSFER_SYNTAX_TYPE_NAME "  ");
        pStream->Write( NDR_TRANSFER_SYNTAX_VAR_NAME );
        pStream->Write( " = ");
        pStream->NewLine();
        Out_TransferSyntax( pCCB,
                            TransferSyntaxGuidStrs,
                            NDR_UUID_MAJOR_VERSION,
                            NDR_UUID_MINOR_VERSION );
        pStream->Write( ';' );
        pStream->NewLine();

        }

    if ( pCommand->NeedsNDR64Run() )
        {
        pStream->WriteOnNewLine("static  " TRANSFER_SYNTAX_TYPE_NAME "  ");
        pStream->Write( NDR64_TRANSFER_SYNTAX_VAR_NAME );
        pStream->Write( " = ");
        pStream->NewLine();
        if ( pCommand->IsSwitchDefined( SWITCH_INTERNAL ) &&
             pCommand->GetEnv() == ENV_WIN32 )
            Out_TransferSyntax( pCCB,
                        FakeNDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        else
            Out_TransferSyntax( pCCB,
                            NDR64TransferSyntaxGuidStrs,
                            NDR64_UUID_MAJOR_VERSION,
                            NDR64_UUID_MINOR_VERSION );
        pStream->Write( ';' );
        pStream->NewLine();

        }

}


void
CG_FILE::EmitFormatStringTypedefs(
    CCB      *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit dummy #defines with sizes for the format string structs,
    then emit typedefs for the type and proc format string structs.
    Sets the context position in the file node for later use.
    Additional tables serviced here:
        transmit_as,     element is a quad
        wire_marshal     element is a quad

 Arguments:

    pCCB        - a pointer to the code generation control block.

 Notes:

    The typedefs are going to be fixed later by a call to
    EmitFixupToFormatStringTypedefs. This is needed for ANSI.
    The dummies would work for ANSI non-compliant code.

--------------------------------------------------------------------------*/
{
    ISTREAM  *  pStream    = pCCB->GetStream();

    // we'll only generate this once in the first run.
    if ( pCommand->Is2ndCodegenRun() )
        return;

    pStream->NewLine(2);
    if ( pCommand->NeedsNDRRun() )
        {
        pStream->Write( "#define TYPE_FORMAT_STRING_SIZE   " );
        SetOptionalTableSizePosition( TypeFormatStringSizePosition,
                                  pStream->GetCurrentPosition() );
        pStream->Write( "                                  " );
        pStream->NewLine();

        pStream->Write( "#define PROC_FORMAT_STRING_SIZE   " );
        SetOptionalTableSizePosition( ProcFormatStringSizePosition,
                                  pStream->GetCurrentPosition() );
        pStream->Write( "                                  " );

        pStream->NewLine();
        }


    pStream->Write( "#define " TRANSMIT_AS_TABLE_SIZE "    " );
    SetOptionalTableSizePosition( TransmitAsSizePosition,
                                  pStream->GetCurrentPosition() );
    pStream->Write( "             " );
    pStream->NewLine();

    pStream->Write( "#define " WIRE_MARSHAL_TABLE_SIZE "   " );
    SetOptionalTableSizePosition( WireMarshalSizePosition,
                                  pStream->GetCurrentPosition() );
    pStream->Write( "             " );
    pStream->NewLine();

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->NewLine();

        pStream->Write( "typedef struct _" FORMAT_STRING_TYPE_NAME );
        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write( "{" );
        pStream->NewLine();
        pStream->Write( "short          Pad;" );
        pStream->NewLine();
        pStream->Write( "unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];" );
        pStream->NewLine();
        pStream->Write( "} " FORMAT_STRING_TYPE_NAME ";" );
        pStream->IndentDec();
        pStream->NewLine(2);

        pStream->Write( "typedef struct _" PROC_FORMAT_STRING_TYPE_NAME );
        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write( "{" );
        pStream->NewLine();
        pStream->Write( "short          Pad;" );
        pStream->NewLine();
        pStream->Write( "unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];" );
        pStream->NewLine();
        pStream->Write( "} " PROC_FORMAT_STRING_TYPE_NAME ";" );
        pStream->IndentDec();
        pStream->NewLine(2);
        }

}

void
CG_FILE::EmitFixupToFormatStringTypedefs(
    CCB      *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Fixes he dummy #defines emitted by EmitFormatStringTypedefs.

 Arguments:

    pCCB        - a pointer to the code generation control block.
    pContext    - a pointer to the position context

--------------------------------------------------------------------------*/
{
    char        Buffer[20];
    ISTREAM  *  pStream = pCCB->GetStream();
    long        EofPosition;

    EofPosition = pStream->GetCurrentPosition();

    if ( !pCommand->Is2ndCodegenRun() )
        {
        pStream->SetCurrentPosition(
                GetOptionalTableSizePosition( TransmitAsSizePosition ) );
        sprintf( Buffer, "%d", pCCB->GetQuintupleDictionary()->GetCount() );
        pStream->Write( Buffer );

        pStream->SetCurrentPosition(
                GetOptionalTableSizePosition( WireMarshalSizePosition ) );
        sprintf( Buffer, "%d", pCCB->GetQuadrupleDictionary()->GetCount() );
        pStream->Write( Buffer );
        }

    if ( pCommand->IsNDRRun() )
        {
        pStream->SetCurrentPosition(
            GetOptionalTableSizePosition( TypeFormatStringSizePosition ) );
        sprintf( Buffer, "%d",  pCCB->GetFormatString()->GetCurrentOffset() + 1);
        pStream->Write( Buffer );

        pStream->SetCurrentPosition(
            GetOptionalTableSizePosition( ProcFormatStringSizePosition ) );
        sprintf( Buffer, "%d",  pCCB->GetProcFormatString()->GetCurrentOffset() + 1);
        pStream->Write( Buffer );
#ifdef     PRINT_METRICS
            printf  (
                    "Format string sizes %16d, %16d, %s\n",
                    pCCB->GetFormatString()->GetCurrentOffset() + 1,
                    pCCB->GetProcFormatString()->GetCurrentOffset() + 1,
                    GetFileName()
                    );
#endif

        }

    pStream->SetCurrentPosition( EofPosition );
}


void
CG_FILE::EmitOptionalClientTableSizeTypedefs(
    CCB  *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit dummy #defines with sizes for the optional tables:
        generic handles, element is a pair
    Tables serviced in the EmitFormStringtypedefs routine:
        transmit_as
        wire_marshal

 Arguments:

    pCCB        - a pointer to the code generation control block.

 Notes:

    The typedefs are going to be fixed later by a call to
    EmitFixupToOptionalTableSizeTypedefs. This is needed for ANSI.
    Note that we have the following tables that are not affected
    by the ANSI issue because element is not a struct:
        context rundown routine table
        expression evaluation table
        notify table

--------------------------------------------------------------------------*/
{
    ISTREAM  *  pStream    = pCCB->GetStream();

    pStream->NewLine(2);

    pStream->Write( "#define " GENERIC_BINDING_TABLE_SIZE "   " );
    SetOptionalTableSizePosition( GenericHandleSizePosition,
                                  pStream->GetCurrentPosition() );
    pStream->Write( "             " );
    pStream->NewLine();

}

void
CG_FILE::EmitFixupToOptionalClientTableSizeTypedefs(
    CCB  *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit dummy #defines with sizes for the optional tables:
        generic handles,

 Arguments:

    pCCB        - a pointer to the code generation control block.

 Notes:

    The typedefs are going to be fixed later by a call to
    EmitFixupOptionalTableSizeTpedefs. This is needed for ANSI.

--------------------------------------------------------------------------*/
{
    char        Buffer[20];
    ISTREAM  *  pStream = pCCB->GetStream();

    long EofPosition = pStream->GetCurrentPosition();

    pStream->SetCurrentPosition(
                GetOptionalTableSizePosition( GenericHandleSizePosition ) );
    sprintf( Buffer, "%d",  pCCB->GetGenericIndexMgr()->GetIndex() - 1 );
    pStream->Write( Buffer );

    pStream->SetCurrentPosition( EofPosition );
}

CG_STATUS
CG_SOURCE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the source node.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR I;
    CG_FILE *   pCG;

    //
    // for all files nodes in this interface, generate code.
    //

    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCG->GenCode( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_CSTUB_FILE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    CG_NDR          *   pCG;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];


    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    ISTREAM     Stream( GetFileName(), 4 );
    ISTREAM *   pStream     = &Stream;

    pCCB->SetStream( pStream, this );

    // Set HasStublessProxies and HasOi2 for each interface.

    EvaluateVersionControl();

    EmitFileHeadingBlock( pCCB, "the RPC client stubs" );

    SetNoOutputIn2ndCodegen( pCCB );

    // Emit the hash includes.

    Out_IncludeOfFile( pCCB, STRING_H_INC_FILE_NAME, TRUE );
    pStream->NewLine();

    // rpcssm puts a reference to malloc and free in the stub_c.c.
    // So, we have to emit the appropriate include.
    // In ms_ext when explicit, in osf always, to cover some weird cases.

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( ( ((CG_INTERFACE *)pCG)->GetUsesRpcSS() || (pCCB->GetMode() == 0) ))
            {
            Out_IncludeOfFile( pCCB, "malloc.h", TRUE );
            break;
            }
        }

    _splitpath( GetHeaderFileName(), Drive, Path, Name, Ext );
    strcpy( Buffer, Name );
    strcat( Buffer, Ext );
    Out_IncludeOfFile( pCCB, Buffer, FALSE );
    EmitFormatStringTypedefs( pCCB );


    Out_TransferSyntaxDefs( pCCB );

    //
    // Emit the external variables needed.
    //

    pStream->NewLine();

    //
    // Emit the format string extern declarations.
    //

    Out_FormatInfoExtern( pCCB );
    Out_TypeFormatStringExtern( pCCB );
    Out_ProcFormatStringExtern( pCCB );

    EmitOptionalClientTableSizeTypedefs( pCCB );
    pCCB->ClearOptionalExternFlags();

    pCCB->SetFileCG(this);

    MIDL_ASSERT( pCommand->IsNDR64Run() || pCommand->IsNDRRun() );

    if ( pCommand->IsNDR64Run() )
        {
        pCCB->SetFormatString( NULL );
        pCCB->SetProcFormatString( NULL );
        pCCB->SetNdr64Format( GenNdr64Format::CreateInstance( pCCB ) );
        }

    else
        {
        //
        // Create a new format string object if it does not yet exist.
        //
        if ( !pCCB->GetFormatString() )
        {
            pCCB->SetFormatString( new FORMAT_STRING() );

            // push a dummy short 0 at the beginning. This disambiguates
            // the case where offset 0 means recursion and a valid offset

            // always push the 0 at the beginning, otherwise we'll av in
            // some idl files (contain VARIANT for example) if -internal
            // is specified.
//            if ( !pCommand->IsSwitchDefined( SWITCH_INTERNAL ) )
//                {
                pCCB->GetFormatString()->PushShort( ( short ) 0 );
//                }
        }

        if ( !pCCB->GetProcFormatString() )
        {
            pCCB->SetProcFormatString( new FORMAT_STRING() );
        }
        }

    //
    // for all interfaces in this file, generate format info.
    //

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                ((CG_INTERFACE *)pCG)->OutputInterfaceIdComment( pCCB );
                ((CG_INTERFACE *)pCG)->GenClientInfo( pCCB );
                break;
            }
        }

    //
    // Output the tables that may be common to several interfaces.
    //
    EmitFixupToOptionalClientTableSizeTypedefs( pCCB );
    ResetNoOutputIn2ndCodegen( pCCB );

    EmitFixupToFormatStringTypedefs( pCCB );

    // REVIEW: The externs may not be necessary anymore
    pCCB->OutputExternsToMultipleInterfaceTables();
    pCCB->OutputMultipleInterfaceTables();

    OutputTypePicklingTables( pCCB );

    //
    // for all interfaces in this file, output stubs, proc tables, etc.
    //

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                ((CG_INTERFACE *)pCG)->OutputClientStub( pCCB );
                break;
           }
        }


    EmitFileClosingBlock( pCCB );

    return CG_OK;
}



void
CG_CSTUB_FILE::OutputTypePicklingTables(
        CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output tables of offsets to type information for type pickling.
    If this is the final run, also output the "table of tables"

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Notes:

    Pickled simple types don't end up in the the table.  They are special
    cased.

    Tables looks like:

        static unsigned long DCE_TypePicklingOffsets[] =
        {
            ...
        };

        static unsigned long Ndr64_TypePicklingOffsets[] =
        {
            ...
        };

        static unsigned long * TypePicklingOffsetTable[] =
        {
            DCE_TypePicklingOffsets,
            Ndr64_TypePicklingOffsets
        }

----------------------------------------------------------------------------*/
{
    // straight DCE mode passes the offset directly to the type pickling API

    if ( !pCommand->NeedsNDR64Run() )
        return;

    IndexedList PickledTypes = pCCB->GetListOfPickledTypes();

    if ( 0 == PickledTypes.GetCount() )
        return;

    ISTREAM        *pStream = pCCB->GetStream();
    PNAME           syntax;
    CG_TYPE_ENCODE *type;
    bool            first = true;

    if ( pCommand->IsNDR64Run() )
        syntax = "FormatInfoRef Ndr64";
    else
        syntax = "unsigned long DCE";

    //
    // Output the type offset table for the current syntax
    //

    pStream->NewLine();
    pStream->WriteFormat(
                    "static %s_TypePicklingOffsets[] =",
                    syntax );
    pStream->WriteOnNewLine( '{' );
    pStream->IndentInc();

    ITERATOR_INIT( PickledTypes );

    while ( ITERATOR_GETNEXT( PickledTypes, type ) )
        {
        if ( !first )
            pStream->Write( ',' );

        pStream->NewLine();

        CG_NDR *pChild = (CG_NDR *) type->GetChild();
        ulong   TypeOffset;
        char   *format;

        if ( pCommand->IsNDR64Run() )
            {
            format = "&__midl_frag%d";
            TypeOffset = (ulong) (size_t) pCCB->GetNdr64Format()->GetRoot()
                                        ->LookupFragmentID( pChild );
            MIDL_ASSERT( 0 != TypeOffset );
            }
        else
            {
            format = "%d";
            TypeOffset = pChild->GetFormatStringOffset();
            MIDL_ASSERT( ((ulong) -1) != TypeOffset );
            }

        pStream->WriteFormat( format, TypeOffset );
        pStream->WriteFormat( "   /* %s */", type->GetSymName() );
        first = false;
        }

    pStream->IndentDec();
    pStream->WriteOnNewLine( "};" );
    pStream->NewLine();

    //
    // If this isn't the final protocol, quit now.  Otherwise output the
    // table of tables.
    //

    if ( !pCommand->IsFinalProtocolRun() )
        return;

    pStream->WriteOnNewLine( "static unsigned long * "
                                    "TypePicklingOffsetTable[] =" );
    pStream->WriteOnNewLine( "{" );
    pStream->IndentInc();

    first = true;

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->WriteOnNewLine( "DCE_TypePicklingOffsets" );
        first = false;
        }
    if ( pCommand->NeedsNDR64Run() )
        {
        if ( !first ) pStream->Write( ',' );
        pStream->WriteOnNewLine( "(unsigned long *) Ndr64_TypePicklingOffsets" );
        first = false;
        }

    pStream->IndentDec();
    pStream->WriteOnNewLine( "};" );
    pStream->NewLine();
}



/****************************************************************************
 *  sstub file implementation class.
 ***************************************************************************/

CG_STATUS
CG_SSTUB_FILE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    CG_NDR      *   pCG;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    ISTREAM     Stream( GetFileName(), 4 );
    ISTREAM *   pStream     = &Stream;

    pCCB->SetStream( pStream, this );

    // Set HasStublessProxies and HasOi2 for each interface.

    EvaluateVersionControl();

    EmitFileHeadingBlock( pCCB, "the RPC server stubs" );

    //
    // Emit the hash includes.
    //
    SetNoOutputIn2ndCodegen( pCCB );

    Out_IncludeOfFile( pCCB, STRING_H_INC_FILE_NAME, TRUE );
    _splitpath( GetHeaderFileName(), Drive, Path, Name, Ext );
    strcpy( Buffer, Name );
    strcat( Buffer, Ext );
    Out_IncludeOfFile( pCCB, Buffer, FALSE );

    EmitFormatStringTypedefs( pCCB );

    Out_TransferSyntaxDefs( pCCB );
    //
    // Emit the external variables needed.
    //

    //
    // Emit the format string extern declarations.
    //
    Out_FormatInfoExtern( pCCB );
    Out_TypeFormatStringExtern( pCCB );
    Out_ProcFormatStringExtern( pCCB );

    pCCB->ClearOptionalExternFlags();

    pCCB->SetFileCG(this);

    Out_NotifyTableExtern( pCCB );

    MIDL_ASSERT( pCommand->IsNDR64Run() || pCommand->IsNDRRun() );

    if ( pCommand->IsNDR64Run() )
        {
        pCCB->SetFormatString( NULL );
        pCCB->SetProcFormatString( NULL );
        pCCB->SetNdr64Format( GenNdr64Format::CreateInstance( pCCB ) );
        }

    else
        {

        //
        // Create a new format string object if it does not exist.
        //
        if ( !pCCB->GetFormatString() )
        {
            pCCB->SetFormatString( new FORMAT_STRING() );

            // push a dummy short 0 at the beginning. This disambiguates
            // the case where offset 0 means recursion and a valid offset

            pCCB->GetFormatString()->PushShort( ( short ) 0 );
        }

        if ( !pCCB->GetProcFormatString() )
        {
            pCCB->SetProcFormatString( new FORMAT_STRING() );
        }

        }

    //
    // Send the message to the children to emit code.
    //

    //
    // For all interfaces in this file, generate code.
    //

    BOOL            HasInterpretedProc = FALSE;

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->GetCGID() == ID_CG_INTERFACE )
            {
            if ( ! ((CG_INTERFACE *)pCG)->HasPicklingStuffOnly() )
                {
                pCCB->SetSkipFormatStreamGeneration( FALSE );

                ((CG_INTERFACE *)pCG)->OutputInterfaceIdComment( pCCB );
                ((CG_INTERFACE *)pCG)->GenServerInfo( pCCB );

                if ( ((CG_INTERFACE *)pCG)->HasInterpretedProc() )
                    HasInterpretedProc = TRUE;
                }
            }
        }

    //
    // Output the tables that may be common to several interfaces.

    pCCB->SetCodeGenSide( CGSIDE_SERVER );

    Out_NotifyTable( pCCB );

    ResetNoOutputIn2ndCodegen( pCCB );

    //
    // If there was at least one interpreted proc in the interfaces of this
    // file than make sure to turn the optimization bit in the CCB's
    // OptimOption on.
    //
    EmitFixupToFormatStringTypedefs( pCCB );

    if ( HasInterpretedProc )
        pCCB->SetOptimOption( unsigned short( pCCB->GetOptimOption() | OPTIMIZE_INTERPRETER ) );

    // REVIEW: The externs may not be necessary anymore
    pCCB->OutputExternsToMultipleInterfaceTables();
    pCCB->OutputMultipleInterfaceTables();

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->GetCGID() == ID_CG_INTERFACE )
            {
            if ( ! ((CG_INTERFACE *)pCG)->HasPicklingStuffOnly() )
                {
                ((CG_INTERFACE *)pCG)->OutputServerStub( pCCB );
                }
            }
        }


    EmitFileClosingBlock( pCCB );

    return CG_OK;
}


class GUID_DICTIONARY   : public Dictionary
    {
public:
                GUID_DICTIONARY()
                    {
                    }

    virtual
    SSIZE_T     Compare (pUserType p1, pUserType p2)
                    {
                    INTERNAL_UUID   *   u1  = &( ((CG_INTERFACE *)p1)->GetGuidStrs().Value );
                    INTERNAL_UUID   *   u2  = &( ((CG_INTERFACE *)p2)->GetGuidStrs().Value );

                    return memcmp( u1, u2, 16 );
                    }


    };

void
CG_PROXY_FILE::MakeImplementedInterfacesList( CCB* )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Make a list of all the interfaces supported by this proxy file
    ( non-inherited, non-local interfaces ).

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_INTERFACE        *    pCG;
    CG_ITERATOR                I;
    GUID_DICTIONARY            GuidDict;

    // work directly on the real list
    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->GetCGID() != ID_CG_OBJECT_INTERFACE )
            continue;

        // Note that we don't need proxies and stubs for a pipe interface.

        if ( ((CG_OBJECT_INTERFACE*)pCG)->IsLocal() )
            continue;

        GuidDict.Dict_Insert( pCG );
        }

    GuidDict.Dict_GetList( ImplementedInterfaces );
    GuidDict.Dict_Discard();
}

void
CG_FILE::EvaluateVersionControl()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Calculates HasStublessProxies and Oi2 flags only through the
    interfaces.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:
 Notes:

----------------------------------------------------------------------------*/
{
    if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT ) ||
          pCommand->GetNdrVersionControl().HasStublessProxies() )
        GetNdrVersionControl().SetHasStublessProxies();

    if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) ||
          pCommand->GetNdrVersionControl().HasOi2() )
        GetNdrVersionControl().SetHasOi2();

    CG_ITERATOR         I;
    CG_NDR        *     pCG;
    CG_INTERFACE  *     pIntf;

    if( !GetMembers( I ) )
        {
        return;
        }

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pIntf = (CG_INTERFACE *)pCG;

        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
            case ID_CG_INHERITED_OBJECT_INTERFACE:
            case ID_CG_OBJECT_INTERFACE:
                pIntf->EvaluateVersionControl();

                if ( pIntf->HasStublessProxies() )
                    GetNdrVersionControl().SetHasStublessProxies();
                if ( pIntf->GetNdrVersionControl().HasOi2() )
                    GetNdrVersionControl().SetHasOi2();
                break;

            default:
                break;
            }
        }

    if ( GetNdrVersionControl().HasStublessProxies() )
        pCommand->GetNdrVersionControl().SetHasStublessProxies();
    if ( GetNdrVersionControl().HasOi2() )
        pCommand->GetNdrVersionControl().SetHasOi2();
}

CG_STATUS
CG_PROXY_FILE::GenCode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a proxy file containing the proxies and stubs for
    the [object] interfaces defined in the IDL file.

 Arguments:

    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR I;
    CG_NDR *    pCG;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];
    unsigned long index = 0;

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    ISTREAM     Stream( GetFileName(), 4 );
    ISTREAM *    pStream        = &Stream;

    pCCB->SetStream( pStream, this );

    // Set HasStublessProxies and HasOi2 for each interface.

    EvaluateVersionControl();

    EmitFileHeadingBlock( pCCB, "the proxy stub code" );

    SetNoOutputIn2ndCodegen( pCCB );
    //
    // Check if midl was invoked with -O1.  This means we can create
    // binaries using stubless proxies (if also compiled -Oi).  These
    // proxies will not work on 807.
    //
    if ( GetNdrVersionControl().HasStublessProxies() )
        {
        pStream->NewLine();
        pStream->Write( "#define USE_STUBLESS_PROXY" );

        pStream->NewLine();
        }


    // rpcproxy.h version guard
    pStream->NewLine(2);
    char sz[192];
    pStream->Write( GetRpcProxyHVersionGuard( sz ) );

    //
    // Emit the hash includes.
    //
    Out_IncludeOfFile( pCCB, "rpcproxy.h", FALSE );

    // rpcproxy.h version guard
    char *sz2 = "\n"
                "#ifndef __RPCPROXY_H_VERSION__\n"
                "#error this stub requires an updated version of <rpcproxy.h>\n"
                "#endif // __RPCPROXY_H_VERSION__\n\n";
    pStream->Write( sz2 );

    _splitpath( GetHeaderFileName(), Drive, Path, Name, Ext );
    strcpy( Buffer, Name );
    strcat( Buffer, Ext );
    Out_IncludeOfFile( pCCB, Buffer, FALSE );

    EmitFormatStringTypedefs( pCCB );

    Out_TransferSyntaxDefs( pCCB );
    //
    // Emit the external variables needed.
    //

    pStream->NewLine();

    //
    // Emit the format string extern declarations.
    //
    Out_FormatInfoExtern( pCCB );
    Out_TypeFormatStringExtern( pCCB );
    Out_ProcFormatStringExtern( pCCB );

    pCCB->ClearOptionalExternFlags();

    pStream->NewLine();

    pCCB->SetFileCG(this);

    MIDL_ASSERT( pCommand->IsNDR64Run() || pCommand->IsNDRRun() );

    if ( pCommand->IsNDR64Run() )
        {
        pCCB->SetFormatString( NULL );
        pCCB->SetProcFormatString( NULL );
        pCCB->SetNdr64Format( GenNdr64Format::CreateInstance( pCCB ) );
        }

    else
        {

        //
        // Create a new format string object if it does not yet exist.
        //
        if ( !pCCB->GetFormatString() )
        {
            pCCB->SetFormatString( new FORMAT_STRING() );

            // push a dummy short 0 at the beginning. This disambiguates
            // the case where offset 0 means recursion and a valid offset
//            if ( !pCommand->IsSwitchDefined( SWITCH_INTERNAL ) )
//                {
                pCCB->GetFormatString()->PushShort( ( short ) 0 );
//                }
        }

        if ( !pCCB->GetProcFormatString() )
        {
            pCCB->SetProcFormatString( new FORMAT_STRING() );
        }

        }

    // make the list of interfaces provided by this proxy file
    MakeImplementedInterfacesList( pCCB );

    //
    // Send the message to the children to emit code.
    //

    //
    // generate code for all [object] interfaces in the IDL file.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INHERITED_OBJECT_INTERFACE:
                {
                CG_INHERITED_OBJECT_INTERFACE * pInhObjCG =
                              ( CG_INHERITED_OBJECT_INTERFACE * ) pCG;
                //
                // Generate format string description for all procs.
                //
                pInhObjCG->GenProxy( pCCB );
                break;
                }
            case ID_CG_OBJECT_INTERFACE:
                {
                CG_OBJECT_INTERFACE * pObjCG;

                pObjCG = (CG_OBJECT_INTERFACE *) pCG;

                // make no code or tables for local interfaces
                pObjCG->GenProxy( pCCB );
                if ( pObjCG->IsLocal()  )
                    break;

                index++;   // index is index in stub/proxy buffer tables
                break;
                }
            default:
                break;
            }
        }

    Out_NotifyTable( pCCB );

    pCCB->SetSkipFormatStreamGeneration( FALSE );

    pStream->NewLine();
//  BUGBUG: figure out where to put this. yongqu
//    pStream->Write( "#pragma data_seg(\".rdata\")" );
//    pStream->NewLine();

    ResetNoOutputIn2ndCodegen( pCCB );

    pCCB->OutputExternsToMultipleInterfaceTables();

    EmitFixupToFormatStringTypedefs( pCCB );

    pCCB->OutputMultipleInterfaceTables();

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                ((CG_INTERFACE *)pCG)->OutputInterfaceIdComment( pCCB );
                break;

            case ID_CG_INHERITED_OBJECT_INTERFACE:
                {
                CG_INHERITED_OBJECT_INTERFACE * pInhObjCG =
                              ( CG_INHERITED_OBJECT_INTERFACE * ) pCG;
                //
                // Generate format string description for all procs.
                //
                pInhObjCG->OutputInterfaceIdComment( pCCB );
                pInhObjCG->OutputProxy( pCCB );
                // make no code or tables for local interfaces
                if ( pInhObjCG->IsLocal() )
                    break;

                //
                // Both of these do nothing right now.  4/25.
                //
                pInhObjCG->GenInterfaceProxy( pCCB, index );
                pInhObjCG->GenInterfaceStub( pCCB, index );
                break;
                }

            case ID_CG_OBJECT_INTERFACE:
                {
                CG_OBJECT_INTERFACE * pObjCG;

                pObjCG = (CG_OBJECT_INTERFACE *) pCG;

                // make no code or tables for local interfaces
                pObjCG->OutputInterfaceIdComment( pCCB );
                pObjCG->OutputProxy( pCCB );
                if ( pObjCG->IsLocal()  )
                    break;

                pObjCG->GenInterfaceProxy( pCCB, index );   // index is not used
                pObjCG->GenInterfaceStub( pCCB, index );    // index is not used

                index++;   // index is index in stub/proxy buffer tables
                break;
                }

            default:
                break;
            }
        }

    Out_StubDescriptor(0, pCCB);

    if ( pCommand->IsFinalProtocolRun() )
        Out_ProxyFileInfo(pCCB);

    EmitFileClosingBlock( pCCB );

    UpdateDLLDataFile( pCCB );

    return CG_OK;
}

void
CG_HDR_FILE::OutputImportIncludes(
    CCB     *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the header file.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    none.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR    *       pImpList    = GetImportList();
    node_file   *       pIFile;
    ISTREAM     *       pStream     = pCCB->GetStream();
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];

    if( pImpList && pImpList->NonNull() )
        {

        pStream->NewLine();
        pStream->Write( "/* header files for imported files */" );

        pImpList->Init();
        while( ITERATOR_GETNEXT( (*pImportList), pIFile ) )
            {
            pStream->NewLine();
            // if this was specified with ACF include, print out as is
            if ( pIFile->IsAcfInclude() )
                sprintf( Buffer, "#include \"%s\"", pIFile->GetSymName() );
            else if ( pIFile->HasComClasses() )
                {
                _splitpath( pIFile->GetSymName(), Drive, Path, Name, Ext );
                sprintf( Buffer, "#include \"%s_d.h\"", Name );
                }
            else
                {
                _splitpath( pIFile->GetSymName(), Drive, Path, Name, Ext );
                sprintf( Buffer, "#include \"%s.h\"", Name );
                }
            pStream->Write( Buffer );
            }

        pStream->NewLine();
        }
}


void OutputInterfaceForwards(
    ISTREAM  * pStream,
    CG_ITERATOR & I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the forwards section of the header file.

 Arguments:

    pCCB    - The code gen controller block.
    I       - an iterator for the nodes to process

 Return Value:

    none.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_INTERFACE *  pCG;
    char *          pszInterfaceName;
    ID_CG           id;

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        id = pCG->GetCGID();
        switch( id )
            {
            case ID_CG_INTERFACE:
            case ID_CG_INHERITED_OBJECT_INTERFACE:
                break;

            case ID_CG_OBJECT_INTERFACE:
            case ID_CG_DISPINTERFACE:
            case ID_CG_COCLASS:
                pszInterfaceName = pCG->GetType()->GetSymName();

                pStream->NewLine();

                // put out the interface guards
                pStream->Write("\n#ifndef __");
                pStream->Write( pszInterfaceName );
                pStream->Write( "_FWD_DEFINED__\n" );

                pStream->Write( "#define __");
                pStream->Write( pszInterfaceName );
                pStream->Write( "_FWD_DEFINED__\n" );

                // put out the forward definition
                if ( ID_CG_COCLASS == id )
                    {
                    pStream->Write("\n#ifdef __cplusplus\n");
                    pStream->Write("typedef class ");
                    pStream->Write(pszInterfaceName);
                    pStream->Write(' ');
                    pStream->Write(pszInterfaceName);
                    pStream->Write(';');
                    pStream->Write("\n#else\n");
                    pStream->Write("typedef struct ");
                    pStream->Write(pszInterfaceName);
                    pStream->Write(' ');
                    pStream->Write(pszInterfaceName);
                    pStream->Write(';');
                    pStream->Write( "\n#endif /* __cplusplus */\n");
                    }
                else
                    {
                    pStream->Write("typedef interface ");
                    pStream->Write(pszInterfaceName);
                    pStream->Write(' ');
                    pStream->Write(pszInterfaceName);
                    pStream->Write(';');
                    }

                // put out the trailing interface guard
                pStream->Write( "\n#endif \t/* __");
                pStream->Write( pszInterfaceName );
                pStream->Write( "_FWD_DEFINED__ */\n" );

                break;

            case ID_CG_LIBRARY:
                {
                CG_ITERATOR Inner;
                if ( pCG->GetMembers( Inner ) )
                    {
                    OutputInterfaceForwards( pStream, Inner );
                    }

                break;
                }
            default:
                break;
            }
        }
}

#define NibbleToAscii(x)  ((x) >= 0x0A ? (x) + 'A' - 0x0A : (x) + '0')
#define IsAlphaNum_(x)    (((x) >= '0' && (x) <= '9') || ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') || (x) == '_')
#define IsNum(x) ( (x) >= '0' && (x) <= '9' )

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    Setup a flag (fIgnore) in STREAM no to write anything out .


 Arguments:


 Return Value:

    none.

 Notes:

    This routine is called to avoid generating the same data structure twice, in
    both NDR32 and NDR64 run.

----------------------------------------------------------------------------*/
void SetNoOutputIn2ndCodegen( CCB *pCCB)
{
    if ( pCommand->Is2ndCodegenRun() )
        {
        pCCB->GetStream()->SetIgnore();
        }
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    Reset Ignore flag in STREAM so Write will really write to the stream.


 Arguments:


 Return Value:

    none.

 Notes:

    This routine is called to avoid generating the same data structure twice, in
    both NDR32 and NDR64 run. This should be called after SetNoOutputInNdr64 to
    resume regular output to stream. Current I assume we'll already generate both.
    The correct checking should be Is2ndNdrRun().

----------------------------------------------------------------------------*/
void ResetNoOutputIn2ndCodegen( CCB *pCCB)
{
    if ( pCommand->Is2ndCodegenRun() )
        {
        pCCB->GetStream()->ResetIgnore();
        }
}

void NormalizeString(
    char*   szSrc,
    char*   szNrm )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Transform a string by converting spaces to underscores and other non-
    alphanumerics to thier hex representation.

 Arguments:

    szSrc   - The source string
    szNrm   - The normalized string

 Return Value:

    none.

 Notes:

    This routine is typically called when some generated variable is biased
    by the filename.  If the filename has a space or DBCS chars then the
    generated variable wouldn't conform to C/C++ naming rules.

----------------------------------------------------------------------------*/
{
    if ( IsNum(*szSrc) || !IsAlphaNum_(*szSrc) )
        *szNrm++ = '_';

    for ( ; *szSrc; szSrc++ )
        {
        if (IsAlphaNum_(*szSrc))
            {
            *szNrm++ = *szSrc;
            }
        else if (*szSrc == ' ')
            {
            *szNrm++ = '_';
            }
        else
            {
            unsigned char ch;

            ch = unsigned char( (*szSrc >> 4) & 0x0F );
            *szNrm++ = (char) NibbleToAscii(ch);
            ch = unsigned char(*szSrc & 0x0F);
            *szNrm++ = (char)NibbleToAscii(ch);
            }
        }
    *szNrm = 0;
}

CG_STATUS
CG_HDR_FILE::GenCode(
    CCB     *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the header file.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK   if all is well.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM         Stream( GetFileName(), 4 );
    ISTREAM    *    pStream = pCCB->SetStream( &Stream, this );
    CG_ITERATOR     I;
    CG_INTERFACE *  pCG;
    BOOL            fHasPickle = FALSE;
    BOOL            fHasObject = FALSE;
    char        Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    char        Drive[ _MAX_DRIVE ];
    char        Path[ _MAX_DIR ];
    char        Name[ _MAX_FNAME ];
    char        Ext[ _MAX_EXT ];

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    if ( pCommand->Is64BitEnv()  &&  pCommand->HasAppend64() )
        {
        // Don't generate the same h file definitions twice.
        return CG_OK;
        }

    EmitFileHeadingBlock( pCCB,
                          "the definitions for the interfaces",
                          0,        // optional comment
                          false );  // no 64 vs.32 ifdef

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        if ( pCG->HasPicklingStuff() )
            {
            fHasPickle = TRUE;
            }
        if ( pCG->IsObject() )
            {
            fHasObject = TRUE;
            }
        }

    // rpcndr.h version guard
    pStream->NewLine(2);
    char sz[192];
    pStream->Write( GetRpcNdrHVersionGuard( sz ) );

    // Include standard files.

    pStream->Write( "#include \"rpc.h\"\n#include \"rpcndr.h\"\n" );

    // rpcndr.h version guard
    if ( pCommand->GetNdrVersionControl().HasNdr50Feature() || fHasObject )
        {
        char *sz2 = "\n"
                    "#ifndef __RPCNDR_H_VERSION__\n"
                    "#error this stub requires an updated version of <rpcndr.h>\n"
                    "#endif // __RPCNDR_H_VERSION__\n\n";
        pStream->Write( sz2 );
        }

    // If there is at least one pickle interface, emit the include
    // of midles.h

    if ( fHasPickle )
        {
        pStream->Write( "#include \"midles.h\"\n" );
        }

    if ( fHasObject )
        {
        pStream->Write( "#ifndef COM_NO_WINDOWS_H\n");
        pStream->Write( "#include \"windows.h\"\n#include \"ole2.h\"\n" );
        pStream->Write( "#endif /*COM_NO_WINDOWS_H*/\n");
        }

    // extract the name and the extension to create the ifdefs

    _splitpath( GetFileName(), Drive, Path, Name, Ext );
    char        szNrmName[ _MAX_FNAME * 2 + 1 ];
    char        szNrmExt[ _MAX_EXT * 2 + 1 ];

    NormalizeString( Name, szNrmName );
    // ignore the '.' preceding the extension
    if ( '.' == Ext[0] )
        NormalizeString( &Ext[1], szNrmExt );
    else
        NormalizeString( Ext, szNrmExt );

    // Write out the #ifndefs and #defines
    pStream->NewLine();
    sprintf( Buffer,
             "#ifndef __%s_%s__\n#define __%s_%s__",
             szNrmName,
             szNrmExt,
             szNrmName,
             szNrmExt
           );

    pStream->Write( Buffer );
    pStream->NewLine( 2 );

    // Generate the #pragma once.
    pStream->Write( "#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n" );
    pStream->Write( "#pragma once\n#endif" );
    pStream->NewLine(2);

    //Generate forward declarations for object interfaces.
    pStream->Write("/* Forward Declarations */ ");
    I.Init();
    OutputInterfaceForwards( pStream, I );
    pStream->NewLine();

    // Include the import files.
    OutputImportIncludes( pCCB );
    pStream->NewLine();

    // Write out the cplusplus guard.
    pStream->Write( "#ifdef __cplusplus\nextern \"C\"{\n#endif " );
    pStream->NewLine( 2 );

    pStream->Write(
         "void * __RPC_USER MIDL_user_allocate(size_t);" );
    pStream->NewLine();
    pStream->Write(
         "void __RPC_USER MIDL_user_free( void * ); " );

    pStream->NewLine();

    //
    // For all interfaces in this file, generate code.
    //

    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
            case ID_CG_OBJECT_INTERFACE:
            case ID_CG_LIBRARY:
                pCG->GenHeader( pCCB );
            case ID_CG_INHERITED_OBJECT_INTERFACE:
            default:
                break;
            }
        }

    // put out all the prototypes that are only needed once
    OutputMultipleInterfacePrototypes( pCCB );

    // print out the closing endifs.
    // first the cplusplus stuff.

    pStream->Write( "#ifdef __cplusplus\n}\n#endif\n" );

    // The endif for the file name ifndef

    pStream->NewLine();

    pStream->Write( "#endif" );
    pStream->NewLine();

    EmitFileClosingBlock( pCCB, false );

    pStream->Close();

    return CG_OK;
}

void
CG_HDR_FILE::OutputMultipleInterfacePrototypes(
    CCB     *   pCCB )

{
    ITERATOR        I;
    ITERATOR        UserI;
    ISTREAM     *   pStream     = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("/* Additional Prototypes for ALL interfaces */");
    pStream->NewLine();

    // ALERT! we are using the same iterator for all different type of objects,
    // so none of code below should Init the list or it'll step into something else.
    // Use a new iterator if you need to rewind the list.
    if( pCCB->GetListOfGenHdlTypes( I ) )
        {
        Out_GenHdlPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfCtxtHdlTypes( I ) )
        {
        Out_CtxtHdlPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfPresentedTypes( I ) )
        {
        Out_TransmitAsPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfRepAsWireTypes( I ) )
        {
        Out_RepAsPrototypes( pCCB, I );
        }

    if( pCCB->GetQuadrupleDictionary()->GetListOfItems( UserI ) )
        {
        Out_UserMarshalPrototypes( pCCB, UserI );
        }

    Out_CSSizingAndConversionPrototypes( pCCB, pCCB->GetCsTypeList() );

    if( pCCB->GetListOfTypeAlignSizeTypes( I ) )
        {
        Out_TypeAlignSizePrototypes( pCCB, I );
        }

    if( pCCB->GetListOfTypeEncodeTypes( I ) )
        {
        Out_TypeEncodePrototypes( pCCB, I );
        }

    if( pCCB->GetListOfTypeDecodeTypes( I ) )
        {
        Out_TypeDecodePrototypes( pCCB, I );
        }

    if( pCCB->GetListOfTypeFreeTypes( I ) )
        {
        Out_TypeFreePrototypes( pCCB, I );
        }

    if ( pCCB->GetListOfCallAsRoutines( I ) )
        {
        Out_CallAsProxyPrototypes( pCCB, I );
        }

    if ( pCCB->GetListOfCallAsRoutines( I ) )
        {
        Out_CallAsServerPrototypes( pCCB, I );
        }

    if( pCCB->GetListOfNotifyTableEntries( I ) )
        {
        Out_NotifyPrototypes( pCCB, I );
        }

    pStream->NewLine();
    pStream->Write("/* end of Additional Prototypes */");
    pStream->NewLine( 2 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\iid.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

 	iid.cxx

 Abstract:

	Generate a file containing UUIDs of [object] interfaces.

 Notes:


 History:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

CG_STATUS
CG_IID_FILE::GenCode(
	CCB		*	pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the IID file.

 Arguments:

 	pCCB	- The code gen controller block.
	
 Return Value:

 	CG_OK	if all is well.
	
 Notes:

----------------------------------------------------------------------------*/
{
	ISTREAM				Stream( GetFileName(), 4 );
	ISTREAM	*			pStream = pCCB->SetStream( &Stream, this );
	CG_INTERFACE	*	pIntf;

	EmitFileHeadingBlock( pCCB, 
                          "the IIDs and CLSIDs",
                          "link this file in with the server and any clients" );


	// Write out the cplusplus guard.

	pStream->NewLine( 2 );
	pStream->Write( "#ifdef __cplusplus\nextern \"C\"{\n#endif " );
	pStream->NewLine( 2 );

	// Print out the declarations of the types and the procedures.

    const char * DefinitionBlock[] = 
    {
        "#include <rpc.h>"
       ,"#include <rpcndr.h>"
       ,""
       ,"#ifdef _MIDL_USE_GUIDDEF_"
       ,""
       ,"#ifndef INITGUID"
       ,"#define INITGUID"
       ,"#include <guiddef.h>"
       ,"#undef INITGUID"
       ,"#else"
       ,"#include <guiddef.h>"
       ,"#endif"
       ,""
       ,"#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \\"
       ,"        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)"
       ,""
       ,"#else // !_MIDL_USE_GUIDDEF_"
       ,""
       ,"#ifndef __IID_DEFINED__"
       ,"#define __IID_DEFINED__"
       ,""
       ,"typedef struct _IID"
       ,"{"
       ,"    unsigned long x;"
       ,"    unsigned short s1;"
       ,"    unsigned short s2;"
       ,"    unsigned char  c[8];"
       ,"} IID;"
       ,""
       ,"#endif // __IID_DEFINED__"
       ,""
       ,"#ifndef CLSID_DEFINED"
       ,"#define CLSID_DEFINED"
       ,"typedef IID CLSID;"
       ,"#endif // CLSID_DEFINED"            
       ,""
       ,"#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \\"
       ,"        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}"
       ,""
       ,"#endif !_MIDL_USE_GUIDDEF_"
       ,""
       ,NULL
    };
     
    pStream->WriteBlock(DefinitionBlock);
    
	pIntf	=	(CG_INTERFACE*) GetChild();

	while ( pIntf )
		{
        node_interface * pIntfNode = (node_interface *) pIntf->GetType();
        if (!pIntfNode->PrintedIID())
            {
		    switch ( pIntf->GetCGID() )
			    {
                case ID_CG_DISPINTERFACE:
                    {
                    CG_DISPINTERFACE * pDI = (CG_DISPINTERFACE *)pIntf;
                    node_dispinterface * pType = (node_dispinterface *) pDI->GetType();
                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(IID, DIID_");
                    pStream->Write(pDI->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
                    pIntfNode->SetPrintedIID();
	    
                    break;
                    }
                case ID_CG_COCLASS:
                    {
                    CG_COCLASS * pCoclass = (CG_COCLASS *)pIntf;
                    node_coclass * pType = (node_coclass *) pCoclass->GetType();
                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(CLSID, CLSID_");
                    pStream->Write(pCoclass->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
                    pIntfNode->SetPrintedIID();
	    
                    break;
                    }
			    case ID_CG_OBJECT_INTERFACE:
				    {
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(IID, IID_");
                    pStream->Write(pIntf->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pIntf->GetGuidStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
                    pIntfNode->SetPrintedIID();

				    break;
				    }
                case ID_CG_LIBRARY:
                    {
                    CG_LIBRARY * pLib = (CG_LIBRARY *)pIntf;
                    node_library * pType = (node_library *) pLib->GetType();
                    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
                    pStream->NewLine();
                    pStream->Write("MIDL_DEFINE_GUID(IID, LIBID_");
                    pStream->Write(pLib->GetSymName());
                    pStream->Write(',');
                    Out_Guid(pCCB, pGuid->GetStrs(), GUIDFORMAT_RAW);
                    pStream->Write(");");
                    pStream->NewLine(2);
	                CG_NDR * pChild	=	(CG_NDR*) pLib->GetChild();
                    pIntfNode->SetPrintedIID();

	                while ( pChild )
		                {
                        node_interface * pChildType = (node_interface *) pChild->GetType();
                        if (!pChildType->PrintedIID())
                            {
		                    switch ( pChild->GetCGID() )
			                    {
			                    case ID_CG_OBJECT_INTERFACE:
				                    {
                                    if (!pChildType->PrintedIID())
                                        {
                                        pStream->NewLine();
                                        pStream->Write("MIDL_DEFINE_GUID(IID, IID_");
				                        pStream->Write(pChild->GetSymName());
				                        pStream->Write(',');
				                        Out_Guid(pCCB, ((CG_INTERFACE*)pChild)->GetGuidStrs(), GUIDFORMAT_RAW );
            				            pStream->Write(");");
				                        pStream->NewLine(2);
                                        pChildType->SetPrintedIID();
                                        }
				                    break;
				                    }
                                case ID_CG_DISPINTERFACE:
                                    {
                                    CG_DISPINTERFACE * pDI = (CG_DISPINTERFACE *)pChild;
                                    node_dispinterface * pIntfType = (node_dispinterface *) pDI->GetType();
                                    node_guid * pIntfGuid = (node_guid *) pIntfType->GetAttribute( ATTR_GUID );
                                    pStream->NewLine();
                                    pStream->Write("MIDL_DEFINE_GUID(IID, DIID_"); 
                                    pStream->Write(pDI->GetSymName());
                                    pStream->Write(',');
                                    Out_Guid(pCCB, pIntfGuid->GetStrs(), GUIDFORMAT_RAW);
                                    pStream->Write(");");
                                    pStream->NewLine(2);
                                    pChildType->SetPrintedIID();
	                    
                                    break;
                                    }
                                case ID_CG_COCLASS:
                                    {
                                    CG_COCLASS * pCoclass = (CG_COCLASS *)pChild;
                                    node_coclass * pClassType = (node_coclass *) pCoclass->GetType();
                                    node_guid * pClassfGuid = (node_guid *) pClassType->GetAttribute( ATTR_GUID );
                                    pStream->NewLine();
                                    pStream->Write("MIDL_DEFINE_GUID(CLSID, CLSID_");
                                    pStream->Write(pCoclass->GetSymName());
                                    pStream->Write(',');
                                    Out_Guid(pCCB, pClassfGuid->GetStrs(), GUIDFORMAT_RAW);
                                    pStream->Write(");");
                                    pStream->NewLine(2);
                                    pChildType->SetPrintedIID();
	                    
                                    break;
                                    }
                                case ID_CG_INTERFACE:
			                    case ID_CG_INHERITED_OBJECT_INTERFACE:
			                    default:
				                    break;
			                    }
                            }
		                pChild = (CG_INTERFACE *) pChild->GetSibling();
        		        }
                    }
			    case ID_CG_INTERFACE:
			    case ID_CG_INHERITED_OBJECT_INTERFACE:
			    default:
				    break;
			    }
            } // if pIntfNode not printed

        pIntf = (CG_INTERFACE *) pIntf->GetSibling();
        } // while

	// print out the closing endifs.
    // the MIDL_DEFINE_GUID stuff.
    pStream->Write( "#undef MIDL_DEFINE_GUID" );
    pStream->NewLine();
	// the cplusplus stuff.
	pStream->NewLine();
	pStream->Write( "#ifdef __cplusplus\n}\n#endif\n" );
	pStream->NewLine();

	EmitFileClosingBlock( pCCB );

	pStream->Close();

	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ilanaly.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:

    ilanaly.cxx

 Abstract:

    Intermediate langangage analyzer/optimizer

 Notes:


 Author:

    mzoran Nov-11-1999 Created.

 Notes:

 This module takes an IL tree from IL translation and fixes the tree for correctness and
 optimizes the tree for performance.   Neither of these steps would be easy to do during 
 translation because of recursion and node reuse.  This module works around that problem by 
 first analyzing the nodes with the assumption that pointers do not propagate attributes, and
 then regenerating parts of the tree.
 
 Here are the steps.
 
 1. IL translation. Generic nodes are created, but variance, conformance, and complexity 
    are not determined yet.
 2. IL analysis.  Nodes are analyzed with recursion stopping at pointers.
 3. IL translation. Each node is converted exactly one. Variance, conformance, and 
    complexity are determined.  Simple structures are unrolled, and complex structures
    and regionalized.           
 ----------------------------------------------------------------------------*/
 
#include "becls.hxx"
#pragma hdrstop

extern  BOOL                            IsTempName( char *);

typedef  gplistmgr                      CG_UNROLLED_LIST;

typedef PTR_MAP<CG_CLASS,CG_CLASS> CG_ILCLASS_MAP;
typedef PTR_SET<CG_CLASS> CG_ILANALYSIS_SET;

void CG_ILANALYSIS_INFO::MergeAttributes( CG_ILANALYSIS_INFO *pMerge )
{
    if (pMerge->IsConformant())                SetIsConformant();
    if (pMerge->IsVarying())                   SetIsVarying();
    if (pMerge->IsForcedBogus())               SetIsForcedBogus();
    if (pMerge->IsFullBogus())                 SetIsFullBogus();
    if (pMerge->IsMultiDimensional())          SetIsMutiDimensional();
    if (pMerge->HasUnknownBuffer())            SetHasUnknownBuffer();
    if (pMerge->IsArrayofStrings())            SetIsArrayofStrings();
}

void ILUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pList );


// 
//
//
//  Analysis STAGE 1
//
//  Analyze the IL nodes and mark them with attributes of interest.
//
//  Note:  Analysis only works if attributes do not propagate past pointers.  This
//         is necessary since pointers are used as a cutoff point during recursion.

enum _ILANALYSIS_ANCESTOR_FLAGS
{
  ILANALYSIS_IN_NOTHING               = 0,
  ILANALYSIS_IN_ARRAY                 = (1 << 0), // Directly under an array 
  ILANALYSIS_IN_ARRAY_CONFORMANCE     = (1 << 1), // Directly under a conformant array
  ILANALYSIS_IN_ARRAY_VARIANCE        = (1 << 2), // Directly under an array with variance
  ILANALYSIS_IN_EVERYTHING            = ((1 << 3) - 1)
};

typedef unsigned long ILANALYSIS_ANCESTOR_FLAGS; 

enum _ILANALYSIS_DESCENDANT_FLAGS
{
  ILANALYSIS_HAS_NOTHING              = 0,
  ILANALYSIS_HAS_ARRAY                = (1 << 0), // No struct/union/ptr between child array
  ILANALYSIS_HAS_ARRAY_CONFORMANCE    = (1 << 1), // No struct/union/ptr between child conf array
  ILANALYSIS_HAS_ARRAY_VARIANCE       = (1 << 2), // No struct/union/ptr between child var array
  ILANALYSIS_HAS_STRING               = (1 << 3), // No struct/union/ptr between child string
  ILANALYSIS_HAS_STRUCT_CONFORMANCE   = (1 << 4), // No ptr between child conf struct
  ILANALYSIS_HAS_STRUCT_VARIANCE      = (1 << 5), // No ptr between child var struct
  ILANALYSIS_HAS_FULL_BOGUS           = (1 << 6), // No ptr between fullbogus child
  ILANALYSIS_HAS_FORCED_BOGUS         = (1 << 7), // No ptr between forced bogus child
  ILANALYSIS_HAS_POINTER              = (1 << 8), // Child has pointer
  ILANALYSIS_HAS_UNKNOWN_BUFFER       = (1 << 9), // Buffer size is unknown
  ILANALYSIS_HAS_POINTER_ARRAY        = (1 << 10),// No ptr between array with pointers
  ILANALYSIS_HAS_EVERYTHING           = ((1 << 11) - 1)
};

typedef unsigned long ILANALYSIS_DESCENDANT_FLAGS;

typedef struct 
{
  ILANALYSIS_ANCESTOR_FLAGS ParentReceiveMask;  // Flags that should be received from parent.
  ILANALYSIS_ANCESTOR_FLAGS ChildPassMask;      // Flags that should be passed to child.
  ILANALYSIS_DESCENDANT_FLAGS ChildReceiveMask; // Flags that should be received from child.  
  ILANALYSIS_DESCENDANT_FLAGS ParentPassMask;   // Flags that should be passed to parent.

} ILANALYSIS_FLAGS_MASK;

const ILANALYSIS_FLAGS_MASK ILANALYSIS_PASS_EVERYTHING_FLAGS = 
    {
    ILANALYSIS_IN_EVERYTHING,
    ILANALYSIS_IN_EVERYTHING,
    ILANALYSIS_HAS_EVERYTHING,
    ILANALYSIS_HAS_EVERYTHING
    };

const ILANALYSIS_FLAGS_MASK ILANALYSIS_BLOCK_EVERYTHING_FLAGS =
    {
    ILANALYSIS_IN_NOTHING,
    ILANALYSIS_IN_NOTHING,
    ILANALYSIS_HAS_NOTHING,
    ILANALYSIS_HAS_NOTHING
    };

class CG_ILANALYSIS_VISITOR
{

protected:

   CG_ILANALYSIS_VISITOR *pParentCtxt;
   ILANALYSIS_ANCESTOR_FLAGS AncestorFlags;
   ILANALYSIS_DESCENDANT_FLAGS DescendantFlags;
   const ILANALYSIS_FLAGS_MASK *pFlagsMask;
   unsigned long Dimensions;

   CG_ILANALYSIS_SET *pRecursiveSet;

   void PropagateInfo( const ILANALYSIS_FLAGS_MASK *pFlags );
   void ContinueAnalysis( CG_CLASS *pClass );
   CG_ILANALYSIS_INFO* GetAnalysisInfo( CG_CLASS *pClass ) {return pClass->GetILAnalysisInfo(); }
   void PropagateInfoToParent( );

   BOOL AnyAncestorFlags(ILANALYSIS_ANCESTOR_FLAGS Flags) { return Flags & AncestorFlags; }
   BOOL AnyDescendantFlags(ILANALYSIS_DESCENDANT_FLAGS Flags) { return Flags & DescendantFlags; }
   void ClearAncestorFlags(ILANALYSIS_ANCESTOR_FLAGS Flags) 
       { AncestorFlags &= ~Flags;}
   void ClearDescendantFlags(ILANALYSIS_DESCENDANT_FLAGS Flags)
       { DescendantFlags &= ~Flags;}
   void AddAncestorFlags( ILANALYSIS_ANCESTOR_FLAGS NewAncestorFlags )
       { AncestorFlags |= NewAncestorFlags; }
   void AddDescendantFlags( ILANALYSIS_ANCESTOR_FLAGS NewDescendantFlags )
       { DescendantFlags |= NewDescendantFlags; }
   unsigned long GetDimensions( ) { return Dimensions; }
   void SetDimensions(unsigned long Dims ) { Dimensions = Dims;}


   ILANALYSIS_ANCESTOR_FLAGS GetFlagsForChild() 
       {
       return AncestorFlags & pFlagsMask->ChildPassMask;
       }
   void SetFlagsFromChild(  ILANALYSIS_DESCENDANT_FLAGS ChildFlags ) 
       {
       AddDescendantFlags( ChildFlags & 
                          pFlagsMask->ChildReceiveMask );
       }

public:


   void Visit( CG_BASETYPE *pClass );
   void Visit( CG_HANDLE *pClass );
   void Visit( CG_GENERIC_HANDLE *pClass );
   void Visit( CG_CONTEXT_HANDLE *pClass );
   void Visit( CG_IGNORED_POINTER *pClass );
   void Visit( CG_CS_TAG *pClass );
   void Visit( CG_CLASS *pClass );
   void Visit( CG_PROC *pClass );
   void Visit( CG_TYPEDEF *pClass );
   void Visit( CG_STRUCT *pClass );
   void Visit( CG_UNION *pClass );
   void Visit( CG_ARRAY *pClass );
   void Visit( CG_STRING_ARRAY *pClass );
   void Visit( CG_CONFORMANT_ARRAY *pClass );
   void Visit( CG_CONFORMANT_STRING_ARRAY *pClass );
   void Visit( CG_VARYING_ARRAY *pClass );
   void Visit( CG_CONFORMANT_VARYING_ARRAY *pClass );
   void Visit( CG_FIXED_ARRAY *pClass );
   void Visit( CG_POINTER *pClass );
   void Visit( CG_BYTE_COUNT_POINTER *pClass );
   void Visit( CG_LENGTH_POINTER *pClass );
   void Visit( CG_INTERFACE_POINTER *pClass );
   void Visit( CG_QUALIFIED_POINTER *pClass );
   void Visit( CG_STRING_POINTER *pClass );
   void Visit( CG_SIZE_POINTER *pClass );
   void Visit( CG_SIZE_STRING_POINTER *pClass ); 
   void Visit( CG_SIZE_LENGTH_POINTER *pClass );
   void Visit( CG_FIELD *pClass );
   void Visit( CG_CASE *pClass );

   static void StartAnalysis( CG_CLASS *pClass );
};

void CG_ILANALYSIS_VISITOR::StartAnalysis( CG_CLASS *pClass )
{
   CG_ILANALYSIS_SET RecursiveSet;

   CG_VISITOR_TEMPLATE<CG_ILANALYSIS_VISITOR> TemplateVisitor;
   CG_ILANALYSIS_VISITOR & Visitor = TemplateVisitor;

   Visitor.pParentCtxt = NULL;
   Visitor.pRecursiveSet = &RecursiveSet;
   Visitor.AncestorFlags = ILANALYSIS_IN_NOTHING;
   Visitor.DescendantFlags = ILANALYSIS_HAS_NOTHING;
   Visitor.pFlagsMask = NULL;

   if ( NULL != pClass)   
       {
       pClass->Visit( &TemplateVisitor );       
       }
}

void CG_ILANALYSIS_VISITOR::ContinueAnalysis( CG_CLASS *pClass )
{
   
   // Some classes have a NULL child in special cases.  In instead
   // of putting this check everywhere, just put it in this central 
   // location.
   if ( NULL != pClass )
       {
       CG_VISITOR_TEMPLATE<CG_ILANALYSIS_VISITOR> TemplateVisitor;
       CG_ILANALYSIS_VISITOR & Visitor = TemplateVisitor;
       
       Visitor.pParentCtxt = this;
       Visitor.pRecursiveSet = this->pRecursiveSet;
       Visitor.AncestorFlags = ILANALYSIS_IN_NOTHING;
       Visitor.DescendantFlags = ILANALYSIS_HAS_NOTHING;
       Visitor.pFlagsMask = NULL;
    
       pClass->Visit( &TemplateVisitor );
    
       Visitor.PropagateInfoToParent();
       }
}

void CG_ILANALYSIS_VISITOR::PropagateInfo( const ILANALYSIS_FLAGS_MASK *pFlags )
{
    pFlagsMask = pFlags;
	if (NULL != pParentCtxt)
        {
        Dimensions = 0;
        AddAncestorFlags( pParentCtxt->GetFlagsForChild() &
                          pFlagsMask->ParentReceiveMask );
        }
}

void CG_ILANALYSIS_VISITOR::PropagateInfoToParent() 
{
    if ( ( pFlagsMask != NULL ) && ( pParentCtxt != NULL ) )
        {
        pParentCtxt->Dimensions = Dimensions;
        pParentCtxt->SetFlagsFromChild( DescendantFlags &
                                pFlagsMask->ParentPassMask );        
        }
}


//
//
// Leaf Nodes
// 

//
// Basetype
// CG_BASETYE
// CG_INT3264
// CG_ENUM
// CG_HRESULT

void CG_ILANALYSIS_VISITOR::Visit( CG_BASETYPE *pClass )
{
    PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

    if (pClass->GetMemorySize() != pClass->GetWireSize())
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    if ( pClass->GetRangeAttribute() )
        AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );
}
            
// CG_HANDLE
// CG_PRIMITIVE_HANDLE

void CG_ILANALYSIS_VISITOR::Visit( CG_HANDLE *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

   if (pClass->GetMemorySize() != pClass->GetWireSize())
       AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_GENERIC_HANDLE *pClass )
{
   Visit( (CG_HANDLE*) pClass );
   AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONTEXT_HANDLE *pClass )
{
   Visit( (CG_HANDLE*) pClass );
   AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_IGNORED_POINTER *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );
   
   AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );

   if (pClass->GetMemorySize() != pClass->GetWireSize())
       AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CS_TAG *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );  
    
   if (pClass->GetMemorySize() != pClass->GetWireSize())
       AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
}

//
// General Catchall cases.   No attributes are propagated.
// CG_CLASS
// CG_NDR
// CG_AUX
// CG_SOURCE
// CG_COCLASS
// CG_MODULE
// CG_SAFEARRAY
//
// Files
// CG_FILE
// CG_SSTUB_FILE
// CG_HDR_FILE
// CG_CSTUB_FILE
// CG_IID_FILE
// CG_NETMONSTUB_FILE
// CG_PROXY_FILE
// CG_TYPELIBRARY_FILE
//
// Interfaces
// CG_INTERFACE
// CG_OBJECT_INTERFACE
// CG_DISPINTERFACE
// CG_INHERITED_OBJECT_INTERFACE
// CG_INTERFACE_REFERENCE
// CG_IUNKNOWN_OBJECT_INTERFACE
// CG_ASYNC_HANDLE
// CG_ID
// 
// Parameters
// CG_PARAM
// CG_RETURN

void CG_ILANALYSIS_VISITOR::Visit( CG_CLASS *pClass )
{
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

   CG_ITERATOR Iterator;
   CG_CLASS *pChild = NULL;

   pClass->GetMembers( Iterator );

   while ( ITERATOR_GETNEXT( Iterator, pChild ) )
       ContinueAnalysis( pChild );

}

//
// Proc derived.  Attributes do not propagate past or apply to these nodes
//
//  CG_PROC
//  CG_CALLBACK_PROC
//  CG_ENCODE_PROC
//  CG_IUNKNOWN_OBJECT_PROC
//  CG_LOCAL_OBJECT_PROC
//  CG_OBJECT_PROC
//  CG_INHERITIED_OBJECT_PROC
//  CG_TYPE_ENCODE_PROC

void CG_ILANALYSIS_VISITOR::Visit( CG_PROC *pClass )
{
   PropagateInfo( &ILANALYSIS_BLOCK_EVERYTHING_FLAGS );

   CG_ITERATOR Iterator;
   CG_CLASS *pParam = NULL;

   pClass->GetMembers( Iterator );

   while ( ITERATOR_GETNEXT( Iterator, pParam ) )
       ContinueAnalysis( pParam );

   CG_CLASS *pReturnCG = pClass->GetReturnType();

   if ( pReturnCG )
       ContinueAnalysis( pReturnCG );

}

//
// typedef derived.  For now all of these force full complexity.
// 
// For now, all of these make the parent bogus.
// 
// CG_TYPEDEF
// CG_TYPE_ENCODE
// CG_PIPE
// CG_USER_MARSHAL
// CG_REPRESENT_AS
// CG_TRANSMIT_AS
// 
//

void CG_ILANALYSIS_VISITOR::Visit( CG_TYPEDEF *pClass )
{
       
   PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );
   
   ContinueAnalysis( pClass->GetChild() );
   
   AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
   AddDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER );

}

//
// 
//
//   Root for structures and unions.
//   MAKE_ASSERT_ENTRY( CG_COMP )
//
//   Structures
//
//   All structures are handled from the base.
//
//   CG_STRUCT
//   CG_COMPLEX_STRUCT
//   CG_CONFORMAT_STRUCT
//   CG_CONFORMANT_VARYING_STRUCT
//   CG_ENCAPSULATED_STRUCT
//
// Policy for structures:
//
// 1.  A structure is full bogus if any of the following is true:
//     A. Any field of the structure is full bogus.
//     B. Any field has a unknown wire size or offset.
//     C. Any field has a wire size or offset that is different from the
//        memory size and offset.
//     D. The wire size of the structure is different from the memory size of the structure.
//     E. Any field is varying.
//
// 2.  A structure is forced bogus is any of the following is true.
//     A. Any field of the structure is forced bogus.
//
//  
//


void CG_ILANALYSIS_VISITOR::Visit( CG_STRUCT *pClass )
{

    static const ILANALYSIS_DESCENDANT_FLAGS STRUCT_TO_PARENT_MASK = 
        ILANALYSIS_HAS_STRUCT_CONFORMANCE |
        ILANALYSIS_HAS_STRUCT_VARIANCE |
        ILANALYSIS_HAS_STRING |
        ILANALYSIS_HAS_FULL_BOGUS |
        ILANALYSIS_HAS_POINTER |
        ILANALYSIS_HAS_POINTER_ARRAY |
        ILANALYSIS_HAS_FORCED_BOGUS |
        ILANALYSIS_HAS_UNKNOWN_BUFFER;

    static const ILANALYSIS_FLAGS_MASK StructAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,     // From parent 
        ILANALYSIS_IN_NOTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING, // From child
        STRUCT_TO_PARENT_MASK      // To parent
    };

    PropagateInfo( &StructAnalysisFlags );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    CG_ITERATOR         Iterator;
    CG_FIELD            *pField;

    pClass->GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {

        ContinueAnalysis( pField );

        // If an array is varying the structure needs to be marked as full bogus.
        if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE |
                                 ILANALYSIS_HAS_STRUCT_VARIANCE |
                                 ILANALYSIS_HAS_STRING ) )
            {
            pAnalysisInfo->SetIsFullBogus();
            }

        if ( ( pField->GetMemOffset() != pField->GetWireOffset() ) ||
             ( pField->GetMemorySize() != pField->GetWireSize() ) )
            {
            pAnalysisInfo->SetIsFullBogus();
            }

        }

    // Copy context attributes to structure node.

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) ||
         ( pClass->GetWireSize() != pClass->GetMemorySize() ) )
        pAnalysisInfo->SetIsFullBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) )
        pAnalysisInfo->SetIsForcedBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_STRUCT_CONFORMANCE | 
                             ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_STRUCT_VARIANCE |
                             ILANALYSIS_HAS_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( pAnalysisInfo->IsConformant() || 
         pAnalysisInfo->IsVarying() ||
         AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) )
        {
        pAnalysisInfo->SetHasUnknownBuffer();
        }

    if ( pAnalysisInfo->IsVarying() )
        pAnalysisInfo->SetIsFullBogus();

    // Copy structure node attributes to context.

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_CONFORMANCE );
         
    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_VARIANCE );

    if ( pAnalysisInfo->IsFullBogus() )
         AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    if ( pAnalysisInfo->IsForcedBogus() )
         AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );

}

//
// 
//
//   Unions
//
// For now, all unions have an unknown buffer size and cause the containing structure or
// array to be full bogus. This may change since a union where all the arms have the
// same size has a well defined wire size.  An example of this is a union of pointers.
//
//  
//
void CG_ILANALYSIS_VISITOR::Visit( CG_UNION *pClass )
{
    static const ILANALYSIS_DESCENDANT_FLAGS UNION_TO_PARENT_MASK = 
        ILANALYSIS_HAS_STRUCT_CONFORMANCE |
        ILANALYSIS_HAS_STRUCT_VARIANCE |
        ILANALYSIS_HAS_STRING |
        ILANALYSIS_HAS_FULL_BOGUS |
        ILANALYSIS_HAS_POINTER |
        ILANALYSIS_HAS_POINTER_ARRAY |
        ILANALYSIS_HAS_FORCED_BOGUS |
        ILANALYSIS_HAS_UNKNOWN_BUFFER;

    static const ILANALYSIS_FLAGS_MASK UnionAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,     // From parent 
        ILANALYSIS_IN_NOTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING, // From child
        UNION_TO_PARENT_MASK      // To parent
    };

    PropagateInfo( &UnionAnalysisFlags );

    CG_ITERATOR         Iterator;
    CG_FIELD            *pArm;

    pClass->GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pArm ) )
       ContinueAnalysis( pArm );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_CONFORMANCE );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
         AddDescendantFlags( ILANALYSIS_HAS_STRUCT_VARIANCE );

    AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    AddDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER );

}
//
//
//  Arrays
//
//  All arrays are handled from the base class.
//
//  CG_ARRAY
//  CG_STRING_ARRAY
//  CG_CONFORMANT_ARRAY
//  CG_CONFORMANT_STRING_ARRAY
//  CG_VARYING_ARRAY
//  CG_CONFORMANT_VARYING_ARRAY
//  CG_FIXED_ARRAY
//
// Policy for arrays:
//
// Conformance/Variance
// 1.  If any dimemsion of a multidimensional array is conformant, all dimensions are
//     conformant.
// 2.  If any dimension of a multidimensional array is varying, all dimensions are varying.
// 3.  An arrays a strings does not make the arrays varying.
// 4.  An array of conformant strings does make all dimensions of the array conformant.
//
// Full bogus:
//
// 5. An array is full bogus if any of the following are true:
//    A. The child of the array is full bogus.
//    B. The array is a string.
//
// Forced bogus:
// 6. An array is forced bogus if any of the following are true:
//    A. The array is multidimensional.
//    B. Any child of the array is an array with pointers.
//    C. The child of the array is forced bogus.
//
//

void CG_ILANALYSIS_VISITOR::Visit( CG_ARRAY *pClass )
    {

    static const ILANALYSIS_DESCENDANT_FLAGS ARRAY_TO_PARENT_MASK = 
          ILANALYSIS_HAS_ARRAY                  |
          ILANALYSIS_HAS_ARRAY_CONFORMANCE      | 
          ILANALYSIS_HAS_ARRAY_VARIANCE         |
          ILANALYSIS_HAS_STRING                 |
          ILANALYSIS_HAS_FULL_BOGUS             |
          ILANALYSIS_HAS_FORCED_BOGUS           |
          ILANALYSIS_HAS_POINTER                |
          ILANALYSIS_HAS_POINTER_ARRAY          |
          ILANALYSIS_HAS_UNKNOWN_BUFFER;

    static const ILANALYSIS_FLAGS_MASK ArrayAnalysisFlags =
    {   ILANALYSIS_IN_EVERYTHING,     // From parent 
        ILANALYSIS_IN_EVERYTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING,    // From child
        ARRAY_TO_PARENT_MASK          // To parent
    };

    PropagateInfo( &ArrayAnalysisFlags );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    //
    // Copy flags from ancestor flags to node.
    //

    if ( AnyAncestorFlags( ILANALYSIS_IN_ARRAY ) )
        pAnalysisInfo->SetIsMutiDimensional();

    if ( AnyAncestorFlags( ILANALYSIS_IN_ARRAY_CONFORMANCE  ) )
        pAnalysisInfo->SetIsConformant();
    
    if ( AnyAncestorFlags( ILANALYSIS_IN_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    //
    // Copy ancestor flags from node to context
    // 


    AddAncestorFlags( ILANALYSIS_IN_ARRAY );

    if ( pAnalysisInfo->IsConformant() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_CONFORMANCE  );

    if ( pAnalysisInfo->IsVarying() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_VARIANCE );

    ContinueAnalysis( pClass->GetChild() );
    
    //
    // copy descendant flags from context to node.
    //
    unsigned long Dimensions = GetDimensions();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY ) )
        {
        Dimensions++;
        pAnalysisInfo->SetIsMutiDimensional();
        }
    else 
        {
        Dimensions = 1;
        }

    SetDimensions( Dimensions );
    pAnalysisInfo->SetDimensions( (unsigned char) Dimensions );

    if ( Dimensions >= 256 )
        {
        RpcError( NULL, 0, ARRAY_DIMENSIONS_EXCEEDS_255, NULL );
        exit(ARRAY_DIMENSIONS_EXCEEDS_255); 
        }

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();
    
    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) ||
         AnyDescendantFlags( ILANALYSIS_HAS_POINTER_ARRAY ) ||
         pAnalysisInfo->IsMultiDimensional() )
        pAnalysisInfo->SetIsForcedBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) ||
         pAnalysisInfo->IsConformant() ||
         pAnalysisInfo->IsVarying() )
        pAnalysisInfo->SetHasUnknownBuffer();

    //
    // If the array has a first_is attribute that is not 0 then,
    // mark the array as forced bogus.
    //
    CG_VARY_ATTRIBUTE *pVaryAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );
    if ( NULL != pVaryAttribute )
       {
       expr_node *pFirstIs = pVaryAttribute->GetFirstIsExpr();
       if ( NULL != pFirstIs )
           {
           if ( !pFirstIs->IsConstant() )
               pAnalysisInfo->SetIsForcedBogus();
           else if ( pFirstIs->GetValue() != 0 )
               pAnalysisInfo->SetIsForcedBogus();
           }
       }

    //
    // Copy descendant flags from node to context
    //

    AddDescendantFlags( ILANALYSIS_HAS_ARRAY );
    if ( AnyDescendantFlags( ILANALYSIS_HAS_POINTER ) )
        {
        AddDescendantFlags( ILANALYSIS_HAS_POINTER_ARRAY );
        }

    if ( pAnalysisInfo->IsForcedBogus() )
        AddDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS );

    if ( pAnalysisInfo->IsFullBogus() )
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    if ( pAnalysisInfo->IsConformant() )
        AddDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE );

    if ( pAnalysisInfo->IsVarying() )
        AddDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE );

    if ( pAnalysisInfo->HasUnknownBuffer() )
        AddDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER );

    if ( pAnalysisInfo->IsArrayofStrings() )
        AddDescendantFlags( ILANALYSIS_HAS_STRING );
    
    }
            
void CG_ILANALYSIS_VISITOR::Visit( CG_STRING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetIsArrayofStrings();
    pAnalysisInfo->SetHasUnknownBuffer();
    
    Visit( (CG_ARRAY*) pClass );

    // Do not propagate up variance from strings
    ClearDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE  );

}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONFORMANT_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_ARRAY *) pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONFORMANT_STRING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetIsArrayofStrings();    
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetHasUnknownBuffer();

    Visit( (CG_ARRAY *) pClass );

    // Do not propagate up variance from strings
    ClearDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE  );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_VARYING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_ARRAY *) pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_CONFORMANT_VARYING_ARRAY *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetIsVarying( );
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_ARRAY *) pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_FIXED_ARRAY *pClass )
{
    // No attributes need to be added for fixed arrays.
    Visit( (CG_ARRAY *) pClass );
}
    
//
// 
//
//   Pointers
//
//   CRITICAL NOTE: This design of this analysis assumes that no attributes
//   may propagate past pointers.  If this changes, then the entire analysis
//   code will need to be redesigned.
//
//  CG_POINTER

void CG_ILANALYSIS_VISITOR::Visit( CG_POINTER *pClass )
{

    static const ILANALYSIS_FLAGS_MASK PointerAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,        // From parent 
        ILANALYSIS_IN_EVERYTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING,    // From child
        ILANALYSIS_HAS_POINTER | ILANALYSIS_HAS_FULL_BOGUS,       // To parent
    };

    PropagateInfo( &PointerAnalysisFlags );

    // CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    // Check for recursion
    if ( pRecursiveSet->Lookup( pClass ) )
        {
        if ( pClass->GetMemorySize() != pClass->GetWireSize() )
            AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

        AddDescendantFlags( ILANALYSIS_HAS_POINTER );        
        return;
        }

    pRecursiveSet->Insert( pClass );

    ContinueAnalysis( pClass->GetChild() );

    //
    //  Misc pointer attributes
    //

    ClearDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    
    if ( pClass->GetMemorySize() != pClass->GetWireSize() )
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    AddDescendantFlags( ILANALYSIS_HAS_POINTER );

}


//
// 
//
//   Qualified Pointers
//
//   CRITICAL NOTE: This design of this analysis assumes that no attributes
//   may propagate past pointers.  If this changes, then the entire analysis
//   code will need to be redesigned.
//
//  CG_QUALIFIED_POINTER
//  CG_BYTE_COUNT
//  CG_LENGTH_POINTER
//  CG_INTERFACE_POINTER
//  CG_STRING_POINTER
//  CG_SIZE_POINTER
//  CG_SIZE_STRING_POINTER
//  CG_SIZE_LENGTH_POINTER
//
// Note: A qualified pointer follows the same rules as an array.   The only difference
//       is that the attributes are not propagated up past the pointer.
//
// 
//

void CG_ILANALYSIS_VISITOR::Visit( CG_QUALIFIED_POINTER *pClass )
{
    static const ILANALYSIS_FLAGS_MASK PointerAnalysisFlags =
    {   ILANALYSIS_IN_NOTHING,        // From parent 
        ILANALYSIS_IN_EVERYTHING,     // To child
        ILANALYSIS_HAS_EVERYTHING,    // From child
        ILANALYSIS_HAS_POINTER | ILANALYSIS_HAS_FULL_BOGUS,       // To parent
    };

    PropagateInfo( &PointerAnalysisFlags );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    // Check for recursion
    if ( pRecursiveSet->Lookup( pClass ) )
        {
        if ( pClass->GetMemorySize() != pClass->GetWireSize() )
            AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

        AddDescendantFlags( ILANALYSIS_HAS_POINTER );        
        return;
        }

    pRecursiveSet->Insert( pClass );

    //
    // Copy Ancestor flags from context to node
    //

    AddAncestorFlags( ILANALYSIS_IN_ARRAY );

    if ( pAnalysisInfo->IsConformant() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_CONFORMANCE );

    if ( pAnalysisInfo->IsVarying() )
        AddAncestorFlags( ILANALYSIS_IN_ARRAY_VARIANCE );

    ContinueAnalysis( pClass->GetChild() );

    //
    // Copy descendant flags from context to node
    //

    unsigned long Dimensions = GetDimensions();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY ) )
        {
        Dimensions++;
        pAnalysisInfo->SetIsMutiDimensional();
        }
    else 
        {
        Dimensions = 1;
        }

    SetDimensions( Dimensions );
    pAnalysisInfo->SetDimensions( (unsigned char) Dimensions );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( pAnalysisInfo->IsConformant() ||
         pAnalysisInfo->IsVarying() )
        pAnalysisInfo->SetHasUnknownBuffer();

    if (AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();
    
    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) ||
         AnyDescendantFlags( ILANALYSIS_HAS_POINTER_ARRAY ) ||
         pAnalysisInfo->IsMultiDimensional() )
        pAnalysisInfo->SetIsForcedBogus();

    //
    // If the sized pointer has a first_is attribute that is not 0 then,
    // mark the pointer as forced bogus.
    //
    CG_VARY_ATTRIBUTE *pVaryAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );
    if ( NULL != pVaryAttribute )
       {
       expr_node *pFirstIs = pVaryAttribute->GetFirstIsExpr();
       if ( NULL != pFirstIs )
           {
           if ( !pFirstIs->IsConstant() )
               pAnalysisInfo->SetIsForcedBogus();
           else if ( pFirstIs->GetValue() != 0 )
               pAnalysisInfo->SetIsForcedBogus();
           }
       } 
    
    //
    //  Misc pointer attributes
    //

    ClearDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );
    
    if ( pClass->GetMemorySize() != pClass->GetWireSize() )
        AddDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS );

    AddDescendantFlags( ILANALYSIS_HAS_POINTER );

}

void CG_ILANALYSIS_VISITOR::Visit( CG_BYTE_COUNT_POINTER *pClass )
{
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_LENGTH_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_INTERFACE_POINTER *pClass )
{
    Visit( (CG_QUALIFIED_POINTER*) pClass );
}
 
void CG_ILANALYSIS_VISITOR::Visit( CG_STRING_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();    
    pAnalysisInfo->SetIsArrayofStrings();    
    pAnalysisInfo->SetHasUnknownBuffer();

    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

void CG_ILANALYSIS_VISITOR::Visit( CG_SIZE_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}
 
void CG_ILANALYSIS_VISITOR::Visit( CG_SIZE_STRING_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetIsArrayofStrings();    
    pAnalysisInfo->SetHasUnknownBuffer();
    
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}
 
void CG_ILANALYSIS_VISITOR::Visit( CG_SIZE_LENGTH_POINTER *pClass )
{
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
    pAnalysisInfo->SetIsVarying();
    pAnalysisInfo->SetIsConformant();
    pAnalysisInfo->SetHasUnknownBuffer();
    Visit( (CG_QUALIFIED_POINTER*)pClass );
}

//
// 
//
//  Fields.
//
//  CG_FIELD
//  CG_UNION_FIELD
//
//  
//

void CG_ILANALYSIS_VISITOR::Visit( CG_FIELD *pClass )
{
    PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );    
    
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    ContinueAnalysis( pClass->GetChild() );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE |
                             ILANALYSIS_HAS_STRUCT_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE  |
                             ILANALYSIS_HAS_STRUCT_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) )
        pAnalysisInfo->SetIsForcedBogus();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();

    if ( pAnalysisInfo->IsConformant() ||
         pAnalysisInfo->IsVarying() ||
         AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) )
        pAnalysisInfo->SetHasUnknownBuffer();

}

//
// 
//
//  Union cases.
//
//  CG_CASE
//  CG_UNION_FIELD
//
//


void CG_ILANALYSIS_VISITOR::Visit( CG_CASE *pClass )
{
    PropagateInfo( &ILANALYSIS_PASS_EVERYTHING_FLAGS );

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    ContinueAnalysis( pClass->GetChild() );

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_CONFORMANCE |
                             ILANALYSIS_HAS_STRUCT_CONFORMANCE ) )
        pAnalysisInfo->SetIsConformant();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_ARRAY_VARIANCE |
                             ILANALYSIS_HAS_STRUCT_VARIANCE ) )
        pAnalysisInfo->SetIsVarying();

    if ( AnyDescendantFlags( ILANALYSIS_HAS_FORCED_BOGUS ) )
        pAnalysisInfo->SetIsForcedBogus();
    if ( AnyDescendantFlags( ILANALYSIS_HAS_FULL_BOGUS ) )
        pAnalysisInfo->SetIsFullBogus();
    if ( AnyDescendantFlags( ILANALYSIS_HAS_UNKNOWN_BUFFER ) )
        pAnalysisInfo->SetHasUnknownBuffer();
}

//
//
//
//
//   Transform STAGE 2
//
//   The tree is modified for correctness and optimized based on information
//   from the analysis pass.
//

class CG_TRANSFORM_VISITOR 
{
private:
  CG_CLASS *pReturn;
  CG_ILCLASS_MAP *pRecursiveMap;

  CG_CLASS *DoTransform( CG_CLASS *pClass );
  CG_CLASS *DoTransform( CG_ARRAY *pClass );
  CG_CLASS *DoTransform( CG_QUALIFIED_POINTER *pClass );
  CG_CLASS *DoTransform( CG_PROC  *pProc );
  CG_CLASS *DoTransform( CG_STRUCT *pClass );
  CG_CLASS *DoTransform( CG_ENCAPSULATED_STRUCT *pClass);

  CG_CLASS *ContinueTransform( CG_CLASS *pClass );
  
  void FlushRegionList( CG_COMPLEX_STRUCT *pClass, gplistmgr *pRegionList, 
                        gplistmgr *pMemberList, unsigned long Pad );
  void RegionalizeUnknownBufferSizeSection( CG_COMPLEX_STRUCT *pClass,
                                            gplistmgr & OldMemberList,
                                            gplistmgr & NewMemberList,
                                            gplistmgr & CurrentRegionList );
  void RegionalizeStruct( CG_COMPLEX_STRUCT *pClass );
  CG_ILANALYSIS_INFO* GetAnalysisInfo( CG_CLASS *pClass ) 
      {
      return pClass->GetILAnalysisInfo(); 
      }

protected:
  CG_TRANSFORM_VISITOR() {}

public:

  // Dispatcher functions. Member templates would be great for this.
  void Visit( CG_CLASS *pClass )               { pReturn = DoTransform( pClass );}
  void Visit( CG_ARRAY *pClass )               { pReturn = DoTransform( pClass );}
  void Visit( CG_QUALIFIED_POINTER *pClass )   { pReturn = DoTransform( pClass );}
  void Visit( CG_PROC *pClass )                { pReturn = DoTransform( pClass );}
  void Visit( CG_STRUCT *pClass )              { pReturn = DoTransform( pClass );}
  void Visit( CG_ENCAPSULATED_STRUCT *pClass ) { pReturn = DoTransform( pClass );}

  static CG_CLASS* StartTransform( CG_CLASS *pClass );
};


CG_CLASS* ILTransform( CG_CLASS *pClass )
{
   return CG_TRANSFORM_VISITOR::StartTransform( pClass );
}

CG_CLASS* CG_TRANSFORM_VISITOR::StartTransform( CG_CLASS *pClass )
{
   CG_VISITOR_TEMPLATE<CG_TRANSFORM_VISITOR> TemplateVisitor;
   CG_TRANSFORM_VISITOR & Visitor = TemplateVisitor;
   CG_ILCLASS_MAP ClassMap;
   
   Visitor.pRecursiveMap = &ClassMap;
   Visitor.pReturn = NULL;

   if (NULL != pClass )
       {
       pClass->Visit( &TemplateVisitor );
       }
   
   return Visitor.pReturn;
}


CG_CLASS *CG_TRANSFORM_VISITOR::ContinueTransform( CG_CLASS *pClass )
{

   // Some classes have a NULL child.  Deal with it here.
   if ( pClass == NULL )
       return NULL;

   CG_CLASS *pNewSelfCG;
   if ( pRecursiveMap->Lookup( pClass, &pNewSelfCG ) )
      return pNewSelfCG;

   CG_VISITOR_TEMPLATE<CG_TRANSFORM_VISITOR> TemplateVisitor;
   CG_TRANSFORM_VISITOR & Visitor = TemplateVisitor;   
   Visitor.pRecursiveMap = pRecursiveMap;

   pClass->Visit( &TemplateVisitor );

   return Visitor.pReturn;
}

//
// General Catchall cases.   Members are exchanged for new versions.
// CG_CLASS
// CG_NDR
// CG_AUX
// CG_SOURCE
// CG_COCLASS
// CG_MODULE
// CG_SAFEARRAY
//
// Files
// CG_FILE
// CG_SSTUB_FILE
// CG_HDR_FILE
// CG_CSTUB_FILE
// CG_IID_FILE
// CG_NETMONSTUB_FILE
// CG_PROXY_FILE
// CG_TYPELIBRARY_FILE
//
// Interfaces
// CG_INTERFACE
// CG_OBJECT_INTERFACE
// CG_DISPINTERFACE
// CG_INHERITED_OBJECT_INTERFACE
// CG_INTERFACE_REFERENCE
// CG_IUNKNOWN_OBJECT_INTERFACE
// CG_ASYNC_HANDLE
// CG_ID
// 
// Parameters
// CG_PARAM
// CG_RETURN
// 
// BaseTypes
// CG_BASETYPE
// CG_INT3264
// CG_ENUM
// CG_HRESULT
// CG_ERROR_STATUS_T
// 
// Handles
// CG_HANDLE
// CG_PRIMITIVE_HANDLE
// CG_GENERIC_HANDLE
// CG_CONTEXT_HANDLE
//
// CG_IGNORED_POINTER
// CG_CS_TAG
//
// Fields.  
// CG_FIELD
// CG_UNION_FIELD
// 
// Union cases. 
// CG_CASE
// CG_DEFAULT_CASE
// 
// CG_UNION
//
//  CG_TYPEDEF
//  CG_TYPE_ENCODE
//  CG_PIPE
//  CG_USER_MARSHAL
//  CG_REPRESENT_AS
//  CG_TRANSMIT_AS
//
//  Unqualified pointers.
//  
CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_CLASS *pClass )
{

   ITERATOR Iterator;
   CG_CLASS *pChildCG = NULL;
   CG_CLASS *pNewChildCG = NULL;

   pRecursiveMap->Insert( pClass, pClass );

   gplistmgr NewList;

   pClass->GetMembers( Iterator );

   ITERATOR_INIT( Iterator );
   while ( ITERATOR_GETNEXT( Iterator, pChildCG ) )
       {                                      
       pNewChildCG = ContinueTransform( pChildCG );
       NewList.Insert( pNewChildCG );
       }
   
   ITERATOR_INIT( NewList );
   pClass->SetMembers( NewList );

   return pClass;

}

// 
// Array derived
//

CG_CLASS *CG_TRANSFORM_VISITOR::DoTransform( CG_ARRAY *pClass )
{
    
    CG_ARRAY *pNewArray = NULL;
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    node_skl *pType = pClass->GetType();
    
    FIELD_ATTR_INFO FieldAttr;
    FieldAttr.SetSizeIs( pClass->GetSizeIsExpr() );
    FieldAttr.SetMinIs( pClass->GetMinIsExpr() );

    node_cs_char *pCsUserType = pClass->GetCSUserType();    

    CG_VARY_ATTRIBUTE *pVaryingAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );

    if ( NULL != pVaryingAttribute )
        {
        FieldAttr.SetLengthIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetFirstIs( pVaryingAttribute->GetFirstIsExpr() );
        }
    else 
        {
        FieldAttr.SetLengthIs( pClass->GetSizeIsExpr() );
        FieldAttr.SetFirstIs( pClass->GetMinIsExpr() );
        }

    unsigned short Dimensions = pClass->GetDimensions();
    XLAT_SIZE_INFO NewSizeInfo(pClass->GetMemoryAlignment(),
                               pClass->GetWireAlignment(),
                               pClass->GetMemorySize(),
                               pClass->GetWireSize(),
                               0,
                               0,
                               0);

    // Class is a string
#pragma prefast(suppress:537, dynamic cast checking problem in prefast)
    if ( ( NULL != dynamic_cast<CG_STRING_ARRAY*>( pClass ) ) ||
         ( NULL != dynamic_cast<CG_CONFORMANT_STRING_ARRAY*>( pClass ) ) ) 
        {
        if ( pAnalysisInfo->IsConformant() )
            {
            pNewArray = new CG_CONFORMANT_STRING_ARRAY( pType,
                                                        &FieldAttr,
                                                        Dimensions,
                                                        NewSizeInfo );                
            }
        else
            {
            pNewArray = new CG_STRING_ARRAY( pType,
                                             &FieldAttr,
                                             Dimensions,
                                             NewSizeInfo );
            }
        }
    
    // Class is an array
    else 
        {
        // Some form of fixed array
        if ( !pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_FIXED_ARRAY( pType,
                                                           &FieldAttr,
                                                           Dimensions,
                                                           NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_FIXED_ARRAY( pType,
                                                             &FieldAttr,
                                                             Dimensions,
                                                             NewSizeInfo );
            else 
                pNewArray = new CG_FIXED_ARRAY( pType,
                                                &FieldAttr,
                                                Dimensions,
                                                NewSizeInfo );
            }
        // Some form of varying array
        else if ( !pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_VARYING_ARRAY( pType,
                                                             &FieldAttr,
                                                             Dimensions,
                                                             NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_VARYING_ARRAY( pType,
                                                               &FieldAttr,
                                                               Dimensions,
                                                               NewSizeInfo );
            else 
                pNewArray = new CG_VARYING_ARRAY( pType,
                                                  &FieldAttr,
                                                  Dimensions,
                                                  NewSizeInfo );
            }
        // Some form of conformant array
        else if ( pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_CONFORMANT_ARRAY( pType,
                                                                  &FieldAttr,
                                                                  Dimensions,
                                                                  NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_CONFORMANT_ARRAY( pType,
                                                                  &FieldAttr,
                                                                  Dimensions,
                                                                  NewSizeInfo );
            else 
                pNewArray = new CG_CONFORMANT_ARRAY( pType,
                                                     &FieldAttr,
                                                     Dimensions,
                                                     NewSizeInfo );
            }
        // Some form of conformant varying array
        else if ( pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewArray = new CG_FULL_COMPLEX_CONFORMANT_VARYING_ARRAY( pType,
                                                                        &FieldAttr,
                                                                        Dimensions, 
                                                                        NewSizeInfo );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewArray = new CG_FORCED_COMPLEX_CONFORMANT_VARYING_ARRAY( pType,
                                                                          &FieldAttr,
                                                                          Dimensions,
                                                                          NewSizeInfo );
            else 
                pNewArray = new CG_CONFORMANT_VARYING_ARRAY( pType,
                                                             &FieldAttr,
                                                             Dimensions,
                                                             NewSizeInfo );            
            }
        }

    *GetAnalysisInfo( pNewArray ) = *pAnalysisInfo;

    pNewArray->SetCSUserType( pCsUserType );
    pNewArray->SetPtrType( pClass->GetPtrType() );
    pRecursiveMap->Insert( pClass, pNewArray );

    CG_CLASS *pChildClass = pClass->GetChild();
    CG_CLASS *pNewChildClass = ContinueTransform( pChildClass );

    pNewArray->SetChild( pNewChildClass );

    return pNewArray;

}

//
// Qualified pointers.
//
CG_CLASS *CG_TRANSFORM_VISITOR::DoTransform( CG_QUALIFIED_POINTER *pClass )
{
    
    CG_QUALIFIED_POINTER *pNewPointer = NULL;
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    node_skl *pType = pClass->GetType();
    PTRTYPE PointerType = pClass->GetPtrType();
    short AllocationDetails = pClass->GetAllocateDetails();
    node_cs_char *pCsUserType = pClass->GetCSUserType();

    FIELD_ATTR_INFO FieldAttr;
    
    CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pClass );
    CG_VARY_ATTRIBUTE *pVaryingAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pClass );

    //
    // If the pointer does not have a conformatn attribute or a varying attribute
    // then the pointer must be a string.

    MIDL_ASSERT( (NULL != pConfAttribute ) ||
            (NULL != pVaryingAttribute ) ||
            (NULL != dynamic_cast<CG_STRING_POINTER*>( pClass ) ) );

    //
    // 1. Conformant
    if ( ( NULL != pConfAttribute ) && ( NULL == pVaryingAttribute ) )
        {
        FieldAttr.SetSizeIs( pConfAttribute->GetSizeIsExpr() );
        FieldAttr.SetMinIs( pConfAttribute->GetMinIsExpr() );
        FieldAttr.SetLengthIs( pConfAttribute->GetSizeIsExpr() );
        FieldAttr.SetFirstIs( pConfAttribute->GetMinIsExpr() );
        }

    //
    // 2. Varying
    else if ( ( NULL == pConfAttribute ) && ( NULL != pVaryingAttribute ) )
        {
        FieldAttr.SetLengthIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetFirstIs( pVaryingAttribute->GetFirstIsExpr() );
        FieldAttr.SetSizeIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetMinIs( pVaryingAttribute->GetFirstIsExpr() );
        }

    //
    // 3. Conformant varying
    else if ( ( NULL != pConfAttribute ) && ( NULL != pVaryingAttribute ) )
        {
        FieldAttr.SetSizeIs( pConfAttribute->GetSizeIsExpr() );
        FieldAttr.SetMinIs( pConfAttribute->GetMinIsExpr() );
        FieldAttr.SetLengthIs( pVaryingAttribute->GetLengthIsExpr() );
        FieldAttr.SetFirstIs( pVaryingAttribute->GetFirstIsExpr() );
        }

    // Class is a string
#pragma prefast(suppress:537, dynamic cast checking problem in prefast)
    if ( ( NULL != dynamic_cast<CG_STRING_POINTER*>( pClass ) ) ||
         ( NULL != dynamic_cast<CG_SIZE_STRING_POINTER*>( pClass ) ) ) 
        {
        if ( pAnalysisInfo->IsConformant() )
            {
            pNewPointer = new CG_SIZE_STRING_POINTER( pType,
                                                      PointerType,
                                                      AllocationDetails,
                                                      &FieldAttr );                
            }
        else
            {
            pNewPointer = new CG_STRING_POINTER( pType,
                                               PointerType,
                                               AllocationDetails );
            }
        }

    // Class is really a pointer to an array
    else 
        {
        // Some form of varying array
        if ( !pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewPointer = new CG_FULL_COMPLEX_LENGTH_POINTER( pType,
                                                              PointerType,
                                                              AllocationDetails,
                                                              &FieldAttr );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewPointer = new CG_FORCED_COMPLEX_LENGTH_POINTER( pType,
                                                                PointerType,
                                                                AllocationDetails,
                                                                &FieldAttr );
            else 
                pNewPointer = new CG_LENGTH_POINTER( pType,
                                                   PointerType,
                                                   AllocationDetails,
                                                   &FieldAttr );
            }
        // Some form of conformant array
        else if ( pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewPointer = new CG_FULL_COMPLEX_SIZE_POINTER( pType,
                                                            PointerType,
                                                            AllocationDetails,
                                                            &FieldAttr );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewPointer = new CG_FORCED_COMPLEX_SIZE_POINTER( pType,
                                                              PointerType,
                                                              AllocationDetails,
                                                              &FieldAttr );
            else 
                pNewPointer = new CG_SIZE_POINTER( pType,
                                                 PointerType,
                                                 AllocationDetails,
                                                 &FieldAttr );
            }
        // Some form of conformant varying array
        else if ( pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying() )
            {
            if ( pAnalysisInfo->IsFullBogus() )
                pNewPointer = new CG_FULL_COMPLEX_SIZE_LENGTH_POINTER( pType,
                                                                   PointerType,
                                                                   AllocationDetails,
                                                                   &FieldAttr );
            else if ( pAnalysisInfo->IsForcedBogus() )
                pNewPointer = new CG_FORCED_COMPLEX_SIZE_LENGTH_POINTER( pType,
                                                                     PointerType,
                                                                     AllocationDetails,
                                                                     &FieldAttr );
            else 
                pNewPointer = new CG_SIZE_LENGTH_POINTER( pType,
                                                        PointerType,
                                                        AllocationDetails,
                                                        &FieldAttr );            
            }
        else 
            {
            MIDL_ASSERT( 0 );
            }
        }

    *GetAnalysisInfo( pNewPointer ) = *pAnalysisInfo;
    pNewPointer->SetCSUserType( pCsUserType );
    pNewPointer->SetPtrType( pClass->GetPtrType() );
    pRecursiveMap->Insert( pClass, pNewPointer );

    CG_CLASS *pChildClass = pClass->GetChild();
    CG_CLASS *pNewChildClass = ContinueTransform( pChildClass );

    pNewPointer->SetChild( pNewChildClass );

    return pNewPointer;

}

//
// Proc derived.  Clone parameters and return type.
//
//  CG_PROC
//  CG_CALLBACK_PROC
//  CG_ENCODE_PROC
//  CG_IUNKNOWN_OBJECT_PROC
//  CG_LOCAL_OBJECT_PROC
//  CG_OBJECT_PROC
//  CG_INHERITIED_OBJECT_PROC
//  CG_TYPE_ENCODE_PROC


CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_PROC *pClass )
   { 

   ITERATOR Iterator;
   CG_CLASS *pChildCG = NULL;
   CG_CLASS *pNewChildCG = NULL;

   pRecursiveMap->Insert( pClass, pClass );

   gplistmgr NewList;

   pClass->GetMembers( Iterator );

   ITERATOR_INIT( Iterator );
   while ( ITERATOR_GETNEXT( Iterator, pChildCG ) )
       {                                      
       pNewChildCG = ContinueTransform( pChildCG );
       NewList.Insert( pNewChildCG );
       }
   
   ITERATOR_INIT( NewList );
   pClass->SetMembers( NewList );
   
   CG_CLASS *pReturnCG = pClass->GetReturnType();

   if ( pReturnCG )
       {
       CG_RETURN *pNewReturnCG = (CG_RETURN*)ContinueTransform( pReturnCG );
       pClass->SetReturnType( pNewReturnCG );
       }
   
   return pClass;
   }

const unsigned long MAX_SIMPLE_REGION_SIZE = 0xFFFF;
const unsigned long MIN_REGION_ELEMENTS = 3;

void CG_TRANSFORM_VISITOR::FlushRegionList( CG_COMPLEX_STRUCT *pClass,
                                            gplistmgr *pRegionList,
                                            gplistmgr *pMemberList,
                                            unsigned long Pad )
{

    // Check if the region has enough elements.  
    ITERATOR_INIT( *pRegionList );
    if ( ITERATOR_GETCOUNT( *pRegionList ) < MIN_REGION_ELEMENTS )
        {
        // transfer field elements unmodied since a region will not be created in this case

        ITERATOR_INIT( *pRegionList );
        CG_FIELD *pCurrentField;
        while ( ITERATOR_GETNEXT( *pRegionList, pCurrentField ) )
            {
            pMemberList->Insert( pCurrentField );
            }

        pRegionList->Discard();
        return;
        
        }
    
    CG_REGION *pRegion;
    CG_FIELD *pCurrentField = NULL;

    XLAT_SIZE_INFO RegionInfo;

    // 
    //  1. Adjust field offsets for region
    //  2. Determine region size.
    //  3. Determine if region has any pointers
    //  

    BOOL bRegionHasPointer = FALSE;
    CG_ILANALYSIS_INFO RegionAnalysisInfo;


    ITERATOR_GETNEXT( *pRegionList, pCurrentField );
    RegionInfo.GetMemOffset()       = pCurrentField->GetMemOffset();
    RegionInfo.GetWireOffset()      = pCurrentField->GetWireOffset(); 
    RegionInfo.GetWireAlign()       = pCurrentField->GetWireAlignment();
    RegionInfo.GetMemAlign()        = pCurrentField->GetMemoryAlignment();

    ITERATOR_INIT( *pRegionList );
    CG_FIELD *pLastField = NULL;
    while ( ITERATOR_GETNEXT( *pRegionList, pCurrentField ) )
        {

        // Adjust offsets
        pCurrentField->SetMemOffset( pCurrentField->GetMemOffset()  - RegionInfo.GetMemOffset() );
        pCurrentField->SetWireOffset( pCurrentField->GetWireOffset() - RegionInfo.GetWireOffset() );
        
        // Merge attributes from field
        bRegionHasPointer = bRegionHasPointer || pCurrentField->GetChild()->IsPointer();
        RegionAnalysisInfo.MergeAttributes( GetAnalysisInfo( pCurrentField ) );

        pLastField = pCurrentField;
        }

    // Compute the size of the new region
    RegionInfo.GetMemSize()      = pLastField->GetMemOffset() + pLastField->GetMemorySize() + Pad;
    RegionInfo.GetWireSize()     = pLastField->GetWireOffset() + pLastField->GetWireSize() + Pad;
    MIDL_ASSERT( RegionInfo.GetMemSize() == RegionInfo.GetWireSize() );

    if (bRegionHasPointer || 
        (RegionInfo.GetMemSize() > MAX_SIMPLE_REGION_SIZE) )
        {
        pRegion = new CG_COMPLEX_REGION(pClass, RegionInfo, bRegionHasPointer);
        }
    else 
        {
        pRegion = new CG_SIMPLE_REGION(pClass, RegionInfo);
        }
    *GetAnalysisInfo( pRegion ) = RegionAnalysisInfo;

    ITERATOR_INIT( *pRegionList );
    pRegion->SetMembers( *pRegionList );               
    
    CG_FIELD *pNewField = new CG_FIELD(pClass->GetType(), RegionInfo);
    pNewField->SetIsRegionField();               
    pNewField->SetChild( pRegion );

    pMemberList->Insert( pNewField );

    pRegionList->Discard();

}

void CG_TRANSFORM_VISITOR::RegionalizeUnknownBufferSizeSection( CG_COMPLEX_STRUCT *pClass,
                                                                gplistmgr & OldMemberList,
                                                                gplistmgr & NewMemberList,
                                                                gplistmgr & CurrentRegionList )
{
    CG_STRUCT *pCurrentRegionHint = NULL;
    CG_FIELD *pCurrentField = NULL;

    // Caller should have flushed the region list before caller

    while( ITERATOR_GETNEXT( OldMemberList, pCurrentField ) )
        {
        
        if ( pCurrentField->GetRegionHint() == NULL )
           {
           FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, 0 );
           pCurrentRegionHint = NULL;
           NewMemberList.Insert( pCurrentField );
           }
 
        else 
           {

           if ( pCurrentField->GetRegionHint() != pCurrentRegionHint )
               {
               FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, 0 );
               pCurrentRegionHint = pCurrentField->GetRegionHint();
               }

           MIDL_ASSERT( !pCurrentField->GetChild()->IsStruct() );

           CurrentRegionList.Insert( pCurrentField );
           
           }
        }
        
   // Caller should flush the region list after returning.           
         
}

void CG_TRANSFORM_VISITOR::RegionalizeStruct( CG_COMPLEX_STRUCT *pClass )
{
    gplistmgr OldMemberList;
    pClass->GetMembers( OldMemberList );
    ITERATOR_INIT( OldMemberList );
    
    gplistmgr CurrentRegionList, NewMemberList;

    BOOL bAreOffsetsKnown = TRUE;
    unsigned long BufferOffset = 0; // Last known good buffer offset.  Used for padding.
    unsigned long MemoryOffset = 0; // Last known good memory offset.

    CG_FIELD *pCurrentField;    
    while( ITERATOR_GETNEXT( OldMemberList, pCurrentField ) )
        {
        CG_ILANALYSIS_INFO *pFieldAnalysisInfo = GetAnalysisInfo( pCurrentField );

        // If this is a bogus field, then it cannot be placed in the region.
        // We also do not put conformant/varying arrays in the region.
        if ( ( pCurrentField->GetMemOffset() != pCurrentField->GetWireOffset() ) ||
             pFieldAnalysisInfo->IsFullBogus() ||
             pFieldAnalysisInfo->IsForcedBogus() ||
             pFieldAnalysisInfo->HasUnknownBuffer() )
            {

            //
            // Create a region out of the region candidate list. 
            //

            unsigned long Pad = 0;

#if 0
            // BUG BUG,  MIDL doesn't compute the wire offset for a varying array
            // correctly.  Reenable this once that code is fixed.

            if ( ( pCurrentField->GetMemOffset() == pCurrentField->GetWireOffset() )  &&
                 ( BufferOffset == MemoryOffset ) )
                {

                //    The padding between this field and previous field can be
                //    added to the region list.
                Pad = pCurrentField->GetMemOffset() - MemoryOffset; 
                }
#endif

            FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, Pad );

            // Do not place field in a region.
            NewMemberList.Insert( pCurrentField );

            // Calculate new memory and buffer offsets.

            if ( pFieldAnalysisInfo->HasUnknownBuffer() )
                 {
                 bAreOffsetsKnown = FALSE;
                 }
            else
                 {
                 BufferOffset = pCurrentField->GetWireOffset();
                 MemoryOffset = pCurrentField->GetMemOffset();
                 }


            }

        else
            {

            MIDL_ASSERT( pCurrentField->GetMemOffset() == pCurrentField->GetWireOffset() );
            MIDL_ASSERT( pCurrentField->GetMemorySize() == pCurrentField->GetWireSize() );

            MIDL_ASSERT( !pCurrentField->GetChild()->IsStruct() );

            CurrentRegionList.Insert( pCurrentField );

            // Update buffer and memory offsets.  
            BufferOffset = pCurrentField->GetMemOffset() + pCurrentField->GetMemorySize();
            MemoryOffset = pCurrentField->GetWireOffset() + pCurrentField->GetWireSize();
            }

        if ( !bAreOffsetsKnown )
            {
            RegionalizeUnknownBufferSizeSection( pClass,
                                                 OldMemberList,
                                                 NewMemberList,
                                                 CurrentRegionList );
            break;
            }         

        }

    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    // BUG, BUG. For now just set the pad to 0.  This means that the tail of a structure 
    // will not be placed in the region.
    FlushRegionList( pClass, &CurrentRegionList, &NewMemberList, 0 );

    ITERATOR_INIT( NewMemberList );
    pClass->SetMembers( NewMemberList );


    if ( pAnalysisInfo->IsConformant() )
        {
        CG_CLASS * pConformantField = static_cast<CG_CLASS*>( NewMemberList.GetTail() );
        MIDL_ASSERT( NULL != pConformantField );
        pClass->SetConformantField( pConformantField );
        }

}

CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_STRUCT *pClass )  
{
   
   // Create the structure node first to handle recursion correctly.
   CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );
   CG_STRUCT *pNewStruct = NULL;
   BOOL bIsComplex = FALSE;


   XLAT_SIZE_INFO NewSizeInfo(pClass->GetMemoryAlignment(),
                              pClass->GetWireAlignment(),
                              pClass->GetMemorySize(),
                              pClass->GetWireSize(),
                              pClass->GetZp(),
                              0,
                              0);

   // Choose the currect structure type and return
   if ( pAnalysisInfo->IsForcedBogus() || pAnalysisInfo->IsFullBogus() )
       {
       
       bIsComplex = TRUE;
       if ( pAnalysisInfo->IsFullBogus() && pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_CONFORMANT_FULL_COMPLEX_STRUCT ( pClass->GetType(),
                                                                NewSizeInfo,
                                                                (unsigned short)pClass->HasPointer());
           }
       else if ( pAnalysisInfo->IsFullBogus() && !pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_FULL_COMPLEX_STRUCT ( pClass->GetType(),
                                                       NewSizeInfo,
                                                       (unsigned short)pClass->HasPointer());

           }

       else if ( pAnalysisInfo->IsForcedBogus() && pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_CONFORMANT_FORCED_COMPLEX_STRUCT ( pClass->GetType(),
                                                                NewSizeInfo,
                                                                (unsigned short)pClass->HasPointer());
           }
       else if ( pAnalysisInfo->IsForcedBogus() && !pAnalysisInfo->IsConformant() )
           {
           pNewStruct = new CG_FORCED_COMPLEX_STRUCT ( pClass->GetType(),
                                                       NewSizeInfo,
                                                       (unsigned short)pClass->HasPointer());

           }
       }
       
   else if (!pAnalysisInfo->IsVarying() && !pAnalysisInfo->IsConformant() )
       {
       pNewStruct = new CG_STRUCT( pClass->GetType(),
                                   NewSizeInfo,
                                   (unsigned short)pClass->HasPointer());       
       }
   else if (pAnalysisInfo->IsConformant() && pAnalysisInfo->IsVarying())
       {
       pNewStruct = new CG_CONFORMANT_VARYING_STRUCT( pClass->GetType(),
                                                      NewSizeInfo,
                                                      (unsigned short)pClass->HasPointer(),
                                                      NULL );       
       }
   else if (pAnalysisInfo->IsConformant() && !pAnalysisInfo->IsVarying())
       {
       pNewStruct = new CG_CONFORMANT_STRUCT( pClass->GetType(),
                                              NewSizeInfo,
                                              (unsigned short)pClass->HasPointer(),
                                              NULL );
       }
   else // !IsConformant && IsVariant( should be bogus )
       MIDL_ASSERT(0);

   *(GetAnalysisInfo( pNewStruct ) ) = *pAnalysisInfo;

   pRecursiveMap->Insert( pClass, pNewStruct );

   gplistmgr NewList;

   CG_ITERATOR Iterator;
   CG_CLASS *pChildCG = NULL;
   CG_CLASS *pNewChildCG = NULL;
   
   pClass->GetMembers( Iterator );

   ITERATOR_INIT( Iterator );
   while ( ITERATOR_GETNEXT( Iterator, pChildCG ) )
       {                                      
       pNewChildCG = ContinueTransform( pChildCG );
       NewList.Insert( pNewChildCG );
       }
   
   ITERATOR_INIT( NewList );
   pNewStruct->SetMembers( NewList );

   CG_UNROLLED_LIST UnrolledList;
   ILUnroll( pClass, &UnrolledList ); 

   ITERATOR_INIT( UnrolledList );

   // If the first field is a pad field, and the field has the same Alignments as this structure
   // delete the pad since it is redundant.
   CG_FIELD *pFirstField = (CG_FIELD*)UnrolledList.GetHead();
   CG_PAD *pPad = dynamic_cast<CG_PAD*>( pFirstField->GetChild() );

   if ( ( NULL != pPad) &&
        ( pFirstField->GetMemOffset() == 0 ) &&
        ( pFirstField->GetWireOffset() == 0 ) &&
        ( pPad->GetMemorySize() == 0 ) &&
        ( pPad->GetWireSize() == 0 ) &&
        ( pPad->GetMemoryAlignment() == pClass->GetMemoryAlignment() ) &&
        ( pPad->GetWireAlignment() == pClass->GetWireAlignment() ) )
       {
       UnrolledList.RemoveHead();
       }

   pNewStruct->SetMembers( UnrolledList );

   if ( pAnalysisInfo->IsConformant() )
       {
       CG_CLASS *pConformatField = static_cast<CG_CLASS*>( UnrolledList.GetTail() );
       dynamic_cast<CG_CONFORMANT_STRUCT*>( pNewStruct )->SetConformantField( pConformatField );
       }

   if (bIsComplex)
       {
       RegionalizeStruct( dynamic_cast<CG_COMPLEX_STRUCT*>( pNewStruct ) ); 
       }

   return pNewStruct;
}

// An encapsulated struct is really a union, so don't treat it like a struct.
CG_CLASS* CG_TRANSFORM_VISITOR::DoTransform( CG_ENCAPSULATED_STRUCT *pClass )
{
   return DoTransform( (CG_CLASS*) pClass );
}

// 
//
//   Unrolling code.
// 
//
//   Note, if recursion occures it must be through a struct or union.
//   Structures, fields, arrays, and pointers are cloned.  

class CG_UNROLL_VISITOR 
{
private:
  CG_UNROLLED_LIST *pParentList;
  BOOL bInPointerOrArray;

  CG_ILANALYSIS_INFO* GetAnalysisInfo( CG_CLASS *pClass ) {return pClass->GetILAnalysisInfo(); }

  void ContinueUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pUnrolledList, 
                       BOOL bInPointerOrArray );
public:
  
  void Visit( CG_CLASS  *pClass );
  void Visit( CG_STRUCT *pClass );
  void Visit( CG_ENCAPSULATED_STRUCT *pClass );
  void Visit( CG_UNION *pClass );
  void Visit( CG_FIELD *pClass );
  void Visit( CG_POINTER *pClass );
  void Visit( CG_ARRAY *pClass );

  static void StartUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pUnrolledList );
};

void ILUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pList )
{
   CG_UNROLL_VISITOR::StartUnroll( pClass, pList );
}

void CG_UNROLL_VISITOR::ContinueUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pParentList, 
                                        BOOL bInPointerOrArray )
{
    if ( NULL != pClass )
        {
        CG_VISITOR_TEMPLATE< CG_UNROLL_VISITOR > TemplateVisitor;
        CG_UNROLL_VISITOR & Visitor = TemplateVisitor;
        
        Visitor.pParentList         = pParentList;
        Visitor.bInPointerOrArray   = bInPointerOrArray;
    
        pClass->Visit( &TemplateVisitor );
        }
}

void CG_UNROLL_VISITOR::StartUnroll( CG_CLASS *pClass, CG_UNROLLED_LIST *pUnrolledList )
{
   CG_VISITOR_TEMPLATE< CG_UNROLL_VISITOR > TemplateVisitor;
   CG_UNROLL_VISITOR & Visitor = TemplateVisitor;
   
   Visitor.pParentList          = pUnrolledList;
   Visitor.bInPointerOrArray    = FALSE;

   if ( NULL != pClass )
       {
       pClass->Visit( &TemplateVisitor );
       }  

}

void CG_UNROLL_VISITOR::Visit( CG_CLASS *pClass )
{
    // Do not unroll random nodes in the tree.
    pParentList->Insert( pClass );
}

void CG_UNROLL_VISITOR::Visit( CG_STRUCT *pClass )
{ 
        
    if ( bInPointerOrArray )
        {
        pParentList->Insert( pClass );
        return;        
        }
    
    CG_UNROLLED_LIST UnrolledList;
    CG_ITERATOR Iterator;
    CG_FIELD *pField;    
    pClass->GetMembers( Iterator );
    
    // Get the first field of the structure, and if the first field has an aligment requirement
    // that is different from structure, add a pad field.

    ITERATOR_INIT( Iterator );
    BOOL HasField = (BOOL)ITERATOR_GETNEXT( Iterator, pField);
        
    if ( !HasField ||
         ( pField->GetWireAlignment() != pClass->GetWireAlignment() ) )
         {

         // Create a pad field for the start of the list
        
         XLAT_SIZE_INFO Info( pClass->GetMemoryAlignment(),
                              pClass->GetWireAlignment(),
                              0, // Memory size
                              0, // Wire size
                              pClass->GetZp(),
                              0, // MemOffset
                              0 // WireOffset
                              );
     
         CG_FIELD *pPadField = new CG_FIELD( pClass->GetType(), Info );
         CG_PAD *pPadItem = new CG_PAD( pClass->GetType(), Info );
         pPadField->SetChild( pPadItem );

         UnrolledList.Insert( pPadField );

         }



    ITERATOR_INIT( Iterator );
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        ContinueUnroll( pField, &UnrolledList, bInPointerOrArray );
        }

    // If this was a simple struct, set the region hint
    // to make the region code more efficient. 
    CG_ILANALYSIS_INFO *pAnalysisInfo = GetAnalysisInfo( pClass );

    BOOL bIsSimpleStruct = !pAnalysisInfo->IsConformant() &&
                           !pAnalysisInfo->IsVarying() &&
                           !pAnalysisInfo->IsFullBogus() &&
                           !pAnalysisInfo->IsForcedBogus();

    if ( bIsSimpleStruct )
        {
        ITERATOR_INIT( UnrolledList );
        while( ITERATOR_GETNEXT( UnrolledList, pField ) ) 
            pField->SetRegionHint( pClass );
        
        ITERATOR_INIT( UnrolledList );        
        }

    pParentList->MergeToTail( &UnrolledList,
                              FALSE ); // Do not delete stack allocated list 
}

void CG_UNROLL_VISITOR::Visit( CG_ENCAPSULATED_STRUCT *pClass )
{
    // Do not unroll encapsulated unions.  
    
    pParentList->Insert( pClass );

}

void CG_UNROLL_VISITOR::Visit( CG_UNION *pClass )
{
    // Unions cannot have sized pointers or arrays, but the union needs to be cloned
    // since the switch expression may be correlated with a different variable.

    CG_UNION *pNewClass = (CG_UNION*)pClass->Clone();
    pParentList->Insert(pNewClass);
}

void CG_UNROLL_VISITOR::Visit( CG_FIELD *pClass )
{
    CG_UNROLLED_LIST UnrolledList;

    ContinueUnroll( pClass->GetChild(), &UnrolledList, bInPointerOrArray );
    
    // We had to have unrolled a structure to get here
        
    ITERATOR_INIT( UnrolledList );
    CG_CLASS *pChild;

    while( ITERATOR_GETNEXT( UnrolledList, pChild ) )
        {
        CG_FIELD *pField = dynamic_cast<CG_FIELD*>( pChild );
          if ( !pField )
            {
            // The child is not a field, so no offset calculation
            // needs to be done.  Just clone yourself and insert to into the list.

            CG_FIELD *pNewField = ( CG_FIELD *) pClass->Clone();
            *GetAnalysisInfo( pNewField ) = *GetAnalysisInfo( pClass );
            pNewField->SetChild( pChild );
            pParentList->Insert( pNewField );
            }
        
        else 
            {

            // We you arn't unrolling a region, append this field's 
            // name to the unrolled field.

            if ( !pClass->IsRegionField() )
                pField->AddPrintPrefix( pClass->GetSymName() );

            // The child is a field, so adjust the offset and append the print prefix.  

            pField->SetMemOffset( pClass->GetMemOffset() + pField->GetMemOffset() );      
            pField->SetWireOffset( pClass->GetWireOffset() + pField->GetWireOffset() );

            pParentList->Insert( pField );
            }
        }
}

void CG_UNROLL_VISITOR::Visit( CG_POINTER *pClass )
{

    CG_CLASS *pNewClass = pClass->Clone();
    *GetAnalysisInfo(pNewClass) = *GetAnalysisInfo(pClass);

    CG_UNROLLED_LIST UnrolledList;

    // We stop unrolling at this point, and switch to cloning.
    // That means that the items in the list are actual items instead 
    // of structure fields.  Since we're not unrolling anymore, we can
    // only have a single child.  Note that some pointers such as interface
    // pointers do not have a child.

    ContinueUnroll( pClass->GetChild(),  &UnrolledList, TRUE );

    MIDL_ASSERT( ( ITERATOR_GETCOUNT( UnrolledList ) == 1 ) ||
		    ( ITERATOR_GETCOUNT( UnrolledList ) == 0 ) );

    ITERATOR_INIT( UnrolledList );
    pNewClass->SetMembers( UnrolledList );

    // We are in deep trouble if our child is a field! 
    MIDL_ASSERT( dynamic_cast<CG_FIELD*>( pClass->GetChild() ) == NULL );

    pParentList->Insert( pNewClass );

}

void CG_UNROLL_VISITOR::Visit( CG_ARRAY *pClass )
{
    
    CG_CLASS *pNewClass = pClass->Clone();
    *GetAnalysisInfo(pNewClass) = *GetAnalysisInfo(pClass);

    CG_UNROLLED_LIST UnrolledList;
    
    // We stop unrolling at this point, and switch to cloning.
    // That means that the items in the list are actual items instead 
    // of structure fields.  Since we're not unrolling anymore, we can
    // only have a single child. 

    ContinueUnroll( pClass->GetChild(), &UnrolledList, TRUE );

    MIDL_ASSERT( ITERATOR_GETCOUNT( UnrolledList ) == 1 );

    ITERATOR_INIT( UnrolledList );
    pNewClass->SetMembers( UnrolledList );

    // We are in deep trouble if our child is a field! 
    MIDL_ASSERT( dynamic_cast<CG_FIELD*>( pClass->GetChild() ) == NULL );

    pParentList->Insert( pNewClass );
}

//
// Master control for this stage
//

CG_CLASS* ILSecondGenTransform( CG_CLASS *pClass )
{
    CG_ILANALYSIS_VISITOR::StartAnalysis( pClass );
    CG_CLASS *pResult = CG_TRANSFORM_VISITOR::StartTransform( pClass );

    return pResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ilcore.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    ilcore.cxx

 Abstract:

    Intermediate Language translator for core typegraph

 Notes:


 Author:

    GregJen Dec-24-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/

 /****************************************************************************
 *      include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilxlat.hxx"
#include "ilreg.hxx"


/****************************************************************************
 *      local data
 ***************************************************************************/


/****************************************************************************
 *      externs
 ***************************************************************************/

extern CMD_ARG    * pCommand;
extern BOOL         IsTempName( char *);
extern REUSE_DICT * pReUseDict;

/****************************************************************************
 *      definitions
 ***************************************************************************/




// #define trace_cg

//--------------------------------------------------------------------
//
// node_href::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_href::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_href,\t%s\n", GetSymName());
#endif
    if ( !GetChild() )
        {
        named_node * pRef = Resolve();
        if ( !pRef )
            {
            SemError( this, *pContext, UNSATISFIED_HREF, GetSymName() );
            exit( UNSATISFIED_HREF );
            }
        }
    return GetChild()->ILxlate( pContext );
}

//--------------------------------------------------------------------
//
// node_forward::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_forward::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_forward,\t%s\n", GetSymName());
#endif
    // MIDL_ASSERT( GetChild() && "unsatisfied node_forward encountered" );

    node_skl* pChild = GetChild();
    // forward interface definitions return null
    if ( ( pContext->GetParent()->IsInterfaceOrObject() ) &&
            ( pChild->NodeKind() == NODE_INTERFACE_REFERENCE ) )
        return NULL;

    if ( pChild )
        {
        // pass it on to the child...
        return pChild->ILxlate( pContext );
        }
    else
        {
        // try again
        pChild = ResolveFDecl();
        if ( pChild )
            {
            // pass it on to the child...
            return pChild->ILxlate( pContext );
            }
        else
            {
            SemError( this, *pContext, UNSATISFIED_FORWARD, GetSymName() );
            exit( UNSATISFIED_FORWARD );
            }
        }

};

//--------------------------------------------------------------------
//
// node_id::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_id::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_id,\t%s\n", GetSymName());
#endif

    XLAT_CTXT   MyContext( this, pContext );
    CG_CLASS  * pCG;

    MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute(ATTR_HIDDEN);

    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    pCG = GetChild()->ILxlate( &MyContext );

    if (NODE_MODULE == pContext->GetParent()->NodeKind())
        {
        CG_ID * pID = new CG_ID (this, MyContext);
        pID->SetChild(pCG);
        pCG = pID;
        }

    pContext->ReturnSize( MyContext );

    return pCG;

};


//--------------------------------------------------------------------
//
// node_field::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_field::ILxlate( XLAT_CTXT * pContext )
{

    CG_NDR       *  pCG;
    CG_CLASS     *  pChildCG;
    XLAT_CTXT       MyContext( this, pContext );
    BOOL            fUnionField;
    CG_CASE      *  pFirstCase;
    CG_CASE      *  pCurCase;
    expr_node    *  pSwitchExpr = NULL;
    node_su_base *  pParent     = (node_su_base *)pContext->GetParent();
    BOOL            fConfFld    = FALSE;

    MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_IDLDESCATTR);
    MyContext.ExtractAttribute(ATTR_VARDESCATTR);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HIDDEN);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

#ifdef trace_cg
    printf("..node_field,\t%s\n", GetSymName());
#endif

    if ( ( fUnionField = ( MyContext.FInSummary( ATTR_CASE ) ||
            MyContext.FInSummary( ATTR_DEFAULT ) ) ) != 0 )
        {
        CG_CASE   * pPrevCase = NULL;
        node_case * pCaseAttr;
        expr_list * pExprList;
        expr_node * pExpr;

        pCG = new CG_UNION_FIELD( this, MyContext );

        // for each case attribute, make a CG_CASE for each expr in the attr
        while ( ( pCaseAttr = (node_case *) MyContext.ExtractAttribute( ATTR_CASE ) ) != 0 )
            {
            pExprList = pCaseAttr->GetExprList();
            pExprList->Init();
            while ( pExprList->GetPeer( &pExpr ) == STATUS_OK )
                {
                pCurCase = new CG_CASE( this, pExpr );
                pCurCase->SetChild( pCG );
                if ( pPrevCase )
                    pPrevCase->SetSibling( pCurCase );
                else
                    pFirstCase = pCurCase;
                pPrevCase = pCurCase;
                }
            }

        // now process the default, if any
        if ( MyContext.ExtractAttribute( ATTR_DEFAULT ) )
            {
            pCurCase = new CG_DEFAULT_CASE( this );
            pCurCase->SetChild( pCG );
            if ( pPrevCase )
                pPrevCase->SetSibling( pCurCase );
            else
                pFirstCase = pCurCase;
            pPrevCase = pCurCase;
            }

        // mark the last case for this arm
        pCurCase->SetLastCase( TRUE );
        }

    // if we have a switch_is expr, fetch it..
    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        {
        node_switch_is * pAttr;
        if ( pCommand->IsNDR64Run() )
            {
            pAttr = (node_switch_is*)MyContext.GetAttribute( ATTR_SWITCH_IS );
            }
        else 
            {
            pAttr = (node_switch_is*)MyContext.ExtractAttribute( ATTR_SWITCH_IS );
            }
        pSwitchExpr = pAttr->GetExpr();
        }

    // process the child of the field
    pChildCG = GetChild()->ILxlate( &MyContext );

    // can't use attribute list after here...

    MyContext.AdjustForZP();            // fix up alignments for current ZP
    MyContext.GetOffset( *pContext );   // offset in parent struct/union

    node_skl * pBasic  = GetBasicType();

    // If this is NDR64, treat conformant fields the same
    // as nonconformant fields since conformant arrays
    // have an alignment even is they have 0 elements.
    if ( !pCommand->IsNDR64Run() &&
         pParent->HasConformance() &&
            IsLastField() &&
            ( pBasic->NodeKind() != NODE_STRUCT ) &&
            !fUnionField)               // if I'm a conf. field
        {
        fConfFld = TRUE;
        MyContext.AlignConfOffset();    // round mem, not wire up to alignment
        }
    else if ( pBasic->IsEncapsulatedStruct() ||
            ( pBasic->NodeKind() == NODE_UNION ) )
        {
        MyContext.AlignEmbeddedUnion();
        }
    else
        {
        MyContext.AlignOffset();    // round up to alignment
        }

    CG_FIELD *pField = NULL;

    if (fUnionField )
        {
        pCG->SetChild( pChildCG );
        pCG = pFirstCase;
        pField = (CG_FIELD *) pCG->GetChild();
        MIDL_ASSERT( ID_CG_UNION_FIELD == pField->GetCGID() );
        pContext->ReturnUnionSize( MyContext ); // return size and alignment
        }
    else
        {
        pField = new CG_FIELD( this, MyContext );
        pField->SetChild( pChildCG );
        pField->SetSwitchExpr( pSwitchExpr );
        pCG = pField;
        pContext->ReturnOffset( MyContext );    // return rounded-up offset

        // Treat conformant fields the same as non-conformant fields in Ndr64.
        // The wire-size and wire_offset should be 0 though.
        if ( !pCommand->IsNDR64Run() && fConfFld )
            pContext->ReturnConfSize( MyContext );  // don't munge wire size!
        else
            pContext->ReturnSize( MyContext );  // return size and alignment
        }

    if ( HasUnknownRepAs() )
        pField->SetHasEmbeddedUnknownRepAs();

    if ( fConfFld )
        {
        pCG->SetMemorySize( 0 );
        pCG->SetWireSize( 0 );
        }
    return pCG;
};

//--------------------------------------------------------------------
//
// node_bitfield::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_bitfield::ILxlate( XLAT_CTXT* pContext )
{
#ifdef trace_cg
    printf("..node_bitfield,\t%s\n", GetSymName());
#endif

    XLAT_CTXT       MyContext( this, pContext );

    SemError( this, MyContext, FAILED_TO_GENERATE_BIT_FIELD, GetSymName() );

    return NULL;
};

//--------------------------------------------------------------------
//
// node_enum::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_enum::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_enum,\t%s\n", GetSymName());
#endif

    XLAT_CTXT       MyContext( this, pContext );
    node_range_attr* pRange = (node_range_attr*) MyContext.ExtractAttribute(ATTR_RANGE);
    node_base_attr  *pV1enum = MyContext.ExtractAttribute( ATTR_V1_ENUM );

    pContext->ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.EnumTypeSizes (
                            this,
                            // All enums are 32bit on wire in new syntax.
                            pCommand->IsNDR64Run() || pV1enum
                            );
    
    CG_ENUM *   pCG = new CG_ENUM( this, MyContext );

    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        pCG->SetRangeAttribute( pRange );
        }

    pContext->ReturnSize( MyContext );
    
    return pCG;

};

//--------------------------------------------------------------------
//
// node_struct::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_struct::ILxlate( XLAT_CTXT * pContext )
{

    MEM_ITER        MemIter( this );
    node_field  *   pN;
    CG_STRUCT   *   pCG;
    CG_CLASS    *   pChildCG        = NULL;
    CG_CLASS    *   pPrevChildCG    = NULL;
    CG_CLASS    *   pFirstChildCG   = NULL;
    XLAT_CTXT       MyContext( this, pContext );
    REUSE_INFO  *   pSaved;
    BOOL fHasMovedFields = FALSE;   // has fields with diff mem/wire offsets
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute(ATTR_HIDDEN);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_struct,\t%s\n", GetSymName());
#endif

    MyContext.ExtractAttribute( ATTR_STRING );

    // raw rpc doesn't care about uuid's on structs, typelibs get a new context
    // during GetTypeInfo.
    MyContext.ExtractAttribute(ATTR_GUID);
  
    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_NDR * pChildCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pChildCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pChildCG;
        }
    
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    // at this point, there should be no more attributes...

    MIDL_ASSERT( !MyContext.HasAttributes() );

    // store our own zp value for below

    MyContext.GetZeePee() = GetZeePee();

    // see if we were already generated
    if ( pReUseDict->GetReUseEntry( pSaved, this ) )
        {
        // reuse found...
        pSaved->FetchInfo( &MyContext, pChildCG );
        pContext->ReturnSize( MyContext );
        return pChildCG;
        }
        
    // manufature the CG node (to allow for recursion)
    switch (Complexity)
        {
        case FLD_PLAIN:
            {
            pCG = new CG_STRUCT( this,
                                 MyContext,
                                 HasAtLeastOnePointer()
                                 );
            break;
            }
        case FLD_CONF:
            {
            pCG = new CG_CONFORMANT_STRUCT( this,
                                            MyContext,
                                            HasAtLeastOnePointer(),
                                            NULL
                                            );
            break;
            }
        case FLD_CONF_VAR:
            {
            pCG = new CG_CONFORMANT_VARYING_STRUCT( this,
                                                    MyContext,
                                                    HasAtLeastOnePointer(),
                                                    NULL
                                                    );
            break;
            }
        case FLD_VAR:
        default:
            {
            pCG = new CG_COMPLEX_STRUCT( this,
                                         MyContext,
                                         HasAtLeastOnePointer(),
                                         NULL
                                         );
            break;
            }
        }

    // save our CG node so that recursive use can find it
    pSaved->SaveInfo( &MyContext, pCG);

    //
    // for each of the fields, call the core transformer.
    //

    while ( ( pN = (node_field *) MemIter.GetNext() ) != 0  )
        {
        pChildCG = pN->ILxlate( &MyContext );

        // adjust the size and current offset of the struct, special
        // case the conformant field ( last one )
        //
        // Except if this is the new transfer syntax.   In that case
        // the wire has a pad to the array even if the array has 0
        // elements.  This allows a case like this to be simple instead
        // of complex.
        //
        // struct MyStruct {
        //    char s;
        //    [size_is(s)] long s[];
        // };
        //

        if ( !pCommand->IsNDR64Run() &&
             ( fHasConformance &&
                   !pN->GetSibling() &&
                   ( pN->GetBasicType()->NodeKind() != NODE_STRUCT ) ) )
            {
            MyContext.AdjustConfSize();
            }
        else
            {
            MyContext.AdjustSize();
            }

        if ( !MyContext.SameOffsets() )
            fHasMovedFields = TRUE;

        // Add the field to the list of fields if it's available
        // pChildCG might be NULL if it's imported from .tlb and being 
        // processed earlier.
        if ( pChildCG )
            {
            if( pPrevChildCG )
                {
                pPrevChildCG->SetSibling( pChildCG );
                }
            else
                {
                pFirstChildCG = pChildCG;
                };

            pPrevChildCG = pChildCG;
            }
            else
                SemError( this, MyContext, FAILED_TO_GENERATE_FIELD, GetSymName() );

        // get the type of the field to determine kind of struct
        }

    // conformant structs don't get trailing padding
    if ( !fHasConformance )
        // The new transfer syntax pads the wire size for structures to the 
        // the new wire alignment.
        if ( pCommand->IsNDR64Run() )
            {
            MyContext.Ndr64AdjustTotalStructSize();
            }
        else 
            {
            MyContext.AdjustTotalSize();
            }

    pContext->ReturnSize( MyContext );

    pCG->SetChild( pFirstChildCG );

    // Sizes aren't determined until after the fields have been made, 
    // so we have to set them manually. For the same reason, i.e. because of
    // invalid recursive definitions, we check the memory size here.

    pCG->SetSizesAndAlignments( MyContext );

    if ( pCommand->IsNDR64Run() )
        {

        if ( pCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
        }
    else if ( pCG->GetMemorySize() > 65535 )
        {
        SemError( this, MyContext, STRUCT_SIZE_EXCEEDS_64K, NULL );
        exit( STRUCT_SIZE_EXCEEDS_64K );
        }

    // this picks up whatever is the last field...
    if ( fHasConformance )
        ((CG_CONFORMANT_STRUCT *) pCG)->SetConformantField( pChildCG );

    if ( fHasMovedFields )
        {
        pCG->SetHasMovedFields();
        }

    pSaved->SaveInfo( &MyContext, pCG);

    return pCG;
};

//--------------------------------------------------------------------
//
// node_en_struct::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_en_struct::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER        MemIter( this );
    node_skl    *   pN;
    CG_STRUCT   *   pCG;
    CG_CLASS    *   pChildCG        = NULL;
    CG_CLASS    *   pPrevChildCG    = NULL;
    CG_CLASS    *   pFirstChildCG   = NULL;
    XLAT_CTXT       MyContext( this, pContext );
    REUSE_INFO  *   pSaved;

#ifdef trace_cg
    printf("..node_en_struct,\t%s\n", GetSymName());
#endif


    // store our own zp value for below

    MyContext.GetZeePee() = GetZeePee();
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    // raw rpc doesn't care about uuid's on structs, typelibs get a new context
    // during GetTypeInfo.
    MyContext.ExtractAttribute(ATTR_GUID);

    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_HANDLE * pHdlCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pHdlCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pHdlCG;
        }

    // at this point, there should be no more attributes...

    MIDL_ASSERT( !MyContext.HasAttributes() );

    if ( pReUseDict->GetReUseEntry( pSaved, this ) )
        {
        // reuse found...
        pSaved->FetchInfo( &MyContext, pChildCG );
        pContext->ReturnSize( MyContext );
        return pChildCG;
        }

    // manufature the CG node (to allow for recursion)
    pCG = new CG_ENCAPSULATED_STRUCT( this,
                                      MyContext,
                                      HasAtLeastOnePointer()
                                      );

    // set that struct is encapsulated
    // pCG->SetIsEncapsulated();

    // save our CG node so that recursive use can find it
    pSaved->SaveInfo( &MyContext, pCG);

    //
    // for each of the fields, call the core transformer.
    //

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pChildCG = pN->ILxlate( &MyContext );
        MyContext.AdjustSize();

        if (pChildCG)
            {
            if( pPrevChildCG )
                {
                pPrevChildCG->SetSibling( pChildCG );
                }
            else
                {
                pFirstChildCG = pChildCG;
                };

            pPrevChildCG = pChildCG;
            }
        else
            SemError( this, MyContext, FAILED_TO_GENERATE_FIELD, GetSymName() );
        }

    MyContext.AdjustTotalSize();
    pContext->ReturnSize( MyContext );


    pCG->SetChild( pFirstChildCG );

    // set sizes manually, since they weren't known at constructor time.

    pCG->SetSizesAndAlignments( MyContext );

    if ( pCommand->IsNDR64Run() )
    {
        if ( pCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }
    else if ( pCG->GetMemorySize() > 65535 )
        {
        SemError( this, MyContext, STRUCT_SIZE_EXCEEDS_64K, NULL );
        exit( STRUCT_SIZE_EXCEEDS_64K );
        }

    pSaved->SaveInfo( &MyContext, pCG);

    return pCG;
};

//--------------------------------------------------------------------
//
// node_union::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_union::ILxlate( XLAT_CTXT * pContext )
{
    XLAT_CTXT               MyContext( this, pContext );
    MEM_ITER                MemIter( this );
    CG_CASE             *   pCurCaseCG;
    CG_CASE             *   pFirstCaseCG    = NULL;
    CG_CASE             *   pLastCaseCG     = NULL;
    CG_UNION            *   pUnionCG;
    node_field          *   pCurField;
    REUSE_INFO          *   pSaved;
    BOOL                    fMSUnion;
    BOOL                    fEncap          = IsEncapsulatedUnion();
    node_switch_type    *   pSwTypeAttr     = ( node_switch_type *)
                                                MyContext.ExtractAttribute( ATTR_SWITCH_TYPE );
    node_switch_is      *   pSwIsAttr       = NULL;
            
    node_skl            *   pReuseKey       = this;

    if ( pCommand->IsNDR64Run() )
        {
        pSwIsAttr = (node_switch_is *)MyContext.ExtractAttribute( ATTR_SWITCH_IS );

        if ( !fEncap )
            {
            pReuseKey = (node_skl*)pSwIsAttr;
            }
        }

    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_union,\t%s\n", GetSymName());
#endif
    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_NDR * pChildCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pChildCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pChildCG;
        }


    // decide if we are a MS union or a DCE union
    fMSUnion = (NULL != MyContext.ExtractAttribute( ATTR_MS_UNION ));

    fMSUnion = fMSUnion ||
               GetMyInterfaceNode()->FInSummary( ATTR_MS_UNION ) ||
               pCommand->IsSwitchDefined( SWITCH_MS_UNION );

    fMSUnion = fMSUnion && !fEncap;

    // store our own zp value for below

    MyContext.GetZeePee() = GetZeePee();

    if ( pReUseDict->GetReUseEntry( pSaved, pReuseKey ) )
        {
        CG_CLASS * pCG;

        // reuse found...
        pSaved->FetchInfo( &MyContext, pCG );
        pContext->ReturnSize( MyContext );
        return pCG;
        }

    pUnionCG = new CG_UNION( this,
                             MyContext,
                             HasAtLeastOnePointer()
                             );

    // save our CG node so that recursive use can find it
    pSaved->SaveInfo( &MyContext, pUnionCG);

    // process the union arms
    while ( ( pCurField = (node_field *) MemIter.GetNext() ) != 0 )
        {
        pCurCaseCG = (CG_CASE *) pCurField->ILxlate( &MyContext );
//      MyContext.AdjustSize();

        // add all the cases for the given field to the list

        if( pLastCaseCG )
            {
            pLastCaseCG->SetSibling( pCurCaseCG );
            }
        else
            {
            pFirstCaseCG = pCurCaseCG;
            };

        // advance pLastCaseCG to the end of the list
        pLastCaseCG = pCurCaseCG;
        MIDL_ASSERT( pLastCaseCG && "Null case list" );

        while ( pLastCaseCG->GetSibling() )
            pLastCaseCG = (CG_CASE *) pLastCaseCG->GetSibling();

        }

    // add a definition for the switch type to the CG node
    if ( pSwTypeAttr )
        {
        node_skl * pNode = pSwTypeAttr->GetType();
        // it gets its own context, so I doesn't mess up our sizing
        XLAT_CTXT SwTypeCtxt( &MyContext );

        CG_NDR * pSwCG = (CG_NDR *) pNode->ILxlate( &SwTypeCtxt );

        pUnionCG->SetSwitchType( pSwCG );
        }

    if ( pCommand->IsNDR64Run() && pSwIsAttr )
        {
        pUnionCG->SetNdr64SwitchIsExpr( pSwIsAttr->GetExpr() );
        }

    // add the case list to the union node and set all the union entries
    pUnionCG->SetChild( pFirstCaseCG );

    MyContext.AlignEmbeddedUnion();

    pUnionCG->SetSizesAndAlignments( MyContext );
    pUnionCG->SetUnionFlavor( unsigned short ( fMSUnion ? UNION_NONENCAP_MS : UNION_NONENCAP_DCE ) );

    if ( pCommand->IsNDR64Run() )
    {
        if ( pUnionCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }


    pSaved->SaveInfo( &MyContext, pUnionCG);

    if ( pCommand->IsNDR64Run() && !fEncap )
    {

        // If this is an nonencapsulated union, then we need to pass up the union alignment
        // instead of the arm alignment.  To do this, put the max of the arm alignment and
        // switchtype alignment is the context.

        // we don't care about union in tlb: they might not have switch

        CG_NDR * pSwCG = dynamic_cast<CG_NDR*>( pUnionCG->GetSwitchType() );

        if ( pSwCG != NULL )
            MyContext.GetWireAlign() = MyContext.GetWireAlign() > pSwCG->GetWireAlignment() ?
                                       MyContext.GetWireAlign() : pSwCG->GetWireAlignment();

    }
        

    pContext->ReturnSize( MyContext );

    return pUnionCG;
};

//--------------------------------------------------------------------
//
// node_en_union::ILxlate
//
// Notes:
//
//
// for an encapsulated union, we return the following tree:
//      CG_ENCAP_STRUCT ( with switch field )
//          |
//      CG_ENCAP_UNION
//          |
//      CG_CASE  -  CG_CASE  -  CG_CASE - CG_CASE
//          |           |           |
//      CG_UNION_FLD CG_UNION_FLD CG_UNION_FLD
//          |
//         etc.
//
//--------------------------------------------------------------------

CG_CLASS *
node_en_union::ILxlate( XLAT_CTXT * pContext )
{
    CG_UNION * pUnionCG;

#ifdef trace_cg
    printf("..node_en_union,\t%s\n", GetSymName());
#endif

    XLAT_CTXT               MyContext( this, pContext );

    // call non-encap union processor
    pUnionCG = (CG_UNION *) node_union::ILxlate( pContext );

    pUnionCG->SetUnionFlavor( UNION_ENCAP );
    
    if ( pCommand->IsNDR64Run() )
    {
        if ( pUnionCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }
    else if (pUnionCG->GetMemoryAlignment() > 16) 
        {
        SemError( this, MyContext, ENCAP_UNION_ARM_ALIGN_EXCEEDS_16, NULL );
        }

    return pUnionCG;
};

//--------------------------------------------------------------------
//
// node_def::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_def::ILxlate( XLAT_CTXT * pContext )
{
    CG_CLASS        *   pChildCG                = NULL;
    XLAT_CTXT           MyContext( this, pContext );
    node_transmit   *   pTransmitAttr   = (node_transmit *)
                                              MyContext.ExtractAttribute( ATTR_TRANSMIT );
    node_wire_marshal * pWireMarshalAttr= (node_wire_marshal *)
                                              MyContext.ExtractAttribute( ATTR_WIRE_MARSHAL );
    node_represent_as * pRepresentAttr  = (node_represent_as *)
                                              MyContext.ExtractAttribute( ATTR_REPRESENT_AS );
    node_user_marshal * pUserMarshalAttr= (node_user_marshal *)
                                              MyContext.ExtractAttribute( ATTR_USER_MARSHAL );
    node_cs_char      * pCSCharAttr     = (node_cs_char *)
                                              MyContext.ExtractAttribute( ATTR_CSCHAR );
    BOOL                fEncode         = (NULL !=
                                              MyContext.ExtractAttribute( ATTR_ENCODE ) );
    BOOL                fDecode         = (NULL !=
                                              MyContext.ExtractAttribute( ATTR_DECODE ) );

    node_guid *         pGUID           = (node_guid *)MyContext.ExtractAttribute(ATTR_GUID);
    node_version *      pVer            = (node_version *)MyContext.ExtractAttribute(ATTR_VERSION);
    node_constant_attr * pHC            = (node_constant_attr *)MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    node_text_attr *    pHelpStr        = (node_text_attr *)MyContext.ExtractAttribute(ATTR_HELPSTRING);
    XLAT_CTXT *         pIntfCtxt       = (XLAT_CTXT *) MyContext.GetInterfaceContext();
    BOOL                fIsHRESULT      = IsHResultOrSCode();
    REUSE_INFO * pSaved;

    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

#ifdef trace_cg
    printf("..node_def,\t%s\n", GetSymName());
#endif

    fEncode |= pIntfCtxt->FInSummary( ATTR_ENCODE );
    fDecode |= pIntfCtxt->FInSummary( ATTR_DECODE );

    // only direct children of the interface get these bits
    if ( !pContext->GetParent()->IsInterfaceOrObject() )
        {
        fEncode = FALSE;
        fDecode = FALSE;
        }
    BOOL fInLibrary = MyContext.AnyAncestorBits(IL_IN_LIBRARY);
    BOOL fHidden = (NULL != MyContext.ExtractAttribute(ATTR_HIDDEN));
    BOOL fPublic = FALSE;
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);

    // check for public attribute
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            case TATTR_PUBLIC:
                fPublic = TRUE;
                break;
            default:
                // MIDL_ASSERT(!"Illegal attribute found on node_def during ILxlate");
                break;
            }
        }
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    BOOL fNeedsCGTYPEDEF = fInLibrary &&
        (fPublic || NULL != pGUID || NULL != pVer || NULL != pHC || NULL != pHelpStr || fHidden)
        &&
        !(fEncode || fDecode || pRepresentAttr || pTransmitAttr ||
            pUserMarshalAttr || pWireMarshalAttr || pCSCharAttr);

    if (fNeedsCGTYPEDEF)
        {
        // see if we're already generated
            if (pReUseDict->GetReUseEntry(pSaved, this))
                {
                MyContext.ExtractAttribute( ATTR_V1_ENUM );

                // reuse found...
                pSaved->FetchInfo(&MyContext, pChildCG);
                pContext->ReturnSize(MyContext);
                return pChildCG;
                }
        }
  
    // process handle stuff
    if ( GetHandleKind() == HDL_CTXT )
        {
        MyContext.ExtractAttribute( ATTR_CONTEXT );
        }
    else if (GetHandleKind() == HDL_GEN)
        {
        MyContext.ExtractAttribute( ATTR_HANDLE );
        }    

    ////////////////////////////////////////////////////////////////////////
    // process the child, except for context handles and transmit_as types
    if ( ( GetHandleKind() != HDL_CTXT ) && !pTransmitAttr && !pWireMarshalAttr)
        {
        pChildCG = (CG_CLASS *) GetChild()->ILxlate( &MyContext );
        
        if (NULL != pChildCG && !IsTempName( GetSymName() ) )
            {
            switch ( pChildCG->GetCGID() )
                {
                // special case transmit_as to set the presented type
                case ID_CG_TRANSMIT_AS:
                        ((CG_TRANSMIT_AS *) pChildCG)->SetPresentedType( this );
                        break;
                case ID_CG_COCLASS:
                        break;
                // acf attributes are NOT transitive
                case ID_CG_REPRESENT_AS:
                case ID_CG_USER_MARSHAL:
                // odl attributes are also NOT transitive
                case ID_CG_TYPEDEF:
                        break;
                // idl attributes ARE transitive
                case ID_CG_CONTEXT_HDL:
                case ID_CG_GENERIC_HDL:
                default:
                    ((CG_NDR *)pChildCG)->SetType( this );
                }
            }

        // an HRESULT return type should be a CG_HRESULT
        if ( fIsHRESULT )
            {
            if ( !MyContext.FindAncestorContext( NODE_PARAM ) )
                {
                node_proc * pProc;
                WALK_CTXT * pProcCtxt =
                    MyContext.FindAncestorContext( NODE_PROC );

                if ( pProcCtxt )
                    {
                    pProc = (node_proc *)pProcCtxt->GetParent();
                    if ( pProc->FInSummary( ATTR_OBJECT ) ||
                            pProc->GetMyInterfaceNode()->FInSummary( ATTR_OBJECT ) )
                        {
                        pChildCG = new CG_HRESULT( this, MyContext );
                        }
                    }
                }
            }       // HRESULT tests
        }
    else if ( pTransmitAttr )
        {
        node_skl        *   pXmit;
        CG_TRANSMIT_AS  *   pTransCG;

        pXmit   = pTransmitAttr->GetTransmitAsType();

        // get rid of dangling attributes from the non-transmitted side
        // we've already picked up the attributes that go with our node
        MyContext.ClearAttributes();
        pChildCG = (CG_CLASS *) pXmit->ILxlate( &MyContext );

        MyContext.FixMemSizes( this );
        // if the child had generic handle, skip that...
        if ( pChildCG->GetCGID() == ID_CG_GENERIC_HDL )
            pChildCG = (CG_CLASS*) pChildCG->GetChild();

        pTransCG = new CG_TRANSMIT_AS( pXmit, this, MyContext );

        pTransCG->SetChild( pChildCG );
        pChildCG = pTransCG;
        }
   else if ( pWireMarshalAttr )
        {
        // Note that this is a node like for a transmit_as attribute,
        // but we map it into CG_USER_MARSHAL like for a user_marshal node.

        // "this" is the node for the presented type.

        node_skl * pXmit = pWireMarshalAttr->GetWireMarshalType();

        // get rid of dangling attributes from the non-transmitted side
        // we've already picked up the attributes that go with our node
        MyContext.ClearAttributes();
        pChildCG = (CG_CLASS *) pXmit->ILxlate( &MyContext );

        MyContext.FixMemSizes( this );

        // no support for user_marshal with Oi or Oi1.
        // Have to use Oi2 or Os.

        if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
              ! (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)  
            )
             SemError( this, MyContext, REQUIRES_I2, "[wire_marshal]" );

        CG_USER_MARSHAL * pUserCG = new CG_USER_MARSHAL(
                                        pXmit,
                                        GetSymName(), // pres type name
                                        this,
                                        MyContext,
                                        TRUE          // from transmit_as
                                    );

        pUserCG->SetChild( pChildCG );
        pChildCG = pUserCG;
        }

    if ( GetHandleKind() != HDL_NONE )
        {
        CG_NDR * pCG;

        if ( GetHandleKind() == HDL_CTXT )
            {
            MyContext.ContextHandleSizes( this );
            // remaining attributes are not needed e.g. pointer attrs
		    pCG = new CG_CONTEXT_HANDLE (
                                        this,
                                        0,
                                        MyContext
                                        );
            MyContext.ClearAttributes();
            }
        else    // HDL_GEN
            {
            pCG = new CG_GENERIC_HANDLE( this, NULL, MyContext );
            }

        pCG->SetChild( pChildCG );
        pChildCG = pCG;
        }

    if ( pRepresentAttr )
        {
        node_skl * pRepT  = pRepresentAttr->GetRepresentationType();

        if (pRepT)
            {
            MyContext.FixMemSizes( pRepT );
            }

        CG_REPRESENT_AS *   pRepCG = new CG_REPRESENT_AS(
            this,
            pRepresentAttr->GetRepresentationName(),
            pRepT,
            MyContext
            );

        pRepCG->SetChild( pChildCG );
        pChildCG = pRepCG;
        }
    else if ( pUserMarshalAttr )
        {
        node_skl * pUserT  = pUserMarshalAttr->GetRepresentationType();

        if (pUserT)
            {
            MyContext.FixMemSizes( pUserT );
            }

        // no support for user_marshal with Oi or Oi1.
        // Have to use Oi2 or Os.

        if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
              ! (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)  
            )
             SemError( this, MyContext, REQUIRES_I2, "[user_marshal]" );

        CG_USER_MARSHAL * pUserCG = new CG_USER_MARSHAL(
            this,
            pUserMarshalAttr->GetRepresentationName(),
            pUserT,
            MyContext,
            FALSE  // not from transmit_as
            );

        pUserCG->SetChild( pChildCG );
        pChildCG = pUserCG;
        }
    // wire marshal has to be under transmit as.

    if ( fEncode || fDecode )
        {
        CG_TYPE_ENCODE * pPickleCG;
        CG_PARAM       * pParamCG;
        CG_PROC        * pProcCG;

        pPickleCG = new CG_TYPE_ENCODE( this, fEncode, fDecode );
        pPickleCG->SetChild( pChildCG );

        pParamCG = new CG_PARAM( this,
            0,
            MyContext,
            NULL,
            0);
        pParamCG->SetChild( pPickleCG );

        pProcCG = new CG_TYPE_ENCODE_PROC( 0,
            this,
            NULL,
            NULL,
            0,
            0,
            0,
            0,
            0,
            NULL,
            unsigned short ( pCommand->Is64BitEnv() ? OPTIMIZE_ALL_I2_FLAGS :
                OPTIMIZE_INTERPRETER ),
            0,
            pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
        pProcCG->SetChild( pParamCG );

        pChildCG = (CG_CLASS *)pProcCG;
        }

    if ( pCSCharAttr )
        {
        MyContext.FixMemSizes( pCSCharAttr->GetUserType() );
        }

    if (fNeedsCGTYPEDEF)
        {
        if (NULL == pChildCG)
            {
                // The only way we should be able to get here is if we had a typedef
                // that contained a forward reference to an interface, dispinterface, etc.
                // MKTYPLIB disallowed this but we're gonna go ahead and allow it.
                pChildCG = ((node_interface *)GetChild())->GetCG(TRUE);
            }
        CG_TYPEDEF * pTD = new CG_TYPEDEF(this, MyContext);
        pTD->SetChild(pChildCG);
        pChildCG = (CG_CLASS *) pTD;

        // remember this node so we don't generate two of these
        pSaved->SaveInfo(&MyContext, pChildCG);
        }
    pContext->ReturnSize( MyContext );

    return pChildCG;

};


//--------------------------------------------------------------------
//
// node_pointer::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_pointer::ILxlate( XLAT_CTXT * pContext )
{
    node_skl*           pType       = GetBasicType();
    CG_CLASS        *   pChildCG    = NULL;
    CG_NDR          *   pCG         = NULL;
    XLAT_CTXT           MyContext( this, pContext );
    PTRTYPE             PtrKind     = PTR_UNKNOWN;
    FIELD_ATTR_INFO     FAInfo;
    node_allocate   *   pAlloc;
    short               AllocDetails = 0;
    node_byte_count *   pCountAttr;
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_pointer,\t%s\n", GetSymName());
#endif

    ////////////////////////////////////////////////////////////////////////
    // process misc attributes

    if ( ( pAlloc = (node_allocate *) MyContext.ExtractAttribute( ATTR_ALLOCATE ) ) != 0 )
        {
        AllocDetails    = pAlloc->GetAllocateDetails();
        }

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();

    // see if a param or return type context attr reached us...
    pCountAttr = (node_byte_count *)
        MyContext.ExtractAttribute( ATTR_BYTE_COUNT );

    ////////////////////////////////////////////////////////////////////////
    // process field attributes

    // see if we have any field attributes (are conformant or varying)
    FAInfo.SetControl( TRUE, pType->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Normalize();

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            if ( ( pType->NodeKind() == NODE_INTERFACE_REFERENCE || pType->IsInterfaceOrObject() )
                    && MyContext.AnyAncestorBits(IL_IN_LIBRARY) )
                {
                //This is an interface pointer without an [iid_is] attribute but in a type library.
                // we don't care about the pointee
                MIDL_ASSERT ( FAInfo.pIIDIsExpr  == NULL );
                node_skl* pIf = ( pType->NodeKind() == NODE_INTERFACE_REFERENCE ) ? 
                    ( ( node_interface_reference* ) pType )->GetRealInterface() : pType ;

                pCG     = new CG_INTERFACE_POINTER( this,
                                                    (node_interface *)pIf );
                node_skl* pAlias = GetChild();

                if ( pType->NodeKind() != NODE_INTERFACE_REFERENCE && pAlias && pAlias->NodeKind() == NODE_DEF)
                    {
                    ( (CG_INTERFACE_POINTER* ) pCG )->SetTypeAlias( ( CG_TYPEDEF* ) pAlias->ILxlate( &MyContext ) );
                    }
                }
            else if ( pCountAttr )
                {
                pCG =   new CG_BYTE_COUNT_POINTER( this,
                                                   PtrKind,
                                                   pCountAttr->GetByteCountParam() );
                }
            else
                {
                pCG =   new CG_POINTER( this,
                                        PtrKind,
                                        AllocDetails );
                }
            break;
            }
        case FA_VARYING:
            {
            pCG = new CG_LENGTH_POINTER( this,
                                         PtrKind,
                                         AllocDetails,
                                         &FAInfo );
            break;
            }
        case FA_CONFORMANT:
            {
            pCG = new CG_SIZE_POINTER( this,
                                       PtrKind,
                                       AllocDetails,
                                       &FAInfo );
            break;
            }
        case FA_CONFORMANT_VARYING:
            {
            pCG = new CG_SIZE_LENGTH_POINTER( this,
                                              PtrKind,
                                              AllocDetails,
                                              &FAInfo );
            break;
            }
        case FA_STRING:
            {
            pCG = new CG_STRING_POINTER( this,
                                         PtrKind,
                                         AllocDetails );
            if (FAInfo.StringKind == STR_BSTRING)
                {
                ((CG_STRING_POINTER *) pCG)->SetBStr();
                }
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            if (FAInfo.StringKind == STR_STRING)
                {
                pCG = new CG_SIZE_STRING_POINTER( this,
                                                  PtrKind,
                                                  AllocDetails,
                                                  &FAInfo );
                }
            break;
            }
        case FA_INTERFACE:
            {
            //This is an interface pointer with an [iid_is] attribute.
            // we don't care about the pointee
            node_skl* pIf = ( pType->NodeKind() == NODE_INTERFACE_REFERENCE ) ? 
                ( ( node_interface_reference* ) pType )->GetRealInterface() : pType ;
            pCG = new CG_IIDIS_INTERFACE_POINTER( this,
                                            pIf,
                                            FAInfo.pIIDIsExpr );
            break;
            }
        default:    // string + varying combinations
            {
            MIDL_ASSERT (!"Invalid pointer kind");
            break;
            }
        }


    // process any context_handle attributes from param nodes
    if ( MyContext.FInSummary( ATTR_CONTEXT ) )
        if ( pType->NodeKind() != NODE_POINTER )
            {
            MyContext.ExtractAttribute( ATTR_CONTEXT );
            MyContext.ContextHandleSizes( this );
            pContext->ReturnSize( MyContext );
		    pCG = new CG_CONTEXT_HANDLE (
                                        this,
                                        0,
                                        MyContext
                                        );
#ifdef trace_cg
            printf("..node_pointer return 1\n");
#endif
            return pCG;
            }

    // ignore pointers do not need to be rpc-able
    if ( MyContext.ExtractAttribute( ATTR_IGNORE ) )
        {
        MyContext.IgnoredPtrSizes();
        pContext->ReturnSize( MyContext );
        pCG = new CG_IGNORED_POINTER( this );

        return pCG;
        }


    ////////////////////////////////////////////////////////////////////////
    // process child
    node_skl*   pChild  = GetChild();

    if ( ( !pType->IsInterfaceOrObject() )  &&
         FAInfo.Kind != FA_INTERFACE        &&
         !pCG->IsInterfacePointer() )
        {
        pChildCG = GetChild()->ILxlate( &MyContext );
        }

    // if we are the pointer above an interface, we should get changed
    // into an interface pointer
    if ( ( ( pType->NodeKind() == NODE_INTERFACE_REFERENCE ) ||
            ( pType->IsInterfaceOrObject() ) )  &&
         !pCG->IsInterfacePointer() )
        {
        pCG = (CG_NDR *)pChildCG;
        pChildCG = NULL;
        }

    if ( pCG == 0 )
        {
        SemError( this, *pContext, UNDEFINED_SYMBOL, pChild->GetSymName() );
        exit( UNDEFINED_SYMBOL );
        }

    // do a three way merge of attributes to pass to parent.
    // Get a new context since the starting context was polleted with pointee attributes.

    XLAT_CTXT           NewPointerContext( this, pContext );
    NewPointerContext.BaseTypeSizes( this );

    pContext->ReturnSize( NewPointerContext);
    
    // update sizes with the size of the pointer
    pCG->SetSizesAndAlignments( NewPointerContext );

    pCG->SetChild( pChildCG );

    if ( HasCSType() )
    {
        node_def *pChild = (node_def *) GetChild();
        MIDL_ASSERT( NODE_DEF == pChild->NodeKind() );
        node_cs_char *p = (node_cs_char *) pChild->GetAttribute( ATTR_CSCHAR );
        MIDL_ASSERT( NULL != p );

        ( (CG_POINTER *) pCG )->SetCSUserType( p );

        CG_NDR *pUserTypeCG = (CG_NDR *) p->GetUserType()->ILxlate( &MyContext );
        p->SetElementSize( pUserTypeCG->GetMemorySize() );
    }

#ifdef trace_cg
    printf("..node_pointer return 2\n");
#endif
    return pCG;
}

//--------------------------------------------------------------------
//
// node_array::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_array::ILxlate( XLAT_CTXT * pContext )
{
    CG_CLASS        *   pChildCG;
    CG_ARRAY        *   pCG;
    unsigned short      Dimensions;
    PTRTYPE             PtrKind     = PTR_UNKNOWN;
    XLAT_CTXT           MyContext( this, pContext );
    FIELD_ATTR_INFO     FAInfo;
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_array,\t%s\n", GetSymName());
#endif

    // process any context_handle attributes from param nodes
    if ( MyContext.ExtractAttribute( ATTR_CONTEXT ) )
        {
        CG_NDR  * pCG;

        MyContext.ContextHandleSizes( this );
        pContext->ReturnSize( MyContext );
		pCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        return pCG;
        }

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();
    MIDL_ASSERT( PtrKind != PTR_UNKNOWN );

    // see if we have any field attributes (are conformant or varying)
    FAInfo.SetControl( FALSE, GetChild()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Normalize( pLowerBound, pUpperBound );

    // The 64bit transfer syntax has it's own mechanism
    // for propagating conformant/variance among array dimensions.
    if ( !pCommand->IsNDR64Run() )
        {
        // if we are multi-dimensional, absorb parent information
        if ( MyContext.AnyAncestorBits( IL_IN_MULTIDIM_CONF ) )
            FAInfo.Kind |= FA_CONFORMANT;
        // don't propogate varying down into a string
        if ( MyContext.AnyAncestorBits( IL_IN_MULTIDIM_VAR ) &&
                ( ( FAInfo.Kind & FA_STRING ) == 0 ))
            FAInfo.Kind |= FA_VARYING;
        }

    // if our child is also an array, tell it about us
    if ( GetBasicType()->NodeKind() == NODE_ARRAY )
        {
        if ( FAInfo.Kind & FA_CONFORMANT )
            MyContext.SetAncestorBits( IL_IN_MULTIDIM_CONF );
        if ( FAInfo.Kind & FA_VARYING )
            MyContext.SetAncestorBits( IL_IN_MULTIDIM_VAR );
        }
    else
        {
        MyContext.ClearAncestorBits( IL_IN_MULTIDIM_CONF | IL_IN_MULTIDIM_VAR );
        }

    // process the child
    pChildCG = GetChild()->ILxlate( &MyContext );

    MyContext.ArraySize( this, &FAInfo );

    // fetch # of dimensions from child;
    if ( pChildCG->IsArray() )
        {
        Dimensions = unsigned short ( ( (CG_ARRAY *) pChildCG )->GetDimensions() + 1 );
        // force all inner dimensions to be REF
        ( (CG_ARRAY *) pChildCG )->SetPtrType( PTR_REF );
        }
    else
        {
        Dimensions = 1;
        }

    // force embedded arrays to be REF
    if ( PtrKind != PTR_REF )
        {
        WALK_CTXT * pUpperCtxt = MyContext.GetParentContext();
        while ( pUpperCtxt )
            {
            NODE_T Kind = pUpperCtxt->GetParent()->NodeKind();
            if ( Kind == NODE_PARAM )
                break;
            else if ( Kind == NODE_DEF )
                {
                node_def * pNode = (node_def *) pUpperCtxt->GetParent();
                if ( pNode->FInSummary( ATTR_TRANSMIT ) ||
                        pNode->FInSummary( ATTR_REPRESENT_AS ) )
                    {
                    PtrKind = PTR_REF;
                    break;
                    }
                // else go up another level
                }
            else
                {
                PtrKind = PTR_REF;
                break;
                }
            pUpperCtxt = pUpperCtxt->GetParentContext();
            }
        }

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            pCG = new CG_FIXED_ARRAY( this,
                                      &FAInfo,
                                      Dimensions,
                                      MyContext );
            break;
            }
        case FA_VARYING:
            {
            pCG =   new CG_VARYING_ARRAY( this,
                                          &FAInfo,
                                          Dimensions,
                                          MyContext );

            break;
            }
        case FA_CONFORMANT:
            {
            pCG = new CG_CONFORMANT_ARRAY( this,
                                           &FAInfo,
                                           Dimensions,
                                           MyContext );

            break;
            }
        case FA_CONFORMANT_VARYING:
            {
            pCG = new CG_CONFORMANT_VARYING_ARRAY( this,
                                                   &FAInfo,
                                                   Dimensions,
                                                   MyContext );

            break;
            }
        case FA_STRING:
            {
            pCG = new CG_STRING_ARRAY( this,
                                       &FAInfo,
                                       Dimensions,
                                       MyContext );

            break;
            }
        case FA_CONFORMANT_STRING:
            {
            pCG = new CG_CONFORMANT_STRING_ARRAY( this,
                                                  &FAInfo,
                                                  Dimensions,
                                                  MyContext );

            break;
            }
        default:    // string + varying combinations
            {
            MIDL_ASSERT (!"invalid conf/var combination");
            break;
            }
        }

    pContext->ReturnSize( MyContext );
    pCG->SetPtrType( PtrKind );

    if ( HasCSType() )
    {
        node_def *pChild = (node_def *) GetChild();
        MIDL_ASSERT( NODE_DEF == pChild->NodeKind() );
        node_cs_char *p = (node_cs_char *) pChild->GetAttribute( ATTR_CSCHAR );
        MIDL_ASSERT( NULL != p );

        ( (CG_ARRAY *) pCG )->SetCSUserType( p );

        CG_NDR *pUserTypeCG = (CG_NDR *) p->GetUserType()->ILxlate( &MyContext );
        p->SetElementSize( pUserTypeCG->GetMemorySize() );
    }

    pCG->SetChild( pChildCG );

    if ( pCommand->IsNDR64Run() )
    {
        if ( pCG->GetMemorySize() >= SIZE_2GB )
            {
            SemError( this, MyContext, SIZE_EXCEEDS_2GB, NULL );
            exit( SIZE_EXCEEDS_2GB );
            }
    }

    return pCG;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ilctxt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    ilctxt.cxx

 Abstract:

    Intermediate Language translator context management routines

 Notes:


 Author:

    GregJen Jun-11-1993 Created.

 Notes:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "nodeskl.hxx"
#include "ilxlat.hxx"
#include "cmdana.hxx"
#include "optprop.hxx"
#include "ilreg.hxx"
#include "ndrcls.hxx"


/****************************************************************************
 *  externs
 ***************************************************************************/

extern CMD_ARG  * pCommand;

/****************************************************************************
 *  definitions
 ***************************************************************************/




// #define trace_cg
//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::XLAT_SIZE_INFO
//
// Notes:
//      
//
//
//--------------------------------------------------------------------
XLAT_SIZE_INFO::XLAT_SIZE_INFO(
    CG_NDR * pCG )
    {
    ZeePee      = pCommand->GetZeePee();
    MemAlign    = pCG->GetMemoryAlignment();
    WireAlign   = pCG->GetWireAlignment();
    MemSize     = pCG->GetMemorySize();
    WireSize    = pCG->GetWireSize();
    MemOffset   = 0;
    WireOffset  = 0;
    MustAlign   = false;
    }

//--------------------------------------------------------------------
//
// ::RoundToAlignment
//
// Helper round-up routine
//
// Notes:
//      
//
//
//--------------------------------------------------------------------

inline unsigned long
RoundToAlignment( unsigned long & Offset, unsigned short Alignment )
{
    unsigned long   AlignFactor = Alignment - 1;

    return (Offset = (Offset + AlignFactor) & ~AlignFactor );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::BaseTypeSizes
//
// Notes:
//      
// Merges attributes for a base type with the given context.
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::BaseTypeSizes( node_skl * pNode )
{
    unsigned short MS, WS;

    switch( pNode->NodeKind() )
        {
        case NODE_DOUBLE:
        case NODE_HYPER:
        case NODE_INT64:
        case NODE_LONGLONG:
            {
            MS=8; WS=8;
            break;
            };
        case NODE_INT128:
        case NODE_FLOAT80: //BUG, BUG double check this once VC supports
        case NODE_FLOAT128:
            {
            MS=16; WS = 16;
            break;
            }
        case NODE_POINTER:
        case NODE_HANDLE_T:
            {
            MS = (unsigned short) SIZEOF_MEM_PTR();
            WS = (unsigned short) SIZEOF_WIRE_PTR();
            break;
            };
        case NODE_INT3264:
            {
            MS = (unsigned short) SIZEOF_MEM_INT3264();
            WS = (unsigned short) SIZEOF_WIRE_INT3264();
            break;
            };
        case NODE_FLOAT:
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT:
        case NODE_E_STATUS_T:
            {
            MS=4; WS=4;
            break;
            };
        case NODE_SHORT:
        case NODE_WCHAR_T:
            {
            MS=2; WS=2;
            break;
            };
        case NODE_SMALL:
        case NODE_CHAR:
        case NODE_BOOLEAN:
        case NODE_BYTE:
            {
            MS=1; WS=1;
            break;
            };
        default:
            {
            MS=0; WS=0;
            break;
            }
        }

    GetMemSize()        = MS;
    GetMemAlign()       = __max(MS,GetMemAlign());

    GetWireSize()       = WS;
    GetWireAlign()      = __max(WS,GetWireAlign());

};

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::EnumTypeSizes
//
// Notes:
//      
// Merges in the sizes for an enum.
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::EnumTypeSizes( node_skl*, BOOL Enum32 )
/*
    Called when xlating node_enum: Enum32 means [enum_v1] used.
*/
{
    unsigned short MS, WS;

    // note - this needs to check environment
    WS  = unsigned short( ( Enum32 ) ? 4 : 2 );
    MS  = 4;

    GetMemSize()        = MS;
    GetMemAlign()       = __max(MS, GetMemAlign());

    GetWireSize()       = WS;
    GetWireAlign()      = __max(WS, GetWireAlign());

};

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ContextHandleSizes
//
// Notes:
//      
//
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::ContextHandleSizes( node_skl * pNode )
{
    FixMemSizes( pNode );

    GetWireSize()       = 20;
    GetWireAlign()      = 4;

};

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ArraySize
//
// Notes:
//      
//
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::ArraySize( node_skl*, FIELD_ATTR_INFO * pFA )
{
    // if conformant, set sizes to 0 and return

    if ( pFA->Kind & FA_CONFORMANT )
        {
        MemSize     =
        WireSize    = 0;
        return;
        }

    // round up element size to alignment boundary
    // Element is already rounded up.
    // RoundToAlignment( MemSize, MemAlign );
    // RoundToAlignment( WireSize, WireAlign );
    
    // compute number of elements and multiply...

    unsigned long       ElementCount;

    ElementCount = (ulong) pFA->pSizeIsExpr->GetValue();

    MemSize     *= ElementCount;
    WireSize    *= ElementCount;


}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::GetOffset
//
// Notes:
//  For use only by field nodes !!
//  
//  Fetch the offsets from another size info block
//
//--------------------------------------------------------------------


void                
XLAT_SIZE_INFO::GetOffset( XLAT_SIZE_INFO & pInfo )
{
    MemOffset   = pInfo.MemOffset;
    WireOffset  = pInfo.WireOffset;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AlignOffset
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AlignOffset()
{
    RoundToAlignment( MemOffset, MemAlign );
    RoundToAlignment( WireOffset, WireAlign );
}


//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AlignEmbeddedUnion
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//  don't round up the wire offset
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AlignEmbeddedUnion()
{
    RoundToAlignment( MemOffset, MemAlign );
    RoundToAlignment( MemSize,   MemAlign );
    // RoundToAlignment( WireOffset, WireAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AlignConfOffset
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//
//  the Mem offset passed down from the parent
//      of the conformant field is aligned
//  the Wire offset passed down from the parent is advanced by
//      the wire size and then aligned
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AlignConfOffset()
{
    RoundToAlignment( MemOffset, MemAlign );
    //WireSize  += WireOffset;
    WireOffset  +=  WireSize;
    RoundToAlignment( WireOffset, WireAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustForZP
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Round the offsets up to the corresponding alignments.
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustForZP()
{
    if ( ( MemAlign > ZeePee ) && !MustAlign ) MemAlign = ZeePee;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustSize
//
// Notes:
//  For use only by field and struct nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustSize()
{
    MemSize     += MemOffset;
    MemOffset   = MemSize;

    WireSize    += WireOffset;
    WireOffset  = WireSize;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustConfSize
//
// Notes:
//  For use only by field and struct nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustConfSize()
{
    MemSize     += MemOffset;
    MemOffset   = MemSize;

    // don't count padding before the conformance (in case it has size 0)
    /*****
    WireSize    += WireOffset;
    WireOffset  = WireSize;
     ******/
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::AdjustTotalSize
//
// Notes:
//  For use only by field and struct/union nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::AdjustTotalSize()
{
    RoundToAlignment( MemSize, MemAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::Ndr64AdjustTotalStructSize
//
// Notes:
//  For use only by field and struct nodes!!
//  
//  Add current offsets to current sizes
//  pad MemSize and BuffSize out to ZeePee
//
//--------------------------------------------------------------------

void
XLAT_SIZE_INFO::Ndr64AdjustTotalStructSize()
{
    RoundToAlignment( WireSize, WireAlign );
    RoundToAlignment( MemSize, MemAlign );
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::FixMemSizes
//
// Notes:
//      
// This routine fixes up mem sizes when they are different from what
// the IL translate of children generated
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::FixMemSizes( node_skl * pNode )
{
    FRONT_MEMORY_INFO MemInfo = pNode->GetMemoryInfo();
    MemSize = MemInfo.Size;
    MemAlign = MemInfo.Align;
    MustAlign = MemInfo.IsMustAlign;
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::IgnoredPointerSizes
//
// Notes:
//      
// This routine fixes up sizes for an ignored pointer
//
//--------------------------------------------------------------------


void
XLAT_SIZE_INFO::IgnoredPtrSizes()
{
    MemSize  =                  SIZEOF_MEM_PTR();
    MemAlign = (unsigned short) SIZEOF_MEM_PTR();
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ReturnSize
//
// Notes:
//
//  Copy the size information up into the parent.
//
//--------------------------------------------------------------------



void
XLAT_SIZE_INFO::ReturnSize( XLAT_SIZE_INFO & pCtxt )
{
    if ( pCtxt.MemAlign > MemAlign ) 
        MemAlign = pCtxt.MemAlign;
    MemSize = pCtxt.MemSize;

    if ( pCtxt.WireAlign > WireAlign ) 
        WireAlign = pCtxt.WireAlign;
    WireSize = pCtxt.WireSize;

    MustAlign = MustAlign || pCtxt.MustAlign;

    // note: ZeePee is NOT propogated up, only down
    // note: offsets are propogated up specially
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ReturnConfSize
//
// Notes:
//
//  Copy the size information up into the parent.
//  Don't overwrite the wire size the parent already has
//
//--------------------------------------------------------------------



void
XLAT_SIZE_INFO::ReturnConfSize( XLAT_SIZE_INFO & pCtxt )
{
    if ( pCtxt.MemAlign > MemAlign ) 
        MemAlign = pCtxt.MemAlign;
    MemSize = pCtxt.MemSize;

    if ( pCtxt.WireAlign > WireAlign ) 
        WireAlign = pCtxt.WireAlign;
    // WireSize     = pCtxt.WireSize;

    MustAlign = MustAlign || pCtxt.MustAlign;

    // note: ZeePee is NOT propogated up, only down
    // note: offsets are propogated up specially
}

//--------------------------------------------------------------------
//
// XLAT_SIZE_INFO::ReturnUnionSize
//
// Notes:
//
//  Copy the size information up into the parent.
//
//--------------------------------------------------------------------



void
XLAT_SIZE_INFO::ReturnUnionSize( XLAT_SIZE_INFO & pCtxt )
{
    if ( pCtxt.MemAlign > MemAlign )    MemAlign = pCtxt.MemAlign;
    if ( pCtxt.MemSize > MemSize )      MemSize  = pCtxt.MemSize;

    if ( pCtxt.WireAlign > WireAlign )  WireAlign = pCtxt.WireAlign;
    if ( pCtxt.WireSize > WireSize )    WireSize  = pCtxt.WireSize;

    MustAlign = MustAlign || pCtxt.MustAlign;
    
    // note: ZeePee is NOT propogated up, only down
    // note: offsets are propogated up specially
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ilbase.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    ilbase.cxx

 Abstract:

    Intermediate Language translator for base types

 Notes:


 Author:

    GregJen Dec-24-1993 Created.

 Notes:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilxlat.hxx"
#include "ilreg.hxx"


/****************************************************************************
 *  local data
 ***************************************************************************/


/****************************************************************************
 *  externs
 ***************************************************************************/

extern CMD_ARG              *   pCommand;
extern BOOL                     IsTempName( char *);
extern REUSE_DICT           *   pReUseDict;

/****************************************************************************
 *  definitions
 ***************************************************************************/

//--------------------------------------------------------------------
//
// node_skl::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_skl::ILxlate( XLAT_CTXT* )
{
#ifdef trace_cg
    printf("..node_skl... kind is %d\n",NodeKind() );
#endif
    return 0;
};

//--------------------------------------------------------------------
//
// node_base_type::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_base_type::ILxlate( XLAT_CTXT * pContext )
{
    CG_NDR  *       pCG;
    XLAT_CTXT       MyContext(this, pContext);
#ifdef trace_cg
    printf("..node_base_type,\t%s\n", GetSymName());
#endif
    MyContext.BaseTypeSizes( this );

    // Note that these nodes are all preallocated so the modifiers
    // and this node can be ignored.

    // process any context_handle attributes from param nodes
    if ( pContext->ExtractAttribute( ATTR_CONTEXT ) )
        {
        MyContext.FixMemSizes( this );
        pCG = new CG_CONTEXT_HANDLE (
                                    this,
                                    0,
                                    MyContext
                                    );
        }

    switch ( NodeKind() )
        {
        case NODE_HANDLE_T:
            {
            pCG = new CG_PRIMITIVE_HANDLE( this, NULL, MyContext );
            break;
            }
        case NODE_INT3264:
            {
            if ( pCommand->Is64BitEnv() )
                pCG = new CG_INT3264( this, MyContext );
            else
                pCG = new CG_BASETYPE( this, MyContext );
            break;
            }
        case NODE_VOID:
            {
            // VOID should only occur as as a single VOID param;
            // return NULL here, then the PARAM returns NULL as well
            if (!pContext->AnyAncestorBits(IL_IN_LIBRARY) )
                return NULL;
            }
            // this looks like a conditional fall through.. 
        default:
            {

            if ( pContext->AnyAncestorBits( IL_CS_STAG | IL_CS_DRTAG | IL_CS_RTAG ) )
                {
                pCG = new CG_CS_TAG(
                                this,
                                MyContext,
                                pContext->AnyAncestorBits( IL_CS_STAG ),
                                pContext->AnyAncestorBits( IL_CS_DRTAG ),
                                pContext->AnyAncestorBits( IL_CS_RTAG ) );
                }
            else
                {
                pCG = new CG_BASETYPE( this, MyContext );
                node_range_attr* pRA = ( node_range_attr* ) pContext->ExtractAttribute( ATTR_RANGE );
                if ( pRA != 0 && pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
                    {
                    pCG->SetRangeAttribute( pRA );
                    }
                }
            break;
            }
        };
    
    pContext->ReturnSize( MyContext );

#ifdef trace_cg
    printf("..node_base_type return \n");
#endif
    return pCG; 
};


//--------------------------------------------------------------------
//
// node_label::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_label::ILxlate( XLAT_CTXT * pContext )
{
    pContext->ExtractAttribute(ATTR_IDLDESCATTR);
    pContext->ExtractAttribute(ATTR_VARDESCATTR);
    pContext->ExtractAttribute(ATTR_ID);
    pContext->ExtractAttribute(ATTR_HIDDEN);

#ifdef trace_cg
    printf("..node_label,\t%s\n", GetSymName());
#endif


return NULL;
};


//--------------------------------------------------------------------
//
// node_e_status_t::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_e_status_t::ILxlate( XLAT_CTXT * pContext )
{
    XLAT_CTXT           MyContext( this, pContext );
    CG_ERROR_STATUS_T * pCG;
    
#ifdef trace_cg
    printf("..node_e_status_t,\t%s\n", GetSymName());
#endif

    MyContext.BaseTypeSizes( this );
    
    // gaj - do we need to see which we used ??
    MyContext.ExtractAttribute( ATTR_COMMSTAT );
    MyContext.ExtractAttribute( ATTR_FAULTSTAT );

    pContext->ReturnSize( MyContext );

    pCG = new CG_ERROR_STATUS_T( this, MyContext );
    return pCG;
};


//--------------------------------------------------------------------
//
// node_wchar_t::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_wchar_t::ILxlate( XLAT_CTXT * pContext )
{
    CG_BASETYPE     *   pCG;
    XLAT_CTXT           MyContext( this, pContext );

#ifdef trace_cg
    printf("..node_wchar_t,\t%s\n", GetSymName());
#endif

    MyContext.BaseTypeSizes( this );

    pContext->ReturnSize( MyContext );

    pCG = new CG_BASETYPE( this, MyContext );
    return pCG;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ilxlat.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    ilxlat.cxx

 Abstract:

    Intermediate Language translator

 Notes:


 Author:

    GregJen Jun-11-1993 Created.

 Notes:


 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilxlat.hxx"
#include "ilreg.hxx"
#include "control.hxx"
#include "tlgen.hxx"

/****************************************************************************
 *  local data
 ***************************************************************************/

// #define trace_cg 1

/****************************************************************************
 *  externs
 ***************************************************************************/

extern  CMD_ARG             *   pCommand;
extern  BOOL                    IsTempName( char *);
extern  ccontrol            *   pCompiler;
extern  REUSE_DICT          *   pReUseDict;
extern  SymTable            *   pBaseSymTbl;

/****************************************************************************
 *  definitions
 ***************************************************************************/

        
void
AddToCGFileList( CG_FILE *& pCGList, CG_FILE * pFile )
{
    if (pFile)
        {
        pFile->SetSibling( pCGList );
        pCGList = pFile;
        }
}

void XLAT_CTXT::InitializeMustAlign( node_skl * pPar ) 
{
    if (pPar)
        {
        if (pPar->GetModifiers().IsModifierSet(ATTR_DECLSPEC_ALIGN))
            {
            GetMustAlign() = true;
            GetMemAlign() = __max(GetMemAlign(),
                                  pPar->GetModifiers().GetDeclspecAlign());
            }
        }
}



//--------------------------------------------------------------------
//
// XLAT_CTXT::~XLAT_CTXT
//
// Notes:  If the node that created this context didn't remove all
//         the attributes it added, force the issue.  This is done
//         mostly because tlb generation short-circuits code
//         generation and tends to leave attributes hanging around.
//         This causes asserts and possibly other problems in random
//         places later on.  Also note that a lot of the top-level
//         stuff (interfaces, etc) don't strip much so you get lots
//         of hits with those.
//
//--------------------------------------------------------------------

XLAT_CTXT::~XLAT_CTXT()
{
    if ( !GetParent() || !GetParent()->HasAttributes() )
        return;
    
    named_node     *pNode = dynamic_cast<named_node *>(GetParent());
    type_node_list  attrs;
    node_base_attr *pAttr;

    MIDL_ASSERT( NULL != pNode);

    pNode->GetAttributeList(&attrs);

    while (ITERATOR_GETNEXT(attrs, pAttr))
    {
#ifdef DUMP_UNEXTRACTED_ATTRIBUTES
        extern void GetSemContextString(char *, node_skl *, WALK_CTXT *);
        char    szContext[1024];

        GetSemContextString(szContext, pNode, this);

        fprintf(
                stderr, 
                "Unextracted attribute: %s: %s\n", 
                pAttr->GetNodeNameString(),
                szContext );
#endif

        ExtractAttribute( pAttr->GetAttrID() );
    }
}



//--------------------------------------------------------------------
//
// IsComplexReturn
//
// Notes:  A complex return value is one that isn't be returned in an
//         ordinary register.  structs, unions, and floating point
//         values are complex
//
//--------------------------------------------------------------------

bool IsComplexReturn(node_skl *node)
{
    // straight dce doesn't support complex returns in intrepreted mode yet

    if ( !pCommand->NeedsNDR64Run() )
        return false;

    node = node->GetNonDefSelf();

    NODE_T kind = node->NodeKind();

    if (   NODE_STRUCT == kind
        || NODE_UNION  == kind
        || NODE_ARRAY  == kind
        || NODE_FLOAT  == kind
        || NODE_DOUBLE == kind 
        || ( NODE_HYPER == kind && pCommand->Is32BitEnv() ) )
    {
        return true;
    }
    
    // REVIEW: NODE_INT64, NODE_LONGLONG

    return false;
}


//--------------------------------------------------------------------
//
// node_file::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_file::ILxlate( XLAT_CTXT * pContext )
{
    node_interface  *   pI = 0;
    CG_CLASS        *   pcgInterfaceList = NULL;
    CG_CLASS        *   pPrevChildCG = NULL;

    CG_PROXY_FILE       *   pProxyCG    = NULL;
    CG_IID_FILE         *   pIidCG      = NULL;
    CG_TYPELIBRARY_FILE *   pLibCG      = NULL; 
    CG_NETMONSTUB_FILE  *   pNetmonCG   = NULL;
    CG_NETMONSTUB_FILE  *   pNetmonObjCG   = NULL;

    CG_CSTUB_FILE           *   pCCG        = NULL;
    CG_SSTUB_FILE           *   pSCG        = NULL;
    CG_HDR_FILE             *   pHCG        = NULL;

    CG_CLASS        *   pChildCG    = NULL;
    CG_FILE         *   pCGList     = NULL;

    char            *   pHdrName    = pCommand->GetHeader();
    XLAT_CTXT           MyContext(this);

    BOOL                HasObjectInterface  = FALSE;
    BOOL                HasRemoteProc       = FALSE;
    BOOL                HasRemoteObjectProc = FALSE;
    BOOL                HasDefs             = FALSE;
    BOOL                HasLibrary          = FALSE;
#ifdef trace_cg
    printf("..node_file,\t%s\n", GetSymName());
#endif

    // don't process for imported stuff
    if ( ImportLevel > 0 )
        {
        return NULL;
        }

    // at this point, there should be no more attributes...

    MIDL_ASSERT( !MyContext.HasAttributes() );

    //////////////////////////////////////////////////////////////////////
    // compute all the child nodes

    for(pI = (node_interface *)GetFirstMember();
        pI;
        pI = (node_interface *)pI->GetSibling())
    {
        // build a linked list of CG_INTERFACE and CG_OBJECT_INTERFACE nodes.
        // Notes: pChildCG points to first node.  pPrevChildCG points to last node.

        MyContext.SetInterfaceContext( &MyContext );
        pcgInterfaceList = pI->ILxlate( &MyContext );
        if(pcgInterfaceList)
            {
            if (pPrevChildCG)
                {
                pPrevChildCG->SetSibling( pcgInterfaceList );
                }
            else
                {
                pChildCG = pcgInterfaceList;
                }
            pPrevChildCG = pcgInterfaceList;
            // advance to the end of the list (skipping inherited interfaces)
            while ( pPrevChildCG->GetSibling() )
                pPrevChildCG = pPrevChildCG->GetSibling();

            switch(pPrevChildCG->GetCGID())
                {
                case ID_CG_INTERFACE:
                    //Check for a remote procedure.
                    if(pPrevChildCG->GetChild())
                        HasRemoteProc = TRUE;
                    HasDefs = TRUE;
                    break;
                case ID_CG_OBJECT_INTERFACE:
                case ID_CG_INHERITED_OBJECT_INTERFACE:
                    HasDefs = TRUE;
                    HasObjectInterface = TRUE;

                    //Check for a remote object procedure or base interface
                    if( pPrevChildCG->GetChild() ||
                        ((CG_OBJECT_INTERFACE *)pPrevChildCG)->GetBaseInterfaceCG() )
                        HasRemoteObjectProc = TRUE;
                    break;
                case ID_CG_LIBRARY:
                    HasLibrary = TRUE;
                    if( pCommand->IsSwitchDefined( SWITCH_HEADER ) )
                        HasDefs = TRUE;
                    break;
                default:
                    break;
                }
            }
    }

    // process the server and client stubs

    // make the list of imported files

    ITERATOR        *   pFileList   = new ITERATOR;
    named_node      *   pCur;

    // make a list of the file nodes included directly by the main file

    // start with the first child of our parent
    pCur = (named_node *)
            ((node_source *) pContext->GetParent())
                ->GetFirstMember();

    while ( pCur )
        {
        if ( ( pCur->NodeKind() == NODE_FILE ) &&
             ( ( (node_file *) pCur )->GetImportLevel() == 1 ) )
            {
            // add all the files imported at lex level 1
            ITERATOR_INSERT( (*pFileList), ((void *) pCur) );
            }
        pCur    = pCur->GetSibling();
        }

    ITERATOR_INIT( (*pFileList) );

    //////////////////////////////////////////////////////////////////////
    // manufacture the header file node

    if ( HasDefs )
        {
        pHCG    = new CG_HDR_FILE( this,
                                    pHdrName,
                                    pFileList);

        pHCG->SetChild( pChildCG );
        }

    //////////////////////////////////////////////////////////////////////
    // manufacture the CG_SSTUB_FILE

    // if the IDL file contains at least one remotable function in a
    // non-object interface, then generate a server stub file.
    //

    if ( HasRemoteProc &&
         (pChildCG != NULL) )   // if server stub desired
        {
        pSCG = new CG_SSTUB_FILE(
                             this,
                             ( pCommand->GenerateSStub() ) ?
                                    pCommand->GetSstubFName():
                                    NULL,
                             pHdrName
                              );

        // plug in the child subtree and add the sstub to the head of the list
        pSCG->SetChild( pChildCG );

        }

    //////////////////////////////////////////////////////////////////////
    // manufacture the CG_CSTUB_FILE

    // if the IDL file contains at least one remotable function in a
    // non-object interface, then generate a client stub file.

    if ( HasRemoteProc &&
         (pChildCG != NULL) )   // if client stub desired
        {
        pCCG = new CG_CSTUB_FILE(
                             this,
                             ( pCommand->GenerateCStub() ) ?
                                    pCommand->GetCstubFName():
                                    NULL,
                             pHdrName
                              );

        pCCG->SetChild( pChildCG );
       
        }

    // If the IDL file contains at least one remotable function in an
    // object interface, then generate a proxy file.
    if ( HasRemoteObjectProc &&
        (pChildCG != NULL) )    // if proxy file desired
        {
        pProxyCG = new CG_PROXY_FILE(
                             this,
                             ( pCommand->GenerateProxy() ) ?
                                    pCommand->GetProxyFName():
                                    NULL,
                             pHdrName
                              );

        pProxyCG->SetChild( pChildCG );

        }


    // If the IDL file contains at least one object interface,
    // then generate an IID file.
    if ( (HasObjectInterface || (HasLibrary && HasDefs) )&&
        (pChildCG != NULL) )    // if IID file desired
        {
        pIidCG = new CG_IID_FILE(
                             this,
                             ( pCommand->GenerateIID() ) ?
                                    pCommand->GetIIDFName():
                                    NULL);

        pIidCG->SetChild( pChildCG );
        }

    // If the IDL file contains a library then gnerate a TYPELIBRARY_FILE
    if (HasLibrary && (NULL != pChildCG) )
        {
#ifdef _WIN64
        bool fGenTypeLib = pCommand->Is64BitEnv() || ( pCommand->Is32BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#else
        bool fGenTypeLib = pCommand->Is32BitEnv() || ( pCommand->Is64BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#endif

        if ( fGenTypeLib && pCommand->GenerateTypeLibrary() )
            {
            pLibCG = new CG_TYPELIBRARY_FILE(
                            this,
                            pCommand->GetTypeLibraryFName() ) ;
            pLibCG->SetChild( pChildCG );
            }
        }

    // If the -netmon switch was used, generate the two NETMONSTUB_FILE's
    if ( pCommand->IsNetmonStubGenerationEnabled() ) 
        {
        if (HasRemoteProc) 
            {
            pNetmonCG = new CG_NETMONSTUB_FILE(
                FALSE,
                this,
                pCommand->GetNetmonStubFName());

            pNetmonCG->SetChild( pChildCG );
            }

        if (HasRemoteObjectProc) 
            {
            pNetmonObjCG = new CG_NETMONSTUB_FILE(
                TRUE,
                this,
                pCommand->GetNetmonStubObjFName());
            pNetmonObjCG->SetChild( pChildCG );
            }
        }

    /////////////////////////////////////////////////////////////////////
    // glue all the parts together by tacking onto the head of the list.
    // the final order is:
    // CStub - SStub - Proxy - IID - Hdr
    // doesn't need to create Hdr & tlb in ndr64 run. 
    pCGList = NULL;

    AddToCGFileList( pCGList, pNetmonObjCG );
    AddToCGFileList( pCGList, pNetmonCG );

    if ( !pCommand->Is2ndCodegenRun() )
        AddToCGFileList( pCGList, pHCG );

    if ( !pCommand->Is2ndCodegenRun() )
        AddToCGFileList( pCGList, pIidCG );
    AddToCGFileList( pCGList, pProxyCG );

    AddToCGFileList( pCGList, pSCG );
    AddToCGFileList( pCGList, pCCG );

    if ( !pCommand->Is2ndCodegenRun() )
        AddToCGFileList( pCGList, pLibCG );

    return pCGList;

};

//--------------------------------------------------------------------
//
// node_implicit::ILxlate
//
// Notes:
//
// This is a little bit different, since it is not a node_skl...
// therefore, it will not set up its own context
//
//--------------------------------------------------------------------

CG_CLASS *
node_implicit::ILxlate( XLAT_CTXT * pContext )
{
    CG_NDR      *   pCG;

    if ( pHandleType->NodeKind() == NODE_HANDLE_T )
        {
        pCG = new CG_PRIMITIVE_HANDLE( pHandleType,
                                         pHandleID,
                                         *pContext );
        }
    else    // assume generic handle
        {
        pCG = new CG_GENERIC_HANDLE( pHandleType,
                                       pHandleID,
                                       *pContext );
        }
#ifdef trace_cg
    printf("..node_implicit,\t\n");
#endif
    return pCG;
}


//--------------------------------------------------------------------
//
// node_proc::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_proc::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER            MemIter( this );
    node_param      *   pN;
    CG_PROC         *   pCG;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    CG_CLASS        *   pFirstChildCG   = NULL;
    CG_RETURN       *   pReturnCG       = NULL;
    CG_CLASS        *   pBinding        = NULL;
    CG_CLASS        *   pBindingParam   = NULL;
    BOOL                fHasCallback    = FALSE;
    BOOL                fNoCode         = FALSE;
    BOOL                fObject;
    BOOL                fRetHresult     = FALSE;
    BOOL                fEnableAllocate;
    XLAT_CTXT           MyContext( this, pContext );
    unsigned short      OpBits          = MyContext.GetOperationBits();
    XLAT_CTXT       *   pIntfCtxt       = (XLAT_CTXT *)
                                                MyContext.GetInterfaceContext();
    node_interface  *   pIntf           = (node_interface *)
                                                pIntfCtxt->GetParent();
    node_base_attr  *   pNotify,
                    *   pNotifyFlag;
    BOOL                HasEncode       = (NULL !=
                                            MyContext.ExtractAttribute( ATTR_ENCODE ) );
    BOOL                HasDecode       = (NULL !=
                                            MyContext.ExtractAttribute( ATTR_DECODE ) );
    node_call_as    *   pCallAs         = (node_call_as *)
                                            MyContext.ExtractAttribute( ATTR_CALL_AS );
    bool                fLocalProc      = MyContext.ExtractAttribute( ATTR_LOCAL ) != 0;
    BOOL                fLocal          = (BOOL ) fLocalProc ||
                                        pIntfCtxt->FInSummary( ATTR_LOCAL );
    BOOL                fLocalCall      = IsCallAsTarget();
    unsigned short      SavedProcCount = 0;
    unsigned short      SavedCallbackProcCount = 0;
    node_param      *   pComplexReturn = NULL;


    MyContext.ExtractAttribute( ATTR_ENTRY );
    MyContext.ExtractAttribute( ATTR_ID );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_IDLDESCATTR );
    MyContext.ExtractAttribute( ATTR_FUNCDESCATTR );
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_ASYNC );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
#ifdef trace_cg
    printf("..node_proc,\t%s\n", GetSymName());
#endif
    BOOL fSupressHeader = FALSE;
    unsigned long ulOptFlags;
    unsigned long ulStackSize = 0;

    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 );

    // do my attribute parsing...
    fHasCallback = (NULL != MyContext.ExtractAttribute( ATTR_CALLBACK ) );

    fObject = (NULL != MyContext.ExtractAttribute( ATTR_OBJECT )) ||
                        pIntfCtxt->FInSummary( ATTR_OBJECT );

    // do my attribute parsing... attributes to ignore here

    MyContext.ExtractAttribute( ATTR_OPTIMIZE );

    MyContext.ExtractAttribute( ATTR_EXPLICIT );

    HasEncode = HasEncode || pIntfCtxt->FInSummary( ATTR_ENCODE );
    HasDecode = HasDecode || pIntfCtxt->FInSummary( ATTR_DECODE );


    pNotify     = MyContext.ExtractAttribute( ATTR_NOTIFY );
    pNotifyFlag = MyContext.ExtractAttribute( ATTR_NOTIFY_FLAG );
    fEnableAllocate = (NULL != MyContext.ExtractAttribute( ATTR_ENABLE_ALLOCATE ));
    fEnableAllocate = fEnableAllocate ||
                      pIntfCtxt->FInSummary( ATTR_ENABLE_ALLOCATE ) ||
                      pCommand->IsRpcSSAllocateEnabled();

    // do my attribute parsing...
    // locally applied [code] attribute overrides global [nocode] attribute
    fNoCode = MyContext.ExtractAttribute( ATTR_NOCODE ) ||
              pIntfCtxt->FInSummary( ATTR_NOCODE );
    fNoCode = !MyContext.ExtractAttribute( ATTR_CODE ) && fNoCode;

    if ( NULL != MyContext.ExtractAttribute( ATTR_CSTAGRTN ) )
        MyContext.SetAncestorBits( IL_CS_HAS_TAG_RTN );

    BOOL fImported = FALSE;
    if ( GetDefiningFile() )
        {
        fImported = GetDefiningFile()->GetImportLevel() != 0;
        }

    if ( fLocalProc && !IsCallAsTarget() && fObject )
        {
        SemError( this, MyContext, LOCAL_NO_CALL_AS, 0 );
        }

    // determine if the proc is local and 
    // determine the proc number (local procs don't bump the number)
    if (fLocalCall || (fLocal && !fObject))
    {
            // return without making anything
            return NULL;
    }
    else
    {
        if ( fHasCallback )
            {
            ProcNum = ( pIntf ->GetCallBackProcCount() )++;
            }
        else
            {
            ProcNum = ( pIntf ->GetProcCount() )++;
            }
    }
   
    if ( fLocal && fObject && !MyContext.AnyAncestorBits(IL_IN_LIBRARY) )
        {

        if ( pIntf->IsValidRootInterface() )
            {
            pCG = new CG_IUNKNOWN_OBJECT_PROC( ProcNum,
                                             this,
                                             GetDefiningFile()->GetImportLevel() > 0,
                                             GetOptimizationFlags(),
                                             fHasDeny );
            }
        else
            {
            pCG = new CG_LOCAL_OBJECT_PROC( ProcNum,
                                             this,
                                             GetDefiningFile()->GetImportLevel() > 0,
                                             GetOptimizationFlags(),
                                             fHasDeny );
            }

        goto done;

        }

    SavedProcCount = pIntf->GetProcCount();
    SavedCallbackProcCount = pIntf->GetCallBackProcCount();

    // add the return type
    if ( HasReturn() )
        {
        node_skl    *   pReturnType = GetReturnType();
        CG_CLASS    *   pRetCG;

        // If the return value is complex it is treated in ndr as if a ref
        // pointer to the complex type was in the parameter list instead of
        // a true return value.  Temporarily add a parameter to the type
        // to get the back-end parameter created.

        if ( IsComplexReturn( pReturnType ) )
            {
            pComplexReturn = new node_param;
            pComplexReturn->SetSymName( RETURN_VALUE_VAR_NAME );
            pComplexReturn->SetChild( new node_pointer( pReturnType) );
            pComplexReturn->GetChild()->GetModifiers().SetModifier( ATTR_TAGREF );
            pComplexReturn->SetAttribute( new node_base_attr( ATTR_OUT ) );

            MemIter.AddLastMember( pComplexReturn );
            ITERATOR_INIT( MemIter );
            }
        else
            {
            pRetCG      = pReturnType->ILxlate( &MyContext );
            fRetHresult = (BOOL) ( pRetCG->GetCGID() == ID_CG_HRESULT );
            pReturnCG   = new CG_RETURN( pReturnType,
                                         MyContext,
                                         (unsigned short) RTStatuses );
            pReturnCG->SetChild( pRetCG );
            }
        }

    // at this point, there should be no more attributes...
    MIDL_ASSERT( !MyContext.HasAttributes() );

    pContext->ReturnSize( MyContext );

    if ( MemIter.GetNumberOfArguments() > 0 )
        {
        //
        // for each of the parameters, call the core transformer.
        //

        while ( ( pN = (node_param *) MemIter.GetNext() ) != 0 )
            {
            // REVIEW: One could argue that hidden status params
            //         aren't on the wire so there shouldn't be a CG node
            //         for them.  The main problem with this is that we
            //         need to be able to calculate a stack offset for the
            //         hidden param and that can only be done in the
            //         back end.

            // Hidden status params are not really [out] params but the way
            // the -Os generator builds up local resources requires them to
            // be.

            if ( pN->IsExtraStatusParam() 
                && ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
                {
                pN->SetAttribute( ATTR_OUT );
                }

            pChildCG = pN->ILxlate( &MyContext );

#ifdef trace_cg
    printf("back from..node_param %s\n",pN->GetSymName());
    printf("binding is now %08x\n",pBindingParam );
    printf("child is now %08x\n",pChildCG );
#endif

            // pChildCG could be NULL if it's imported from .tlb somewhere else already
            if ( pChildCG )
                {
                // the first binding param gets picked up for binding
                if ( !pBindingParam
                     && pN->IsBindingParam() )
                    {
#ifdef trace_cg
    printf("value for IsBindingParam is %08x\n",pN->IsBindingParam() );
    printf("binding found on node_param %s\n",pN->GetSymName());
    printf("binding is now %08x\n",pBindingParam );
#endif
                    pBindingParam = pChildCG;
                    }
    
                // build up the parameter list
                if( pPrevChildCG )
                    {
                    pPrevChildCG->SetSibling( pChildCG );
                    }
                else
                    {
                    pFirstChildCG = pChildCG;
                    };

            // this is only a calculated guess. We need more information to make an accurate
            // estimate.
                unsigned long ulSize = ( ( CG_PARAM* ) pChildCG )->GetStackSize();
                ulSize += (8 - (ulSize % 8));
                ulStackSize += ulSize;

                pPrevChildCG = pChildCG;
                }
            else
                SemError( this, MyContext, FAILED_TO_GENERATE_PARAM, pN->GetSymName() );
            }
        }

    ulOptFlags = GetOptimizationFlags();
    if ( ( ulOptFlags & OPTIMIZE_INTERPRETER ) &&
         !( ulOptFlags & OPTIMIZE_INTERPRETER_V2 ) &&
         ( ulStackSize > INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD ) )
        {
        if ( ForceNonInterpret() )
            {
            SemError( this, *pContext, OI_STACK_SIZE_EXCEEDED, 0 );
            }
        }
    if ( ulOptFlags & OPTIMIZE_INTERPRETER && ulStackSize > INTERPRETER_PROC_STACK_FRAME_SIZE_THRESHOLD )
        {
        if ( ForceNonInterpret() )
            {
            SemError( this, *pContext, STACK_FRAME_SIZE_EXCEEDED, GetSymName() );
            exit ( STACK_FRAME_SIZE_EXCEEDED );
            }
        }
    if (fForcedI2 && fForcedS)
        {
        // ERROR - Can't force it both ways.
        SemError( this, *pContext, CONFLICTING_OPTIMIZATION_REQUIREMENTS, 0 );
        exit ( CONFLICTING_OPTIMIZATION_REQUIREMENTS );
        }


#ifdef trace_cg
    printf("done with param list for %s\n",GetSymName());
    printf("binding is now %08x\n",pBindingParam );
#endif

    // get the binding information
    if ( pBindingParam )
        {
        pBinding    = pBindingParam;

        while (! ((CG_NDR *) pBinding)->IsAHandle() )
            pBinding = pBinding->GetChild();
        // pBinding now points to the node for the binding handle
        }
    else    // implicit handle or auto handle
        {
        // note: if no implicit handle,
        //      then leave pBinding NULL for auto_handle
        if (pIntfCtxt->FInSummary( ATTR_IMPLICIT ) )
            {
            node_implicit   *   pImplAttr;
            pImplAttr = (node_implicit *) pIntf->GetAttribute( ATTR_IMPLICIT );

            pBinding = pImplAttr->ILxlate( &MyContext );
            }
        }

#ifdef trace_cg
    printf("done with binding for %s",GetSymName());
    printf("binding is now %08x\n",pBinding );
#endif

    // see if thunked interpreter needed for server side
    if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {   // check for non-stdcall
        ATTR_T      CallingConv;

        GetCallingConvention( CallingConv );

        if ( ( CallingConv != ATTR_STDCALL ) &&
             ( CallingConv != ATTR_NONE ) )
            {
            SetOptimizationFlags( unsigned short( GetOptimizationFlags() | OPTIMIZE_THUNKED_INTERPRET ) );
            }
        else if ( pCallAs )
            {
            SetOptimizationFlags( unsigned short( GetOptimizationFlags() | OPTIMIZE_THUNKED_INTERPRET ) );
            }
        else if ( pReturnCG )   // check the return type
            {
            CG_NDR  *   pRetTypeCG  = (CG_NDR *) pReturnCG->GetChild();

            if ( !pCommand->NeedsNDR64Run() 
                 && pRetTypeCG->GetCGID() != ID_CG_CONTEXT_HDL )
                {
                // This check is bogus.  First off, it should be checking the
                // memory size, not the wire size.  Secondly, for straight dce
                // mode large (i.e. complex) return types are prohibited in
                // semantic analysis.  Finally, it should be checking the size
                // against the pointer size, not 4.

                if ( ( pRetTypeCG->GetWireSize() > 4 ) ||
                     ( !pRetTypeCG->IsSimpleType() && 
                       !pRetTypeCG->IsPointer() ) )
                    SetOptimizationFlags( unsigned short( GetOptimizationFlags() | OPTIMIZE_THUNKED_INTERPRET ) );
                }
            }

        }

    if ( fHasCallback )
        {
        pCG     = new CG_CALLBACK_PROC(
                                       ProcNum,
                                       this,
                                       (CG_HANDLE *) pBinding,
                                       (CG_PARAM *) pBindingParam,
                                       HasAtLeastOneIn(),
                                       HasAtLeastOneOut(),
                                       HasAtLeastOneShipped(),
                                       fHasStatuses,
                                       fHasFullPointer,
                                       pReturnCG,
                                       GetOptimizationFlags(),
                                       OpBits,
                                       fHasDeny
                                     );
        }
    else if ( fObject )
        {
        BOOL                fInherited = 0;
        if ( GetDefiningFile() )
            {
            fInherited = GetDefiningFile()->GetImportLevel() > 0;
            }
        if ( fInherited )
            {
            pCG     = new CG_INHERITED_OBJECT_PROC(
                                   ProcNum,
                                   this,
                                   (CG_HANDLE *) pBinding,
                                   (CG_PARAM *) pBindingParam,
                                   HasAtLeastOneIn(),
                                   HasAtLeastOneOut(),
                                   HasAtLeastOneShipped(),
                                   fHasStatuses,
                                   fHasFullPointer,
                                   pReturnCG,
                                   GetOptimizationFlags(),
                                   OpBits,
                                   fHasDeny
                                 );
            }
        else
            {
            pCG     = new CG_OBJECT_PROC(
                                   ProcNum,
                                   this,
                                   (CG_HANDLE *) pBinding,
                                   (CG_PARAM *) pBindingParam,
                                   HasAtLeastOneIn(),
                                   HasAtLeastOneOut(),
                                   HasAtLeastOneShipped(),
                                   fHasStatuses,
                                   fHasFullPointer,
                                   pReturnCG,
                                   GetOptimizationFlags(),
                                   OpBits,
                                   fHasDeny
                                 );
            }
        }
    else if ( HasEncode || HasDecode )
        {
        pCG     = new CG_ENCODE_PROC(
                               ProcNum,
                               this,
                               (CG_HANDLE *) pBinding,
                               (CG_PARAM *) pBindingParam,
                               HasAtLeastOneIn(),
                               HasAtLeastOneOut(),
                               HasAtLeastOneShipped(),
                               fHasStatuses,
                               fHasFullPointer,
                               pReturnCG,
                               GetOptimizationFlags(),
                               OpBits,
                               HasEncode,
                               HasDecode,
                               fHasDeny
                             );
        }
    else
        {
        pCG     = new CG_PROC(
                               ProcNum,
                               this,
                               (CG_HANDLE *) pBinding,
                               (CG_PARAM *) pBindingParam,
                               HasAtLeastOneIn(),
                               HasAtLeastOneOut(),
                               HasAtLeastOneShipped(),
                               fHasStatuses,
                               fHasFullPointer,
                               pReturnCG,
                               GetOptimizationFlags(),
                               OpBits,
                               fHasDeny
                             );
        }

    pCG->SetChild( pFirstChildCG );

#ifdef trace_cg
    printf("....returning from %s\n",GetSymName());
#endif
    
    pIntf->GetProcCount() = SavedProcCount;
    pIntf->GetCallBackProcCount() = SavedCallbackProcCount;

done:
    // save a pointer to the interface CG node
    pCG->SetInterfaceNode( (CG_INTERFACE*) pIntf->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) );

    if (fSupressHeader)
        pCG->SetSupressHeader();

    // mark nocode procs
    if ( fNoCode )
        pCG->SetNoCode();

    if ( pNotify )
        pCG->SetHasNotify();

    if ( pNotifyFlag )
        pCG->SetHasNotifyFlag();

    if ( fEnableAllocate )
        pCG->SetRpcSSSpecified( 1 );

    if ( fRetHresult )
        pCG->SetReturnsHRESULT();

    if (HasPipes())
        pCG->SetHasPipes(1);

    if ( pCallAs )
        pCG->SetCallAsName( pCallAs->GetCallAsName() );

    if ( HasExtraStatusParam() )
        pCG->SetHasExtraStatusParam();

    if ( HasAsyncHandle() )
        pCG->SetHasAsyncHandle();

    if ( HasAsyncUUID() )
        pCG->SetHasAsyncUUID();

    if ( HasServerCorr() )
        pCG->SetHasServerCorr();

    if ( HasClientCorr() )
        pCG->SetHasClientCorr();

    // A fake parameter was added to the type for complex return values.
    // Remove it.

    if ( pComplexReturn )
        {
        pCG->SetHasComplexReturnType();
        MemIter.RemoveLastMember();
        }

    pCG->SetCSTagRoutine( GetCSTagRoutine() );

    // Typelib generation does not remove ATTR_V1_ENUM.
    MyContext.ExtractAttribute( ATTR_V1_ENUM );
    
    // at this point, there should be no more attributes...
    MIDL_ASSERT( !MyContext.HasAttributes() );

    if (  ( pCG->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) && 
            !( pCG->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) &&
                pCommand->Is64BitEnv() )
        {
        SemError( this, *pContext, NO_OLD_INTERPRETER_64B, GetSymName() );
        exit ( NO_OLD_INTERPRETER_64B );
        }

    return pCG;
}

//--------------------------------------------------------------------
//
// node_param::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_param::ILxlate( XLAT_CTXT * pContext )
{
    CG_PARAM    *   pCG;
    CG_CLASS    *   pChildCG    = NULL;
    expr_node   *   pSwitchExpr = NULL;

#ifdef trace_cg
    printf("..node_param,\t%s\n",GetSymName());
#endif

    PARAM_DIR_FLAGS F = 0;
    XLAT_CTXT   MyContext( this, pContext );

    // make sure all member attributes get processed
    node_member_attr * pMA;

    MyContext.ExtractAttribute(ATTR_IDLDESCATTR);
    MyContext.ExtractAttribute(ATTR_DEFAULTVALUE);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

    if ( MyContext.ExtractAttribute(ATTR_FLCID) )
        {
        LCID();
        }

    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_RETVAL:
                Retval();
                break;
            case MATTR_OPTIONAL:
            {
                Optional();
            }
                break;
            default:
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
            }
        }
  
    if( MyContext.ExtractAttribute( ATTR_IN ) )
        {
        F   |= IN_PARAM;
        }

    if( MyContext.ExtractAttribute( ATTR_OUT ) )
        {
        F   |= OUT_PARAM;
        }

    if ( MyContext.ExtractAttribute( ATTR_PARTIAL_IGNORE ) )
        {
        F   |= PARTIAL_IGNORE_PARAM; 
        }

    // default to in
    if ( F == 0 && !IsExtraStatusParam() )
        F   |= IN_PARAM;

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        {
        node_switch_is  *   pAttr;
         
        if ( pCommand->IsNDR64Run() )
            {
            pAttr = (node_switch_is *) MyContext.GetAttribute( ATTR_SWITCH_IS );
            }
        else 
            {
            pAttr = (node_switch_is *) MyContext.ExtractAttribute( ATTR_SWITCH_IS );
            }
        pSwitchExpr = pAttr->GetExpr();
        }

    BOOL fHasCSSTag = ( NULL != MyContext.ExtractAttribute( ATTR_STAG ) );
    BOOL fHasCSDRTag = ( NULL != MyContext.ExtractAttribute( ATTR_DRTAG ) );
    BOOL fHasCSRTag = ( NULL != MyContext.ExtractAttribute( ATTR_RTAG ) );

    MyContext.SetAncestorBits(
                      ( fHasCSSTag  ? IL_CS_STAG  : 0 )
                    | ( fHasCSDRTag ? IL_CS_DRTAG : 0 )
                    | ( fHasCSRTag  ? IL_CS_RTAG  : 0 ) );

    BOOL HasForceAllocate = ( NULL != MyContext.ExtractAttribute( ATTR_FORCEALLOCATE ) );
    
	pChildCG = GetChild()->ILxlate( &MyContext );

    pContext->ReturnSize( MyContext );

#ifdef trace_cg
    printf("..node_param back.. %s\n",GetSymName());
#endif
    // make sure void parameters get skipped
    if ( !pChildCG )
        return NULL;

    pCG = new CG_PARAM( this,
                        F,
                        MyContext,
                        pSwitchExpr,
                        (unsigned short) Statuses );

#ifdef trace_cg
    printf("..node_param ..... %08x child=%08x\n", pCG, pChildCG );
    fflush(stdout);
#endif

    if ( IsExtraStatusParam() )
        pCG->SetIsExtraStatusParam();

    // only set the bit if there was non-toplevel only
    if ( fDontCallFreeInst == 1 )
        pCG->SetDontCallFreeInst( TRUE );


#ifdef trace_cg
    printf("..node_param ........ %08x child=%08x\n", pCG, pChildCG );
    fflush(stdout);
#endif
    pCG->SetChild( pChildCG );

    if (IsAsyncHandleParam())
        {
        pCG->SetIsAsyncHandleParam();
        }
    if ( IsSaveForAsyncFinish() )
        {
        pCG->SaveForAsyncFinish();
        }

    pCG->SetIsCSSTag( fHasCSSTag );
    pCG->SetIsCSDRTag( fHasCSDRTag );
    pCG->SetIsCSRTag( fHasCSRTag );

    if ( MyContext.AnyAncestorBits( IL_CS_HAS_TAG_RTN ) && pCG->IsSomeCSTag() )
        pCG->SetIsOmittedParam();

#ifdef trace_cg
    printf("..node_param return %s\n",GetSymName());
    fflush(stdout);
#endif
    if ( HasForceAllocate )
        {
    	pCG->SetForceAllocate( );
    	}


    if ( !MyContext.AnyAncestorBits(IL_IN_LIBRARY) )
        {
        SetCG( pCG );
        }

    // REVIEW: There is no concept of switch_type in a library block.
    //         Perhaps issue an error in semantic analysis.

    if ( MyContext.AnyAncestorBits( IL_IN_LIBRARY )
         && MyContext.ExtractAttribute( ATTR_SWITCH_TYPE ) )
        {
        SemError(
                this, 
                MyContext, 
                IGNORE_UNIMPLEMENTED_ATTRIBUTE, 
                "[switch_type] in a library block");
        }

    return pCG;
}

const GUID_STRS DummyGuidStrs( "00000000", "0000", "0000", "0000", "000000000000" );

// helper function for adding a new list to the end of the list of children
inline
void    AddToCGList(
    const CG_CLASS * pCNew,
    CG_CLASS * * ppChild,
    CG_CLASS * * ppLastSibling )
{
    CG_CLASS * pCurrent;
    CG_CLASS * pNew         = (CG_CLASS *) pCNew;

    // hook the head on
    if ( !*ppChild )
        *ppChild = pNew;
    else
        (*ppLastSibling)->SetSibling( pNew );

    // advance the last sibling pointer
    *ppLastSibling = pNew;
    while ( ( pCurrent = (*ppLastSibling)->GetSibling() ) != 0 )
        *ppLastSibling = pCurrent;

}

//--------------------------------------------------------------------
//
// node_interface::ILxlate
//
// Notes: This function returns either a CG_INTERFACE or a
//        CG_OBJECT_INTERFACE node.
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_interface::ILxlate( XLAT_CTXT * pContext )
{
    CG_NDR          *   pcgInterface    = NULL;
    CG_NDR          *   pResultCG       = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           ChildContext( MyContext );
    node_guid       *   pGuid       = (node_guid *)
                                            MyContext.ExtractAttribute( ATTR_GUID );
    GUID_STRS           GuidStrs;
    node_implicit   *   pImpHdl     = NULL;
    CG_HANDLE       *   pImpHdlCG   = NULL;
    NODE_T              ChildKind;
    BOOL                IsPickle    = MyContext.FInSummary( ATTR_ENCODE ) ||
                                      MyContext.FInSummary( ATTR_DECODE );
    BOOL                fAllRpcSS   = MyContext.FInSummary( ATTR_ENABLE_ALLOCATE ) ||
                                        pCommand->IsRpcSSAllocateEnabled();
    BOOL                fObject     = MyContext.FInSummary( ATTR_OBJECT );

    node_interface  *   pBaseIntf       = GetMyBaseInterface();
    CG_OBJECT_INTERFACE     *   pBaseCG = NULL;
    CG_OBJECT_INTERFACE     *   pCurrentCG  = NULL;
    CG_OBJECT_INTERFACE     *   pLastItfCG = 0;
    BOOL                        fInheritedIntf = NULL;

    MyContext.ExtractAttribute( ATTR_TYPEDESCATTR );
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_ASYNC );
    MyContext.ExtractAttribute( ATTR_CSTAGRTN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

#ifdef trace_cg
    printf("..node_interface,\t%s\n", GetSymName());
#endif

    if( FInSummary( ATTR_IMPLICIT ) )
        {
        pImpHdl = (node_implicit *) GetAttribute( ATTR_IMPLICIT );
        if (pImpHdl)
            pImpHdlCG = (CG_HANDLE *) pImpHdl->ILxlate( &MyContext );
        }

    if (pGuid)
        GuidStrs = pGuid->GetStrs();
    else
        GuidStrs = DummyGuidStrs;

    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );

    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL;
        
    // start the procnum counting over
    GetProcCount() = 0;
    GetCallBackProcCount() = 0;

    // Generate the interface's CG node first
    if( fObject || MyContext.AnyAncestorBits(IL_IN_LIBRARY))
        {
        // object interfaces need to have their base classes generated, too
        if ( pBaseIntf )
            {
            pBaseCG = (CG_OBJECT_INTERFACE *) pBaseIntf->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) );
            if ( !pBaseCG )
                {
                XLAT_CTXT       BaseCtxt( &ChildContext );

                BaseCtxt.SetInterfaceContext( &BaseCtxt );
                pCurrentCG  = (CG_OBJECT_INTERFACE *)
                                pBaseIntf->ILxlate( &BaseCtxt );
                AddToCGList( pCurrentCG, (CG_CLASS**) &pResultCG, (CG_CLASS**) &pLastItfCG );

                // our base interface made the last one on the list
                pBaseCG = pLastItfCG;
                }

            // start the procnum from our base interface
            GetProcCount()          = pBaseIntf->GetProcCount();
            GetCallBackProcCount()  = pBaseIntf->GetCallBackProcCount();

            }

        if ( GetFileNode() )
            {
            fInheritedIntf = GetFileNode()->GetImportLevel() > 0;
            }

        if ( IsValidRootInterface() )
            {
            pcgInterface = new CG_IUNKNOWN_OBJECT_INTERFACE(this,
                                            GuidStrs,
                                            FALSE,
                                            FALSE,
                                            pBaseCG,
                                            fInheritedIntf);
            }
        else if ( fInheritedIntf )
            {
            pcgInterface = new CG_INHERITED_OBJECT_INTERFACE(this,
                                            GuidStrs,
                                            FALSE,
                                            FALSE,
                                            pBaseCG);
            }
        else
            {
            pcgInterface = new CG_OBJECT_INTERFACE(this,
                                            GuidStrs,
                                            FALSE,
                                            FALSE,
                                            pBaseCG);
            }
        }
    else
        {
        pcgInterface = new CG_INTERFACE(this,
                                        GuidStrs,
                                        FALSE,
                                        FALSE,
                                        pImpHdlCG,
                                        pBaseCG);
        }

    if ( fHasMSConfStructAttr )
        {
        ( (CG_INTERFACE*) pcgInterface)->SetHasMSConfStructAttr();
        }

    // store a pointer to our CG node
    SetCG(  MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgInterface );

    // if we generated a bunch of new inherited interfaces, link us to the end
    // of the list, and return the list
    AddToCGList( pcgInterface, (CG_CLASS**) &pResultCG, (CG_CLASS**) &pLastItfCG );

    BOOL fImported = FALSE;
    if ( GetDefiningFile() )
        {
        fImported = GetDefiningFile()->GetImportLevel() != 0;
        }

    // if they specified LOCAL, don't generate any CG nodes (except for object)
    if ( MyContext.FInSummary(ATTR_LOCAL) && !fObject )
        {
        return pResultCG;
        }

    //
    // for each of the procedures.
    //

    CG_PROC * pBeginProc = NULL;

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        ChildKind = pN->NodeKind();

        // proc nodes may hang under node_id's
        if( ( ChildKind == NODE_PROC )  ||
            (   ( ChildKind == NODE_ID )
             && ( pN->GetChild()->NodeKind() == NODE_PROC ) ) ||
            (   ( ChildKind == NODE_DEF )
             && ( IsPickle ||
                  pN->FInSummary( ATTR_ENCODE ) ||
                  pN->FInSummary( ATTR_DECODE ) ) ) )
            {
            // skip call_as targets
            if (ChildKind == NODE_PROC && ((node_proc *)pN)->IsCallAsTarget())
                continue;

            // translate target of call_as proc
            CG_PROC * pTarget = NULL;
            if (ChildKind == NODE_PROC)
            {
                node_proc * p = ((node_proc *)pN)->GetCallAsType();
                if (p)
                {
                    pTarget = (CG_PROC *) p->ILxlate( &ChildContext);
                }
            }

            // translate CG_NODE
            pChildCG    = pN->ILxlate( &ChildContext );

            // attach target of call_as proc
            if ( pChildCG )
                {
                if (pTarget)
                    ((CG_PROC *)pChildCG)->SetCallAsCG(pTarget);
                    
                AddToCGList( pChildCG, &pCG, &pPrevChildCG );
                }
            
            // Connect Begin and Finish async DCOM procs together.
            // CloneIFAndSplitMethods always places the procedures
            // immediatly under the interface with the Finish proc
            // immediatly following the begin proc.  This code
            // will need to be changed if CloneIFAndSplitMethods
            // changes.
            if ( NODE_PROC == ChildKind ) 
                {

                node_proc *pProc = ( node_proc * ) pN;

                if ( pProc->IsBeginProc() )
                    {

                    MIDL_ASSERT( ( ( CG_NDR * ) pChildCG )->IsProc() );
                    pBeginProc = ( CG_PROC * )pChildCG;
#ifndef NDEBUG                    
                    // assert that the next proc is the finish proc
                    MEM_ITER NewMemIter = MemIter;
                    named_node *pNextNode = NewMemIter.GetNext();
                    MIDL_ASSERT( pNextNode );
                    MIDL_ASSERT( NODE_PROC == pNextNode->NodeKind() );
                    MIDL_ASSERT( ( (node_proc *)pNextNode )->IsFinishProc() );
#endif // NDEBUG
                    }

                else if ( pProc->IsFinishProc() )
                    {
                    
                    MIDL_ASSERT( ( ( CG_NDR * ) pChildCG )->IsProc() );
                    CG_PROC *pFinishProc = ( CG_PROC * )pChildCG;
                                        
                    // Link the begin and finsh procs together
                    pBeginProc->SetIsBeginProc();
                    pBeginProc->SetAsyncRelative( pFinishProc );
                    pFinishProc->SetIsFinishProc();
                    pFinishProc->SetAsyncRelative( pBeginProc );

                    pBeginProc = NULL;
                    }

                }
            
            }

        }

    // make sure we don't have too many procs
    if ( fObject && fInheritedIntf )
        {
        if ( ( GetProcCount() > 256 ) )
            {
            // complain about too many delegated routines
            SemError(this, MyContext, TOO_MANY_DELEGATED_PROCS, NULL);
            }
        else if ( GetProcCount() > 64 )
            {
            pCommand->GetNdrVersionControl().SetHasMoreThan64DelegatedProcs();
            }
        }

        // mark ourselves if we are an all RPC SS interface
    // or if enable is used anywhere within.

    if ( fAllRpcSS )
        {
        ((CG_INTERFACE *)pcgInterface)->SetAllRpcSS( TRUE );
        }
    if ( fAllRpcSS  ||  GetHasProcsWithRpcSs() )
        {
        ((CG_INTERFACE *)pcgInterface)->SetUsesRpcSS( TRUE );
        }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgInterface->SetChild(pCG);

    return pResultCG;
}

//--------------------------------------------------------------------
//
// node_interface_reference::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_interface_reference::ILxlate( XLAT_CTXT * pContext )
{
    XLAT_CTXT       MyContext( this, pContext );
    CG_CLASS    *   pCG       = NULL;

#ifdef trace_cg
    printf("..node_interface_reference,\t%s\n", GetSymName());
#endif

    pCG = new CG_INTERFACE_POINTER( this,
                                    (node_interface *) GetChild() );

    pContext->ReturnSize( MyContext );

    return pCG;
};

//--------------------------------------------------------------------
//
// node_source::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_source::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER        MemIter( this );
    CG_CLASS    *   pCG;
    CG_CLASS    *   pNew;
    CG_CLASS    *   pChildCG        = NULL;
    CG_CLASS    *   pPrevChildCG    = NULL;
    node_skl    *   pN;
    XLAT_CTXT       MyContext( this, pContext );


#ifdef trace_cg
    printf("..node_source,\t%s\n", GetSymName());
#endif

    pCG =  (CG_CLASS *) new CG_SOURCE( this );

    //
    // for each of the children.
    //

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pChildCG    = pN->ILxlate( &MyContext );

        if ( pChildCG )
            {
            if (pPrevChildCG)
                {
                pPrevChildCG->SetSibling( pChildCG );
                }
            else
                {
                pCG->SetChild(pChildCG);
                };

            pPrevChildCG    = pChildCG;
            while ( ( pNew = pPrevChildCG->GetSibling() ) != 0 )
                pPrevChildCG = pNew;
            }
        }

    pContext->ReturnSize( MyContext );

    return pCG;
};


//--------------------------------------------------------------------
//
// node_echo_string::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_echo_string::ILxlate( XLAT_CTXT* )
{

#ifdef trace_cg
    printf("..node_echo_string,\t%s\n", GetSymName());
#endif

return 0;
};


//--------------------------------------------------------------------
//
// node_error::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_error::ILxlate( XLAT_CTXT* )
{

#ifdef trace_cg
    printf("..node_error,\t%s\n", GetSymName());
#endif

return 0;
};


CG_CLASS *
Transform(
    IN              node_skl    *   pIL )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine performs the translation from the type graph into the
    code generation classes.

 Arguments:

    pIL     - a pointer to the il tranformer controlling structure.

 Return Value:

    A pointer to the new code generator class.

 Notes:

    This method should be called only on placeholder nodes like struct / proc
    interface, file etc.

----------------------------------------------------------------------------*/

{
    XLAT_CTXT   MyContext;

#ifdef trace_cg
    printf("transforming...\n");
#endif

    pReUseDict  = new REUSE_DICT;
    
    return pIL->ILxlate( &MyContext );
};


//--------------------------------------------------------------------
//
// node_library::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_library::ILxlate( XLAT_CTXT * pContext )
{
    MEM_ITER MemIter(this);
#ifdef trace_cg
    printf("..node_library,\t%s\n", GetSymName());
#endif
    XLAT_CTXT MyContext( this, pContext);

    if ( pCommand->IsNDR64Run() )
        {
        if ( !pCommand->NeedsNDRRun() )
            {
            
            SemError( this, MyContext , NDR64_ONLY_TLB, GetSymName() );        
            }
        return NULL;
        }

    MyContext.SetAncestorBits(IL_IN_LIBRARY);
    XLAT_CTXT  ChildContext( MyContext );

    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );

    CG_LIBRARY * pLib = new CG_LIBRARY(this, MyContext);

    named_node * pN;

    CG_CLASS * pLast    = NULL;
    CG_CLASS * pChild   = 0;

    while ( ( pN = MemIter.GetNext() ) != 0 )
    {
        switch(pN->NodeKind())
        {
        case NODE_FORWARD:
            {
                node_interface_reference * pIRef = (node_interface_reference *)pN->GetChild();
                if (pIRef)
                    {
                    if (pIRef->NodeKind() == NODE_INTERFACE_REFERENCE)
                        {
                            // create a CG_INTEFACE_REFERENCE node that points to this node
                            pChild = new CG_INTERFACE_REFERENCE(pIRef, ChildContext);
                            // make sure that the interface gets ILxlated.
                            CG_CLASS * pRef = pIRef->GetRealInterface()->ILxlate(&ChildContext);
                            pChild->SetSibling(pRef);
                        }
                    else 
                        {
                        if (pIRef->NodeKind() == NODE_COCLASS)
                            {
                                // don't process this type early
                                pChild = NULL;
                            }
                        else
                            {
                                pChild = pN->ILxlate(&ChildContext);
                                if (pChild && pChild->GetSibling())
                                    pChild = NULL;
                            }
                        }
                    }
                else
                    {
                    pChild = 0;
                    }
            }
            break;
        case NODE_INTERFACE:
            {
                pChild = pN->ILxlate(&ChildContext);
                // skip over inherited interfaces
                while (pChild && pChild->GetCGID() == ID_CG_INHERITED_OBJECT_INTERFACE)
                    pChild=pChild->GetSibling();
            }
            break;
        default:
            // create the appropriate CG node
            pChild = pN->ILxlate(&ChildContext);
            if (pChild && pChild->GetSibling())   // We must have already entered this one.
                pChild = NULL; 
            break;
        }
        // attach the CG_NODE to the end of my child list
        if (NULL != pChild && pChild != pLast)
        {
            if (pLast)
            {
                pLast->SetSibling(pChild);
            }
            else
            {
                pLib->SetChild(pChild);
            }
            pLast = pChild;
            // advance past the end of the list
            while (pLast->GetSibling())
                pLast = pLast->GetSibling();
        }
    }

    SetCG(FALSE, pLib);
    SetCG(TRUE, pLib);

    return pLib;
}

//--------------------------------------------------------------------
//
// node_module::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_module::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_module,\t%s\n", GetSymName());
#endif

    CG_NDR          *   pcgModule    = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           ChildContext( MyContext );
    
    MyContext.ExtractAttribute( ATTR_GUID );
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    while (MyContext.ExtractAttribute(ATTR_TYPE));
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );

    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL;

    // generate our CG node

    pcgModule = new CG_MODULE(this, MyContext);

    // store a pointer to our CG node
    SetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgModule );

    //
    // for each of the members.
    //

    while ( ( pN = MemIter.GetNext() ) != 0 )
    {
        pChildCG    = pN->ILxlate( &ChildContext );

        if ( pChildCG )
        {
            if (NODE_PROC == pN->NodeKind())
            {
                ((CG_PROC *)pChildCG)->SetProckind(PROC_STATIC);
            }
            AddToCGList( pChildCG, &pCG, &pPrevChildCG );
        }
    }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgModule->SetChild(pCG);

    return pcgModule;
}

//--------------------------------------------------------------------
//
// node_coclass::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_coclass::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_coclass,\t%s\n", GetSymName());
#endif
    CG_NDR          *   pcgCoclass    = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           ChildContext(MyContext);
    MyContext.ExtractAttribute( ATTR_GUID );
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    while (MyContext.ExtractAttribute(ATTR_TYPE));
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));
    
    // don't pass the interface attributes down...
    // save them off elsewhere

    ChildContext.SetInterfaceContext( &MyContext );
    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL ;

    // generate our CG node

    pcgCoclass = new CG_COCLASS(this, MyContext);

    // store a pointer to our CG node
    SetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgCoclass );

    //
    // for every member of the coclass
    //

    node_skl * pChild = 0;
    while ( ( pN = MemIter.GetNext()) != 0 )
        {
        pChild = pN;
        while(NODE_FORWARD == pChild->NodeKind() || NODE_HREF == pChild->NodeKind())
            {
            pChild = pChild->GetChild();
            if ( !pChild )
                {
                XLAT_CTXT ChildErrContext( pN, &MyContext ); 
                SemError( pN, ChildErrContext, UNSATISFIED_FORWARD, pN->GetSymName() );
                exit( UNSATISFIED_FORWARD );
                }
            }
        pChildCG    = pChild->ILxlate( &ChildContext );
        if (pChild->IsInterfaceOrObject())
        {
//            pChildCG = ((node_interface * )pChild)->GetCG(TRUE);
            pChildCG = new CG_INTERFACE_POINTER(this, (node_interface *)pChild );
        }
/*
        if ( pChildCG && NODE_DISPINTERFACE == pChild->NodeKind())
        {
            pChildCG = new CG_INTERFACE_POINTER(this, pChild, NULL);
            //((node_dispinterface *) pChild)->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) );
        }
*/
        if ( pChildCG )
            AddToCGList( pChildCG, &pCG, &pPrevChildCG );
        }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgCoclass->SetChild(pCG);

    return pcgCoclass;
}

//--------------------------------------------------------------------
//
// node_dispinterface::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_dispinterface::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_dispinterface,\t%s\n", GetSymName());
#endif

    CG_NDR          *   pcgInterface    = NULL;
    CG_CLASS        *   pCG             = NULL;
    CG_CLASS        *   pChildCG        = NULL;
    CG_CLASS        *   pPrevChildCG    = NULL;
    CG_CLASS        *   pcgDispatch     = NULL;
    MEM_ITER            MemIter( this );
    node_skl        *   pN;
    XLAT_CTXT           MyContext( this, pContext );
    XLAT_CTXT           BaseContext( MyContext );  // context passed to IDispatch
    XLAT_CTXT           ChildContext( MyContext );
    node_guid       *   pGuid       = (node_guid *)
                                            MyContext.ExtractAttribute( ATTR_GUID );
    GUID_STRS           GuidStrs;
    NODE_T              ChildKind;

    node_interface          *   pBaseIntf;
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    while (MyContext.ExtractAttribute(ATTR_TYPE));
    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    if (pGuid)
        GuidStrs = pGuid->GetStrs();

    // don't pass the interface attributes down...
    // save them off elsewhere

    BaseContext.SetInterfaceContext( &MyContext );
    ChildContext.SetInterfaceContext( &MyContext );

    // if we already got spit out, don't do it again...
    if ( GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) ) )
        return NULL;

    //
    // ILxlate IDispatch
    //
    pcgDispatch = GetIDispatch()->ILxlate(&BaseContext);
    pcgDispatch = ((node_interface *)GetIDispatch())->GetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY) );

    // generate our CG node

    pcgInterface = new CG_DISPINTERFACE(this, GuidStrs,(CG_OBJECT_INTERFACE *)pcgDispatch);

    // store a pointer to our CG node
    SetCG( MyContext.AnyAncestorBits(IL_IN_LIBRARY), pcgInterface );

    // Either we have a single base interface, or we have no base interface.

    pN = MemIter.GetNext();
    if (pN)
    {
        ChildKind = pN->NodeKind();
        if (ChildKind == NODE_FORWARD)
        {
            // We have a base interface
            pBaseIntf = (node_interface *)GetMyBaseInterfaceReference();
            // process the base interface
            if (pBaseIntf)
            {
                pChildCG = pBaseIntf->ILxlate(&ChildContext);
                if ( pChildCG )
                    AddToCGList( pChildCG, &pCG, &pPrevChildCG );
            }
        }
    }

    //
    // for each of the procedures.
    //

    while( pN )
        {
        ChildKind = pN->NodeKind();

        // proc nodes may hang under node_id's
        if( (ChildKind == NODE_FIELD) ||
            ( ChildKind == NODE_PROC )  ||
            ( ( ChildKind == NODE_ID ) && ( pN->GetChild()->NodeKind() == NODE_PROC ) ) )
            {
            pChildCG    = pN->ILxlate( &ChildContext );

            if ( pChildCG )
                AddToCGList( pChildCG, &pCG, &pPrevChildCG );
            }

        pN = MemIter.GetNext();
        }

    // consume all the interface attributes
    MyContext.ClearAttributes();
    pContext->ReturnSize( MyContext );

    pcgInterface->SetChild(pCG);

    return pcgInterface;
}

//--------------------------------------------------------------------
//
// node_pipe::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_pipe::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_pipe,\t%s\n", GetSymName());
#endif

    CG_CLASS     *  pChildCG;
    XLAT_CTXT       MyContext( this, pContext );
    CG_PIPE      *  pCG = new CG_PIPE   (
                                        this,
                                        MyContext
                                        );
    // if /deny is not specified, ignore [range]
    // if [range] is not ignored, new format string is
    // generated for pipes.
    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        pCG->SetRangeAttribute( ( node_range_attr* ) MyContext.ExtractAttribute( ATTR_RANGE ) );
        }
    pChildCG = GetChild()->ILxlate( &MyContext );

    pContext->ReturnSize( MyContext );
    pCG->SetChild( pChildCG );

    return pCG;
};

//--------------------------------------------------------------------
//
// node_safearray::ILxlate
//
// Notes:
//
//
//
//--------------------------------------------------------------------

CG_CLASS *
node_safearray::ILxlate( XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_safearray,\t%s\n", GetSymName());
#endif

    CG_CLASS     *  pChildCG;
    XLAT_CTXT       MyContext( this, pContext );
    CG_SAFEARRAY *  pCG = new CG_SAFEARRAY(this, MyContext);

    // SAFEARRAY, being defined in the public IDL files, has a known
    // alignment of 4. Now the struct etc. that embeds the SAFEARRAY
    // may have a different alignment but the struct code will make it
    // right by choosing min(ZeePee, max(children)).
    // The child of the node is a type specifier from SAFEARRAY(type).
    // The type alias is the LPSAFEARRAY

    pCG->SetMemoryAlignment( 4 );

    MyContext.GetMemAlign() = 4;
    pContext->ReturnSize( MyContext );

    pChildCG = GetChild()->ILxlate( &MyContext );

    pCG->SetChild( pChildCG );

    // If the SAFEARRAY was not used in a proxy, just pass up the SAFEARRAY class.  
    if ( ! fInProxy )
        return pCG;

    // If the SAFEARRAY was used in a proxy, pass up the the annoted node for
    // LPSAFEARRAY.

    CG_NDR *pTypeAliasCG = (CG_NDR*) ( GetTypeAlias()->ILxlate( pContext ) );

    MIDL_ASSERT( pTypeAliasCG->GetCGID() == ID_CG_USER_MARSHAL );

    CG_USER_MARSHAL *pUserMarshalCG = (CG_USER_MARSHAL *)pTypeAliasCG;

    pUserMarshalCG->SetTypeDescGenerator( pCG );
    
    return pUserMarshalCG;
}


CG_CLASS*
node_async_handle::ILxlate(  XLAT_CTXT * pContext )
{
#ifdef trace_cg
    printf("..node_async_handle,\t%s\n", GetSymName());
#endif
    XLAT_CTXT           MyContext( this, pContext );
    CG_ASYNC_HANDLE*    pAsyncHdl = new CG_ASYNC_HANDLE( this, MyContext );

    return pAsyncHdl;
}

CG_CLASS*
node_midl_pragma::ILxlate( XLAT_CTXT* )
{
    return 0;
}

CG_CLASS*
node_decl_guid::ILxlate( XLAT_CTXT* )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\misccls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    misccls.hxx

 Abstract:

    Code generation methods for miscellaneous cg classes.

 Notes:


 History:

    Sep-01-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "malloc.h"


/****************************************************************************
 *  local definitions
 ***************************************************************************/

/****************************************************************************
 *  local data
 ***************************************************************************/
GUID_STRS   TransferSyntaxGuidStrs( TRANSFER_SYNTAX_GUID_STR_1,
                                    TRANSFER_SYNTAX_GUID_STR_2,
                                    TRANSFER_SYNTAX_GUID_STR_3,
                                    TRANSFER_SYNTAX_GUID_STR_4,
                                    TRANSFER_SYNTAX_GUID_STR_5);

GUID_STRS   NDR64TransferSyntaxGuidStrs( NDR64_TRANSFER_SYNTAX_GUID_STR_1,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_2,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_3,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_4,
                                         NDR64_TRANSFER_SYNTAX_GUID_STR_5);

GUID_STRS   FakeNDR64TransferSyntaxGuidStrs( 
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_1,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_2,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_3,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_4,
                 FAKE_NDR64_TRANSFER_SYNTAX_GUID_STR_5);
                                         

/****************************************************************************
 *  externs
 ***************************************************************************/
extern CMD_ARG * pCommand;

extern BOOL                     IsTempName( char * );

/****************************************************************************/

CG_INTERFACE::CG_INTERFACE(
    node_interface * pI,
    GUID_STRS       GStrs,
    BOOL            fCallbacks,
    BOOL            fMopInfo,
    CG_HANDLE   *   pIH,
    CG_INTERFACE*   pBaseIF
    ) :CG_NDR(pI, XLAT_SIZE_INFO() ),
    fTypeInfoInitialized( FALSE )

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    The constructor for the code generation file node.

 Arguments:

    pI          - A pointer to the interface node in type graph.
    GStrs       - guid strings
    fCallbacks  - Does the interface have any callbacks ?
    fMopInfo    - Does the interface have any mops ?
    pIH         - A pointer to the CG nodes for any implicit handle
    
 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
{
    pCGBase = pBaseIF;
    _pCTI = NULL;
    char        *       pName   = GetType()->GetSymName();

    GuidStrs            = GStrs;
    GuidStrs.SetValue();
    fMopsPresent        = fMopInfo;
    fCallbacksPresent   = fCallbacks;
    pImpHdlCG           = (CG_HANDLE *) pIH;
    CreateDispatchTables();
    fAllRpcSS           = FALSE;
    fUsesRpcSS          = FALSE;
    pIntfName           = pName;
    fHasPipes           = FALSE;
    fVisited            = FALSE;

    fLocal            = GetType()->FInSummary( ATTR_LOCAL );
    fHasMSConfStructAttr = FALSE;
    //
    // For now.
    //

    ProtSeqEPCount      = 0;

    pStubDescName = new char[ strlen(STUB_DESC_STRUCT_VAR_NAME) +
                              strlen(pName) + 1 ];

    strcpy( pStubDescName, pName );
    strcat( pStubDescName, STUB_DESC_STRUCT_VAR_NAME );

    pSyntaxInfoName = new char [strlen(MIDL_SYNTAX_INFO_VAR_NAME) +
                                strlen(pName) + 1];

    strcpy( pSyntaxInfoName, pName );
    strcat( pSyntaxInfoName, MIDL_SYNTAX_INFO_VAR_NAME );

    pProxyInfoName = new char [strlen(MIDL_PROXY_INFO_VAR_NAME) + 
                               strlen(pName) + 1];

    strcpy( pProxyInfoName, pName );
    strcat( pProxyInfoName, MIDL_PROXY_INFO_VAR_NAME );
}


CG_STATUS
CG_INTERFACE::GenClientInfo(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the file node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    unsigned short      M,m;            // for MAJOR and minor versions :-)
    CG_ITERATOR         I;
    CG_PROC         *   pCG;
    CG_HANDLE       *   pCGHandle   = GetImplicitHandle();
    node_skl        *   pID;
    char                Buffer[_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
    short               CallbackCount;
    ISTREAM         *   pStream = pCCB->GetStream();
    int                 ProtSeqEPCount = 0;
    ITERATOR        *   pProtSeqIterator;
    char            *   pCStubPrefix;

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    pCCB->SetImplicitHandleIDNode( 0 );

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    //
    // Emit the external variables needed.
    //
    if ( HasInterpretedCallbackProc() )
        Out_InterpreterServerInfoExtern( pCCB );

    if ( pCommand->NeedsNDR64Run() )
        Out_ProxyInfoExtern( pCCB );

    pStream->NewLine();

    if( pCGHandle )
        {
        pID = pCGHandle->GetHandleIDOrParam();
        pID->PrintType( PRT_ID_DECLARATION, pStream, 0 );
        }


    //
    // Emit the protseq endpoint structure if necessary. It is not
    // necessary if the endpoint attribute was not specified in which 
    // case the ep count is 0.
    //

    if ( ( pProtSeqIterator = GetProtSeqEps() ) != 0 )
        {
        ProtSeqEPCount = ITERATOR_GETCOUNT( *pProtSeqIterator );
        Out_EP_Info( pCCB, pProtSeqIterator );
        }

    //
    // Emit the interface information structure.
    //

    pCCB->GetVersion( &M,&m );

    CallbackCount = ((node_interface *)GetType())->GetCallBackProcCount();

    if( CallbackCount )
        {
        sprintf( Buffer, 
                "extern %s %s%s%s%_DispatchTable;",
                RPC_DISPATCH_TABLE_TYPE_NAME,
                pCCB->GetInterfaceName(),
                pCommand->IsNDR64Run()?"_NDR64_":"",
                pCCB->GenMangledName() );

        pStream->NewLine( 2 );
        pStream->Write( Buffer );

        /// NOTE:: This buffer is printed in the Out_IfInfo call !!!!
        sprintf( Buffer,
                 "&%s%s%s_DispatchTable",
                 pCCB->GetInterfaceName(),
                 pCommand->IsNDR64Run()?"_NDR64_":"",
                 pCCB->GenMangledName() );
        
        }
    
    //
    // Must set this before outputing the interface info.
    //
    pCCB->SetCodeGenSide( CGSIDE_CLIENT );

    Out_IFInfo( pCCB,                           // controller block.
                RPC_C_INT_INFO_TYPE_NAME,       // interface info type name.
                RPC_C_INT_INFO_STRUCT_NAME,     // variable name.
                SIZEOF_RPC_CLIENT_INTERFACE,    // string speicifying size.

                GuidStrs,                       // Guid specified in idl
                M,                              // user specified major version
                m,                              // user specified minor version
//              TransferSyntaxGuidStrs,         // ndr identifying guid.
//              NDR_UUID_MAJOR_VERSION,         // ndr's version
//              NDR_UUID_MINOR_VERSION,

                CallbackCount ? Buffer : 0,     // call back dispatch table name
                ProtSeqEPCount,                 // if this is 0, then the next
                                                // 2 fields are ignored by 
                                                // the call.
                PROTSEQ_EP_TYPE_NAME,           // RPC_PROTSEQ_ENDPOINT
                PROTSEQ_EP_VAR_NAME,            // ___RpcProtSeqEndpoint
                pCCB->IsNoDefaultEpv(),
                0,                              // client side
                HasPipes()
              );


    if ( (pCStubPrefix = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB ) ) == 0 )
        {
        pCStubPrefix = "";
        }

    pStream->NewLine();
    sprintf( Buffer,
            "RPC_IF_HANDLE %s%s%s_%s = (RPC_IF_HANDLE)& %s" RPC_C_INT_INFO_STRUCT_NAME";",
            pCStubPrefix,
            pCCB->GetInterfaceName(),
            pCCB->GenMangledName(),
            ((pCCB->IsOldNames()) ? "ClientIfHandle" : "c_ifspec"),
            pCCB->GetInterfaceName()
           );
    pStream->Write( Buffer );

    //
    // Emit the stub descriptor extern declaration.
    //
    Out_StubDescriptorExtern( pCCB );

    //
    // Check for use of [enable_allocate]
    // Use in ms_ext when explicit, in osf always, to cover some weird cases.
    //

    if ( GetUsesRpcSS() || pCCB->InOSFMode() )
        pCCB->SetMallocAndFreeStructExternEmitted();

    // Emit the auto handle extern

    pStream->NewLine();
    sprintf( Buffer,
             "static %s %s%s;",
             AUTO_BH_TYPE_NAME,
             pCCB->GetInterfaceName(),
             AUTO_BH_VAR_NAME
           );

    pStream->Write( Buffer );

    pStream->NewLine();

    //
    // Send the message to the children to emit code.
    //

    //
    // for all procedure in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCG->GenClientStub( pCCB );
        }

    return CG_OK;
}



void
CG_INTERFACE::Out_ProcOffsetTable( CCB *pCCB, BOOL IsForCallback )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a table of offsets to procedure information in the format 
    string/structure.
    
 Arguments:
    
    pCCB            - a pointer to the code generation control block.
    IsForCallback   - Is this is a table of callback offsets?

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *pStream = pCCB->GetStream();

    if ( pCommand->IsNDR64Run() )
        pStream->WriteOnNewLine( "static const FormatInfoRef " );
    else
        pStream->WriteOnNewLine( "static const unsigned short " );

    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
    
    pStream->Write( GetSymName() );
    
    if ( pCommand->IsNDR64Run() )
        pStream->Write( "_Ndr64ProcTable[] =" );
    else
        pStream->Write( "_FormatStringOffsetTable[] =" );

    pStream->IndentInc();
    pStream->WriteOnNewLine( '{' );
    pStream->NewLine();

    OutputProcOffsets( pCCB, TRUE, IsForCallback );

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine( 2 );

    // If we need a table of callbacks also, recursively call ourselves

        if ( !IsForCallback && HasInterpretedCallbackProc() )
            Out_ProcOffsetTable( pCCB, TRUE );
}



CG_STATUS
CG_INTERFACE::OutputClientStub(
    CCB *   pCCB )
{
    CG_ITERATOR I;

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // Output a table containing the offsets of each proc description for this
    // interface in the format info string/struct.  Output another table for 
    // callbacks if needed.

    Out_ProcOffsetTable( pCCB );

    //
    // Emit the stub descriptor and all that is specific to the interface,
    // Generate externs to tables that may be common to several interfaces.
    //

    Out_StubDescriptor( GetImplicitHandle(), pCCB );

    if ( pCommand->NeedsNDR64Run() )
        Out_ProxyInfo( pCCB, FALSE );

    //
    // Generate the dispatch table.
    //

    short CallbackCount = ( (node_interface *) GetType() )
                                            ->GetCallBackProcCount();
    if( CallbackCount )
        {
        ITERATOR    ProcList;

        GetCallbackProcedureList( ProcList, DTF_NONE );
        Out_DispatchTableStuff( pCCB,   
                                ProcList,
                                CallbackCount
                              );
        }

    if ( HasInterpretedCallbackProc() )
        {
        GenSyntaxInfo( pCCB, TRUE );
        Out_InterpreterServerInfo( pCCB, CGSIDE_CLIENT );
        }

    return CG_OK;
}



CG_STATUS
CG_INTERFACE::GenServerInfo(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code for the interface node.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    unsigned short      M,m;            // for MAJOR and minor versions :-)
    CG_PROC *           pCG;
    CG_ITERATOR         I;
    char                Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    ISTREAM *           pStream = pCCB->GetStream();
    ITERATOR    *       pProtSeqIterator;
    node_interface *    pInterface = (node_interface *)GetType();
    char            *   pSStubPrefix;

    InitializeCCB(pCCB);

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }


    //
    // Emit the external variables needed.
    //
    if ( HasInterpretedProc() )
        Out_InterpreterServerInfoExtern( pCCB );

    //
    // Emit the protseq endpoint structure if necessary. It is not
    // necessary if the endpoint attribute was not specified in which 
    // case the ep count is 0.
    //

    if ( ( pProtSeqIterator = GetProtSeqEps() ) != 0 )
        {
        ProtSeqEPCount = ITERATOR_GETCOUNT( *pProtSeqIterator );
        Out_EP_Info( pCCB, pProtSeqIterator );
        }

    //
    // Emit the interface information structure.
    //

    pCCB->GetVersion( &M,&m );

    //
    // Emit the extern decl for the server's dispatch table, which goes
    // in the server interface structure which follows.
    //
    sprintf( Buffer, 
             "extern %s %s%s%s_DispatchTable;",
             RPC_DISPATCH_TABLE_TYPE_NAME,
             pCCB->GetInterfaceName(),
             pCommand->IsNDR64Run()?"_NDR64_":"",
             pCCB->GenMangledName() );

    pStream->NewLine( 2 );
    pStream->Write( Buffer );

    //
    // Emit the extern decl for the server side manager epv table, which goes
    // in the server interface structure which follows.
    //

    if( pCCB->IsMEpV()  &&
       !pCCB->IsNoDefaultEpv() &&
       (pInterface->GetProcCount() != 0) )
        {
        sprintf( Buffer, 
                "extern %s%s_%s DEFAULT_EPV;",
                pCCB->GetInterfaceName(),
                pCCB->GenMangledName(), 
                pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );

        pStream->NewLine( 2 );
        pStream->Write( Buffer );
        }

    // Prepare address string for the address of the dispatch table in the
    // interface information structure.

    sprintf( Buffer,
             "&%s%s%s_DispatchTable",
             pCCB->GetInterfaceName(),
             pCommand->IsNDR64Run()?"_NDR64_":"",
             pCCB->GenMangledName()
           );

    //
    // Must set this before outputing the interface info.
    //
    pCCB->SetCodeGenSide( CGSIDE_SERVER );

    Out_IFInfo( pCCB,                           // controller block.
                RPC_S_INT_INFO_TYPE_NAME,       // interface info type name.
                RPC_S_INT_INFO_STRUCT_NAME,     // variable name.
                SIZEOF_RPC_SERVER_INTERFACE,    // string speicifying size.
                GuidStrs,                       // Guid specified in idl
                M,                              // user specified major version
                m,                              // user specified minor version
//              TransferSyntaxGuidStrs,         // ndr identifying guid.
//              NDR_UUID_MAJOR_VERSION,         // ndr's version
//              NDR_UUID_MINOR_VERSION,

                Buffer,
                ProtSeqEPCount,                 // if this is 0, then the next
                                                // 2 fields are ignored by 
                                                // the call.
                PROTSEQ_EP_TYPE_NAME,           // RPC_PROTSEQ_ENDPOINT
                PROTSEQ_EP_VAR_NAME,            // ___RpcProtSeqEndpoint
                pCCB->IsNoDefaultEpv(),
                1,
                HasPipes()
              );

    if ( (pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR ) ) == 0 )
        {
        pSStubPrefix = "";
        }

    pStream->NewLine();
    sprintf( Buffer,
            "RPC_IF_HANDLE %s%s%s_%s = (RPC_IF_HANDLE)& %s"
                            RPC_S_INT_INFO_STRUCT_NAME";",
            pSStubPrefix,
            pCCB->GetInterfaceName(),
            pCCB->GenMangledName(),
            ((pCCB->IsOldNames()) ? "ServerIfHandle" : "s_ifspec"),
            pCCB->GetInterfaceName()
           );
    pStream->Write( Buffer );

    //
    // Emit the stub descriptor extern declaration.
    //
    Out_StubDescriptorExtern( pCCB );

    //
    // Check for use of [enable_allocate]
    //

    if ( GetUsesRpcSS() && !pCCB->InOSFMode() )
        pCCB->SetMallocAndFreeStructExternEmitted();

    // has callback and Needsndr64: we need to generate proxy info for callback's
    // client stub. 
    if ( HasInterpretedCallbackProc() )
        Out_ProxyInfoExtern( pCCB );        

    //
    // Send the message to the children to emit code.
    //

    //
    // For all procedures in this interface, generate code.
    //

    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        pCG->GenServerStub( pCCB );
        }

    return CG_OK;
}



CG_STATUS
CG_INTERFACE::OutputServerStub(
    CCB *   pCCB )
{
    CG_ITERATOR I;

    if( !GetMembers( I ) )
        {
        return CG_OK;
        }

    short               NormalProcCount;
    ITERATOR            NormalProcList;

    InitializeCCB( pCCB );

    // For procs that return complex types (structures, floating point, etc)
    // we need to have a thunk that takes a pointer to where to store this
    // type.

    OutputComplexReturnThunks( pCCB );

    // Output a table containing the offsets of each proc description for this
    // interface in the format info string/struct.  Output another table for 
    // callbacks if needed.

    Out_ProcOffsetTable( pCCB );

    //
    // Emit the stub descriptor.
    //

    if ( HasInterpretedProc() ) 
        pCCB->SetOptimOption( unsigned short( pCCB->GetOptimOption() | OPTIMIZE_INTERPRETER ) );


    Out_StubDescriptor( GetImplicitHandle(), pCCB );

    //
    // Generate the dispatch table.
    //

    NormalProcCount = GetNormalProcedureList( NormalProcList,
                                              DTF_NONE  
                                            );
    if( NormalProcCount )
        Out_DispatchTableStuff( pCCB,   
                                NormalProcList,
                                NormalProcCount
                              );

    // Generate the manager epv if the -use epv switch has been specified.

    if( pCCB->IsMEpV() && !pCCB->IsNoDefaultEpv() )
        {
        ITERATOR    ProcList;
        short       Count;

        Count = GetNormalProcedureList( ProcList,
                                        DTF_NONE
                                      );

        if( Count )
            {
            Out_ManagerEpv( pCCB, pCCB->GetInterfaceName(), ProcList, Count );
            }
        }

    if ( pCommand->NeedsNDR64Run() )
        {
        GenSyntaxInfo( pCCB, FALSE );
        if ( pCCB->GetInterfaceCG()->HasInterpretedCallbackProc() )
            Out_ProxyInfo( pCCB, TRUE );
        }

    if ( HasInterpretedProc() )
        Out_InterpreterServerInfo( pCCB, CGSIDE_SERVER );
 
    return CG_OK;
}



void 
CG_INTERFACE::OutputComplexReturnThunks(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    For procs that return complex types (structures, floating point, etc
    we need to have a thunk that takes a pointer to where to store this
    type.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Notes:
    
    The thunk looks like:

        void Proc_ComplexThunk(..., ReturnType *_RetVal)
        {
            *_RetVal = Proc(...);
        }

 REVIEW: 

    Integrate this with NeedsServerThunk stuff

----------------------------------------------------------------------------*/
{
    if ( CGSIDE_SERVER != pCCB->GetCodeGenSide() )
        return;

    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM    *pStream = pCCB->GetStream();
    ITERATOR    procs;
    CG_PROC    *procCG;

    GetMembers( procs );

    while ( ITERATOR_GETNEXT( procs, procCG ) )
        {
        if ( ! procCG->HasComplexReturnType() || procCG->HasAsyncHandle() )
            continue;


        ITERATOR        params;
        short           nParams;
        expr_proc_call *pCall = new expr_proc_call( procCG->GetSymName() );
        expr_node      *pExpr;
        CG_PARAM       *param;

        procCG->GetMembers( params );
        nParams = ITERATOR_GETCOUNT( params );

        for ( int i = 0; i < nParams - 1; i++ )
            {
            ITERATOR_GETNEXT( params, param );
            pCall->SetParam( new expr_variable( param->GetResource()->GetResourceName() ) );
            }

        node_proc  *proc = new node_proc( (node_proc *) procCG->GetType() );
        node_param *pParam;
        node_skl   *pVoid;
        node_skl   *pOldChild;

        char *pProcName = (char *) alloca(
                                        strlen( proc->GetSymName() ) 
                                        + sizeof( "_ComplexThunk" ) );

        strcpy( pProcName, proc->GetSymName() );
        strcat( pProcName, "_ComplexThunk" );
        proc->SetSymName( pProcName );
        
        // REVIEW: A lot of this is cruft, clean it up!

        GetBaseTypeNode( &pVoid, SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID, ATTR_NONE );
        pParam = new node_param;
        pParam->SetSymName( RETURN_VALUE_VAR_NAME );
        pParam->SetChild( new node_pointer( proc->GetChild() ) );
        pParam->GetChild()->GetModifiers().SetModifier( ATTR_TAGREF );
        pOldChild = proc->GetChild();
        proc->SetChild( pVoid );
//        proc->SetHasComplexReturnType( FALSE );
        proc->RemoveAttribute( ATTR_PTR_KIND );
        proc->AddLastMember( pParam );

        pExpr = new expr_assign(new expr_variable( "*" RETURN_VALUE_VAR_NAME ), pCall );

        pStream->NewLine( 2 );
        proc->PrintType( PRT_DECL, pStream );
        pStream->WriteOnNewLine( "{" );
        pStream->IndentInc();
        pStream->NewLine();
        pExpr->PrintCall( pStream, 0, 0 );
        pStream->IndentDec();
        pStream->WriteOnNewLine( "}" );

        proc->RemoveLastMember();
        proc->SetChild( pOldChild );
        }
}
    


CG_STATUS
CG_INTERFACE::GenHeader(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate interface header file.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error other wise.

 Notes:
    

----------------------------------------------------------------------------*/
{
    node_interface *    pInterface = (node_interface *) GetType();
    ITERATOR            I;
    ITERATOR            J;
    char                Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    CG_HANDLE *         pCGHandle   = GetImplicitHandle();
    node_skl *          pID;
    ISTREAM *           pStream = pCCB->GetStream();
    unsigned short      M, m;
    char            *   pCStubPrefix;
    char            *   pSStubPrefix;
    char            *   pName   = pInterface->GetSymName();
    BOOL                fAnonymous  = IsTempName( pName );

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

    // put out the interface guards
    if ( !fAnonymous )
        {
        pStream->Write("\n#ifndef __");
        pStream->Write( pName );
        pStream->Write( "_INTERFACE_DEFINED__\n" );

        pStream->Write( "#define __");
        pStream->Write( pName );
        pStream->Write( "_INTERFACE_DEFINED__\n" );
        }

    // Print out the declarations of the types and the procedures.
    // If the user defined a prefix for the cstub or sstub,
    // then emit prototypes with the prefix in them.

    pStream->NewLine();
    pInterface->PrintType( 
            PRT_INTERFACE | PRT_BOTH_PREFIX | PRT_OMIT_CS_TAG_PARAMS, 
            pStream, 
            0 );

    if( pCGHandle )
        {
        pID = pCGHandle->GetHandleIDOrParam();
        pStream->NewLine();
        pStream->Write( "extern " );
        pID->PrintType( PRT_ID_DECLARATION, pStream, 0 );
        }

    // Emit the declarations for user supplied routines.


    // Print out the dispatch table.

    pStream->NewLine();
    GetNormalProcedureList( I, DTF_NONE );

    if( pCCB->IsMEpV() )
        {
        if( ITERATOR_GETCOUNT(I) )
            Out_DispatchTableTypedef(
                                    pCCB,
                                    pCCB->GetInterfaceName(),
                                    I,
                                    0
                                    );
        }

    GetCallbackProcedureList( J, DTF_NONE );

    if( ITERATOR_GETCOUNT(J ) )
        Out_DispatchTableTypedef(
                                pCCB,
                                pCCB->GetInterfaceName(),
                                J,
                                1
                                );
    pCCB->GetVersion( &M, &m );

    if ( (pCStubPrefix = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB ) ) == 0 )
        {
        pCStubPrefix = 0;
        }
    if ( (pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR ) )  == 0 )
        {
        pSStubPrefix = 0;
        }

    // Generate the extern for the client if handle.

    pStream->NewLine();
    sprintf( Buffer, "extern RPC_IF_HANDLE %s%s%s_%s;", 
             (pCStubPrefix == 0) ? "" : pCStubPrefix,
             pCCB->GetInterfaceName(),
             pCCB->GenMangledName(),
             (pCCB->IsOldNames()) ? "ClientIfHandle" : "c_ifspec" );
    pStream->Write( Buffer );

    // If a prefix is defined for cstub, generate another extern for the
    // non - prefixed client if handle. Remember, in the header file we need
    // both the externs, since the header file generated out of the -prefix
    // cstub invocation contains prototypes for both prefixed and non-prefix
    // stuff.

    if( pCStubPrefix )
        {
        pStream->NewLine();
        sprintf( Buffer, "extern RPC_IF_HANDLE %s%s%s_%s;", 
                 "",
                 pCCB->GetInterfaceName(),
                 pCCB->GenMangledName(),
                 (pCCB->IsOldNames()) ? "ClientIfHandle" : "c_ifspec" );
        pStream->Write( Buffer );
        }

    pStream->NewLine();
    sprintf( Buffer, "extern RPC_IF_HANDLE %s%s%s_%s;", 
             (pSStubPrefix == 0) ? "" : pSStubPrefix,
             pCCB->GetInterfaceName(),
             pCCB->GenMangledName(),
             (pCCB->IsOldNames()) ? "ServerIfHandle" : "s_ifspec" );
    pStream->Write( Buffer );
    pStream->NewLine();

    // put out the trailing interface guard
    if ( !fAnonymous )
        {
        pStream->Write( "#endif /* __");
        pStream->Write( pName );
        pStream->Write( "_INTERFACE_DEFINED__ */\n" );
        }
    return CG_OK;
}



ITERATOR *
CG_INTERFACE::GetProtSeqEps()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the protocol sequences pairs iterator.

 Arguments:

    Iterator reference.
    
 Return Value:
    
    FALSE if there are no endpoints

 Notes:

    The iterator is invalid if there are no endpoints.

----------------------------------------------------------------------------*/
{
    node_interface  *       pIntf   = (node_interface *) GetType();
    node_endpoint   *       pEps    = (node_endpoint *)
                                        pIntf->GetAttribute( ATTR_ENDPOINT );

    return ( pEps ) ? &(pEps->GetEndPointPairs()) : NULL;

}


void
CG_INTERFACE::CreateDispatchTables()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set up the stub dispatch tables.

 Arguments:

    None.
    
 Return Value:
    
    None.

 Notes:

----------------------------------------------------------------------------*/
{

    pNormalDispatchTable    = new DISPATCH_TABLE();
    pCallbackDispatchTable  = new DISPATCH_TABLE();

    ppDispatchTableSaved = ppDispatchTable = &pNormalDispatchTable;

}

BOOL
CG_INTERFACE::HasInterpretedProc()
{
    CG_ITERATOR    Iterator;
    CG_PROC *   pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) 
            return TRUE;

    return FALSE;
}

BOOL
CG_INTERFACE::HasOnlyInterpretedProcs()
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) == 0 ) 
            return FALSE;

    return TRUE;
}

BOOL
CG_OBJECT_INTERFACE::HasOnlyInterpretedMethods()
{
    CG_ITERATOR             Iterator;
    CG_PROC *               pProc;
    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();
    if ( pBaseCG && !pBaseCG->HasOnlyInterpretedMethods() )
        return FALSE;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) == 0 ) 
            return FALSE;

    return TRUE;
}

BOOL
CG_INTERFACE::HasItsOwnOi2()
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)  ) 
            return TRUE;

    return FALSE;
}

void
CG_INTERFACE::EvaluateVersionControl()
{
    if ( HasItsOwnOi2() )
        {
        GetNdrVersionControl().SetHasOi2();
        }
}

BOOL
CG_OBJECT_INTERFACE::HasItsOwnStublessProxies()
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if (pProc->GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT ) 
            return TRUE;

    return FALSE;
}

void
CG_OBJECT_INTERFACE::EvaluateVersionControl()
{
    CG_OBJECT_INTERFACE*    pBaseCG = (CG_OBJECT_INTERFACE*) GetBaseInterfaceCG();
    if ( pBaseCG )
        {
        pBaseCG->EvaluateVersionControl();
        }

    if ( HasItsOwnStublessProxies()  ||
         pBaseCG  &&  pBaseCG->HasStublessProxies() )
        {
        GetNdrVersionControl().SetHasStublessProxies();
        }

    if ( HasItsOwnOi2()  ||
         pBaseCG  &&  pBaseCG->HasOi2() )
        {
        GetNdrVersionControl().SetHasOi2();
        }
}


BOOL
CG_INTERFACE::HasInterpretedCallbackProc()
{
    CG_ITERATOR    Iterator;
    CG_PROC *   pProc;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( pProc->GetCGID() == ID_CG_CALLBACK_PROC &&
             pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER ) 
            return TRUE;

    return FALSE;
}

BOOL
CG_INTERFACE::HasClientInterpretedCommOrFaultProc( CCB * pCCB )
{
    CG_ITERATOR Iterator;
    CG_PROC *   pProc;
    CGSIDE      Side;

    Side = pCCB->GetCodeGenSide();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        if ( (pProc->GetOptimizationFlags() & OPTIMIZE_INTERPRETER) &&
             pProc->HasStatuses() && 
             ( ((pProc->GetCGID() == ID_CG_PROC) && (Side == CGSIDE_CLIENT)) ||
               ((pProc->GetCGID() == ID_CG_CALLBACK_PROC) && (Side == CGSIDE_SERVER)) ) ) 
            return TRUE;

    return FALSE;
}

CG_STATUS
CG_INTERFACE::InitializeCCB( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Initialize the CCB for this interface.

 Arguments:
    
    pCCB    - a pointer to the code generation control block.

 Return Value:

    CG_OK   if all is well, error otherwise.
    
 Notes:

----------------------------------------------------------------------------*/
{
    unsigned short      Major,minor;    
    node_interface *pInterface = (node_interface *) GetType();

    pInterface->GetVersionDetails(&Major, &minor);
    pCCB->SetVersion(Major, minor);
    pCCB->SetInterfaceName(pInterface->GetSymName());
    pCCB->SetInterfaceCG(this);

    return CG_OK;
}


void
CG_INTERFACE::OutputProcOffsets( CCB * pCCB, BOOL fLast, BOOL IsForCallback )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a list of offsets (from the beginning of the proc format info)
    to each proc in the interface

 Arguments:
    
    pCCB            - a pointer to the code generation control block.
    fLast           -
    IsForCallback   -

 Notes:

    For Ndr32 the list is a table of shorts that offset from the beginning
    of the proc format string.

    For Ndr64 it is a table of longs that is the offset from the format info 
    structure.

----------------------------------------------------------------------------*/
{
    CG_PROC *   pProc;
    CG_ITERATOR    Iterator;
    ISTREAM *   pStream     = pCCB->GetStream();
    CGSIDE      Side;
    long        Offset;

    // IUnknown doesn't get entries in the proc offsets table
    if ( IsIUnknown() )
        {
        if ( fLast )
            {
            pStream->Write( '0' );
            pStream->NewLine();
            }
        return;
        }

    Side = pCCB->GetCodeGenSide();

    if ( IsObject() )
        {
        CG_OBJECT_INTERFACE * pObjInterface;

        pObjInterface = (CG_OBJECT_INTERFACE *) this;

        if ( pObjInterface->GetBaseInterfaceCG() )
            {
            pObjInterface->GetBaseInterfaceCG()->OutputProcOffsets( pCCB, FALSE, IsForCallback );
            }
        } 

    GetMembers( Iterator );

    BOOL fNoOffsetsEmitted = TRUE;

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        {
        if ( (Side == CGSIDE_CLIENT) &&
            ( IsForCallback ? ( pProc->GetCGID() != ID_CG_CALLBACK_PROC ) :
             (pProc->GetCGID() == ID_CG_CALLBACK_PROC) ) )
            continue;

        if ( (Side == CGSIDE_SERVER) &&
             ( ( IsForCallback ? ( pProc->GetCGID() != ID_CG_CALLBACK_PROC ) :
               ( pProc->GetCGID() == ID_CG_CALLBACK_PROC )  )
               || (pProc->GetCGID() == ID_CG_TYPE_ENCODE_PROC ) ) )
            continue;

        CG_PROC *pTargetProc = pProc;

        if ( fLocal )
            pTargetProc = pProc->GetCallAsCG();

        // type encode procs are not real procs

        if ( dynamic_cast<CG_TYPE_ENCODE_PROC *>(pTargetProc) )
            continue;

        fNoOffsetsEmitted = FALSE;

        // REVIEW: If Offset is -1 (dce) or 0 (ndr64) then we haven't generated
        //         format info for the proc.  This can only happen in certain
        //         conditions ([nocode], methods in parent interface).  There
        //         should be an assert.

        if ( pCommand->IsNDR64Run() )
            {
            Offset = 0;
            if ( pTargetProc )
                Offset = (long) (size_t) pCCB->GetNdr64Format()->GetRoot()
                                        ->LookupFragmentID( pTargetProc );

            if ( 0 == Offset )
                pStream->Write( "(FormatInfoRef) -1" );
            else
                pStream->WriteNumber( "&__midl_frag%d", Offset );
            }
        else
            {
            Offset = -1;
            if ( pTargetProc )
                Offset = pTargetProc->GetFormatStringOffset();

            if ( -1 == Offset )
                pStream->Write( "(unsigned short) -1" );
            else
                pStream->WriteNumber( "%d", Offset );
            }

        if ( pProc->GetSibling() || !fLast )
            pStream->Write( ',' );

        pStream->NewLine();
        }

    if ( fNoOffsetsEmitted && fLast )
        {
        pStream->Write( '0' );
        pStream->NewLine();
        }
}

void
CG_INTERFACE::OutputThunkTableEntries( CCB * pCCB, BOOL fLast )
{
    CG_PROC *   pProc;
    CG_ITERATOR Iterator;
    ISTREAM *   pStream     = pCCB->GetStream();
    CGSIDE      Side        = pCCB->GetCodeGenSide();
    char    *   pIntfName   = GetType()->GetSymName();

    // IUnknown doesn't get entries in the thunk table
    if ( IsIUnknown() )
        {
        if ( fLast )
            {
            pStream->Write( '0' );
            pStream->NewLine();
            }
        return;
        }

    if ( IsObject() )
        {
        CG_OBJECT_INTERFACE * pObjInterface;

        pObjInterface = (CG_OBJECT_INTERFACE *) this;

        if ( pObjInterface->GetBaseInterfaceCG() )
            {
            pObjInterface->GetBaseInterfaceCG()->OutputThunkTableEntries( pCCB, FALSE );
            }
        } 

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pProc ) )
        {
        if ( (Side == CGSIDE_CLIENT) && 
             (pProc->GetCGID() != ID_CG_CALLBACK_PROC) )
            continue;

        if ( (Side == CGSIDE_SERVER) && 
             (pProc->GetCGID() == ID_CG_CALLBACK_PROC) )
            continue;

        if ( pProc->NeedsServerThunk( pCCB, Side ) && !pProc->IsDelegated() )
            {
            pStream->Write( pIntfName );
            pStream->Write( '_' );
            pStream->Write( pProc->GetType()->GetSymName() );

            // if( IsObject() )
                pStream->Write( "_Thunk" );
            }
        else
            pStream->Write( '0' );

        if ( pProc->GetSibling() || !fLast )
            pStream->Write( ',' );

        pStream->NewLine();
        }
}

void
CG_INTERFACE::OutputInterfaceIdComment( CCB * pCCB )
{
    char            TmpBuf[40];
    unsigned short  Major, Minor;
    ISTREAM *   pStream = pCCB->GetStream();
    char *      pIfKind = IsObject() ? "Object"
                                     : HasPicklingStuffOnly() ? "Pickling"
                                                              : "Standard";
    pStream->NewLine(2);
    sprintf( TmpBuf, "/* %s interface: ", pIfKind );
    pStream->Write( TmpBuf );
    pStream->Write( GetInterfaceName() );

    ((node_interface *) GetType())->GetVersionDetails( &Major, &Minor );
    sprintf( TmpBuf, ", ver. %d.%d,\n   GUID=", Major, Minor );
    pStream->Write( TmpBuf );

    Out_Guid( pCCB, GetGuidStrs() );
    pStream->Write( " */" );
    pStream->NewLine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ilreg.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	ilreg.cxx

 Abstract:

	This file implements the type registry for structure/union reuse.

 Notes:

 History:

	Oct-25-1993		GregJen		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

#include "ilreg.hxx"

/***********************************************************************
 * global data
 **********************************************************************/

// #define trace_reuse

REUSE_DICT				*	pReUseDict;

REUSE_DICT::REUSE_DICT()
		: Dictionary()
	{
	}

SSIZE_T
REUSE_DICT::Compare( pUserType pL, pUserType pR )
	{
	SSIZE_T	l1	= (SSIZE_T) ((REUSE_INFO *)pL)->pType;
	SSIZE_T l2  = (SSIZE_T) ((REUSE_INFO *)pR)->pType;

	return l1 - l2;
	}


REUSE_INFO *
REUSE_DICT::IsRegistered(
	REUSE_INFO	*	pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a type with the reuse registry.

 Arguments:

 	pInfo	- A pointer to the type being registered.
	
 Return Value:

 	The node that gets registered.
	
 Notes:

----------------------------------------------------------------------------*/
{
#ifdef trace_reuse
printf(". . .Reuse: finding %08x\n", pInfo->pType );
fflush(stdout);
#endif
	Dict_Status	Status	= Dict_Find( pInfo );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (REUSE_INFO *)0;
		default:
			return (REUSE_INFO *)Dict_Curr_Item();
		}
}

REUSE_INFO *
REUSE_DICT::Register(
	REUSE_INFO	*	pInfo )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a type with the dictionary.

 Arguments:
	
 	pType	- A pointer to the type node.

 Return Value:

 	The final inserted type.
	
 Notes:

----------------------------------------------------------------------------*/
{
#ifdef trace_reuse
printf(". . .Reuse: inserting %08x\n", pInfo->pType );
fflush(stdout);
#endif
		Dict_Insert( (pUserType) pInfo );
		return pInfo;
}

BOOL				
REUSE_DICT::GetReUseEntry( 
	REUSE_INFO * & pRI, 
	node_skl * pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a type with the dictionary.

 Arguments:
	
 	pRI		- A pointer to the returned REUSE_INFO block
 	pNode	- A pointer to the type node.

 Return Value:

 	True if the entry was already in the table,
 	False if the entry is new.
	
 Notes:

----------------------------------------------------------------------------*/
{
	REUSE_INFO		TempEntry(pNode);
	REUSE_INFO	*	pRealEntry;

#ifdef trace_reuse
printf(". . .Reuse: searching for %08x\n", pNode );
fflush(stdout);
#endif
	if ( (pRealEntry = IsRegistered( &TempEntry ) ) == 0 )
		{
		pRealEntry = new REUSE_INFO( pNode );
		Register( pRealEntry );
		pRI = pRealEntry;
#ifdef trace_reuse
printf(". . .Reuse: new node %08x\n", pRI );
fflush(stdout);
#endif
		return FALSE;
		}

	pRI	= pRealEntry;
#ifdef trace_reuse
printf(". . .Reuse: found %08x\n", pRI );
fflush(stdout);
#endif
	return TRUE;

}

void
REUSE_DICT::MakeIterator(
	ITERATOR&	ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get a list of structs and unions into the specified iterator.

 Arguments:
	
	ListIter	- A reference to the iterator class where the list is
				  accumulated.

 Return Value:
	
	A count of the number of resources.

 Notes:

----------------------------------------------------------------------------*/
{
	REUSE_INFO	*	pR;
	Dict_Status		Status;
	
	//
	// Get to the top of the dictionary.
	//

	Status = Dict_Next( (pUserType) 0 );

	//
	// Iterate till the entire dictionary is done.
	//

	while( SUCCESS == Status )
		{
		pR	= (REUSE_INFO *)Dict_Curr_Item();
		ITERATOR_INSERT( ListIter, pR->pSavedCG );
		Status = Dict_Next( pR );
		}

	return;
}

/****************************************************************************
 	utility functions.
 ****************************************************************************/
SSIZE_T
CompareReUseKey( void * p1, void *p2 )
	{
#ifdef trace_reuse
printf(". . .Reuse: comparing %08x to %08x (in)\n", p1, p2 );
fflush(stdout);
#endif
	SSIZE_T	l1	= (SSIZE_T)
					((REUSE_INFO *)p1)->pType;
	SSIZE_T	l2	= (SSIZE_T)
					((REUSE_INFO *)p2)->pType;

#ifdef trace_reuse
printf(". . .Reuse: comparing %08x to %08x\n", l1, l2 );
fflush(stdout);
#endif

	if( l1 < l2 ) return -1;
	else if( l1 > l2 ) return 1;
	return 0;
	}
void
PrintReUseKey( void* ) { }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ndr64.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:
    
    ndr64.cxx

 Abstract:

    Routines for the ndr64 transfer syntax.

 Notes:


 History:

 ----------------------------------------------------------------------------*/


#include "becls.hxx"

char * _SimpleTypeName[] = {
    "",
    "NDR64_FORMAT_UINT8",
    "NDR64_FORMAT_UINT16",
    "NDR64_FORMAT_UINT32",
    "NDR64_FORMAT_UINT64"
};

// define the name table for the NDR64 format characters
#define NDR64_BEGIN_TABLE \
const char *pNDR64FormatCharNames[] = {

#define NDR64_TABLE_END \
};

#define NDR64_ZERO_ENTRY \
"FC64_ZERO"

#define NDR64_TABLE_ENTRY( number, tokenname, marshal, embeddedmarshall, unmarshall, embeddedunmarshal, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
, #tokenname

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, simpletypebuffersize, simpletypememorysize ) \
, #tokenname

#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) \
, #tokenname

#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) \
, NULL

#include "tokntbl.h"

extern const pNDR64FormatCharNamesSize = (sizeof(pNDR64FormatCharNames) / sizeof(*pNDR64FormatCharNames));

C_ASSERT( (sizeof(pNDR64FormatCharNames) / sizeof(*pNDR64FormatCharNames)) == 256 );
#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_END
#undef NDR64_ZERO_ENTRY
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY_NOSYM


FormatFragment * GenExprFormatString(CCB *pCCB,
                         expr_node *pSizeExpr,
                         CompositeFormatFragment *FragmentList,
                         BOOL    *  IsEarly,
                         ulong *    pExprLength );


//+--------------------------------------------------------------------------
//
//  Method:     FormatFragment::OutputDescription
//
//  Synopsis:   Output a description of this fragment
//
//  Notes:      The output is in the form of a C style comment.
//              The decription is the name of the type that this fragment
//              represents.  If this fragment represents more than on type
//              because of optimization then all the types will be output.
//              
//---------------------------------------------------------------------------

void FormatFragment::OutputDescription( ISTREAM *stream )
{
    FormatFragment *frag = this;
    bool            first = true;

    stream->WriteOnNewLine( "/* " );

    do
    {
        if ( !first )
            stream->Write(", ");

        CG_CLASS   *pClass = frag->GetCGNode();
        const char *pName = NULL;

        while ( NULL != pClass && pClass->IsPointer() )
            {
            stream->Write( "*" );
            pClass = pClass->GetChild();
            }
        if ( NULL != pClass && NULL != pClass->GetType() )
            {
            pName = pClass->GetName();
            if ( pName != NULL && pName[0] == '\0' )
                pName = NULL;
            }
        if ( NULL == pName )
            pName = frag->GetTypeName();

        stream->Write( pName );

        frag = frag->pNextOptimized;
        first = false;
    }
    while ( NULL != frag );

    stream->Write( " */" );
}



//+--------------------------------------------------------------------------
//
//  Method:     CompositeFormatFragment::IsEqualTo
//
//  Synopsis:   Compare two composite fragments
//
//  Notes:      This method compares two composite fragments. Two composite
//              fragments are equal if and only if the elements of the composite
//              are equal.
//              
//---------------------------------------------------------------------------

bool CompositeFormatFragment::IsEqualTo( FormatFragment *candidate )
{
    CompositeFormatFragment *pOther = (CompositeFormatFragment *)candidate;

    FormatFragment *pCurrent        = pHead;
    FormatFragment *pCurrentOther   = pOther->pHead;

    while ( (pCurrent != NULL) &&
            (pCurrentOther != NULL) )
        {

        const type_info &frag_type      = typeid( *pCurrent );
        const type_info &other_type     = typeid( *pCurrentOther );

        if ( frag_type != other_type )
            return false;

        if ( !pCurrent->IsEqualTo( pCurrentOther ) )
            return false;

        pCurrent        = pCurrent->Next;
        pCurrentOther   = pCurrentOther->Next;

        }

    // Both lists must have the same length.
    bool bResult = ( NULL == pCurrent ) && ( NULL == pCurrentOther );

    return bResult;
}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::LookupFragment
//
//  Synopsis:   Find the fragment corresponding to a class
//
//  Parameters: [pClass]        -- The class
//
//  Returns:    NULL if the class has no fragment yet
//
//---------------------------------------------------------------------------

FormatFragment * CompositeFormatFragment::LookupFragment( CG_CLASS *pClass )
{
    FormatFragment *frag;
  
    // Generic handles are a special case.  They don't actually have any
    // representation in the format info.

    if ( ID_CG_GENERIC_HDL == pClass->GetCGID() )
        pClass = pClass->GetChild();

    for ( frag = pHead; NULL != frag; frag = frag->Next )
        if ( frag->pClass == pClass )
            return frag;

    return NULL;
}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::AddFragment
//
//  Synopsis:   Add a fragment to the list if it isn't already present
//
//  Parameters: [frag]          -- The fragment
//    
//  Returns:    The id of the fragment
//              
//  Notes:      Another way to think of this method is that it provides a
//              mapping between CG_CLASS pointers and FormatInfoRef's.
//
//---------------------------------------------------------------------------

FormatInfoRef CompositeFormatFragment::AddFragment( FormatFragment *frag )
{
    frag->Next   = NULL;
    frag->RefID  = NextRefID;
    frag->Prev   = pTail;
    frag->Parent = this;

    if ( NULL == pTail )
        pHead = frag;
    else
        pTail->Next = frag;

    pTail = frag;
    NextRefID = (FormatInfoRef) ((size_t) NextRefID + 1);

    return frag->RefID;
}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::OutputFragmentType
//
//  Synopsis:   Output a type declaration for this composite
//
//  Notes:      It looks like:
//
//              struct <name>
//              {
//                  <frag1 type>,
//                  <frag2 type>
//                  ...
//              }
//
//---------------------------------------------------------------------------

void CompositeFormatFragment::OutputFragmentType( CCB *pCCB )
{

    ISTREAM *stream = pCCB->GetStream();

    stream->WriteOnNewLine("struct ");
    stream->Write( GetTypeName() );
    stream->WriteOnNewLine("{");
    stream->IndentInc();

    FormatFragment *pCurrent = pHead;

    for ( pCurrent = pHead; NULL != pCurrent; pCurrent = pCurrent->Next )
        {
        if ( pCurrent->WasOptimizedOut() )
        {
            // Only top-level stuff should be optimized
            MIDL_ASSERT( NULL == GetParent() );
            continue;
        }

        pCurrent->OutputFragmentType( pCCB );
        stream->WriteFormat(" frag%d;", (size_t) pCurrent->GetRefID());
        }

    stream->IndentDec();
    stream->WriteOnNewLine("}");

}



//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::OutputFragmentData
//
//  Synopsis:   Output the initializer data for this composite
//
//  Notes:      It looks like:
//
//              {
//                  <frag1 data>,
//                  <frag2 type>
//                  ...
//              }
//
//---------------------------------------------------------------------------

void CompositeFormatFragment::OutputFragmentData( CCB *pCCB )
{
    
    ISTREAM *stream = pCCB->GetStream();

    OutputStructDataStart( pCCB );

    FormatFragment *pCurrent;
    bool FirstFragment = true;

    for ( pCurrent = pHead; NULL != pCurrent; pCurrent = pCurrent->Next )
        {
        if ( pCurrent->WasOptimizedOut() )
        {
            // Only top-level stuff should be optimized
            MIDL_ASSERT( NULL == GetParent() );
            continue;
        }

        if ( !FirstFragment )
            stream->Write(",");

        FirstFragment = false;

        pCurrent->OutputFragmentData( pCCB );

    }

    OutputStructDataEnd( pCCB );
}

//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment::OptimizeFragment
//
//  Synopsis:   Try to optimize out a fragment in the format string by
//              checking to see if it is the same as some other fragment.
//
//  Parameters: [frag]     -- The fragment to optimize
//
//  Returns:    The final ID of the fragment
//              
//  Notes:      Optimization can be suppressed by the user by specifiying
//              -no_format_opt
//  
//---------------------------------------------------------------------------

FormatInfoRef CompositeFormatFragment::OptimizeFragment( FormatFragment *frag )
{
    if ( pCommand->IsSwitchDefined( SWITCH_NO_FMT_OPT ) )
        return frag->RefID;

    // Only stuff in the root composite can be optimized

    if ( ! dynamic_cast<RootFormatFragment *>(frag->GetParent()) )
        return frag->RefID;

    FormatFragment *candidate;

    for ( candidate = pHead; 
          NULL != candidate && candidate != frag; 
          candidate = candidate->Next )
        {
        const type_info &frag_type      = typeid( *frag );
        const type_info &candidate_type = typeid( *candidate );

        if ( frag_type != candidate_type )
            continue;

        if ( candidate->IsEqualTo( frag ) )
            {
            frag->RefID = candidate->RefID;
            
            while ( NULL != candidate->pNextOptimized )
                candidate = candidate->pNextOptimized;

            candidate->pNextOptimized = frag;
            frag->pPrevOptimized = candidate;

            break;
            }
        }

    return frag->RefID;
}
        
//+--------------------------------------------------------------------------
//
//  Method:     RootFormatFragement::Output
//
//  Synopsis:   Output a the whole ndr64 format structure
//
//---------------------------------------------------------------------------

void RootFormatFragment::Output( CCB *pCCB )
{
    ISTREAM *stream = pCCB->GetStream();

    stream->NewLine();

    // REVIEW: Is this the right place to output these?

    stream->WriteOnNewLine("#include \"ndr64types.h\"");
    stream->WriteOnNewLine("#include \"pshpack8.h\"");
    stream->NewLine();

    FormatFragment *pCurrent;

    for ( pCurrent = pTail; NULL != pCurrent; pCurrent = pCurrent->Prev )
        {
        if ( pCurrent->WasOptimizedOut() )
            continue;

        stream->NewLine();
        stream->WriteOnNewLine("typedef ");
        pCurrent->OutputFragmentType( pCCB );
        stream->NewLine();
        stream->WriteFormat("__midl_frag%d_t;", pCurrent->GetRefID() );
        stream->NewLine();
        stream->WriteFormat(
                    "extern const __midl_frag%d_t __midl_frag%d;", 
                    pCurrent->GetRefID(), 
                    pCurrent->GetRefID() );            
        }

    for ( pCurrent = pTail; NULL != pCurrent; pCurrent = pCurrent->Prev )
        {
        if ( pCurrent->WasOptimizedOut() )
            continue;

        stream->NewLine( 2 );
        stream->WriteFormat(
                    "static const __midl_frag%d_t __midl_frag%d =", 
                    pCurrent->GetRefID(), 
                    pCurrent->GetRefID() );            
        pCurrent->OutputFragmentData( pCCB );
        stream->Write(";");
        }

    stream->NewLine( 2 );
    stream->WriteOnNewLine("#include \"poppack.h\"");
    stream->NewLine( 2 );
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::CreateInstance  (static)
//
//  Synopsis:   Class factory for GenNdr64Format
//
//---------------------------------------------------------------------------

GenNdr64Format * GenNdr64Format::CreateInstance( CCB *pCCB )
{
    MIDL_ASSERT( pCommand->IsNDR64Run() );

    CG_VISITOR_TEMPLATE<GenNdr64Format> *pVisitor = new CG_VISITOR_TEMPLATE<GenNdr64Format>;

	GenNdr64Format *generator = pVisitor;

    generator->pCCB     = pCCB;
    generator->pRoot    = new RootFormatFragment;
    generator->pCurrent = generator->pRoot;
    generator->pVisitor = pVisitor;

    // add a dummy entry at the beginning of format string to prevent
    // an emptry structure being generated when there is only [local] 
    // interface in an .idl file.
    MIDL_NDR_FORMAT_UINT32  * pDummy = new MIDL_NDR_FORMAT_UINT32;
    pDummy->Data = 0;
    
    generator->pRoot->AddFragment( pDummy ); 
    
    return generator;
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::ContinueGeneration
//
//  Synopsis:   Do generation for a sub-tree. This is typically called
//              by a parent node to generate it's children so that it can
//              get offsets to the child format string indices, etc.
//
//  Parameters: pClass              -- The subtree to generate from
//              pCompositeFragment  -- The composite to generate into
//
//---------------------------------------------------------------------------


FormatInfoRef GenNdr64Format::ContinueGeneration( 
    CG_CLASS *pClass,
    CompositeFormatFragment *pComposite )
{
    CompositeFormatFragment *pOldCurrent = pCurrent;

    // Some CG classes don't have children.  Those classes should not be
    // calling ContinueGeneration on thier non-existant children.

    MIDL_ASSERT( NULL != pClass );

    // Do this here to save from every visit function from doing it.
    FormatFragment* pFrag = pComposite->LookupFragment( pClass );
    if ( NULL != pFrag )
        return pFrag->GetRefID();

    if ( NULL != pComposite )
        pCurrent    = pComposite;        

    pClass->Visit( pVisitor );

    FormatInfoRef NewFragmentID = pCurrent->LookupFragmentID( pClass );

    pCurrent    =   pOldCurrent;

    return NewFragmentID;
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Generate
//
//  Synopsis:   External routine called to generate the string for a type.
//
//  Parameters: pClass              -- Type to generate string for.
//
//---------------------------------------------------------------------------

FormatInfoRef GenNdr64Format::Generate( CG_CLASS *pClass ) 
     {
     return ContinueGeneration( pClass, GetRoot() );
     }

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Output
//
//  Synopsis:   External routine called to output the string.
//
//  Parameters: None
//
//---------------------------------------------------------------------------
    
void GenNdr64Format::Output( )
     {
     GetRoot()->Output( pCCB );
     }


//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::ContinueGenerationInRoot
//
//  Synopsis:   Same as ContinueGeneration except switches to root.
//
//  Parameters: pClass              -- The subtree to generate from
//
//---------------------------------------------------------------------------


inline FormatInfoRef GenNdr64Format::ContinueGenerationInRoot( CG_CLASS *pClass )
{
    return ContinueGeneration( pClass, GetRoot() );
}


//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_CLASS )
//
//  Synopsis:   Default visitor that handles things that don't need any
//              handling.
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_CLASS *pClass )
{
    // Should only be called for these classes or drived ones
/*
    assert(
        NULL != dynamic_cast<CG_AUX *>(pClass) 
          );
*/

    CG_ITERATOR Iterator;
    CG_CLASS    *pChild;

    pClass->GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pChild ) )
        ContinueGenerationInRoot( pChild );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_BASETYPE )
//
//  Synopsis:   Generate info for base types and ranges
//
//  Notes:      FC64_BYTE, FC64_CHAR, FC64_WCHAR, FC64_SMALL, FC64_USMALL,
//              FC64_SHORT, FC64_USHORT, FC64_LONG, FC64_ULONG, FC64_HYPER, FC64_UHYPER,
//              FC64_INT3264, FC64_UINT3264, FC64_FLOAT, FC64_DOUBLE, 
//              FC64_ERROR_STATUS_T
//
//              (also, pending support elsewhere)
//
//              FC64_INT128, FC64_UINT128, FC64_FLOAT128, FC64_FLOAT80
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_BASETYPE *pClass )
{
    if ( pClass->GetRangeAttribute() )
        {
        GenRangeFormat( pClass );
        return;
        }

    MIDL_NDR64_FORMAT_CHAR *frag = new MIDL_NDR64_FORMAT_CHAR( pClass );

    GetCurrent()->AddFragment( frag );
    GetRoot()->OptimizeFragment( frag );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenRangeFormat
//
//  Synopsis:   Ranges are a special case of base types so we can't
//              distinguish between them polymorphically.  The base type
//              visitor method calls this if we have a range.
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenRangeFormat( CG_BASETYPE *pRangeCG )
{
    MIDL_NDR64_RANGE_FORMAT    *format;
    node_range_attr            *range;

    format = new MIDL_NDR64_RANGE_FORMAT( pRangeCG );

    range = pRangeCG->GetRangeAttribute();
    MIDL_ASSERT( NULL != range );

    format->FormatCode   = FC64_RANGE;
    format->RangeType    = (NDR64_FORMAT_CHAR)pRangeCG->GetNDR64FormatChar();
    format->Reserved     = 0;
    format->MinValue     = range->GetMinExpr()->GetValue();
    format->MaxValue     = range->GetMaxExpr()->GetValue();

    GetCurrent()->AddFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_ENCAPSULATED_STRUCT )
//
//  Synopsis:   Despite the name, this is for generating info for 
//              encapsulated unions
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_ENCAPSULATED_STRUCT *pEncapUnion )
{

    // A union is represented in the format info by a composite containing
    // the union header follow by fragments representing the arm selector

    CompositeFormatFragment *composite = new CompositeFormatFragment( pEncapUnion );

    GetCurrent()->AddFragment( composite );

    MIDL_NDR64_ENCAPSULATED_UNION *format;

    format = new MIDL_NDR64_ENCAPSULATED_UNION( pEncapUnion );

    composite->AddFragment( format );

    CG_FIELD    *pSwitchField = (CG_FIELD *) pEncapUnion->GetChild();
    CG_BASETYPE *pSwitch      = (CG_BASETYPE *) pSwitchField->GetChild();
    CG_FIELD    *pUnionField  = (CG_FIELD *) pSwitchField->GetSibling();
    CG_UNION    *pUnion       = (CG_UNION *) pUnionField->GetChild();

    MIDL_ASSERT( NULL != dynamic_cast<CG_BASETYPE *>(pSwitch) );
    MIDL_ASSERT( NULL != pUnion && NULL != dynamic_cast<CG_UNION *>(pUnion) );

    format->FormatCode      = FC64_ENCAPSULATED_UNION;         
    format->Alignment       = ConvertAlignment( pEncapUnion->GetWireAlignment() );
    format->Flags           = 0;
    format->SwitchType      = (NDR64_FORMAT_CHAR)pSwitch->GetNDR64SignedFormatChar();
    format->MemoryOffset    = pUnionField->GetMemOffset() 
                                        - pSwitchField->GetMemOffset();
    format->MemorySize      = pEncapUnion->GetMemorySize();
    format->Reserved        = 0;

    GenerateUnionArmSelector( pUnion, composite );    
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateUnionArmSelector
//
//  Synopsis:   Generate info about union arms
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenerateUnionArmSelector( 
        CG_UNION                *pUnion, 
        CompositeFormatFragment *FragmentList )
{
    MIDL_NDR64_UNION_ARM_SELECTOR *header;

    header = new MIDL_NDR64_UNION_ARM_SELECTOR;

    header->Reserved1            = 0;
    header->Alignment            = ConvertAlignment( pUnion->GetWireAlignment() );
    header->Reserved2            = 0;
    header->Arms                 = (NDR64_UINT32) pUnion->GetNumberOfArms();

    FragmentList->AddFragment( header );

    // Generate the non-default arms

    CG_ITERATOR  Iterator;
    CG_CASE     *pCase;
    CG_CASE     *pDefaultCase = NULL;
    NDR64_UINT16 ArmCount = 0;

    pUnion->GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {   
        // The default case is always put at the end

        if ( ID_CG_DEFAULT_CASE == pCase->GetCGID() )
            {
            pDefaultCase = pCase;
            continue;
            }

        MIDL_NDR64_UNION_ARM *arm = new MIDL_NDR64_UNION_ARM;

        MIDL_ASSERT( NULL != pCase->GetExpr() );

        arm->CaseValue = pCase->GetExpr()->GetValue();

        // it's legal to have a case with no type

        if ( NULL == pCase->GetChild() || NULL == pCase->GetChild()->GetChild() )
            arm->Type = 0;
        else
            arm->Type = ContinueGenerationInRoot( 
                                pCase->GetChild()->GetChild() );

        arm->Reserved = 0;
        FragmentList->AddFragment( arm );
        ++ArmCount;
        }

    MIDL_ASSERT( ArmCount == header->Arms );

    // Generate the default

    PNDR64_FORMAT    Type;

    if ( NULL == pDefaultCase )
        Type = (PNDR64_FORMAT) -1;
    else
        {
        CG_CLASS *pType = pDefaultCase->GetChild();

        if ( NULL != pType )
            pType = pType->GetChild();

        if ( NULL == pType )
            Type = 0;
        else
            Type = ContinueGenerationInRoot( pType );
        }

    FragmentList->AddFragment( new MIDL_NDR64_DEFAULT_CASE( Type ) );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_INTERFACE )
//
//  Synopsis:   Generate info for interfaces
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_INTERFACE *pInterface )
{
    CG_ITERATOR     I;
    CCB            *pCCB = GetCCB();
    CG_PROC        *pProc;

    pInterface->InitializeCCB( pCCB );

    pCCB->SetImplicitHandleIDNode( 0 );

	if( pInterface->GetMembers( I ) )
        while ( ITERATOR_GETNEXT( I, pProc ) )
            ContinueGenerationInRoot( pProc );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_PARAM )
//
//  Synopsis:   Generate info for parameters
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_PARAM *pParam )
{

    if ( GetCurrent()->HasClassFragment( pParam ) )
        return;

    NDR64_PARAM_FLAGS   Attributes;
    CG_NDR             *pChild;
    CG_NDR             *pOldPlaceholder;

    pChild = (CG_NDR *) pParam->GetChild();

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *) pChild->GetChild();

    // Ignore the following type of arguments that don't go on wire:
    //  - async handles
    //  - primitive handles
    //  
    if ( pChild->GetCGID() == ID_CG_PRIMITIVE_HDL  || ( (CG_PARAM*) pParam)->IsAsyncHandleParam() )
        return;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

    // Get the parameter attributes.  The 32-bit PARAM_ATTRIBUTES structure
    // is essentially the same as the NDR64_PARAM_FLAGS structure except
    // the 64-bit structure has a single bit (UseCache) for the old 
    // ServerAllocSize field

    PARAM_ATTRIBUTES *pattr = (PARAM_ATTRIBUTES *) &Attributes;
    pChild->GetNdrParamAttributes( pCCB, pattr );
    Attributes.UseCache = (NDR64_UINT16) ((pattr->ServerAllocSize) ? 1 : 0);
    Attributes.Reserved = 0;

    // For reasons not understood, GenNdrParamAttributes marks basetypes as
    // not by value even if they are (unless they are ranges).  Fix the 
    // insanity.

    if ( pChild->IsSimpleType() )
        Attributes.IsByValue = 1;

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    // Get the fragment of the pointee.

    FormatFragment *pChildFragment;

    pChildFragment = GetCurrent()->GetParent()->LookupFragment( pChild );
    MIDL_ASSERT( NULL != pChildFragment );

    // Fill in the parameter information

    MIDL_NDR64_PARAM_FORMAT    *format;

    format = new MIDL_NDR64_PARAM_FORMAT( pParam );

    format->Attributes      = Attributes;
    format->Reserved        = 0;
    
    pParam->GetStackOffsets( pCCB, &format->StackOffset );

    // REVIEW:  The reason why we have to test base types seperately is
    //          because of the inconsistent way things are stored.  Consider
    //          a string pointer.  It's format info is a simple ref to an
    //          string array - this can be intrepreted as a pointer to a block
    //          of memory.  However, it's CG representation is just a pointer.
    //          The missing level of dereference causes the problem.  In
    //          constrast a pointer to a single long is represented as a ref
    //          pointer to a long both in CG and in the format info.

    if ( Attributes.IsBasetype
         && ( Attributes.IsByValue || Attributes.IsSimpleRef ) )
        {
        if ( Attributes.IsSimpleRef )
            pChild = (CG_NDR *) pChild->GetChild();

        format->Type = GetRoot()->LookupFragment( pChild )->GetRefID();
        }
    else
        {
        FormatFragment *pCompChildFragment = GetCurrent()->GetParent()->LookupFragment( pChild );
        MIDL_ASSERT( NULL != pCompChildFragment );

        // Is the parameter is a simple ref, we need to bypass the pointer
        // in the format string.
        if ( Attributes.IsSimpleRef )
            {
            MIDL_NDR64_POINTER_FORMAT* pPointerFrag =
                 dynamic_cast<MIDL_NDR64_POINTER_FORMAT*>(pCompChildFragment);
            format->Type = pPointerFrag->Pointee;
            }
        else 
            {
            format->Type = pCompChildFragment->GetRefID();
            }
        }        

    GetCurrent()->AddFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_PROC )
//
//  Synopsis:   Generate info for interfaces
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_PROC *pProc )
{

    if ( GetCurrent()->HasClassFragment( pProc ) )
        return;

    CG_NDR *                pOldCGNodeContext;
    CG_ITERATOR             Iterator;
    CG_PARAM *              pParam;
    short                   ParamNum;
    long                    ServerBufferSize;
    long                    ClientBufferSize;
    long                    BufSize;
    BOOL                    fServerMustSize;
    BOOL                    fClientMustSize;

    // Make sure [call_as] targets are processed

    CG_PROC *pCallAs = pProc->GetCallAsCG();
    if (pCallAs)
        ContinueGenerationInRoot( pCallAs );

    CompositeFormatFragment *composite = new CompositeFormatFragment( pProc );

    composite->SetParent( GetCurrent() );
    GetCurrent()->AddFragment(composite);

    MIDL_NDR64_PROC_FORMAT *format = new MIDL_NDR64_PROC_FORMAT( pProc );

    composite->AddFragment( format );

    pCCB->SetInObjectInterface( pProc->IsObject() );

    pOldCGNodeContext = pCCB->SetCGNodeContext( pProc );

    //
    // If this procedure uses an explicit handle then set the
    // NdrBindDescriptionOffset to 0 so that it will not try to output it's
    // description when given the GenNdrParamOffLine method in the loop below.
    // It's description must be part of the procedure description.
    //
    if ( pProc->GetHandleUsage() == HU_EXPLICIT )
        {
        CG_HANDLE * pHandle = pProc->GetHandleClassPtr();

        pHandle->SetNdrBindDescriptionOffset( 0 );

        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            // The context handle directs the call.
            ((CG_CONTEXT_HANDLE *)pHandle)->SetCannotBeNull();
            }
        }

    if ( !pProc->IsObject() && !pCCB->IsInCallback() )
        {
        if ( HU_IMPLICIT == pProc->GetHandleUsage() )
            {
            if ( pProc->IsGenericHandle() )
                pCCB->RegisterGenericHandleType(
                            pProc->GetHandleClassPtr()->GetHandleType() );
            }
        }

    pProc->GetMembers( Iterator );

    ParamNum = 0;

    ServerBufferSize = 0;
    ClientBufferSize = 0;

    fServerMustSize = FALSE;
    fClientMustSize = FALSE;

    pCCB->SetInterpreterOutSize( 0 );

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        pChild = (CG_NDR *) pParam->GetChild();

        // Ignore the following type of arguments that don't go on wire:
        //  - async handles
        //  - primitive handles
        //  
        if ( pChild->GetCGID() == ID_CG_PRIMITIVE_HDL  || ( (CG_PARAM*) pParam)->IsAsyncHandleParam() )
            continue;

        pParam->SetParamNumber( ParamNum++ );

        pCCB->SetCurrentParam( (CG_PARAM *) pParam );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        ContinueGenerationInRoot( pChild );
                               
        // A procedure's buffer size does not depend on pipe arguments
        if (pChild->IsPipeOrPipeReference())
            {
                if (pChild->GetChild()->HasAFixedBufferSize())
                    pParam->SetInterpreterMustSize(FALSE);
                else
                    // There must be a union in there somewhere 
                    pParam->SetInterpreterMustSize(TRUE);
            }
        else
            {            
            BufSize = pChild->FixedBufferSize( pCCB );

            if ( BufSize != -1 )
                {
                //
                // If either the client's or server's fixed buffer size gets too
                // big then we force the parameter to be sized.
                //
                if ( (pParam->IsParamIn() &&
                    ((ClientBufferSize + BufSize) >= 65356)) ||
                    (pParam->IsParamOut() &&
                    ((ServerBufferSize + BufSize) >= 65356)) )
                    {
                    fClientMustSize = TRUE;
                    fServerMustSize = TRUE;
                    }
                else
                    {
                    pParam->SetInterpreterMustSize( FALSE );
    
                    if ( pParam->IsParamIn() )
                        ClientBufferSize += BufSize;
                    if ( pParam->IsParamOut() )
                        ServerBufferSize += BufSize;
                    }
                }
            else
                {
                if ( pParam->IsParamIn() )
                    fClientMustSize = TRUE;
                if ( pParam->IsParamOut() )
                    fServerMustSize = TRUE;
                }
            }

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // Generate the format string for the return type if needed.
    //
    if ( pProc->GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        pProc->GetReturnType()->SetParamNumber( ParamNum++ );
        
        pChild = (CG_NDR *) pProc->GetReturnType()->GetChild();

        pCCB->SetCurrentParam( pProc->GetReturnType() );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pProc->GetReturnType() );

        ContinueGenerationInRoot( pChild );

        BufSize = pChild->FixedBufferSize( pCCB );

        if ( BufSize != -1 )
            {
            if ( (ServerBufferSize + BufSize) >= 65536 )
                {
                fServerMustSize = TRUE;
                }
            else
                {
                ServerBufferSize += BufSize;
                pProc->GetReturnType()->SetInterpreterMustSize( FALSE );
                }
            }
        else
            fServerMustSize = TRUE;

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pCCB->SetCurrentParam( 0 );

//
// REVIEW: This routine really needs to be broken up a bit
//

    // Figure out the handle type

    if ( pProc->IsObject() )
        format->Flags.HandleType = NDR64_FC_AUTO_HANDLE;
    else if ( pCCB->IsInCallback() )
        format->Flags.HandleType = NDR64_FC_CALLBACK_HANDLE;
    else if ( HU_IMPLICIT != pProc->GetHandleUsage() )
        format->Flags.HandleType = NDR64_FC_EXPLICIT_HANDLE;
    else if ( pProc->IsAutoHandle() )
        format->Flags.HandleType = NDR64_FC_AUTO_HANDLE;
    else if ( pProc->IsPrimitiveHandle() )
        format->Flags.HandleType = NDR64_FC_BIND_PRIMITIVE;
    else if ( pProc->IsGenericHandle() )
        format->Flags.HandleType = NDR64_FC_BIND_GENERIC;

    // Set the proc flags

    format->Flags.ProcType = 0;     // REVIEW: ??
    format->Flags.IsInterpreted = 1;            // REVIEW: ??
    format->Flags.IsObject = pProc->IsObject();
    format->Flags.IsAsync = pProc->HasAsyncUUID();  // REVIEW: HasAsyncHandle?
    format->Flags.IsEncode = pProc->HasEncode();
    format->Flags.IsDecode = pProc->HasDecode();
    format->Flags.UsesFullPtrPackage = pProc->HasFullPtr(); 
    format->Flags.UsesRpcSmPackage = pProc->MustInvokeRpcSSAllocate();
    format->Flags.HandlesExceptions = pProc->HasStatuses(); // REVIEW: ??
    format->Flags.UsesPipes = pProc->HasPipes();
    format->Flags.ServerMustSize = fServerMustSize;
    format->Flags.ClientMustSize = fClientMustSize;
    format->Flags.HasReturn = ( NULL != pProc->GetReturnType() );
    format->Flags.HasComplexReturn = pProc->HasComplexReturnType();
    format->Flags.ServerHasCorrelation = pProc->HasServerCorr();
    format->Flags.ClientHasCorrelation = pProc->HasClientCorr();
    format->Flags.HasNotify = pProc->HasNotify() || pProc->HasNotifyFlag();
    format->Flags.HasOtherExtensions = 0;   // Reset in GenExtendedProcInfo
    format->Flags.Reserved = 0;

    // Figure out the stack size.  Note that stack size in the 
    // NDR64_PROC_FORMAT structure is meaningless outside of ndr since it is
    // different for every processor

    format->ia64StackSize = pProc->GetTotalStackSize( pCCB );

    // Constant buffer sizes

    format->ConstantClientBufferSize = ClientBufferSize;
    format->ConstantServerBufferSize = ServerBufferSize;


    // RpcFlags
    //
    // REVIEW: Async is not an operation type!

    unsigned int opbits = pProc->GetOperationBits();

    format->RpcFlags.Idempotent       = (NDR64_UINT16) (opbits & OPERATION_IDEMPOTENT ? 1 : 0);
    format->RpcFlags.Broadcast        = (NDR64_UINT16) (opbits & OPERATION_BROADCAST  ? 1 : 0);
    format->RpcFlags.Maybe            = (NDR64_UINT16) (opbits & OPERATION_MAYBE      ? 1 : 0);
    format->RpcFlags.Message          = (NDR64_UINT16) (opbits & OPERATION_MESSAGE    ? 1 : 0);
    format->RpcFlags.InputSynchronous = (NDR64_UINT16) (opbits & OPERATION_INPUT_SYNC ? 1 : 0);
    format->RpcFlags.Asynchronous     = 0; // !!
    format->RpcFlags.Reserved1        = 0;
    format->RpcFlags.Reserved2        = 0;
    format->RpcFlags.Reserved3        = 0;

    // Miscellaneous

    format->FloatDoubleMask = pProc->GetFloatArgMask( pCCB );
    format->NumberOfParams  = ParamNum;
    format->ExtensionSize   = 0;         // Reset in GenExtendedProcInfo

    // Generate the extended proc info if any

    if ( format->Flags.HasNotify || pProc->GetHandleUsage() == HU_EXPLICIT )
        GenExtendedProcInfo( composite );

    // Now generate the parameter descriptors

    ITERATOR_INIT( Iterator );
    
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        ContinueGeneration( pParam, composite );

    if ( pProc->HasReturn() )
        ContinueGeneration( pProc->GetReturnType(), composite );

    // REVIEW: Are procs optimized?  If so be careful because the stack size
    //         field is set to 0 for all procs 
    // composite->OptimizeFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenExtendedProcInfo
//
//  Synopsis:   Generate info concerning explicit binding handles and
//              [notify] procs.
//
//  Parameters: [composite]     -- The composite to add the info to
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenExtendedProcInfo( CompositeFormatFragment *composite )
{
    // The proc info should be the first thing in the composite 
    MIDL_NDR64_PROC_FORMAT                 *procFormat;
    CG_PROC                                *procCG;
    MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION   *extension;

    extension = new MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION;

    composite->AddFragment( extension );
    
    procFormat = dynamic_cast<MIDL_NDR64_PROC_FORMAT *>(composite->GetFirstFragment());
    MIDL_ASSERT( NULL != procFormat );

    procCG = (CG_PROC *) procFormat->GetCGNode();

    procFormat->Flags.HasOtherExtensions = 1;     // REVIEW: ??

    //
    // explicit handles
    //

    if ( procCG->GetHandleUsage() == HU_EXPLICIT )
        {
            CG_HANDLE *pHandle = procCG->GetHandleClassPtr();
            CG_PARAM  *pParam  = procCG->GetHandleUsagePtr();
            CG_NDR    *pOldPlaceholder;

            pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

            pHandle->GetNdrHandleInfo( pCCB, &extension->Binding );            
            pParam->GetStackOffsets( pCCB, &extension->StackOffsets );

            pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }
    else
        {
        // No explicit handle, zero out the handle info.
        memset( &extension->Binding, 0, sizeof( extension->Binding ) );
        memset( &extension->StackOffsets, 0, sizeof( extension->StackOffsets ) );
        }

    //
    // [notify] 
    //

    if ( procFormat->Flags.HasNotify )
        extension->NotifyIndex = procCG->GetNotifyTableOffset( pCCB );
    else
        extension->NotifyIndex = 0;

    // Update the extension size field.

    procFormat->ExtensionSize = sizeof(NDR64_BIND_AND_NOTIFY_EXTENSION);
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_POINTER )
//
//  Synopsis:   Generate info for simple pointer and add fragment to
//              current composite fragment.
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_POINTER *pPointer )
{
    MIDL_NDR64_POINTER_FORMAT   *format;

    format = new MIDL_NDR64_POINTER_FORMAT( pPointer );

    // Get the type of the pointer (ref, etc) and any flags

    pPointer->GetTypeAndFlags( pCCB, format );

    CG_CLASS *pointee = pPointer->GetChild();

    if ( format->Flags & FC_SIMPLE_POINTER )
        {

        // generic handles are represented as thier underlying type and
        // otherwise pretty much ignored for our purposes.

        if ( ID_CG_GENERIC_HDL == pointee->GetCGID() )
            pointee = pointee->GetChild();

        MIDL_ASSERT( NULL != dynamic_cast<CG_BASETYPE *> ( pointee ) );
    
        }
    
    GetCurrent()->AddFragment( format );

    format->Reserved = 0;
    
    format->Pointee  = ContinueGenerationInRoot( pointee );

    GetRoot()->OptimizeFragment( format );
}


MIDL_NDR64_POINTER_FORMAT* GenNdr64Format::GenQualifiedPtrHdr( CG_QUALIFIED_POINTER *pPointer )
{
    MIDL_NDR64_POINTER_FORMAT* pHeader = new MIDL_NDR64_POINTER_FORMAT( pPointer );    
    pPointer->GetTypeAndFlags( pCCB, pHeader );

    // Always use complex pointer struct
    pHeader->Flags &= ~FC_SIMPLE_POINTER;
    pHeader->Reserved = 0;
    pHeader->Pointee = INVALID_FRAGMENT_ID;

    return pHeader;
}

MIDL_NDR64_POINTER_FORMAT* GenNdr64Format::GenQualifiedArrayPtr( CG_ARRAY *pArray )
{
    // Ref arrays do not need the pointer header.
    if ( pArray->GetPtrType() == PTR_REF )
        return NULL;

    MIDL_NDR64_POINTER_FORMAT* pFragment = new MIDL_NDR64_POINTER_FORMAT( pArray );
    switch ( pArray->GetPtrType() )
        {
        case PTR_UNKNOWN:
        case PTR_REF:
            MIDL_ASSERT(0);
            break;

        case PTR_UNIQUE:
            pFragment->FormatCode = FC64_UP;
            break;

        case PTR_FULL:
            pFragment->FormatCode = FC64_FP;
            break;
        
        default:
            MIDL_ASSERT(0);
            break;        
        }

    pFragment->Flags    = 0;
    pFragment->Reserved = 0;

    return pFragment;
}

void GenNdr64Format::Visit( CG_STRING_POINTER *pPointer )
{
    // REVIEW: This is essentially two routines distinguished by an if.
    //         Seperate them.

    MIDL_NDR64_POINTER_FORMAT* pPointerHdr = GenQualifiedPtrHdr( pPointer );
    GetCurrent()->AddFragment( pPointerHdr );
    
    FormatFragment *pStringFrag = NULL;

    if ( dynamic_cast<CG_SIZE_STRING_POINTER *>(pPointer) )
        {
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pPointer );
        FormatFragment *pFrag = GenerateCorrelationDescriptor( pConfAttribute->GetSizeIsExpr() );            
        MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT *pSizedConfFormat =
            new MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT( pPointer );
        pStringFrag = pSizedConfFormat;
        
        InitStringHeader( pPointer, &pSizedConfFormat->Header, true, true);
        pSizedConfFormat->SizeDescription = (PNDR64_FORMAT)pFrag->GetRefID();
        }
    else
        {
        MIDL_NDR64_CONFORMANT_STRING_FORMAT *pConfFormat =
            new MIDL_NDR64_CONFORMANT_STRING_FORMAT( pPointer );
        pStringFrag = pConfFormat;
        
        InitStringHeader( pPointer, &pConfFormat->Header, true, false);
        }
    GetRoot()->AddFragment( pStringFrag );
    GetRoot()->OptimizeFragment( pStringFrag );

    pPointerHdr->Pointee = pStringFrag->GetRefID();

    GetRoot()->OptimizeFragment( pPointerHdr );
}

void GenNdr64Format::GenerateNonStringQualifiedPtr( CG_QUALIFIED_POINTER *pPointer )
{
    MIDL_NDR64_POINTER_FORMAT *pPointerFrag = GenQualifiedPtrHdr( pPointer );
    GetCurrent()->AddFragment( pPointerFrag );

    FormatFragment *pArrayFrag = GenerateNonStringQualifiedArrayLayout( pPointer, GetRoot() );
    pPointerFrag->Pointee = pArrayFrag->GetRefID();
    
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenInterfacePointer
//
//  Synopsis:   Generate info for interface pointers
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenInterfacePointer( CG_POINTER *pPointer, BOOL IsConstantIID )
{
    MIDL_NDR64_POINTER_FORMAT   *format;

    format = new MIDL_NDR64_POINTER_FORMAT( pPointer );

    // Generate the pointer node

    pPointer->GetTypeAndFlags( pCCB, format );

    format->FormatCode = FC64_IP;     // GetTypeAndFlags doesn't emit FC64_IP
    format->Reserved = 0;

    GetCurrent()->AddFragment( format );

    // generate the interface type node

    if ( IsConstantIID )
        {

        CG_INTERFACE_POINTER *pInterface =
            dynamic_cast<CG_INTERFACE_POINTER*>( pPointer );

        MIDL_NDR64_CONSTANT_IID_FORMAT *iid;

        iid = new MIDL_NDR64_CONSTANT_IID_FORMAT;

        iid->FormatCode = FC64_IP;         
        iid->Flags.ConstantIID = 1;
        iid->Flags.Reserved = 0;
        iid->Reserved = 0;

        node_guid * pGuid = (node_guid *) pInterface
                                                ->GetTheInterface()
                                                ->GetAttribute( ATTR_GUID );

        pGuid->GetGuid( iid->Guid );

        format->Pointee = GetRoot()->AddFragment( iid );

        }
    else 
        {
        CG_IIDIS_INTERFACE_POINTER *piidInterface = 
            dynamic_cast<CG_IIDIS_INTERFACE_POINTER*>( pPointer );
        
        FormatFragment *pIIDExpr = GenerateCorrelationDescriptor( piidInterface->GetIIDExpr() );
        MIDL_NDR64_IID_FORMAT *iid = new MIDL_NDR64_IID_FORMAT;

        iid->FormatCode             = FC64_IP;
        iid->Flags.ConstantIID      = 0;
        iid->Flags.Reserved         = 0;
        iid->Reserved               = 0;
        iid->IIDDescriptor          = pIIDExpr->GetRefID();

        format->Pointee = GetRoot()->AddFragment( iid );
        }

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_UNION )
//
//  Synopsis:   Generate info for unions
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_UNION *pUnion )
{

    // A union is represented in the format info by a composite containing
    // the union header follow by fragments representing the arm selector

    CompositeFormatFragment *composite = new CompositeFormatFragment( pUnion );

    GetCurrent()->AddFragment( composite );

    MIDL_NDR64_NON_ENCAPSULATED_UNION *format;

    format = new MIDL_NDR64_NON_ENCAPSULATED_UNION( pUnion );

    composite->AddFragment( format );

    MIDL_ASSERT( dynamic_cast<CG_BASETYPE *> (pUnion->GetSwitchType()) );

    NDR64_FORMAT_CHAR SwitchType = (NDR64_FORMAT_CHAR)
                                   ( (CG_BASETYPE *) pUnion->GetSwitchType() )
                                            ->GetNDR64SignedFormatChar();
    
    // The alignment of a union is the max of the type alignment and the arm alignment.
    unsigned short UnionArmAlignment = pUnion->GetWireAlignment();
    unsigned short SwitchTypeAlignment =  
        ( (CG_BASETYPE*) pUnion->GetSwitchType() )->GetWireAlignment() ;
    unsigned short UnionAlignment = UnionArmAlignment > SwitchTypeAlignment ? 
                                    UnionArmAlignment : SwitchTypeAlignment;

    format->FormatCode      = FC64_NON_ENCAPSULATED_UNION;
    format->Alignment       = ConvertAlignment( UnionAlignment ); 
    format->Flags           = 0;
    format->SwitchType      = SwitchType;
    format->MemorySize      = pUnion->GetMemorySize();
    format->Reserved        = 0;

    expr_node  *pSwitchExpr = pUnion->GetNdr64SwitchIsExpr();
    
    FormatFragment* pSwitchFormat = GenerateCorrelationDescriptor( pSwitchExpr );
    format->Switch = (PNDR64_FORMAT)pSwitchFormat->GetRefID();

    GenerateUnionArmSelector( pUnion, composite );    

    GetRoot()->OptimizeFragment( composite );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_CONTEXT_HANDLE )
//
//  Synopsis:   Generate info for context handles
//
//  Notes:      This is an an abreviated version of the same information in
//              the proc descriptor.
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_CONTEXT_HANDLE *pHandle )
{
    CG_PARAM * pBindParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    CG_PROC  * pProc      = (CG_PROC *) pCCB->GetCGNodeContext();

    MIDL_NDR64_CONTEXT_HANDLE_FORMAT  *format;
    
    format = new MIDL_NDR64_CONTEXT_HANDLE_FORMAT( pHandle );

    format->FormatCode = FC64_BIND_CONTEXT;

    //
    // Register the rundown routine always, even if the context handle is
    // not used as the binding paramter.
    //
    if ( pHandle->GetHandleType()->NodeKind() == NODE_DEF )
        {
        pCCB->RegisterContextHandleType( pHandle->GetHandleType() );
        }

    // Flags

    unsigned char uFlags = pHandle->MakeExplicitHandleFlag( pBindParam );

    format->ContextFlags.CannotBeNull = pHandle->GetCannotBeNull() 
                                        || pBindParam->IsParamIn() 
                                        && !pBindParam->IsParamOut();

    format->ContextFlags.Serialize    = (NDR64_UINT8) ( pHandle->HasSerialize() ? 1 : 0 );
    format->ContextFlags.NoSerialize  = (NDR64_UINT8) ( pHandle->HasNoSerialize() ? 1 : 0 );
    format->ContextFlags.Strict       = (NDR64_UINT8) ( pHandle->HasStrict() ? 1 : 0 );
    format->ContextFlags.IsReturn     = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_RETURN ) ? 1 : 0 );
    format->ContextFlags.IsOut        = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_OUT ) ? 1 : 0 );
    format->ContextFlags.IsIn         = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_IN ) ? 1 : 0 );
    format->ContextFlags.IsViaPointer = (NDR64_UINT8) ( ( uFlags & HANDLE_PARAM_IS_VIA_PTR ) ? 1 : 0 );

    // Routine index.
    // IndexMgr keeps indexes 1..n, we use indexes 0..n-1

    format->RundownRoutineIndex = (NDR64_UINT8) 
                    ( pCCB->LookupRundownRoutine( pHandle->GetRundownRtnName() ) - 1);

    // Ordinal

    format->Ordinal = (NDR64_UINT8) pProc->GetContextHandleCount();
    pProc->SetContextHandleCount( (short) (format->Ordinal + 1) );

    GetCurrent()->AddFragment( format );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_GENERIC_HANDLE )
//
//  Synopsis:   Generate info for generic handles
//
//  Notes:      Actually generic handles are represented by thier underlying
//              type, not by any special "generic handle" type.  Therefore
//              there's nothing to generate.  We do need a place to
//              register the handle though.
//
//  Review:     Since we're not generating perhaps registering is better
//              placed in some other phase?  
//
//---------------------------------------------------------------------------
    
void GenNdr64Format::Visit( CG_GENERIC_HANDLE *pHandle )
{
    ContinueGenerationInRoot( pHandle->GetChild() );

    MIDL_ASSERT( pCCB->GetCGNodeContext()->IsProc() );

    CG_HANDLE *pBindingHandle = ((CG_PROC *)pCCB->GetCGNodeContext())
                                    ->GetHandleClassPtr();

    if ( pBindingHandle == pHandle )
        pCCB->RegisterGenericHandleType( pHandle->GetHandleType() );
}



//---------------------------------------------------------------------------
//
//  Pointer Layout Functions
//
//---------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenSimplePtrLayout( CG_STRUCT, bool, ulong *)
//
//  Synopsis:   Generate a pointer layout for a block copyable structure.
//
//---------------------------------------------------------------------------

FormatFragment * GenNdr64Format::GenSimplePtrLayout( CG_STRUCT *pStruct,
                                                     bool bGenHeaderFooter,
                                                     ulong *pPtrInstances )
{
    CompositeFormatFragment *pCompositeFormatFragment = NULL;
    CCB *pCCB = GetCCB();
    ulong NumberPointerInstances = 0;

    CG_FIELD *pOldRegionField = NULL;
    CG_NDR *pOldContext       = NULL;

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pOldRegionField = pCCB->StartRegion();
    else
        pOldContext = pCCB->SetCGNodeContext( pStruct );

    CG_ITERATOR Iterator;
    pStruct->GetMembers( Iterator );

    CG_FIELD *pField;
    ITERATOR_INIT( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {

        CG_NDR * pOldPlaceHolder = pCCB->SetLastPlaceholderClass( pField );

        CG_CLASS *pMember = (CG_NDR *) pField->GetChild();

        MIDL_ASSERT( !pMember->IsStruct() ); // Structure should have been unrolled.

        if ( pMember->IsPointer() )
            {
            
            if ( NULL == pCompositeFormatFragment )
                pCompositeFormatFragment = new CompositeFormatFragment();

            if ( bGenHeaderFooter )
                pCompositeFormatFragment->AddFragment( 
                    new MIDL_NDR64_NO_REPEAT_FORMAT() );

            pCompositeFormatFragment->AddFragment(
                    new MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT( pField->GetMemOffset() ) );

            ContinueGeneration( pMember, pCompositeFormatFragment );

            NumberPointerInstances++;
            }

        // For now, arrays do not have pointers.

        else if ( pMember->IsArray() )
            {
            FormatFragment *pPointerFragment = GenSimplePtrLayout( dynamic_cast<CG_ARRAY*>( pMember ),
                                                                   false,
                                                                   pField->GetMemOffset() );
                                                                      
            if ( NULL != pPointerFragment )
                {

                if ( NULL == pCompositeFormatFragment )
                    pCompositeFormatFragment = new CompositeFormatFragment();

                pCompositeFormatFragment->AddFragment( pPointerFragment );

                }
            }

        pCCB->SetLastPlaceholderClass( pOldPlaceHolder );
        }

    if ( ( NULL != pCompositeFormatFragment ) && 
         bGenHeaderFooter )
        {
        FormatFragment *pFormatFragment = new MIDL_NDR64_FORMAT_CHAR( FC64_END );
        pCompositeFormatFragment->AddFragment( pFormatFragment );
        }

    if ( NULL != pPtrInstances )
        {
        *pPtrInstances = NumberPointerInstances;
        }

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pCCB->EndRegion( pOldRegionField );
    else
        pCCB->SetCGNodeContext( pOldContext );

    return pCompositeFormatFragment;
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenSimplePtrLayout( CG_ARRAY, bool, ulong *)
//
//  Synopsis:   Generate a pointer layout for a block copyable structure.
//
//---------------------------------------------------------------------------
FormatFragment * GenNdr64Format::GenSimplePtrLayout( CG_NDR *pArray,
                                                     bool bGenHeaderFooter,
                                                     ulong MemoryOffset )
{

    CompositeFormatFragment *pArrayLayout = NULL;
    CG_CLASS *pChild             = pArray->GetChild();
    FormatFragment* pChildLayout = NULL;
    unsigned long NumberPointers = 0;

    // Multidimensional arrays should be bogus
    MIDL_ASSERT( !pChild->IsArray() );
    
    if ( pChild->IsPointer() )
        {

        CompositeFormatFragment *pCompositeFormatFragment = 
            new CompositeFormatFragment();
        
        pCompositeFormatFragment->AddFragment(
                new MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT( 0 ) );

        ContinueGeneration( pChild, pCompositeFormatFragment );

        pChildLayout = pCompositeFormatFragment;
        NumberPointers = 1;
        }

    else if ( pChild->IsStruct() )
        {
        pChildLayout = GenSimplePtrLayout( dynamic_cast< CG_STRUCT *>( pChild ),
                                           false,
                                           &NumberPointers );
        }

    if ( pChildLayout )
        {

        pArrayLayout = new CompositeFormatFragment();
        FormatFragment *pHeader;

        if ( dynamic_cast<CG_FIXED_ARRAY*>( pArray ) )
            {
            
            CG_FIXED_ARRAY *pFixedArray = (CG_FIXED_ARRAY*)( pArray );
            pHeader = new MIDL_NDR64_FIXED_REPEAT_FORMAT( dynamic_cast<CG_NDR*>( pChild )->GetMemorySize(),
                                                          MemoryOffset,
                                                          NumberPointers,
                                                          pFixedArray->GetNumOfElements(),
                                                          dynamic_cast<CG_NDR*>( pChild )->IsStruct() );
            }

        else 
            {
            
            pHeader = new MIDL_NDR64_REPEAT_FORMAT( dynamic_cast<CG_NDR*>( pChild )->GetMemorySize(),
                                                    MemoryOffset,
                                                    NumberPointers,
                                                    dynamic_cast< CG_NDR* >( pChild )->IsStruct() );
            }

        pArrayLayout->AddFragment( pHeader );
        pArrayLayout->AddFragment( pChildLayout );

        if ( bGenHeaderFooter )
            {
            pArrayLayout->AddFragment( new MIDL_NDR64_FORMAT_CHAR( FC64_END ) );
            }

        }

    return pArrayLayout;

}

//--------------------------------------------------------------------------
//  
//   Structure layout
//
//
//--------------------------------------------------------------------------



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenCmplxPtrLayout( CG_COMPLEX_STRUCT )
//
//  Synopsis:   Generate a pointer layout for a complex structure.
//
//---------------------------------------------------------------------------


FormatFragment * GenNdr64Format::GenCmplxPtrLayout( CG_COMPLEX_STRUCT *pStruct )
{
    CompositeFormatFragment *pCompositeFormatFragment = NULL;
    CCB *pCCB = GetCCB();

    CG_ITERATOR Iterator;
    pStruct->GetMembers( Iterator );
    MIDL_ASSERT( pCCB->GetCurrentRegionField() == NULL );

    CG_FIELD *pField;
    ITERATOR_INIT( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {

        CG_NDR * pOldPlaceHolder = pCCB->SetLastPlaceholderClass( pField );

        CG_CLASS *pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() )
            {
            
            if (NULL == pCompositeFormatFragment)
                pCompositeFormatFragment = new CompositeFormatFragment();
            
            ContinueGeneration( pMember, pCompositeFormatFragment );
            
            }

        pCCB->SetLastPlaceholderClass( pOldPlaceHolder );
        }

    return pCompositeFormatFragment;

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateSimpleStructure( CG_STRUCT, bool )
//
//  Synopsis:   Generate the format string for a simple structure.
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenerateSimpleStructure( CG_STRUCT *pStruct,
                                              bool IsConformant )
{
    // Add the fragment right away so recursive structure definitions 
    // are caught

    CompositeFormatFragment *pMainFragment 
                                    = new CompositeFormatFragment( pStruct );
    GetCurrent()->AddFragment( pMainFragment );

    CG_FIELD *pOldRegionField = NULL;
    CG_NDR   *pOldContext     = NULL;

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pOldRegionField = pCCB->StartRegion();
    else
        {
        pOldRegionField = pCCB->GetCurrentRegionField();
        pCCB->EndRegion( NULL );
        pOldContext = pCCB->SetCGNodeContext( pStruct );
        }

    FormatFragment* pMemberLayout  = NULL;
    FormatFragment* pPointerLayout = GenSimplePtrLayout( pStruct );
    
    if ( pCommand->NeedsNDR64DebugInfo() )
        pMemberLayout = GenerateStructureMemberLayout( pStruct, true );

    if ( IsConformant )
        {
        CG_CONFORMANT_STRUCT *pConfStruct = dynamic_cast<CG_CONFORMANT_STRUCT*>( pStruct );
        CG_FIELD *pConfField = dynamic_cast<CG_FIELD*>( pConfStruct->GetConformantField() );
        MIDL_ASSERT( NULL != pConfField );
        CG_ARRAY *pConfArray = dynamic_cast<CG_ARRAY*>( pConfField->GetChild() );
        MIDL_ASSERT( NULL != pConfArray );
        
        CG_NDR * pOldPlaceholder = GetCCB()->SetLastPlaceholderClass( pConfField );
        
        FormatFragment *pHeader = 
            new MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT( pConfStruct, 
                                                         NULL != pPointerLayout, 
                                                         NULL != pMemberLayout,
                                                         ContinueGenerationInRoot( pConfArray ) );
        
        pMainFragment->AddFragment( pHeader );

        GetCCB()->SetLastPlaceholderClass( pOldPlaceholder );

        }

    else
        {

        FormatFragment *pHeader = 
            new MIDL_NDR64_STRUCTURE_HEADER_FORMAT( pStruct, 
                                                    NULL != pPointerLayout, 
                                                    NULL != pMemberLayout );

        pMainFragment->AddFragment( pHeader );

        }

    if ( NULL != pPointerLayout )   pMainFragment->AddFragment( pPointerLayout );
    if ( NULL != pMemberLayout )    pMainFragment->AddFragment( pMemberLayout );

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pCCB->EndRegion( pOldRegionField );
    else
        {
        pCCB->EndRegion( pOldRegionField );
        pCCB->SetCGNodeContext( pOldContext );
        }

    GetRoot()->OptimizeFragment( pMainFragment );

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateComplexStruct( CG_STRUCT, bool )
//
//  Synopsis:   Generate the format string for a complex structure.
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenerateComplexStruct( CG_COMPLEX_STRUCT *pStruct,
                                            bool IsConformant )
{
    
    if ( GetCurrent()->HasClassFragment( pStruct ) )
        return;

    // This must be done first to handle recurion.
    CompositeFormatFragment *pMainFragment = 
        new CompositeFormatFragment( pStruct );
    GetCurrent()->AddFragment( pMainFragment );

    CG_FIELD *pOldRegionField = NULL;
    CG_NDR   *pOldContext     = NULL;

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pOldRegionField = pCCB->StartRegion();
    else
        {
        pOldRegionField = pCCB->GetCurrentRegionField();
        pCCB->EndRegion( NULL );
        pOldContext = pCCB->SetCGNodeContext( pStruct );
        }

    FormatInfoRef ArrayID = INVALID_FRAGMENT_ID;
    CG_ARRAY *pConfArray = NULL;

    if ( IsConformant )
        {
        CG_FIELD *pConfField = dynamic_cast<CG_FIELD*>( pStruct->GetConformantField() );
        MIDL_ASSERT( NULL != pConfField );
        pConfArray = dynamic_cast<CG_ARRAY*>( pConfField->GetChild() );
        MIDL_ASSERT( NULL != pConfArray );
        
        CG_NDR * pOldPlaceholder = GetCCB()->SetLastPlaceholderClass( pConfField );
        ArrayID = ContinueGenerationInRoot( pConfArray );
        GetCCB()->SetLastPlaceholderClass( pOldPlaceholder );

        }

    FormatInfoRef PointerID = INVALID_FRAGMENT_ID;
    FormatFragment *pPointerLayout = GenCmplxPtrLayout( pStruct );
    if ( NULL != pPointerLayout )
        {
        // Pointer Layout for complex struct goes in the root fragment.
        PointerID = GetRoot()->AddFragment( pPointerLayout );
        }
    
    FormatFragment* pMemberLayout  = GenerateStructureMemberLayout( pStruct, false );

    // The only difference between the member layout with debugging
    // and without debugging is that simple region become complex regions
    // with member layouts. 
    FormatInfoRef DebugPointerID    = INVALID_FRAGMENT_ID;
    FormatInfoRef DebugMemberLayoutID = INVALID_FRAGMENT_ID;
    if ( pCommand->NeedsNDR64DebugInfo() )
        {

        DebugPointerID = PointerID;
        FormatFragment *pDebugMemberLayout = GenerateStructureMemberLayout( pStruct, true );

        DebugMemberLayoutID = GetRoot()->AddFragment( pDebugMemberLayout );
        }

    
    FormatFragment* pHeader;

    if ( IsConformant )
        {
		MIDL_ASSERT( NULL != pConfArray );
        pHeader = new MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT( pStruct,
                                                                     pConfArray,
                                                                     ArrayID,
                                                                     DebugMemberLayoutID, 
                                                                     DebugPointerID,
                                                                     PointerID );
        }
    else 
        {
        pHeader = new MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT( pStruct, 
                                                                DebugMemberLayoutID,
                                                                DebugPointerID,
                                                                PointerID );
        }
    
    pMainFragment->AddFragment( pHeader );
    pMainFragment->AddFragment( pMemberLayout );

    if ( dynamic_cast<CG_REGION*>( pStruct ) )
        pCCB->EndRegion( pOldRegionField );
    else
        {
        pCCB->EndRegion( pOldRegionField );
        pCCB->SetCGNodeContext( pOldContext );
        }
}

//+--------------------------------------------------------------------------
//
//  Class:      StructureMemberGenerator
//
//  Synopsis:   This object is responsible for generating the member layout 
//              of a structure.
//
//---------------------------------------------------------------------------

class StructureMemberGenerator 
{
private:
    GenNdr64Format *pMainGenerator;
    CompositeFormatFragment *pCompositeFormatFragment;
    CG_VISITOR *pVisitor;
    bool bIsDebug;

    void StartGeneration( CG_STRUCT *pStruct ); 
    void GenerateMember( CG_CLASS *pClass ) 
       {
       pClass->Visit( pVisitor );
       }
    
public:

    static FormatFragment*  Generate( GenNdr64Format *pMainGenerator,
                                      CG_STRUCT *pStruct,
                                      bool bIsDebug )
       {
       CG_VISITOR_TEMPLATE<StructureMemberGenerator> TemplateVisitor;
       StructureMemberGenerator & Visitor = TemplateVisitor;

       Visitor.pMainGenerator              = pMainGenerator;
       Visitor.pCompositeFormatFragment    = new CompositeFormatFragment();
       Visitor.pVisitor                    = &TemplateVisitor;
       Visitor.bIsDebug                    = bIsDebug;

       Visitor.StartGeneration( pStruct );

       return Visitor.pCompositeFormatFragment;
       }
    
    // Items that get a unique member layout item.
    void Visit( CG_POINTER *pPointer) 
       {
       pPointer;
       FormatFragment *pFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FC64_POINTER );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    void Visit( CG_IGNORED_POINTER *pPointer )
       {
       pPointer;
       FormatFragment *pFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FC64_IGNORE );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    void Visit( CG_BASETYPE *pBaseType )
       {
       if ( pBaseType->GetRangeAttribute() != NULL )
           {
           // Send to generic catch all case(Embedded complex)
           Visit( (CG_CLASS*) pBaseType );
           return;
           }
       NDR64_FORMAT_CHAR FormatCode = (NDR64_FORMAT_CHAR)pBaseType->GetNDR64FormatChar();
       FormatFragment *pFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FormatCode );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    void Visit( CG_SIMPLE_REGION *pSimpleRegion )
       {

       // If this member layout is for debugging, send this 
       // to the CG_CLASS visit function to create an
       // embedded complex.
       if ( bIsDebug )
           {
           Visit( (CG_CLASS*)pSimpleRegion );
           return;
           }

       FormatFragment *pFormatFragment = 
           new MIDL_NDR64_SIMPLE_REGION_FORMAT( pSimpleRegion );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }
    
    void Visit( CG_PAD *pPad )
       {
       FormatFragment *pFormatFragment 
           = new MIDL_NDR64_BUFFER_ALIGN_FORMAT( pPad );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }

    // Do nothing for conformant arrays.  They must be at the end.
    void Visit( CG_CONFORMANT_ARRAY *pConfArray )               { pConfArray; }
    void Visit( CG_CONFORMANT_VARYING_ARRAY *pConfVaryArray )   { pConfVaryArray; }
    void Visit( CG_CONFORMANT_STRING_ARRAY *pConfStringArray )  { pConfStringArray; }

    // Catch all case. Generates embedded complex
    void Visit( CG_CLASS *pClass )
       {
       FormatInfoRef ID = pMainGenerator->ContinueGenerationInRoot( pClass );
       FormatFragment *pFormatFragment = new MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT( ID );
       pCompositeFormatFragment->AddFragment( pFormatFragment );
       }
};

void StructureMemberGenerator::StartGeneration( CG_STRUCT *pStruct )
{
    CCB *pCCB = pMainGenerator->GetCCB();
    CG_NDR * pOldPlaceholder = pCCB->GetLastPlaceholderClass();

    CG_ITERATOR         Iterator;
    pStruct->GetMembers( Iterator );

    CG_FIELD * pField;
    unsigned long BufferOffset = 0;

    ITERATOR_INIT( Iterator );
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        
        //FormatFragment *FormatFragment = NULL;
        unsigned long MemPad = pField->GetMemOffset() - BufferOffset;

        if ( MemPad != 0 )
            {

            MIDL_NDR64_MEMPAD_FORMAT *pMemPadFormat = 
                new MIDL_NDR64_MEMPAD_FORMAT( MemPad );
            pCompositeFormatFragment->AddFragment( pMemPadFormat );
            }

        BufferOffset += MemPad;

        pCCB->SetLastPlaceholderClass( pField );
        
        CG_NDR *pMember = (CG_NDR *) pField->GetChild();
        
        // Embedded unknown represent as is not allowed.
        MIDL_ASSERT( ! pField->HasEmbeddedUnknownRepAs() ); 

        GenerateMember( pMember );
        
        BufferOffset += pField->GetMemorySize();

        }

    // Account for padding at the end of the structure.

    MIDL_ASSERT( pStruct->GetMemorySize() >= BufferOffset );

    unsigned long EndingPad = pStruct->GetMemorySize() - BufferOffset;

    
    if ( EndingPad )
        {
        MIDL_NDR64_MEMPAD_FORMAT *pMemPadFormat = 
            new MIDL_NDR64_MEMPAD_FORMAT( EndingPad );
        pCompositeFormatFragment->AddFragment( pMemPadFormat );
        }

    FormatFragment* pEndFormatFragment = new MIDL_NDR64_SIMPLE_MEMBER_FORMAT( FC64_END );
    pCompositeFormatFragment->AddFragment( pEndFormatFragment );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateStructureMemberLayout( CG_STRUCT, bool )
//
//  Synopsis:   Wrapper for the member layout generator
//
//---------------------------------------------------------------------------
FormatFragment *GenNdr64Format::GenerateStructureMemberLayout( CG_STRUCT *pStruct, bool bIsDebug )
{
    return StructureMemberGenerator::Generate( this, pStruct, bIsDebug );
}



//---------------------------------------------------------------------------
//
//
//  Arrays
//
//
//
//---------------------------------------------------------------------------

FormatFragment *GenNdr64Format::GenerateArrayElementInfo( CG_CLASS *pChild )
{
    CG_NDR *pNdr = dynamic_cast<CG_NDR*>( pChild );
    MIDL_ASSERT( NULL != pNdr );
    
    MIDL_NDR64_ARRAY_ELEMENT_INFO *pElementInfo =
        new MIDL_NDR64_ARRAY_ELEMENT_INFO();

    pElementInfo->ElementMemSize = pNdr->GetMemorySize();
    pElementInfo->Element        = (PNDR64_FORMAT)ContinueGenerationInRoot( pNdr );

    return pElementInfo;
}

void GenNdr64Format::Visit( CG_FIXED_ARRAY *pArray )
{
    CompositeFormatFragment *pMainFragment = new CompositeFormatFragment( pArray );
    GetCurrent()->AddFragment( pMainFragment );

    FormatFragment *pMemberInfo    = NULL;
    FormatFragment *pPointerLayout = GenSimplePtrLayout( pArray );
    
    if ( pCommand->NeedsNDR64DebugInfo() )
        pMemberInfo    = GenerateArrayElementInfo( pArray->GetChild() );

    MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT *pArrayFormat = 
        new MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT( pArray );

    memset( (NDR64_FIX_ARRAY_HEADER_FORMAT*)pArrayFormat,
            0,
            sizeof(NDR64_FIX_ARRAY_HEADER_FORMAT*));

    pArrayFormat->FormatCode              = (NDR64_FORMAT_CHAR) FC64_FIX_ARRAY; 
    pArrayFormat->Alignment               = ConvertAlignment( pArray->GetWireAlignment() );

    pArrayFormat->Flags.HasPointerInfo    = (NULL != pPointerLayout);
    pArrayFormat->Flags.HasElementInfo    = (NULL != pMemberInfo );;

    pArrayFormat->Reserved                = 0;
    pArrayFormat->TotalSize               = pArray->GetMemorySize();

    pMainFragment->AddFragment( pArrayFormat );
    
    if ( pPointerLayout )
       pMainFragment->AddFragment( pPointerLayout );

    if ( pMemberInfo )
       pMainFragment->AddFragment( pMemberInfo );
}

void GenNdr64Format::GenerateFixBogusArrayCommon( CG_FIXED_ARRAY *pArray, bool IsFullBogus )
{
    CompositeFormatFragment *pMainFragment = new CompositeFormatFragment( pArray );
    GetCurrent()->AddFragment( pMainFragment );
        
    CG_ILANALYSIS_INFO *pAnalysisInfo = pArray->GetILAnalysisInfo();


    MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT *pHeaderFragment = 
        new MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT( pArray );

    memset( (NDR64_BOGUS_ARRAY_HEADER_FORMAT*)pHeaderFragment,
            0,
            sizeof(NDR64_BOGUS_ARRAY_HEADER_FORMAT));

    pHeaderFragment->FormatCode                 = (NDR64_FORMAT_CHAR) 
                                                  ( IsFullBogus ? FC64_FIX_BOGUS_ARRAY  :
                                                                  FC64_FIX_FORCED_BOGUS_ARRAY ); 

    pHeaderFragment->Alignment                  = ConvertAlignment( ((CG_NDR*)pArray->GetChild())
                                                                    ->GetWireAlignment() );
    pHeaderFragment->Flags.HasPointerInfo       = false;
    pHeaderFragment->Flags.HasElementInfo       = true;
    pHeaderFragment->Flags.IsArrayofStrings     = pAnalysisInfo->IsArrayofStrings();
    pHeaderFragment->Flags.IsMultiDimensional   = pAnalysisInfo->IsMultiDimensional();

    pHeaderFragment->NumberDims                 = pAnalysisInfo->GetDimensions();
    pHeaderFragment->NumberElements             = pArray->GetNumOfElements();
    pHeaderFragment->Element                    = (PNDR64_FORMAT)
                                                  ContinueGenerationInRoot( pArray->GetChild() );

    pMainFragment->AddFragment( pHeaderFragment );

}

FormatFragment * 
GenNdr64Format::GenerateNonStringQualifiedArrayLayout( CG_NDR *pNdr,
                                                       CompositeFormatFragment *pComp )
{
    CompositeFormatFragment *pMainFragment = new CompositeFormatFragment( pNdr );
    pComp->AddFragment( pMainFragment );
    
    FormatFragment *pHeaderFragment;
    FormatFragment *pPointerLayout = NULL;    
    FormatFragment *pMemberInfo = NULL;

    CG_ILANALYSIS_INFO *pAnalysisInfo = pNdr->GetILAnalysisInfo();
    
    FormatInfoRef SizeIsDescriptor      = INVALID_FRAGMENT_ID;
    FormatInfoRef OffsetOfDescriptor    = INVALID_FRAGMENT_ID;
    FormatInfoRef LengthIsDescriptor    = INVALID_FRAGMENT_ID;

    if ( pAnalysisInfo->IsConformant() )
        {
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pNdr );
        expr_node *pSizeIs     = pConfAttribute->GetSizeIsExpr();
        if ( pSizeIs != NULL )
            {
            FormatFragment *pSizeIsFrag = GenerateCorrelationDescriptor( pSizeIs );
            SizeIsDescriptor = pSizeIsFrag->GetRefID();
            }

        }
    if ( pAnalysisInfo->IsVarying() )
        {
        CG_VARY_ATTRIBUTE *pVaryAttribute = dynamic_cast<CG_VARY_ATTRIBUTE*>( pNdr );
        expr_node *pLengthIs   = pVaryAttribute->GetLengthIsExpr();
        if ( pLengthIs != NULL )
            {
            FormatFragment *pLengthIsFrag = GenerateCorrelationDescriptor( pLengthIs );
            LengthIsDescriptor = pLengthIsFrag->GetRefID();
            }

        expr_node *pFirstIs    = pVaryAttribute->GetFirstIsExpr();
        if ( pFirstIs != NULL )
            {
            FormatFragment *pOffsetOfFrag = GenerateCorrelationDescriptor( pFirstIs );
            OffsetOfDescriptor = pOffsetOfFrag->GetRefID();
            }
        }



    if ( pAnalysisInfo->IsFullBogus() || pAnalysisInfo->IsForcedBogus() )
        {
        // treat like a bogus array
        
        MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT( pNdr );
        NDR64_BOGUS_ARRAY_HEADER_FORMAT *pFixedArrayHeader = &pArrayHeader->FixedArrayFormat;
        pHeaderFragment = pArrayHeader;

        bool bIsFullBogus = pAnalysisInfo->IsFullBogus();

        NDR64_UINT32 NumberElements = 0;
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE *>( pNdr );
        
        if ( !pAnalysisInfo->IsConformant() && 
             pConfAttribute &&
             pConfAttribute->GetSizeIsExpr() &&
             pConfAttribute->GetSizeIsExpr()->IsConstant() )
            {
            NumberElements = (NDR64_UINT32)pConfAttribute->GetSizeIsExpr()->GetValue();
            }

        CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>( pNdr->GetChild() );
        memset( (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pArrayHeader,
                0,
                sizeof(NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT));

        pFixedArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) 
                                                     ( bIsFullBogus ? FC64_BOGUS_ARRAY :
                                                                      FC64_FORCED_BOGUS_ARRAY );        
        pFixedArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );

        pFixedArrayHeader->Flags.HasPointerInfo        = false;
        pFixedArrayHeader->Flags.HasElementInfo        = true;
        pFixedArrayHeader->Flags.IsArrayofStrings      = pAnalysisInfo->IsArrayofStrings();
        pFixedArrayHeader->Flags.IsMultiDimensional    = pAnalysisInfo->IsMultiDimensional();

        pFixedArrayHeader->NumberDims                  = pAnalysisInfo->GetDimensions();

        pFixedArrayHeader->NumberElements              = NumberElements;
                
        pFixedArrayHeader->Element                     = (PNDR64_FORMAT)
                                                         ContinueGenerationInRoot( pChildNdr );
        
        pArrayHeader->ConfDescription                  = (PNDR64_FORMAT)SizeIsDescriptor;
        pArrayHeader->VarDescription                   = (PNDR64_FORMAT)LengthIsDescriptor;
        pArrayHeader->OffsetDescription                = (PNDR64_FORMAT)OffsetOfDescriptor;
        
        }
    else 
        {

        pPointerLayout = GenSimplePtrLayout( pNdr );
        
        if ( pCommand->NeedsNDR64DebugInfo() )
            pMemberInfo    = GenerateArrayElementInfo( pNdr->GetChild() );

        if ( !pAnalysisInfo->IsConformant() && 
              pAnalysisInfo->IsVarying() )
            {
            
            MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT( pNdr );
            pHeaderFragment = pArrayHeader;

            CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>(pNdr->GetChild());

            memset( (NDR64_VAR_ARRAY_HEADER_FORMAT*)pArrayHeader,
                    0,
                    sizeof(NDR64_VAR_ARRAY_HEADER_FORMAT));
            
            pArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) FC64_VAR_ARRAY; 
            pArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );
            
            pArrayHeader->Flags.HasPointerInfo    = ( NULL != pPointerLayout );
            pArrayHeader->Flags.HasElementInfo    = ( NULL != pMemberInfo );

            pArrayHeader->Reserved                = 0;
            pArrayHeader->TotalSize               = pNdr->GetMemorySize();
            pArrayHeader->ElementSize             = pChildNdr->GetMemorySize();

            pArrayHeader->VarDescriptor           = (PNDR64_FORMAT)LengthIsDescriptor;

            pMemberInfo = GenerateArrayElementInfo( pNdr->GetChild() );
            }
        else if (  pAnalysisInfo->IsConformant() && 
                  !pAnalysisInfo->IsVarying() )
            {
            
            MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT( pNdr );
            pHeaderFragment = pArrayHeader;

            CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>(pNdr->GetChild());

            memset( (NDR64_CONF_ARRAY_HEADER_FORMAT*)pArrayHeader,
                    0,
                    sizeof(NDR64_CONF_ARRAY_HEADER_FORMAT));

            pArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) FC64_CONF_ARRAY; 
            pArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );
            
            pArrayHeader->Flags.HasPointerInfo    = (NULL != pPointerLayout);
            pArrayHeader->Flags.HasElementInfo    = (NULL != pMemberInfo);

            pArrayHeader->Reserved                = 0;
            pArrayHeader->ElementSize             = pChildNdr->GetMemorySize();

            pArrayHeader->ConfDescriptor          = (PNDR64_FORMAT)SizeIsDescriptor;
            
            pMemberInfo = GenerateArrayElementInfo( pNdr->GetChild() );

            }
        else if ( pAnalysisInfo->IsConformant() && 
                  pAnalysisInfo->IsVarying() )
            {
            
            MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT *pArrayHeader = 
              new MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT( pNdr );
            pHeaderFragment = pArrayHeader;

            CG_NDR *pChildNdr = dynamic_cast<CG_NDR*>(pNdr->GetChild());

            memset( (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*)pArrayHeader,
                    0,
                    sizeof(NDR64_CONF_VAR_ARRAY_HEADER_FORMAT));

            pArrayHeader->FormatCode              = (NDR64_FORMAT_CHAR) FC64_CONFVAR_ARRAY; 
            pArrayHeader->Alignment               = ConvertAlignment( pChildNdr->GetWireAlignment() );
            
            pArrayHeader->Flags.HasPointerInfo    = (NULL != pPointerLayout);
            pArrayHeader->Flags.HasElementInfo    = (NULL != pMemberInfo);

            pArrayHeader->Reserved                = 0;
            pArrayHeader->ElementSize             = pChildNdr->GetMemorySize();

            pArrayHeader->ConfDescriptor          = (PNDR64_FORMAT)SizeIsDescriptor;
            pArrayHeader->VarDescriptor           = (PNDR64_FORMAT)LengthIsDescriptor;
            

            }
        else 
            {
            // !pAnalysisInfo->IsConformant && !pAnalysisInfo->IsVarying
            MIDL_ASSERT(0);
            pHeaderFragment = NULL;
            }
        }

    pMainFragment->AddFragment( pHeaderFragment );
    if ( pPointerLayout )
        pMainFragment->AddFragment( pPointerLayout );    
    if ( pMemberInfo )
        pMainFragment->AddFragment( pMemberInfo );

    return pMainFragment;  
}

void GenNdr64Format::GenerateNonStringQualifiedArray( CG_ARRAY *pArray )
{
    CompositeFormatFragment *pContainer;
    MIDL_NDR64_POINTER_FORMAT* pPointerHdr = GenQualifiedArrayPtr( pArray );    
    if ( pPointerHdr != NULL)
        {
        GetCurrent()->AddFragment( pPointerHdr );
        pContainer = GetRoot();
        }
    else 
        pContainer = GetCurrent();

    FormatFragment *pArrayFragment = 
        GenerateNonStringQualifiedArrayLayout( pArray, pContainer );

    if ( NULL != pPointerHdr )
        {
        pPointerHdr->Pointee = pArrayFragment->GetRefID();
        }

}

void GenNdr64Format::InitStringHeader( CG_NDR *pString,
                                       NDR64_STRING_HEADER_FORMAT *pHeader,
                                       bool bIsConformant,
                                       bool bIsSized )
{
    NDR64_FORMAT_CHAR FormatCode;
    CG_BASETYPE *pBT = dynamic_cast<CG_BASETYPE*>( pString->GetChild() );

    if ( NULL != pBT )
        {             
        
        switch( pBT->GetType()->GetBasicType()->NodeKind() )
            {
            case NODE_BYTE:
            case NODE_CHAR:
                FormatCode = (NDR64_FORMAT_CHAR)
                             ( bIsConformant ? FC64_CONF_CHAR_STRING : FC64_CHAR_STRING );
                break;
            case NODE_WCHAR_T:
                FormatCode = (NDR64_FORMAT_CHAR)
                             ( bIsConformant ? FC64_CONF_WCHAR_STRING : FC64_WCHAR_STRING );
                break;
            default:
                FormatCode = (NDR64_FORMAT_CHAR)
                             ( bIsConformant ? FC64_CONF_STRUCT_STRING : FC64_STRUCT_STRING );
                break;
            }

        }
    else
        FormatCode = (NDR64_FORMAT_CHAR)
                     ( bIsConformant ? FC64_CONF_STRUCT_STRING : FC64_STRUCT_STRING );

    CG_NDR *pChildNdr           = dynamic_cast<CG_NDR*>( pString->GetChild() );
    MIDL_ASSERT( pChildNdr->GetMemorySize() <= 0xFFFF );
    NDR64_UINT16 ElementSize    = (NDR64_UINT16)pChildNdr->GetMemorySize();

    MIDL_ASSERT( (FC64_CHAR_STRING == FormatCode) ? (1 == ElementSize) : 1 );
    MIDL_ASSERT( (FC64_WCHAR_STRING == FormatCode) ? (2 == ElementSize) : 1 );

    memset( pHeader, 0, sizeof(NDR64_STRING_HEADER_FORMAT)); 

    pHeader->FormatCode    = FormatCode;
    pHeader->Flags.IsSized = bIsSized;
    pHeader->ElementSize   = ElementSize;

}



void GenNdr64Format::GenerateStringArray( CG_ARRAY *pArray,
                                          bool bIsSized )
{
    MIDL_NDR64_POINTER_FORMAT* pPointerHdr = GenQualifiedArrayPtr( pArray );    
    if ( pPointerHdr != NULL)
        GetCurrent()->AddFragment( pPointerHdr );

    FormatFragment *pStringFrag = NULL;

    if ( bIsSized )
        {
        CG_CONF_ATTRIBUTE *pConfAttribute = dynamic_cast<CG_CONF_ATTRIBUTE*>( pArray );
        expr_node *pSizeIs = pConfAttribute->GetSizeIsExpr();

        if ( NULL != pSizeIs )
            {
            FormatFragment *pFrag = GenerateCorrelationDescriptor( pConfAttribute->GetSizeIsExpr() );
    
            MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT *pSizedConfFormat =
                new MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT( pArray );
            pStringFrag = pSizedConfFormat;
            
            InitStringHeader( pArray, &pSizedConfFormat->Header, true, true);
            pSizedConfFormat->SizeDescription = (PNDR64_FORMAT)pFrag->GetRefID();
            }
        else 
            {
            MIDL_NDR64_CONFORMANT_STRING_FORMAT *pConfFormat =
                new MIDL_NDR64_CONFORMANT_STRING_FORMAT( pArray );
            pStringFrag = pConfFormat;
            
            InitStringHeader( pArray, &pConfFormat->Header, true, false);
            }
        }
    else
        {
        MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT *pNonConfFormat =
            new MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT( pArray );
        pStringFrag = pNonConfFormat;

        InitStringHeader( pArray, &pNonConfFormat->Header, false, false);
        pNonConfFormat->TotalSize = pArray->GetMemorySize();
        }

    if ( NULL != pPointerHdr )
        {
        GetRoot()->AddFragment( pStringFrag );
        pPointerHdr->Pointee = pStringFrag->GetRefID();
        }
    else
        {
        GetCurrent()->AddFragment( pStringFrag );
        }
}

class ExpressionGenerator
{
public:
    static  CompositeFormatFragment * 
        Generate( CCB *         pCCB,
                  expr_node *   pSizeExpr
                );

private:
    static void 
        GenExprPadIfNecessary( 
                 CompositeFormatFragment * FragmentList,
                 ulong *    pExprLength,
                 ulong      Align );

    static FormatFragment * 
        GenExprConstant(
                 NDR64_FORMAT_CHARACTER fc,
                 EXPR_VALUE lValue,
                 CompositeFormatFragment * FragmentList,
                 ulong * pExprLength );
    static BOOL 
        IsConstantExpr (expr_node * pExpr );
    
    static NDR64_FORMAT_CHARACTER
        GetTypeForExpression( node_skl *pType );

    static FormatFragment * 
        GenExprFormatString(
            CCB *pCCB,
            expr_node *pSizeExpr,
            CompositeFormatFragment *FragmentList,
            BOOL * pIsEarly,
            ulong * pExprLength );

    static CG_FIELD* 
        FindField( 
            node_skl * pFieldType,
            CG_STRUCT *pStruct,
            const char *pPrintPrefix,
            unsigned long *pMemOffset );

    static void 
        ComputeFieldCorrelationOffset( 
            CCB *pCCB,
            node_skl *pFieldType,
            // return parameters
            CG_FIELD **ppVariableField, // var in expression
            long *pOffset,
            BOOL *pIsEarly );
};

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenerateCorrelationDescriptor
//
//  Synopsis:   
//
//---------------------------------------------------------------------------

FormatFragment*
GenNdr64Format::GenerateCorrelationDescriptor( expr_node *pExpr )
{     
    MIDL_ASSERT(NULL != pExpr);
    
    FormatFragment *pCorrelationDescriptor =
                                ExpressionGenerator::Generate( pCCB, pExpr );
     
    GetRoot()->AddFragment( pCorrelationDescriptor );
    GetRoot()->OptimizeFragment( pCorrelationDescriptor );

    return pCorrelationDescriptor;
}

//+--------------------------------------------------------------------------
//
//  Method:     Generate
//
//  Synopsis:   generate correlation expression. 
//              
//
//---------------------------------------------------------------------------

CompositeFormatFragment *
ExpressionGenerator::Generate( CCB *         pCCB,
                               expr_node *   pSizeExpr
                               )
{
    
    if ( NULL == pSizeExpr )
        return NULL ;

#if defined(DBG)

     CG_CLASS *pAttributedNode = pCCB->GetLastPlaceholderClass( );

     MIDL_ASSERT( ( NULL != dynamic_cast<CG_PARAM*>( pAttributedNode ) ) ||
             ( NULL != dynamic_cast<CG_FIELD*>( pAttributedNode ) ) );

#endif

    BOOL                IsEarly = FALSE;
    CompositeFormatFragment * pExprComposite = new CompositeFormatFragment;
    MIDL_NDR_FORMAT_UINT32  * pFlag = new MIDL_NDR_FORMAT_UINT32;
    ulong               ulExprLength = 0;

    // correlation flags. 4 bytes.
    pExprComposite->AddFragment( pFlag );
    ulExprLength = sizeof( NDR64_UINT32 );

    // recursive code to generate the expression stack.
    GenExprFormatString( pCCB, pSizeExpr, pExprComposite, &IsEarly, &ulExprLength );   

    pFlag->Data = 0;
    if ( IsEarly )
        pFlag->Data |= FC_NDR64_EARLY_CORRELATION;
        
    return pExprComposite;
}

void 
ExpressionGenerator::GenExprPadIfNecessary( 
                 CompositeFormatFragment * FragmentList,
                 ulong *    pExprLength,
                 ulong      Align )
{
    MIDL_NDR64_EXPR_NOOP * pExprPad = NULL;
    if ( *pExprLength & ( Align - 1 ) )
        {
        // need to add padding to align next element
        pExprPad = new MIDL_NDR64_EXPR_NOOP;
        pExprPad->Size = (NDR64_UINT8) ( ( Align - 1 ) & *pExprLength );
        FragmentList->AddFragment( pExprPad );
        *pExprLength += sizeof( NDR64_EXPR_NOOP );
        }
    else
        return;
}

FormatFragment * 
ExpressionGenerator::GenExprConstant(
                 NDR64_FORMAT_CHARACTER fc,
                 EXPR_VALUE lValue,
                 CompositeFormatFragment * FragmentList,
                 ulong * pExprLength )
{
    if ( fc == FC64_INT64 )
        {
        MIDL_NDR64_EXPR_CONST64 * pFormat;

        pFormat = new MIDL_NDR64_EXPR_CONST64;
        pFormat->ConstValue = lValue;
        GenExprPadIfNecessary( FragmentList, pExprLength, 8 ); 
        FragmentList->AddFragment( pFormat );
        *pExprLength += sizeof( NDR64_EXPR_CONST64 );
        return pFormat;
        }
    else
        {
        MIDL_NDR64_EXPR_CONST32 *pFormat;

        pFormat = new MIDL_NDR64_EXPR_CONST32;
        pFormat->ConstValue = (NDR64_UINT32) lValue;
        GenExprPadIfNecessary( FragmentList, pExprLength, 4 ); 
        FragmentList->AddFragment( pFormat );
        *pExprLength += sizeof( NDR64_EXPR_CONST64 );
        return pFormat;
        }
    
}


// check if the expression (including all sub expressions ) is a constant expression
BOOL 
ExpressionGenerator::IsConstantExpr (expr_node * pExpr )
{
    if ( pExpr->IsConstant() )
        return TRUE;

    if ( pExpr->IsAVariable() )
        return FALSE;


    if ( pExpr->IsBinaryOperator() )
        {
        return IsConstantExpr( ((expr_op_binary *)pExpr)->GetLeft() ) && 
               IsConstantExpr( ((expr_op_binary *)pExpr)->GetRight() ); 
        }
    else
        {
        if ( pExpr->IsUnaryOperator() )
            {
            return IsConstantExpr( ((expr_op_unary *)pExpr)->GetLeft() );
            }
        else
            {
            MIDL_ASSERT( ((expr_ternary *)pExpr)->GetRelational() != NULL );
            return IsConstantExpr( ((expr_ternary *)pExpr)->GetLeft() ) && 
                   IsConstantExpr( ((expr_ternary *)pExpr)->GetRight() ) &&
                   IsConstantExpr( ((expr_ternary *)pExpr)->GetRelational() ) ; 
            }
        }                  
}

NDR64_FORMAT_CHARACTER
ExpressionGenerator::GetTypeForExpression(
    node_skl *pType
    )
{


    // Get the size of the type.
    unsigned long Size = pType->GetSize();

    // determine if the type is signed or unsigned.
    bool IsSigned = true;
    node_base_type *pBaseType = dynamic_cast<node_base_type*>( pType->GetBasicType() );

    if ( pBaseType )
        {
        IsSigned = !pBaseType->IsUnsigned();
        }

    switch ( Size )
        {
        case 1:
            return IsSigned ? FC64_INT8 : FC64_UINT8;
        case 2:
            return IsSigned ? FC64_INT16 : FC64_UINT16;
        case 4:
            return IsSigned ? FC64_INT32 : FC64_UINT32;
        case 8:
            return IsSigned ? FC64_INT64 : FC64_UINT64;
        default:
            RpcError( NULL, 0, EXPR_NOT_EVALUATABLE, pType->GetSymName() );
            return FC64_ZERO;  // Keep the compiler happy
        }
}

FormatFragment * 
ExpressionGenerator::GenExprFormatString(
    CCB *pCCB,
    expr_node *pSizeExpr,
    CompositeFormatFragment *FragmentList,
    BOOL * pIsEarly,
    ulong * pExprLength )
{
    node_skl *          pAttributeNodeType;
    EXPR_TOKEN          Op;
    long                Offset;

    CG_PARAM *      pParam = NULL;
    CG_NDR   *      pSwitchNode = NULL;
   
    // BUGBUG: how  to generate 32bit constant? 
    if ( IsConstantExpr( pSizeExpr ) )
        {

        // Constant expressions are always early!
        *pIsEarly = TRUE;

        return GenExprConstant( FC64_INT64, pSizeExpr->GetValue(), FragmentList, pExprLength );

        }

    if ( pSizeExpr->IsAVariable() )
        // variable
        {
        Op = FC_EXPR_VAR;
        MIDL_NDR64_EXPR_VAR * pFormat;
        
        CG_NDR * pNdr = pCCB->GetCGNodeContext();
        CG_ITERATOR     Iterator;

        pAttributeNodeType = pSizeExpr->GetType();

        if ( pNdr->IsProc() )
            // top level param
            {
            CG_PARAM*       pCurrentParam   = (CG_PARAM*) pCCB->GetCurrentParam();
            CG_PROC*        pCurrentProc    = (CG_PROC*) pNdr;
            
            *pIsEarly = TRUE;
            
            if ( ( (node_param *) pAttributeNodeType )->IsSaveForAsyncFinish() && 
                 pCurrentProc->IsFinishProc() )
                {

                // This is an async split where the finish proc is using
                // a param from the begin proc.   Since the parameter 
                // was stored on the split stack, the expression will
                // always be early correlation.   So all that is needed
                // here is to find the parameter in the begin proc.

                CG_PROC* pBeginProc = pCurrentProc->GetAsyncRelative();
                pBeginProc->GetMembers( Iterator );
                
                for (;;)
                    {
                    if (!ITERATOR_GETNEXT( Iterator, pParam ))
                        {
                        // Didn't find the parameter.  We are in trouble!
                        MIDL_ASSERT(0);
                        return NULL;
                        }

                    if ( pParam->GetType()  == pAttributeNodeType )
                        {
                        break;
                        }
                    }

                }

            else 
                {

                // Typical case of correlation in the same parameter.

                pCurrentProc->GetMembers( Iterator);

                if ( pCurrentParam->GetType() == pAttributeNodeType  )
                    *pIsEarly = FALSE;

                for(;;)
                    {

                    if (!ITERATOR_GETNEXT( Iterator, pParam ))
                        {
                        // Didn't find the parameter.  We are in trouble!
                        MIDL_ASSERT(0);
                        return NULL;
                        }

                    // If we find the current parameter before the variable,
                    // parameter, then late correlation is needed.
                    if ( pParam == pCurrentParam )
                        *pIsEarly = FALSE;

                    if ( pParam->GetType() == pAttributeNodeType )
                        break;
                    }

                }

            pSwitchNode = (CG_NDR *) pParam->GetChild();

            }
        else
            // structure /union etc.
            {
            CG_FIELD *pSwitchField;
            ComputeFieldCorrelationOffset( pCCB,
                                           pAttributeNodeType,
                                           // return parameters
                                           &pSwitchField, 
                                           &Offset,
                                           pIsEarly );
            pSwitchNode = (CG_NDR*)pSwitchField->GetChild();                
            }
            
        // Code the type of the size_is etc. expression.

        NDR64_FORMAT_CHARACTER Type = GetTypeForExpression( pSwitchNode->GetType() );
            
        pAttributeNodeType = pSizeExpr->GetType();      

        pFormat = new MIDL_NDR64_EXPR_VAR;

        pFormat->ExprType = FC_EXPR_VAR;
        pFormat->VarType = (NDR64_UINT8)Type;

        if ( pNdr->IsProc() )
            {
            CG_NDR* pOld = 0;
            BOOL IsFinish = FALSE;
            MIDL_NDR64_EXPR_OPERATOR * pAsyncOp; 
            if ( ( (node_param *) pAttributeNodeType )->IsSaveForAsyncFinish() )
                {
                pAsyncOp = new MIDL_NDR64_EXPR_OPERATOR;
                if ( ( (CG_PROC *)pNdr )->IsFinishProc() )
                    {
                    pOld = pCCB->SetCGNodeContext( ( (CG_PROC *)pNdr )->GetAsyncRelative() );
                    IsFinish = TRUE;
                    }
                    
                pAsyncOp->ExprType = (NDR64_FORMAT_CHAR) FC_EXPR_OPER;
                pAsyncOp->Operator = (NDR64_FORMAT_CHAR) OP_ASYNCSPLIT;
                FragmentList->AddFragment( pAsyncOp );
                *pExprLength += sizeof( NDR64_EXPR_OPERATOR );
                }
            pFormat->fStackOffset = TRUE;
            pFormat->ia64Offset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );

            if ( IsFinish )
                pCCB->SetCGNodeContext( pOld );               
            }
        else
            {
            // Structure
            pFormat->fStackOffset = FALSE;
            pFormat->Offset = Offset;
            }

        GenExprPadIfNecessary( FragmentList, pExprLength, 4 );
        FragmentList->AddFragment( pFormat );
        *pExprLength += sizeof( NDR64_EXPR_VAR );           

        return pFormat;
        
        }
    else
        // operator
        {
        expr_node * pLeftExpr = NULL;
        BOOL bLeftExprIsEarly = TRUE;
        
        expr_node * pRightExpr = NULL;
        BOOL bRightExprIsEarly = TRUE;

        expr_node * pRationalExpr = NULL;
        BOOL bRationalExprIsEarly = TRUE;

        MIDL_NDR64_EXPR_OPERATOR *pFormat;
        NDR64_FORMAT_CHARACTER fcKind = (NDR64_FORMAT_CHARACTER)0;

        OPERATOR Operator ;

        if ( pSizeExpr->IsBinaryOperator() )
            {
            Operator = ((expr_op_binary *)pSizeExpr)->GetOperator();
            pLeftExpr = ((expr_op_binary *)pSizeExpr)->GetLeft();
            pRightExpr = ((expr_op_binary *)pSizeExpr)->GetRight();
            }
        else
            {
            if ( pSizeExpr->IsUnaryOperator() )
                {
                Operator = ((expr_op_unary *)pSizeExpr)->GetOperator();
                pLeftExpr = ((expr_op_unary *)pSizeExpr)->GetLeft();
                }
            else
                {
                Operator = ((expr_ternary *)pSizeExpr)->GetOperator();
                pLeftExpr = ((expr_ternary *)pSizeExpr)->GetLeft();
                pRightExpr = ((expr_ternary *)pSizeExpr)->GetRight();
                pRationalExpr = ((expr_ternary *)pSizeExpr)->GetRelational();
                }
            }           

        switch ( Operator )
            {
            case OP_UNARY_SIZEOF:
                EXPR_VALUE lSize;
                lSize = pSizeExpr->GetType()->GetSize();
                
                *pIsEarly = TRUE;

                return GenExprConstant( FC64_INT8, lSize, FragmentList, pExprLength);

            case OP_UNARY_CAST:
            case OP_UNARY_INDIRECTION:
                fcKind = GetTypeForExpression( pSizeExpr->GetType() );  
                break;
            }

            pFormat = new MIDL_NDR64_EXPR_OPERATOR;

            pFormat->ExprType = (NDR64_FORMAT_CHAR) FC_EXPR_OPER;
            pFormat->Operator = (NDR64_FORMAT_CHAR) Operator;
            // This was initially 0
            pFormat->CastType = (NDR64_FORMAT_CHAR) fcKind;

            FragmentList->AddFragment( pFormat );
            *pExprLength += sizeof( NDR64_EXPR_OPERATOR );

            GenExprFormatString( pCCB, pLeftExpr, FragmentList, &bLeftExprIsEarly, pExprLength );

            if ( pRightExpr )
                GenExprFormatString( pCCB, pRightExpr, FragmentList, &bRightExprIsEarly, pExprLength );
            if  ( pRationalExpr )
                GenExprFormatString( pCCB, pRationalExpr, FragmentList, &bRationalExprIsEarly, pExprLength );
            
            //
            // An operator is early if and only if all the arguments to the
            // operator are early.
            //

            *pIsEarly = bLeftExprIsEarly && bRightExprIsEarly && bRationalExprIsEarly;

            return pFormat;
        }
}


CG_FIELD* 
ExpressionGenerator::FindField( 
    node_skl * pFieldType,
    CG_STRUCT *pStruct,
    const char *pPrintPrefix,
    unsigned long *pMemOffset )
{
   CG_ITERATOR Iterator;

   pStruct->GetMembers( Iterator );
   ITERATOR_INIT( Iterator );

   CG_FIELD *pField;
   while ( ITERATOR_GETNEXT( Iterator, pField ) )
       {

       // First check if the fields are the same type.  If they
       // are, then check the print prefixes to make sure the fields came 
       // from the same structure.

       if ( ( pField->GetType() == pFieldType ) &&
            ( strcmp( pField->GetPrintPrefix(), pPrintPrefix ) == 0 ) )
           {

           *pMemOffset = pField->GetMemOffset();
           return pField;
           }

       CG_CLASS * pChildClass = pField->GetChild();
       
       if ( pChildClass->IsStruct() )
           {
           unsigned long TempMemOffset;
           CG_STRUCT *pChildStruct = (CG_STRUCT*)pChildClass;
           
           CG_FIELD *pTempField = FindField( pFieldType,
                                             pChildStruct,
                                             pPrintPrefix,
                                             &TempMemOffset );

           if ( NULL != pTempField )
               {
               *pMemOffset = TempMemOffset + pField->GetMemOffset(); 
               return pTempField;
               }
           }
       
       }

   return NULL;
}

void 
ExpressionGenerator::ComputeFieldCorrelationOffset( 
    CCB *pCCB,
    node_skl *pFieldType,
    // return parameters
    CG_FIELD **ppVariableField, // var in expression
    long *pOffset,
    BOOL *pIsEarly )
{

    //
    // Find the fields.
    //
    CG_FIELD *pCurrentField = dynamic_cast<CG_FIELD*>( pCCB->GetLastPlaceholderClass() );
    MIDL_ASSERT( NULL != pCurrentField );
    const char *pPrintPrefix = pCurrentField->GetPrintPrefix();

    CG_STRUCT *pContext = dynamic_cast<CG_STRUCT*>( pCCB->GetCGNodeContext() );
    MIDL_ASSERT( NULL != pContext );

    unsigned long VariableOffset;
    CG_FIELD* pVariableField = FindField( pFieldType, 
                                          pContext,
                                          pPrintPrefix,
                                          &VariableOffset );
    MIDL_ASSERT( NULL != pVariableField );
    *ppVariableField = pVariableField;

    unsigned long CurrentOffset;
    CG_FIELD* pAlsoCurrentField = FindField( pCurrentField->GetType(),
                                             pContext,
                                             pPrintPrefix,
                                             &CurrentOffset );
    pAlsoCurrentField;
    MIDL_ASSERT( pAlsoCurrentField == pCurrentField );

    //
    // Determine the correlation type.
    // The correlation type is early if the variable field will
    // be completely marshalled before the current field.
    //
    BOOL bVariableIsPointer = pVariableField->GetChild()->IsPointer();
    BOOL bCurrentFieldIsPointer = pCurrentField->GetChild()->IsPointer();
    
    BOOL bOnlyVariableIsPointer = bVariableIsPointer && !bCurrentFieldIsPointer;

    *pIsEarly = ( CurrentOffset > VariableOffset ) && !bOnlyVariableIsPointer;

    // In the land of the new transfer syntax, all offsets are a positive offset
    // from the start of the stack or the last structure/region that was passed.

    CG_FIELD *pRegionField = pCCB->GetCurrentRegionField();

    // Make offset relative to start of region
    if (NULL != pRegionField)
        VariableOffset -= pRegionField->GetMemOffset(); 

    *pOffset = VariableOffset;

}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_TRANSMIT_AS )
//
//  Synopsis:   Generate info for transmit_as types
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_TRANSMIT_AS *pTransmitAs )
{
    MIDL_NDR64_TRANSMIT_AS_FORMAT *format;

    format = new MIDL_NDR64_TRANSMIT_AS_FORMAT( pTransmitAs );

    GetCurrent()->AddFragment( format );

    GenXmitOrRepAsFormat(
            pTransmitAs,
            format,
            pTransmitAs->GetPresentedType()->GetSymName(),
            pTransmitAs->GetPresentedType(),
            pTransmitAs->GetTransmittedType() );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_REPRESENT_AS )
//
//  Synopsis:   Generate info for represent_as types
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_REPRESENT_AS *pRepresentAs )
{
    MIDL_NDR64_REPRESENT_AS_FORMAT *format;

    format = new MIDL_NDR64_REPRESENT_AS_FORMAT( pRepresentAs );

    GetCurrent()->AddFragment( format );

    GenXmitOrRepAsFormat(
            pRepresentAs,
            format,
            pRepresentAs->GetRepAsTypeName(),
            pRepresentAs->GetRepAsType(),
            pRepresentAs->GetTransmittedType() );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::GenXmitOrRepAsFormat
//
//  Synopsis:   Do the actual work for transmit_as and represent_as types
//
//---------------------------------------------------------------------------

void GenNdr64Format::GenXmitOrRepAsFormat(
        CG_TYPEDEF                     *pXmitNode,
        MIDL_NDR64_TRANSMIT_AS_FORMAT  *format,
        char                           *pPresentedTypeName,
        node_skl                       *pPresentedType,
        node_skl                       *pTransmittedType )
{
    CG_NDR *pChild = (CG_NDR *) pXmitNode->GetChild();
    BOOL    fXmit  = ( NULL == dynamic_cast<CG_REPRESENT_AS *>(pXmitNode) );

    NDR64_UINT16 RoutineIndex = pXmitNode->GenXmitOrRepAsQuintuple(
                                        pCCB,
                                        fXmit,
                                        pXmitNode,
                                        pPresentedTypeName,
                                        (fXmit ? pPresentedType
                                               : pTransmittedType) );


    format->FormatCode = (NDR64_FORMAT_CHAR) ( fXmit ? FC64_TRANSMIT_AS : FC64_REPRESENT_AS );
    format->RoutineIndex = RoutineIndex;
    format->TransmittedTypeWireAlignment = (NDR64_UINT16) ( pChild->GetWireAlignment() - 1 );
            
    // REVIEW: The spec doesn't say whether "MemoryAlignment" is the 
    //         presented type or the transmitted type.  Transmitted doesn't
    //         make much sense but on the other hand presented has some
    //         alignment flags already.
    format->MemoryAlignment = pXmitNode->GetMemoryAlignment();

    if ( pPresentedType )
        format->PresentedTypeMemorySize = (NDR64_UINT16) pPresentedType->GetSize();
    else
        MIDL_ASSERT(!"BUGBUG: unknown rep/transmit_as");
        
    if ( pChild->HasAFixedBufferSize() )
        format->TransmittedTypeBufferSize = (NDR64_UINT16) pChild->GetWireSize();
    else
        format->TransmittedTypeBufferSize = 0;

    format->Flags.PresentedTypeIsArray = 0;
    format->Flags.PresentedTypeAlign4 = 0;
    format->Flags.PresentedTypeAlign8 = 0;
    format->Flags.Reserved = 0;

    if ( pPresentedType )
        {
        if ( pPresentedType->GetBasicType()->NodeKind() == NODE_ARRAY )
            format->Flags.PresentedTypeIsArray = 1;
        else
            {
            if ( pXmitNode->GetMemoryAlignment() == 4 )
                format->Flags.PresentedTypeAlign4 = 1;
            else if ( pXmitNode->GetMemoryAlignment() == 8 )
                format->Flags.PresentedTypeAlign8 = 1;
            }
        }        

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *)pChild->GetChild();

    format->TransmittedType = ContinueGenerationInRoot( pChild );
}



//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_USER_MARSHAL )
//
//  Synopsis:   Generate info for user_marshal types
//
//  REVIEW:     user_marshall and represent_as are so close to one another
//              they really should probably be merged
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_USER_MARSHAL *pUserMarshal )
{
    MIDL_NDR64_USER_MARSHAL_FORMAT *format;

    format = new MIDL_NDR64_USER_MARSHAL_FORMAT( pUserMarshal );

    GetCurrent()->AddFragment( format );
 
    CG_NDR *pChild = (CG_NDR *) pUserMarshal->GetChild();

    format->FormatCode = FC64_USER_MARSHAL;
    format->TransmittedTypeWireAlignment = (NDR64_UINT16) (pChild->GetWireAlignment() - 1);
    format->MemoryAlignment = pChild->GetMemoryAlignment();

    memset( &format->Flags, 0, sizeof(format->Flags) );
    if ( pChild->IsPointer() )
        {
        CG_POINTER *pPointer = (CG_POINTER *) pChild;
        MIDL_ASSERT( ! pPointer->IsFull() );

        if ( pPointer->IsUnique() )
            format->Flags.UniquePointer = 1;
        else if ( pPointer->IsRef() )
            format->Flags.RefPointer = 1;
        }

    format->Flags.IID = 0;      // Only used by JIT compiler
    format->Flags.Reserved = 0;

    USER_MARSHAL_CONTEXT * pUserMarshalContext = new USER_MARSHAL_CONTEXT;

    pUserMarshalContext->pTypeName = pUserMarshal->GetRepAsTypeName();
    pUserMarshalContext->pType     = pUserMarshal->GetRepAsType();

    BOOL  Added = pCCB->GetQuadrupleDictionary()->Add( pUserMarshalContext );

    format->RoutineIndex = pUserMarshalContext->Index;

    if ( !Added )
        delete pUserMarshalContext;

    if ( pUserMarshal->GetRepAsType() )
        format->UserTypeMemorySize = pUserMarshal->GetRepAsType()->GetSize();
    else
        MIDL_ASSERT( !"BUGBUG: undefined user_marshal" );

    if ( pChild->HasAFixedBufferSize() )
        format->TransmittedTypeBufferSize = pChild->GetWireSize();
    else
        format->TransmittedTypeBufferSize = 0;

    format->TransmittedType = ContinueGenerationInRoot( pChild );
}

//+--------------------------------------------------------------------------
//
//  Method:     GenNdr64Format::Visit( CG_PIPE )
//
//  Synopsis:   Generate info for [pipe] types
//
//---------------------------------------------------------------------------

void GenNdr64Format::Visit( CG_PIPE *pPipe )
{
    pCommand->GetNdrVersionControl().SetHasRawPipes();

    MIDL_NDR64_PIPE_FORMAT *format = new MIDL_NDR64_PIPE_FORMAT( pPipe );

    GetCurrent()->AddFragment( format );

    CG_NDR             *pChild     = (CG_NDR *) pPipe->GetChild();
    NDR64_UINT32        BufferSize = 0;
    node_range_attr    *range      = pPipe->GetRangeAttribute();
    NDR64_UINT32        MinValue   = 0;
    NDR64_UINT32        MaxValue   = 0;

    CG_ILANALYSIS_INFO *pAnalysisInfo = pChild->GetILAnalysisInfo();

    if ( pChild->HasAFixedBufferSize() )
        BufferSize = pChild->GetWireSize();

    if ( range )
        {
        MinValue = (NDR64_UINT32) range->GetMinExpr()->GetValue();
        MaxValue = (NDR64_UINT32) range->GetMaxExpr()->GetValue();
        }

    format->FormatCode = FC64_PIPE;
    format->Flags.Reserved1  = 0;
    format->Flags.HasRange   = (bool) ( NULL != range );
    format->Flags.BlockCopy  = !pAnalysisInfo->IsForcedBogus() && !pAnalysisInfo->IsFullBogus();
    format->Flags.Reserved2  = 0;
    format->Alignment  = (NDR64_UINT8) ( pChild->GetWireAlignment() - 1 );
    format->Reserved   = 0;
    format->Type       = ContinueGenerationInRoot( pChild );
    format->MemorySize = pChild->GetMemorySize();
    format->BufferSize = BufferSize;
    format->MinValue   = MinValue;
    format->MaxValue   = MaxValue;
}



//+--------------------------------------------------------------------------
//
//  Method:     OutputParamFlagDescription
//
//  Synopsis:   Output a description string for the ndr64 param flags 
//
//---------------------------------------------------------------------------

void OutputParamFlagDescription( CCB *pCCB, const NDR64_PARAM_FLAGS &flags )
{
    static const PNAME flag_descrip[16] = 
                    {
                    "MustSize",
                    "MustFree",
                    "pipe",
                    "[in]",
                    "[out]",
                    "IsReturn",
                    "Basetype",
                    "ByValue",
                    "SimpleRef",
                    "DontFreeInst",
                    "AsyncFinish",
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "UseCache"
                    };

    pCCB->GetStream()->Write( "    " );
    OutputFlagDescriptions( pCCB->GetStream(), &flags, sizeof(flags), flag_descrip );
}



//+--------------------------------------------------------------------------
//
//  Method:     OutputFlagDescription
//
//  Synopsis:   Given a set of flags and a description for each flags, 
//              output the corresponding description for flag that is set.
//              usused flags can be marked with a NULL description.
//
//  Notes:      Assumes little-endian memory layout!
//
//---------------------------------------------------------------------------

void OutputFlagDescriptions(
        ISTREAM     *stream, 
        const void  *pvFlags, 
        int          bytes, 
        const PNAME *description)
{
    unsigned char *flags = (unsigned char *) pvFlags;
    bool first = true;

    stream->Write( "/*");

    for (int i = 0; i < (bytes * 8); i++)
        {
        if (    ( NULL == description[i] )
             || ( 0 == ( flags[i / 8] & ( 1 << (i % 8) ) ) ) )
            {
            continue;
            }

        if ( !first )
            stream->Write( "," );

        first = false;

        stream->Write( " " );
        stream->Write( description[i] );
        }

    stream->Write( " */" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ndrcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    ndrcls.cxx

 Abstract:

    Routines for the ndrcls code generation class.

 Notes:


 History:

    Aug-31-1993     VibhasC     Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/

expr_node *
CG_NDR::PresentedLengthExpression( CCB* )
    {
    expr_sizeof *   pExpr   = new expr_sizeof( GetType() );
    return pExpr;
    }

expr_node *
CG_NDR::PresentedSizeExpression( CCB* )
    {
    expr_sizeof *   pExpr   = new expr_sizeof( GetType() );
    return pExpr;
    }
expr_node *
CG_NDR::PresentedFirstExpression( CCB* )
    {
    return new expr_constant(0L);
    }

    
/****************************************************************************
    utility functions
 ****************************************************************************/
CG_STATUS
CG_NDR::SizeAnalysis( ANALYSIS_INFO * pAna )
    {
    pAna;
    return CG_OK;
    }
CG_STATUS
CG_NDR::MarshallAnalysis( ANALYSIS_INFO * pAna )
    {
    pAna;
    return CG_OK;
    }

node_skl    *
CG_NDR::GetBasicType()
    {
    node_skl    *   pT  = GetType();

    switch (pT->NodeKind())
        {
        case NODE_ID:
        case NODE_FIELD:
        case NODE_PARAM:
        case NODE_DEF:
            return pT->GetBasicType();
        }
    return pT;
    }

CG_STATUS
CG_NDR::RefCheckAnalysis(
    ANALYSIS_INFO * pAna )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->RefCheckAnalysis( pAna );

    return CG_OK;
    }

CG_STATUS
CG_NDR::InLocalAnalysis(
    ANALYSIS_INFO * pAna )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->InLocalAnalysis( pAna );

    return CG_OK;
    }

CG_STATUS
CG_NDR::S_GenInitInLocals(
    CCB * pCCB )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->S_GenInitInLocals( pCCB );

    return CG_OK;
    }

CG_STATUS
CG_NDR::GenRefChecks(
    CCB * pCCB )
    {
    CG_NDR * pC = (CG_NDR *)GetChild();

    if( pC )
        pC->GenRefChecks( pCCB );

    return CG_OK;
    }

extern CMD_ARG * pCommand;

void 
CG_NDR::GetNdrParamAttributes( CCB *pCCB, PARAM_ATTRIBUTES *attributes)
{
    CG_PARAM *          pParam;
    CG_NDR *            pChild;
    CG_PROC *           pProc;

    pChild = (CG_NDR *) GetChild();

    if ( pChild && (pChild->GetCGID() == ID_CG_GENERIC_HDL) )
        pChild = (CG_NDR *) pChild->GetChild();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    if ( IsPipeOrPipeReference() )
        {
        // Pipe parameters are never sized.

        attributes->MustSize = 0;
        }
    else
        attributes->MustSize = (unsigned short) pParam->GetInterpreterMustSize();

    attributes->IsIn = (unsigned short) pParam->IsParamIn();
    attributes->IsOut = (unsigned short) pParam->IsParamOut();
    attributes->IsReturn = ( pParam->GetCGID() == ID_CG_RETURN )
                           || ( pProc->HasComplexReturnType() 
                                && NULL == pParam->GetSibling() );
    attributes->IsPartialIgnore = pParam->IsParamPartialIgnore();
    attributes->IsForceAllocate = pParam->IsForceAllocate();
    attributes->IsBasetype = 0;
    // SAFEARRAY(FOO) is being generated as ID_CG_SAFEARRAY. It's in fact user 
    // marshal on the wire.
    attributes->IsByValue = 
            IsStruct() || 
            IsUnion() ||
            ( GetCGID() == ID_CG_TRANSMIT_AS )  ||
            ( GetCGID() == ID_CG_REPRESENT_AS ) ||
            ( GetCGID() == ID_CG_USER_MARSHAL ) ||
            ( GetCGID() == ID_CG_SAFEARRAY )    ||
            ( GetCGID() == ID_CG_CS_TAG ) ;
    attributes->IsSimpleRef = 
            (pParam->GetCGID() != ID_CG_RETURN) &&
            IsPointer() && 
            ((CG_POINTER *)this)->IsBasicRefPointer();
    attributes->IsDontCallFreeInst = (unsigned short) pParam->GetDontCallFreeInst();
    attributes->IsPipe = (unsigned short) IsPipeOrPipeReference();
    attributes->SaveForAsyncFinish = (unsigned short) pParam->IsSaveForAsyncFinish();

    if ( (attributes->IsPipe) || (GetCGID() == ID_CG_CONTEXT_HDL) ||
         (IsPointer() && pChild && (pChild->GetCGID() == ID_CG_CONTEXT_HDL)))
        attributes->MustFree = 0;
    else
        attributes->MustFree = 1;

    attributes->ServerAllocSize = 0;

    if ( GetCGID() == ID_CG_PTR ) 
        {
        long Size = 0;

        (void) 
        ((CG_POINTER *)this)->InterpreterAllocatesOnStack( pCCB, 
                                                           pParam, 
                                                           &Size );

        attributes->ServerAllocSize = unsigned short(Size / 8);
        }

    //
    // Now make a final check for a simple ref pointer to a basetype and for 
    // a ref pointer to pointer.
    //
    // We mark pointers to basetypes as being both a basetype and a simple 
    // ref pointer.  Kind of an anomoly, but it works out well in the 
    // interpreter.  
    //
    // For both of these cases the pointer must have no allocate attributes
    // and can not be a return value.
    //
    if ( 
         IsPointer() && 
         (((CG_POINTER *)this)->GetPtrType() == PTR_REF) &&

         ! IS_ALLOCATE( ((CG_POINTER *)this)->GetAllocateDetails(), 
                        ALLOCATE_ALL_NODES ) &&
         ! IS_ALLOCATE( ((CG_POINTER *)this)->GetAllocateDetails(), 
                        ALLOCATE_DONT_FREE ) &&

         (pParam->GetCGID() != ID_CG_RETURN) 
       )
        {
        //
        // Now make sure it's a pointer to basetype and that it is either 
        // [in] or [in,out] (in which case we use the buffer to hold it) or 
        // that it is [out] and there is room for it on the interpreter's 
        // stack.  We don't mark enum16s as SimpleRef-Basetype because of
        // their special handling (i.e. wire size != memory size).
        //
        if ( ((CG_POINTER *)this)->IsPointerToBaseType() && 
             ( pParam->IsParamIn() ||
               (((CG_POINTER *)this)->GetFormatAttr() & FC_ALLOCED_ON_STACK) ) )
            {
            if ( ((CG_BASETYPE *)pChild)->GetFormatChar() != FC_ENUM16 )
                {
                attributes->IsBasetype = 1;
                attributes->IsSimpleRef = 1;
                }
            attributes->MustFree = 0;
            }

        // we give a warning here because pointer to range doesn't work on 
        // w2k sp2 and xp 2600 and before. There is a NDR bug that doesn't
        // allocate memory for poitner to range case.
        if (pChild && 
             pChild->IsSimpleType() && 
             ((CG_BASETYPE *)pChild)->GetRangeAttribute() != NULL  &&
             !pCommand->IsNDR64Run()  )
                    {
                    RpcError( NULL, 0,  TOP_LEVEL_POINTER_RANGE, pParam->GetSymName() );
                    }

        }
}

void
CG_NDR::GenNdrParamDescription( CCB * pCCB )
{
    FORMAT_STRING *     pProcFormatString;
    PARAM_ATTRIBUTES    Attributes;
    long                FormatStringOffset;
    CG_PARAM *          pParam;
    CG_NDR *            pChild;

    pChild = (CG_NDR *) GetChild();

    if ( pChild && (pChild->GetCGID() == ID_CG_GENERIC_HDL) )
        pChild = (CG_NDR *) pChild->GetChild();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();
    
    pProcFormatString = pCCB->GetProcFormatString();
    
    // Attributes.

    GetNdrParamAttributes( pCCB, &Attributes );

    pProcFormatString->PushParamFlagsShort( *((short *)&Attributes) );

    // Stack offset as number of ints.
    pProcFormatString->PushUShortStackOffsetOrSize(
            pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    //
    // If we found a pointer to a basetype, make sure and emit the basetype's
    // param format.
    //
    if ( Attributes.IsSimpleRef && Attributes.IsBasetype )
        {
        pProcFormatString->PushFormatChar( 
                ((CG_BASETYPE *)pChild)->GetFormatChar() );
        pProcFormatString->PushByte( 0 );
        return;
        }

    if ( Attributes.IsSimpleRef ) 
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) this;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    FormatStringOffset = GetFormatStringOffset();
                else
                    FormatStringOffset = pPointer->GetFormatStringOffset() + 2;
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    FormatStringOffset = GetFormatStringOffset();
                else
                    FormatStringOffset = pPointer->GetPointeeFormatStringOffset();
                break;

            case ID_CG_STRUCT_STRING_PTR :
                FormatStringOffset = GetFormatStringOffset();
                break;

            default :
                FormatStringOffset = pPointer->GetPointeeFormatStringOffset();
                break;
            }
        }
    else
        {
        FormatStringOffset = GetFormatStringOffset();
        }

    //
    // Push the offset in the type format string to the param's description.
    //
    pProcFormatString->PushShortTypeOffset( FormatStringOffset );
}

void
CG_NDR::GenNdrParamDescriptionOld( CCB * pCCB )
{
    FORMAT_STRING * pProcFormatString;
    CG_PARAM *      pParam;
    long            StackSize;
    long            StackElem;

    pProcFormatString = pCCB->GetProcFormatString();

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    if ( pCommand->Is64BitEnv() )
        StackElem = 8;
    else
        StackElem = 4;
    
    StackSize = pParam->GetStackSize();

    StackSize = (StackSize + StackElem - 1) & ~ (StackElem - 1);

    pProcFormatString->PushSmallStackSize( (char) (StackSize / StackElem) );

    //
    // Push the offset in the type format string to the param's description.
    //
    pProcFormatString->PushShortTypeOffset( GetFormatStringOffset() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\netmon.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1998-2000 Microsoft Corporation

 Module Name:

    netmon.cxx

 Abstract:

    Generate C code for the stub DLL's used for Netmon debugging

 Notes:

    Two files are generated by this file:  
        xxx_netmon_stub.c
        xxx_netmob_stub_obj.c


 History:

    - Created 7/28/98 by Max Attar Feingold
 ----------------------------------------------------------------------------*/

#include "becls.hxx"

// Stub version
#define NETMON_STUB_VERSION "(float) 1.0"

#pragma hdrstop

CG_STATUS
CG_NETMONSTUB_FILE::GenCode(
    CCB     *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the Netmon stub file for classic and object interfaces

 Arguments:

    pCCB    - The code gen controller block.
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
{

    ISTREAM             Stream( GetFileName(), 4 );
    ISTREAM *           pStream = pCCB->SetStream( &Stream, this );

    m_pCCB = pCCB;
    m_pStream = pStream;

    // Scan for interfaces of the appropriate type
    ScanInterfaces();
    if (!m_bDoObject && !m_bClassic ||
        m_bDoObject && !m_bObject) {
        m_pStream->Close();
        return CG_OK;
    }

    // If m_bDoObject is TRUE, then we're producing a stub file for object interfaces;
    // otherwise, we're doing classic interfaces
    if (m_bDoObject) {
        EmitFileHeadingBlock (pCCB, "code for an object interface Netmon stub DLL", 
            "This file should be compiled as source for a DLL, linked with rpcrt4.lib");
    } else {
        EmitFileHeadingBlock (pCCB, "code for a classic interface Netmon stub DLL", 
            "This file should be compiled as source for a DLL, linked with rpcrt4.lib");
    }

    // Write standard include files
    EmitStandardIncludes();

    // Write local include files
    EmitLocalIncludes();

    // Write definitions (#defines and variables needed by the code)
    EmitDefinitions();

    if (m_bDoObject) {
        
        // We seem to need this to solve a link error
        OpenComment();
        EmitComment ("This implementation is needed to solve a link error");
        CloseComment();
        pStream->NewLine();
        pStream->Write ("ULONG STDMETHODCALLTYPE CStdStubBuffer_Release "\
            "(IRpcStubBuffer *This) { ULONG u = 0; return u; }");
        
        // Write the special data for object interfaces
        EmitObjectInterfaceData();
    }

    // Write the server and client debug procedures for each interface
    EmitDebugProcedures();

    // Write the data tables
    EmitDataTables();

    // Close the header block
    EmitFileClosingBlock( pCCB );

    // Close the stream
    pStream->Close();

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Descriptions:

    Determine which types of interfaces (object or classic) we have and how many,
    adding the names to the interface table

 Arguments:
    
 Return Value:

    TRUE if yes
    FALSE if no
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::ScanInterfaces() {
    
    CG_ITERATOR I;
    CG_NDR * pCG;
    
    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) )
    {
		// We check GetChild()'s non-nullness here and elsewhere in the code because
		// there are object interfaces without children that cause problems, such as IUnknown
        if (pCG->GetChild()) {
            switch(pCG->GetCGID())
            {
            case ID_CG_INTERFACE:
                m_bClassic = TRUE;
                m_lNumClassicInterfaces ++;
                m_itInterfaceTable.AddInterface (((CG_INTERFACE*)pCG)->GetInterfaceName());
                break;
                
            case ID_CG_OBJECT_INTERFACE:
                m_bObject = TRUE;
                m_lNumObjectInterfaces ++;
                m_itInterfaceTable.AddInterface (((CG_INTERFACE*)pCG)->GetInterfaceName());
                break;
                
            default:
                break;
            }
        }
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Descriptions:

    Respectively,
    -Open a comment block
    -Write comments
    -Close a comment block

 Arguments:
    
      pszString is the comment that should be emitted

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::OpenComment() {
    
    m_pStream->NewLine();
    m_pStream->NewLine();
    m_pStream->Write ("/*");

    return CG_OK;
}

CG_STATUS CG_NETMONSTUB_FILE::EmitComment (char* pszString) {
    
    m_pStream->NewLine();
    m_pStream->Write (" * ");
    m_pStream->Write (pszString);

    return CG_OK;
}

CG_STATUS CG_NETMONSTUB_FILE::CloseComment() {
    
    m_pStream->NewLine();
    m_pStream->Write (" */");

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the standard includes for the netmon stub dll

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitStandardIncludes() {

	m_pStream->NewLine();
    m_pStream->Write ("#include <stdio.h>");

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the local includes for the netmon stub dll.

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

    Local includes are the proxy and iid files for object interfaces
    and the stub file for classic interfaces.

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitLocalIncludes() {

    m_pStream->NewLine(2);
    
    // This is defined to avoid target errors
    m_pStream->Write ("#define _WIN32_DCOM");
    
    // Write includes
    m_pStream->NewLine();
    if (m_bDoObject) {
        m_pStream->Write ("#include \"");
        m_pStream->Write (pCommand->GetProxyFName());
        m_pStream->Write ("\"");
        m_pStream->NewLine();
        m_pStream->Write ("#include \"");
        m_pStream->Write (pCommand->GetIIDFName());
        m_pStream->Write ("\"");
        m_pStream->NewLine();
    } else {
        m_pStream->Write ("#include \"");
        m_pStream->Write (pCommand->GetSstubFName());
        m_pStream->Write ("\"");
        m_pStream->NewLine();
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate any definitions needed by the netmon stub dll.

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
const char* ppszIncludeBlock[] = {
    "#define DLL_EXPORT_PROC(x) __declspec(dllexport) GLOBAL_INTERFACE_DATA* GetGlobalInterfaceData__##x () { return &GlobalInterfaceData__##x ; }",
    "#define NetmonStubAllocate(x) malloc(x)",
    "#define Debug() *pNull = 0",
    "static DWORD* pNull = NULL;",
    NULL
};

const char* ppszGlobalInterfaceDataStructure[] = {
	"float Version;",
    "char* InterfaceName;",
    "DWORD ProcFormatStringSize;",
    "DWORD NumProcedures;",
    "char** ProcedureNames;",
    "SERVER_ROUTINE* ServerRoutineTable;",
    "SERVER_ROUTINE* ClientRoutineTable;",
    "RPC_SERVER_INTERFACE* RpcServerInterface;",
    "void* DebugArgumentBuffer;",
    NULL
};

CG_STATUS CG_NETMONSTUB_FILE::EmitDefinitions() {

    if (!m_bDoObject) {
        m_pStream->NewLine();
        m_pStream->Write ("#pragma warning (disable : 4700) /* No warnings from the "\
			"use of uninitialized variables */");
        m_pStream->NewLine();
    }
    m_pStream->WriteBlock (ppszIncludeBlock);

    OpenComment();
    EmitComment ("Structure used to encapsulate all relevant interface information");
    CloseComment();

    m_pStream->NewLine(2);
    m_pStream->Write ("typedef struct _GLOBAL_INTERFACE_DATA {");
    Out_IndentInc( m_pCCB );
    m_pStream->WriteBlock (ppszGlobalInterfaceDataStructure);
    Out_IndentDec( m_pCCB );
    m_pStream->NewLine();
    m_pStream->Write ("} GLOBAL_INTERFACE_DATA;");

    OpenComment();
    EmitComment ("Function used to view unmarshalled argument buffers");
    CloseComment();
    m_pStream->NewLine();
    m_pStream->Write ("static void DebugArgumentBuffer (BYTE* ArgumentBuffer, DWORD BufferSize) "\
        "{ Debug(); }");

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the data used specifically by object interfaces.

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitObjectInterfaceData() {

    CG_ITERATOR I;
    CG_NDR * pCG;

    OpenComment();
    EmitComment ("Data used specifically by object interfaces");
    CloseComment();
    
    // Loop through all interfaces
    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {
        
        if (pCG->GetChild()) {
            
            switch(pCG->GetCGID()) {

            case ID_CG_OBJECT_INTERFACE:
                
                // Emit the object interface RPC_SERVER_INTERFACE structures
                OpenComment();
                EmitComment ("RPC_SERVER_INTERFACE structure for object interface ");
                m_pStream->Write (pCG->GetSymName());
                CloseComment();
                
                EmitRPCServerInterface ((CG_INTERFACE*) pCG);   
                
                break;
                
            default:
                break;
            }
        }
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate an RPC_SERVER_INTERFACE structure for the given interface

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:
 
   Most of the code was taken from misccls.cxx -> CG_INTERFACE::GenServerStub

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitRPCServerInterface (CG_INTERFACE* pCG) {
    
    GUID_STRS TransferSyntaxGuid( TRANSFER_SYNTAX_GUID_STR_1,
                                  TRANSFER_SYNTAX_GUID_STR_2,
                                  TRANSFER_SYNTAX_GUID_STR_3,
                                  TRANSFER_SYNTAX_GUID_STR_4,
                                  TRANSFER_SYNTAX_GUID_STR_5);
    GUID_STRS GuidStrs;
    unsigned short M, m;
    char Buffer[ _MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1 ];
    long ProtSeqEPCount = 0;
    ITERATOR * pProtSeqIterator;
    
    GuidStrs = pCG->GetGuidStrs();
    
    m_pCCB->SetInterfaceCG (pCG);
    m_pCCB->SetInterfaceName (pCG->GetInterfaceName());
    m_pCCB->GetVersion( &M,&m );
    
    sprintf( Buffer,
            "&%s_%s_DispatchTable",
            pCG->GetInterfaceName(),
            m_pCCB->GenMangledName()
            );

    if ( ( pProtSeqIterator = pCG->GetProtSeqEps() ) != 0 ) 
        {
            ProtSeqEPCount = ITERATOR_GETCOUNT( *pProtSeqIterator );
            Out_EP_Info( m_pCCB, pProtSeqIterator );
        }

    Out_IFInfo( m_pCCB,                         // controller block.
                RPC_S_INT_INFO_TYPE_NAME,       // interface info type name.
                RPC_S_INT_INFO_STRUCT_NAME,     // variable name.
                SIZEOF_RPC_SERVER_INTERFACE,    // string speicifying size.
                GuidStrs,                       // Guid specified in idl
                M,                              // user specified major version
                m,                              // user specified minor version
//                TransferSyntaxGuid,             // ndr identifying guid.
//                NDR_UUID_MAJOR_VERSION,         // ndr's version
//                NDR_UUID_MINOR_VERSION,
                NULL, //Buffer,
                ProtSeqEPCount,                 // if this is 0, then the next
                // 2 fields are ignored by the call.
                PROTSEQ_EP_TYPE_NAME,           // RPC_PROTSEQ_ENDPOINT
                PROTSEQ_EP_VAR_NAME,            // ___RpcProtSeqEndpoint
                m_pCCB->IsNoDefaultEpv(),
                1,
                pCG->HasPipes()
                );

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the debug procedures for all interfaces

 Arguments:
    
 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitDebugProcedures() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    
    CG_PROC * pProc;
    CG_INTERFACE * pInt;

    ID_CG idCg;

    ITERATOR IProc;

    char* pszInterfaceName, * pszLastInterfaceName, * pszOurInterfaceName;

    // Write midl malloc and free if we're writing a classic interface stub
    if (!m_bDoObject) {
        OpenComment();
        EmitComment ("Procedures used by the runtime to allocate and free memory");
        CloseComment();

        m_pStream->NewLine(2);
        m_pStream->Write (
            "static void * __RPC_API midl_user_allocate(size_t len) { return NetmonStubAllocate(len); }");
        m_pStream->NewLine();
        m_pStream->Write (
            "static void __RPC_API midl_user_free(void * ptr) { free(ptr); }");
    }

    OpenComment();
    EmitComment ("Implementation of debug server and client functions for all ");
    if (m_bDoObject) {
        m_pStream->Write ("object");
    } else {
        m_pStream->Write ("classic");
    }
    m_pStream->Write (" interfaces");
    CloseComment();

    // Loop through all interfaces
    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) )
    {
        if (pCG->GetChild()) {
            
            pInt = (CG_INTERFACE*) pCG;
            idCg = pCG->GetCGID();
            
            switch(idCg) {
                
            case ID_CG_INTERFACE:
                
                if (!m_bDoObject) {
                    
                    // Loop through all member functions
                    pInt->GetAllMemberFunctions( IProc );
                    while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                        
                        EmitServerClientDebugProcedure (pProc, FALSE);
                        
                        // Emit the procedure as is (to avoid link errors)
                        m_pStream->NewLine(2);
                        m_pStream->Write ("static");
                        Out_ClientProcedureProlog( m_pCCB, pProc->GetType() );
                        Out_IndentInc( m_pCCB );
                        
                        // Return a variable of the appropriate return value
                        if (((node_proc*) pProc->GetType())->HasReturn()) {
                            m_pStream->Spaces( STANDARD_STUB_TAB );
                            m_pStream->Write( pProc->GetReturnType()->GetSymName() );
                            m_pStream->Write(" RetVal;");
                            m_pStream->NewLine();
                            m_pStream->Write( "return RetVal;" );
                        }
                        
                        // Close the procedure
                        Out_IndentDec( m_pCCB );
                        Out_ProcClosingBrace( m_pCCB );
                    }
                }
                
                break;
                
            case ID_CG_OBJECT_INTERFACE:
                
                if (m_bDoObject) {
                    
                    pszOurInterfaceName = pInt->GetInterfaceName();
                    pszLastInterfaceName = NULL;

                    // Loop through all member functions
                    pInt->GetAllMemberFunctions ( IProc);
                    while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                        
                        // Get the procedure's real interface name
                        pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                        
                        // Write the function if:
                        // a) We're its real interface.
                        // b) The interface hasn't been used yet and it's not IUnknown
                        // c) The interface name is the same as the last one we used
                        // (so it's OK to use it again)
                        if (strcmp (pszInterfaceName, pszOurInterfaceName) == 0 ||
                            (!m_itOutputInterfaceTable.FindInterface (pszInterfaceName) &&
                             strcmp (pszInterfaceName, "IUnknown") != 0) ||
                            (pszLastInterfaceName != NULL &&
                             strcmp (pszInterfaceName, pszLastInterfaceName) == 0)
                             ) {
                            
                            // Write the server and client debug procedures
                            EmitServerClientDebugProcedure (pProc, TRUE);

                            // Add the interface name to the table of used interfaces
                            m_itOutputInterfaceTable.AddInterface (pszInterfaceName);

                            // Record the last interface name used
                            pszLastInterfaceName = pszInterfaceName;
                        }
                    }
                }
                
                break;
                
            default:
                break;
            }
        }
    }

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate server, client and link stub procedures for a given procedure

 Arguments:
    
      pProc -> The procedure to be processed
      bIsObject ->  TRUE if the procedure belongs to an object interface
                    FALSE otherwise
 Return Value:

    CG_OK   if all is well.
        
 Notes:
 
   This function is long and ugly

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitServerClientDebugProcedure (CG_PROC* pProc, BOOL bIsObject) {

    PNAME pszProcName, pszNewProcName;

    node_proc * pNodeProc = ((node_proc*) pProc->GetType());
    node_param * pRetValParam, * pThisParam, * pParam;
    node_skl * pOldRetType;
    node_base_type * pVoidBaseType;
    type_node_list ITypeNodeList;
    
    short i, siNumArgs;
    PNAME* ppszOldArgName;
    PNAME* ppszNewArgName;
    node_base_attr * pNodeAttribIn, * pNodeAttribOut;

    BOOL bHasReturn = pNodeProc->HasReturn();

    // Get the procedure name
    pszProcName = pProc->GetSymName();
                
    // Rename the procedure to Server__InterfaceName__ProcName
    pszNewProcName = new char [strlen (pProc->GetInterfaceName()) + 
        strlen (pszProcName) + 11];
    sprintf ( pszNewProcName, "Server__%s__%s", pProc->GetInterfaceName(), pszProcName );
    pNodeProc->SetSymName ( pszNewProcName );
                
    // Set void type
    pVoidBaseType = new node_base_type( NODE_VOID, ATTR_BASE );
    pVoidBaseType->SetSymName( "void" );
    pOldRetType = pNodeProc->GetChild();
    pNodeProc->SetChild( pVoidBaseType );
                
    // Rename the arguments to IN__Name, OUT__Name or IN_OUT__name
    i = 0;
    siNumArgs = pNodeProc->GetNumberOfArguments();
        
    ppszOldArgName = new PNAME [siNumArgs];
    ppszNewArgName = new PNAME [siNumArgs];
                
    pNodeProc->GetParameterList (&ITypeNodeList);
    while( ITERATOR_GETNEXT( ITypeNodeList, pParam ) ) {
                
        MIDL_ASSERT (i < siNumArgs);
                    
        ppszOldArgName[i] = pParam->GetSymName();
        ppszNewArgName[i] = new char [strlen (ppszOldArgName[i]) + 10];
                    
        if ((pNodeAttribIn = pParam->GetAttribute (ATTR_IN)) && 
            (pNodeAttribOut = pParam->GetAttribute (ATTR_OUT))) {
            sprintf (ppszNewArgName[i], "IN_OUT__%s", ppszOldArgName[i]);
        } else {
                        
            if (pNodeAttribIn) {
                sprintf (ppszNewArgName[i], "IN__%s", ppszOldArgName[i]);
            } else {
                sprintf (ppszNewArgName[i], "OUT__%s", ppszOldArgName[i]);
            }
        }
        pParam->SetSymName (ppszNewArgName[i]);
        i ++;           

        delete []ppszOldArgName;
        delete []ppszNewArgName;
    }
    
    // If proc belongs to an object interface, add the 'this' pointer
    if (bIsObject) {
        pThisParam = new node_param();
        pThisParam->SetAttribute (ATTR_IN);
        pThisParam->SetSymName ("this");
        pThisParam->SetBasicType( (node_skl *) new node_def( "void*" ));
        pThisParam->SetEdgeType( EDGE_USE );
                    
        pNodeProc->AddFirstMember (pThisParam);
    }

    // Emit the server procedure
    m_pStream->NewLine(2);
    m_pStream->Write ("static");
    Out_ClientProcedureProlog( m_pCCB, pNodeProc );
    Out_IndentInc( m_pCCB );
    m_pStream->Spaces( STANDARD_STUB_TAB );
    m_pStream->Write( "Debug();" );
    Out_IndentDec( m_pCCB );
    Out_ProcClosingBrace( m_pCCB );
    
    // Rename the procedure to Client__InterfaceName__ProcName
    sprintf( pszNewProcName, "Client__%s__%s", pProc->GetInterfaceName(), pszProcName );
    
    // Add a RetVal parameter to the param list if the function isn't void
    if (bHasReturn) {
            
        pRetValParam = new node_param();
        pRetValParam->SetAttribute (ATTR_IN);
        pRetValParam->SetSymName ("RetVal");
        pRetValParam->SetBasicType( (node_skl *) new node_def( pProc->GetReturnType()->GetSymName() ));
        pRetValParam->SetEdgeType( EDGE_USE );
                    
        pNodeProc->AddLastMember (pRetValParam);
    }
                
    // Emit the client procedure
    m_pStream->NewLine(2);
    m_pStream->Write ("static");
    Out_ClientProcedureProlog( m_pCCB, pNodeProc );
    Out_IndentInc( m_pCCB );
    m_pStream->Spaces( STANDARD_STUB_TAB );
    m_pStream->Write( "Debug();" );
    Out_IndentDec( m_pCCB );
    Out_ProcClosingBrace( m_pCCB );
    
    // Delete the this parameter we created
    if (bIsObject) {
        pNodeProc->RemoveFirstMember();
        delete pThisParam;
    }

    // Delete the RetVal from the param List
    if (bHasReturn) {
        pNodeProc->RemoveLastMember();
        delete pRetValParam;
    }
                
    // Restore the procedure's name
    pNodeProc->SetSymName( pszProcName );
    
    // Restore the procedure's parameter names
    if (siNumArgs > 0) {
        i = 0;
        pNodeProc->GetParameterList (&ITypeNodeList);
        while( ITERATOR_GETNEXT( ITypeNodeList, pParam ) ) {
            pParam->SetSymName (ppszOldArgName[i]);
            delete [] ppszNewArgName[i];
            i ++;
        }
        delete [] ppszNewArgName;
        delete [] ppszOldArgName;
    }

    // Restore the node's return type
    pNodeProc->SetChild( pOldRetType );
    
    // Delete the fake void type node we created
    delete pVoidBaseType;
                
    // Delete the new name we created
    delete [] pszNewProcName;

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate data tables for each interface

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitDataTables() {

    // Write procedure name tables for each interface
    EmitProcNameTables();

    // Write the server and client lookup tables for each interface
    EmitServerClientTables();

    // Write the global_interface_data structures and exports for each interface
    EmitGlobalInterfaceData();

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate tables with each interface's procedure names and the number of 
    procedures in each interface.

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitProcNameTables() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    CG_INTERFACE* pInt;

    ITERATOR IProc;
    CG_PROC * pProc;

    long lNumProcs;
    BOOL bBeenHereBefore;

    char* pszInterfaceName;
    char pszTemp [1024];

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {
        
        if (pCG->GetChild()) {
            
            pInt = (CG_INTERFACE*) pCG;
            
            if (m_bDoObject && pCG->GetCGID() == ID_CG_OBJECT_INTERFACE ||
                !m_bDoObject && pCG->GetCGID() == ID_CG_INTERFACE) {
                
                lNumProcs = 0;
                bBeenHereBefore = FALSE;
                
                pszInterfaceName = pInt->GetInterfaceName();
                
                OpenComment();
                EmitComment ("Procedure tables for interface ");
                m_pStream->Write (pszInterfaceName);
                CloseComment();
                
                m_pStream->NewLine();
                sprintf (pszTemp, "static char* %s__ProcedureNames[] = {", pszInterfaceName);
                m_pStream->Write (pszTemp);
                
                Out_IndentInc( m_pCCB );
                
                pInt->GetAllMemberFunctions ( IProc);
                while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                    
                    pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                    if (strcmp (pszInterfaceName, "IUnknown") != 0) {
                        
                        // Write a comma if we're not the first function in the list
                        if (bBeenHereBefore) {
                            m_pStream->Write (",");
                        } else {
                            bBeenHereBefore = TRUE;
                        }

                        // Write procedure name enclosed in quotes
                        m_pStream->NewLine();
                        m_pStream->Write ("\"");
                        m_pStream->Write (pProc->GetSymName());
                        m_pStream->Write ("\"");

                        // Increment procedure count
                        lNumProcs ++;
                    }
                }
                
                Out_IndentDec( m_pCCB );
                m_pStream->NewLine();
                m_pStream->Write ("};");

                // Set number of procedures in interface table
                m_itInterfaceTable.SetNumProcedures (pszInterfaceName, lNumProcs);
            }
        }   // if
    }   // while

    return CG_OK;
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server and client lookup tables for each interface

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitServerClientTables() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    CG_INTERFACE* pInt;

    ITERATOR IProc;
    CG_PROC * pProc;

    char* pszInterfaceName;

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {
    
        if (pCG->GetChild()) {
            
            if (m_bDoObject && pCG->GetCGID() == ID_CG_OBJECT_INTERFACE ||
                !m_bDoObject && pCG->GetCGID() == ID_CG_INTERFACE) {
                
                pInt = (CG_INTERFACE*) pCG;
                pszInterfaceName = pInt->GetInterfaceName();
                
                // Write the server table
                OpenComment();
                EmitComment ("Debug server procedures for interface ");
                m_pStream->Write (pszInterfaceName);
                CloseComment();
                m_pStream->NewLine();
                
                m_pStream->Write ("static SERVER_ROUTINE ");
                m_pStream->Write (pszInterfaceName);
                m_pStream->Write ("__ServerRoutineTable[] = {");
                Out_IndentInc( m_pCCB );
                
                // If we're processing an object interface, 
                // we have to make room for the 3 IUnknown procedures
                if (m_bDoObject) {
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                }
                
                pInt->GetAllMemberFunctions ( IProc);
                while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                    
                    pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                    if (strcmp (pszInterfaceName, "IUnknown") != 0) {
                        m_pStream->NewLine();
                        m_pStream->Write ("(SERVER_ROUTINE)Server__");
                        m_pStream->Write (pProc->GetInterfaceNode()->GetSymName());
                        m_pStream->Write ("__");
                        m_pStream->Write (pProc->GetSymName());
                        m_pStream->Write (",");
                    }
                }
                Out_IndentDec( m_pCCB );
                m_pStream->NewLine();
                m_pStream->Write ("};");
                
                // Write client table
                OpenComment();
                EmitComment ("Debug client procedures for interface ");
                m_pStream->Write (pszInterfaceName);
                CloseComment();
                m_pStream->NewLine();
                
                m_pStream->Write ("static SERVER_ROUTINE ");
                m_pStream->Write (pszInterfaceName);
                m_pStream->Write ("__ClientRoutineTable[] = {");
                Out_IndentInc( m_pCCB );
                
                // If we're processing an object interface, 
                // we have to make room for the 3 IUnknown procedures
                if (m_bDoObject) {
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                    m_pStream->NewLine();
                    m_pStream->Write ("NULL,");
                }
                
                pInt->GetAllMemberFunctions ( IProc);
                while( ITERATOR_GETNEXT( IProc, pProc ) ) {
                    
                    pszInterfaceName = pProc->GetInterfaceNode()->GetInterfaceName();
                    if (strcmp (pszInterfaceName, "IUnknown") != 0) {
                        m_pStream->NewLine();
                        m_pStream->Write ("(SERVER_ROUTINE)Client__");
                        m_pStream->Write (pProc->GetInterfaceNode()->GetSymName());
                        m_pStream->Write ("__");
                        m_pStream->Write (pProc->GetSymName());
                        m_pStream->Write (",");
                    }
                }
                Out_IndentDec( m_pCCB );
                m_pStream->NewLine();
                m_pStream->Write ("};");
            }
        }
    }

    return CG_OK;
}



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the global interface data structures for each interface, as well
    as the export functions that return them

 Arguments:

 Return Value:

    CG_OK   if all is well.
        
 Notes:

----------------------------------------------------------------------------*/
CG_STATUS CG_NETMONSTUB_FILE::EmitGlobalInterfaceData() {

    CG_ITERATOR I;
    CG_NDR * pCG;
    ID_CG idCG;
    
    char pszTemp [100], * pszInterfaceName, * pszFixedUuid;
    char * p1, * p2, * p3, * p4, * p5;
    long lNumProcs;
    size_t lLength;

    GetMembers( I );
    while( ITERATOR_GETNEXT( I, pCG ) ) {

        idCG = pCG->GetCGID();

        if (((idCG == ID_CG_OBJECT_INTERFACE && m_bDoObject) || 
            (idCG == ID_CG_INTERFACE && !m_bDoObject)) &&
            pCG->GetChild()) {

            // Get the underscored uuid
            ((CG_INTERFACE*) pCG)->GetGuidStrs().GetStrs (p1, p2, p3, p4, p5);
            lLength = (long) strlen (p1) + strlen (p2) + strlen (p3) + strlen (p4) + strlen (p5);
            pszFixedUuid = new char [lLength + 5];
            sprintf (pszFixedUuid, "%s_%s_%s_%s_%s", p1, p2, p3, p4, p5);
            pszFixedUuid = _strlwr (pszFixedUuid);

            // Get the interface name
            pszInterfaceName = pCG->GetSymName();

            // Write a comment
            OpenComment();
            EmitComment ("GLOBAL_INTERFACE_DATA structure for interface ");
            m_pStream->Write (pszInterfaceName);
            CloseComment();

            // Header
            m_pStream->NewLine();
            m_pStream->Write ("static GLOBAL_INTERFACE_DATA GlobalInterfaceData__");
            m_pStream->Write (pszFixedUuid);
            m_pStream->Write (" = {");
            Out_IndentInc( m_pCCB );

			// Version
			m_pStream->NewLine();
			m_pStream->Write (NETMON_STUB_VERSION);
			m_pStream->Write (",");

            // Name
            m_pStream->NewLine();
            m_pStream->Write ("\"");
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("\",");

            // Proc format string size
            m_pStream->NewLine();
            m_pStream->Write ("PROC_FORMAT_STRING_SIZE,");

            // NumProcs
            m_pStream->NewLine();
            if (m_itInterfaceTable.GetNumProcedures (pszInterfaceName, &lNumProcs)) {
                m_pStream->Write (_itoa (lNumProcs, pszTemp, 10));
            } else {
                MIDL_ASSERT (FALSE);
            }
            m_pStream->Write (",");

            // Proc name table
            m_pStream->NewLine();
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("__ProcedureNames,");

            // Server routine table
            m_pStream->NewLine();
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("__ServerRoutineTable,");

            // Client routine table
            m_pStream->NewLine();
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("__ClientRoutineTable,");
            
            // Rpc server interface pointer
            m_pStream->NewLine();
            m_pStream->Write ("(RPC_SERVER_INTERFACE*) &");
            m_pStream->Write (pszInterfaceName);
            m_pStream->Write ("___RpcServerInterface,");

            // DebugArgumentBuffer
            m_pStream->NewLine();
            m_pStream->Write ("(void*) DebugArgumentBuffer");

            Out_IndentDec( m_pCCB );
            m_pStream->NewLine();
            m_pStream->Write ("};");

            // Export function
            OpenComment();
            EmitComment ("Export function for interface ");
            m_pStream->Write (pszInterfaceName);
            CloseComment();

            m_pStream->NewLine();
            m_pStream->Write ("DLL_EXPORT_PROC (");
            m_pStream->Write (pszFixedUuid);
            m_pStream->Write (")");

            delete [] pszFixedUuid;
        }
    }

    return CG_OK;
}

/****************************************************
* InterfaceTable implementations
****************************************************/
#define NUM_BUCKETS 100
NetmonStubFileInterfaceTable::NetmonStubFileInterfaceTable() {
    m_pTable = new NetmonStubFileInterfaceList [NUM_BUCKETS];
}

NetmonStubFileInterfaceTable::~NetmonStubFileInterfaceTable() {
    delete [] m_pTable;
}

void NetmonStubFileInterfaceTable::AddInterface (char* pszInterface) {
    m_pTable[GetHashValue (pszInterface)].AddInterface (pszInterface);  
}

// Return true if the interface name was found
BOOL NetmonStubFileInterfaceTable::FindInterface (char* pszInterface) {
    return m_pTable[GetHashValue (pszInterface)].FindInterface (pszInterface);
}

// Set the number of procedures in the interface
BOOL NetmonStubFileInterfaceTable::SetNumProcedures (char* pszInterface, long lNumProcs) {
    return m_pTable[GetHashValue (pszInterface)].SetNumProcedures (pszInterface, lNumProcs);
}

// Get the number of procedures in the interface
BOOL NetmonStubFileInterfaceTable::GetNumProcedures (char* pszInterface, long* plNumProcs) {
    return m_pTable[GetHashValue (pszInterface)].GetNumProcedures (pszInterface, plNumProcs);
}

// The hash value is just the sum of the characters in the interface name
// mod the number of buckets in the table
long NetmonStubFileInterfaceTable::GetHashValue (char* pszInterface) {
    
    long i, lSum = 0, lLen = (long) strlen (pszInterface);
    for (i = 0; i < lLen; i ++) {
        lSum += (long) pszInterface[i];
    }
    return lSum % NUM_BUCKETS;
}


/* InterfaceNode */
NetmonStubFileInterfaceNode::NetmonStubFileInterfaceNode (char* pszInterface) {
    m_pszInterface = new char [strlen (pszInterface) + 1];
    strcpy (m_pszInterface, pszInterface);
    m_pNext = NULL;
    m_lNumProcs = 0;
}

NetmonStubFileInterfaceNode::~NetmonStubFileInterfaceNode() {
    delete [] m_pszInterface;
}

void NetmonStubFileInterfaceNode::SetNext (NetmonStubFileInterfaceNode* pNext) {
    m_pNext = pNext;
}

NetmonStubFileInterfaceNode* NetmonStubFileInterfaceNode::GetNext() {
    return m_pNext;
}

char* NetmonStubFileInterfaceNode::GetInterface() {
    return m_pszInterface;
}

void NetmonStubFileInterfaceNode::SetNumProcedures (long lNumProcs) {
    m_lNumProcs = lNumProcs;
}

long NetmonStubFileInterfaceNode::GetNumProcedures() {
    return m_lNumProcs;
}

/* InterfaceList */
NetmonStubFileInterfaceList::NetmonStubFileInterfaceList() {
    m_pHead = NULL;
    m_pTail = NULL;
}

NetmonStubFileInterfaceList::~NetmonStubFileInterfaceList() {
    NetmonStubFileInterfaceNode* pNode = m_pHead, *pDeleteNode;
    while (pNode != NULL) {
        pDeleteNode = pNode;
        pNode = pNode->GetNext();
        delete pDeleteNode;
    }
}

void NetmonStubFileInterfaceList::AddInterface (char* pszInterface) {
    
    NetmonStubFileInterfaceNode* pNode = new NetmonStubFileInterfaceNode (pszInterface);
        
    if (m_pHead == NULL) {
        m_pHead = m_pTail = pNode;
    } else {
        m_pTail->SetNext (pNode);
        m_pTail = pNode;
    }
}

BOOL NetmonStubFileInterfaceList::FindInterface (char* pszInterface) {

    NetmonStubFileInterfaceNode* pNode = m_pHead;
    while (pNode != NULL) {
        if (strcmp (pszInterface, pNode->GetInterface()) == 0) {
            return TRUE;
        }
        pNode = pNode->GetNext();
    }

    return FALSE;
}

BOOL NetmonStubFileInterfaceList::SetNumProcedures (char* pszInterface, long lNumProcs) {

    NetmonStubFileInterfaceNode* pNode = m_pHead;
    while (pNode != NULL) {
        if (strcmp (pszInterface, pNode->GetInterface()) == 0) {
            pNode->SetNumProcedures (lNumProcs);
            return TRUE;
        }
        pNode = pNode->GetNext();
    }

    return FALSE;
}

BOOL NetmonStubFileInterfaceList::GetNumProcedures (char* pszInterface, long* plNumProcs) {
    
    NetmonStubFileInterfaceNode* pNode = m_pHead;
    while (pNode != NULL) {
        if (strcmp (pszInterface, pNode->GetInterface()) == 0) {
            *plNumProcs = pNode->GetNumProcedures();
            return TRUE;
        }
        pNode = pNode->GetNext();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\output.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    output.cxx

 Abstract:

    Low level output routines for midl.

 Notes:


 History:

    Sep-18-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
#include "buffer.hxx"
#include "midlvers.h"
#include "ndrtypes.h"
#include "rpc.h"

static BOOL HasExprRoutines = FALSE;

#if 0
                            Notes

    A few general rules followed throughout the file.

        1. Never emit tab other than thru the stream.
        2. Never emit a new line other than thru the stream.
        3. Emitting a new line is the responsibility of the entity that wants
           itself to be emitted on a new line. Therefore, say each local
           variable in the stub needs to be on a new line, then the routine
           responsible for emitting the local variable will be responsible
           for setting the new line.

#endif // 0

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/
/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;


void
Out_ServerProcedureProlog(
    CCB     *   pCCB,
    node_skl*   pNode,
    ITERATOR&   LocalsList,
    ITERATOR&   ParamsList,
    ITERATOR&   TransientList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side procedure prolog.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pNode       - A pointer to the actual procedure node.
    LocalsList  - A list of local resources.
    ParamsList  - A list of param resources.
    TransientList- A list of temp variables.

 Return Value:

 Notes:

    The server side procedure prolog generation cannot use the normal
    printtype method on the procedure node, since the server stub signature
    looks different.

    Also the name of the server side stub is mangled with the interface name.

    All server side procs are void returns.

----------------------------------------------------------------------------*/
{
    CSzBuffer TempBuffer( "void __RPC_STUB\n" );
    TempBuffer.Append( pCCB->GetInterfaceName() );
    TempBuffer.Append( "_" );
    TempBuffer.Append( pNode->GetSymName() );
    TempBuffer.Append( "(" );
    
    Out_ProcedureProlog( pCCB,
                         TempBuffer,
                         pNode,
                         LocalsList,
                         ParamsList,
                         TransientList
                       );

}

void
Out_ProcedureProlog(
    CCB     *   pCCB,
    PNAME       pProcName,
    node_skl*   ,
    ITERATOR&   LocalsList,
    ITERATOR&   ParamsList,
    ITERATOR&   TransientList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side procedure prolog.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pName       - A pointer to the procs name string.
    pNode       - A pointer to the actual procedure node.
    LocalsList  - A list of local resources.
    ParamsList  - A list of param resources.

 Return Value:

 Notes:

    Any name mangling is the responsibility of the caller.
----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    RESOURCE*   pRes;
    BOOL fFirst = TRUE;

    pStream->NewLine();
    pStream->Write( pProcName );
    pStream->IndentInc();

    //
    // Emit the list of parameters.
    //

    if( ITERATOR_GETCOUNT( ParamsList ) )
        {
        ITERATOR_INIT( ParamsList );

        while( ITERATOR_GETNEXT( ParamsList, pRes ) )
            {
            if(fFirst != TRUE)
                pStream->Write(',');
            pRes->GetType()->PrintType(
                                        (PRT_PARAM_WITH_TYPE | PRT_CSTUB_PREFIX),
                                        pStream,             // into stream
                                        (node_skl *)0        // no parent.
                                      );
            fFirst = FALSE;
            }
        }

    pStream->IndentDec();

    //
    // Write out the opening brace for the server proc and all that.
    //

    pStream->Write(" )");
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    //
    // This is where we get off for /Oi.  We have a special routine
    // for local variable declaration for /Oi.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return;

    //
    // Print out declarations for the locals.
    //

    if( ITERATOR_GETCOUNT( LocalsList ) )
        {
        ITERATOR_INIT( LocalsList );

        while( ITERATOR_GETNEXT( LocalsList, pRes ) )
            {
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            }
        }

    if( ITERATOR_GETCOUNT( TransientList ) )
        {
        ITERATOR_INIT( TransientList );

        while( ITERATOR_GETNEXT( TransientList, pRes ) )
            {
            pStream->IndentInc();
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            pStream->IndentDec();
            }
        }

    pStream->Write( RPC_STATUS_TYPE_NAME" "RPC_STATUS_VAR_NAME";" );

    pStream->NewLine();

    //
    // Done.
    //
}

void
Out_ClientProcedureProlog(
    CCB     *   pCCB,
    node_skl*   pNode )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the procedure prolog for the client side.

 Arguments:

    pCCB    - A pointer to the code generation controller block.
    pNode   - A pointer to the procedure node.

 Return Value:

    None.

 Notes:

    The procedure prolog consists of the return type, the proc name and the
    parameters along with the open brace.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PRTFLAGS    flags;

    MIDL_ASSERT( NODE_PROC == pNode->NodeKind() );

    flags = PRT_PROC_PROTOTYPE | PRT_CSTUB_PREFIX;

    if ( NULL != ( ( node_proc * ) pNode )->GetCSTagRoutine() )
        flags |= PRT_OMIT_CS_TAG_PARAMS;

    pStream->NewLine();
    pStream->NewLine(); // extra new line.

    pNode->PrintType( 
            flags,            // print the declaration only.
            pStream,          // into this stream.
            (node_skl *)0     // parent pointer not applicable.
                    );

    //
    // Write the opening brace on a new line.
    //

    pStream->WriteOnNewLine( "{" );

    pStream->NewLine();

}

void
Out_ClientLocalVariables(
    CCB             *   pCCB,
    ITERATOR&           LocalVarList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output the list of client side local variables.


 Arguments:

    pCCB            - A pointer to the code generation controller block.
    LocalVarList    - An iterator containing the list of local variables.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    RESOURCE    *   pResTemp;

    ITERATOR_INIT( LocalVarList );


    while( ITERATOR_GETNEXT( LocalVarList, pResTemp ) )
        {
        pStream->IndentInc();
        pStream->NewLine();
        pResTemp->GetType()->PrintType( PRT_ID_DECLARATION,
                                                        // print top level decl
                                        pStream,        // into stream with
                                        (node_skl *)0   // parent not applicable
                                      );
        pStream->IndentDec();
        }
}


void
Out_AllocAndFreeFields(
    CCB *               pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs the alloc and free fields of the stub descriptor.

 Arguments:

    pCCB            - A pointer to the code generation controller block.

----------------------------------------------------------------------------*/
{
    ISTREAM         *   pStream;
    CG_INTERFACE    *   pIntfCG = pCCB->GetInterfaceCG();

    pStream = pCCB->GetStream();

    if ( pIntfCG->IsObject() )
        {
        pStream->Write( OLE_ALLOC_RTN_NAME );
        }
    else if ( pCCB->GetMode() )
        {
        // non-osf modes

        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? RPC_SM_CLIENT_ALLOCATE_RTN_NAME
                                : DEFAULT_ALLOC_RTN_NAME );
            }
        else
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? DEFAULT_ALLOC_OSF_RTN_NAME
                                : DEFAULT_ALLOC_RTN_NAME );
        }
    else
        {
        // osf mode

        pStream->Write( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT)
                            ?  RPC_SM_CLIENT_ALLOCATE_RTN_NAME
                            :  DEFAULT_ALLOC_OSF_RTN_NAME );
        }
    pStream->Write(',');
    pStream->NewLine();

    if ( pIntfCG->IsObject() )
        {
        pStream->Write( OLE_FREE_RTN_NAME );
        }
    else if ( pCCB->GetMode() )
        {
        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? RPC_SM_CLIENT_FREE_RTN_NAME
                                : DEFAULT_FREE_RTN_NAME );
            }
        else
            pStream->Write( pIntfCG->IsAllRpcSS()
                                ? DEFAULT_FREE_OSF_RTN_NAME
                                : DEFAULT_FREE_RTN_NAME );
        }
    else
        {
        pStream->Write( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT)
                            ?  RPC_SM_CLIENT_FREE_RTN_NAME
                            :  DEFAULT_FREE_OSF_RTN_NAME );
        }
    pStream->Write(',');
    pStream->NewLine();
}

void
Out_NotifyTable (
                CCB*        pCCB
                )
    {
    CGSIDE      Side = pCCB->GetCodeGenSide();
    ITERATOR    NotifyProcList;

    pCCB->GetListOfNotifyTableEntries( NotifyProcList );
    ITERATOR_INIT( NotifyProcList );

    if ( Side == CGSIDE_SERVER && pCommand->GetNdrVersionControl().HasInterpretedNotify() )
        { 
        ISTREAM*    pStream = pCCB->GetStream();
        CG_PROC*    pProc   = 0;

        pStream->NewLine();
        pStream->Write( "static const NDR_NOTIFY_ROUTINE " );
        pStream->Write( "_NotifyRoutineTable[] = {" );
        pStream->IndentInc();
        pStream->NewLine();
        while ( ITERATOR_GETNEXT( NotifyProcList, pProc ) )
            {
            pStream->Write( "(NDR_NOTIFY_ROUTINE) " );
            pStream->Write( pProc->GetSymName() );
            pStream->Write( "_notify" );
            if ( pProc->HasNotifyFlag() )
                {
                pStream->Write( "_flag" );
                }
            pStream->Write( "," );
            pStream->NewLine();
            }
        pStream->Write( "0" );
        pStream->NewLine();
        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine();
        }
    }

void
Out_NotifyTableExtern   (
                        CCB* pCCB
                        )
    {
    if ( pCommand->GetNdrVersionControl().HasInterpretedNotify() )
        {
        ISTREAM*    pStream = pCCB->GetStream();
        pStream->NewLine();
        pStream->Write( "extern const NDR_NOTIFY_ROUTINE _NotifyRoutineTable[];" );
        pStream->NewLine();
        }
    }

void
Out_StubDescriptor(
    CG_HANDLE *         pImplicitHandle,
    CCB *               pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the stub descriptor structure in the client or server stub.

 Arguments:

    pImplicitHandle - A pointer to the implicit CG_HANDLE used in the
                      interface.  Every interface has one of these even if
                      it is not used.
    pCCB            - A pointer to the code gen controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    if ( !pCommand->IsFinalProtocolRun() )
        {
        // Expression routines are generated in dce run, but we are generating stubdesc in
        // ndr64 run. So we need to save the state for second run.
        // better solution would be using expression evaluator for dce. 
        MIDL_ASSERT( pCommand->IsNDRRun() );
        if ( pCommand->NeedsNDR64Run() && pCCB->GetExprEvalIndexMgr()->Lookup(1) )
            {
            HasExprRoutines = TRUE;
            }
        return;
        }

    ISTREAM *       pStream;
    CG_INTERFACE *  pInterface;
    CSzBuffer       Buffer;
    CGSIDE          Side;
    BOOL            fObjectInterface;
    ULONG_PTR       ulMidlFlag = 0;

    pStream = pCCB->GetStream();

    Side = pCCB->GetCodeGenSide();

    pInterface = pCCB->GetInterfaceCG();
    fObjectInterface = pInterface->IsObject();

    if ( pInterface->HasClientInterpretedCommOrFaultProc( pCCB ) )
        {
        CG_ITERATOR Iterator;
        CG_PROC *   pProc;

        pStream->NewLine();
        pStream->Write( "static const COMM_FAULT_OFFSETS " );
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( "CommFaultOffsets[]" );
        pStream->Write( " = " );
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        pInterface->GetMembers( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pProc ) )
            {
            long   CommOffset, FaultOffset;

            if ( ((Side == CGSIDE_CLIENT) &&
                  (pProc->GetCGID() != ID_CG_PROC)) ||
                 ((Side == CGSIDE_SERVER) &&
                  (pProc->GetCGID() != ID_CG_CALLBACK_PROC)) )
                continue;

            if ( pProc->HasStatuses() )
                {
                pProc->GetCommAndFaultOffset( pCCB, CommOffset, FaultOffset );

                Buffer.Set( "\t{ " );
                Buffer.Append( CommOffset );
                Buffer.Append( ", " );
                Buffer.Append( FaultOffset );
                Buffer.Append( " }" );
                Buffer.Append( pProc->GetSibling() ? "," : " " );
                
                if ( ! pCommand->Is32BitEnv() )
                    {
                    Buffer.Append( "\t/* ia64 Offsets for " );
                    }
                else
                    {
                    Buffer.Append( "\t/* x86 Offsets for " );
                    }

                Buffer.Append( pProc->GetSymName() );
                Buffer.Append( " */" );
                pStream->Write( Buffer );
                }
            else
                {
                pStream->Write( "\t{ -2, -2 }" );
                if ( pProc->GetSibling() )
                    pStream->Write( ',' );
                }

            pStream->NewLine();
            }

        pStream->Write( "};" );
        pStream->NewLine();
        pStream->NewLine();
        }

    //
    // If we have an implicit generic handle then output the generic info
    // structure which will be placed in the IMPLICIT_HANDLE_INFO union.
    //

    if ( (Side == CGSIDE_CLIENT) &&
         pImplicitHandle && pImplicitHandle->IsGenericHandle() )
        {
        pStream->NewLine();
        pStream->Write( "static " GENERIC_BINDING_INFO_TYPE );
        pStream->Write( ' ' );
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( GENERIC_BINDING_INFO_VAR );
        pStream->Write( " = " );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        pStream->Write( '&' );
        pStream->Write( pImplicitHandle->GetHandleIDOrParam()->GetSymName() );
        pStream->Write( ',' );
        pStream->NewLine();

        char    Buffer[80];

        sprintf( Buffer, "%d,",
                 ((CG_GENERIC_HANDLE *)pImplicitHandle)->GetImplicitSize() );
        pStream->Write( Buffer );
        pStream->NewLine();

        pStream->Write( "(" GENERIC_BINDING_ROUTINE_TYPE ")" );
        pStream->Write( pImplicitHandle->GetHandleType()->GetSymName() );
        pStream->Write( "_bind," );
        pStream->NewLine();

        pStream->Write( "(" GENERIC_UNBINDING_ROUTINE_TYPE ")" );
        pStream->Write( pImplicitHandle->GetHandleType()->GetSymName() );
        pStream->Write( "_unbind" );
        pStream->NewLine();

        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine();
        }

    //
    // Emit the stub descriptor structure itself.
    //

    pStream->NewLine();

    pStream->Write( "static const " STUB_DESC_STRUCT_TYPE_NAME );

    pStream->Write( ' ' );

    pStream->Write( pCCB->GetInterfaceCG()->GetStubDescName() );
    pStream->Write( " = " );

    pStream->IndentInc();

    pStream->NewLine();
    pStream->Write('{' );
    pStream->NewLine();

    if( (fObjectInterface == TRUE) )
        pStream->Write( "0," );
    else
        {
        pStream->Write( "(void *)& " );
        pStream->Write( pCCB->GetInterfaceName() );

        if( Side == CGSIDE_SERVER )
            pStream->Write( RPC_S_INT_INFO_STRUCT_NAME"," );
        else
            pStream->Write( RPC_C_INT_INFO_STRUCT_NAME"," );
        }

    pStream->NewLine();

    Out_AllocAndFreeFields( pCCB );

    //
    // Output the implicit handle information on the client side.
    //
    if ( (Side == CGSIDE_CLIENT) && (fObjectInterface != TRUE) )
        {
        if ( ! pImplicitHandle )
            {
            pStream->Write( '&' );
            pStream->Write( pCCB->GetInterfaceName() );
            pStream->Write( AUTO_BH_VAR_NAME );
            }
        else
            {
            if ( pImplicitHandle->IsPrimitiveHandle() )
                {
                pStream->Write( '&' );
                pStream->Write(
                    pImplicitHandle->GetHandleIDOrParam()->GetSymName() );
                }
            else // has to be implicit generic
                {
                MIDL_ASSERT( pImplicitHandle->IsGenericHandle() );

                pStream->Write( "(handle_t *)& " );
                pStream->Write( pCCB->GetInterfaceName() );
                pStream->Write( '_' );
                pStream->Write( GENERIC_BINDING_INFO_VAR );
                }
            }
        }
    else
        pStream->Write( '0' );

    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Output the rundown routine table on the server side interpreted stub
    // if needed.
    //
    if ( (Side == CGSIDE_SERVER) &&
         (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER) &&
         pCCB->HasRundownRoutines()
       )
        {
        pStream->Write( RUNDOWN_ROUTINE_TABLE_VAR );
        }
    else
        {
        pStream->Write( '0' );
        }

    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Output the generic bind/unbind routine pair table on the client side
    // interpreted stub if needed.
    //
    if ( (Side == CGSIDE_CLIENT) &&
         pCCB->GetInterpretedRoutinesUseGenHandle()
       )
        {
        pStream->Write( BINDING_ROUTINE_TABLE_VAR );
        }
    else
        {
        pStream->Write( '0' );
        }
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Output the expression evaluation routine table.
    //
    pStream->Write( pCCB->GetExprEvalIndexMgr()->Lookup(1) || HasExprRoutines
                        ? EXPR_EVAL_ROUTINE_TABLE_VAR","
                        : "0," );
    pStream->NewLine();

    //
    // Output the transmit as routine table.
    //
    pStream->Write( pCCB->GetQuintupleDictionary()->GetCount()
                          ?  XMIT_AS_ROUTINE_TABLE_VAR ","
                          :  "0," );
    pStream->NewLine();

    //
    // Output the type format string.
    //
    if ( SYNTAX_DCE == pCommand->GetDefaultSyntax() )
        pStream->Write( FORMAT_STRING_STRING_FIELD );
    else
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
        
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // -error bounds_check flag.
    //
    pStream->Write( pCCB->MustCheckBounds() ? "1" : "0" );
    pStream->Write( ',' );
    pStream->Write( " /* -error bounds_check flag */" );
    pStream->NewLine();

    //
    // Ndr library version.
    //
    unsigned long ulNdrLibVer = NDR_VERSION_1_1;
    if ( pCommand->GetNdrVersionControl().HasNdr60Feature() )
        {
        ulNdrLibVer = NDR_VERSION_6_0;
        }
    else if ( pCommand->GetNdrVersionControl().HasNdr50Feature() )
        {
        if ( pCommand->GetNdrVersionControl().HasOicfPickling() )
            {
            ulNdrLibVer = NDR_VERSION_5_4;
            }
        else if ( pCommand->GetNdrVersionControl().HasNT5VTableSize() )
            {
            ulNdrLibVer = NDR_VERSION_5_3;
            }
        else if (pCommand->GetNdrVersionControl().HasAsyncUUID() ||
            pCommand->GetNdrVersionControl().HasDOA() ||
            pCommand->GetNdrVersionControl().HasContextSerialization() ||
            pCommand->GetNdrVersionControl().HasInterpretedNotify() )
            {
            ulNdrLibVer = NDR_VERSION_5_2;
            }
        else
            {
            ulNdrLibVer = NDR_VERSION_5_0;
            }
        }
    else if ( (pCommand->GetOptimizationFlags() & OPTIMIZE_NON_NT351) ||
          pCommand->GetNdrVersionControl().HasNdr20Feature() )
        {
        ulNdrLibVer = NDR_VERSION_2_0;
        }
    sprintf( Buffer, "0x%x", ulNdrLibVer );

    pStream->Write( Buffer );
    pStream->Write( ',' );
    pStream->Write( " /* Ndr library version */" );
    pStream->NewLine();

    if ( fObjectInterface  &&
         pCommand->GetNdrVersionControl().HasUserMarshal()  &&
         (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
         ! (pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2)
       )
        {
        pStream->NewLine(2);
        pStream->Write( "#error [user_marshal] and [wire_marshal] not supported with -Oi and -Oic" );
        pStream->NewLine();
        pStream->Write( "/* use -Os or -Oicf compiler flag */" );
        pStream->NewLine();

        RpcError( NULL, 0, USER_MARSHAL_IN_OI, "" );
        exit( USER_MARSHAL_IN_OI );
        }

    // Used one reserved field for RpcSs.
    // In ms_ext when explicit, in osf always, to cover some weird cases.

    if ( ( pCCB->GetInterfaceCG()->GetUsesRpcSS() || (pCCB->GetMode() == 0) )
         &&
         ( (Side == CGSIDE_CLIENT) ||
           ((Side == CGSIDE_SERVER) && pCCB->GetMode()) )// because of callbacks
       )
        {
        pStream->Write( "&" MALLOC_FREE_STRUCT_VAR_NAME "," );
        }
    else
        pStream->Write( "0," );
    pStream->NewLine();

    // MIDL version number.

    sprintf( Buffer,
             "0x%x, /* MIDL Version %d.%d.%d */",
             (rmj << 24) | (rmm << 16) | rup,
             rmj,
             rmm,
             rup );
    pStream->Write( Buffer );
    pStream->NewLine();

    // Interpreter comm/fault status info.

    if ( pInterface->HasClientInterpretedCommOrFaultProc( pCCB ) )
        {
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( '_' );
        pStream->Write( "CommFaultOffsets," );
        }
    else
        {
        pStream->Write( "0," );
        }
    pStream->NewLine();

    // Fields for the compiler version 3.0+

    //
    // Output the usr_marshal routine table.
    //
    if ( pCCB->HasQuadrupleRoutines() )
        {
        if ( SYNTAX_DCE == pCommand->GetDefaultSyntax() )
            pStream->Write( USER_MARSHAL_ROUTINE_TABLE_VAR );
        else
            pStream->Write( NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR );
        }
    else
        pStream->Write( "0" );
    pStream->Write( "," );
    pStream->NewLine();

    // notify & notify_flag routine table
    if ( Side == CGSIDE_SERVER && pCommand->GetNdrVersionControl().HasInterpretedNotify() )
        { 
        pStream->Write( "_NotifyRoutineTable" );
        }
    else
        {
        pStream->Write( "0" );
        }
        pStream->Write( ",  /* notify & notify_flag routine table */" );
        pStream->NewLine();

    if ( ! pInterface->GetHasMSConfStructAttr() )
        {
        ulMidlFlag |= 1;
        }

    if ( pCommand->IsSwitchDefined(SWITCH_NOREUSE_BUFFER))
        ulMidlFlag |= 2;

    if ( pCommand->NeedsNDR64Run() )
        ulMidlFlag |= RPCFLG_HAS_MULTI_SYNTAXES;

    sprintf( Buffer,
             "0x%x, /* MIDL flag */",
             ulMidlFlag);
        
    pStream->Write( Buffer );

    if ( pCCB->HasCsTypes() )
        {
        pStream->WriteOnNewLine( '&' );
        pStream->Write( CS_ROUTINE_TABLES_VAR );
        pStream->Write( ',' );
        }
    else
        {
        pStream->WriteOnNewLine( "0, /* cs routines */" );
        }

    if ( !fObjectInterface  && pCommand->NeedsNDR64Run() )
        {
        if ( Side == CGSIDE_SERVER )
            {
            pStream->WriteOnNewLine( "(void *)& " );
            pStream->Write( pCCB->GetInterfaceName() );
            pStream->Write( "_ServerInfo," );
            }
        else
            {
            pStream->WriteOnNewLine( "(void *)& " );
            pStream->Write( pCCB->GetInterfaceName() );
            pStream->Write( "_ProxyInfo," );
            }
        }
    else
        {
        pStream->WriteOnNewLine( "0," );
        }
    pStream->Write( "   /* proxy/server info */" );
        
    //
    // The reserved fields for future use.
    //

    // 1 reserved fields

    pStream->WriteOnNewLine( "0   /* Reserved5 */" );

    // No reserved fields left.
    // Check the compiler version and or lib version if you need to access
    // newer fields.

    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();
    pStream->NewLine();

}


void CG_INTERFACE::Out_ProxyInfo( CCB * pCCB, 
                                  BOOL IsForCallback )
{
    if ( pCommand->IsNDR64Run() )
        {
        GenSyntaxInfo( pCCB, IsForCallback );
        GenProxyInfo( pCCB, IsForCallback );
        }
}



void CG_INTERFACE::Out_ServerInfo(CCB *pCCB,
                    BOOL fHasThunk,
                    BOOL IsForCallback )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM *       pStream     = pCCB->GetStream();
    CG_INTERFACE *  pInterface  = pCCB->GetInterfaceCG();
    char        *   pItfName    = pInterface->GetSymName();
    BOOL            fObject     = pCCB->GetInterfaceCG()->IsObject();

    pStream->Write( "static const " SERVER_INFO_TYPE_NAME " " );
    pStream->Write( pItfName );
    pStream->Write( SERVER_INFO_VAR_NAME );
    pStream->Write( " = " );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    //
    // Stub descriptor.
    //
    pStream->Write( '&' );
    pStream->Write( pInterface->GetStubDescName() );
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Dispatch table to server routines.
    //
    if ( !pCCB->GetInterfaceCG()->IsObject() )
        {
        pStream->Write( pItfName );
        pStream->Write( SERVER_ROUTINE_TABLE_NAME );
        }
    else
        {
        pStream->Write( '0' );
        }

    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Procedure format string.
    //
    if (pCommand->GetDefaultSyntax() == SYNTAX_NDR64 )
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
    else
        pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Array of proc format string offsets.
    //
    if ( pCommand->IsNDR64Run() )
        pStream->Write( "(unsigned short *) " );
    if ( fObject )
        pStream->Write( '&' );
    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
    pStream->Write( pItfName );
    if ( pCommand->GetDefaultSyntax() == SYNTAX_DCE )
        {
        pStream->Write( FORMAT_STRING_OFFSET_TABLE_NAME );
        }
    else
        {
        pStream->Write( "_Ndr64ProcTable" );
        }
    if ( fObject )
        pStream->Write( "[-3]" );
    pStream->Write( ',' );
    pStream->NewLine();

    //
    // Thunk table.
    //
    if ( fHasThunk )
        {
        if ( fObject )
            pStream->Write( '&' );
        pStream->Write( pItfName );
        pStream->Write( STUB_THUNK_TABLE_NAME );
        if ( fObject )
            pStream->Write( "[-3]" );
       }
    else
        pStream->Write( '0' );

    pStream->Write( ',' );

    pStream->NewLine();

    // old inteface supporting one transfer syntax.
    // old interfaces. 
    if ( !pCommand->NeedsNDR64Run() )
        {
        pStream->Write( "0,");
        pStream->NewLine();
        pStream->Write( "0,");
        pStream->NewLine();
        pStream->Write( "0");
        }
    else
        {
        // default transfer syntax is NDR
        pStream->Write( '&' );
        if ( pCommand->IsNDRRun() )
            pStream->Write( NDR_TRANSFER_SYNTAX_VAR_NAME );
        else
            pStream->Write( NDR64_TRANSFER_SYNTAX_VAR_NAME );
           
        pStream->Write( ',' );
        pStream->NewLine();
        // we only support one additional transfer syntax
        if ( pCommand->NeedsNDRRun() )
            pStream->Write( "2," );
        else
            pStream->Write( "1," );
        pStream->NewLine();
        if ( IsForCallback )
            pStream->Write( MIDL_CALLBACK_VAR_NAME );
        pStream->Write( GetMulSyntaxInfoName() );
        pStream->NewLine();
        }


    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();
}

/*
*   Generates MIDL_SERVER_INFO. It'll be generated in:
        . object interface
        . raw RPC server side
        . raw RPC client side, if callback is presented (client side means for callback)
        regardless of transfer syntax.
        
*   
*/
void
CG_INTERFACE::Out_InterpreterServerInfo( CCB *    pCCB,
                           CGSIDE   Side )
{
    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM *       pStream     = pCCB->GetStream();
    CG_PROC *       pProc;
    BOOL            fHasThunk;
    char         *  pSStubPrefix;
    CSzBuffer       Buffer;
    BOOL            fObject     = pCCB->GetInterfaceCG()->IsObject();
    char        *   pItfName    = GetSymName();

    pStream->NewLine();

    fHasThunk = FALSE;

    if ( (pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR ) ) == 0 )
        {
        pSStubPrefix = "";
        }

    //
    // Server routine dispatch table.
    //

    if ( !fObject )
        {
        CG_ITERATOR     Iterator;

        pStream->Write( "static const " SERVER_ROUTINE_TYPE_NAME " " );
        pStream->Write( pItfName );
        pStream->Write( SERVER_ROUTINE_TABLE_NAME "[]" );
        pStream->Write( " = " );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        GetMembers( Iterator );

        BOOL fNoProcsEmitted = TRUE;

        while ( ITERATOR_GETNEXT( Iterator, pProc ) )
            {
            if ( (Side == CGSIDE_CLIENT) &&
                 (pProc->GetCGID() != ID_CG_CALLBACK_PROC) )
                continue;

            if ( (Side == CGSIDE_SERVER) &&
                 ( (pProc->GetCGID() == ID_CG_CALLBACK_PROC)
                   || ( pProc->GetCGID() == ID_CG_TYPE_ENCODE_PROC ) ) )
                continue;

            fNoProcsEmitted = FALSE;

            if ( pProc->NeedsServerThunk( pCCB, Side ) )
                {
                fHasThunk = TRUE;
                }

            pStream->Write( "(" SERVER_ROUTINE_TYPE_NAME ")" );

            if ( pProc->GetCallAsName() )
                {
                pStream->Write( pProc->GenMangledCallAsName( pCCB ) );
                }
            else
                {
                if ( pProc->GetCGID() == ID_CG_ENCODE_PROC  ||
                     pProc->GetCGID() == ID_CG_TYPE_ENCODE_PROC ) 
                    pStream->Write( '0' );
                else
                    {
                    Buffer.Set( pSStubPrefix );
                    Buffer.Append( pProc->GetType()->GetSymName() );

                    if ( pProc->HasComplexReturnType() && !pProc->HasAsyncHandle() )
                        Buffer.Append( "_ComplexThunk" );

                    pStream->Write( Buffer );
                    }
                }

            if ( pProc->GetSibling() )
                pStream->Write( ',' );

            pStream->NewLine();
            }

        if ( fNoProcsEmitted )
            {
            pStream->Write( '0' );
            pStream->NewLine();
            }

        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine( 2 );
        }
    else    // object interfaces only need to know about thunks
        {
        ITERATOR        Iterator;
        CG_OBJECT_PROC  *   pObjProc;

        GetAllMemberFunctions( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pObjProc ) )
            {
            if ( pObjProc->NeedsServerThunk( pCCB, Side ) && !pObjProc->IsDelegated() )
                fHasThunk = TRUE;
            }
        }

    //
    // Thunk table.
    //
    if ( fHasThunk )
        {
        pStream->Write( "static const " STUB_THUNK_TYPE_NAME " " );
        pStream->Write( pItfName );
        pStream->Write( STUB_THUNK_TABLE_NAME "[]" );
        pStream->Write( " = " );
        pStream->IndentInc();
        pStream->NewLine();

        pStream->Write( '{' );
        pStream->NewLine();

        OutputThunkTableEntries( pCCB, TRUE );

        pStream->Write( "};" );
        pStream->IndentDec();
        pStream->NewLine( 2 );
        }

        

    // ---------------------------
    //
    // Emit the Server Info struct.
    //
    // ---------------------------

    Out_ServerInfo( pCCB , fHasThunk, Side == CGSIDE_CLIENT  );

}


void
Out_EP_Info(
    CCB *   pCCB,
    ITERATOR *  I )
    {
    ISTREAM     *   pStream = pCCB->GetStream();
    int             Count   = ITERATOR_GETCOUNT( *I );
    int             i;
    CSzBuffer   Buffer;
    ENDPT_PAIR  *   pPair;

    pStream->NewLine();
    pStream->Write( "static RPC_PROTSEQ_ENDPOINT __RpcProtseqEndpoint[] = " );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );

    for( i = 0, ITERATOR_INIT( *I );
         i < Count;
         i++ )
        {
        ITERATOR_GETNEXT( *I, pPair );

        pStream->NewLine();
        pStream->Write( '{' );

        Buffer.Set( "(unsigned char *) \"" );
        Buffer.Append( pPair->pString1 );
        Buffer.Append( "\", (unsigned char *) \"" );
        Buffer.Append( pPair->pString2 );
        Buffer.Append( "\"" );

        pStream->Write( Buffer );
        pStream->Write( '}' );

        if( ITERATOR_PEEKTHIS( *I ) )
            {
            pStream->Write( ',' );
            }

        }

    pStream->NewLine();
    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();
    }

void
Out_SetOperationBits(
    CCB         *   pCCB,
    unsigned int  OpBits )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    Set the RPC operation flags.

 Arguments:

    pCCB                - A pointer to the code generation controller block.
    OpBits              - Operation bits. These contain datagram related flags.
 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream         = pCCB->GetStream();

    pStream->NewLine();

    if( OpBits != 0 )
        {
        char            Buffer[ 512 ];
        sprintf( Buffer, RPC_MESSAGE_VAR_NAME".RpcFlags = ( RPC_NCA_FLAGS_DEFAULT "  );

        if( OpBits & OPERATION_MAYBE )
            {
            strcat( Buffer, "| RPC_NCA_FLAGS_MAYBE" );
            }

        if( OpBits & OPERATION_BROADCAST )
            {
            strcat( Buffer, "| RPC_NCA_FLAGS_BROADCAST" );
            }

        if( OpBits & OPERATION_IDEMPOTENT )
            {
            strcat( Buffer, "| RPC_NCA_FLAGS_IDEMPOTENT" );
            }

        if( OpBits & OPERATION_INPUT_SYNC )
            {
            strcat( Buffer, "| RPCFLG_INPUT_SYNCHRONOUS" );
            }

        if( OpBits & OPERATION_MESSAGE )
            {
            strcat( Buffer, "| RPCFLG_MESSAGE" );
            pCommand->GetNdrVersionControl().SetHasMessageAttr();
            }

        strcat( Buffer, " );" );

        pStream->Write( Buffer );
        }
}


void
Out_HandleInitialize(
    CCB         *   pCCB,
    ITERATOR&       BindingParamList,
    expr_node  *   ,
    BOOL            ,
    unsigned short  OpBits )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the call for initializing the stub message for a auto_handle
    case.

 Arguments:

    pCCB                - A pointer to the code generation controller block.
    BindingParamList    - List of params to the call.
    pAssignExpr         - if this param is non-null, assign the value of the
                          call to this.
    fAuto               - is this an auto handle call ?

    OpBits              - Operation bits. These contain datagram related flags.
 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream         = pCCB->GetStream();
    PNAME           pName           = CSTUB_INIT_RTN_NAME;

    expr_proc_call *   pProcCall   = MakeProcCallOutOfParamExprList(
                                                     pName,
                                                     (node_skl *)0,
                                                     BindingParamList
                                                                );

    pStream->NewLine();

    pProcCall->PrintCall( pStream, 0, 0 );

    pStream->NewLine();

    Out_SetOperationBits(pCCB, OpBits);
}


void
Out_AutoHandleSendReceive(
    CCB         *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit code for an auto handle base send receive call.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    pDest   - Optional destination for the result of the procedure call.
    pProc   - The procedure to call.

 Return Value:

 Notes:

    If there are no output parameters, we wont pick up the returned
    value of the send receive calls into the local variable for the
    buffer length. In that case the pDest pointer will be null.

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr   = pProc;

    pStream->NewLine();

    if( pDest )
        {
        pExpr   = new expr_assign( pDest, pProc );
        }

    pExpr->PrintCall( pStream, 0, 0 );
}

void
Out_NormalSendReceive(
    CCB *   pCCB,
    BOOL     )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit code for an auto handle base send receive call.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    fAnyOuts- Are there any out parameters at all ?

 Return Value:

 Notes:

    If there are no output parameters, we wont pick up the returned
    value of the send receive calls into the local variable for the
    buffer length.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuf;

    pStream->NewLine();

    //
    // Call the send receive routine.
    //

    TempBuf.Set( NORMAL_SR_NDR_RTN_NAME );
    TempBuf.Append( "( (PMIDL_STUB_MESSAGE) &" );
    TempBuf.Append( STUB_MESSAGE_VAR_NAME );
    TempBuf.Append( ", (unsigned char *)" );
    TempBuf.Append( STUB_MSG_BUFFER_VAR_NAME );
    TempBuf.Append( " );" );
    pStream->Write( TempBuf );
}

void
Out_NormalFreeBuffer(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the free buffer with check for status.

 Arguments:

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr   = pCCB->GetStandardResource(
                                ST_RES_STUB_MESSAGE_VARIABLE );
    ITERATOR        ParamList;

    pStream->NewLine();

    ITERATOR_INSERT( ParamList,
                     MakeAddressExpressionNoMatterWhat( pExpr )
                   );
    pExpr   = MakeProcCallOutOfParamExprList(
                                            NORMAL_FB_NDR_RTN_NAME, // rtn name
                                            (node_skl *)0,  // type - dont care
                                            ParamList       // param list
                                            );
    // generate the procedure call.

    pExpr->PrintCall( pStream, 0, 0 );

}

void
Out_IncludeOfFile(
    CCB     *   pCCB,
    PFILENAME       p,
    BOOL            fAngleBrackets )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a hash include of the given file.

 Arguments:

    pCCB            - A pointer to the code generation controller block.
    p               - The ready to emit file name string.
    fAngleBrackets  - Do we want angle brackets or quotes (TRUE if anglebrackets)

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuf;

    pStream->NewLine();

    TempBuf.Set( "#include " );
    TempBuf.Append( fAngleBrackets ? "<" : "\"" );
    TempBuf.Append( p );
    TempBuf.Append( fAngleBrackets ? ">" : "\"" );
    pStream->Write( TempBuf );
}

void
Out_MKTYPLIB_Guid(
    CCB     *   pCCB,
    GUID_STRS & GStrs,
    char * szPrefix,
    char * szName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a MKTYPLIB style guid structure.

 Arguments:

    pCCB          - A pointer to the code generation controller block.
    pGString1     - Partial guid strings.
    char * szName - name for the GUID

 Return Value:

 Notes:

    No checks are made for the validity of the string. The front-end has done
    that.

    All strings are emitted with a leading 0x.

    The 5 strings are treated this way:

        1 - 3. Emitted as such
        4 - 5. Broken into and emitted as byte hex values, without
               transformation, so they are just picked up and written out.
----------------------------------------------------------------------------*/
{
    char        TempBuf[256];
    ISTREAM *   pStream = pCCB->GetStream();

    if ( !GStrs.str1 )
        GStrs.str1 = "00000000";
    if ( !GStrs.str2 )
        GStrs.str2 = "0000";
    if ( !GStrs.str3 )
        GStrs.str3 = "0000";
    if ( !GStrs.str4 )
        GStrs.str4 = "00000000";
    if ( !GStrs.str5 )
        GStrs.str5 = "00000000";

    pStream->Write( "DEFINE_GUID(" );
    pStream->Write( szPrefix );
    pStream->Write( szName );
    pStream->Write( ',' );
    sprintf( TempBuf, "0x%s,0x%s,0x%s", GStrs.str1, GStrs.str2, GStrs.str3 );
    pStream->Write( TempBuf );

    //
    // Each of the above strings are just broken down into six 2 byte
    // characters with 0x preceding them.
    //

    strcpy( TempBuf, GStrs.str4 );
    strcat( TempBuf, GStrs.str5 );

    pStream->Write( "," );

    //
    // We will use the iteration counter to index into the string. Since we
    // need 2 per iteration, double the counter. Also pGString4 is actually
    // a 16 bit qty.
    //

    for( int i = 0; i < (6+2)*2 ; i += 2 )
        {
        pStream->Write( "0x");
        pStream->Write( TempBuf[ i ] );
        pStream->Write( TempBuf[ i+1 ] );
        if( i < (6+2)*2-2 )
            pStream->Write( ',' );
        }

    pStream->Write( ");" );
    pStream->NewLine();
}

void
Out_Guid(
    CCB     *   pCCB,
    GUID_STRS & GStrs,
    GUIDFORMAT  format)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a guid structure.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pGString1   - Partial guid strings.
    format      - Output format ( MIDL_DEFINE_GUID or const IID = )

 Return Value:

 Notes:

    This routine emits a guid as a inited structure along with the proper
    matched bracing.

    No checks are made for the validity of the string. The front-end has done
    that.

    All strings are emitted with a leading 0x.

    The 5 strings are treated this way:

        1 - 3. Emitted as such
        4 - 5. Broken into and emitted as byte hex values, without
               transformation, so they are just picked up and written out.
----------------------------------------------------------------------------*/
{
    char        TempBuf[ 256 ];
    ISTREAM *   pStream = pCCB->GetStream();

    if ( !GStrs.str1 )
        GStrs.str1 = "00000000";
    if ( !GStrs.str2 )
        GStrs.str2 = "0000";
    if ( !GStrs.str3 )
        GStrs.str3 = "0000";
    if ( !GStrs.str4 )
        GStrs.str4 = "00000000";
    if ( !GStrs.str5 )
        GStrs.str5 = "00000000";

    if (GUIDFORMAT_RAW != format)
        pStream->Write( '{' );

    sprintf( TempBuf, "0x%s,0x%s,0x%s", GStrs.str1, GStrs.str2, GStrs.str3 );
    pStream->Write( TempBuf );

    //
    // Each of the above strings are just broken down into six 2 byte
    // characters with 0x preceding them.
    //

    strcpy( TempBuf, GStrs.str4 );
    strcat( TempBuf, GStrs.str5 );

    pStream->Write( "," );
    if (GUIDFORMAT_RAW != format)
        pStream->Write( "{" );

    //
    // We will use the iteration counter to index into the string. Since we
    // need 2 per iteration, double the counter. Also pGString4 is actually
    // a 16 bit qty.
    //

    for( int i = 0; i < (6+2)*2 ; i += 2 )
        {
        pStream->Write( "0x");
        pStream->Write( TempBuf[ i ] );
        pStream->Write( TempBuf[ i+1 ] );
        if( i < (6+2)*2-2 )
            pStream->Write( ',' );
        }

    if (GUIDFORMAT_RAW != format)
        pStream->Write( "}}" );
}

void
Out_IFInfo(
    CCB             *   pCCB,
    char            *   pIntInfoTypeName,
    char            *   pIntInfoVarName,
    char            *   pIntInfoSizeOfString,
    GUID_STRS       &   UserGuidStr,
    unsigned short      UserMajor,
    unsigned short      UserMinor,
//    GUID_STRS       &   XferGuidStr,
//    unsigned short      XferSynMajor,
//    unsigned short      XferSynMinor,
    char            *   pCallbackDispatchTable,
    int                 ProtSeqEPCount,
    char            *   ,
    char            *   ,
    BOOL                fNoDefaultEpv,
    BOOL                fSide,
    BOOL                fHasPipes
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Arguments:

    pCCB                    - Ptr to code gen controller block.
    pIntInfoTypeName        - Client InterfaceInfo type name string.
    pIntInfoVarName         - Client InterfaceInfo variable name string.
    pIntInfoSizeOfString    - string sizeof interface.
    UserGuidStr             - User specified Guid string components.
    UserMajor               - User specified major interface version
    UserMinor               - User specified minor interface version
    XferGuidStr             - Xfer syntax identifying Guid string components.
    XferSynMajor            - Transfre syntax major version
    XferSynMinor            - Transfre syntax minor version
    pCallbackDispatchTable  - A pointer to the call back dispatch table name.
    ProtSeqEPCount          - ProtSeq endpoint count.
    ProtSeqEPTypeName       - Protseq endpoint Type name.
    ProtSeqEPVarName        - Protseq endpoint variable name.
    fNoDefaultEpv           - No default epv switch specicied.
    fSide                   - The server side (1) or client side(0)
    fHasPipes               - TRUE if any proc in the Interface has pipes

 Return Value:

    None.

 Notes:

    I'm tired already specifying so many params !
----------------------------------------------------------------------------*/
{
    CSzBuffer TempBuf;
    ISTREAM *   pStream = pCCB->GetStream();
    unsigned int RpcIntfFlag = 0;

    pStream->NewLine( 2 );
    TempBuf.Set( "static const " );
    TempBuf.Append( pIntInfoTypeName );
    TempBuf.Append( " " );
    TempBuf.Append( pCCB->GetInterfaceName() );
    TempBuf.Append( pIntInfoVarName );
    TempBuf.Append( " =" );

    pStream->Write( TempBuf );

    pStream->IndentInc();

    pStream->NewLine();
    pStream->Write( '{' );

    pStream->NewLine();

    TempBuf.Set( pIntInfoSizeOfString );
    TempBuf.Append( "," );

    pStream->Write( TempBuf );

    //
    // Emit the guid.
    //

    pStream->NewLine();
    pStream->Write( '{' );
    Out_Guid( pCCB,
              UserGuidStr
            );

    //
    // Emit the interface version specified by the user.
    //

    TempBuf.Set( ",{" );
    TempBuf.Append( UserMajor );
    TempBuf.Append( "," );
    TempBuf.Append( UserMinor );
    TempBuf.Append( "}" );
    pStream->Write( TempBuf );
    pStream->Write( "}," );

    //
    // Emit the xfer syntax guid.
    //

    pStream->NewLine();
    if ( pCommand->GetDefaultSyntax() == SYNTAX_DCE )
        Out_TransferSyntax( pCCB,
				TransferSyntaxGuidStrs,			// ndr identifying guid.
				NDR_UUID_MAJOR_VERSION,			// ndr's version
				NDR_UUID_MINOR_VERSION );
    else
        {
        if ( pCommand->IsSwitchDefined( SWITCH_INTERNAL ) && 
             pCommand->GetEnv() == ENV_WIN32 )            
            Out_TransferSyntax( pCCB,
                        FakeNDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        else
            Out_TransferSyntax( pCCB,
				NDR64TransferSyntaxGuidStrs,			// ndr identifying guid.
				NDR64_UUID_MAJOR_VERSION,			// ndr's version
				NDR64_UUID_MINOR_VERSION );
	    }
        
    pStream->Write( ',' );
                        
                        

    //
    // Emit the callback dispatch table address, if none, emit a NULL
    //
    pStream->NewLine();
    if( pCallbackDispatchTable )
        {
        pStream->Write( pCallbackDispatchTable );
        }
    else
        {
        pStream->Write( '0' );
        }
    pStream->Write( ',' );

    //
    // If there is a protseq ep count, emit a pointer to the ep table
    // else emit a null.
    //

    pStream->NewLine();

    if( ProtSeqEPCount )
        {
        TempBuf.Set(",");
        TempBuf.Prepend(ProtSeqEPCount);
//        sprintf( TempBuf, "%d,", ProtSeqEPCount );
        pStream->Write( TempBuf );
        pStream->NewLine();
        pStream->Write( "__RpcProtseqEndpoint," );
        }
    else
        {
        pStream->Write( "0," );
        pStream->NewLine();
        pStream->Write( "0," );
        }

    pStream->NewLine();

    if( fNoDefaultEpv )
        {
        if( fSide == 1 )
            {
            TempBuf.Set( "(" );
            TempBuf.Append( pCCB->GetInterfaceName() );
            TempBuf.Append( pCCB->GenMangledName() );
            TempBuf.Append( "_" );
            TempBuf.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );
            TempBuf.Append( " *) " );
            // c compiler doesn't like to convert int to pointer in 64bit. 
            // this is checked in runtime. runtime will throw if user doesn't change
            // this when calling RpcRegisterServerIfx. 
            if ( pCommand->Is32BitEnv() )
                TempBuf.Append( "0xffffffff" );
            else
                TempBuf.Append( "0xffffffffffffffff" );
            
            pStream->Write( TempBuf );
            }
        else
            {
            pStream->Write( '0' );
            }
        }
    else if( pCCB->IsMEpV() )
        {
        if( fSide == 1)
            pStream->Write( "&DEFAULT_EPV" );
        else
            pStream->Write( '0' );
        }
    else
        {
        pStream->Write('0');
        }

    //
    // Intepreter info.
    //
    pStream->Write( ',' );
    pStream->NewLine();

    if ( ( pCCB->GetCodeGenSide() == CGSIDE_SERVER &&
           pCCB->GetInterfaceCG()->HasInterpretedProc() ) ||
         ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT &&
           pCCB->GetInterfaceCG()->HasInterpretedCallbackProc() ) )
        {
        RpcIntfFlag |= RPCFLG_HAS_CALLBACK;
        pStream->Write( '&' );
        pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
        pStream->Write( SERVER_INFO_VAR_NAME );
        }
    else if ( pCommand->NeedsNDR64Run() )
        {
        pStream->Write( '&' );
        pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
        pStream->Write( MIDL_PROXY_INFO_VAR_NAME );
        }
        else 
        {
        pStream->Write( '0' );
        }

    //
    // Emit flags
    //
    pStream->Write( ',' );
    pStream->NewLine();
    
    if (fHasPipes)
        {
        RpcIntfFlag |= RPC_INTERFACE_HAS_PIPES;
        }
        
    if ( pCommand->NeedsBothSyntaxes() )
        {
        RpcIntfFlag |= RPCFLG_HAS_MULTI_SYNTAXES;
        }

    pStream->WriteNumber( "0x%08x",(unsigned long )RpcIntfFlag );
    
    //
    // All Done. Phew !!
    //

    pStream->NewLine();
    pStream->Write( "};" );
    pStream->IndentDec();
}

void Out_OneSyntaxInfo( CCB * pCCB,
                        BOOL IsForCallback,
                        SYNTAX_ENUM syntaxType )
{
    ISTREAM *pStream = pCCB->GetStream();
    char                Buffer[_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];

    pStream->Write( "{" );
    pStream->NewLine();
    
    if ( syntaxType == SYNTAX_NDR64 )
        {
        if ( pCommand->IsSwitchDefined( SWITCH_INTERNAL ) && 
             pCommand->GetEnv() == ENV_WIN32 )            
            Out_TransferSyntax( pCCB,
                        FakeNDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        else
            Out_TransferSyntax( pCCB,
                        NDR64TransferSyntaxGuidStrs,
                        NDR64_UUID_MAJOR_VERSION,
                        NDR64_UUID_MINOR_VERSION );
        
        }
    if ( syntaxType == SYNTAX_DCE )
        Out_TransferSyntax( pCCB,
                        TransferSyntaxGuidStrs,
                        NDR_UUID_MAJOR_VERSION,
                        NDR_UUID_MINOR_VERSION );

                        
    pStream->Write( ',' );

    // yongqu: DispatchTable: we need only one dispatch table for now.

    // we need to generate dispatch table for syntax_info in MIDL_SERVER_INFO, where
    // runtime will use it to dispatch call. This include regular server side syntaxinfo
    // and client side callback syntax info. 
    if ( ! pCCB->GetInterfaceCG()->IsObject() && 
         ( ( ( pCCB->GetCodeGenSide() == CGSIDE_SERVER ) && !IsForCallback ) ||
         ( ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) && IsForCallback ) ) )
        {
        pStream->WriteOnNewLine( "&" );
        sprintf( Buffer, 
                "%s%s%s%_DispatchTable,",
                pCCB->GetInterfaceName(),
                ( syntaxType == SYNTAX_NDR64 )?"_NDR64_":"",
                pCCB->GenMangledName() );

        pStream->Write(Buffer );
        }
    else 
        pStream->WriteOnNewLine( "0," );
        
    pStream->NewLine();

    // proc format string.
    if ( syntaxType == SYNTAX_DCE )
        {
        pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
        }
    else
        {
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );
        }
    pStream->Write( ',' );
    pStream->NewLine();

    // The reference to the proc offset table

    if ( SYNTAX_NDR64 == syntaxType)
        pStream->Write( "(unsigned short *) " );

    if ( pCCB->GetInterfaceCG()->IsObject() )
        pStream->Write( '&' );
    
    if ( IsForCallback )
        pStream->Write( MIDL_CALLBACK_VAR_NAME );
        
    pStream->Write( pCCB->GetInterfaceCG()->GetSymName() );

    if ( syntaxType == SYNTAX_DCE )
        pStream->Write( FORMAT_STRING_OFFSET_TABLE_NAME );
    else
        pStream->Write( "_Ndr64ProcTable" );

    if ( pCCB->GetInterfaceCG()->IsObject() )
        pStream->Write( "[-3]," );
    else    
        pStream->Write( ',' );
    pStream->NewLine();

    //

    if ( syntaxType == SYNTAX_DCE )
        {
        pStream->Write( FORMAT_STRING_STRING_FIELD );
        }
    else
        pStream->Write( "(unsigned char *) &NDR64_MIDL_FORMATINFO" );

    pStream->Write( ',' );

    // TODO: Usermarshal routines?
    pStream->NewLine();

    if ( pCCB->HasQuadrupleRoutines() )
        {
        if ( syntaxType == SYNTAX_DCE )
            pStream->Write( USER_MARSHAL_ROUTINE_TABLE_VAR );
        else
            pStream->Write( NDR64_USER_MARSHAL_ROUTINE_TABLE_VAR );            
        pStream->Write( "," );
        }
    else
        pStream->Write( "0," );
        
    pStream->WriteOnNewLine( "0," );
    pStream->WriteOnNewLine( "0" );

    pStream->NewLine();
    pStream->Write( "}" );
    pStream->NewLine();

   
}


// separate out because this is being called from multiple places.
void 
Out_TransferSyntax(
    CCB *               pCCB,
    GUID_STRS       &   XferGuidStr,
    unsigned short      XferSynMajor,
    unsigned short      XferSynMinor )
{
    CSzBuffer TempBuf;
    ISTREAM *pStream = pCCB->GetStream();
   
    pStream->Write( '{' );
    Out_Guid( pCCB,
              XferGuidStr
            );

    //
    // Emit the interface version specified by the user.
    //

    TempBuf.Set( ",{" );
    TempBuf.Append( XferSynMajor );
    TempBuf.Append( "," );
    TempBuf.Append( XferSynMinor );
    TempBuf.Append( "}" );
    pStream->Write( TempBuf );
    pStream->Write( "}" );
}    

void
Out_MarshallSimple(
    CCB         *   pCCB,
    RESOURCE    *   pResource,
    node_skl    *   pType,
    expr_node  *   pSource,
    BOOL            fIncr,
    unsigned short  Size )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate marshalling for a type of a given alignment.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pResource   - The marshalling buffer pointer resource.
    pType       - A pointer to the type of the entity being marshalled.
    pSource     - A pointer to the expression representing the source of
                  the marshalling.
    fIncr       - Output pointer increment code.
    Size        - The target alignment.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    BOOL        fUnsigned   = pType->FInSummary( ATTR_UNSIGNED );
    CSzBuffer   TempBuf;
    ISTREAM *   pStream = pCCB->GetStream();
    char    *   pRtn;

    switch( Size )
        {
        case 1: pRtn = "char"; break;
        case 2: pRtn = "short"; break;
        case 4: pRtn = "long"; break;
        case 8: pRtn = "hyper";break;
        default: break;
        }

    pStream->NewLine();

    TempBuf.Set( "*((" );
    if (fUnsigned)
        TempBuf.Append( "unsigned " );
    TempBuf.Append( pRtn );
    TempBuf.Append( "*)" );
    TempBuf.Append( pResource->GetResourceName() );
    TempBuf.Append( ")" );
    if (fIncr)
        TempBuf.Append( "++" );
    TempBuf.Append( " = " );

    pStream->Write( TempBuf );
    pSource->Print( pStream );
    pStream->Write(';');
}

void
Out_AddToBufferPointer(
    CCB         *   pCCB,
    expr_node  *   pSource,
    expr_node  *   pExprAmount )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a force alignment by the specified alignment.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pSource     - A source pointer
    pExprAmount - The amount to add

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr;

    pStream->NewLine();
    pExpr   = new expr_b_arithmetic( OP_PLUS,
                                      pSource,
                                      pExprAmount
                                    );
    pExpr   = new expr_assign( pSource, pExpr );
    pExpr->Print( pStream );
    pStream->Write(';');
}

void
Out_DispatchTableStuff(
    CCB     *   pCCB,
    ITERATOR&   ProcList,
    short       CountOfProcs)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the dispatch table and related data structures.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    ProcList    - A list of all the procedure names in the dispatch table.
    CountOfProcs- The number of procedures in the list.

 Return Value:

    None.

 Notes:

    Generate the dispatch table entries and then the dispatch table stuff.

----------------------------------------------------------------------------*/
{
//    if ( !pCommand->IsFinalProtocolRun() )
//        return;

    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuf;
    unsigned short M, m;

    pStream->NewLine();


    //
    // Generate the dispatch table structure name. Currently we just do
    // simple name mangling. This needs to be changed for dce stuff.
    //

    TempBuf.Set( "static " );
    TempBuf.Append( RPC_DISPATCH_FUNCTION_TYPE_NAME );
    TempBuf.Append( " " );
    TempBuf.Append( pCCB->GetInterfaceName() );
    if ( pCommand->IsNDR64Run() )
        TempBuf.Append( "_NDR64_" );

    TempBuf.Append( "_table[] =" );

    pStream->Write( TempBuf );

    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();

    //
    // Now print out the names of all the procedures.
    //

    ITERATOR_INIT( ProcList );

    for( int i = 0; i < CountOfProcs; ++i )
        {
        DISPATCH_TABLE_ENTRY    *   p;
        node_skl                *   pNode;

        ITERATOR_GETNEXT( ProcList, p );

        if ( p->Flags & DTF_PICKLING_PROC )
            pStream->Write( '0' );

//  BUGBUG: yongqu: code cleanup needed.
// -----------------------------------------------------------------
//      Server dispatch routine names:
//  raw rpc:
//      sync interface
//          ndr64 only:     NdrServerCallNdr64
//          ndr20 only:     NdrServerCall2
//          both syntaxes:  NdrServerCallAll
//      async interface
//          ndr64 only:     Ndr64AsyncServerCall64
//          ndr20 only:     NdrAsyncServerCall
//          both syntaxes:  Ndr64AsyncServerCallAll
//  ORPC:
//      sync interface
//          ndr64 only:     NdrStubCall3
//          both syntaxes:  NdrStubCall3
//          ndr20 only:     NdrStubCall2
//      async interface
//          ndr64 only:     NdrDcomAsyncStubCall
//          ndr20 only:     NdrDcomAsyncStubCall
//          both syntaxes:  NdrDcomAsyncStubCall
//
// reason for so many different entries:
//      In raw RPC, there is one dispatch table for each transfer syntax. RPC runtime
//      will call into the right dispatch table according to the syntax being used.
//      for raw rpc interface, we want to improvement server performance. 
//      after runtime select the right transfer syntax and called into 
//      right dispatch table, we know where MIDL_SYNTAX_INFO is and we can 
//      pickup the right format string etc. directly.
// 
//      In ORPC, all calls will be forwarded to the stub's Invoke, so we don't know
//      which transfer syntax is being used when ole dispatch the call to engine. 
//      we need to find out the selected syntax anyway. 
//      
// ------------------------------------------------------------------
#ifndef TEMPORARY_OI_SERVER_STUBS
        else if ( p->Flags & DTF_INTERPRETER )
            {
            if ( ((node_proc *)p->pNode)->HasAsyncUUID() )
                {
                if ( pCommand->IsNDR64Run() )
                    pStream->Write( S_NDR64_CALL_RTN_NAME_DCOM_ASYNC );
                else
                    pStream->Write( S_NDR_CALL_RTN_NAME_DCOM_ASYNC );
                }
            else if ( ((node_proc *)p->pNode)->HasAsyncHandle() )
                {
                if ( pCommand->IsNDR64Run() )
                    {
                    if ( pCommand->NeedsBothSyntaxes() )
                        pStream->Write( S_ALL_CALL_RTN_NAME_ASYNC );
                    else
                        pStream->Write( S_NDR64_CALL_RTN_NAME_ASYNC );
                    }
                else
                    pStream->Write( S_NDR_CALL_RTN_NAME_ASYNC );
                }
            else if ( ((node_proc *)p->pNode)->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
                {
                if ( pCommand->IsNDR64Run() )
                    {
                    if ( pCommand->NeedsBothSyntaxes() )
                        pStream->Write( S_ALL_CALL_RTN_NAME );
                    else
                        pStream->Write( S_NDR64_CALL_RTN_NAME );
                    }
                else
                    pStream->Write( S_NDR_CALL_RTN_NAME_V2 );
                }
            else
                pStream->Write( S_NDR_CALL_RTN_NAME );
            }
#endif // TEMPORARY_OI_SERVER_STUBS

        else
            {

            pNode = p->pNode;

            TempBuf.Set( pCCB->GetInterfaceName() );
            TempBuf.Append( "_" );
            TempBuf.Append( pNode->GetSymName() );

            pStream->Write( TempBuf );
            }
        pStream->Write( ',' );
        pStream->NewLine();
        }

    //
    // Write out a null and the closing brace.
    //

    pStream->Write( '0' ); pStream->NewLine();
    pStream->Write( "};" );

    pStream->IndentDec();

    //
    // Write out the dispatch table.
    //

    pCCB->GetVersion( &M, &m );

    pStream->NewLine();

    TempBuf.Set( RPC_DISPATCH_TABLE_TYPE_NAME );
    TempBuf.Append( " " );
    TempBuf.Append( pCCB->GetInterfaceName() );
    if ( pCommand->IsNDR64Run() )
        TempBuf.Append( "_NDR64_" );
    TempBuf.Append( pCCB->GenMangledName() );
    TempBuf.Append( "_DispatchTable = " );

    pStream->Write( TempBuf );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->NewLine();

    TempBuf.Set( "" );
    TempBuf.Append( CountOfProcs );
    TempBuf.Append( "," );

    pStream->Write( TempBuf );
    pStream->NewLine();

    TempBuf.Set( pCCB->GetInterfaceName() );
    if ( pCommand->IsNDR64Run() )
        TempBuf.Append( "_NDR64_" );   
    TempBuf.Append( "_table" );

    pStream->Write( TempBuf ); pStream->NewLine(); pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();


}

void
Out_CallManager(
    CCB         *   pCCB,
    expr_proc_call *   pProcExpr,
    expr_node      *   pRet,
    BOOL                fIsCallback )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pProcExpr   - A pointer to the complete procedure expression.
    pRet        - An optional pointer to ther return variable.
    fIsCallback - Is this a callback proc ?

 Return Value:

    None.
 Notes:

    Emit code to check for the manager epv also.
----------------------------------------------------------------------------*/
{
    expr_node  *   pAss    = pProcExpr;
    expr_node  *   pExpr;
    CSzBuffer       Buffer;
    ISTREAM     *   pStream = pCCB->GetStream();
    unsigned short  M, m;
    char        *   pTemp;
    short           Indent  = 0;

    pCCB->GetStream()->NewLine();

    // If he specified the -epv flag, then dont generate the call to the
    // static procedure. This is the opposite of the dce functionality.

    //
    // In case of -epv:
    //   ((interface_...) -> proc( ... );
    // else
    //   proc ( ... );
    //

    if( pCCB->IsMEpV() && !fIsCallback  )
        {
        pCCB->GetVersion( &M, &m );

        Buffer.Set( "((" );
        Buffer.Append( pCCB->GetInterfaceName() );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );
        Buffer.Append( " *)(" );
        Buffer.Append( PRPC_MESSAGE_MANAGER_EPV_NAME );
        Buffer.Append( "))" );

        pTemp = new char [ strlen( Buffer ) + 1 ];
        strcpy( pTemp, Buffer );

        pExpr = new expr_variable( pTemp );//this has the rhs expr for the
                                           // manager epv call. Sneaky !
        pExpr = new expr_pointsto( pExpr, pProcExpr );
        pAss = pExpr;
        if( pRet )
            {
            pAss    = new expr_assign( pRet, pExpr );
            Indent  = 7;        // sizeof "_RetVal"
            }
        pStream->NewLine();
        }
    else
        {
        pAss = pProcExpr;
        if( pRet )
            {
            pAss    = new expr_assign( pRet, pProcExpr );
            Indent  = 7;        // sizeof "_RetVal"
            }
        pStream->NewLine();
        }
    pAss->PrintCall( pStream, Indent, 0 );


}

void
Out_FormatInfoExtern( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration for the FormatInfo.
    (64bit format string)

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/

{
    ISTREAM *   pStream = pCCB->GetStream();
    
    if ( pCommand->NeedsNDR64Run() )
        {
        pStream->NewLine();

        // BUGBUG: We really don't need this anymore.
        pStream->WriteOnNewLine( 
                        "static const int NDR64_MIDL_FORMATINFO = 0;" );
        }
}

void
Out_TypeFormatStringExtern( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration of the global type format string.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->NewLine( 1 );
        pStream->Write( "extern const " FORMAT_STRING_TYPE_NAME " " );
        pStream->Write( FORMAT_STRING_STRUCT_NAME ";" );
        }
}


void
Out_ProcFormatStringExtern( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration of the interface-wide
    procedure/parameter format string.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    if ( pCommand->NeedsNDRRun() )
        {
        pStream->NewLine( 1 );
        pStream->Write( "extern const " PROC_FORMAT_STRING_TYPE_NAME " " );
        pStream->Write( PROC_FORMAT_STRING_STRUCT_NAME ";" );
        }
}


void
Out_StubDescriptorExtern(
    CCB *           pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates the forward extern declaration of the global stub descriptor
    variable.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine( 2 );

    pStream->Write( "extern const " STUB_DESC_STRUCT_TYPE_NAME );

    pStream->Write( ' ' );

    pStream->Write( pCCB->GetInterfaceCG()->GetStubDescName() );
    pStream->Write( ';' );

    pStream->NewLine();
}

void 
Out_ProxyInfoExtern( CCB * pCCB )
{
    ISTREAM * pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write( " extern const " MIDL_PROXY_INFO_TYPE_NAME );

    pStream->Write( ' ' );
    pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
    pStream->Write( MIDL_PROXY_INFO_VAR_NAME );
    pStream->Write( ';' );
}


void
Out_InterpreterServerInfoExtern( CCB * pCCB )
{
    ISTREAM * pStream;

    pStream = pCCB->GetStream();

    pStream->NewLine( 2 );

    pStream->Write( "extern const " SERVER_INFO_TYPE_NAME );

    pStream->Write( ' ' );

    pStream->Write( pCCB->GetInterfaceCG()->GetType()->GetSymName() );
    pStream->Write( SERVER_INFO_VAR_NAME );
    pStream->Write( ';' );
}

void
Out_NdrMarshallCall( CCB *      pCCB,
                     char *     pRoutineName,
                     char *     pParamName,
                     long       FormatStringOffset,
                     BOOL       fTakeAddress,
                     BOOL       fDereference )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Ouputs a call to an Ndr marshalling routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "Marshall")
    pParamName          - the name of the parameter/variable being marshalled
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 10); // strlen("Marshall( ");

    pStream->Write( pRoutineName );
    pStream->Write( "Marshall( (PMIDL_STUB_MESSAGE)& "STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    if ( fDereference )
        pStream->Write( '*' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();
}

void
Out_NdrUnmarshallCall( CCB *        pCCB,
                       char *       pRoutineName,
                       char *       pParamName,
                       long         FormatStringOffset,
                       BOOL         fTakeAddress,
                       BOOL         fMustAllocFlag )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to an Ndr unmarshalling routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "Unmarshall")
    pParamName          - the name of the parameter/variable being unmarshalled
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces = 0;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 12); // strlen("Unmarshall( ");

    pStream->Write( pRoutineName );
    pStream->Write( "Unmarshall( (PMIDL_STUB_MESSAGE) &"STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char * *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d],", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char)" );
    pStream->Write( fMustAllocFlag ? "1" : "0" );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_NdrBufferSizeCall( CCB *        pCCB,
                       char *       pRoutineName,
                       char *       pParamName,
                       long         FormatStringOffset,
                       BOOL         fTakeAddress,
                       BOOL         fDereference,
                       BOOL         fPtrToStubMsg )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to an Ndr buffer sizing routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "BufferSize")
    pParamName          - the name of the parameter/variable being sized
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins
    fPtrToStubMsg       - defines how the StubMsg should be referenced to
                            FALSE:  &_StubMsg
                            TRUE :  pStupMsg

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 12); // strlen("BufferSize( ");

    // Stub message
    pStream->Write( pRoutineName );
    pStream->Write( fPtrToStubMsg ? "BufferSize( (PMIDL_STUB_MESSAGE) "PSTUB_MESSAGE_PAR_NAME","
                                  : "BufferSize( (PMIDL_STUB_MESSAGE) &"STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    // Param
    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    if ( fDereference )
        pStream->Write( '*' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    // Format string
    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();
}

void
Out_NdrFreeCall( CCB *      pCCB,
                 char *     pRoutineName,
                 char *     pParamName,
                 long       FormatStringOffset,
                 BOOL       fTakeAddress,
                 BOOL       fDereference )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to an Ndr unmarshalling routine.

 Arguments:

    pStream             - the stream to write the output to
    pRoutineName        - the routine name (without the trailing "Free")
    pParamName          - the name of the parameter/variable being freed
    FormatStringOffset  - the offset into the format string where this
                          parameter's/variable's description begins

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Spaces;
    char            Buf[80];

    pStream->NewLine();

    Spaces = (unsigned short)(strlen(pRoutineName) + 6); // strlen("Free( ");

    pStream->Write( pRoutineName );
    pStream->Write( "Free( &"STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "(unsigned char *)" );
    if ( fTakeAddress )
        pStream->Write( '&' );
    if ( fDereference )
        pStream->Write( '*' );
    pStream->Write( pParamName );
    pStream->Write( ',' );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( '&' );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", FormatStringOffset );
    pStream->Write( Buf );
    pStream->NewLine();
}

void
Out_NdrConvert( CCB *           pCCB,
                long            FormatStringOffset,
                long            ParamTotal,
                unsigned short  ProcOptimFlags )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrConvert().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    char        Buf[80];

    pStream->NewLine();
    pStream->Write( "if ( ("  );
    pStream->Write( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT) ?
                        RPC_MESSAGE_VAR_NAME"." : PRPC_MESSAGE_VAR_NAME"->" );
    pStream->Write( "DataRepresentation & 0X0000FFFFUL) != "
                    "NDR_LOCAL_DATA_REPRESENTATION )" );
    pStream->IndentInc();
    pStream->NewLine();

    if ( ProcOptimFlags  &  OPTIMIZE_NON_NT351 )
        pStream->Write( NDR_CONVERT_RTN_NAME_V2 );
    else
        pStream->Write( NDR_CONVERT_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );

    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( PROC_FORMAT_STRING_STRING_FIELD );
    sprintf( Buf, "[%d]", FormatStringOffset );
    pStream->Write( Buf );

    //
    // NdrConvert2 takes a third parameter.
    //
    if ( ProcOptimFlags  &  OPTIMIZE_NON_NT351 )
        {
        sprintf( Buf, ", %d", ParamTotal );
        pStream->Write( Buf );
        }

    pStream->Write( " );" );

    pStream->IndentDec();
    pStream->NewLine();
}

void
Out_NdrNsGetBuffer( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrNsGetBuffer().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( AUTO_NDR_GB_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
    pStream->Write( STUB_MSG_LENGTH_VAR_NAME ", " );

    if( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
        {
        pStream->Write( pCCB->GetInterfaceName() );
        pStream->Write( AUTO_BH_VAR_NAME );
        }
    else
        pStream->Write( '0' );

    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_NdrGetBuffer( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrGetBuffer().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *       pStream = pCCB->GetStream();
    unsigned short  Env;

    Env = pCommand->GetEnv();

    if (pCCB->GetCodeGenSide() == CGSIDE_CLIENT)
        {
        pStream->NewLine();
        pStream->Write( DEFAULT_NDR_GB_RTN_NAME );
        pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
        pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
        pStream->Write( STUB_MSG_LENGTH_VAR_NAME ", " );

        if( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            pStream->Write( BH_LOCAL_VAR_NAME );
        else
            pStream->Write( '0' );

        pStream->Write( " );" );
        pStream->NewLine();
        }
    else
        {
        //
        // This saves us at least 15 instructions on an x86 server.
        //
        pStream->NewLine();
        pStream->Write( PRPC_MESSAGE_VAR_NAME "->BufferLength = "
                        STUB_MSG_LENGTH_VAR_NAME ";" );
        pStream->NewLine();
        pStream->NewLine();

        pStream->Write( RPC_STATUS_VAR_NAME" = I_RpcGetBuffer( "
                        PRPC_MESSAGE_VAR_NAME " ); ");
        pStream->NewLine();
        pStream->Write( "if ( "RPC_STATUS_VAR_NAME" )" );
        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write( "RpcRaiseException( "RPC_STATUS_VAR_NAME" );" );
        pStream->IndentDec();
        pStream->NewLine();
        pStream->NewLine();

        pStream->Write( STUB_MSG_BUFFER_VAR_NAME
                        " = (unsigned char *) "
                        PRPC_MESSAGE_VAR_NAME "->Buffer;" );
        pStream->NewLine();
        }
}

void
Out_NdrNsSendReceive( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrNsSendReceive().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( AUTO_NDR_SR_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
    pStream->Write( "(unsigned char *) "STUB_MESSAGE_VAR_NAME ".Buffer, " );
    pStream->Write( "(RPC_BINDING_HANDLE *) ""&" );
    pStream->Write( pCCB->GetInterfaceName() );
    pStream->Write( AUTO_BH_VAR_NAME );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_NdrSendReceive( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrSendReceive().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( DEFAULT_NDR_SR_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME ", " );
    pStream->Write( "(unsigned char *) "STUB_MESSAGE_VAR_NAME ".Buffer" );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_FreeParamInline( CCB *  pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Frees a top level param using the current stub message deallocator.

 Arguments:

    pCCB    - Code control block.

----------------------------------------------------------------------------*/
{
    CG_PARAM *  pParam;
    ISTREAM *   pStream;

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( "if ( " );
    pStream->Write( pParam->GetResource()->GetResourceName() );
    pStream->Write( " )" );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( STUB_MESSAGE_VAR_NAME ".pfnFree( " );
    pStream->Write( pParam->GetResource()->GetResourceName() );
    pStream->Write( " );" );

    pStream->IndentDec();
    pStream->NewLine();
}

void
Out_CContextHandleMarshall( CCB *   pCCB,
                            char *  pName,
                            BOOL    IsPointer )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node *        pHandle;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pCall = new expr_proc_call( "NdrClientContextMarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pHandle = new expr_variable( pName );

    if ( IsPointer )
        pHandle = new expr_u_deref( pHandle );

    pHandle = MakeExpressionOfCastToTypeName( CTXT_HDL_C_CONTEXT_TYPE_NAME,
                                              pHandle );

    pCall->SetParam( new expr_param( pHandle ) );

    pCall->SetParam( new expr_param(
                     new expr_variable( IsPointer ? "0" : "1" ) ) );

    pCall->PrintCall( pStream, 0, 0 );
}

void
Out_SContextHandleMarshall( CCB *   pCCB,
                            char *  pName,
                            char *  pRundownRoutineName )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node *        pHandle;
    expr_node *        pRoutine;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pCall = new expr_proc_call( "NdrServerContextMarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pHandle = new expr_variable( pName );

    pHandle = MakeExpressionOfCastToTypeName( CTXT_HDL_S_CONTEXT_TYPE_NAME,
                                              pHandle );

    pCall->SetParam( new expr_param( pHandle ) );

    pRoutine =  new expr_variable( pRundownRoutineName );

    pRoutine = MakeExpressionOfCastToTypeName( CTXT_HDL_RUNDOWN_TYPE_NAME,
                                               pRoutine );

    pCall->SetParam( new expr_param( pRoutine ) );

    pCall->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_SContextHandleNewMarshall( CCB *   pCCB,
                               char *  pName,
                               char *  pRundownRoutineName,
                               long    TypeOffset )
{
    ISTREAM *           pStream;
    unsigned short  Spaces;
    char            Buf[80];

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write( "NdrServerContextNewMarshall(" );
    pStream->NewLine();
    Spaces = 20;
    pStream->Spaces( Spaces );
    pStream->Write( "( PMIDL_STUB_MESSAGE )& "STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "( " CTXT_HDL_S_CONTEXT_TYPE_NAME " ) " );
    pStream->Write( pName );
    pStream->Write( "," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "( " CTXT_HDL_RUNDOWN_TYPE_NAME " ) " );
    pStream->Write( pRundownRoutineName );
    pStream->Write( "," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "(PFORMAT_STRING) &" );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", TypeOffset );
    pStream->Write( Buf );

    pStream->NewLine();
}

void
Out_CContextHandleUnmarshall( CCB *     pCCB,
                              char *    pName,
                              BOOL      IsPointer,
                              BOOL      IsReturn )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node *        pHandle;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    if ( IsPointer )
        {
        pStream->Write( '*' );
        pStream->Write( pName );
        pStream->Write( " = (void *)0;" );
        pStream->NewLine();
        }
    else if ( IsReturn )
        {
        pStream->Write( pName );
        pStream->Write( " = 0;" );
        pStream->NewLine();
        }

    pCall = new expr_proc_call( "NdrClientContextUnmarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pHandle = new expr_variable( pName );

    if ( ! IsPointer && IsReturn )
        pHandle = new expr_u_address( pHandle );

    pHandle = MakeExpressionOfCastPtrToType(
                    (node_skl *) new node_def(CTXT_HDL_C_CONTEXT_TYPE_NAME),
                    pHandle );

    pCall->SetParam( new expr_param( pHandle ) );

    CG_PROC * pProc;

    pProc = (CG_PROC *)pCCB->GetCGNodeContext();

    char * FullAutoHandleName = NULL;

    if ( pProc->IsAutoHandle() )
        {
        FullAutoHandleName = new char[ strlen( pCCB->GetInterfaceName()) +
                                       strlen( AUTO_BH_VAR_NAME ) + 1 ];
        strcpy( FullAutoHandleName, pCCB->GetInterfaceName() );
        strcat( FullAutoHandleName, AUTO_BH_VAR_NAME );
        }

    pCall->SetParam( new expr_param(
                     new expr_variable( pProc->IsAutoHandle()
                                            ? FullAutoHandleName
                                            : BH_LOCAL_VAR_NAME ) ) );

    pCall->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_SContextHandleUnmarshall( CCB *     pCCB,
                              char *    pName,
                              BOOL      IsOutOnly )
{
    ISTREAM *           pStream;
    expr_proc_call *   pCall;
    expr_node  *       pExpr;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    if ( IsOutOnly )
        {
        CSzBuffer Buffer;

        Buffer.Set( pName );
        Buffer.Append( " = NDRSContextUnmarshall( (uchar *)0, " );
        Buffer.Append( PRPC_MESSAGE_VAR_NAME "->DataRepresentation" );
        Buffer.Append( " );" );

        pStream->Write(Buffer);
        pStream->NewLine();

        return;
        }

    pCall = new expr_proc_call( "NdrServerContextUnmarshall" );

    pExpr = new expr_u_address( new expr_variable( STUB_MESSAGE_VAR_NAME ));
    pExpr = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME , pExpr );

    pCall->SetParam( new expr_param( pExpr ) );

    pExpr = new expr_variable( pName );

    pExpr = new expr_assign( pExpr, pCall );

    pExpr->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_SContextHandleNewUnmarshall( CCB *  pCCB,
                              char *    pName,
                              BOOL      IsOutOnly,
                              long      TypeOffset )
{
    ISTREAM *           pStream;
    unsigned short      Spaces;
    char                Buf[80];

    if ( IsOutOnly )
        return; 

    pStream = pCCB->GetStream();

    pStream->NewLine();

    pStream->Write( pName );
    pStream->Write( " = " );
    pStream->Write( "NdrServerContextNewUnmarshall(" );
    pStream->NewLine();
    Spaces = (unsigned short)(strlen( pName ) + 7);
    pStream->Spaces( Spaces );
    pStream->Write( "( PMIDL_STUB_MESSAGE )& "STUB_MESSAGE_VAR_NAME"," );
    pStream->NewLine();
    pStream->Spaces( Spaces );
    pStream->Write( "( PFORMAT_STRING )& " );
    pStream->Write( FORMAT_STRING_STRUCT_NAME );
    sprintf( Buf, ".Format[%d] );", TypeOffset );
    pStream->Write( Buf );

    pStream->NewLine();
}

void
Out_NdrFreeBuffer( CCB * pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Outputs a call to NdrFreeBuffer().

 Arguments:

    None.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( DEFAULT_NDR_FB_RTN_NAME );
    pStream->Write( "( (PMIDL_STUB_MESSAGE) &" );
    pStream->Write( STUB_MESSAGE_VAR_NAME );
    pStream->Write( " );" );
    pStream->NewLine();
}

void
Out_FullPointerInit( CCB * pCCB )
{
    ISTREAM *           pStream = pCCB->GetStream();
    expr_proc_call *   pProc;
    expr_node *        pExpr;

    pProc   = new expr_proc_call( FULL_POINTER_INIT_RTN_NAME );

    pProc->SetParam( new expr_param(
                     new expr_constant( (long) 0 ) ) );

    pProc->SetParam( new expr_param(
                     new expr_variable(
                        (pCCB->GetCodeGenSide() == CGSIDE_SERVER)
                            ? "XLAT_SERVER" : "XLAT_CLIENT" ) ) );

    pExpr = new expr_variable( STUB_MESSAGE_VAR_NAME ".FullPtrXlatTables" );

    pExpr = new expr_assign( pExpr, pProc );

    pStream->NewLine();

    pExpr->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_FullPointerFree( CCB * pCCB )
{
    ISTREAM *           pStream = pCCB->GetStream();
    expr_proc_call *   pProc;

    pProc   = new expr_proc_call( FULL_POINTER_FREE_RTN_NAME );

    pProc->SetParam( new expr_param(
                     new expr_variable(
                        STUB_MESSAGE_VAR_NAME ".FullPtrXlatTables" ) ) );

    pStream->NewLine();

    pProc->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
}

void
Out_NdrInitStackTop( CCB * pCCB )
{
    ISTREAM * pStream;

    pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( STUB_MESSAGE_VAR_NAME ".StackTop = 0;" );
    pStream->NewLine();
}


void
Out_DispatchTableTypedef(
    CCB     *   pCCB,
    PNAME       pInterfaceName,
    ITERATOR&   ProcNodeList,
    int         flag )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output the dispatch table typedef.

 Arguments:

    pCCB            - A pointer to the code gen controller block.
    pInterfacename  - The base interface name.
    ProcNodeList    - The list of procedure node_proc nodes.
    flag            - 0 : normal, 1 : callback

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM         *   pStream = pCCB->GetStream();
    CSzBuffer       Buffer;
    node_skl        *   pNode;
    node_pointer    *   pPtr;
    node_id         *   pID;
    unsigned short      M, m;
    DISPATCH_TABLE_ENTRY    *   pDEntry;

    if( flag == 1 )
        return;

    pCCB->GetVersion( &M, &m );

    pStream->NewLine();

    if( flag == 0 )
        {
        Buffer.Set( "typedef struct _" );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );

        pStream->Write( Buffer );
        pStream->NewLine();
        pStream->IndentInc();
        pStream->Write('{');
        pStream->NewLine();
        }
#if 0
    else
        {
        Buffer.Set( "typedef struct _" );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_CLIENT_EPV" );
        }
#endif // 0


    ITERATOR_INIT( ProcNodeList );
    while( ITERATOR_GETNEXT( ProcNodeList, pDEntry ) )
        {
        pNode = pDEntry->pNode;
        pID     = new node_id( pNode->GetSymName() );
        pPtr    = new node_pointer( pNode );
        pID->SetBasicType( pPtr );
        pPtr->SetBasicType( pNode );
        pID->SetEdgeType( EDGE_DEF );
        pPtr->SetEdgeType( EDGE_USE );

        pID->PrintType( PRT_PROC_PTR_PROTOTYPE, pStream, (node_skl *)0 );
        }

    pStream->NewLine();
    pStream->IndentDec();

    if( flag == 0 )
        {
        Buffer.Set( "} " );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( pCCB->IsOldNames() ?"SERVER_EPV" : "epv_t" );
        Buffer.Append( ";" );
        }
    else
        {
        Buffer.Set( "} " );
        Buffer.Append( pInterfaceName );
        Buffer.Append( pCCB->GenMangledName() );
        Buffer.Append( "_" );
        Buffer.Append( (flag == 0) ?"SERVER" : "CLIENT" );
        Buffer.Append( "_EPV;" );
        }
    pStream->Write( Buffer );
    pStream->NewLine();

}

void
Out_ManagerEpv(
    CCB     *   pCCB,
    PNAME       pInterfaceName,
    ITERATOR&   ProcNodeList,
    short       Count )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output the manager epv table.

 Arguments:

    pCCB            - A pointer to the code gen controller block.
    pInterfacename  - The base interface name.
    ProcNodeList    - The list of procedure node_proc nodes.
    Count           - Count of procs.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    if ( !pCommand->IsFinalProtocolRun() )
        return;

    ISTREAM         *   pStream = pCCB->GetStream();
    CSzBuffer       Buffer;
    unsigned short      M, m;
    DISPATCH_TABLE_ENTRY    *   pDEntry;

    pCCB->GetVersion( &M, &m );

    pStream->NewLine();

    Buffer.Set( "static " );
    Buffer.Append( pInterfaceName );
    Buffer.Append( pCCB->GenMangledName() );
    Buffer.Append( "_" );
    Buffer.Append( pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t" );
    Buffer.Append( " DEFAULT_EPV = " );

    pStream->Write( Buffer );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();

    ITERATOR_INIT( ProcNodeList );
    while( ITERATOR_GETNEXT( ProcNodeList, pDEntry ) )
        {
    char    *   pPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR );
        if ( pPrefix )
        pStream->Write( pPrefix );

        pStream->Write( pDEntry->pNode->GetSymName() );
        if( --Count != 0 )
            {
            pStream->Write( ',' );
            pStream->NewLine();
            }
        }

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "};" );
    pStream->NewLine();
}

void
Out_GenHdlPrototypes(
    CCB *   pCCB,
    ITERATOR& List )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a list of generic handle prototypes.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    List    - List of type nodes.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   Buffer;
    node_skl*   pN;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( List, pN ) )
        {
        PNAME   pName = pN->GetSymName();

        Buffer.Set( "handle_t __RPC_USER " );
        Buffer.Append( pName );
        Buffer.Append( "_bind  ( " );
        Buffer.Append( pName );
        Buffer.Append( " );" );
        pStream->Write( Buffer );
        pStream->NewLine();

        Buffer.Set( "void     __RPC_USER " );
        Buffer.Append( pName );
        Buffer.Append( "_unbind( " );
        Buffer.Append( pName );
        Buffer.Append( ", handle_t );" );
        pStream->Write( Buffer );
        pStream->NewLine();
        }
}

void
Out_CtxtHdlPrototypes(
    CCB *   pCCB,
    ITERATOR& List )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a list of context handle prototypes.

 Arguments:

    pCCB    - A pointer to the code gen controller block.
    List    - List of type nodes.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   Buffer;
    node_skl*   pN;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( List, pN ) )
        {
        PNAME   pName = pN->GetSymName();

        // A name can be a "" (an empty string).

        if ( strlen(pName) )
            {
            Buffer.Set( "void __RPC_USER " );
            Buffer.Append( pName );
            Buffer.Append( "_rundown( " );
            Buffer.Append( pName );
            Buffer.Append( " );" );
            pStream->Write( Buffer );
            pStream->NewLine();
            }
        }
}


void
Out_TransmitAsPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfPresentedTypes )
{
    ISTREAM *   pStream = pCCB->GetStream();
    ISTREAM *   pMemoryStream = new ISTREAM;
    CSzBuffer   Buffer;
    node_skl *  pXmittedType;
    node_skl *  pPresentedType;

    char *      pMemBufferStart = pMemoryStream->GetCurrentPtr();

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfPresentedTypes, pPresentedType ) )
        {
        // we reuse the same memory stream.
        pMemoryStream->SetCurrentPtr( pMemBufferStart );

        pXmittedType = ((node_def *)pPresentedType)->GetTransmittedType();

        PNAME   pPresentedTypeName  = pPresentedType->GetSymName();
        PNAME   pTransmittedTypeName= pXmittedType->GetSymName();

        pXmittedType->PrintType( PRT_TYPE_SPECIFIER,
                                 pMemoryStream,       // into stream
                                 (node_skl *)0        // no parent.
                               );
        //
        // The type spec is in the stream, except that it needs a terminating
        // null to use it as a string.
        //

        pTransmittedTypeName = pMemBufferStart;
        *(pMemoryStream->GetCurrentPtr()) = 0;

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_to_xmit( " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_from_xmit( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_free_inst( " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pPresentedTypeName );
        Buffer.Append( "_free_xmit( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        }

    delete pMemoryStream;
}


void
Out_RepAsPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfRepAsWireTypes )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   Buffer;
    node_skl *  pWireType;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfRepAsWireTypes, pWireType ) )
        {
        PNAME   pRepAsTypeName = ((node_def *)pWireType)->GetRepresentationName();
        PNAME   pTransmittedTypeName= pWireType->GetSymName();

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_from_local( " );
        Buffer.Append( pRepAsTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER ");
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_to_local( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " *, " );
        Buffer.Append( pRepAsTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set(" void __RPC_USER " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_free_inst( " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        Buffer.Set( "void __RPC_USER " );
        Buffer.Append( pTransmittedTypeName );
        Buffer.Append( "_free_local( " );
        Buffer.Append( pRepAsTypeName );
        Buffer.Append( " * );" );
        pStream->Write( Buffer );

        pStream->NewLine();
        }
    }



#define USRM_SIZE      0
#define USRM_FREE      3


char * UserMProtoName[ 4 ] =
    {
    USER_MARSHAL_SIZE "(     ",
    USER_MARSHAL_MARSHALL "(  ",
    USER_MARSHAL_UNMARSHALL "(",
    USER_MARSHAL_FREE "(     "
    };

char * NDR64_UserMProtoName[ 4 ] =
    {
    NDR64_USER_MARSHAL_SIZE "(     ",
    NDR64_USER_MARSHAL_MARSHALL "(  ",
    NDR64_USER_MARSHAL_UNMARSHALL "(",
    NDR64_USER_MARSHAL_FREE "(     "
    };

void
Out_UserMarshalSingleProto(
    ISTREAM *   pStream,
    char *      pTypeName,
    int         fProto,
    SYNTAX_ENUM SyntaxType )
{
    switch ( fProto )
        {
        case USRM_SIZE:
            pStream->Write( "unsigned long             __RPC_USER  " );
            break;
        case USRM_FREE:
            pStream->Write( "void                      __RPC_USER  " );
            break;
        default:
            pStream->Write( "unsigned char * __RPC_USER  " );
            break;
        }
    pStream->Write( pTypeName );
    if ( SyntaxType == SYNTAX_NDR64 )
        pStream->Write( NDR64_UserMProtoName[ fProto ] );
    else
        pStream->Write( UserMProtoName[ fProto ] );
        
    pStream->Write( "unsigned long *, " );  // flags
    switch ( fProto )
        {
        case USRM_SIZE:
            pStream->Write( "unsigned long            , " );
            break;
        case USRM_FREE:
            break;
        default:
            pStream->Write( "unsigned char *, " );
            break;
        }
    pStream->Write( pTypeName );
    pStream->Write( " * ); " );
    pStream->NewLine();
}

void
Out_OneUserMarshalProtoTypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfPresentedTypes,
    SYNTAX_ENUM SyntaxType )
{
    USER_MARSHAL_CONTEXT * pUsrContext;

    ISTREAM *   pStream = pCCB->GetStream();

    ITERATOR_INIT( ListOfPresentedTypes );
    
    while( ITERATOR_GETNEXT( ListOfPresentedTypes, pUsrContext ) )
        {
        pStream->NewLine();

        for (int i=0; i < 4; i++)
            Out_UserMarshalSingleProto( pStream,
                                       pUsrContext->pTypeName,
                                       i,
                                       SyntaxType );
        }

    
}

void
Out_UserMarshalPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfPresentedTypes )
{
    if ( pCommand->NeedsNDRRun() )
        Out_OneUserMarshalProtoTypes( pCCB, ListOfPresentedTypes, SYNTAX_DCE );

    if ( pCommand->NeedsNDR64Run() ||
         pCommand->NeedsNDR64Header() )
        Out_OneUserMarshalProtoTypes( pCCB, ListOfPresentedTypes, SYNTAX_NDR64 );
    
}


char CsNetSizePrototype[] = 
        "_net_size(\n"
        "        RPC_BINDING_HANDLE     hBinding,\n"
        "        unsigned long          ulNetworkCodeSet,\n"
        "        unsigned long          ulLocalBufferSize,\n"
        "        IDL_CS_CONVERT *       conversionType,\n"
        "        unsigned long *        pulNetworkBufferSize,\n"
        "        error_status_t *       pStatus);\n\n";

char CsLocalSizePrototype[] = 
        "_local_size(\n"
        "        RPC_BINDING_HANDLE     hBinding,\n"
        "        unsigned long          ulNetworkCodeSet,\n"
        "        unsigned long          ulNetworkBufferSize,\n"
        "        IDL_CS_CONVERT *       conversionType,\n"
        "        unsigned long *        pulLocalBufferSize,\n"
        "        error_status_t *       pStatus);\n\n";
        
char CsToNetCsPrototype[] =
        "_to_netcs(\n"
        "       RPC_BINDING_HANDLE      hBinding,\n"
        "       unsigned long           ulNetworkCodeSet,\n"
        "       void *                  pLocalData,\n"
        "       unsigned long           ulLocalDataLength,\n"
        "       byte *                  pNetworkData,\n"
        "       unsigned long *         pulNetworkDataLength,\n"
        "       error_status_t *        pStatus);\n\n";

char CsFromNetCsPrototype[] = 
        "_from_netcs(\n"
        "       RPC_BINDING_HANDLE      hBinding,\n"
        "       unsigned long           ulNetworkCodeSet,\n"
        "       byte *                  pNetworkData,\n"
        "       unsigned long           ulNetworkDataLength,\n"
        "       unsigned long           ulLocalBufferSize,\n"
        "       void *                  pLocalData,\n"
        "       unsigned long *         pulLocalDataLength,\n"
        "       error_status_t *        pStatus);\n\n";

void
Out_CSSizingAndConversionPrototypes(
    CCB        * pCCB,
    ITERATOR & types )
{
    PNAME     pTypeName;
    ISTREAM * pStream = pCCB->GetStream();

    ITERATOR_INIT( types );

    while ( ITERATOR_GETNEXT( types, pTypeName ) )
        {
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsNetSizePrototype );
    
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsLocalSizePrototype );
    
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsToNetCsPrototype );
    
        pStream->Write( "void __RPC_USER " );
        pStream->Write( pTypeName );
        pStream->Write( CsFromNetCsPrototype );
        }
}


void
Out_CallAsServerPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfCallAsRoutines )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    node_proc * pProc;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfCallAsRoutines, pProc ) )
        {
        // keep these on the stack...
        CSzBuffer           NewName;
        char                TempBuf[40];
        node_call_as    *   pCallAs = (node_call_as *)
                                            pProc->GetAttribute( ATTR_CALL_AS );
        unsigned short      M, m;
        node_interface  *   pIntf   = pProc->GetMyInterfaceNode();
    
        // don't emit the server prototype for object routines
        if ( pIntf->FInSummary( ATTR_OBJECT ) )
            continue;

        // local stub routine, with remote param list
        node_proc           NewStubProc( pProc );

        pIntf->GetVersionDetails( &M, &m );
        sprintf( TempBuf,
                "_v%d_%d",
                M,
                m );
        NewName.Set( pIntf->GetSymName() );
        NewName.Append( TempBuf );
        NewName.Append( "_" );
        NewName.Append( pCallAs->GetCallAsName() );

        NewStubProc.SetSymName( NewName );

        NewStubProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI,
                            pCCB->GetStream(),
                            NULL ,
                            pIntf );

        pCCB->GetStream()->NewLine();

        }
    }

void
Out_NotifyPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfNotifyProcedures)
/*
    We generate
        void  <proc_name>_notify( void );
        void  <proc_name>_notify_flag( boolean );

*/
    {
    ISTREAM *   pStream = pCCB->GetStream();
    CG_PROC   * pProcCG;
    node_proc * pProc;
    node_skl  * pRet;
    BOOL        fHasFlag;

    GetBaseTypeNode( &pRet, SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID );

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfNotifyProcedures, pProcCG ) )
        {
        // keep these on the stack...
        CSzBuffer           NewName;
        node_proc           NewStubProc( 0, 0 );
        node_param          FlagParam;

        fHasFlag = pProcCG->HasNotifyFlag();
        pProc    = (node_proc *) pProcCG->GetType();

        NewStubProc.SetChild( pRet );

        if ( fHasFlag )
            {
            node_skl  * pParamType;

            GetBaseTypeNode( &pParamType, SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN );

            FlagParam.SetChild( pParamType );
            FlagParam.SetSymName( NOTIFY_FLAG_VAR_NAME );
            
            NewStubProc.SetFirstMember( & FlagParam );
            }

        NewName.Set( pProc->GetSymName() );
        NewName.Append( (fHasFlag ? NOTIFY_FLAG_SUFFIX
                                  : NOTIFY_SUFFIX )  );
        NewStubProc.SetSymName( NewName );

        NewStubProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI,
                               pStream,
                               NULL );

        pCCB->GetStream()->NewLine();

        }
    }


void
Out_PatchReference(
    CCB     *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSrc,
    BOOL            fIncr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Output a patch of a pointer to the source pointer.

 Arguments:

    pCCB    - The cg cont. block.
    pDest   - The destination expression
    pSrc    - The source expression.
    fIncr   - Should we increment the ptr ?

 Return Value:

    None.

 Notes:

    Both the expressions must be pointers.
    Cast the source expression to the destination.
----------------------------------------------------------------------------*/
{
    ISTREAM     * pStream = pCCB->GetStream();

    node_skl    * pType = pDest->GetType();
    NODE_T        NT    = pType->NodeKind();
    expr_node  * pCast;
    expr_node  * pAss;

    if( (NT == NODE_ID) || (NT == NODE_PARAM) || (NT == NODE_FIELD) )
        {
        pType   = pType->GetBasicType();
        }

    pCast   = (expr_node *) new expr_cast( pType, pSrc );
    if( fIncr )
        pCast   = (expr_node *) new expr_post_incr( pCast );
    pAss    = (expr_node *) new expr_assign( pDest, pCast );
    pStream->NewLine();

    pAss->Print( pStream );
    pStream->Write(';');

}

void
Out_Endif( CCB * pCCB )
    {
    pCCB->GetStream()->NewLine();
    pCCB->GetStream()->Write( '}' );
    Out_IndentDec( pCCB );
    }

void
Out_If(
    CCB         *   pCCB,
    expr_node  *   pExpr )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( "if(" );
    pExpr->Print( pStream );
    pStream->Write( ')' );
    Out_IndentInc( pCCB );
    pStream->NewLine();
    pStream->Write( '{' );
    }
void
Out_Else(
    CCB         *   pCCB )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( "else" );
    Out_IndentInc( pCCB );
    pStream->NewLine();
    pStream->Write( '{' );
    }
void
Out_UniquePtrMarshall(
    CCB         *   pCCB,
    expr_node  *   pDestExpr,
    expr_node  *   pSrcExpr )
    {

    ISTREAM         *   pStream = pCCB->GetStream();
    expr_proc_call *   pProc;

    pStream->NewLine();

    pProc   = new expr_proc_call( MARSHALL_UNIQUE_PTR_RTN_NAME );

    pProc->SetParam(new expr_param( pDestExpr ));
    pProc->SetParam(new expr_param( pSrcExpr ));

    pProc->PrintCall( pStream, 0, 0 );
    }
void
Out_IfUniquePtrInBuffer(
    CCB         *   pCCB,
    expr_node  *   pSrc )
//
//  This appears to be a fossil. Ryszard 3/30/98.
//  However, the routine above appears to be used.
//
    {

    expr_proc_call *   pProc   = new expr_proc_call( CHECK_UNIQUE_PTR_IN_BUFFER );
    ISTREAM         *   pStream = pCCB->GetStream();

    pProc->SetParam( new expr_param( pSrc ) );

    pStream->NewLine();
    pStream->Write( "if(" );
    pProc->Print( pStream );
    pStream->Write( ')' );
    Out_IndentInc( pCCB );
    pStream->NewLine();
    pStream->Write( '{' );
    }

void
Out_Assign( CCB * pCCB,
            expr_node * pDest,
            expr_node * pSrc )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pDest->Print( pStream );
    pStream->Write( " = " );
    pSrc->Print( pStream );
    pStream->Write( ';' );
    }

void
Out_Memcopy(
    CCB *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSource,
    expr_node  *   pLength )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    expr_proc_call *   pCall   = new expr_proc_call( "memcpy" );

    pStream->NewLine();
    pCall->SetParam( new expr_param( pDest ) );
    pCall->SetParam( new expr_param( pSource ) );
    pCall->SetParam( new expr_param( pLength ) );
    pCall->PrintCall( pStream, 0, 0 );

    }
void
Out_strlen(
    CCB *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSource,
    unsigned short  Size )
    {
    ISTREAM *   pStream         = pCCB->GetStream();
    PNAME       pName           = (Size == 1) ? "strlen" : "MIDL_wchar_strlen";
    expr_proc_call *   pCall   = new expr_proc_call( pName );
    expr_node      *   pExpr;

    pStream->NewLine();
    pCall->SetParam( new expr_param( pSource ) );
    if( pDest )
        pExpr = new expr_assign( pDest, pCall );
    else
        pExpr = pCall;

    pExpr->PrintCall( pStream, 0, 0 );

    }
void
Out_For(
    CCB         *   pCCB,
    expr_node  *   pIndexExpr,
    expr_node  *   pInitialValue,
    expr_node  *   pFinalValue,
    expr_node  *   pIncrExpr )
    {

    ISTREAM     *   pStream = pCCB->GetStream();
    expr_node  *   pExpr;

    pStream->NewLine();
    pStream->Write( "for( " );

    pExpr   = new expr_assign( pIndexExpr, pInitialValue );
    pExpr->Print( pStream );
    pStream->Write( ';' );

    pExpr   = new expr_op_binary( OP_LESS, pIndexExpr, pFinalValue );
    pExpr->Print( pStream );
    pStream->Write( ';' );

    pExpr   = new expr_op_binary( OP_PLUS, pIndexExpr, pIncrExpr );
    pExpr   = new expr_assign( pIndexExpr, pExpr );
    pExpr->Print( pStream );
    pStream->Write( ')' );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
    }

void
Out_EndFor( CCB * pCCB )
    {
    pCCB->GetStream()->NewLine();
    pCCB->GetStream()->Write( '}' );
    Out_IndentDec( pCCB );
    }

void
Out_PlusEquals(
    CCB *   pCCB,
    expr_node  *pL,
    expr_node  *pR )
    {
    ISTREAM *   pStream = pCCB->GetStream();

    pStream->NewLine();
    pL->Print( pStream );
    pStream->Write( " += " );
    pR->Print( pStream );
    pStream->Write(';');

    }

void
Out_Comment(
    CCB     *   pCCB,
    char    *   pComment )
    {
    ISTREAM *   pStream = pCCB->GetStream();
    pStream->NewLine();
    pStream->Write( "/* " );
    pStream->Write( pComment );
    pStream->Write( " */" );

    }

void
Out_RpcSSEnableAllocate(
    CCB *   pCCB )
    {
    expr_proc_call * pCall = new expr_proc_call( RPC_SS_ENABLE_ALLOCATE_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCCB->GetStream()->NewLine();
    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_RpcSSSetClientToOsf(
    CCB *   pCCB )
    {
    expr_proc_call * pCall = new expr_proc_call( RPC_SM_SET_CLIENT_TO_OSF_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCCB->GetStream()->NewLine();
    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_RpcSSDisableAllocate(
    CCB *   pCCB )
    {
    expr_proc_call * pCall = new expr_proc_call( RPC_SS_DISABLE_ALLOCATE_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCCB->GetStream()->NewLine();
    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_MemsetToZero(
    CCB *   pCCB,
    expr_node  *   pDest,
    expr_node  *   pSize )
    {
    expr_proc_call *   pProc   = new expr_proc_call( (PNAME) MIDL_MEMSET_RTN_NAME );

    pProc->SetParam( new expr_param( pDest ) );
    pProc->SetParam( new expr_param( new expr_constant(0L) ) );
    pProc->SetParam( new expr_param( pSize ) );

    pCCB->GetStream()->NewLine();
    pProc->PrintCall( pCCB->GetStream(), 0, 0 );
    }

void
Out_CallAsProxyPrototypes(
    CCB     *   pCCB,
    ITERATOR&   ListOfCallAsRoutines )
/*++

Routine Description:

    This routine generates the call_as function prototypes.

    One for the proxy( with local param list )
    One for the stub( with remote param list )

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
    {
    ISTREAM *   pStream = pCCB->GetStream();
    node_proc * pProc;

    pStream->NewLine();

    while( ITERATOR_GETNEXT( ListOfCallAsRoutines, pProc ) )
    {
        node_interface  *   pIntf   = pProc->GetMyInterfaceNode();

        // skip for non-object routines
        if ( !pIntf->FInSummary( ATTR_OBJECT ) )
            continue;

        // keep these on the stack...
        CSzBuffer   NewName;
        node_call_as    *   pCallAs = (node_call_as *)
                                            pProc->GetAttribute( ATTR_CALL_AS );
        node_proc   NewProc( pCallAs->GetCallAsType() );

        // local proxy routine with local param list
        NewName.Set( pIntf->GetSymName() );
        NewName.Append( "_" );
        NewName.Append( pCallAs->GetCallAsName() );
        NewName.Append( "_Proxy" );

        NewProc.SetSymName( NewName );

        NewProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI | PRT_THIS_POINTER | PRT_FORCE_CALL_CONV,
                            pCCB->GetStream(),
                            NULL ,
                            pIntf );
        pStream->NewLine();

        // local stub routine, with remote param list
        node_proc   NewStubProc( pProc );
        NewName.Set( pIntf->GetSymName() );
        NewName.Append( "_" );
        NewName.Append( pCallAs->GetCallAsName() );
        NewName.Append( "_Stub" );

        NewStubProc.SetSymName( NewName );

        pStream->NewLine();
        NewStubProc.PrintType( PRT_PROC_PROTOTYPE_WITH_SEMI | PRT_THIS_POINTER | PRT_FORCE_CALL_CONV,
                            pStream,
                            NULL ,
                            pIntf );
        pStream->NewLine();

    }
}

void
CG_OBJECT_PROC::Out_ProxyFunctionPrototype(CCB *pCCB, PRTFLAGS F )
/*++

Routine Description:

    This routine generates a proxy function prototype.

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
{
    // keep these on the stack...
    CSzBuffer NewName;
    node_proc   *   pProc               = (node_proc *)GetType();
    node_proc       NewProc( pProc );

    NewName.Set( pCCB->GetInterfaceName() );
    NewName.Append( "_" );
    NewName.Append( pProc->GetSymName() );
    NewName.Append( "_Proxy" );

    NewProc.SetSymName( NewName );

    pCCB->GetStream()->NewLine();
    NewProc.PrintType( PRT_PROC_PROTOTYPE | PRT_THIS_POINTER | F | PRT_FORCE_CALL_CONV,
                        pCCB->GetStream(),
                        NULL ,
                        pCCB->GetInterfaceCG()->GetType() );

}


void
Out_IID(CCB *pCCB)
/*++

Routine Description:

    This routine generates an IID declaration for the current interface.

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        node_guid * pGuid = (node_guid *) ((node_interface *)pCCB->GetInterfaceCG()->GetType())->GetAttribute(ATTR_GUID);
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "IID_", pCCB->GetInterfaceName());
    }
    else
    {
        pStream->Write("EXTERN_C const IID IID_");
        pStream->Write(pCCB->GetInterfaceName());
        pStream->Write(';');
        pStream->NewLine();
    }
}

void
Out_CLSID(CCB *pCCB)
/*++

Routine Description:

    This routine generates an CLSID declaration for the current com class.

Arguments:

    pCCB    - a pointer to the code generation control block.

--*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("EXTERN_C const CLSID CLSID_");
    pStream->Write(pCCB->GetInterfaceName());
    pStream->Write(';');
    pStream->NewLine();
}


void
CG_OBJECT_PROC::Out_StubFunctionPrototype(CCB *pCCB)
{
    ISTREAM *   pStream = pCCB->GetStream();
    CSzBuffer   TempBuffer;

    TempBuffer.Set( "void __RPC_STUB " );
    TempBuffer.Append( pCCB->GetInterfaceName() );
    TempBuffer.Append( "_" );
    TempBuffer.Append( GetType()->GetSymName() );
    TempBuffer.Append( "_Stub(" );

    pStream->NewLine();
    pStream->Write( TempBuffer );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("IRpcStubBuffer *This,");
    pStream->NewLine();
    pStream->Write("IRpcChannelBuffer *_pRpcChannelBuffer,");
    pStream->NewLine();
    pStream->Write("PRPC_MESSAGE _pRpcMessage,");
    pStream->NewLine();
    pStream->Write("DWORD *_pdwStubPhase)");
    pStream->IndentDec();
}

void
CG_OBJECT_PROC::Out_ServerStubProlog(
    CCB     *   pCCB,
    ITERATOR&   LocalsList,
    ITERATOR&   TransientList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side procedure prolog.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    LocalsList  - A list of local resources.
    TransientList- A list of temp variables.

 Return Value:

 Notes:

    The server side procedure prolog generation cannot use the normal
    printtype method on the procedure node, since the server stub signature
    looks different.

    Also the name of the server side stub is mangled with the interface name.

    All server side procs are void returns.

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    RESOURCE*   pRes;

    Out_StubFunctionPrototype(pCCB);

    //
    // Write out the opening brace for the server proc and all that.
    //

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    //
    // This is where we get off for /Oi.  We have a special routine
    // for local variable declaration for /Oi.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return;

    //
    // Print out declarations for the locals.
    //

    if( ITERATOR_GETCOUNT( LocalsList ) )
        {
        ITERATOR_INIT( LocalsList );

        while( ITERATOR_GETNEXT( LocalsList, pRes ) )
            {
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            }
        }

    if( ITERATOR_GETCOUNT( TransientList ) )
        {
        ITERATOR_INIT( TransientList );

        while( ITERATOR_GETNEXT( TransientList, pRes ) )
            {
            pStream->IndentInc();
            pRes->GetType()->PrintType( PRT_ID_DECLARATION, // print decl
                                         pStream,        // into stream
                                         (node_skl *)0   // no parent.
                                      );
            pStream->IndentDec();
            }
        }

    pStream->IndentDec();
    pStream->NewLine();

    //
    // Done.
    //
}

void
Out_CallMemberFunction(
    CCB         *   pCCB,
    expr_proc_call *   pProcExpr,
    expr_node      *   pRet,
    BOOL                fThunk)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB        - A pointer to the code generation controller block.
    pProcExpr   - A pointer to the complete procedure expression.
    pRet        - An optional pointer to ther return variable.
    fThunk      - flag for "this call is in a thunk with a param struct"

 Return Value:

    None.

 Notes:

    //call server
    _RetVal = (((IClassFactory *) ((CStdStubBuffer*)This)->pvServerObject)->lpVtbl) -> LockServer((IClassFactory *) ((CStdStubBuffer *)This)->pvServerObject,fLock);

----------------------------------------------------------------------------*/
{
    expr_node  *   pAss    = pProcExpr;
    expr_node  *   pExpr;
    CSzBuffer   Buffer;
    ISTREAM     *   pStream = pCCB->GetStream();
    char        *   pTemp;

    if ( fThunk )
        {
        // ((IFoo*) ((CStdStubBuffer*)pParamStruct->This)->lpVtbl)->Bar();
        Buffer.Set( "((" );
        Buffer.Append( pCCB->GetInterfaceName() );
        Buffer.Append( "*) ((CStdStubBuffer*)pParamStruct->This)->lpVtbl)" );
        }
    else
        {
        // (((IFoo*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl)->Bar();
        Buffer.Set( "(((" );
        Buffer.Append( pCCB->GetInterfaceName() );
        Buffer.Append( "*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl)" );
        }

    pTemp = new char [ strlen( Buffer ) + 1 ];
    strcpy( pTemp, Buffer );

    pExpr = new expr_variable( pTemp );//this has the rhs expr for the
                                       // manager epv call. Sneaky !
    pExpr = new expr_pointsto( pExpr, pProcExpr );
    pAss = pExpr;
    if( pRet )
        {
        pAss    = new expr_assign( pRet, pExpr );
        }

    pAss->PrintCall( pStream, 0, 0 );


}

void
OutputNdrAlignment( CCB * pCCB,
                    unsigned short Alignment )
{
    ISTREAM *   pStream;
    unsigned long Align = Alignment - 1;
    CSzBuffer   Buffer;

    pStream = pCCB->GetStream();

    Buffer.Set( STUB_MSG_BUFFER_VAR_NAME );
    Buffer.Append( " = (unsigned char *)(((" );
    Buffer.Append( (pCommand->Is64BitEnv() ? "__int64"
                                           : "long" ));
    Buffer.Append( ")" STUB_MSG_BUFFER_VAR_NAME " + " );
    Buffer.Append( Align );
    char sz[100];
    sprintf( sz, ") & ~ %#x);", Align);
    Buffer.Append( sz );

    pStream->Write( Buffer );
    pStream->NewLine();
}

CG_NDR * 
GetFirstMulti( 
    CG_NDR * pNdr )
{
    // Skip pointers leading to a multi-dimensional object.

    while ( pNdr->GetCGID() == ID_CG_GENERIC_HDL  ||
            pNdr->GetCGID() == ID_CG_PTR ) 
        {
        pNdr = (CG_NDR *) pNdr->GetChild();
        }

    return pNdr;
}

void
Out_MultiDimVars(
    CCB * pCCB,
    CG_PARAM * pParam
    )
/*
    Output local resources related to multi-dimensional conf or varying arrays.
    Note that the parameter may be a pointer to multidimensional object.
*/
{
    ISTREAM *   pStream;
    CG_NDR *    pNdr;
    char *      pParamName;
    long        dim;
    CSzBuffer   Buffer;

    pStream = pCCB->GetStream();

    pParamName = pParam->GetType()->GetSymName();

    pNdr = (CG_NDR *) pParam->GetChild();

    pNdr = GetFirstMulti( pNdr );

    if ( pNdr->IsArray() )
        dim = ((CG_ARRAY *)pNdr)->GetDimensions();
    else // pNdr->IsPointer()
        dim = ((CG_POINTER *)pNdr)->SizedDimensions();

    Buffer.Set( "unsigned long _maxcount_" );
    Buffer.Append( pParamName );
    Buffer.Append( "[" );
    Buffer.Append( dim );
    Buffer.Append( "]" );

    pStream->Write( Buffer );
    pStream->Write( ";" );
    pStream->NewLine( 2 );

    Buffer.Set( "unsigned long _offset_" );
    Buffer.Append( pParamName );
    Buffer.Append( "[" );
    Buffer.Append( dim );
    Buffer.Append( "]" );
    pStream->Write( Buffer );
    pStream->Write( ';' );
    pStream->NewLine();

    Buffer.Set( "unsigned long _length_" );
    Buffer.Append( pParamName );
    Buffer.Append( "[" );
    Buffer.Append( dim );
    Buffer.Append( "]" );
    pStream->Write( Buffer );
    pStream->Write( ';' );
    pStream->NewLine();
}

void
Out_MultiDimVarsInit(
    CCB * pCCB,
    CG_PARAM * pParam
    )
/*
    Output local resources related to multi-dimensional conf or varying arrays.
    Note that the parameter may be a pointer to multidimensional object.
*/
{
    ISTREAM *   pStream;
    CG_NDR *    pNdr;
    char *      pParamName;
    long        i, dim;
    CSzBuffer   Buffer;

    pStream = pCCB->GetStream();

    pParamName = pParam->GetType()->GetSymName();

    pNdr = (CG_NDR *) pParam->GetChild();
    pNdr = GetFirstMulti( pNdr );

    if ( pNdr->IsArray() )
        dim = ((CG_ARRAY *)pNdr)->GetDimensions();
    else // pNdr->IsPointer()
        dim = ((CG_POINTER *)pNdr)->SizedDimensions();

    pStream->NewLine();

    //
    // Max count var.
    //
/*
    if ( (pNdr->GetCGID() == ID_CG_CONF_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_CONF_VAR_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
         (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
*/
        {
        expr_node * pSizeIsExpr = 0;

        for ( i = 0; i < dim; pNdr = (CG_NDR *) pNdr->GetChild(), i++ )
            {
            Buffer.Set( "_maxcount_" );
            Buffer.Append( pParamName );
            Buffer.Append( "[" );
            Buffer.Append( i );
            Buffer.Append( "] = " );

            pStream->Write( Buffer );

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_CONF_ARRAY :
                case ID_CG_CONF_VAR_ARRAY :
                case ID_CG_CONF_STRING_ARRAY :
                case ID_CG_STRING_ARRAY :
                    pSizeIsExpr = ((CG_ARRAY *)pNdr)->GetSizeIsExpr();
                    break;
                case ID_CG_SIZE_PTR :
                    pSizeIsExpr =
                        ((CG_SIZE_POINTER *)pNdr)->GetSizeIsExpr();
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pSizeIsExpr =
                        ((CG_SIZE_LENGTH_POINTER *)pNdr)->GetSizeIsExpr();
                    break;
                case ID_CG_SIZE_STRING_PTR :
                    pSizeIsExpr =
                        ((CG_SIZE_STRING_POINTER *)pNdr)->GetSizeIsExpr();
                    break;
                }

            if ( pSizeIsExpr )
                pSizeIsExpr->Print( pStream );
            else
                pStream->Write( '0' );

            pStream->Write( ';' );
            pStream->NewLine();
            }
        }

    pNdr = (CG_NDR *) pParam->GetChild();
    pNdr = GetFirstMulti( pNdr );

    //
    // Offset and Length vars.
    //
/*
    if ( (pNdr->GetCGID() == ID_CG_VAR_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_CONF_VAR_ARRAY) ||
         (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
*/
        {
        expr_node *     pFirstIsExpr = 0;
        expr_node *     pLengthIsExpr = 0;

        for ( i = 0; i < dim; pNdr = (CG_NDR *) pNdr->GetChild(), i++ )
            {
            Buffer.Set( "_offset_" );
            Buffer.Append( pParamName );
            Buffer.Append( "[" );
            Buffer.Append( i );
            Buffer.Append( "] = " );

            pStream->Write( Buffer );

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_VAR_ARRAY :
                    pFirstIsExpr = ((CG_VARYING_ARRAY *)pNdr)->
                                        GetFirstIsExpr();
                    break;
                case ID_CG_CONF_VAR_ARRAY :
                    pFirstIsExpr = ((CG_CONFORMANT_VARYING_ARRAY *)pNdr)->
                                        GetFirstIsExpr();
                    break;
                case ID_CG_CONF_STRING_ARRAY :
                case ID_CG_STRING_ARRAY :
                    pFirstIsExpr = 0;
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pFirstIsExpr = ((CG_SIZE_LENGTH_POINTER *)pNdr)->
                                        GetFirstIsExpr();
                    break;
                }

            if ( pFirstIsExpr )
                pFirstIsExpr->Print( pStream );
            else
                pStream->Write( '0' );

            pStream->Write( ';' );
            pStream->NewLine();
            }

        pNdr = (CG_NDR *) pParam->GetChild();
        pNdr = GetFirstMulti( pNdr );

        for ( i = 0; i < dim; pNdr = (CG_NDR *) pNdr->GetChild(), i++ )
            {
            Buffer.Set( "_length_" );
            Buffer.Append( pParamName );
            Buffer.Append( "[" );
            Buffer.Append( i );
            Buffer.Append( "] = " );

            pStream->Write( Buffer );

            switch ( pNdr->GetCGID() )
                {
                case ID_CG_VAR_ARRAY :
                    pLengthIsExpr = ((CG_VARYING_ARRAY *)pNdr)->
                        GetLengthIsExpr();
                    break;
                case ID_CG_CONF_VAR_ARRAY :
                    pLengthIsExpr = ((CG_CONFORMANT_VARYING_ARRAY *)pNdr)->
                        GetLengthIsExpr();
                    break;
                case ID_CG_CONF_STRING_ARRAY :
                case ID_CG_STRING_ARRAY :
                    pLengthIsExpr = 0;
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pLengthIsExpr = ((CG_SIZE_LENGTH_POINTER *)pNdr)->
                        GetLengthIsExpr();
                    break;
                }

            if ( pLengthIsExpr )
                pLengthIsExpr->Print( pStream );
            else
                pStream->Write( '0' );

            pStream->Write( ';' );
            pStream->NewLine();
            }
        }
}

void
Out_CheckUnMarshallPastBufferEnd(
    CCB *   pCCB,
    ulong   size )
    {
/*
    This method will be called only within the try-except of
    unmarshalling on the server side.

    Generate an expression of the form:
        if( (StubMessage.pBuffer + size) > StubMessage.BufferEnd )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
*/

    expr_node  *   pBufferExpr     =
                         new expr_variable( STUB_MSG_BUFFER_VAR_NAME , 0);

    if ( 0 != size )
        {
        pBufferExpr = new expr_op_binary( 
                            OP_PLUS,
                            pBufferExpr,
                            new expr_constant( size ) );
        }

    expr_node  *   pBufferEndExpr  =
                         new expr_variable( STUB_MSG_BUFFER_END_VAR_NAME, 0);
    expr_node  *   pExpr           = new expr_relational( OP_GREATER,
                                                            pBufferExpr,
                                                            pBufferEndExpr );

    Out_If( pCCB, pExpr );
    Out_RaiseException( pCCB, "RPC_X_BAD_STUB_DATA" );
    Out_Endif( pCCB );
    }


void
Out_TypePicklingInfo(
    CCB *   pCCB )
{
    ISTREAM     *   pStream;
    MIDL_TYPE_PICKLING_FLAGS   Flags;
    unsigned long             &intFlags = * (unsigned long *) &Flags;
             
    static const char  *pFlagNames[] = 
                        {
                         "Oicf "
                        ,"NewCorrDesc "
                        };
                        
    pStream = pCCB->GetStream();

    if ( pCommand->NeedsNDR64Run() )
        {
        pStream->WriteOnNewLine( 
                    "extern unsigned long * TypePicklingOffsetTable[]; " );
        pStream->NewLine();
        }

    pStream->WriteOnNewLine("static " MIDL_TYPE_PICKLING_INFO_NAME
                                          " " PICKLING_INFO_STRUCT_NAME " =");
    pStream->IndentInc();
    pStream->WriteOnNewLine( "{" );
    
    pStream->NewLine();
    pStream->WriteNumber( "0x%x, /* Signature & version: TP 1 */", 0x33205054 );

    intFlags = 0;

    MIDL_ASSERT( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 ); 
    Flags.Oicf = 1;

    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        Flags.HasNewCorrDesc = 1;

    pStream->NewLine();
    pStream->WriteNumber( "0x%x,", intFlags );
    if ( 0 != intFlags )
        {
        pStream->Write( " /* Flags: " );
        for ( int i = 0; i < sizeof(pFlagNames)/sizeof(char*); i++ )
            {
            if ( intFlags & ( 1 << i ) )
                pStream->Write( pFlagNames[i] );
            }
        pStream->Write( "*/" );
        }
 
    pStream->WriteOnNewLine( "0," );
    pStream->WriteOnNewLine( "0," );
    pStream->WriteOnNewLine( "0," );

    pStream->WriteOnNewLine( "};" );
    pStream->IndentDec();

    pStream->NewLine();
}

void                Out_PartialIgnoreClientBufferSize( CCB *pCCB, char *pParamName );

void
Out_PartialIgnoreClientMarshall( 
    CCB *pCCB,
    char *pParamName )
{
    ISTREAM     *pStream = pCCB->GetStream();
    unsigned short Spaces = sizeof("NdrPartialIgnoreClientMarshall( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreClientMarshall( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME "," );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( pParamName );
    pStream->Write( " ); " );
    pStream->NewLine();

}

void 
Out_PartialIgnoreServerUnmarshall(
    CCB *pCCB,
    char *pParamName )
{
    ISTREAM     *pStream = pCCB->GetStream();
    unsigned short Spaces = sizeof("NdrPartialIgnoreServerUnmarshall( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreServerUnmarshall( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "&" );
    pStream->Write( pParamName );
    pStream->Write( " ); " );
    pStream->NewLine();
}

void 
Out_PartialIgnoreClientBufferSize( 
    CCB *pCCB,
    char *pParamName )
{
    ISTREAM     *pStream = pCCB->GetStream();
    unsigned short Spaces = sizeof("NdrPartialIgnoreClientBufferSize( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreClientBufferSize( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( pParamName );
    pStream->Write( " ); " );
    pStream->NewLine();

}

void                
Out_PartialIgnoreServerInitialize( 
    CCB *pCCB, 
    char *pParamName, 
    long FormatStringOffset )
{

    ISTREAM     *pStream = pCCB->GetStream();
    char Buffer[256];
    unsigned short Spaces = sizeof("NdrPartialIgnoreServerInitialize( ")-1;

    pStream->WriteOnNewLine( "NdrPartialIgnoreServerInitialize( (PMIDL_STUB_MESSAGE) &" 
                             STUB_MESSAGE_VAR_NAME ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    pStream->Write( "&" );
    pStream->Write( pParamName );
    pStream->Write( ", " );
    pStream->NewLine();

    pStream->Spaces( Spaces );
    sprintf( Buffer, "(PFORMAT_STRING) &" FORMAT_STRING_STRUCT_NAME ".Format[%d] );", 
             FormatStringOffset );
    pStream->Write( Buffer );
    pStream->NewLine();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\output1.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	output.cxx

 Abstract:

	Low level output routines for midl.

 Notes:


 History:

 	Sep-18-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

 #pragma warning ( disable : 4127 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
#if 0
							Notes

	A few general rules followed throughout the file.

		1. Never emit tab other than thru the stream.
		2. Never emit a new line other than thru the stream.
		3. Emitting a new line is the responsibility of the entity that wants
		   itself to be emitted on a new line. Therefore, say each local
		   variable in the stub needs to be on a new line, then the routine
		   responsible for emitting the local variable will be responsible
		   for setting the new line.

#endif // 0

/****************************************************************************
 *	local definitions
 ***************************************************************************/

#define NDR_UP_DECISION_RTN_NAME		"NdrSH_UPDecision"
#define NDR_TLUP_DECISION_RTN_NAME		"NdrSH_TLUPDecision"
#define NDR_TLUP_DECISION_RTN_B_ONLY	"NdrSH_TLUPDecisionBuffer"
#define NDR_IF_ALLOC_RTN_NAME			"NdrSH_IfAlloc"
#define NDR_IF_ALLOC_REF_RTN_NAME		"NdrSH_IfAllocRef"
#define NDR_IF_ALLOC_COPY_RTN_NAME		"NdrSH_IfAllocCopy"
#define NDR_IF_ALLOC_SET_RTN_NAME		"NdrSH_IfAllocSet"
#define NDR_IF_COPY_RTN_NAME			"NdrSH_IfCopy"
#define NDR_COPY_RTN_NAME				"NdrSH_Copy"
#define NDR_CONF_STRING_HDR_MARSHALL	"NdrSH_MarshConfStringHdr"
#define NDR_CONF_STRING_HDR_UNMARSHALL	"NdrSH_UnMarshConfStringHdr"
#define NDR_C_CTXT_HDL_MARSHALL			"NdrSH_MarshCCtxtHdl"
#define NDR_C_CTXT_HDL_UNMARSHALL		"NdrSH_UnMarshCCtxtHdl"
#define NDR_S_CTXT_HDL_MARSHALL			"NdrSH_MarshSCtxtHdl"
#define NDR_S_CTXT_HDL_UNMARSHALL		"NdrSH_UnMarshSCtxtHdl"
#define NDR_IF_FREE_RTN_NAME			"NdrSH_IfFree"
#define NDR_CONF_STR_M_RTN_NAME			"NdrSH_ConfStringMarshall"
#define NDR_CONF_STR_UN_RTN_NAME		"NdrSH_ConfStringUnMarshall"
#define NDR_MAP_COMM_FAULT_RTN_NAME		"NdrMapCommAndFaultStatus"

/****************************************************************************
 *	local data
 ***************************************************************************/
/****************************************************************************
 *	externs
 ***************************************************************************/
void
Out_UPDecision(
	CCB			*	pCCB,
	expr_node	*	pPtrInBuffer,
	expr_node	*	pPtrInMemory )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_UP_DECISION_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));
	pPtrInBuffer = MakeRefExprOutOfDeref( pPtrInBuffer );
	pProc->SetParam( new expr_param( pPtrInBuffer ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar(pPtrInMemory) ) );

	Out_If( pCCB, pProc );
	}

void
Out_TLUPDecision(
	CCB			*	pCCB,
	expr_node	*	,
	expr_node	*	pPtrInMemory )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_TLUP_DECISION_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory) ) );

	Out_If( pCCB, pProc );
	}

void
Out_TLUPDecisionBufferOnly(
	CCB			*	pCCB,
	expr_node	*	,
	expr_node	*	pPtrInMemory )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_TLUP_DECISION_RTN_B_ONLY );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ) );

	Out_If( pCCB, pProc );
	}

void
Out_IfAlloc(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pPtrInMemory = MakeAddressExpressionNoMatterWhat( pPtrInMemory );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_If_IfAlloc(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pPtrInMemory = MakeAddressExpressionNoMatterWhat( pPtrInMemory );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	Out_If( pCCB, pProc );
	// pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_If_IfAllocRef(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_REF_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pPtrInMemory = MakeAddressExpressionNoMatterWhat( pPtrInMemory );
	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	Out_If( pCCB, pProc );
	// pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_Alloc(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc;
	expr_node	*	pExpr;

	if( pCCB->MustCheckAllocationError() )
		{
		expr_node		*	pStubMsg
				= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
		pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
		pProc	= new expr_proc_call( ENGINE_CHECKED_ALLOC_RTN_NAME );
		pProc->SetParam( new expr_param( pStubMsg ) );
		}
	else
		pProc	= new expr_proc_call( STUB_MSG_ALLOCATE_RTN_NAME );
		
	pProc->SetParam( new expr_param( pExprCount ));
	pExpr = new expr_assign( pPtrInMemory, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_IfAllocSet(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_SET_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory )));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_AllocSet(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	pBuffer,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( MIDL_MEMSET_RTN_NAME );
	expr_node		*	pExpr;
	Out_Alloc( pCCB, pPtrInMemory, pBuffer, pExprCount );

	pExpr	= new expr_u_deref( pPtrInMemory );
	pProc->SetParam( new expr_param( pExpr ) );
	pProc->SetParam( new expr_param( pExprCount ) );
	pProc->SetParam( new expr_param( new expr_constant(0L) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_IfCopy(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_COPY_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory ) ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_IfAllocCopy(
	CCB			*	pCCB,
	expr_node	*	pPtrInMemory,
	expr_node	*	,
	expr_node	*	pExprCount )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_ALLOC_COPY_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));

	pProc->SetParam( new expr_param( MakeCastExprPtrToPtrToUChar( pPtrInMemory )));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_Copy(
	CCB		*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pExprCount,
	expr_node	*	pAssign )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_COPY_RTN_NAME );

	pProc->SetParam( new expr_param( pDest ));
	pProc->SetParam( new expr_param( pSource ));
	pProc->SetParam( new expr_param( pExprCount ));
	pCCB->GetStream()->NewLine();

	if( pAssign )
		{
		Out_PlusEquals( pCCB, pAssign, pProc );
		}
	else
		{
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}
	}
void
Out_IfFree(
	CCB		*	pCCB,
	expr_node	*	pSrc )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_IF_FREE_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ) );
	pProc->SetParam( new expr_param( MakeCastExprPtrToUChar( pSrc ) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_ConfStringHdr(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSize,
	expr_node	*	pLength,
	BOOL			fMarsh )
	{
	PNAME	pName;

	if( fMarsh == TRUE )
		{
		pName	= NDR_CONF_STRING_HDR_MARSHALL;
		}
	else
		pName	= NDR_CONF_STRING_HDR_UNMARSHALL;

	expr_proc_call	*	pProc	= new expr_proc_call( pName );
	pProc->SetParam( new expr_param( pDest ) );
	pProc->SetParam( new expr_param( pSize ) );
	pProc->SetParam( new expr_param( pLength ) );

	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_CContextMarshall(
	CCB		*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_C_CTXT_HDL_MARSHALL );
	expr_node	*	pExpr;

	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDest ) );
	pExpr	= new expr_assign( pDest, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_SContextMarshall(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pRDRtn )
	{
	expr_proc_call	* pProc	= new expr_proc_call( NDR_S_CTXT_HDL_MARSHALL );
	expr_node	*	pExpr;

	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDest ) );
	pProc->SetParam( new expr_param( pRDRtn ) );
	pExpr	= new expr_assign( pDest, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_CContextUnMarshall(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pHandle,
	expr_node	*	pDRep )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_C_CTXT_HDL_UNMARSHALL );
	expr_node		*	pExpr;

	pProc->SetParam( new expr_param( pDest ) );
	pProc->SetParam( new expr_param( pHandle ) );
	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDRep ) );

	pExpr	= new expr_assign( pSource, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_SContextUnMarshall(
	CCB			*	pCCB,
	expr_node	*	pDest,
	expr_node	*	pSource,
	expr_node	*	pDRep )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_S_CTXT_HDL_UNMARSHALL );
	expr_node		*	pExpr;

	pProc->SetParam( new expr_param( pSource ) );
	pProc->SetParam( new expr_param( pDRep ) );
	pExpr	= new expr_assign( pDest, pProc );
	pCCB->GetStream()->NewLine();
	pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
	}

void
Out_RaiseException(
	CCB			*	pCCB,
	PNAME			pExceptionName)
	{
	expr_proc_call	*	pProc	= new expr_proc_call( "RpcRaiseException" );
	
	pProc->SetParam( new expr_param( new expr_variable( pExceptionName ) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	}
void
Out_RpcTryFinally(
	CCB		*	pCCB )
	{
	ISTREAM		*	pStream	= pCCB->GetStream();

	pStream->NewLine();
	pStream->Write( "RpcTryFinally" );
	pStream->IndentInc();
	pStream->NewLine();
	pStream->Write( '{' );
	}
void
Out_RpcFinally(
	CCB		*	pCCB )
	{
	ISTREAM		*	pStream	= pCCB->GetStream();

	pStream->NewLine();
	pStream->Write( '}' );
	pStream->IndentDec();
	pStream->NewLine();
	pStream->Write( "RpcFinally" );
	pStream->IndentInc();
	pStream->NewLine();
	pStream->Write('{');
	}
void
Out_RpcEndFinally(
	CCB		*	pCCB )
	{
	ISTREAM		*	pStream	= pCCB->GetStream();

	pStream->NewLine();
	pStream->Write( '}' );
	pStream->IndentDec();
	pStream->NewLine();
	pStream->Write( "RpcEndFinally" );
	pStream->NewLine();
	}
void
Out_RpcTryExcept( CCB * pCCB )
	{
	ISTREAM * pStream = pCCB->GetStream();
	pStream->NewLine();
	pStream->Write( "RpcTryExcept" );
	pStream->IndentInc();
	pStream->NewLine();
	pStream->Write( '{' );
	}

void
Out_RpcExcept(
    CCB * pCCB,
    char * pFilterString )
{
    ISTREAM	*	pStream	= pCCB->GetStream();
    pStream->NewLine();
    pStream->Write('}');
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( "RpcExcept( " );
    pStream->Write( pFilterString );
    pStream->Write( " )" );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
}

void
Out_RpcEndExcept( CCB * pCCB )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	pStream->NewLine();
	pStream->Write( '}' );
	pStream->IndentDec();
	pStream->NewLine();
	pStream->Write( "RpcEndExcept" );
	}
void
Out_CallNdrMapCommAndFaultStatus(
	 CCB * pCCB,
	expr_node * pAddrOfStubMsg,
	expr_node * StatRes,
	expr_node * pCommExpr,
	expr_node * pFaultExpr )
	{
	node_skl	*	pType;
	expr_proc_call * pProc = new expr_proc_call( NDR_MAP_COMM_FAULT_RTN_NAME );
	expr_node * pExpr;
	expr_variable * pExceptionCode = new expr_variable( "RpcExceptionCode()",0);


	pAddrOfStubMsg = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME,
									 				 pAddrOfStubMsg );


	GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );

	pCommExpr = MakeExpressionOfCastPtrToType( pType, pCommExpr );
	pFaultExpr = MakeExpressionOfCastPtrToType( pType, pFaultExpr );

	pProc->SetParam( new expr_param( pAddrOfStubMsg ));
	pProc->SetParam( new expr_param( pCommExpr ));
	pProc->SetParam( new expr_param( pFaultExpr ));
	pProc->SetParam( new expr_param( pExceptionCode ));
	pExpr = new expr_assign( StatRes, pProc );

	Out_If( pCCB, pExpr );
	Out_RaiseException( pCCB, ((RESOURCE * )StatRes)->GetResourceName() );
	Out_Endif(pCCB);
	}
void
Out_CallToXmit(
	CCB	*	pCCB,
	PNAME	XmittedTypeName,
	expr_node * pPresented,
	expr_node * pTransmitted )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+10+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_to_xmit" );
	expr_proc_call	*	pProc = new expr_proc_call( p );
	pProc->SetParam( new expr_param( pPresented ) );
	pProc->SetParam( new expr_param(
						 MakeAddressExpressionNoMatterWhat( pTransmitted ) ));

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}

void
Out_CallFromXmit(
	CCB	*	pCCB,
	PNAME	XmittedTypeName,
	expr_node * pPresented,
	expr_node * pTransmitted )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+10+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_from_xmit" );
	expr_proc_call	*	pProc = new expr_proc_call( p );
	pProc->SetParam( new expr_param( pTransmitted ));
	pProc->SetParam( new expr_param( pPresented ) );

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}
void
Out_CallFreeXmit(
	CCB		*	pCCB,
	PNAME		XmittedTypeName,
	expr_node * pTransmitted )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+15+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_free_xmit" );
	expr_proc_call * pProc = new expr_proc_call( p );

	pProc->SetParam( new expr_param( pTransmitted ) );

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}
void
Out_CallFreeInst(
	CCB		*	pCCB,
	PNAME		XmittedTypeName,
	expr_node *	pPresented )
	{
	ISTREAM	*	pStream	= pCCB->GetStream();
	char 	*	p	= new char [strlen( XmittedTypeName )+15+1];

	strcpy( p, XmittedTypeName );
	strcat( p, "_free_inst" );
	expr_proc_call * pProc = new expr_proc_call( p );

	pProc->SetParam( new expr_param( pPresented ) );

	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}

void
Out_StringMarshall(
	CCB			*	pCCB,
	expr_node	*	pMemory,
	expr_node	*	pCount,
	expr_node	*	pSize )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_CONF_STR_M_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	ISTREAM			*	pStream = pCCB->GetStream();

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));
	pProc->SetParam( new expr_param( MakeCastExprPtrToUChar( pMemory ) ) );
	pProc->SetParam( new expr_param( pCount ) );
	pProc->SetParam( new expr_param( pSize ) );
	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}
void
Out_StringUnMarshall(
	CCB			*	pCCB,
	expr_node	*	pMemory,
	expr_node	*	pSize )
	{
	expr_proc_call	*	pProc	= new expr_proc_call( NDR_CONF_STR_UN_RTN_NAME );
	expr_node		*	pStubMsg= pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
	ISTREAM			*	pStream = pCCB->GetStream();

	pStubMsg	= MakeAddressExpressionNoMatterWhat( pStubMsg );
	pProc->SetParam( new expr_param( pStubMsg ));
	pProc->SetParam( new expr_param( MakeAddressExpressionNoMatterWhat( MakeCastExprPtrToPtrToUChar( pMemory ) )) );
	pProc->SetParam( new expr_param( pSize ) );
	pStream->NewLine();
	pProc->PrintCall( pStream, 0, 0 );
	}

char *
MakeRtnName(
	char * pBuffer, // if 0 it means allocate anew buffer and return.
	char * pName,
	int Code )
	{
	char * p;

	switch( Code )
		{
		case NC_SIZE_RTN_NAME: p = "Sizing"; break;
		case NC_MARSHALL_RTN_NAME: p = "Marshall"; break;
		case NC_UNMARSHALL_RTN_NAME: p = "UnMarshall"; break;
		case NC_MEMSIZE_RTN_NAME: p = "MemSize"; break;
		case NC_FREE_RTN_NAME: p = "Free"; break;
		}

	if( !pBuffer )
		{
		pBuffer = new char[ strlen( pName ) +		// name of structure
							1 +						// underscore.
							strlen( p ) 	+		// name of rtn
							1						// 0 terminator.
						  ];
		}

	sprintf( pBuffer, "%s_%s", pName, p );

	return pBuffer;
	}

void
Out_TypeAlignSizePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_ALIGN_SIZE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));

        pStream->Write(';');
        pStream->NewLine();
        }

}
void
Out_TypeEncodePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_ENCODE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));
        pStream->Write(';');
        pStream->NewLine();
        }

}
void
Out_TypeDecodePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_DECODE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));
        pStream->Write(';');
        pStream->NewLine();
        }
}


void
Out_TypeFreePrototypes(
    CCB *   pCCB,
    ITERATOR&   I )
{
    // Freeing is not supported for the v1 interpreter

    if ( ! ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 ) )
        return;

    TYPE_ENCODE_INFO    *p;
    ISTREAM *   pStream = pCCB->GetStream();

    // The iterator items are really a set of name pointers.

    pStream->NewLine();
    while( ITERATOR_GETNEXT( I, p ) )
        {
        GenStdMesPrototype(
                         pCCB,
                         p->pName,
                         TYPE_FREE_CODE,
                         (p->Flags == TYPE_ENCODE_WITH_IMPL_HANDLE));
        pStream->Write(';');
        pStream->NewLine();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\pickle.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:
    
    pickle.cxx

 Abstract:

    Generates stub routines to call the pickle engine.

 Notes:


 History:

    Mar-22-1994 VibhasC     Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

#pragma warning ( disable : 4127 )

#include "szbuffer.h"

/****************************************************************************
 *  local definitions
 ***************************************************************************/

/****************************************************************************
 *  local data
 ***************************************************************************/

/****************************************************************************
 *  externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_ENCODE_PROC::GenClientStubV1(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate DCE style procedure pickling stub code for the V1 interpreter.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

        CG_OK

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM     *   pStream = pCCB->GetStream();

    // Register this procedure as a proc-encoding procedure.

    pCCB->RegisterEncodeDecodeProc( this );

    // Generate the format strings.

    MIDL_ASSERT( pCommand->IsNDRRun() );
    GenNdrFormat( pCCB );

    // Print the prolog of procedure.

    Out_ClientProcedureProlog( pCCB, GetType() );

    // If there exists a return type, declare a local resource of that
    // type.

    if( GetReturnType() )
        {
        node_id *node = MakeIDNode( RETURN_VALUE_VAR_NAME, GetReturnType()->GetType() );

        pStream->Write( "    " );
        node->PrintType(
                                (PRT_PARAM_WITH_TYPE | PRT_CSTUB_PREFIX),
                                pStream,
                                (node_skl *)0 );
        pStream->NewLine();
        }

    //
    // The V1 interpreter calls NdrMesProcEncodeDecode and passes the addresses
    // of all the parameters that were passed to the stub.
    //

    GenMesProcEncodeDecodeCall( pCCB, PROC_PLATFORM_V1_INTERPRETER );

    GenEpilog( pCCB );

    return CG_OK;
}


CG_STATUS
CG_ENCODE_PROC::GenClientStub(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate DCE style procedure pickling stub code.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    if ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
        return GenClientStubV1( pCCB );

    ISTREAM         *   pStream = pCCB->GetStream();

    // Register this procedure as a proc-encoding procedure.

    pCCB->RegisterEncodeDecodeProc( this );

    // Generate the format strings.

    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );
        }
    else
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    // Print the prolog of procedure.

    Out_ClientProcedureProlog( pCCB, GetType() );

    // If there exists a return type, declare a local resource of that
    // type.

    if( GetReturnType() || HasComplexReturnType() )
        {
        pStream->IndentInc();

            if ( HasComplexReturnType() )
                {
                pStream->NewLine();
                ( (node_proc *) GetType() )
                        ->GetReturnType()->PrintType(PRT_DECL, pStream);
                }
            else
                pStream->WriteOnNewLine( "CLIENT_CALL_RETURN " );

        pStream->Write( RETURN_VALUE_VAR_NAME ";" );
        pStream->IndentDec();
        pStream->NewLine( 2 );
        }

    // Generate ia64 or x86 code

    if (  pCommand->Is64BitEnv() )
        {
        GenMesProcEncodeDecodeCall( pCCB, PROC_PLATFORM_IA64) ;
        }
    else
        {
        GenMesProcEncodeDecodeCall( pCCB, PROC_PLATFORM_X86 );
        }

    if ( GetReturnType() || HasComplexReturnType() )
        {
        CG_NDR*     pNdr;
        node_skl*   pType;

        if ( GetReturnType() )
            {
            pNdr = (CG_NDR *) GetReturnType()->GetChild();
            pType = GetReturnType()->GetType();
            }

        pStream->NewLine( 2 );
        pStream->Write("return ");

        //
        // byval structures, unions, floats, doubles
        //

        if ( HasComplexReturnType() )
            {
            pStream->Write( RETURN_VALUE_VAR_NAME ";");
            }

        //
        // Base type return value.
        //
        else if ( pNdr->IsSimpleType() )
            {
            pType->PrintType( PRT_CAST_TO_TYPE, pStream );
            pStream->Write( RETURN_VALUE_VAR_NAME ".Simple;" );
            }
        //
        // old-style byval structs and unions
        //
        else if ( pNdr->IsStruct() || pNdr->IsUnion() )
            {
            expr_node * pExpr;

            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME ".Pointer" );

            pExpr = MakeDerefExpressionOfCastPtrToType( pType, pExpr );

            pExpr->Print( pStream );

            pStream->Write( ';' );
            }
        //
        // Otherwise pointer or array.
        //
        else
            {
            pType->PrintType( PRT_CAST_TO_TYPE, pStream );
            pStream->Write( RETURN_VALUE_VAR_NAME ".Pointer;" );
            }
        }

    pStream->IndentDec();
    pStream->WriteOnNewLine("}");

    return CG_OK;
}


CG_STATUS
CG_ENCODE_PROC::GenMesProcEncodeDecodeCall(
    CCB *               pCCB,
    PROC_CALL_PLATFORM  Platform )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate DCE style procedure pickling stub code.

 Arguments:

    pCCB        - The code gen controller block.
    Platform    - ia64, etc

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    expr_proc_call  *   pProc;
    node_skl        *   pType;
    expr_node       *   pExpr;
    CG_ITERATOR         I;
    CG_PARAM        *   pCG;
    ISTREAM         *   pStream = pCCB->GetStream();
    PNAME               pHandleName;
    RESOURCE        *   pReturnResource = 0;
    bool                fOutputConstantZero = true;

    //
    // Generate a call to the single encode proc engine call.

    if ( pCommand->NeedsNDR64Run() )
        pProc = new expr_proc_call( "NdrMesProcEncodeDecode3" );
    else if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) 
        pProc = new expr_proc_call( PROC_ENCODE_DECODE_RTN_NAME2 );
    else
        pProc = new expr_proc_call( PROC_ENCODE_DECODE_RTN_NAME );

    // Handle. If the handle is explicit, then it must be a MIDL_ES_HANDLE

    if( GetHandleUsage() == HU_EXPLICIT )
        {
        pHandleName = SearchForBindingParam()->GetName();
        pType   = MakeIDNodeFromTypeName( pHandleName,
                                          MIDL_ES_HANDLE_TYPE_NAME );
        }
    else
        {
        MIDL_ASSERT( pCCB->GetInterfaceCG()->GetImplicitHandle() != 0 );

        pType = (node_id *)pCCB->GetInterfaceCG()->GetImplicitHandle()->
                                                        GetHandleIDOrParam();
        pHandleName = pType->GetSymName();
        }

    pProc->SetParam( new expr_variable( pHandleName, pType ) );

    // ProcEncodeDecode3 needs a proxy info and a proc number.  1 and 2
    // need a stub descriptor and a format string

    if ( pCommand->NeedsNDR64Run() )
        {
        long ProcNum = GetProcNum();

        pExpr = new expr_variable(pCCB->GetInterfaceCG()->GetProxyInfoName());
        pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr = MakeExpressionOfCastToTypeName(
                                        PMIDL_PROXY_INFO_TYPE_NAME, 
                                        pExpr);

        pProc->SetParam( new expr_param( pExpr ) );
        pProc->SetParam( new expr_param( new expr_constant( ProcNum ) ) );

        if ( HasComplexReturnType() )
            {
            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME );
            pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
            }
        else
            {
            pExpr = new expr_param( new expr_constant( (long) 0 ) );
            }

        pProc->SetParam( pExpr );
        }
    else
        {
        // Stub descriptor.

        pExpr   = new RESOURCE( pCCB->GetInterfaceCG()->GetStubDescName(),
                                (node_skl *)0 );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PSTUB_DESC_STRUCT_TYPE_NAME,
                                                      pExpr );

        pProc->SetParam( pExpr );

        // Offset into the format string.

        pExpr   =  Make_1_ArrayExpressionFromVarName(
                                        PROC_FORMAT_STRING_STRING_FIELD,
                                        GetFormatStringOffset() );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( 
                                        PFORMAT_STRING_TYPE_NAME, 
                                        pExpr );
        pProc->SetParam( pExpr );
        }

    switch ( Platform ) 
        {
    case PROC_PLATFORM_V1_INTERPRETER:
        {
        // Parameters to the engine are the address of each of the parameters to
        // this procedure. If there is no parameter AND no return type, push a
        // null (0).

        if( GetMembers( I ) )
            {
            fOutputConstantZero = false;
            while( ITERATOR_GETNEXT( I, pCG ) )
                {
                pExpr   = new expr_variable( pCG->GetType()->GetSymName(),
                                              pCG->GetType());
                pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
                pExpr   = MakeCastExprPtrToUChar( pExpr );
                pProc->SetParam( pExpr );
                }
            }
        break;
        }

    case PROC_PLATFORM_IA64:
        {
        // Parameters to the engine are the actual parameter to this
        // this procedure. If there is no parameter AND no return type, push a
        // null (0).

        if( GetMembers( I ) )
            {
            fOutputConstantZero = false;
            while( ITERATOR_GETNEXT( I, pCG ) )
                {
                pExpr   = new expr_variable( pCG->GetType()->GetSymName(),
                                              pCG->GetType());
                pProc->SetParam( pExpr );
                }
            }
        break;
        }

    default:    // PROC_PLATFORM_DEFAULT (i.e. x86)
        {
        CG_PARAM * pParam = (CG_PARAM *) GetChild();

        if (NULL != pParam)
            {
            fOutputConstantZero = false;
            pExpr = new expr_variable( pParam->GetType()->GetSymName(), pParam->GetType() );
            pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
            pExpr   = MakeCastExprPtrToUChar( pExpr );
            pProc->SetParam( pExpr );
            }
        }
        break;
        }

    //
    // If there is a return value, for the V1 interpreter add another 
    // parameter to the generated procedure expression.  For the V2
    // interpreter assign the return value from the engine to the local 
    // return value variable.
    //

    expr_node *pFinalExpr = pProc;

    if( GetReturnType() && !HasComplexReturnType() )
        {

        if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) 
            {
            pFinalExpr = new expr_assign(
                                new expr_variable( RETURN_VALUE_VAR_NAME ),
                                pProc );
            }
        else
            {
            pReturnResource = new RESOURCE( RETURN_VALUE_VAR_NAME,
                                            GetReturnType()->GetType() );
            pExpr   = MakeAddressExpressionNoMatterWhat( pReturnResource );
            pExpr   = MakeCastExprPtrToUChar( pExpr );
            pProc->SetParam( pExpr );
            }
        }
    else if (fOutputConstantZero )
        {
        pProc->SetParam( new expr_constant( 0L ) );
        }

    // Now print the call out.

    pStream->IndentInc();
    pStream->NewLine();

    pFinalExpr->PrintCall( pStream, 0, 0 );

    pStream->NewLine();
    pStream->IndentDec();

    return CG_OK;
}



CG_STATUS
CG_TYPE_ENCODE_PROC::GenClientStub(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the client side type encoding stub for this proc.

 Arguments:

    pCCB    - The code gen controller block.


 Return Value:

    CG_OK
    
 Notes:

    This proc node hanging under the encode interface node is really a dummy
    proc, put in so that the format string generator can have a placeholder
    node to look at.
----------------------------------------------------------------------------*/
{
    return ((CG_PARAM *)GetChild())->GenTypeEncodingStub( pCCB );
}


CG_STATUS
CG_PARAM::GenTypeEncodingStub(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the client side type encoding stub for this param.

 Arguments:

    pCCB    - The code gen controller block.


 Return Value:

    CG_OK
    
 Notes:

    This param is really a dummy param, put in so that the format string
    generator can have a placeholder node to look at.
----------------------------------------------------------------------------*/
{
    CG_STATUS   Status;
    CG_NDR  *   pLast = pCCB->SetLastPlaceholderClass( this );

    Status =  ((CG_TYPE_ENCODE *)GetChild())->GenTypeEncodingStub( pCCB );

    pCCB->SetLastPlaceholderClass( pLast );

    return Status;
}


CG_STATUS
CG_TYPE_ENCODE::GenTypeEncodingStub(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the pickling stubs for a given type.

 Arguments:

    pCCB    - A pointer to the code generator control block.

 Return Value:

    CG_OK
    
 Notes:

    Emit the Type_Encode(), Type_Size() and Type_Decode() routines.
    If the encode is needed, then sizing is needed too !.
----------------------------------------------------------------------------*/
{
    CG_NDR  *   pChild  = (CG_NDR *)GetChild();

    // Generate the ndr format for the types.

    if( ! pChild->IsSimpleType() )
        {
        if ( pCommand->IsNDRRun() )
            pChild->GenNdrFormat( pCCB );
        else
            pCCB->GetNdr64Format()->Generate( pChild );

        // Register this type so we can output a table of type offsets later

        if ( pCommand->NeedsNDR64Run() )
            TypeIndex = pCCB->RegisterPickledType( this );
        }

    // Check if implicit binding exists.

    if( pCCB->GetInterfaceCG()->GetImplicitHandle() )
        {
        SetHasImplicitHandle();
        }

    // Create a resource dictionary database.

    pCCB->SetResDictDatabase( new RESOURCE_DICT_DATABASE );
    pCCB->ClearParamResourceDict();

    if ( ! pCCB->HasTypePicklingInfoBeenEmitted()  && 
                ( pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
        {
        Out_TypePicklingInfo( pCCB );
        pCCB->SetTypePicklingInfoEmitted();
        }

    // If the type has [encode] on it, generate the sizing and encode routines.

    if( IsEncode() )
        {
        // Allocate standard resources for type encoding.

        AllocateEncodeResources( pCCB );

        // Generate the sizing and encode routines.

        GenTypeSize( pCCB );
        GenTypeEncode( pCCB );

        }

    pCCB->ClearParamResourceDict();

    // If the type has [decode] on it, generate the decode routine.

    if( IsDecode() )
        {
        // Allocate standard resources for type decoding.

        AllocateEncodeResources( pCCB );

        GenTypeDecode( pCCB );
        GenTypeFree( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_TYPE_ENCODE::GenTypeSize(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type sizing routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. Remember, a real proc node does not exist
    // for this pickling type. So we emit a prototype by hand (so to speak).
    // The body of the function is output later,

    GenStdMesPrototype( pCCB,
                        (pName = GetType()->GetSymName()),
                        TYPE_ALIGN_SIZE_CODE,
                        HasImplicitHandle()
                      );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_ALIGN_SIZE_CODE);

    pStream->Write( "return " );
    pProc->PrintCall( pStream, 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeAlignSize( pTEInfo );

    return CG_OK;

}


CG_STATUS
CG_TYPE_ENCODE::GenTypeEncode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type encoding routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. The body of the function output later,

    GenStdMesPrototype( pCCB,
                        (pName = GetType()->GetSymName()),
                        TYPE_ENCODE_CODE,
                        HasImplicitHandle()
                      );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_ENCODE_CODE);

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeEncode( pTEInfo );

    return CG_OK;

}


CG_STATUS
CG_TYPE_ENCODE::GenTypeDecode(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type sizing routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. The body of the function output later,

    GenStdMesPrototype( pCCB,
                        ( pName = GetType()->GetSymName()),
                        TYPE_DECODE_CODE,
                        HasImplicitHandle()
                       );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_DECODE_CODE);

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeDecode( pTEInfo );

    return CG_OK;

}


CG_STATUS
CG_TYPE_ENCODE::GenTypeFree( CCB* pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the type freeing routine for the type.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

----------------------------------------------------------------------------*/
{
    // Freeing is only allowed under the new intrepreter

    if ( ! ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 ) )
        return CG_OK;

    ISTREAM *   pStream = pCCB->GetStream();
    PNAME       pName;
    TYPE_ENCODE_INFO    *   pTEInfo = new TYPE_ENCODE_INFO;

    // Generate the standard prototype. This really means emit the proto of
    // the proc in the stub file. The body of the function output later,

    if ( ((CG_NDR *)GetChild())->IsSimpleType() )
        return CG_OK;

    GenStdMesPrototype( pCCB,
                        ( pName = GetType()->GetSymName()),
                        TYPE_FREE_CODE,
                        HasImplicitHandle()
                       );

    pStream->NewLine();
    pStream->Write( '{' );
    pStream->IndentInc();pStream->NewLine();

    // The procedure body consists of a single procedure call.

    expr_proc_call *   pProc = CreateStdMesEngineProc( pCCB, TYPE_FREE_CODE);

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    // Terminate the procedure body.

    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write( '}' );
    pStream->NewLine();

    // Register the routine with the ccb to enable emitting of prototypes.

    pTEInfo->pName = pName;
    pTEInfo->Flags = HasImplicitHandle() ? TYPE_ENCODE_WITH_IMPL_HANDLE : TYPE_ENCODE_FLAGS_NONE;
    pCCB->RegisterTypeFree( pTEInfo );

    return CG_OK;
}

void
CG_TYPE_ENCODE::AllocateEncodeResources(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Allocate predefined resources for type pickling.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

    Resources are:

    1. The MIDL_ES_HANDLE if explicit binding.
    2. A pointer to the type.

    If there is no explicit binding set the implicit binding resource.
----------------------------------------------------------------------------*/
{
    node_id         *   pMidlESHandle;
    RESOURCE        *   pBindingResource;
    node_id         *   pType           = MakeIDNode( PTYPE_VAR_NAME,GetType());

    // If explicit binding, then a parameter of the type MIDL_ES_HANDLE will
    // be specified by the user. This must be added to the dictionary of
    // parameter resources.

    if( !HasImplicitHandle() )
        {
        pMidlESHandle   = MakeIDNodeFromTypeName( MIDL_ES_HANDLE_VAR_NAME,
                                                  MIDL_ES_HANDLE_TYPE_NAME
                                                );
        pBindingResource = pCCB->AddParamResource(
                                                  MIDL_ES_HANDLE_VAR_NAME,
                                                  pMidlESHandle
                                                 );
        }
    else
        {

        PNAME   pName;

        // If an implicit binding has been specified, a global variable of the
        // type MIDL_ES_HANDLE will have been specified by the user. Pick that
        // up and use as the binding resource.

        MIDL_ASSERT( pCCB->GetInterfaceCG()->GetImplicitHandle() != 0 );

        pMidlESHandle =
           (node_id *)pCCB->GetInterfaceCG()->
                                GetImplicitHandle()->
                                    GetHandleIDOrParam();
        pName   = pMidlESHandle->GetSymName();

        pBindingResource = new RESOURCE( pName,
                                         MakeIDNodeFromTypeName(
                                                    pName,
                                                    MIDL_ES_HANDLE_TYPE_NAME));

        }

    SetBindingResource( pBindingResource );

    // Add a param for the type being pickled.

    pCCB->AddParamResource( PTYPE_VAR_NAME, pType );
}


expr_proc_call *
CG_TYPE_ENCODE::CreateStdMesEngineProc(
    CCB *   pCCB,
    int     Code )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Create a standard proc expression for calls to the engine for encode, 
    decode, align/size, and free.

 Arguments:

    pCCB        -   The code gen controller block.
    Code        -   Which can be any standard encoding services code.

 Return Value:

    CG_OK
    
 Notes:

    If the child is a base type that is being pickled, make direct calls
    to the internal apis.

    In -Oicf mode the emitted stub looks like the following with Encode
    changed to whichever operation [Code] specifies:

        void
        <typename>_Encode(
                        <object>)
        {
            NdrMesTypeEncodeXXX();
        }

    For pre -Oicf modes the <&type_pickling_info> parameter is omitted.

----------------------------------------------------------------------------*/
{
    expr_node       *   pExpr;
    expr_proc_call  *   pProc;
    PNAME               pProcName;
    CG_NDR          *   pChild  = (CG_NDR *)GetChild();
    CSzBuffer           ProcNameBuf;
    BOOL                fIsBaseType;
    bool                fNeedPicklingInfoParam = false;
    int                 fNeedsNDR64;

    fIsBaseType = pChild->IsSimpleType();
    fNeedsNDR64 = pCommand->NeedsNDR64Run();

    // 
    // Figure out what the name of the routine to call is
    //

    PNAME pNdrMesProcNames[4] = 
        {
        "NdrMesTypeAlignSize",
        "NdrMesTypeEncode",
        "NdrMesTypeDecode",
        "NdrMesTypeFree"
        };

    if ( fIsBaseType )
        {
        MIDL_ASSERT( Code != TYPE_FREE_CODE );

        ProcNameBuf.Set("NdrMesSimpleType");
        ProcNameBuf.Append((Code == TYPE_ALIGN_SIZE_CODE) ? "AlignSize" :
                    (Code == TYPE_ENCODE_CODE) ? "Encode" : "Decode");

        if ( fNeedsNDR64 )
            {
            ProcNameBuf.Append( "All" );
            }           
        }
    else
        {
        ProcNameBuf.Set( pNdrMesProcNames[Code] );

        // -protocol all and ndr64 uses "3" routines.
        // -Oicf in straight dce mode uses "2" routines
        // otherwise uses unnumbered routines

        if ( fNeedsNDR64 )
            {
            ProcNameBuf.Append( "3" );
            fNeedPicklingInfoParam = true;
            }   
        else if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2 )
            {
            ProcNameBuf.Append( "2" );
            fNeedPicklingInfoParam = true;
            }
        else
            {
            MIDL_ASSERT( TYPE_FREE_CODE != Code );
            }
        }

    pProcName = new char [strlen( ProcNameBuf ) + 1];
    strcpy( pProcName, ProcNameBuf );

    //
    // Start putting together the proc call
    //

    pProc = new expr_proc_call( pProcName );

    // Set parameters. 
    
    // First the encoding handle. 

    pProc->SetParam( GetBindingResource() );

    // Then pickling info structure

    if( fNeedPicklingInfoParam )
        {
        pExpr   = new RESOURCE( PICKLING_INFO_STRUCT_NAME,
                                (node_skl *)0 );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PMIDL_TYPE_PICKLING_INFO_NAME,
                                                  pExpr );

        pProc->SetParam( pExpr );
        }

    // Next the stub descriptor or the proxy info

    if ( !fIsBaseType || fNeedsNDR64 || Code == TYPE_ENCODE_CODE )
        {
        PNAME StubOrProxy;

        if ( fNeedsNDR64 )
            StubOrProxy = pCCB->GetInterfaceCG()->GetProxyInfoName();
        else
            StubOrProxy = pCCB->GetInterfaceCG()->GetStubDescName();

        pExpr   = new RESOURCE( StubOrProxy,
                                (node_skl *)0 );

        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );

        pProc->SetParam( pExpr );
        }
    
    // Next in straight dce, if it's not a simple type, comes the offset into
    // the format string of the type

    if( !fNeedsNDR64 && !fIsBaseType )
        {
        // Next parameter is the address of the format string indexed by the
        // correct offset i.e &__MIDLFormatString[ ? ].

        pExpr   =  Make_1_ArrayExpressionFromVarName(FORMAT_STRING_STRING_FIELD,
                                                     pChild->GetFormatStringOffset());
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PFORMAT_STRING_TYPE_NAME, pExpr );
        pProc->SetParam( pExpr );

        }

    // For -protocol all or ndr64, the table of type offset tables is next
    // followed by the index of this type into the tables.

    if ( fNeedsNDR64 && !fIsBaseType )
        {
        pExpr = new RESOURCE( "TypePicklingOffsetTable", NULL );
        pProc->SetParam( pExpr );

        pExpr = new expr_constant( this->TypeIndex );
        pProc->SetParam( pExpr );
        }

    // Now for everything except simply type AlignSize, we need the object
    // itself

    if ( ! (fIsBaseType  &&  Code == TYPE_ALIGN_SIZE_CODE) )
        {
        pExpr = pCCB->GetParamResource( PTYPE_VAR_NAME );
        pProc->SetParam( pExpr );
        }

    // Data size for simple type encoding and decoding

    if ( fIsBaseType )
        {
        switch ( Code )
            {
            case TYPE_ALIGN_SIZE_CODE:
                break;

            case TYPE_ENCODE_CODE:
                {
                pExpr = new expr_constant( (short) pChild->GetMemorySize() );
                pProc->SetParam( pExpr );

                }
                break;

            case TYPE_DECODE_CODE:
                // We need format char because of conversion.

                pExpr = new expr_constant( (short)
                                 ((CG_BASETYPE *)pChild)->GetFormatChar() );
                pProc->SetParam( pExpr );
                break;

            default:
                MIDL_ASSERT( FALSE );
                break;
            }
        }

    return pProc;
}


void
GenStdMesPrototype(
    CCB *   pCCB,
    PNAME   TypeName,
    int     Code,
    BOOL    fImplicitHandle )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a standard prototype for the type pickle routines.

 Arguments:

    pCCB            - The code gen controller block.
    PNAME           - Name of the type.
    Code            - Size / Encode / Decode code.
    fImplicitImplicitHandle - TRUE if implicit binding handle used.

 Return Value:
    
 Notes:

----------------------------------------------------------------------------*/
    {
    CSzBuffer   Buffer;
    char    *   p;

    switch( Code )
        {
        case TYPE_ALIGN_SIZE_CODE: p = "AlignSize"; break;
        case TYPE_ENCODE_CODE: p = "Encode"; break;
        case TYPE_DECODE_CODE: p = "Decode"; break;
        case TYPE_FREE_CODE:   p = "Free"; break;
        default:
            MIDL_ASSERT( FALSE );
        }

    if( fImplicitHandle )
        {
        Buffer.Set("\n");
        Buffer.Append((Code == TYPE_ALIGN_SIZE_CODE) ? "size_t" : "void");
        Buffer.Append("\n");
        Buffer.Append(TypeName);
        Buffer.Append("_");
        Buffer.Append(p);
        Buffer.Append("(\n    ");
        Buffer.Append(TypeName);
        Buffer.Append(" * ");
        Buffer.Append(PTYPE_VAR_NAME);
        Buffer.Append(")");
        }
    else
        {
        Buffer.Set("\n");
        Buffer.Append((Code == TYPE_ALIGN_SIZE_CODE) ? "size_t" : "void");
        Buffer.Append("\n");
        Buffer.Append(TypeName);
        Buffer.Append("_");
        Buffer.Append(p);
        Buffer.Append("(\n    ");
        Buffer.Append(MIDL_ES_HANDLE_TYPE_NAME);
        Buffer.Append(" ");
        Buffer.Append(MIDL_ES_HANDLE_VAR_NAME);
        Buffer.Append(",\n    ");
        Buffer.Append(TypeName);
        Buffer.Append(" * ");
        Buffer.Append(PTYPE_VAR_NAME);
        Buffer.Append(")");
        }

    pCCB->GetStream()->Write( Buffer );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\pipendr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1995-1999 Microsoft Corporation

 Module Name:

    pipendr.cxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    pipe types.

 Notes:

 History:

    SteveBl   Dec-1995        Created.
    
 ----------------------------------------------------------------------------*/

#include "becls.hxx"

extern CMD_ARG * pCommand;

#pragma hdrstop

void
CG_PIPE::GenNdrFormat( CCB * pCCB )
/*++
    The format string is:

        FC_PIPE     
        flags & alignment<1>        // pointer flags on the higher nibble
        index to type desc<2>       // the usual
        memory size<2>              
        buffer size<2>              // wire size, essential

    If either memory size or buffer size > 64k then 
    the FC_BIG_PIPE flag is set and the following format string is used:

        FC_PIPE     
        flags & alignment<1>        
        index to type desc<2>       
        memory size<4>          
        buffer size<4>          
        
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    pCommand->GetNdrVersionControl().SetHasRawPipes();

    FORMAT_STRING * pFormatString;
    CG_NDR *        pChild;
    long            ChildOffset;

    // Format offset

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    MIDL_ASSERT( pChild );

    // Do this in case the child is a simple type.
    ChildOffset = pFormatString->GetCurrentOffset();

    pChild->GenNdrFormat( pCCB );

    // Again, do this in case the child is a simple type.
    pFormatString->Align();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    // Real stuff now

    pFormatString->PushFormatChar( FC_PIPE );

    // Compute the memory size and buffer size.
    // Account for alignment

    unsigned long uMemorySize         = pChild->GetMemorySize();
    
    unsigned long uBufferSize = pChild->HasAFixedBufferSize() 
                                           ? pChild->GetWireSize() 
                                           : 0;

    // Now the flag byte.
    
    unsigned char FlagByte = unsigned char(pChild->GetWireAlignment() - 1);

    if (uMemorySize > 0xffff || uBufferSize > 0xffff)
        FlagByte |= FC_BIG_PIPE;

    if ( IsObjectPipe() )
        FlagByte |= FC_OBJECT_PIPE;

    if ( GetRangeAttribute() )
        {
        FlagByte |= FC_PIPE_HAS_RANGE;
        }

    pFormatString->PushByte( FlagByte );

    // Now the index to the type desc

    if ( pChild->IsSimpleType() )
        {
        pFormatString->PushShortOffset(
                           ChildOffset - pFormatString->GetCurrentOffset() );
        }
    else
        {
        pFormatString->PushShortOffset(
                           pChild->GetFormatStringOffset() - 
                             pFormatString->GetCurrentOffset() );
        }

    // Now push the memory size and buffer size.

    if (FlagByte & FC_BIG_PIPE)
    {
        pFormatString->PushLong( uMemorySize);
        pFormatString->PushLong( uBufferSize);
    }
    else
    {
        pFormatString->PushShort( (short) uMemorySize);
        pFormatString->PushShort( (short) uBufferSize);
    }
    if ( GetRangeAttribute() )
        {
        // RKK64: TBD support for a range check on hyper.
        pFormatString->PushLong( (ulong) GetRangeAttribute()->GetMinExpr()->GetValue() );  // min.
        pFormatString->PushLong( (ulong) GetRangeAttribute()->GetMaxExpr()->GetValue() );  // max.
        }

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\proccls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

        proccls.cxx

 Abstract:

        Implementation of offline methods for the proc / param code generation
        classes.

 Notes:

 History:

        Sep-14-1993             VibhasC         Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *      include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

extern CMD_ARG * pCommand;

/* 
    These flags could be picked up from the actual rpcdcep.h file.
    However, this would give us a bad dependency and the flags cannot change anyway
    because of backward compatibility reasons: in the interpreted modes the value
    of the flag is used in format strings, not the name like in the -Os code.
*/

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#define RPCFLG_MESSAGE              0x01000000
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000
// the following flag is now redundant
// #define RPCFLG_ASYNCHRONOUS         0x40000000


/****************************************************************************/

/****************************************************************************
 *      procedure class methods.
 ***************************************************************************/
CG_PROC::CG_PROC(
        unsigned int    ProcNumber,
        node_skl        *       pProc,
        CG_HANDLE       *       pBH,
        CG_PARAM        *       pHU,
        BOOL                    fIn,
        BOOL                    fOut,
        BOOL                    fAtLeastOneShipped,
        BOOL                    fHasStat,
        BOOL                    fHasFull,
        CG_RETURN       *       pRT,
        OPTIM_OPTION    OptimFlags,
        unsigned short  OpBits, 
        BOOL            fDeny
        ) : 
        CG_NDR(pProc, XLAT_SIZE_INFO() ),
        fHasAsyncHandle( FALSE ),
        fHasDeny( fDeny ),
        fHasAsyncUUID( FALSE ),
        uNotifyTableOffset( 0 )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Constructor for the parm cg class.

 Arguments:

        ProcNumber                      - The procedure number in the interface.
        pProc                           - a pointer to the original node in the type graph.
        pBH                                     - a pointer to a binding handle cg class.
        pHU                                     - the usage of the handle, a CG_PARAM or NULL
        fIn                                     - flag specifying at least one in param.
        fOut                            - flag specifying at least one out param.
        fAtLeastOneShipped      - flag specifying that at least one param is shipped.
        fHasStat                        - flag for any comm/fault statuses on return or params
        pRT                                     - pointer to CG_PARAM or NULL.
        OptimFlags                      - optimization flags for this proc

 Return Value:

        NA.

 Notes:

        The procedure number is the lexical sequence number of the procedure as
        specified in the interface, not counting the callback procedures. The
        type of the procnum matches the corresponding field of the rpc message.

----------------------------------------------------------------------------*/
{
    SetProcNum( ProcNumber );
    SetHandleClassPtr( pBH );
    SetHandleUsagePtr( pHU );
    SetOptimizationFlags( OptimFlags );
    SetOperationBits( OpBits );
    SetHasFullPtr( fHasFull );
    SetProckind(PROC_PUREVIRTUAL);

    fNoCode         = FALSE;
    fHasNotify      = FALSE;
    fHasNotifyFlag  = FALSE;
    fReturnsHRESULT = FALSE;

    fHasStatuses    = fHasStat;
    fHasExtraStatusParam  = 0;
    fOutLocalAnalysisDone = 0;
    pCallAsName     = NULL;

    if( fIn == TRUE )
        SetHasAtLeastOneIn();
    else
        ResetHasAtLeastOneIn();

    if( fOut == TRUE )
        SetHasAtLeastOneOut();
    else
        ResetHasAtLeastOneOut();

    SetReturnType( pRT );

    if( fAtLeastOneShipped )
        {
        SetHasAtLeastOneShipped();
        }
    else
        ResetHasAtLeastOneShipped();

    SetSStubDescriptor( 0 );
    SetCStubDescriptor( 0 );
    SetStatusResource( 0 );

    SetFormatStringParamStart(-1);

    SetMustInvokeRpcSSAllocate( 0 );

    SetRpcSSSpecified( 0 );

    SetContextHandleCount( 0 );

    SetHasPipes( 0 );
    fSupressHeader = FALSE;
    pSavedProcFormatString = NULL;
    pSavedFormatString = NULL;
    cRefSaved = 0;
    pCallAsType = NULL;

    fHasServerCorr = FALSE;
    fHasClientCorr = FALSE;

    fIsBeginProc = FALSE;
    fIsFinishProc = FALSE;
    pAsyncRelative = NULL;

    pCSTagRoutine = NULL;

    fHasComplexReturn = FALSE;
}

char    *
CG_PROC::GetInterfaceName()
        {
        return GetInterfaceNode()->GetSymName();
        }

BOOL CG_PROC::SetHasPipes(BOOL f)
        {
        if (f)
            GetInterfaceNode()->SetHasPipes(TRUE);
        return (fHasPipes = f);
        }

short
CG_PROC::GetInParamList(
        ITERATOR&       I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Get the list of [in] parameters.

 Arguments:

        I       - An iterator supplied by the caller.

 Return Value:

        Count of the number of in parameters.

 Notes:

----------------------------------------------------------------------------*/
{
        CG_ITERATOR             I1;
        CG_PARAM        *       pParam;
        short                   Count = 0;

        //
        // Get all the members of this cg class and pick ones which are in params.
        //

        GetMembers( I1 );

        ITERATOR_INIT( I1 );

        while( ITERATOR_GETNEXT( I1, pParam ) )
                {
                if( pParam->IsParamIn() && (pParam->GetType()->GetBasicType()->NodeKind() != NODE_VOID) )
                        {
                        ITERATOR_INSERT( I, pParam );
                        Count++;
                        }
                }
        return Count;
}

short
CG_PROC::GetOutParamList(
        ITERATOR&       I )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Get the list of [out] parameters.

 Arguments:

        I       - An iterator supplied by the caller.

 Return Value:

        Count of the number of out parameters.

 Notes:

----------------------------------------------------------------------------*/
{
        CG_ITERATOR             I1;
        CG_PARAM        *       pParam;
        short                   Count = 0;

        //
        // Get all the members of this cg class and pick ones which are out params.
        //

        GetMembers( I1 );

        ITERATOR_INIT( I1 );

        while( ITERATOR_GETNEXT( I1, pParam ) )
                {
                if( pParam->IsParamOut() )
                        {
                        ITERATOR_INSERT( I, pParam );
                        Count++;
                        }
                }
        return Count;
}

long
CG_PROC::GetTotalStackSize(
     CCB  * pCCB 
     )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
----------------------------------------------------------------------------*/
{
    //
    // Figure out the total stack size of all parameters.
    //
    CG_ITERATOR Iterator;
    CG_PARAM *  pParam;
    long        Size;
    BOOL        f64 = pCommand->Is64BitEnv();

    GetMembers( Iterator );

    Size = 0;

    pParam = 0;

    // Get the last parameter.
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        ;

    if ( pParam )
        {
        Size += pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) +
                pParam->GetStackSize();
        if ( f64 )
            Size = (Size + 7) & ~ 0x7;
        else
            Size = (Size + 3) & ~ 0x3;
        }
    else
        if ( IsObject() )
            {
            //
            // If our stack size is still 0 and we're an object proc then
            // add in the 'this' pointer size.
            //
            Size = SIZEOF_PTR( f64 );
            }

    if ( ( pParam = GetReturnType() ) != 0 )
        {
        Size += pParam->GetStackSize();
        if ( f64 )
            Size = (Size + 7) & ~ 0x7;
        else
            Size = (Size + 3) & ~ 0x3;
        }

    return Size;
}


BOOL
CG_PROC::MustUseSingleEngineCall(
         CCB    *       pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Must we generate code for a single call to the marshalling engine routine ?

 Arguments:

        pCCB    - A pointer to the code gen controller block.

 Return Value:

        TRUE if one call is recommended.
        FALSE otherwise.

 Notes:

        If all parameters recommend that a single engine call be used, then
        recommend that.
----------------------------------------------------------------------------*/
{
    return (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER);
}

BOOL
CG_PROC::UseOldInterpreterMode( CCB* )
{
#ifdef TEMPORARY_OI_SERVER_STUBS
    return TRUE;
#else //  TEMPORARY_OI_SERVER_STUBS
    return FALSE;
#endif //  TEMPORARY_OI_SERVER_STUBS
}

BOOL
CG_PROC::NeedsServerThunk( CCB *    pCCB,
                           CGSIDE   Side )
{
    OPTIM_OPTION OptimizationFlags = GetOptimizationFlags();

    // -Os
    if ( ( ( (unsigned long)OptimizationFlags ) & OPTIMIZE_INTERPRETER ) == 0 )
        return FALSE;


    if ( (Side == CGSIDE_CLIENT) && (GetCGID() != ID_CG_CALLBACK_PROC) )
        return FALSE;

    pCCB->SetCGNodeContext( this );

    // not -Oicf
    if ( !( OptimizationFlags & OPTIMIZE_INTERPRETER_V2 ) )
        {
        long x86StackSize = GetTotalStackSize( pCCB );

        //
        // Now check if the parameter size threshold is exceeded on any of the
        // four platforms.  On the Alpha and win64 we allow a size twice as big to
        // compensate for the 8 byte aligned stacks.  The interpreter has the
        // necessary #ifdefs to handle this anomoly.
        // We ignore non-server platforms.

        long x86Limit;

        x86Limit = (long)(pCommand->Is64BitEnv() ? INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD * 2
                                                 : INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD);

        if ( x86StackSize > x86Limit )
            {
            return TRUE;
            }
        }

    return OptimizationFlags & OPTIMIZE_THUNKED_INTERPRET;
}


expr_node *
CG_PROC::GenBindOrUnBindExpression(
        CCB             *       pCCB,
        BOOL            fBind )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Create the final binding expression for the procedure.

 Arguments:

        pCCB    - A pointer to the code gen controller block.
        fBind   - TRUE if called for binding, FALSE for unbinding.

 Return Value:

        The final expression.

 Notes:

        1. If the procedure is an auto binding handle procedure, then the final
           binding expression is the address of the AutoBindVariable.
        2. If the handle is a generic handle, then the binding expression is the
           call to the generic bind routine.
        3. If the handle is a context handle, then the bindiing expression is the
           NDRCContextBinding Expression.


        The Binding expression is passed on to the initialize routine or the
        single call engine routine.

----------------------------------------------------------------------------*/
{
    expr_node       *       pExpr   = 0;

    if( IsAutoHandle() )
        {
        if( fBind == TRUE )
            {
            RESOURCE * pR = pCCB->GetStandardResource( ST_RES_AUTO_BH_VARIABLE );

            // Make the code generator believe we have a binding resource.
            SetBindingResource( pR );
            }
        }
    else if( IsGenericHandle() )
        {

        // For a generic handle, the expression is the call to the generic
        // handle bind routine. To do this, we need to send the message to
        // the handle param to generate the parameter passed to this routine
        // and then generate an expression for the call to the procedure.

        ITERATOR        I;
        PNAME           p;
        node_skl*       pType   = ((CG_GENERIC_HANDLE *)GetHandleClassPtr())->GetHandleType();
        char    *       pName   = pType->GetSymName();

        if( GetHandleUsage() == HU_IMPLICIT )
            {
            node_skl * pID;

            if( (pID = pCCB->GetImplicitHandleIDNode()) == 0 )
                {
                pID = pCCB->SetImplicitHandleIDNode(
                                 GetHandleClassPtr()->GetHandleIDOrParam() );
                }
            pExpr   = new expr_variable( pID->GetSymName() );
            }
        else
            {

            // An explicit parameter is specified for the binding handle.

            pExpr   = ((CG_NDR *)SearchForBindingParam())->GenBindOrUnBindExpression    (
                                                                                        pCCB,
                                                                                        fBind
                                                                                        );

            // Register this genric handle with the ccb.

            }

        pCCB->RegisterGenericHandleType( pType );

        ITERATOR_INSERT( I, pExpr );

        // For unbind we have to specify the original binding handle variable
        // also as a parameter.

        if( fBind == FALSE )
            {
            RESOURCE * pTR = GetBindingResource();
            ITERATOR_INSERT( I, pTR );
            }

        // Generate the name: Type_bind;

        p       = new char [ strlen(pName) + 10 ];
        strcpy( p, pName );
        strcat( p, fBind ? "_bind" : "_unbind" );

        pExpr = MakeProcCallOutOfParamExprList( p,
                                                GetType(),
                                                I
                                              );
        if( fBind == TRUE )
            {
            pExpr = new expr_assign( GetBindingResource(), pExpr );
            }
        }
    else if(IsPrimitiveHandle() )
        {

        // This should never be called for an unbind request.

        MIDL_ASSERT( fBind == TRUE );

        // may be an explicit or implicit primitive handle.

        if( GetHandleUsage() == HU_IMPLICIT )
            {
            node_skl * pID;

            if( (pID = pCCB->GetImplicitHandleIDNode()) == 0 )
                {
                pID = pCCB->SetImplicitHandleIDNode(
                                 GetHandleClassPtr()->GetHandleIDOrParam() );
                }
            pExpr   = new expr_variable( pID->GetSymName() );
            }
        else
            {

            // The binding handle parameter derives the expression.
            pExpr   = ((CG_NDR *)SearchForBindingParam())->
                                GenBindOrUnBindExpression( pCCB, fBind );
            }

        if( fBind == TRUE )
            {
            pExpr = new expr_assign( GetBindingResource(), pExpr );
            }
        }
    else
        {
        // Context handles.
        // This method should never be called on an unbind.
        MIDL_ASSERT( fBind == TRUE );

        node_skl* pType = ((CG_CONTEXT_HANDLE *)GetHandleClassPtr())->GetHandleType();
        if( pType->NodeKind() == NODE_DEF )
            {
            pCCB->RegisterContextHandleType( pType );
            }
        }

    return pExpr;
}

unsigned int
CG_PROC::TranslateOpBitsIntoUnsignedInt()
        {
        unsigned int    OpBits  = GetOperationBits();
        unsigned int    Flags   = RPC_NCA_FLAGS_DEFAULT;

        if( OpBits & OPERATION_MAYBE )
                {
                Flags |= RPC_NCA_FLAGS_MAYBE;
                }

        if( OpBits & OPERATION_BROADCAST )
                {
                Flags |= RPC_NCA_FLAGS_BROADCAST;
                }

        if( OpBits & OPERATION_IDEMPOTENT )
                {
                Flags |= RPC_NCA_FLAGS_IDEMPOTENT;
                }

        if( OpBits & OPERATION_MESSAGE )
                {
                Flags |= RPCFLG_MESSAGE;
                pCommand->GetNdrVersionControl().SetHasMessageAttr();
                }

        if( OpBits & OPERATION_INPUT_SYNC )
                {
                Flags |= RPCFLG_INPUT_SYNCHRONOUS;
                }

        return Flags;
        }

BOOL
CG_PROC::HasInterpreterDeferredFree()
{
    CG_ITERATOR Iterator;
    CG_PARAM *  pParam;

    GetMembers( Iterator );

    //
    // Just check for pointers to basetypes for now.  Eventually we'll have
    // to check if a pointer to basetype actually occurs in any *_is
    // expression.
    //
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( ((CG_NDR *)pParam->GetChild())->IsPointerToBaseType() )
            return TRUE;
        }

    // Don't have to check return type since it can't be part of a *_is
    // expression.

    return FALSE;
}

/****************************************************************************
 *      parameter class methods.
 */

CG_PARAM::CG_PARAM(
    node_skl      *     pParam,
    PARAM_DIR_FLAGS     Dir,
    XLAT_SIZE_INFO &    Info,
    expr_node *         pSw,
    unsigned short      Stat 
    )  
    : CG_NDR( pParam, Info ),
    fIsAsyncHandle( FALSE ),
    fSaveForAsyncFinish( false )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Constructor for the parm cg class.

 Arguments:

    pParam  - a pointer to the original node in the type graph.
    Dir     - the direction : IN_PARAM, OUT_PARAM or IN_OUT_PARAM
    WA      - wire alignment.
    pSw     - any switch_is expression on the param
    Stat    - any comm/fault statuses on the param

 Notes:

----------------------------------------------------------------------------*/
{
    //
    // set the direction indicator for quick future reference.
    //
    fDirAttrs       = Dir;

    fDontCallFreeInst    = 0;
    fInterpreterMustSize = 1;
    fIsExtraStatusParam  = 0;
    fIsForceAllocate    = FALSE;

    // save the optional attributes; switch_is, comm/fault statuses

    pSwitchExpr = pSw;
    Statuses    = Stat;

    //
    // initialize phase specific information array.
    //

    SetFinalExpression( 0 );
    SetSizeExpression( 0 );
    SetSizeResource(0);
    SetLengthResource(0);
    SetFirstResource(0);
    SetSubstitutePtrResource(0);

    SetUnionFormatStringOffset(-1);

    SetParamNumber( -1 );

    SetIsCSSTag( FALSE );
    SetIsCSDRTag( FALSE );
    SetIsCSRTag( FALSE );
    SetIsOmittedParam( FALSE );
}

expr_node *
CG_PARAM::GenBindOrUnBindExpression(
        CCB     *       pCCB,
        BOOL    fBind )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

        Generate the binding expression.

 Arguments:

        pCCB    - A pointer to the code generator controller block.
        fBind   - bool to indicate a bind or unbind generation.

 Return Value:

 Notes:

        Actually for a param node, the expression remains the same whether it
        is being called for a bind or unbind.
----------------------------------------------------------------------------*/
{
    RESOURCE *  pR = pCCB->GetParamResource( GetType()->GetSymName() );

    MIDL_ASSERT( pR != 0 );

    pCCB->SetSourceExpression( pR );

    return ((CG_NDR *)GetChild())->GenBindOrUnBindExpression( pCCB, fBind );
}

long
CG_PARAM::GetStackOffset(
    CCB * pCCB,
    long  PlatformForSizing )
/*++

Routine Description :

        Returns the offset on the stack to the parameter.

--*/
{
    CG_ITERATOR     Iterator;
    CG_PROC *       pProc;
    CG_PARAM *      pParam;
    CG_NDR *        pNdr;
    long            Offset;
    long            Align;

    BOOL  fForIA64  = pCommand->Is64BitEnv() && 
                             (PlatformForSizing & I386_STACK_SIZING);

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    //
    // If this is a cs_tag param and there is a tag routine it is not
    // pushed on the stack.
    //

    if ( this->IsSomeCSTag() && pProc->GetCSTagRoutine() )
        return 0;

    pProc->GetMembers( Iterator );

    Offset = 0;

    //
    // Add in size of 'this' pointer for object procs.
    //
    if ( pProc->IsObject() )
        {
        Offset += fForIA64 ? 8 : 4;
        }

    Align = 0x3;

    // Override for ia64.
    if ( fForIA64 )
        Align = 0x7;

    pParam = 0;

    for ( ; ITERATOR_GETNEXT( Iterator, pParam );
            Offset += Align, Offset = Offset & ~ Align )
        {
        if ( pParam->IsSomeCSTag() && pProc->GetCSTagRoutine() )
            continue;

        pNdr = (CG_NDR *) pParam->GetChild();

        //
        // For CG_CSARRAY, the size is the size of the underlying type
        //

        if ( pNdr->GetCGID() == ID_CG_CS_ARRAY )
            pNdr = (CG_NDR *) pNdr->GetChild();

        //
        // If this is a generic handle then re-set the ndr pointer to the
        // handle's child, which is what is actually being pushed on the
        // stack.
        //
        if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
            pNdr = (CG_NDR *) pNdr->GetChild();

        // The IA64 stack rules as of Jan 14, 2000.
        // The following is a quote from ver. 2.5 of Intel's doc:
        //
        //     Table 8-1. Rules for Allocating Parameter Slots
        // ---------------------------------------------------------------------
        //     Type            Size(bits)  Slot         How many       Alignment
        // ---------------------------------------------------------------------
        // Integer/Pointer       1-64      next             1             LSB
        // Integer               65-128    next even        2             LSB
        // Single-Precision FP   32        next             1             LSB
        // Double-Precision FP   64        next             1             LSB
        // Double-Extended  FP   80        next even        2             byte 0
        // Quad-Precision FP     128       next even        2             byte 0
        // Aggregates            any       next aligned   (size+63)/64    byte 0
        // ---------------------------------------------------------------------
        //
        // Notes. 
        //  "next aligned" is for aggregates with alignment of 16 (becomes next even).
        //  The padding is always to a single slot boundary, padding is undefined.
        //  As of this writing the C++ compiler does not support any of these:
        //     __int128, float128, float80.
        //

        if ( fForIA64  )
            {
            // Slightly simplified rules as no int or FP is bigger than 64b.

            if ( (pNdr->GetMemoryAlignment() > 8)  &&
                 (pNdr->GetMemorySize() > 8)  &&
                 ! pNdr->IsArray() )
                {
                if (pNdr->IsStruct()  || pNdr->IsUnion()) 
                    {
                    Offset = (Offset + 15) & ~ 0xf;
                    }
                else if ( (pNdr->GetCGID() == ID_CG_TRANSMIT_AS) ||
                          (pNdr->GetCGID() == ID_CG_REPRESENT_AS) ||
                          (pNdr->GetCGID() == ID_CG_USER_MARSHAL) )
                    {
                    node_skl *  pPresented;

                    //
                    // Presented type alignment is 16 and
                    // Since we know the presented type is >= 8 bytes in
                    // size, we just have to make sure it's not an array
                    // (could be a large fixed array of alignment < 8).
                    //

                    if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
                        pPresented = ((CG_TRANSMIT_AS *)pNdr)->GetPresentedType();
                    else if ( (pNdr->GetCGID() == ID_CG_REPRESENT_AS) ||
                         (pNdr->GetCGID() == ID_CG_USER_MARSHAL) )
                        pPresented = ((CG_REPRESENT_AS *)pNdr)->GetRepAsType();

                    //
                    // We could have a null presented type for unknown rep_as.
                    // If it is null then the proc will have been changed
                    // to -Os and the stub won't need the stack sizes anyway.
                    //
                    if ( pPresented &&
                         (pPresented->GetBasicType()->NodeKind() != NODE_ARRAY) )
                        Offset = (Offset + 15) & ~ 0xf;
                    }
                }
            } // ia64

        //
        // Do the exit condition check AFTER the above three alignment checks.
        //

        if ( pParam == this )
            break;

        //
        // Add in the stack size of this parameter.
        //

        // If this is a pipe, then we need to ensure proper alignment and
        // then bump the stack by the size of the pipe structure
        // (four far pointers)

        if ( pNdr->GetCGID() == ID_CG_PIPE )
            {
            // Pipes don't need any special treatment on ia64.
            // For ia64 offset is already aligned to 8.

            Offset += 4 * SIZEOF_MEM_PTR();
            continue;
            }

        if ( pNdr->IsSimpleType() )
            {
            ((CG_BASETYPE *)pNdr)->IncrementStackOffset( &Offset );
            continue;
            }

        if ( pNdr->IsPointer() || pNdr->IsArray() ||
                         (pNdr->IsInterfacePointer() ) )
            {
            Offset += SIZEOF_MEM_PTR();
            continue;
            }

        if ( pNdr->IsStruct() || pNdr->IsUnion() || ID_CG_CS_TAG == pNdr->GetCGID() )
            {
            // Already aligned for the bigger-than-8 rule on ia64.

            Offset += pParam->GetStackSize();
            continue;
            }

        if ( pNdr->IsAHandle() )
            {
            //
            // We only get here for primitive and context handles.  For
            // primitive handles we know the pushed size is always 4.
            //
            // For context handles this is a major hassle and for now we assume
            // that the underlying user defined type is a pointer.
            //

            Offset += SIZEOF_MEM_PTR();
            continue;
            }

        if (pParam->IsAsyncHandleParam())
            {
            Offset += SIZEOF_MEM_PTR();
            continue;
            }

        if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
            {
            Offset += ((CG_TRANSMIT_AS *)pNdr)->GetStackSize();
            continue;
            }

        if ( pNdr->GetCGID() == ID_CG_REPRESENT_AS )
            {
            Offset += ((CG_REPRESENT_AS *)pNdr)->GetStackSize();
            continue;
            }

        if ( pNdr->GetCGID() == ID_CG_USER_MARSHAL )
            {
            Offset += ((CG_USER_MARSHAL *)pNdr)->GetStackSize();
            continue;
            }

        // Should never get here.
        MIDL_ASSERT(0);

        } //for

    return Offset;
}

long
CG_PARAM::GetStackSize()
/*++

Routine Description :

        Returns the size of the parameter.

--*/
{
    CG_NDR* pNdr      = (CG_NDR *) GetChild();

    // if this is a pipe then return the size of the pipe structure
    if ( pNdr->GetCGID() == ID_CG_PIPE )
        return (4 * SIZEOF_MEM_PTR());  // four pointers

    //
    // If this is a generic handle then re-set the ndr pointer to the
    // handle's child, which is what is actually being pushed on the
    // stack.  Same for CsArray's
    //
    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL 
         || pNdr->GetCGID() == ID_CG_CS_ARRAY )
        {
        pNdr = (CG_NDR *) pNdr->GetChild();
        }

    if ( pNdr->GetCGID() == ID_CG_TYPE_ENCODE )
        pNdr = (CG_NDR *) ((CG_TYPE_ENCODE *) pNdr)->GetChild();

    if ( pNdr->IsPointer() || pNdr->IsArray() ||
            (pNdr->IsInterfacePointer() ) )
        return SIZEOF_MEM_PTR();

    if ( pNdr->IsSimpleType() || pNdr->IsStruct() || pNdr->IsUnion() )
        return pNdr->GetMemorySize();

    if ( pNdr->IsAHandle() )
        {
        //
        // We only get here for primitive and context handles.  For
        // primitive handles we know the pushed size is always 4.
        //
        // For context handles this is a major hassle and for now we assume
        // that the underlying user defined type is a pointer.
        //

        return SIZEOF_MEM_PTR();
        }

    if ( pNdr->GetCGID() == ID_CG_TRANSMIT_AS )
        return ((CG_TRANSMIT_AS *)pNdr)->GetStackSize();

    if ( pNdr->GetCGID() == ID_CG_REPRESENT_AS )
        return ((CG_REPRESENT_AS *)pNdr)->GetStackSize();

    if ( pNdr->GetCGID() == ID_CG_USER_MARSHAL )
        return ((CG_USER_MARSHAL *)pNdr)->GetStackSize();

    if (IsAsyncHandleParam())
        return SIZEOF_MEM_PTR();

    return 0;
}



short CG_PROC::GetFloatArgMask( CCB * pCCB )
/*++
Routine Description:

    On Ia64 floating point types are passed in floating point registers 
    instead of general registers.  Just to make life difficult "homogenous
    floating point aggregates" (structs that only contain floats/doubles or
    other HFA's) are also passed in floating point registers.  Floating point
    registers are allocated sequentially and out of sync with general 
    registers so e.g. if the third paramater was the first floating point
    argument it would go in the first floating point register and a "hole" 
    would be left in the third general register.

    The floating point mask consists of a series of 2-bit nibbles, one for 
    each general register slot.  This nibble contains a 0 if the register slot
    does not have a floating point value, a 1 for single precsion, a 2 for
    double, and a 3 for dual singles.

--*/
{
    MIDL_ASSERT( pCommand->Is64BitEnv() );

    enum FloatType
    {
        NonFloat    = 0,
        Single      = 1,
        Double      = 2,
        DualSingle  = 3
    };

    CG_ITERATOR Iterator;
    CG_PARAM   *pParam;
    unsigned    mask = 0;
    int         floatslot = 0;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) && floatslot < 8 )
        {
        CG_NDR *pChild = (CG_NDR *) pParam->GetChild();
        if ( pChild->IsArray() )
            continue;

        bool issingle = pChild->IsHomogeneous(FC_FLOAT);
        bool isdouble = pChild->IsHomogeneous(FC_DOUBLE);

        if ( issingle || isdouble )
            {
            long      slot = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );
            long      size = pParam->GetStackSize();
            FloatType type;

            slot /= 8;
            size /= (isdouble ? 8 : 4);

            while (size > 0 && floatslot < 8)
                {
                if (isdouble)
                    type = Double;
                else if (size > 1 && floatslot < 7)
                    type = DualSingle;
                else 
                    type = Single;

                mask |= type << (slot * 2);

                slot      += 1;
                size      -= 1 + (DualSingle == type);
                floatslot += 1 + (DualSingle == type);
                }
            }
        }

    return (short) (mask & 0xffff);
}



char *
CG_PROC::SetCallAsName( char * pName )
        {
        return (pCallAsName = pName);
        }

void
CG_PROC::GetCommAndFaultOffset(
    CCB *   pCCB,
    long &  CommOffset,
    long &  FaultOffset )
{
    CG_ITERATOR Iterator;
    CG_PARAM *  pParam;
    CG_NDR *    pOldCGNodeContext;

    //
    // 0 is of course a valid offset.
    // -1 offset means it is the return value.
    // -2 offset means it was not specified in the proc.
    //

    CommOffset = -2;
    FaultOffset= -2;

    if ( ! HasStatuses() )
        return;

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( (pParam->GetStatuses() == STATUS_COMM) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            CommOffset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );
            }

        if ( (pParam->GetStatuses() == STATUS_FAULT) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            FaultOffset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );
            }
        }

    if ( ( pParam = GetReturnType() ) != 0 )
        {
        if ( (pParam->GetStatuses() == STATUS_COMM) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            CommOffset = -1;
            }

        if ( (pParam->GetStatuses() == STATUS_FAULT) ||
             (pParam->GetStatuses() == STATUS_BOTH) )
            {
            FaultOffset = -1;
            }
        }

    pCCB->SetCGNodeContext( pOldCGNodeContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\paddict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
    
    paddict.cxx

 Abstract:

    Implement a counted dictionary class.

    Implements a dictionary for handling padding expressions for unknown
    represent as data types.

    Implements a dictionary for handling sizing macro for unknown
    represent as data types.

    Implements Quintuple dictionary for registering all type names for both
    transmit_as and represent_as.

    Implements Quadruple dictionary for handling usr_marshal.

 Notes:


 History:

     Jan 25, 1994        RyszardK        Created

 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

#include "typecls.hxx"

/////////////////////////////////////////////////////////////////////////////
//
//  CountedDictionary class.
//
/////////////////////////////////////////////////////////////////////////////

unsigned short
CountedDictionary::GetListOfItems(
    ITERATOR&    ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Get a list of dict items into the specified iterator.

 Arguments:
    
    ListIter    - A reference to the iterator class where the list is
                  accumulated.

 Return Value:
    
    A count of the number of dictionary elements.

 Notes:

----------------------------------------------------------------------------*/
{
    Dict_Status     Status;
    void *          pR;
    short           Count = 0;
    
    //
    // Get to the top of the dictionary.
    //

    Status = Dict_Next( (pUserType) 0 );

    //
    // Iterate till the entire dictionary is done.
    //

    while( SUCCESS == Status )
        {
        pR = Dict_Curr_Item();
        ITERATOR_INSERT( ListIter, pR );
        Count++;
        Status = Dict_Next( pR );
        }

    return Count;
}

void *
CountedDictionary::GetFirst()
{
    Dict_Status     Status;
    void *          pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = Dict_Curr_Item();

    return( pFirst );
}

void *
CountedDictionary::GetNext()
{
    Dict_Status     Status;
    void            *pCurr, *pNext = 0;

    pCurr = Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = Dict_Curr_Item();
        }

    return( pNext );
}


SSIZE_T
CountedDictionary::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare two Counted types. Defaults to string comparison.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    return( strcmp( (char *)pE1, (char *)pE2) );
}

//===========================================================================


void 
RepAsPadExprDict::Register(
    unsigned long   Offset,
    node_skl *      pStructType,
    char *          pFieldName,
    node_skl *      pPrevFieldType
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a padding expression description to the dictionary

Arguments:

    Offset          - offset of the padding field
    pPaddingExpr    - text of the expression to be printed out
    
----------------------------------------------------------------------------*/
{
    Dict_Status    Status;

    REP_AS_PAD_EXPR_DESC * pOldEntry;
    REP_AS_PAD_EXPR_DESC * pEntry = new REP_AS_PAD_EXPR_DESC;

    pEntry->KeyOffset = Offset;
    pEntry->pStructType = pStructType;
    pEntry->pFieldName =  pFieldName;
    pEntry->pPrevFieldType =  pPrevFieldType;

    Status    = Dict_Find( pEntry );

    switch( Status )
        {
        case EMPTY_DICTIONARY:
        case ITEM_NOT_FOUND:

            Dict_Insert( pEntry );
            EntryCount++;
            break;

        default:
            // The only reason for an entry (offset) to be used already
            // would be that the otimization has shrunk the format string.
            // This means that the old entry should be deleted.

            pOldEntry = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

            Dict_Delete( (pUserType *) &pOldEntry );
            Dict_Insert( pEntry );
            break;
        }
    return;
}


SSIZE_T
RepAsPadExprDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare pad expr descriptors.
     KeyOffset is the key that orders the entries.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    if( ((REP_AS_PAD_EXPR_DESC *)pE1)->KeyOffset <
                                ((REP_AS_PAD_EXPR_DESC *)pE2)->KeyOffset )
        return( -1 );
    else
    if( ((REP_AS_PAD_EXPR_DESC *)pE1)->KeyOffset >
                                ((REP_AS_PAD_EXPR_DESC *)pE2)->KeyOffset )
        return( 1 );
    else
        return( 0 );
}

REP_AS_PAD_EXPR_DESC *
RepAsPadExprDict::GetFirst()
{
    Dict_Status             Status;
    REP_AS_PAD_EXPR_DESC *  pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

    return( pFirst );
}

REP_AS_PAD_EXPR_DESC *
RepAsPadExprDict::GetNext()
{
    Dict_Status             Status;
    REP_AS_PAD_EXPR_DESC    *pCurr, *pNext = 0;

    pCurr = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();
        }

    return( pNext );
}

void
RepAsPadExprDict::WriteCurrentPadDesc(
    ISTREAM * pStream
    )
/*++

Routine description:

    Writes out the following string:

        (unsigned char)(NdrFieldPad(pSN,pFN,pPFN,pPFT))

Arguments:

    pStream -   stream to write to.

--*/
{
    REP_AS_PAD_EXPR_DESC    *pCurr = (REP_AS_PAD_EXPR_DESC *)Dict_Curr_Item();

    if ( pCurr  &&  pCurr->pPrevFieldType )
        {
        pStream->Write( "(unsigned char)("FC_FIELD_PAD_MACRO"(" );
        pCurr->pStructType->PrintType( PRT_TYPE_SPECIFIER, pStream );
        pStream->Write( ',' );
        pStream->Write( pCurr->pFieldName );
        pStream->Write( ',' );
        pStream->Write( pCurr->pPrevFieldType->GetSymName() );
        pStream->Write( ',' );
        pCurr->pPrevFieldType->GetChild()->
                                PrintType( PRT_TYPE_SPECIFIER, pStream );
        pStream->Write( "))," );
        }
    else
        pStream->Write( "0," );
}


//========================================================================


void 
RepAsSizeDict::Register(
    unsigned long   Offset,
    char *          pTypeName
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a sizing macro description to the dictionary

Arguments:

    Offset          - offset of the padding field
    pPaddingExpr    - text of the expression to be printed out
    
----------------------------------------------------------------------------*/
{
    Dict_Status    Status;

    REP_AS_SIZE_DESC * pOldEntry;
    REP_AS_SIZE_DESC * pEntry = new REP_AS_SIZE_DESC;

    pEntry->KeyOffset = Offset;
    pEntry->pTypeName =  pTypeName;

    Status    = Dict_Find( pEntry );

    switch( Status )
        {
        case EMPTY_DICTIONARY:
        case ITEM_NOT_FOUND:

            Dict_Insert( pEntry );
            EntryCount++;
            break;

        default:
            // The only reason for an entry (offset) to be used already
            // would be that the otimization has shrunk the format string.
            // This means that the old entry should be deleted.

            pOldEntry = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

            Dict_Delete( (pUserType *) &pOldEntry );
            Dict_Insert( pEntry );
            break;
        }
    return;
}


SSIZE_T
RepAsSizeDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare size descriptors.
     KeyOffset is the key that orders the entries.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    if( ((REP_AS_SIZE_DESC *)pE1)->KeyOffset <
                                ((REP_AS_SIZE_DESC *)pE2)->KeyOffset )
        return( -1 );
    else
    if( ((REP_AS_SIZE_DESC *)pE1)->KeyOffset >
                                ((REP_AS_SIZE_DESC *)pE2)->KeyOffset )
        return( 1 );
    else
        return( 0 );
}

REP_AS_SIZE_DESC *
RepAsSizeDict::GetFirst()
{
    Dict_Status         Status;
    REP_AS_SIZE_DESC *  pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

    return( pFirst );
}

REP_AS_SIZE_DESC *
RepAsSizeDict::GetNext()
{
    Dict_Status         Status;
    REP_AS_SIZE_DESC    *pCurr, *pNext = 0;

    pCurr = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = (REP_AS_SIZE_DESC *)Dict_Curr_Item();
        }

    return( pNext );
}

void
RepAsSizeDict::WriteCurrentSizeDesc(
    ISTREAM * pStream
    )
/*++

Routine description:

    Writes out the following string:

        NdrFcShort( sizeof(<type>) 

Arguments:

    pStream -   stream to write to.

--*/
{
    REP_AS_SIZE_DESC    *pCurr = (REP_AS_SIZE_DESC *)Dict_Curr_Item();

    if ( pCurr )
        {
        pStream->Write( "NdrFcShort( sizeof(" );
        pStream->Write( pCurr->pTypeName );
        pStream->Write( "))," );
        }
    else
        pStream->Write( "0," );
}


//========================================================================


BOOL 
QuintupleDict::Add(
    void *          pContext
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a Quintuple description to the dictionary.

Arguments:

Returns:

    TRUE    - when a new entry has been registered,
    FALSE   - otherwise

    Index field gets set to appropriate index.

    
----------------------------------------------------------------------------*/
{
    Dict_Status         Status;
    XMIT_AS_CONTEXT  *  pEntry = (XMIT_AS_CONTEXT *) pContext;

    Status = Dict_Find( pEntry );

    if( Status == EMPTY_DICTIONARY  ||  Status == ITEM_NOT_FOUND )
        {
        pEntry->Index = CurrentIndex;
        Dict_Insert( pEntry );
        CurrentIndex++;
        return TRUE;
        }
    else
        {
        pEntry->Index = ((XMIT_AS_CONTEXT *)Dict_Curr_Item())->Index;
        return FALSE;
        }
}


SSIZE_T
QuintupleDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare two quintuple types.
     Both fXmit and the name have to match.

     fXmit allows for comparing xmit_as with xmit_as and rep_as with rep_as.
     For xmit_as we compare the presented types.
     For rep_as we compare the wire types (not the local types).

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    if( ((XMIT_AS_CONTEXT *)pE1)->fXmit == ((XMIT_AS_CONTEXT *)pE2)->fXmit )
        if ( ((XMIT_AS_CONTEXT *)pE1)->fXmit )
            return( strcmp( ((XMIT_AS_CONTEXT *)pE1)->pTypeName,
                            ((XMIT_AS_CONTEXT *)pE2)->pTypeName ) );
        else
            return( strcmp(
                ((CG_REPRESENT_AS *)((XMIT_AS_CONTEXT *)pE1)->pXmitNode)->
                            GetTransmittedType()->GetSymName(),
                ((CG_REPRESENT_AS *)((XMIT_AS_CONTEXT *)pE2)->pXmitNode)->
                            GetTransmittedType()->GetSymName()
                           ) );
    else
    if( ((XMIT_AS_CONTEXT *)pE1)->fXmit )
        return( -1 );
    else
        return( 1 );
}

void *
QuintupleDict::GetFirst()
{
    Dict_Status             Status;
    XMIT_AS_CONTEXT *  pFirst = 0;

    Status = Dict_Next( 0 );

    if ( Status == SUCCESS )
        pFirst = (XMIT_AS_CONTEXT *)Dict_Curr_Item();

    return( pFirst );
}

void *
QuintupleDict::GetNext()
{
    Dict_Status             Status;
    XMIT_AS_CONTEXT    *pCurr, *pNext = 0;

    pCurr = (XMIT_AS_CONTEXT *)Dict_Curr_Item();

    if ( pCurr )
        {
        Status = Dict_Next( pCurr );
        if ( Status == SUCCESS )
            pNext = (XMIT_AS_CONTEXT *)Dict_Curr_Item();
        }

    return( pNext );
}

//========================================================================


BOOL 
QuadrupleDict::Add(
    void *          pContext
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Adds a Quadruple description to the dictionary.

Arguments:

Returns:

    TRUE    - when a new entry has been registered,
    FALSE   - otherwise entry exist already

    Index field gets set to appropriate index.

    
----------------------------------------------------------------------------*/
{
    Dict_Status             Status;
    USER_MARSHAL_CONTEXT *  pEntry = (USER_MARSHAL_CONTEXT *) pContext;

    Status = Dict_Find( pEntry );

    if( Status == EMPTY_DICTIONARY  ||  Status == ITEM_NOT_FOUND )
        {
        pEntry->Index = GetCount();
        Dict_Insert( pEntry );
        IncrementCount();
        return TRUE;
        }
    else
        {
        pEntry->Index = ((USER_MARSHAL_CONTEXT *)Dict_Curr_Item())->Index;
        return FALSE;
        }
}


SSIZE_T
QuadrupleDict::Compare(
    pUserType   pE1,
    pUserType   pE2
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

     Compare two Quadruple types.
     For usr_marshall we compare the types.

 Arguments:

 Return Value:
    
----------------------------------------------------------------------------*/
{
    return( strcmp( ((USER_MARSHAL_CONTEXT *)pE1)->pTypeName,
                    ((USER_MARSHAL_CONTEXT *)pE2)->pTypeName ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\procgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    procgen.cxx

 Abstract:

    code generation for procedures.


 Notes:


 History:

    Aug-15-1993     VibhasC     Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *  externs
 ***************************************************************************/
extern  CMD_ARG             *   pCommand;
void GenCorrInit( CCB* );
void GenCorrPassFree( CCB*, char* );

/****************************************************************************/

CG_STATUS
CG_PROC::GenClientStub(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate client stub.

 Arguments:

    pCCB    - pointer to code generation control block.


 Return Value:

    A status of the code generation.

 Notes:

    Set up local variables, parameters etc.
    Perform buffer size and marshalling analysis.
    Generate the stub.


    The strategy for binding is now different than the old stubs. The actual
    binding is performed AFTER the sizing is performed, right at the first
    get buffer call. This allows us to combine the message init and the call
    to get buffer and binding into one single call to an ndr routine.
    Significant code / time savings.
----------------------------------------------------------------------------*/
{
    ANALYSIS_INFO   Analysis;
    BOOL            fHasExceptionHandler = FALSE;
    ISTREAM *   pStream = pCCB->GetStream();

    // [nocode] procs get no client side stub; although they do get a
    // server side stub
    if ( IsNoCode() )
        return CG_OK;

    // call_as procs need additional prototypes
    if ( pCallAsName )
        pCCB->RegisterCallAsRoutine( (node_proc *)GetType() );

    //
    // Set the CCB code generation side.
    //
    pCCB->SetCodeGenSide( CGSIDE_CLIENT );
    pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

    //
    // Change to -Os if needed because of number of param and/or stack size.
    //
    (void) MustUseSingleEngineCall( pCCB );
    pCCB->SetOptimOption( GetOptimizationFlags() );

    Analysis.SetCurrentSide( C_SIDE );
    Analysis.SetOptimOption( pCCB->GetOptimOption() );
    Analysis.SetMode( pCCB->GetMode() );
    Analysis.SetRpcSSSwitchSet( (unsigned long)pCCB->IsRpcSSSwitchSet() );

    // Declare pre-allocated resources. All params are registered as resources,
    // The standard local variables : an rpc message and the stub message are
    // also set up local variables.

    C_PreAllocateResources( &Analysis );

    // Set current phase. Perform buffer size, binding and marshalling analysis.
    // The binding analysis usually sets up resources needed for binding.

    Analysis.SetCurrentPhase( ANA_PHASE_CLIENT_MARSHALL );

    C_BindingAnalysis( &Analysis );
    MarshallAnalysis( &Analysis );

    // Perform analysis to check if anything needs to be done for ref
    // pointer checks. This is especially needed for arrays of ref pointers
    // where we need to declare indexes for each array dimension.

    RefCheckAnalysis( &Analysis );

    // Perform the unmarshalling analysis. This allows the cg nodes to set
    // up for unmarshall, figure out local variables needed if any.

    Analysis.SetCurrentPhase( ANA_PHASE_CLIENT_UNMARSHALL );
    UnMarshallAnalysis( &Analysis );

    // Perform the Out Local analysis even on the client side, so the engine
    // format string generation will get information if the pointer is
    // allocated on stack. One the client side  this call will NOT actually
    // allocate a resource.

    S_OutLocalAnalysis( &Analysis );

    // Perform this analysis on the client side so the format string is
    // correct for server. It is needed for -Oi RpcSs flag generation.

    RpcSsPackageAnalysis( &Analysis );

    // Find out which alloc and free routines should be put in the stub
    // descriptor.

    PNAME AllocRoutineName, FreeRoutineName;

    GetCorrectAllocFreeRoutines( pCCB,
                                 FALSE,  //client
                                 & AllocRoutineName,
                                 & FreeRoutineName );


    // Init the code gen. controller block for a new procedure. The resource
    // dictionary data base is handed over to the code generation controller
    // for use.

    pCCB->InitForNewProc(
                         GetProcNum(),
                         (RPC_FLAGS) 0,                 // rpc flags
                         AllocRoutineName,
                         FreeRoutineName,
                         Analysis.GetResDictDatabase()  // resource dict.
                        );

    // If the single engine call is to be used, send message to the ndr
    // code generator.

    if ( MustUseSingleEngineCall( pCCB ) )
        {
        if ( IsObject() )
            {
            //
            // Non-call_as object proxies are now stubless.
            //

            if (((CG_OBJECT_PROC *)this)->IsStublessProxy())
                return CG_OK;

            ((CG_OBJECT_PROC *)this)->Out_ProxyFunctionPrototype(pCCB,0);
            pStream->WriteOnNewLine( "{" );
            pStream->NewLine();
            }
        else
            {
            // Generate the function header.
            Out_ClientProcedureProlog( pCCB, GetType() );

            Out_IndentInc( pCCB );
            pStream->NewLine();
            }

        GenNdrSingleClientCall( pCCB );

        Out_IndentDec( pCCB );
        Out_ProcClosingBrace( pCCB );

        // All done.
        return CG_OK;
        }

    pCCB->SetCGNodeContext( this );

    MIDL_ASSERT( pCommand->IsNDRRun() || pCommand->IsNDR64Run() );

    //
    // Always create the format string for the proc.
    //
    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    // Generate the prolog, the sizing code. Then once the length has been
    // calculated, go ahead and perform the binding using our ndr routines.
    // The call to the ndr routine returns a buffer pointer ready for
    // marshalling.

    C_GenProlog( pCCB );

    if ( ( fHasExceptionHandler = ( HasStatuses() || IsObject() ) ) == TRUE )
        {
        Out_RpcTryExcept( pCCB );
        }

    if ( HasFullPtr() )
        Out_FullPointerInit( pCCB );

    // Generate the null ref check code.
    // For object interfaces we need to generate a call to initialize proxy
    // first as we won't be able to walk parameters later for cleanup.
    // For raw interfaces we don't ned to move initialization call
    // as we don't have the walk problem.

    if ( IsObject() )
        C_GenBind( pCCB );

    if( pCCB->MustCheckRef() )
        GenRefChecks( pCCB );

    Out_RpcTryFinally( pCCB);

    if ( !IsObject() )
        C_GenBind( pCCB );

    // generate NdrCorrelationInitialize( _StubMsg, _NdrCorrCache, _NdrCorrCacheSize, _NdrCorrFlags );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrInit( pCCB );
        }

    // If the rpc ss package is to be enabled, do so.
    // It would need to be enabled explicitely on the client side when
    // in non-osf mode, with the attribute on the operation AND
    //      - the routine is a callback,
    //      - the routine is not a callback and the interface doesn't
    //        have the attribute (if it does, we optimized via stub descr.)

    if( pCCB->GetMode()  &&  MustInvokeRpcSSAllocate()
        &&
        ( GetCGID() == ID_CG_CALLBACK_PROC  ||
          GetCGID() != ID_CG_CALLBACK_PROC  &&
                                    ! pCCB->GetInterfaceCG()->IsAllRpcSS())
        )
        {
        Out_RpcSSSetClientToOsf( pCCB );
        }

    GenSizing( pCCB );

    GenMarshall( pCCB );

    // Generate the send receive.

    C_GenSendReceive( pCCB );

    // Before Win2000 Ndr<whatetver>SendReceive didn't set the BufferStart
    // and BufferEnd fields.  Do it now.

    pStream->WriteOnNewLine( "_StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; ");
    pStream->WriteOnNewLine( "_StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;" );
    pStream->NewLine();
    
    pCCB->SetCodeGenPhase( CGPHASE_UNMARSHALL );
    GenUnMarshall( pCCB );

    // generate NdrCorrelationPass( _StubMsg );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_PASS_RTN_NAME );
        }

    Out_RpcFinally( pCCB );
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_FREE_RTN_NAME );
        }
    if ( HasFullPtr() )
        Out_FullPointerFree( pCCB );
    C_GenFreeBuffer( pCCB );
    C_GenUnBind( pCCB );
    Out_RpcEndFinally( pCCB );

    if( fHasExceptionHandler )
        {

        if(IsObject())
            {
            ISTREAM * pStream = pCCB->GetStream();

            pStream->NewLine();
            pStream->Write('}');
            pStream->IndentDec();
            pStream->NewLine();
            pStream->Write( "RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)" );
            pStream->IndentInc();
            pStream->NewLine();
            pStream->Write( '{' );
            }
        else
            {
            Out_RpcExcept( pCCB, "1" );
            }

        if(ReturnsHRESULT())
            {
            C_GenClearOutParams( pCCB );
            C_GenMapHRESULT( pCCB );
            }
        else if( HasStatuses() )
            {
            C_GenMapCommAndFaultStatus( pCCB );
            }
        else
            {
            Out_RaiseException( pCCB, "RpcExceptionCode()" );
            }

        Out_RpcEndExcept( pCCB );
        }
    // All done, emit the final closed curly and we're done.
    GenEpilog( pCCB );

    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenMapCommAndFaultStatus(
    CCB     *   pCCB )
    {
    CG_NDR  *   pTemp   = 0;
    CG_NDR  *   pComm   = 0;
    CG_NDR  *   pFault  = 0;
    CG_NDR  *   pRT;
    int         i = 0;
    expr_node   *   pCommExpr;
    expr_node   *   pFaultExpr;
    BOOL        fReturnHasStatus = FALSE;

    ITERATOR    I;

    GetMembers( I );

    if ( (pRT = GetReturnType()) != 0 && (fReturnHasStatus = pRT->HasStatuses() ) == TRUE )
        ITERATOR_INSERT( I, pRT );

    while( ITERATOR_GETNEXT(I, pTemp ) && (i < 2) )
        {
        if( pTemp->HasStatuses() )
            {
            if( pTemp->GetStatuses() == STATUS_COMM )
                pComm = pTemp;
            if( pTemp->GetStatuses() == STATUS_FAULT )
                pFault = pTemp;
            if( pTemp->GetStatuses() == STATUS_BOTH )
                {
                pComm = pFault = pTemp;
                break;
                }
            }
        }

    if( pComm )
        {
        if( pComm == pRT )
            pCommExpr = MakeAddressExpressionNoMatterWhat( pRT->GetResource() );
        else
            pCommExpr = pComm->GetResource();
        }
    else
        pCommExpr = new expr_constant(0L);

    if( pFault )
        {
        if( pFault == pRT )
            pFaultExpr = MakeAddressExpressionNoMatterWhat(pRT->GetResource());
        else
            pFaultExpr = pFault->GetResource();
        }
    else
        pFaultExpr = new expr_constant(0L);

    Out_CallNdrMapCommAndFaultStatus( pCCB,
                                      MakeAddressExpressionNoMatterWhat(
                                             pCCB->GetStandardResource(
                                                 ST_RES_STUB_MESSAGE_VARIABLE)),
                                      GetStatusResource(),
                                      pCommExpr,
                                      pFaultExpr );
    return CG_OK;
    }

CG_STATUS
CG_PROC::C_GenClearOutParams(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to clear out params in the case of exceptions.

 Arguments:

    pCCB    - The code gen controller block.

 Return Value:

    CG_OK
    
 Notes:

    Generate a call to a varargs function which will take a stub message, a
    format string offset and a list of all output parameters.
----------------------------------------------------------------------------*/
{
    ITERATOR    I;
    expr_proc_call *   pProc;
    expr_node       *   pExpr;
    short               Count;
    CG_PARAM        *   pParam;
    ISTREAM         *   pStream = pCCB->GetStream();

    // The first parameter is the stub message.

    Count =  GetOutParamList( I );

    // For each of the output parameters, call the ndr clear out parameters
    // procedure.

    ITERATOR_INIT( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        pParam->GenNdrTopLevelAttributeSupport( pCCB, TRUE );

        // Create a call to the procedure.

        pProc   = new expr_proc_call( C_NDR_CLEAR_OUT_PARAMS_RTN_NAME );

        // First param is the address of the stub message.

        pExpr   = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME,
                                                  pExpr );
        pProc->SetParam( pExpr );


        // Second param is the  format string offset of the first out parameter.
        // Emitted as &__MIDL_FormatString[ ?? ]


        pExpr   = Make_1_ArrayExpressionFromVarName(
                                 FORMAT_STRING_STRING_FIELD,
                                 ((CG_NDR *)(pParam->GetChild()))->GetFormatStringOffset() );
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr   = MakeExpressionOfCastToTypeName(
                                             PFORMAT_STRING_TYPE_NAME,
                                             pExpr);

        pProc->SetParam( pExpr );

        // The last param is the [out] parameter itself.

        pProc->SetParam( MakeCastExprPtrToVoid(pParam->GetResource()) );

        pStream->NewLine();
        pProc->PrintCall( pStream, 0, 0 );
        }

    return CG_OK;

}

CG_STATUS
CG_PROC::C_GenMapHRESULT(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates code to map exceptions into HRESULT return values.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ISTREAM *pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write("_RetVal = NdrProxyErrorHandler(RpcExceptionCode());");
    return CG_OK;
}


CG_STATUS
CG_PROC::C_GenProlog(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the procedure prolog for the stub procedure.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise

 Notes:

    Increment the stream indentation at the end of the prolog.
    Although we register params as param resources, we dont generate the
    procedure signature using the PrintType/Decl facility.
----------------------------------------------------------------------------*/
{

    ITERATOR        I;
    ITERATOR        T;

    // Output the bare procedure declaration

    Out_ClientProcedureProlog( pCCB, GetType() );

    // Generate declarations for pre-allocated and analyser-determined locals.

    pCCB->GetListOfLocalResources( I );
    Out_ClientLocalVariables( pCCB, I );

    pCCB->GetListOfTransientResources( T );
    Out_ClientLocalVariables( pCCB, T );

    // Increment the indentation of the output stream. Reset at epilog time.

    Out_IndentInc( pCCB );

    //
    // This is where we output additional variable declarations to handle
    // multidimensional conformant/varying arrays.
    //

    CG_ITERATOR Iterator;
    ISTREAM *   pStream;
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;

    pStream = pCCB->GetStream();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVars( pCCB, pParam );
        }
    Iterator.Init();
    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVarsInit( pCCB, pParam );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenBind(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to bind to server.

 Arguments:

    pCCB    - A pointer to the code generation controller block.
    pAna    - A pointer to the analysis information.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    The binding process is a part of the stub message initialization. The
    stub initializing routine takes the actual binding as a parameter. The
    binding therefore is done as part of the call to this init routine. This
    routine also calls rpc get buffer. This is a change from the erstwhile
    stub generation when binding was done first before the size pass. With
    this call which takes the length as a parameter which means that now we
    will do the sizing pass before the binding pass.

    In case of auto handles, the call is a slightly different one.

    Also, we need to assign to the local buffer pointer variable only if there
    is at least one param that is shipped.

----------------------------------------------------------------------------*/
{
    ITERATOR            BindingParamList;
    expr_node       *   pExpr;
    expr_node       *   pExprStubMsg;
    BOOL                fCallBack = (GetCGID() == ID_CG_CALLBACK_PROC);

    //
    // collect standard arguments to the init procedure.
    //

    // The rpc message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_RPC_MESSAGE_VARIABLE );
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PRPC_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub message variable.

    pExpr   = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE);
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );
    pExprStubMsg = pExpr;
    ITERATOR_INSERT(
                    BindingParamList,
                    pExpr
                   );

    // The stub descriptor structure variable. This is not allocated as
    // a resource explicitly.

    pExpr   = new RESOURCE( pCCB->GetInterfaceCG()->GetStubDescName(),
                            (node_skl *)0 );

    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_DESC_STRUCT_TYPE_NAME,
                                              pExpr );

    ITERATOR_INSERT( BindingParamList, pExpr );

    //
    // Proc num.
    //
    ITERATOR_INSERT( BindingParamList,
                     new expr_constant( (long) GetProcNum() ) );

    // This call doesn't do much nowadays except for generating
    // the initialize call and rpc flags assignment and so could
    // be eliminated.

    Out_HandleInitialize( pCCB,
                          BindingParamList,
                          0,
                          IsAutoHandle(),
                          (unsigned short) GetOperationBits()
                        );

    // Generate an explicit binding call depending upon the handle or callback.
    if( fCallBack )
        {
        pExpr   = new expr_proc_call( CALLBACK_HANDLE_RTN_NAME );
        pExpr   = new expr_assign( GetBindingResource(), pExpr );
        }
    else
        {
        pExpr   = GenBindOrUnBindExpression( pCCB,
                                             TRUE   // call to bind.
                                           );
        }

    // Emit the handle init expression.

    if( IsContextHandle() )
        {

        // Special for context handles:
        // The bind expression will contain only the context handle expression,
        // and not the assignment to the binding handle variable. This is to
        // be done right here. This is because some special code has to be
        // generated for context handles for error checking.

        // if the context handle param is [in] generate code of the form:
        //  if( Context_Handle != 0 )
        //      {
        //      _Handle = NdrContextBinding( Context_Handle );
        //      }
        //  else
        //      {
        //      RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );
        //      }
        //
        // if the context handle is [in, out] then generate code of the form:
        //  if( Context_Handle != 0 )
        //      {
        //      Handle = NdrContextBinding( Context_Handle );
        //      }
        //  else
        //      {
        //      _Handle = 0;
        //      }

        // Note: The case of [out] context handle will never come here since
        // this context handle is not a binding handle, and hence will be
        // handled elsewhere.
        //

        ITERATOR    I;
        BOOL        fIn     = (SearchForBindingParam())->IsParamIn();
        BOOL        fInOut  = ((SearchForBindingParam())->IsParamOut()
                                &&
                                fIn );

        // For now assume we always have error checking on. When we get -error
        // none implemented on procs, we can set it based on that.

        BOOL        fErrorCheckReqd = pCCB->MustCheckRef();
        expr_node   *   pAss;
        expr_node   *   pContextParam   =  ((CG_NDR *)SearchForBindingParam())->
                                                GenBindOrUnBindExpression(
                                                                pCCB, TRUE );


        pExpr   =  pContextParam;
        pExpr   = MakeExpressionOfCastToTypeName( CTXT_HDL_C_CONTEXT_TYPE_NAME,
                                                pExpr
                                              );

        ITERATOR_INSERT( I, pExpr );

        pExpr   = MakeProcCallOutOfParamExprList( CTXT_HDL_BIND_RTN_NAME,
                                                  (node_skl *)0,
                                                  I
                                                );
        pAss= new expr_assign(GetBindingResource(), pExpr);

        if( !fErrorCheckReqd )
            {
            pCCB->GetStream()->NewLine();
            pAss->PrintCall( pCCB->GetStream(), 0, 0 );
            pCCB->GetStream()->Write(';');
            pCCB->GetStream()->NewLine();
            }
        else
            {
            Out_If( pCCB, new expr_relational(OP_NOT_EQUAL,
                                               pContextParam,
                                               new expr_constant(0L) ) );
            pCCB->GetStream()->NewLine();
            pAss->PrintCall( pCCB->GetStream(), 0, 0 );
            pCCB->GetStream()->Write(';');
            pCCB->GetStream()->NewLine();
            Out_Endif( pCCB );

            if( !fInOut )
                {
                Out_Else( pCCB );
                Out_RaiseException( pCCB, "RPC_X_SS_IN_NULL_CONTEXT" );
                Out_Endif( pCCB );
                }
            }
        }
    else if( pExpr )
        {
        pCCB->GetStream()->NewLine();
        pExpr->PrintCall( pCCB->GetStream(), 0, 0 );
        pCCB->GetStream()->Write(';');
        pCCB->GetStream()->NewLine();

        if ( IsGenericHandle() )
            {
            // For generic handles generate a check that the handle
            // is not null after calling user's bind routine.

            Out_If( pCCB, new expr_relational( OP_EQUAL,
                                               GetBindingResource(),
                                               new expr_constant(0L) ) );
            Out_RaiseException( pCCB, "RPC_S_INVALID_BINDING" );
            Out_Endif( pCCB );
            }
        }


    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenSendReceive(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call the rpc runtime sendreceive.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

     We will always call an ndr routine for the sendreceive call. This
     is so that we can unify the buffer length updating in that one call.
     The only difference is for Auto handles when we will have to call this
     with an additional parameter.
----------------------------------------------------------------------------*/
{
    PNAME               pProcName;
    expr_proc_call  *   pProc;
    expr_node       *   pExpr;
    expr_node       *   pStubMsgExpr    = pCCB->GetStandardResource(
                                            ST_RES_STUB_MESSAGE_VARIABLE );
    ITERATOR            ParamsList;

    //
    // Check if we're targeting the ndr engine.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_SIZE )
        {
        if ( IsAutoHandle() )
            Out_NdrNsSendReceive( pCCB );
        else
            Out_NdrSendReceive( pCCB );

        return CG_OK;
        }

    // update the param list with a pointer to the stub message.

    pStubMsgExpr    = MakeAddressExpressionNoMatterWhat( pStubMsgExpr );

    ITERATOR_INSERT( ParamsList, pStubMsgExpr );

    // In case of auto handles, an additional param is reqd, viz the
    // address of the auto handle variable.

    if( IsAutoHandle() )
        {
        pExpr   = pCCB->GetStandardResource( ST_RES_AUTO_BH_VARIABLE );
        pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
        ITERATOR_INSERT( ParamsList, pExpr );
        pProcName   = AUTO_SR_NDR_RTN_NAME;
        }
    else
        {
        pProcName   = NORMAL_SR_NDR_RTN_NAME;
        }

    ITERATOR_INSERT( ParamsList,
                     new expr_variable(  STUB_MSG_BUFFER_VAR_NAME ) );

    // generate the procedure call expression.

    pProc = MakeProcCallOutOfParamExprList( pProcName,
                                            (node_skl *)0,
                                            ParamsList
                                          );

    pCCB->GetStream()->NewLine();
    pProc->PrintCall( pCCB->GetStream(), 0, 0 );

    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenUnBind(
    CCB         *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to unbind from server.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    Dont make unbind calls if not a generic handle.
----------------------------------------------------------------------------*/
{

    if( IsGenericHandle() )
        {
        ISTREAM         *   pStream = pCCB->GetStream();

        expr_proc_call  *   pUnBindCall =
                    (expr_proc_call *)GenBindOrUnBindExpression( pCCB, FALSE );

        pStream->NewLine();
        Out_If( pCCB, GetBindingResource() );
        pStream->NewLine();

        pUnBindCall->PrintCall( pStream, 0, 0 );

        Out_Endif( pCCB );
        }
    return CG_OK;
}

CG_STATUS
CG_PROC::C_GenFreeBuffer(
    CCB             *   pCCB)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate code to call runtime to free the rpc buffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    The analyser will supply the binding information.

----------------------------------------------------------------------------*/
{
    if ( pCCB->GetOptimOption() & OPTIMIZE_SIZE )
        {
        Out_NdrFreeBuffer( pCCB );
        return CG_OK;
        }

    Out_NormalFreeBuffer( pCCB );
    return CG_OK;
}

CG_STATUS
CG_PROC::GenServerStub(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side unmarshalling stub.

 Arguments:

    pCCB    - A pointer to the code generation block.

 Return Value:

    CG_OK   if all is well
    error   otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ANALYSIS_INFO           Analysis;
    DISPATCH_TABLE_FLAGS    Dtf;
    BOOL                    fEmitCheckStubData;

    // call_as procs need additional prototypes
    if ( pCallAsName )
        pCCB->RegisterCallAsRoutine( (node_proc *)GetType() );

    BOOL fPicklingProcOrType =  GetCGID() == ID_CG_ENCODE_PROC ||
                                GetCGID() == ID_CG_TYPE_ENCODE_PROC;

    //
    // Set the CCB code generation side.
    //
    pCCB->SetCodeGenSide( CGSIDE_SERVER );
    pCCB->SetCodeGenPhase( CGPHASE_UNMARSHALL );
    pCCB->SetOptimOption( GetOptimizationFlags() );


    Analysis.SetCurrentSide( S_SIDE );
    Analysis.SetOptimOption( pCCB->GetOptimOption() );

    // Set the analysis phase to the correct one.

    Analysis.SetCurrentPhase( ANA_PHASE_SERVER_UNMARSHALL );

    //
    // Change to -Os if needed because of number of param and/or stack size.
    //
    (void) MustUseSingleEngineCall( pCCB );
    Analysis.SetOptimOption( pCCB->GetOptimOption() );

    Analysis.SetMode( pCCB->GetMode() );
    Analysis.SetRpcSSSwitchSet( (unsigned long)pCCB->IsRpcSSSwitchSet() );


    // Preallocate param and local resources if needed. We do need at least
    // one param resource - the rpc message pointer.

    S_PreAllocateResources( &Analysis );

    // The unmarshall analysis figures out the local variables needed,
    // and their allocation type. This helps the code generator select the
    // most optimal instruction. This is performed only for [in] and [in,out]
    // params.

    UnMarshallAnalysis( &Analysis );


    // Perform the initialization analysis for the server side locals if
    // allocated for the [out] ONLY parameters.

    S_OutLocalAnalysis( &Analysis );

    // Perform this analysis so the format string is correct for server.
    // It is needed for -Oi RpcSs flag generation.

    RpcSsPackageAnalysis( &Analysis );

    // Perform InLocalAnalysis to allocate any in params( for now arrays of
    // ref pointers only) on the server side stub stack.

    InLocalAnalysis( &Analysis );

    // Perform the size analysis for the marshalling part of the stub.

    Analysis.SetCurrentPhase( ANA_PHASE_SERVER_MARSHALL );

    MarshallAnalysis( &Analysis );


    // Generate the unmarshalling code. Register this procedure with the
    // dispatch table. Copy the resource dictionary from the analysis phase
    // to be used during the code gen phase.

    char * AllocRoutineName, * FreeRoutineName;

    GetCorrectAllocFreeRoutines( pCCB,
                                 TRUE, //client
                                 &AllocRoutineName,
                                 &FreeRoutineName );


    pCCB->InitForNewProc(
                GetProcNum(),                   // procedure number
                (RPC_FLAGS)0,                   // flags, datagram etc
                (PNAME) AllocRoutineName,
                (PNAME) FreeRoutineName,
                Analysis.GetResDictDatabase()   // copy the resource database
                );

    if( HasNotify() || HasNotifyFlag() )
        GetNotifyTableOffset( pCCB );

    // Register the procedure for the dispatch table.
    // If this proc is interpreted, then the dispatch table has an
    // entry which specifies the NdrServerCall rather than the proc name itself.

    if( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {
        Dtf = DTF_INTERPRETER;
        }
    else
        {
        Dtf = DTF_NONE;
        }

    if ( GetCGID() == ID_CG_ENCODE_PROC )
        Dtf = (DISPATCH_TABLE_FLAGS) (Dtf | DTF_PICKLING_PROC);

    if ( GetCGID() != ID_CG_TYPE_ENCODE_PROC )
        pCCB->GetInterfaceCG()->RegisterProcedure( GetType(), Dtf );

    if ( ! fPicklingProcOrType )
        {
        if ( MustUseSingleEngineCall( pCCB ) )
            {
            if ( UseOldInterpreterMode( pCCB ) )
                {
                GenNdrOldInterpretedServerStub( pCCB );
                }

            if ( NeedsServerThunk( pCCB, CGSIDE_SERVER ) )
                {
                GenNdrThunkInterpretedServerStub( pCCB );
                }

            //
            // This will only do something for a [callback] proc when we're
            // called while generating the client side.
            //       
            MIDL_ASSERT( pCommand->IsNDRRun() || pCommand->IsNDR64Run() );

            if ( pCommand->IsNDRRun() )
               {
               GenNdrFormat( pCCB );        
               }
            else 
               {
               pCCB->GetNdr64Format()->Generate( this );
               }

            return CG_OK;
            }
        }

    pCCB->SetCGNodeContext( this );

    //
    // Always create the format string for the proc.
    //

    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    // Dont generate the stub itself for pickling.

    if ( fPicklingProcOrType )
        return( CG_OK );

    // Generate the server side procedure prolog. This generates only the
    // server side proc signature, the locals needed and the stub descriptor
    // structure.

    // This also generates the call to server initialize routine.
    // Note, that it is out of RpcTryFinally, but this is ok as
    // we shouldn't attempt to free parameters (they haven't been
    // unmarshaled yet.

    S_GenProlog( pCCB );
    S_GenInitTopLevelStuff( pCCB );

    S_GenInitInLocals( pCCB );

    // Initialize the local variables allocated on the server side if necessary.
    // Also make the initialization call for the server side stub message which
    // updates the buffer pointer.

    // Generate the unmarshalling code.
    Out_RpcTryFinally( pCCB );

    // If the user specifies the -error stub_data to check server unmarshall
    // errors, we need to enclose the unmarshall in a try except, and in the
    // except clause, raise a bad stub data exception.

    fEmitCheckStubData  = pCCB->IsMustCheckStubDataSpecified() && !IsObject();

    if( fEmitCheckStubData )
        {
        Out_RpcTryExcept( pCCB );
        }

    if ( HasFullPtr() )
        Out_FullPointerInit( pCCB );

    // generate NdrCorrelationInitialize( _StubMsg, _NdrCorrCache, _NdrCorrCacheSize, _NdrCorrFlags );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrInit( pCCB );
        }

    GenUnMarshall( pCCB );

    // generate NdrCorrelationUninitialize( _StubMsg );
    // normally, /deny causes a switch to /Oicf. This code will be executed when a 
    // a switch to from /Os to /Oicf is not posible
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_PASS_RTN_NAME );
        }

    // If the check for bad stub data must be made, then generate a
    // Rpcexcept() to catch some exceptions here, and re-raise a bad
    // stub data exception for them.
    // Other exceptions would propagate unchanged.

    if( fEmitCheckStubData )
        {
        Out_CheckUnMarshallPastBufferEnd( pCCB );
        Out_RpcExcept( pCCB, "RPC_BAD_STUB_DATA_EXCEPTION_FILTER" );
        Out_RaiseException( pCCB, "RPC_X_BAD_STUB_DATA" );
        Out_RpcEndExcept( pCCB );
        }

    S_GenInitOutLocals( pCCB );

    // Generate the call to the actual manager procedure.

    S_GenCallManager( pCCB );

    S_GenInitMarshall( pCCB );

    pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

    GenSizing( pCCB );

    // Generate the server side marshall initialization.

    // Marshall the outs and return value.

    GenMarshall( pCCB );

    Out_RpcFinally( pCCB );
    if ( fHasDeny )
        {
        GenCorrPassFree( pCCB, CSTUB_CORR_FREE_RTN_NAME );
        }

    // When notify is used, guard also against an exception in freeing.
    if( HasNotify() || HasNotifyFlag() )
        {
        Out_RpcTryFinally( pCCB );
        }

    // Free anything that needs freeing.

    GenFree( pCCB );

    if( MustInvokeRpcSSAllocate())
        {
        Out_RpcSSDisableAllocate( pCCB );
        }

    if ( HasFullPtr() )
        Out_FullPointerFree( pCCB );

    // If this is a notify procedure, generate the call to the notify procedure.

    if( HasNotify() || HasNotifyFlag() )
        {
        Out_RpcFinally( pCCB );
        GenNotify( pCCB , HasNotifyFlag() );
        Out_RpcEndFinally( pCCB );
        }

    Out_RpcEndFinally( pCCB );

    // For now, just return.

    GenEpilog( pCCB );

    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenInitMarshall(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side marshall init.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR Iterator;
    ISTREAM *   pStream;
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;

    //
    // We have to fill in the arrays that we use for handling multidimensional
    // arrays.
    //

    pStream = pCCB->GetStream();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVarsInit( pCCB, pParam );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenInitOutLocals(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the initialization of the local variables.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   otherwise.

 Notes:

    This method performs initalization of local variables on the server side.
    Local variables may be declared in the server stub for [out] params, and
    for in parameters which cannot reuse the buffer.

    This method will also perform the stub descriptor structure initialization.
    This method will also perform the server side stub message init.
----------------------------------------------------------------------------*/
{
    CG_ITERATOR     Iter;
    CG_PARAM    *   pParam;

    if( GetMembers( Iter ) )
        {
        while( ITERATOR_GETNEXT( Iter, pParam ) )
            {
            pParam->S_GenInitOutLocals( pCCB );
            }
        }

    //
    // We have to catch initialization of returns of pointers to context
    // handles here.
    //
    if ( GetReturnType() )
        {
        GetReturnType()->S_GenInitOutLocals( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenCallManager(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate a call to the manager routine.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   otherwise.

 Notes:

    Make a procedure node with all the parameters that need to be passed to
    the manager code. The actual expression that needs to be passed to the
    actual manager code is set up during earlier passes. This is called the
    result expression.

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         I;
    PNAME               pName;
    expr_proc_call  *   pProc;
    CG_PARAM        *   pParam;
    expr_node       *   pExpr;
    expr_node       *   pReturnExpr = 0;
    CG_RETURN       *   pRT;
    char            *   pSStubPrefix    = NULL;

    pSStubPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR );

    if ( GetCallAsName() )
        pName   = (PNAME ) GenMangledCallAsName( pCCB );
    else if ( pSStubPrefix )
        {
        pName   = new char[ strlen(pSStubPrefix) + strlen(GetType()->GetSymName()) + 1];
        strcpy( pName, pSStubPrefix );
        strcat( pName, GetType()->GetSymName() );
        }
    else
        pName   = (PNAME ) GetType()->GetSymName();

    pProc   = new expr_proc_call( pName );

    GetMembers( I );

    while( ITERATOR_GETNEXT( I, pParam ) )
        {
        if ( pParam->IsOmittedParam() )
            continue;

        if ( ( pExpr = pParam->GetFinalExpression() ) != 0 )
            {
            CG_NDR * pChild = (CG_NDR *)pParam->GetChild();

            //
            // We have to dereference arrays because of how they are defined
            // in the stub.
            //
            if ( pChild->IsArray() )
                {
                pExpr = new expr_u_deref( pExpr );
                }
            else if( (pChild->GetCGID() == ID_CG_GENERIC_HDL ) &&
                     (((CG_NDR *)pChild->GetChild())->IsArray() )
                   )
                {
                pExpr = new expr_u_deref( pExpr );
                }

            //
            // Context handle param is handled differently.
            //
            if ( (pChild->GetCGID() == ID_CG_CONTEXT_HDL) ||
                 ((pChild->GetCGID() == ID_CG_PTR) &&
                  (((CG_NDR *)pChild->GetChild())->GetCGID() ==
                     ID_CG_CONTEXT_HDL)) )
                {
                expr_proc_call *    pCall;

                pCall = new expr_proc_call( "NDRSContextValue" );
                pCall->SetParam(
                    new expr_param(
                    new expr_variable(
                            pParam->GetResource()->GetResourceName() )) );

                expr_node * pFinal;

                if ( pChild->GetCGID() == ID_CG_CONTEXT_HDL )
                    pFinal = new expr_u_deref(pCall);
                else
                    pFinal = pCall;

                //
                // Dereference a plain context handle.
                //
                pExpr = new expr_cast( pParam->GetType()->GetChild(),
                                        pFinal );
                }

            pProc->SetParam( new expr_param( pExpr ) );
            }
        }

    if ( ( pRT = GetReturnType() ) != 0 )
        {
        pReturnExpr = pRT->GetFinalExpression();
        }

    if ( HasNotifyFlag() )
        {
        // Assign TRUE to the notify flag variable.

        expr_node * pNotifyFlag;
        expr_node * pAssignExpr;

        ISTREAM *   pStream = pCCB->GetStream();

        pNotifyFlag = new expr_variable( NOTIFY_FLAG_VAR_NAME );
        pAssignExpr = new expr_assign( pNotifyFlag,
                                       new expr_variable( "TRUE" ) );
        pStream->NewLine();
        pAssignExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();
        }

    Out_CallManager( pCCB,
                     pProc,
                     pReturnExpr,
                     (GetCGID() == ID_CG_CALLBACK_PROC)
                   );

    return CG_OK;

}
CG_STATUS
CG_PROC::S_GenInitTopLevelStuff(
    CCB *   pCCB )
    {
    CG_ITERATOR Iter;
    CG_NDR  *   pParam;

    if( GetMembers( Iter ) )
        {
        while( ITERATOR_GETNEXT( Iter, pParam ) )
            {
            pParam->S_GenInitTopLevelStuff( pCCB );
            }
        }

    if ( GetReturnType() )
        GetReturnType()->S_GenInitTopLevelStuff( pCCB );

    return CG_OK;
    }

CG_STATUS
CG_PROC::S_GenProlog(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side stub prolog.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

    Print out the signature, locals, the stub descriptor if needed and the
    adjust indent in anticipation of code.
----------------------------------------------------------------------------*/
{

    ITERATOR    LocalsList;
    ITERATOR    ParamsList;
    ITERATOR    TransientList;

    // Collect all the params and locals into lists ready to print.

    pCCB->GetListOfLocalResources( LocalsList );
    pCCB->GetListOfParamResources( ParamsList );
    pCCB->GetListOfTransientResources( TransientList );

    //
    // Print out the procedure signature and the local variables.
    //
    Out_ServerProcedureProlog( pCCB,
                               GetType(),
                               LocalsList,
                               ParamsList,
                               TransientList
                             );

    //
    // Done for interpretation op.  No indent needed either.
    //
    if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
        return CG_OK;

    //
    // This is where we output additional variable declarations to handle
    // multidimensional conformant/varying arrays.
    //

    CG_ITERATOR Iterator;
    ISTREAM *   pStream;
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;

    pStream = pCCB->GetStream();

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( (pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsMultiConfOrVar()) ||
             (pNdr->IsPointer() && ((CG_POINTER *)pNdr)->IsMultiSize()) )
            Out_MultiDimVars( pCCB, pParam );
        }

    pStream->NewLine();

    // Removes warning if we don't use the _Status variable.
    pStream->Write( "((void)(" RPC_STATUS_VAR_NAME "));" );
    pStream->NewLine();

    if ( HasNotifyFlag() )
        {
        // Assign FALSE to the notify flag variable.

        expr_node * pNotifyFlag;
        expr_node * pAssignExpr;

        pNotifyFlag = new expr_variable( NOTIFY_FLAG_VAR_NAME );
        pAssignExpr = new expr_assign( pNotifyFlag,
                                       new expr_variable( "FALSE" ) );
        pStream->NewLine();
        pAssignExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();
        }

    //
    // Call the NdrServerInitialize routine.
    //

    expr_proc_call  *   pCall;

    pCall = new expr_proc_call( SSTUB_INIT_RTN_NAME );

    pCall->SetParam( new expr_param (
                     new expr_variable( PRPC_MESSAGE_VAR_NAME ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    pCall->SetParam( new expr_param (
                     new expr_u_address (
                     new expr_variable(
                          pCCB->GetInterfaceCG()->GetStubDescName() ) ) ) );

    pCall->PrintCall( pCCB->GetStream(), 0, 0 );
    pStream->NewLine();

    // if the rpc ss package is to be enabled, do so.

    if( MustInvokeRpcSSAllocate() )
        {
        Out_RpcSSEnableAllocate( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::GenUnMarshall(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the unmarshalling code for the server side stub.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well,
    error   Otherwise.

 Notes:


    The new server stubs will contain an ndr transformation phase which will
    convert, in-situ, any incoming buffer that needs ndr transformations like
    big-little endian conversions, char / float transformations etc.

    Therefore the first thing the server stub does is to tranform the data into
    the correct format and then the rest of the stub can proceed as if the
    data came in little endian format.

    Currently we will use the engine to tranform the data.
----------------------------------------------------------------------------*/
{
    CG_ITERATOR         Iterator;
    ITERATOR            ParamList;
    CG_RETURN       *   pRT;
    CGSIDE              Side;
    BOOL                fReturnNeedsUnMarshall  = FALSE;
    long                ParamTotal;

    GetMembers( Iterator );

    ParamTotal = ITERATOR_GETCOUNT( Iterator );

    if ( GetReturnType() )
        ParamTotal++;

    pCCB->SetCodeGenPhase( CGPHASE_UNMARSHALL );

    // Generate a call to tranform the data into the proper endianness.

    S_XFormToProperFormat( pCCB );

    // For all [in] params, generate the unmarshalling code.

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        GetOutParamList( ParamList );
    else
        GetInParamList( ParamList );

    if ( (Side == CGSIDE_CLIENT) && (pRT = GetReturnType()) != 0 )
        fReturnNeedsUnMarshall = TRUE;

    //
    // Output the call to check for and perform endian or other transformations
    // if needed.
    //
    if ( fReturnNeedsUnMarshall || ParamList.GetCount() )
        Out_NdrConvert( pCCB,
                        GetFormatStringParamStart(),
                        ParamTotal,
                        GetOptimizationFlags() );

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;
        CG_PARAM    *   pS;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            // The extra fault/comm status param doesn't go on wire.

            pS = (CG_PARAM *)ITERATOR_PEEKTHIS( ParamList );

            pParam->GenUnMarshall( pCCB );
            }
        }

    // For the client side, generate the unmarshall call if there is a return
    // value.

    if( fReturnNeedsUnMarshall )
        {
        pRT->GenUnMarshall( pCCB );
        }

    return CG_OK;
}


CG_STATUS
CG_PROC::GenFree(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generates freeing code.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         ParamList;
    CGSIDE              Side;
    CG_RETURN       *   pRT;
    BOOL                fReturnNeedsFree    = FALSE;

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        return CG_OK;

    // Else it's the server side

    GetMembers( ParamList );

    if ( ( pRT = GetReturnType() ) != 0 )
        fReturnNeedsFree = TRUE;

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            pParam->GenFree( pCCB );
            }
        }

    //
    // Size the return value on the server side if needed.
    //
    if( fReturnNeedsFree )
        {
        pRT->GenFree( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::GenNotify(
    CCB *   pCCB,
    BOOL    fHasFlag )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the notify call for the procedure.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

 Notes:

    We need to generate a call to foo_notify with all parameters, exactly
    the same as the original procedure. The return value is a void.
----------------------------------------------------------------------------*/
{
    ISTREAM *   pStream = pCCB->GetStream();

    // Create an expression for the call to the notify procedure. The name
    // of the notify procedure is the procname suffixed by _notify.

    CSzBuffer   ProcName;

    ProcName.Set( GetType()->GetSymName() );
    ProcName.Append( (fHasFlag ? NOTIFY_FLAG_SUFFIX
                               : NOTIFY_SUFFIX) );

    expr_proc_call   ProcExpr( ProcName.GetData(), 0 );
    expr_variable *  pVarNode;
    expr_param    *  pFlagParam;

    if ( fHasFlag )
        {
        pVarNode   = new expr_variable( NOTIFY_FLAG_VAR_NAME );
        pFlagParam = new expr_param( pVarNode );

        ProcExpr.SetParam( pFlagParam );
        }

    // The call expression has been made. Emit it.

    pStream->NewLine();
    ProcExpr.PrintCall( pStream, 0, 0 );
    pStream->NewLine();

    // Clean up.

    if ( fHasFlag )
        {
        delete pVarNode;
        delete pFlagParam;
        }

    return CG_OK;
}


CG_STATUS
CG_PROC::GenEpilog(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate the server side epilog for the procedure.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

 Notes:

    Decrement the indent back to the initial, and emit the closing brace.
----------------------------------------------------------------------------*/
{
    if( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT) && GetReturnType() )
        {
        expr_node * pExpr = new expr_variable( RETURN_VALUE_VAR_NAME );
        pCCB->GetStream()->NewLine();
        pCCB->GetStream()->Write( "return " );
        pExpr->Print( pCCB->GetStream() );
        pCCB->GetStream()->Write( ';' );
        }

    if ( (pCCB->GetCodeGenSide() == CGSIDE_SERVER) )
        {
        ISTREAM * pStream = pCCB->GetStream();

        pStream->Write( PRPC_MESSAGE_VAR_NAME "->BufferLength = " );
        pStream->NewLine();
        pStream->Spaces( STANDARD_STUB_TAB );
        pStream->Write( "(unsigned int)(" STUB_MESSAGE_VAR_NAME ".Buffer - ");
        pStream->Write( "(unsigned char *)" PRPC_MESSAGE_VAR_NAME "->Buffer);" );
        pStream->NewLine();
        }

    Out_IndentDec( pCCB );
    Out_ProcClosingBrace( pCCB );
    return CG_OK;
}


CG_STATUS
CG_PROC::GenSizing(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate sizing code.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            ParamList;
    CGSIDE              Side;
    CG_RETURN       *   pRT;
    BOOL                fReturnNeedsSizing  = FALSE;
    short               ParamCount = 0;

    pCCB->GetStream()->NewLine();


    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        ParamCount = GetInParamList( ParamList );
    else
        ParamCount = GetOutParamList( ParamList );

    if ( (Side == CGSIDE_SERVER) && (pRT = GetReturnType()) != 0 )
        fReturnNeedsSizing = TRUE;

    // On the server side if there are no out params and no returns, dont
    // generate code for sizing and get buffer at all !

    if( (Side == CGSIDE_SERVER) && (ParamCount == 0) && !fReturnNeedsSizing )
        {
        return CG_OK;
        }


    //
    // Analyze all the parameters and compute the constant buffer.
    // 

    long ConstantBufferSize = 0;

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            long ParamBufferSize = pParam->FixedBufferSize( pCCB );
            pParam->SetFixedBufferSize( ParamBufferSize );

            if (-1 != ParamBufferSize)
                ConstantBufferSize += ParamBufferSize;
            }
        }

    //
    // Size the return value on the server side if needed.
    //
    if( fReturnNeedsSizing )
        {
        long ReturnBufferSize = pRT->FixedBufferSize( pCCB );
        pRT->SetFixedBufferSize( ReturnBufferSize );
        
        if (-1 != ReturnBufferSize)
            ConstantBufferSize += ReturnBufferSize;
        }

    //
    // Init the length variable to 0.
    //

    Out_Assign( pCCB,
                new expr_variable ( STUB_MSG_LENGTH_VAR_NAME, 0 ),
                new expr_constant( ConstantBufferSize )
              );


    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            if (pParam->GetFixedBufferSize() == -1)
                pParam->GenSizing( pCCB );
            }
        }

    //
    // Size the return value on the server side if needed.
    //
    if( fReturnNeedsSizing )
        {
        if (pRT->GetFixedBufferSize() == -1)
            pRT->GenSizing( pCCB );
        }

    GenGetBuffer( pCCB );

    return CG_OK;
}


CG_STATUS
CG_PROC::GenGetBuffer(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the message buffer.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    if ( IsAutoHandle() && (pCCB->GetCodeGenSide() == CGSIDE_CLIENT) )
        Out_NdrNsGetBuffer( pCCB );
    else
        Out_NdrGetBuffer( pCCB );

    return CG_OK;
}


CG_STATUS
CG_PROC::GenMarshall(
    CCB             *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Server side procedure to marshall out params.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:


----------------------------------------------------------------------------*/
{
    ITERATOR            ParamList;
    CGSIDE              Side;
    CG_RETURN       *   pRT;
    BOOL                fReturnNeedsMarshall    = FALSE;

    pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

    // Generate a call to tranform the data into the proper endianness.

    S_XFormToProperFormat( pCCB );

    // For all [in] params, generate the unmarshalling code.

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        GetInParamList( ParamList );
    else
        GetOutParamList( ParamList );

    if ( (Side == CGSIDE_SERVER) && (pRT = GetReturnType()) != 0 )
        fReturnNeedsMarshall = TRUE;

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;
        CG_PARAM    *   pS;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            // IsExtraParam

            pS = (CG_PARAM *)ITERATOR_PEEKTHIS( ParamList );
            pParam->GenMarshall( pCCB );
            }
        }

    // For the server side, generate the marshall call if there is a return
    // value.

    if( fReturnNeedsMarshall )
        {
        pRT->GenMarshall( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_PROC::GenRefChecks(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate ref checks for a procedure.

 Arguments:

    pCCB    - The code gen block.

 Return Value:

    CG_OK

 Notes:

----------------------------------------------------------------------------*/
{
    CG_ITERATOR         ParamList;
    CGSIDE              Side;

    // On the client side, perform ref checks for every pointer parameter.
    // On the server side, dont perform any checks at all. If it is a top
    // level ref, the stub allocates the pointee on the stack or in memory.
    // if the allocation fails, the engine will always raise an exception.
    // For embedded pointers, the engine checks anyhow.
    //
    // If the parameter is a cs tag (e.g. [cs_stag]), and the proc has 
    // a tag setting routine, the param will be allocated as a local variable
    // so we don't need to check them.

    if( (Side = pCCB->GetCodeGenSide()) == CGSIDE_CLIENT )
        {
        GetMembers( ParamList );

        if( ITERATOR_GETCOUNT( ParamList ) )
            {
            CG_PARAM    *   pParam;
    
            ITERATOR_INIT( ParamList );
    
            while( ITERATOR_GETNEXT( ParamList, pParam ) )
                {
                if( ( pCCB->GetOptimOption() & OPTIMIZE_SIZE )
                    && ( NULL == GetCSTagRoutine() || !pParam->IsSomeCSTag() ) )
                    {
                    pParam->GenRefChecks( pCCB );
                    }
                }
            }
        }
    return CG_OK;
}

CG_STATUS
CG_PROC::S_GenInitInLocals(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate in local initialization for the procedure.

 Arguments:

    pCCB    - The code gen block.

 Return Value:

    CG_OK

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR            ParamList;

    GetInParamList( ParamList );

    if( ITERATOR_GETCOUNT( ParamList ) )
        {
        CG_PARAM    *   pParam;

        ITERATOR_INIT( ParamList );

        while( ITERATOR_GETNEXT( ParamList, pParam ) )
            {
            pParam->S_GenInitInLocals( pCCB );
            }
        }

    return CG_OK;
}

/***************************************************************************
 * parameter code generation class implementation.
 ***************************************************************************/
CG_STATUS
CG_PARAM::S_GenInitInLocals(
    CCB *   pCCB )
    {
    pCCB->SetMemoryAllocDone();
    pCCB->ResetRefAllocDone();
    pCCB->SetSourceExpression( GetResource() );
    pCCB->SetLastPlaceholderClass(this);
    ((CG_NDR *)GetChild())->S_GenInitInLocals( pCCB );
    return CG_OK;
    }

CG_STATUS
CG_PARAM::S_GenInitOutLocals(
    CCB     *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Generate local initialization for the parameters.

 Arguments:

    pCCB    - A pointer to the code generation controller block.

 Return Value:

    CG_OK   if all is well
    error   Otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    
    if ( IsParamPartialIgnore() )
        {

        // Evaluate toplevel size_is.  Ignore first_is and length_is since
        // the entire data needs to be allocated and cleared.

        GenNdrTopLevelAttributeSupport( pCCB, TRUE );

        char *pParamName = GetResource()->GetResourceName();
        long FormatOffset = dynamic_cast<CG_NDR*>(GetChild())->GetFormatStringOffset();

        Out_PartialIgnoreServerInitialize( pCCB,
                                           pParamName,
                                           FormatOffset );
        return CG_OK;
        }

    else if( IsParamOut() && !IsParamIn() )
        {
        pCCB->SetMemoryAllocDone();
        pCCB->ResetRefAllocDone();
        pCCB->SetSourceExpression( GetResource() );
        pCCB->SetLastPlaceholderClass(this);
        ((CG_NDR *)GetChild())->S_GenInitOutLocals( pCCB );
        SetFinalExpression( GetResource() );
        }
    return CG_OK;
}

CG_STATUS
CG_PARAM::S_GenInitTopLevelStuff(
    CCB     *   pCCB )
    {
    ISTREAM *   pStream;
    CG_NDR *    pChild;
    ID_CG       ChildID;

    pStream = pCCB->GetStream();

    pChild = (CG_NDR *)GetChild();
    ChildID = pChild->GetCGID();

    if ( ChildID == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ChildID = pChild->GetCGID();
        }

    //
    // Initialize all [in] pointer and array params, and handle by-value
    // structures and unions.
    //
    if ( pChild->IsArray() || pChild->IsSimpleType() )
        {
        expr_node * pParam;
        expr_node *     pExpr;

        pParam = new expr_variable( GetResource()->GetResourceName() );
        pExpr = new expr_assign( pParam,
                                  new expr_constant( (long) 0 ) );

        pStream->NewLine();
        pExpr->Print( pStream );
        pStream->Write( ';' );
        }

    if ( pChild->IsPointer() )
        {
        // const type* ptr or type* const ptr
        // get initialized as (type*) ptr = 0;
        expr_node*  pParam;
        expr_node*  pExpr;
        expr_node*  pLHS;

        pParam = new expr_variable( GetResource()->GetResourceName() );

        node_skl*   pType = GetChild()->GetType();
        if ( pType != 0 && pType->NodeKind() != NODE_INTERFACE_REFERENCE )
            {
            expr_cast*  pCast = new expr_cast( pType, pParam );
            pCast->SetEmitModifiers( false );
            pLHS = pCast;
            }
        else
            {
            pLHS = pParam;
            }

        pExpr = new expr_assign( pLHS, new expr_constant( (long) 0 ) );
        pStream->NewLine();
        pExpr->Print( pStream );
        pStream->Write( ';' );
        }

    //
    // If this is a by-value structure or union then we allocate a
    // local which is a pointer to the same type.
    //
    if ( pChild->IsStruct() || pChild->IsUnion()  ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        expr_node * pParam;
        expr_node * pPointer;
        expr_node *     pExpr;
        char *          pPointerName;
        char *          pPlainName = GetResource()->GetResourceName();

        pPointerName = new char[strlen( pPlainName ) + 10];

        strcpy( pPointerName, LOCAL_NAME_POINTER_MANGLE);
        strcat( pPointerName, pPlainName);

        pParam = new expr_u_address (
                 new expr_variable( pPlainName ) );

        pPointer = new expr_variable( pPointerName );

        pExpr = new expr_assign( pPointer, pParam );

        pStream->NewLine();
        pExpr->Print( pStream );
        pStream->Write( ';' );

        //
        // Memset [in], [in,out] by-value structs & unions in case we catch
        // an exception before we finish unmarshalling them.  If they have
        // embedded pointers they must be zeroed before freeing.
        //
        if ( IsParamIn() &&
             (pChild->IsStruct() || pChild->IsUnion()) )
            {
            Out_MemsetToZero( pCCB,
                              pPointer,
                              new expr_sizeof( pChild->GetType() ) );
            }

        // If there is a transmit_as etc, init the ptr to 0.

        switch( ChildID )
            {
            case ID_CG_TRANSMIT_AS:
                {
                expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
                pProc->SetParam( new expr_param( pPointer ) );
                pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
                pProc->SetParam(
                     new expr_param(
                       new expr_sizeof(
                        ((CG_TRANSMIT_AS *)pChild)->GetPresentedType())));
                pCCB->GetStream()->NewLine();
                pProc->PrintCall( pCCB->GetStream(), 0, 0 );
                break;
                }
            case ID_CG_REPRESENT_AS:
                {
                node_skl    *   pNode = new node_def(
                            ((CG_REPRESENT_AS *)pChild)->GetRepAsTypeName() );
                expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME  );
                pProc->SetParam( new expr_param( pPointer ) );
                pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
                pProc->SetParam( new expr_param( new expr_sizeof( pNode ) ) );
                pCCB->GetStream()->NewLine();
                pProc->PrintCall( pCCB->GetStream(), 0, 0 );
                break;
                }
            case ID_CG_USER_MARSHAL:
                {
                node_skl    *   pNode = new node_def(
                            ((CG_REPRESENT_AS *)pChild)->GetRepAsTypeName() );
                expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME  );
                pProc->SetParam( new expr_param( pPointer ) );
                pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
                pProc->SetParam( new expr_param( new expr_sizeof( pNode ) ) );
                pCCB->GetStream()->NewLine();
                pProc->PrintCall( pCCB->GetStream(), 0, 0 );
                break;
                }
            default:
                break;
            }
        }

    if ( ChildID == ID_CG_PRIMITIVE_HDL )
        {
        pStream->NewLine();
        pStream->Write( GetType()->GetSymName() );
        pStream->Write( " = " PRPC_MESSAGE_VAR_NAME "->Handle;" );
        }

    return CG_OK;
    }

CG_STATUS
CG_PARAM::GenMarshall(
    CCB     *   pCCB )
{
    CG_STATUS   Status;
    CG_NDR *    pOldPlaceholder;

    // The fault/comm additional parameter doesn't go on wire.

    if ( IsExtraStatusParam() )
        return CG_OK;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrMarshallCall( pCCB );
    Status = CG_OK;

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
}

CG_STATUS
CG_PARAM::GenUnMarshall(
    CCB     *   pCCB )
{
    CG_STATUS       Status;
    CG_NDR      *   pOldPlaceholder;
    CG_NDR      *   pC  = (CG_NDR *)GetChild();
    BOOL            fPtrToContext = FALSE;
    expr_node   *   pFinalExpr  = GetResource();

    // The fault/comm additional parameter doesn't go on wire...
    // However, we need to generate an assignment in its place.

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    if ( pC->GetCGID() == ID_CG_CONTEXT_HDL ||
        ( (fPtrToContext = ( pC->GetChild()) != 0 && pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL ) ) == TRUE )
        {
        expr_node      *    pExpr;
        expr_proc_call *    pProc = new expr_proc_call( "NDRSContextValue" );
        CG_CONTEXT_HANDLE * pCtxtHandle;

        pProc->SetParam( new expr_param( GetResource() ) );

        if( fPtrToContext )
            {
            pExpr   = new expr_u_deref( pProc );
            pCtxtHandle = (CG_CONTEXT_HANDLE *)pC->GetChild();
            }
        else
            {
            pExpr   = pProc;
            pCtxtHandle = (CG_CONTEXT_HANDLE *)pC;
            }

        pExpr   = new expr_cast( GetType()->GetChild(), pExpr );
        pFinalExpr = pExpr;

        // Register the context handle for a rundown.

        if( pCtxtHandle->GetHandleType()->NodeKind() == NODE_DEF )
            pCCB->RegisterContextHandleType( pCtxtHandle->GetHandleType() );
        }


    GenNdrUnmarshallCall( pCCB );
    SetFinalExpression( pFinalExpr );
    Status = CG_OK;
	
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    return Status;
}


CG_STATUS
CG_PARAM::GenSizing(
    CCB *       pCCB )
{
    CG_STATUS   Status;
    CG_NDR *    pOldPlaceholder;

    // The fault/comm additional parameter doesn't go on wire.

    if ( IsExtraStatusParam() || IsAsyncHandleParam() )
        return CG_OK;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrBufferSizeCall( pCCB );
		
    Status = CG_OK;
		
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
}

CG_STATUS
CG_PARAM::GenFree(
    CCB     *   pCCB )
{
    CG_NDR *    pOldPlaceholder;

    if ( IsExtraStatusParam() )
        return CG_OK;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrFreeCall( pCCB );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    return CG_OK;
}
CG_STATUS
CG_PARAM::GenRefChecks(
    CCB     *   pCCB )
{
    pCCB->ResetEmbeddingLevel();
    pCCB->ResetIndirectionLevel();
    pCCB->ResetReturnContext();
    pCCB->ResetRefAllocDone();
    pCCB->SetPrefix(0);
    pCCB->SetSourceExpression( GetResource() );
    ((CG_NDR *)GetChild())->GenRefChecks( pCCB );

    return CG_OK;
}

/*****************************************************************************
    CG_RETURN procedures.
 *****************************************************************************/
CG_STATUS
CG_RETURN::GenMarshall(
    CCB     *   pCCB )
{
    CG_NDR *    pOldPlaceholder;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrMarshallCall( pCCB );
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;

}

CG_STATUS
CG_RETURN::GenSizing(
    CCB *   pCCB )
    {
    CG_NDR *    pOldPlaceholder;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    pCCB->SetSourceExpression( GetResource() );

  	GenNdrBufferSizeCall( pCCB );
		
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
    }

CG_STATUS
CG_RETURN::GenUnMarshall(
    CCB     *   pCCB )
{
    CG_NDR *    pOldPlaceholder;

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    ISTREAM * pStream;
    
    pStream = pCCB->GetStream();

    //
    // Initialize a pointer return type to 0.
    //
    if ( GetChild()->IsPointer() )
        {
  	pStream->NewLine();
  	pStream->Write( RETURN_VALUE_VAR_NAME );
  	pStream->Write( " = 0;" );
  	}

    //
    // Initialize a struct or union return value.
    //
    if ( GetChild()->IsStruct() || GetChild()->IsUnion() ||
         ((CG_NDR *)GetChild())->IsXmitRepOrUserMarshal() )
  	{
  	pStream->NewLine();
  	pStream->Write( LOCAL_NAME_POINTER_MANGLE RETURN_VALUE_VAR_NAME );
  	pStream->Write( " = " );
  	pStream->Write( "(void *) &" RETURN_VALUE_VAR_NAME );
  	pStream->Write( ';' );
  	}

    GenNdrUnmarshallCall( pCCB );
    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;

}

CG_STATUS
CG_RETURN::S_GenInitOutLocals(
    CCB     *   pCCB )
{
    CG_NDR * pNdr;

    pNdr = (CG_NDR *) GetChild();

    //
    // The only return type we ever have to initialize is a context handle.
    // A pointer to a context handle as a return type is forbidden.
    //
    if ( pNdr->GetCGID() == ID_CG_CONTEXT_HDL )
        {
        pCCB->SetLastPlaceholderClass(this);
        pNdr->S_GenInitOutLocals( pCCB );
        }

    return CG_OK;
}

CG_STATUS
CG_RETURN::S_GenInitTopLevelStuff(
    CCB     *   pCCB )
{
    CG_NDR *    pChild;
    expr_node * pExpr;

    pChild = (CG_NDR *) GetChild();

    pExpr = new expr_u_address (
            new expr_variable( RETURN_VALUE_VAR_NAME ) );

    if ( pChild->IsStruct() || pChild->IsUnion() )
        {
        Out_MemsetToZero( pCCB,
                          pExpr,
                          new expr_sizeof( pChild->GetType() ) );
        }

    return CG_OK;
}

CG_STATUS
CG_RETURN::GenFree(
    CCB *   pCCB )
    {
    CG_NDR *    pOldPlaceholder;
    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GenNdrFreeCall( pCCB );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );
    return CG_OK;
    }

expr_node *
CG_RETURN::GetFinalExpression()
    {
    expr_node * pReturnExpr;
    BOOL         fPtrToContext  = FALSE;
    CG_NDR  *    pC = (CG_NDR *)GetChild();

    if( pC->GetCGID() == ID_CG_CONTEXT_HDL ||
        ( (fPtrToContext = ( pC->GetChild()) != 0 &&
                 pC->GetChild()->GetCGID() == ID_CG_CONTEXT_HDL ) ) == TRUE )
        {
        expr_node       *   pExpr;
        expr_proc_call * pProc      = new expr_proc_call( "NDRSContextValue" );

        pProc->SetParam( new expr_param( GetResource() ) );

        // cast the proc call to this type.

        pExpr   = MakeDerefExpressionOfCastPtrToType( GetType(), pProc );

        pReturnExpr = pExpr;
        }
    else
        pReturnExpr = GetResource();

    return pReturnExpr;
    }

CG_STATUS
CG_CALLBACK_PROC::GenClientStub( CCB * pCCB )
    {
    CGSIDE  Side = pCCB->GetCodeGenSide();

    pCCB->GetInterfaceCG()->SetDispatchTBLPtrForCallback();
    pCCB->SetInCallback();
    CG_PROC::GenServerStub( pCCB );
    pCCB->ClearInCallback();
    pCCB->GetInterfaceCG()->RestoreDispatchTBLPtr();

    pCCB->SetCodeGenSide( Side );
    return CG_OK;
    }

CG_STATUS
CG_CALLBACK_PROC::GenServerStub( CCB * pCCB )
    {
    CGSIDE  Side = pCCB->GetCodeGenSide();

    pCCB->GetInterfaceCG()->SetDispatchTBLPtrForCallback();
    pCCB->SetInCallback();
    CG_PROC::GenClientStub( pCCB );
    pCCB->ClearInCallback();
    pCCB->GetInterfaceCG()->RestoreDispatchTBLPtr();
    pCCB->SetCodeGenSide( Side );
    return CG_OK;
    }

void
CG_PROC::GetCorrectAllocFreeRoutines(
    CCB *   pCCB,
    BOOL    fServer,
    char ** ppAllocName,
    char ** ppFreeName )
/*++
    Finds out correct Alloc and Free routine names, depending on the mode
    (osf vs. msft) and need to enable memory management.

    In object mode:
        use NdrOleAllocate, NdrOleFree

    In ms_ext mode and c-ext:
        unless forced to enable allocate, use MIDL_user_*

    In osf mode:
        client always uses NdrRpcSsClient*
        server use a default allocator or RpcSsAllocate.

++*/
{
    *ppAllocName = (char *) DEFAULT_ALLOC_RTN_NAME;      // MIDL_user_allocate
    *ppFreeName  = (char *) DEFAULT_FREE_RTN_NAME;       // MIDL_user_free

    if ( IsObject() )
        {
        *ppAllocName = (char *) OLE_ALLOC_RTN_NAME;      // NdrOleAllocate
        *ppFreeName  = (char *) OLE_FREE_RTN_NAME;       // NdrOleFree
        }
    else if ( MustInvokeRpcSSAllocate() )
        {
        // This means: msft mode - only when forced to enable
        //             osf  mode - when there is a need or forced to.

        if ( fServer )
            {
            *ppAllocName = (char *) RPC_SS_SERVER_ALLOCATE_RTN_NAME;
            *ppFreeName  = (char *) RPC_SS_SERVER_FREE_RTN_NAME;
            }
        else
            {
            *ppAllocName = (char *) RPC_SM_CLIENT_ALLOCATE_RTN_NAME;
            *ppFreeName  = (char *) RPC_SM_CLIENT_FREE_RTN_NAME;
            }
        }
    else
    if ( pCCB->GetMode() == 0 )
        {
        // osf, without having to enable memory manager

        if ( fServer )
            {
            *ppAllocName = (char *) DEFAULT_ALLOC_OSF_RTN_NAME;
            *ppFreeName  = (char *) DEFAULT_FREE_OSF_RTN_NAME;
            }
        else
            {
            *ppAllocName = (char *) RPC_SM_CLIENT_ALLOCATE_RTN_NAME;
            *ppFreeName  = (char *) RPC_SM_CLIENT_FREE_RTN_NAME;
            }
        }
}

void
GenCorrInit (
            CCB*    pCCB
            )
    {
    ISTREAM*    pStream         = pCCB->GetStream();
    ITERATOR    ParamList;

    // _StubMsg
    expr_node*  pExpr = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );
    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );
    ITERATOR_INSERT( ParamList, pExpr );

    // _Cache
    pExpr  = pCCB->GetLocalResource( NDR_CORR_CACHE_VAR_NAME );
    ITERATOR_INSERT( ParamList, pExpr );
    
    // _CacheSize
    unsigned long ulSize = NDR_CORR_CACHE_SIZE * sizeof( unsigned long );
    pExpr = new expr_constant( ulSize );
    ITERATOR_INSERT( ParamList, pExpr );

    // _Flags
    pExpr = new expr_constant( unsigned long( 0 ) );
    ITERATOR_INSERT( ParamList, pExpr );

    expr_proc_call* pProcCall = MakeProcCallOutOfParamExprList  (
                                                                CSTUB_CORR_INIT_RTN_NAME,
                                                                0,
                                                                ParamList
                                                                );
    pStream->NewLine();
    pProcCall->PrintCall( pStream, 0, 0 );
    pStream->NewLine();
    }

void
GenCorrPassFree (
                CCB*    pCCB,
                char*   szRtn
                )
    {
    ISTREAM*    pStream     = pCCB->GetStream();
    expr_node*  pExpr = pCCB->GetStandardResource( ST_RES_STUB_MESSAGE_VARIABLE );

    pExpr   = MakeAddressExpressionNoMatterWhat( pExpr );
    pExpr   = MakeExpressionOfCastToTypeName( PSTUB_MESSAGE_TYPE_NAME, pExpr );

    ITERATOR    ParamList;
    ITERATOR_INSERT( ParamList, pExpr );

    expr_proc_call* pProcCall = MakeProcCallOutOfParamExprList  (
                                                                szRtn,
                                                                0,
                                                                ParamList
                                                                );
    pStream->NewLine();
    pProcCall->PrintCall( pStream, 0, 0 );
    pStream->NewLine();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ptrgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	ptrgen.cxx

 Abstract:

	Implementations of the pointer cg class methods.

 Notes:


 History:

 	Oct-10-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_POINTER::S_GenInitOutLocals(
	CCB		*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate code for initialization of server side local variables.

 Arguments:

	pCCB	- A Ptr to the code gen controller block.

 Return Value:

 Notes:

	The source expression field of the ccb has the final presented expression.
----------------------------------------------------------------------------*/
{
	expr_node	*	pExpr;

	if( pCCB->IsRefAllocDone() )
		{
		pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
		Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
		pExpr = pCCB->SetSourceExpression( GetResource() );
		Out_Assign( pCCB, GetResource(), new expr_constant( 0L ) );
		}
	else
		pExpr = pCCB->GetSourceExpression();

	if( IsRef() && !IsQualifiedPointer() )
		{
		pCCB->ResetMemoryAllocDone();
		pCCB->SetRefAllocDone();
		((CG_NDR *)GetChild())->S_GenInitOutLocals( pCCB );
		}

	// If it is a byte count pointer, allocate the bytes specified as the
	// byte count param.

	// else if it is an out sized etc pointer, then must allocate.

	if( GetCGID() == ID_CG_BC_PTR )
		{
		PNAME	pName = ((CG_BYTE_COUNT_POINTER *)this)->GetByteCountParam()->GetSymName();

		expr_node * pByteCountExpr = new expr_variable( pName );

		Out_Alloc(pCCB,
				  pExpr,
				  0,
				  pByteCountExpr );

		}
	else if( IsQualifiedPointer() && !(GetCGID() == ID_CG_STRING_PTR) && IsRef() )
		{
		expr_node * pElementExpr;
		expr_node * pFinalExpr;
		expr_node * pCheckExpr;
		BOOL        fIsSigned;

		// Fool the presented expression to beleive it is marshalling, so that
		// it generates the correct expression.

		CGPHASE	Ph = pCCB->GetCodeGenPhase();
		pCCB->SetCodeGenPhase( CGPHASE_MARSHALL );

		// The proper size of the allocation is size times the element size.

		pElementExpr = new expr_constant(
						 (long) (((CG_NDR *)GetChild())->GetMemorySize()) );

		pFinalExpr = FinalSizeExpression( pCCB );

		fIsSigned = !((node_base_type *)pFinalExpr->GetType()->GetBasicType())->IsUnsigned();

		pFinalExpr = new expr_op_binary( OP_STAR,
										  pFinalExpr,
										  pElementExpr );
										  
		// Allocate the proper size.
		// If the size expression is signed and the value is less than 0, we
		// need to raise an exception.

		if( pCCB->MustCheckBounds() && fIsSigned )
		    {
		    pCheckExpr = new expr_op_binary( OP_LESS,
		                                     pFinalExpr,
		                                     new expr_constant(0L));
		    Out_If( pCCB, pCheckExpr);
		    Out_RaiseException( pCCB, "RPC_X_INVALID_BOUND" );
		    Out_Endif( pCCB );
		    }

		Out_Alloc(pCCB,
				  pExpr,
				  0,
				  pFinalExpr );

		pCCB->SetCodeGenPhase( Ph );
		}
	return CG_OK;
}

CG_STATUS
CG_STRING_POINTER::GenConfVarianceEtcUnMarshall( CCB* )
	{
	return CG_OK;
	}

/*****************************************************************************
 	utility functions
 *****************************************************************************/
expr_node *
CG_POINTER::GenBindOrUnBindExpression(
	CCB	*	pCCB,
	BOOL	 )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the final binding expression.

 Arguments:

 	pCCB	- Ptr to Code gen controller block.
 	fBind	- Indicates a bind or unbind code gen.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
	MIDL_ASSERT( pCCB->GetSourceExpression() );
	return new expr_u_deref( pCCB->GetSourceExpression() );
}

CG_STATUS
CG_POINTER::GenRefChecks(
	CCB		*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
 	
 	Generate ref checks for a pointer.

 Arguments:

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pSrc = pCCB->GetSourceExpression();

	if( IsRef() )
		{
		if( pCCB->IsRefAllocDone() )
			pSrc = pCCB->SetSourceExpression(
			 	MakeDereferentExpressionIfNecessary(
					 pCCB->GetSourceExpression()));

		// using the source expression, check for null ref pointers.

		Out_If( pCCB, new expr_u_not( pSrc ) );
		Out_RaiseException( pCCB,  "RPC_X_NULL_REF_POINTER" );
		Out_Endif( pCCB );

		pCCB->SetRefAllocDone();
		pCCB->ResetMemoryAllocDone();
		((CG_NDR *)GetChild())->GenRefChecks( pCCB );
		}

	return CG_OK;
}
CG_STATUS
CG_POINTER::S_GenInitInLocals(
	CCB		*	pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
 	
 	Perform in local init code generation. This method does nothing for 
 	pointers. Ref pointers are supposed to pass this message to their
 	children after setting the appropriate source expressions.

 Arguments:

	pCCB	- The code gen block.

 Return Value:

	CG_OK
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pSrc = pCCB->GetSourceExpression();

	if( IsRef() )
		{
		if( pCCB->IsRefAllocDone() )
			pSrc = pCCB->SetSourceExpression(
			 	MakeDereferentExpressionIfNecessary(
					 pCCB->GetSourceExpression()));

		((CG_NDR *)GetChild())->S_GenInitInLocals( pCCB );
		}

	return CG_OK;
}

expr_node *
CG_POINTER::FinalSizeExpression(
	CCB		*	pCCB )
	{
	return PresentedSizeExpression( pCCB );
	}
expr_node *
CG_POINTER::FinalFirstExpression(
	CCB		*	pCCB )
	{
	return PresentedFirstExpression( pCCB );
	}
expr_node *
CG_POINTER::FinalLengthExpression(
	CCB		*	pCCB )
	{
	return PresentedLengthExpression( pCCB );
	}

expr_node *
CG_STRING_POINTER::PresentedSizeExpression(
	 CCB * pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return PresentedLengthExpression( pCCB );
		}
	}
expr_node *
CG_STRING_POINTER::PresentedLengthExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL ) 
		{
		return GetLengthResource();
		}
	else if((pCCB->GetCodeGenPhase() == CGPHASE_MARSHALL ) && !IsUsedInArray())
		{
		return GetLengthResource();
		}
	else
		{
		unsigned short Size	= (unsigned short )((CG_NDR *)GetChild())->GetMemorySize();
		expr_proc_call	*	pProc;
		PNAME				pName;
		expr_node		*	pExpr;

		if( Size == 1 )
			{
			pName	= "strlen";
			}
		else if( Size == 2)
			{
			pName	= "MIDL_wchar_strlen";
			}
		else
			pName = "MIDL_NChar_strlen";
	
		pProc	= new expr_proc_call( pName );
		pProc->SetParam( new expr_param( pCCB->GetSourceExpression() ));
		pExpr	= new expr_b_arithmetic( OP_PLUS,
									  	pProc,
									  	new expr_constant( 1L ));

		return pExpr;
		}
	}


expr_node *
CG_SIZE_STRING_POINTER::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return GetSizeIsExpr();
		}
	}

expr_node *
CG_SIZE_POINTER::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return GetSizeIsExpr();
		}
	}
expr_node *
CG_LENGTH_POINTER::PresentedLengthExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		return GetLengthIsExpr();
		}
	}
expr_node *
CG_LENGTH_POINTER::PresentedFirstExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		return GetFirstIsExpr();
		}
	}
expr_node *
CG_SIZE_LENGTH_POINTER::PresentedSizeExpression(
	CCB	*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetSizeResource();
		}
	else
		{
		return GetSizeIsExpr();
		}
	}
expr_node *
CG_SIZE_LENGTH_POINTER::PresentedLengthExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetLengthResource();
		}
	else
		{
		return GetLengthIsExpr();
		}
	}
expr_node *
CG_SIZE_LENGTH_POINTER::PresentedFirstExpression(
	CCB		*	pCCB )
	{
	if( pCCB->GetCodeGenPhase() == CGPHASE_UNMARSHALL )
		{
		return GetFirstResource();
		}
	else
		{
		return GetFirstIsExpr();
		}
	}

CG_STATUS
CG_IIDIS_INTERFACE_POINTER::S_GenInitOutLocals(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the init call for the locals.

 Arguments:

 	pCCB	- The ptr to code gen block.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node	*	pExpr;

	if( !pCCB->IsRefAllocDone() )
		{
		pExpr	= new expr_sizeof( GetType() );
		Out_Alloc( pCCB, pCCB->GetSourceExpression(), 0, pExpr );
		}
	else
		{
		pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
		Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
		pExpr = pCCB->SetSourceExpression( GetResource() );
		Out_Assign( pCCB, GetResource(), new expr_constant( 0L ) );
		}

	return CG_OK;
}


CG_STATUS
CG_INTERFACE_POINTER::S_GenInitOutLocals(
    CCB *   pCCB )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Generate the init call for the locals.

 Arguments:

 	pCCB	- The ptr to code gen block.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node	*	pExpr;

	if( !pCCB->IsRefAllocDone() )
		{
		pExpr	= new expr_sizeof( GetType() );
		Out_Alloc( pCCB, pCCB->GetSourceExpression(), 0, pExpr );
		}
	else
		{
		pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
		Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
		pExpr = pCCB->SetSourceExpression( GetResource() );
		Out_Assign( pCCB, GetResource(), new expr_constant( 0L ) );
		}

	return CG_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\procndr.cxx ===
/*---------------------------------------------------------------------------
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    procndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    the code generation procedure class.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

#include "szbuffer.h"
#include "walkctxt.hxx"
#include <malloc.h>

extern CMD_ARG * pCommand;

void
CG_PROC::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Interpreted procedure format string descriptions.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    CG_ITERATOR             Iterator;
    CG_PARAM *              pParam;
    FORMAT_STRING *         pProcFormatString;
    CG_NDR *                pOldCGNodeContext;
    short                   ParamNum;
    long                    ServerBufferSize;
    long                    ClientBufferSize;
    long                    BufSize;
    BOOL                    fServerMustSize;
    BOOL                    fClientMustSize;
    INTERPRETER_OPT_FLAGS   InterpreterOptFlags;

    MIDL_ASSERT( !pCommand->IsNDR64Run() );    

    // make sure that call-as proc targets get processed when necessary.
    CG_PROC * pCallAs = GetCallAsCG();
    if (pCallAs)
        pCallAs->GenNdrFormat(pCCB);
        
    SetupFormatStrings(pCCB);

    if ( ! (GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2) )
        {
        // Generate -Os or -Oi format string.

        GenNdrFormatV1( pCCB );
        UnsetupFormatStrings(pCCB);
        return;
        }

    if ( GetFormatStringOffset() != -1 )
    {
        UnsetupFormatStrings(pCCB);
        return;
    }

    pCCB->SetInObjectInterface( IsObject() );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    //
    // If this procedure uses an explicit handle then set the
    // NdrBindDescriptionOffset to 0 so that it will not try to output it's
    // description when given the GenNdrParamOffLine method in the loop below.
    // It's description must be part of the procedure description.
    //
    if ( GetHandleUsage() == HU_EXPLICIT )
        {
        CG_HANDLE * pHandle = GetHandleClassPtr();

        pHandle->SetNdrBindDescriptionOffset( 0 );

        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            // The context handle directs the call.
            ((CG_CONTEXT_HANDLE *)pHandle)->SetCannotBeNull();
            }
        }

    GetMembers( Iterator );

    ParamNum = 0;

    ServerBufferSize = 0;
    ClientBufferSize = 0;

    fServerMustSize = FALSE;
    fClientMustSize = FALSE;

    pCCB->SetInterpreterOutSize( 0 );

    //
    // Generate the offline portion of the format string for all of the params.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        pChild = (CG_NDR *) pParam->GetChild();

        // Ignore the following type of arguments that don't go on wire:
        //  - async handles
        //  - primitive handles
        //  
        if ( pChild->GetCGID() == ID_CG_PRIMITIVE_HDL  || ( (CG_PARAM*) pParam)->IsAsyncHandleParam() )
            continue;

        pParam->SetParamNumber( ParamNum++ );

        pCCB->SetCurrentParam( (CG_PARAM *) pParam );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamOffline( pCCB );
                               
        // A procedure's buffer size does not depend on pipe arguments
        if (pChild->IsPipeOrPipeReference())
            {
                if (pChild->GetChild()->HasAFixedBufferSize())
                    pParam->SetInterpreterMustSize(FALSE);
                else
                    // There must be a union in there somewhere 
                    pParam->SetInterpreterMustSize(TRUE);
            }
        else
            {            

            BufSize = pChild->FixedBufferSize( pCCB );

            if ( BufSize != -1 )
                {
                //
                // If either the client's or server's fixed buffer size gets too
                // big then we force the parameter to be sized.
                //
                if ( (pParam->IsParamIn() &&
                    ((ClientBufferSize + BufSize) >= 65356)) ||
                    (pParam->IsParamOut() &&
                    ((ServerBufferSize + BufSize) >= 65356)) )
                    {
                    fClientMustSize = TRUE;
                    fServerMustSize = TRUE;
                    }
                else
                    {
                    pParam->SetInterpreterMustSize( FALSE );
    
                    if ( pParam->IsParamIn() )
                        ClientBufferSize += BufSize;
                    if ( pParam->IsParamOut() )
                        ServerBufferSize += BufSize;
                    }
                }
            else
                {
                if ( pParam->IsParamIn() )
                    fClientMustSize = TRUE;
                if ( pParam->IsParamOut() )
                    fServerMustSize = TRUE;
                }
            }

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // Generate the format string for the return type if needed.
    //
    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        GetReturnType()->SetParamNumber( ParamNum++ );
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        pCCB->SetCurrentParam( GetReturnType() );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamOffline( pCCB );

        BufSize = pChild->FixedBufferSize( pCCB );

        if ( BufSize != -1 )
            {
            if ( (ServerBufferSize + BufSize) >= 65536 )
                {
                fServerMustSize = TRUE;
                }
            else
                {
                ServerBufferSize += BufSize;
                GetReturnType()->SetInterpreterMustSize( FALSE );
                }
            }
        else
            fServerMustSize = TRUE;

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pCCB->SetCurrentParam( 0 );
    
    pProcFormatString = pCCB->GetProcFormatString();

    SetFormatStringOffset( pProcFormatString->GetCurrentOffset() );

    //
    // Generate procedure description stuff for the interpreter if needed.
    //
    if ( (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER)
         ||  HasAPicklingAttribute() )
        {
        GenNdrFormatProcInfo( pCCB );

        // Client side constant buffer size.
        pProcFormatString->PushShort( ClientBufferSize );

        // Server side constant buffer size.
        pProcFormatString->PushShort( ServerBufferSize );
        }

    InterpreterOptFlags.ServerMustSize = (unsigned char) fServerMustSize;
    InterpreterOptFlags.ClientMustSize = (unsigned char) fClientMustSize;
    InterpreterOptFlags.HasReturn      = (unsigned char) (GetReturnType() != 0 ? 1 : 0);
    InterpreterOptFlags.HasPipes       = (unsigned char) HasPipes();
    InterpreterOptFlags.Unused         = (unsigned char) 0;
    InterpreterOptFlags.HasAsyncUuid   = (unsigned char) HasAsyncUUID();
    InterpreterOptFlags.HasAsyncHandle = (unsigned char) HasAsyncHandle();
    InterpreterOptFlags.HasExtensions  = (unsigned char) 
                                              (    HasDeny() 
                                                || HasNotify() 
                                                || HasNotifyFlag() 
                                                || HasComplexReturnType() );

    short floatmask = 0;

    if ( pCommand->Is64BitEnv() )
        {
        floatmask = GetFloatArgMask( pCCB );

        InterpreterOptFlags.HasExtensions = (unsigned char)
              InterpreterOptFlags.HasExtensions || (0 != floatmask);
        }

    // New procedure flags.
    pProcFormatString->PushOi2ProcFlagsByte( *((char *)&InterpreterOptFlags) );

    // Number of parameters.
    pProcFormatString->PushByte( ParamNum );

    if ( InterpreterOptFlags.HasExtensions )
        {
        // Extensions layout:
        //   size<1>
        //   flags<1>
        //   client correlation cache size hint<2>
        //   server correlation cache size hint<2>
        //   notify routine index<2>
        //
        INTERPRETER_OPT_FLAGS2   InterpreterOptFlags2;

        InterpreterOptFlags2.Unused             = 0;
        InterpreterOptFlags2.HasNewCorrDesc     = ( unsigned char )HasDeny();
        if ( InterpreterOptFlags2.HasNewCorrDesc )
            {
            InterpreterOptFlags2.ClientCorrCheck    = ( unsigned char )HasClientCorr();
            InterpreterOptFlags2.ServerCorrCheck    = ( unsigned char )HasServerCorr();
            }
        else
            {
            InterpreterOptFlags2.ClientCorrCheck    = 0;
            InterpreterOptFlags2.ServerCorrCheck    = 0;
            }
        InterpreterOptFlags2.HasNotify          = ( unsigned char )HasNotify();
        InterpreterOptFlags2.HasNotify2         = ( unsigned char )HasNotifyFlag();

        InterpreterOptFlags2.HasComplexReturn   = ( unsigned char )HasComplexReturnType();

        if ( pCommand->Is64BitEnv() )
            {
            pProcFormatString->PushByte( sizeof(NDR_PROC_HEADER_EXTS64) );
            }
        else
            {
            pProcFormatString->PushByte( sizeof(NDR_PROC_HEADER_EXTS) );
            }
        pProcFormatString->PushExtProcFlagsByte( *((char *)&InterpreterOptFlags2) );

        node_proc* pProcThis = (node_proc*) GetType();
        pProcFormatString->PushShort( short( pProcThis->GetClientCorrelationCount() ) );  // client
        pProcFormatString->PushShort( short( pProcThis->GetServerCorrelationCount() ) );  //server
#ifdef PRINT_METRICS
        printf  (
                "Client hint is %16d, Server hint is %16d, for %s\n",
                pProcThis->GetClientCorrelationCount(),
                pProcThis->GetServerCorrelationCount(),
                pProcThis->GetSymName()
                );
#endif

        if( HasNotify() || HasNotifyFlag() )
            GetNotifyTableOffset( pCCB );

        pProcFormatString->PushShort( (short)uNotifyTableOffset ); // notify index
        if ( pCommand->Is64BitEnv() )
            {
            pProcFormatString->PushShort( floatmask );
            }
        }

    SetFormatStringParamStart( pProcFormatString->GetCurrentOffset() );

    pCCB->SetInterpreterOutSize( 0 );

    ITERATOR_INIT( Iterator );
    //
    // Now generate the param info at the end of the format string.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        if (pParam->IsAsyncHandleParam())
            continue;

        pChild = (CG_NDR *) pParam->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamDescription( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamDescription( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    pCCB->SetInObjectInterface( FALSE );

    SetFormatStringEndOffset( pProcFormatString->GetCurrentOffset() );

    // save delta, in case the routine is optimized
    short   usParamStartDelta   = (short) ( GetFormatStringParamStart() -
                                            GetFormatStringOffset() );

    pProcFormatString->OptimizeFragment( this );

    // Set param start!!!
    SetFormatStringParamStart( GetFormatStringOffset() + usParamStartDelta );

    //
    // For interpreted procs we add some comments to the procedure format
    // strings to make the stubs easier to read.
    //

    if ( ! (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER) )
        return;

    char *  pComment;
    long    FormatOffset;
    short   Bytes;

    Bytes = short(32 + strlen( GetSymName() ) );
    pComment = new char[Bytes];

    sprintf( pComment, "\n\t/* Procedure %s */\n\n", GetSymName() );
    pProcFormatString->AddComment( GetFormatStringOffset(), pComment );

    GetMembers( Iterator );

    FormatOffset = GetFormatStringParamStart();

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( pParam->GetCGID() == ID_CG_PRIMITIVE_HDL  || pParam->IsAsyncHandleParam() )
            continue;
        Bytes = short( 32 + strlen( pParam->GetSymName() ) );
        pComment = new char[Bytes];
        sprintf( pComment,
                 "\n\t/* Parameter %s */\n\n",
                 pParam->GetSymName() );
        pProcFormatString->AddComment( FormatOffset, pComment );
        FormatOffset += 6;
        }

    if ( GetReturnType() )
        {
        pProcFormatString->AddComment(
                FormatOffset, "\n\t/* Return value */\n\n" );
        }
    UnsetupFormatStrings(pCCB);
}

void
CG_PROC::GenNdrFormatProcInfo( CCB * pCCB )
/*++
    The layout is:

        handle type<1>
        Oi and pickling flags <1>
        [ rpc flags<4> ]
        proc num <2>
        stack size<2>
        [ explicit handle description <> ]
        [ notify table offset<2> ]
--*/
{
    FORMAT_STRING * pProcFormatString;
    
    SetupFormatStrings(pCCB);
    pProcFormatString = pCCB->GetProcFormatString();

    if ( IsObject() )
        {
        pProcFormatString->PushFormatChar( FC_AUTO_HANDLE );
        }
    else
        {
        if ( pCCB->IsInCallback() )
            {
            pProcFormatString->PushFormatChar( FC_CALLBACK_HANDLE );
            }
        else
            {
            if ( GetHandleUsage() == HU_IMPLICIT )
                {
                //
                // Implicit handle type.
                //
                if ( IsAutoHandle() )
                    pProcFormatString->PushFormatChar( FC_AUTO_HANDLE );
                if ( IsPrimitiveHandle() )
                    pProcFormatString->PushFormatChar( FC_BIND_PRIMITIVE );
                if ( IsGenericHandle() )
                    {
                    pProcFormatString->PushFormatChar( FC_BIND_GENERIC );

                    // implicit generic handle needs to be registered.

                    pCCB->RegisterGenericHandleType(
                                        GetHandleClassPtr()->GetHandleType() );
                    }
                }
            else
                pProcFormatString->PushByte( 0 );
            }
        }

    unsigned char OiFlags = 0;

    // Indicate if there is a need to init the full ptr or rpcss packages.
    if ( HasFullPtr() )
        OiFlags |= Oi_FULL_PTR_USED;

    if ( MustInvokeRpcSSAllocate() )
        OiFlags |= Oi_RPCSS_ALLOC_USED;

    if ( IsObject() )
        {
        OiFlags |= Oi_OBJECT_PROC;

        if ( !ReturnsHRESULT() )
            OiFlags |= Oi_IGNORE_OBJECT_EXCEPTION_HANDLING;

        if ( (GetOptimizationFlags() & OPTIMIZE_INTERPRETER)  &&
             (GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2) )
            OiFlags |= Oi_OBJ_USE_V2_INTERPRETER;
        }

    OiFlags |= Oi_HAS_RPCFLAGS;

    if ( GetCGID() == ID_CG_ENCODE_PROC )
        {
        if ( HasEncode() )
            OiFlags |= ENCODE_IS_USED;
        if ( HasDecode() )
            OiFlags |= DECODE_IS_USED;

        // The Oi_USE_NEW_INIT_ROUTINES and PICKLING_HAS_COMM_OR_FAULT flags
        // are overloaded.  In -Oicf mode, the new routines are always used
        // and the bit specifics comm/fault options (which overriden also).
        // In pre-Oicf comm/fault is not supported.

        if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
            {
            if ( HasStatuses() )
                OiFlags |= PICKLING_HAS_COMM_OR_FAULT;
            }
        else
            {
            OiFlags |= Oi_USE_NEW_INIT_ROUTINES;
            }
        }
    else
        {
        // Always do this.
        OiFlags |= Oi_USE_NEW_INIT_ROUTINES;

        if ( HasStatuses() )
            OiFlags |= Oi_HAS_COMM_OR_FAULT;
        }

    pProcFormatString->PushOldProcFlagsByte( OiFlags );

    pProcFormatString->PushLong( (long) TranslateOpBitsIntoUnsignedInt() );

    // Proc num.
    pProcFormatString->PushShort( (short) GetProcNum() );

    long    Size = GetTotalStackSize( pCCB );

    //
    // Use a push ushort offset or size method which outputs a #ifdef for
    // the various platforms, for which stack offsets are often different.
    //
    pProcFormatString->PushUShortStackOffsetOrSize( Size );

    //
    // Output explicit handle description.
    //
    if ( GetHandleUsage() == HU_EXPLICIT && !IsObject() )
        {
        CG_NDR *    pOldPlaceholder;
        CG_HANDLE * pHandle;

        pHandle = GetHandleClassPtr();

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetHandleUsagePtr() );

        pHandle->GenNdrHandleFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );

        //
        // Patch up a pointer to context handle's offset<2> field.
        //
        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            CG_NDR *    pNdr;
            CG_NDR *    pPointer;

            // Get the handle param's first child node.
            pNdr = (CG_NDR *) GetHandleUsagePtr()->GetChild();
        
            pPointer = 0;

            while ( pNdr->IsPointer() )
                {
                pPointer = pNdr;
                pNdr = (CG_NDR *) GetChild();
                }
            
            if ( pPointer )
                {
                long    OffsetField;
            
                OffsetField = pPointer->GetFormatStringOffset() + 2;

                pCCB->GetFormatString()->PushShortOffset(
                        pHandle->GetFormatStringOffset() - OffsetField,
                        OffsetField );
                }
            }
        }
    UnsetupFormatStrings(pCCB);
}

//
// ##########################################################################
// ----- Interpreted client stub generation. -----###########################
// ##########################################################################
//

void
CG_PROC::GenNdrSingleClientCall( CCB * pCCB )
/*++

Routine Description :

    This is the top level routine for generating code for the single NDR call
    case on the client side.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *           pStream;
    CG_ITERATOR         Iterator;
    expr_node       *   pFinalExpr;
    CG_PARAM        *   pLastParam;
    bool                fIsErrorStatus = false;

    pStream = pCCB->GetStream();

    // Generate the format string.
    if ( pCommand->IsNDRRun() )
        {
        GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    if ( GetReturnType() || HasComplexReturnType() )
        {
        if ( HasAsyncHandle() )
            {
            if ( !HasComplexReturnType() 
                 && GetReturnType()->GetChild()->GetCGID() != ID_CG_CONTEXT_HDL )
                {
                fIsErrorStatus = GetReturnType()->GetChild()->GetCGID() == ID_CG_ERROR_STATUS_T;
                }
            if ( fIsErrorStatus || GetCGID() == ID_CG_OBJECT_PROC )
                {
                pStream->Write( "CLIENT_CALL_RETURN " RETURN_VALUE_VAR_NAME );
                pStream->Write( " = {0};" );
                pStream->NewLine( 2 );
                }
            }
        else
            {
            if ( HasComplexReturnType() )
                {
                ( (node_proc *) GetType() )
                            ->GetReturnType()->PrintType(PRT_DECL, pStream);
                }
            else
                pStream->Write( "CLIENT_CALL_RETURN " );

            pStream->Write( RETURN_VALUE_VAR_NAME );
            pStream->Write( ';' );
            pStream->NewLine( 2 );
            }
        }

    GetMembers(Iterator);

    pLastParam = 0;

    while ( ITERATOR_GETNEXT( Iterator, pLastParam ) )
        ;

    // If we have a complex return type the "last parameter" is actually the
    // return value so we need the one before that.

    if ( pLastParam && HasComplexReturnType() )
        {
        CG_PARAM *pPrevLastParam = NULL;

        ITERATOR_INIT( Iterator );
        while ( ITERATOR_GETNEXT( Iterator, pPrevLastParam ) )
            if ( pPrevLastParam->GetSibling() == pLastParam )
                break;

        pLastParam = pPrevLastParam;
        }

    // Now emit code for x86 or ia64.

    if (  pCommand->Is64BitEnv() )
        {
        // Emit code for IA64 platform
        pFinalExpr = GenCoreNdrSingleClientCall( pCCB, PROC_PLATFORM_IA64) ;
        }
    else
        {
        // x86
        pFinalExpr = GenCoreNdrSingleClientCall( pCCB, PROC_PLATFORM_X86 );
        }

    pFinalExpr->PrintCall( pStream, 0, 0 );
    pStream->NewLine();

    if ( GetReturnType() || HasComplexReturnType() )
        {
        if ( HasAsyncHandle() )
            {
            if ( !fIsErrorStatus && GetCGID() != ID_CG_OBJECT_PROC )
                {
                return;
                }
            }

        pStream->Write("return ");
        
        // 
        // Complex return types
        //

        if ( HasComplexReturnType() )
            {
            pStream->Write( RETURN_VALUE_VAR_NAME ";" );
            pStream->NewLine();
            return;
            }

        CG_NDR*     pNdr = (CG_NDR *) GetReturnType()->GetChild();
        node_skl*   pType = GetReturnType()->GetType();

        //
        // Base type return value.
        //
        if ( pNdr->IsSimpleType() )
            {
            switch ( ((CG_BASETYPE *)pNdr)->GetFormatChar() )
                {
                case FC_FLOAT :
                    pType->PrintType( PRT_CAST_TO_TYPE, pStream );
                    pStream->Write( RETURN_VALUE_VAR_NAME ".Float;" );
                    break;
                case FC_DOUBLE :
                    pType->PrintType( PRT_CAST_TO_TYPE, pStream );
                    pStream->Write( RETURN_VALUE_VAR_NAME ".Double;" );
                    break;
                default :
                    pType->PrintType( PRT_CAST_TO_TYPE, pStream );
                    pStream->Write( RETURN_VALUE_VAR_NAME ".Simple;" );
                    break;
                }

            pStream->NewLine();
            return;
            }

        //
        // A by-value struct or union.
        //
        if ( pNdr->IsStruct() || pNdr->IsUnion() )
            {
            expr_node * pExpr;

            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME ".Pointer" );

            pExpr = MakeDerefExpressionOfCastPtrToType( pType, pExpr );

            pExpr->Print( pStream );

            pStream->Write( ';' );
            pStream->NewLine();
            return;
            }

        //
        // Otherwise pointer or array.
        //
        pType->PrintType( PRT_CAST_TO_TYPE, pStream );
        pStream->Write( RETURN_VALUE_VAR_NAME ".Pointer;" );
        pStream->NewLine();
        }
}

//
// ##########################################################################
// ----- Interpreted server stub generation. -----###########################
// ##########################################################################
//

void
CG_PROC::GenNdrSingleServerCall( CCB * pCCB )
/*++

Routine Description :

    This is the top level routine for generating code for the single NDR call
    case on the server side.  It actually ends up being 3 calls.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *           pStream;
//    CG_PARAM *            pParam;
    expr_proc_call *    pCallExpr;
    char                FormatStringExpr[80];

    //
    // On the server side we just use the format string that was generated
    // during client stub generation if such generation occured.
    //    
    if ( pCommand->IsNDRRun() )
        {
        if ( GetFormatStringOffset() == -1 )
            GenNdrFormat( pCCB );        
        }
    else 
        {
        pCCB->GetNdr64Format()->Generate( this );
        }

    pCCB->SetCGNodeContext( this );

    pStream = pCCB->GetStream();

    //
    // Output the server stub locals.  There are two locals : the stub
    // descriptor and the param struct.
    //
    GenNdrInterpretedServerLocals( pCCB );

    pStream->NewLine();

    //
    // Make the single unmarshall call.
    //
    pCallExpr = new expr_proc_call( S_NDR_UNMARSHALL_RTN_NAME );

    // Rpc message.
    pCallExpr->SetParam( new expr_param(
                         new expr_variable( PRPC_MESSAGE_VAR_NAME ) ) );

    // Stub message.
    pCallExpr->SetParam( new expr_param(
                         new expr_u_address (
                         new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    // Stub descriptor.
    pCallExpr->SetParam( new expr_param(
                         new expr_u_address (
                         new expr_variable(
                            pCCB->GetInterfaceCG()->GetStubDescName() ) ) ) );

    sprintf( FormatStringExpr,
             "&%s[%d]",
             PROC_FORMAT_STRING_STRING_FIELD,
             GetFormatStringOffset() );

    // Format string pointer.
    pCallExpr->SetParam( new expr_param(
                         new expr_variable( FormatStringExpr ) ) );

    // Parameter structure pointer.
    if ( ! IsNullCall() )
        {
        pCallExpr->SetParam( new expr_param(
                             new expr_u_address (
                             new expr_variable( "ParamStruct" ) ) ) );
        }
    else
        {
        pCallExpr->SetParam( new expr_param(
                             new expr_variable( "0" ) ) );
        }

    // Print the unmarshall call.
    pCallExpr->PrintCall( pCCB->GetStream(),
                          0,
                          0 );

    pStream->NewLine();

    //
    // Now make the call to the manager.
    //
    GenNdrInterpretedManagerCall( pCCB );

    //
    // Make the single marshall call.
    //
    pCallExpr = new expr_proc_call( S_NDR_MARSHALL_RTN_NAME );

    // Stub message.
    pCallExpr->SetParam( new expr_param(
                         new expr_u_address (
                         new expr_variable( STUB_MESSAGE_VAR_NAME ) ) ) );

    // Format string pointer.
    pCallExpr->SetParam( new expr_param(
                         new expr_variable( FormatStringExpr ) ) );

    pStream->NewLine( 2 );

    // Print the marshall routine call.
    pCallExpr->PrintCall( pCCB->GetStream(),
                          0,
                          0 );
}

void
CG_PROC::GenNdrInterpretedServerLocals( CCB * pCCB )
/*++

Routine Description :

    This routine outputs the two local variables for an interpreted server
    stub.  The two locals are the stub message and the param struct.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *       pStream;

    pStream = pCCB->GetStream();

    // Stub message local.
    pStream->Write( STUB_MESSAGE_TYPE_NAME " " STUB_MESSAGE_VAR_NAME ";" );
    pStream->NewLine();

    // Generate the param struct for non-null calls only.
    if ( ! IsNullCall() )
        {
        GenNdrInterpreterParamStruct( pCCB );

        pStream->Write( PARAM_STRUCT_TYPE_NAME " ParamStruct;" );
        pStream->NewLine();
        }
}


void
CG_PROC::GenNdrInterpreterParamStruct( 
    CCB *   pCCB)
{
    BOOL   f64 = pCommand->Is64BitEnv();   

    if ( f64)
        GenNdrInterpreterParamStruct64( pCCB);
    else 
        GenNdrInterpreterParamStruct32( pCCB );
}

void
CG_PROC::GenNdrInterpreterParamStruct64( CCB *   pCCB )
{
    CG_ITERATOR     Iterator;
    ISTREAM *       pStream;
    CG_PARAM *      pParam;
    CG_PARAM *      pParamPrev;
    CG_RETURN *     pReturn;
    CG_NDR *        pNdr;
    long            PadNumber;
    char            Buffer[80];
    long            PrevEndOffset;

    pStream = pCCB->GetStream();

    // Register size is 8 for 64b platform.
    pStream->Write( "#pragma pack(8)" );
    pStream->NewLine();

    pStream->Write( PARAM_STRUCT_TYPE_NAME );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->NewLine();

    PadNumber = 0;

    GetMembers( Iterator );

    if ( IsObject() )
        {
        pCCB->GetInterfaceCG()->GetThisDeclarator()->PrintType(
                    PRT_PARAM_OR_ID_DECLARATION,
                    pStream,
                    (node_skl *)0 );
        PrevEndOffset = 8;
        }
    else
        PrevEndOffset = 0;

    pParamPrev = 0;

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
            pNdr = (CG_NDR *) pNdr->GetChild();

        // IA64 does not align every big struct to 16b boundary.
        // Only __int128 etc. would be aligned to 16 (and objects embedding it).
        // OPTIMIZE: The code below is correct, as GetStackOffset with PrevEndOffset
        // is a check for alignment of 16, but pParam->GetMemAlign() would be better.

        if ( (pParam->GetStackSize() > 8)  &&  PrevEndOffset > 0 ) 
            {
                long    CurrentIA64Offset;

                if ( pParamPrev )
                    {
                    PrevEndOffset = pParamPrev->GetStackOffset( pCCB, I386_STACK_SIZING )
                                  + pParamPrev->GetStackSize();
                    if ( PrevEndOffset & 7 )  
                        PrevEndOffset += 8 - (PrevEndOffset & 7);  
                    }

                // The additional pad for 16b aligned objects can only be 
                // a full register as the prev param is already padded.

                CurrentIA64Offset = pParam->GetStackOffset( pCCB, I386_STACK_SIZING );

                if ( CurrentIA64Offset - PrevEndOffset )
                    {
                    sprintf( Buffer, "char Pad%d[8];", PadNumber++ );
                    pStream->Write( Buffer );
                    pStream->NewLine();
                    }
            }

        // 
        // For reasons lost to the ages if we have a pointer to a 
        // context handle then it's type gets munged from TYPE* to
        // NDR_SCONTEXT.  This is fine except that it causes type 
        // mismatch errors in the server stub.  Special case it here.
        //

        bool print = true;

        if ( pNdr->IsPointer() )
            {
            CG_CONTEXT_HANDLE *pHandle = dynamic_cast<CG_CONTEXT_HANDLE *>
                                                ( pNdr->GetChild() );

            if ( pHandle )
                {
                pStream->WriteFormat(
                                "%s *%s;",
                                pHandle->GetHandleType()->GetSymName(),
                                pParam->GetSymName());
                pStream->NewLine();
                print = false;
                }
            }

        // Print the field declaration.
        if (print)
            {
            pParam->GetResource()->GetType()->PrintType(
                        PRT_PARAM_OR_ID_DECLARATION,
                        pStream,
                        (node_skl *)0 );
            }

        //
        // Generate some padding if needed.
        //
        if ( pParam->GetStackSize() & 7 )
            {
            long Pad = 8 - (pParam->GetStackSize() & 7);

            sprintf( Buffer, "char Pad%d[%d];", PadNumber++, Pad );
            pStream->Write( Buffer );
            pStream->NewLine();
            }

        pParamPrev = pParam;
        } // while params
        
    // Add the return type if one is present.
    if ( ( pReturn = GetReturnType() ) != 0 )
        {
        pReturn->GetResource()->GetType()->PrintType(
                PRT_PARAM_OR_ID_DECLARATION,    
                pStream,
                (node_skl *)0 );
        // Possibly we could add a padding after the return type member 
        // but it would not be used anyway.
        }

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( "#pragma pack()" );
    pStream->NewLine();
}

void
CG_PROC::GenNdrInterpreterParamStruct32( CCB * pCCB )
{
    CG_ITERATOR     Iterator;
    ISTREAM *       pStream;
    CG_PARAM *      pParam;
    CG_PARAM *      pParamPrev;
    CG_RETURN *     pReturn;
    CG_NDR *        pNdr;
    long            Pad;
    long            PadNumber;
    char            Buffer[80];

    pStream = pCCB->GetStream();

    pStream->Write( "#pragma pack(4)" );
    pStream->NewLine();

    pStream->Write( PARAM_STRUCT_TYPE_NAME );
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write( '{' );
    pStream->NewLine();

    PadNumber = 0;

    GetMembers( Iterator );

    if ( IsObject() )
        {
        pCCB->GetInterfaceCG()->GetThisDeclarator()->PrintType(
                    PRT_PARAM_OR_ID_DECLARATION,
                    pStream,
                    (node_skl *)0 );
        }

    pParamPrev = 0;

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        pNdr = (CG_NDR *) pParam->GetChild();

        if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
            pNdr = (CG_NDR *) pNdr->GetChild();

        // 
        // For reasons lost to the ages if we have a pointer to a 
        // context handle then it's type gets munged from TYPE* to
        // NDR_SCONTEXT.  This is fine except that it causes type 
        // mismatch errors in the server stub.  Special case it here.
        //

        bool print = true;

        if ( pNdr->IsPointer() )
            {
            CG_CONTEXT_HANDLE *pHandle = dynamic_cast<CG_CONTEXT_HANDLE *>
                                                ( pNdr->GetChild() );

            if ( pHandle )
                {
                pStream->WriteFormat(
                                "%s *%s;",
                                pHandle->GetHandleType()->GetSymName(),
                                pParam->GetSymName());
                pStream->NewLine();
                print = false;
                }
            }

        // Print the field declaration.
        if (print)
            {
            pParam->GetResource()->GetType()->PrintType(
                        PRT_PARAM_OR_ID_DECLARATION,
                        pStream,
                        (node_skl *)0 );
            }

        //
        // Generate some padding if needed.
        //
        if ( pParam->GetStackSize() & 3 )
            {
            Pad = 4 - (pParam->GetStackSize() & 3);

            sprintf( Buffer, "char Pad%d[%d];", PadNumber++, Pad );
            pStream->Write( Buffer );
            pStream->NewLine();
            }

        pParamPrev = pParam;
        } // while params

    // Add the return type if one is present.
    if ( ( pReturn = GetReturnType() ) != 0 )
        {
        pReturn->GetResource()->GetType()->PrintType(
                PRT_PARAM_OR_ID_DECLARATION,    
                pStream,
                (node_skl *)0 );
        }

    pStream->Write( "};" );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( "#pragma pack()" );
    pStream->NewLine();
}



void
CG_PROC::GenNdrInterpretedManagerCall( CCB * pCCB )
/*++

Routine Description :

    This routine outputs the call to the manager for interpreted stubs.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    CG_ITERATOR         Iterator;
    CG_PARAM *          pParam;
//  CG_RETURN *         pReturn;
    expr_proc_call *    pCall;
    expr_node *     pExpr;
    
    if ( GetCallAsName() )
        {
        pCall = new expr_proc_call( GenMangledCallAsName( pCCB ) );
        }
    else
        pCall = new expr_proc_call( GetType()->GetSymName() );

    GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *        pNdr;
        char *          pName;
        expr_node * pExpr;

        pNdr = (CG_NDR *) pParam->GetChild();

        pName = new char[80];

        strcpy( pName, "pParamStruct->" );
        strcat( pName, pParam->GetResource()->GetResourceName() );

        pExpr = new expr_variable( pName );

        pCall->SetParam( new expr_param ( pExpr ) );
        }

    //
    // epv stuff
    //

    expr_node * pExprTemp;

    if( pCCB->IsMEpV() && (GetCGID() != ID_CG_CALLBACK_PROC)  )
        {
        unsigned short M, m;
        CSzBuffer Buffer;
        char * pTemp;

        pCCB->GetVersion( &M, &m );

        Buffer.Set("((");
        Buffer.Append(pCCB->GetInterfaceName());
        Buffer.Append(pCCB->GenMangledName());
        Buffer.Append("_");
        Buffer.Append(pCCB->IsOldNames() ? "SERVER_EPV" : "epv_t");
        Buffer.Append(" *)(");
        Buffer.Append(PRPC_MESSAGE_MANAGER_EPV_NAME);
        Buffer.Append("))");

        pTemp = new char [ strlen( Buffer ) + 1 ];
        strcpy( pTemp, Buffer );

        pExprTemp = new expr_variable( pTemp );//this has the rhs expr for the
                                               // manager epv call. Sneaky !
        pCall = (expr_proc_call *)new expr_pointsto( pExprTemp, pCall );
        }

    //
    // end epv stuff
    //

    // async methods don't have return values
    if ( GetReturnType() && !HasAsyncHandle() )
        {
        CG_NDR  * pC = (CG_NDR *) GetReturnType()->GetChild();

        if( pC->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            expr_proc_call * pProc = new expr_proc_call( "NDRSContextValue" );

            pProc->SetParam( new expr_param(
                             new expr_variable(
                                "pParamStruct->" RETURN_VALUE_VAR_NAME ) ) );

            // cast the proc call to this type.

            pExpr   = MakeDerefExpressionOfCastPtrToType(
                                                 GetReturnType()->GetType(),
                                                 pProc );
            pExpr = new expr_assign (pExpr, pCall );
            }
        else
            {
            pExpr = new expr_assign(
                        new expr_variable(
                            "pParamStruct->" RETURN_VALUE_VAR_NAME ),
                        pCall );
            }
        }
    else
        pExpr = pCall;

    pCCB->GetStream()->NewLine();

    pExpr->PrintCall( pCCB->GetStream(), 0, 0 );

    pCCB->GetStream()->NewLine();
}


void
CG_PROC::GenNdrThunkInterpretedServerStub( CCB * pCCB )
{
    ISTREAM *   pStream;

    pStream = pCCB->GetStream();

    pStream->NewLine();

    if ( pCCB->GetInterfaceCG()->GetCGID() == ID_CG_INHERITED_OBJECT_INTERFACE )
        pStream->Write( "static " );

    pStream->Write( "void __RPC_API" );

    pStream->NewLine();

    pStream->Write( pCCB->GetInterfaceName() );
    pStream->Write( '_' );
    pStream->Write( GetType()->GetSymName() );
//  if ( IsObject() )
        pStream->Write( "_Thunk" );
    pStream->Write( '(' );
    pStream->IndentInc();
    pStream->NewLine();

    pStream->Write( PSTUB_MESSAGE_TYPE_NAME " " PSTUB_MESSAGE_PAR_NAME " )" );
    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( '{' );
    pStream->IndentInc();
    pStream->NewLine();

    GenNdrInterpreterParamStruct( pCCB );

    pStream->Write( PARAM_STRUCT_TYPE_NAME " * pParamStruct;" );
    pStream->NewLine( 2 );

    pStream->Write( "pParamStruct = (" PARAM_STRUCT_TYPE_NAME " *) " );
    pStream->Write( PSTUB_MESSAGE_PAR_NAME "->StackTop;" );
    pStream->NewLine();

    GenNdrInterpretedManagerCall( pCCB );

    pStream->IndentDec();
    pStream->NewLine();

    pStream->Write( '}' );
    pStream->NewLine();
}

void
CG_PROC::GenNdrOldInterpretedServerStub( CCB * pCCB )
{
#ifdef TEMPORARY_OI_SERVER_STUBS

    // This code is being generated temporarily to enable easier debugging
    // of server side -Oi stubs. Normally server side stubs do not exist. And
    // the server side runtime calls the Server side interpreter directly. This
    // causes debugging problems if we want to breakpoint on a method on an
    // interface. Therefore till we get the system converted to -Oi and the
    // stress stabilizes, we will emit a server side procedure which will
    // enable breakpointing per interface proc.


    // This emits just the server side prolog for -Oi.

    S_GenProlog( pCCB );

    // Emit the call to NdrStubCall or NdrServerCall.

    PNAME               pProcName = IsObject() ? S_OBJECT_NDR_CALL_RTN_NAME :
                                                 S_NDR_CALL_RTN_NAME;
    expr_proc_call  *   pProc = new expr_proc_call( pProcName );
    ITERATOR            ParamList;
    expr_node       *   pParam;

    // Set the parameters.

    pCCB->GetListOfParamResources( ParamList );

    while( ITERATOR_GETNEXT( ParamList, pParam ) )
        {
        pProc->SetParam( pParam );
        }

    // Emit the call to the interpreter.

    pProc->PrintCall( pCCB->GetStream(), 0, 0 );
    Out_IndentDec( pCCB );
    Out_ProcClosingBrace( pCCB );

#else TEMPORARY_OI_SERVER_STUBS
    //
    // Generate the function header.
    //
    S_GenProlog( pCCB );

    //
    // Do the single call code generation.  This includes the
    // declarations of the three server locals : the stub message, the
    // return variable if needed, and the parameter structure.
    //
    GenNdrSingleServerCall( pCCB );

    // Generate end stuff.
    Out_IndentDec( pCCB );
    Out_ProcClosingBrace( pCCB );

#endif // TEMPORARY_OI_SERVER_STUBS
}

//
// Param format string generation.
//

void
CG_PARAM::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Calls the parameter's child node to generate it's format string.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    MIDL_ASSERT( !pCommand->IsNDR64Run() );    

    if ( GetFormatStringOffset() != -1 )
        return;

    // The invisible fault/comm status param added by means of acf definition
    // doesn't go on wire, so it has no format string representation.

    if ( IsExtraStatusParam() )
        return;

    // [async_handle] This parameter is the invisible xxx_AsyncHandle and does not go
    // on the wire, so it has no format representation.
    if ( IsAsyncHandleParam() )
        return;
    //
    // Call the param child to generate it's format string.
    //
    ((CG_NDR *)GetChild())->GenNdrFormat( pCCB );

    //
    // Set the param node's format string offset equal to the child.
    //
    SetFormatStringOffset( ((CG_NDR *)GetChild())->GetFormatStringOffset() );
}

//
// Individual NDR routine calls output.
//

void
CG_PARAM::GenNdrMarshallCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr marshall routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    ISTREAM *           pStream;
    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    ID_CG               ParamId;
    long                NameIndex;
    long                FormatOffset;
    BOOL                fTakeAddress;
    BOOL                fDereference;
    unsigned short WireAlign;

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );

    pStream = pCCB->GetStream();

    pChild = (CG_NDR *)GetChild();

    ParamId = pChild->GetCGID();

    pParamName = GetResource()->GetResourceName();

    if ( IsParamPartialIgnore() &&
         ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) )
        {
        Out_PartialIgnoreClientMarshall( pCCB, pParamName );
        return;
        }

    if ( (ParamId == ID_CG_PRIMITIVE_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_PRIMITIVE_HDL)) )
        return;

    //
    // For a generic handle, get the handle data type and then continue.
    //
    if ( ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    //
    // Since a ref pointer is not shipped, we must use it's child to figure
    // out the alignment action and next alignment state.
    //
    if ( pChild->IsPointer() &&
         ( !pChild->IsInterfacePointer() ) && 
         (pChild->GetCGID() != ID_CG_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_STRUCT_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_LENGTH_PTR) &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) )
        {
        CG_NDR * pPtrChild = (CG_NDR *) pChild->GetChild();

        if ( ! pChild->IsPipeOrPipeReference() )
            {
            WireAlign = pPtrChild->GetWireAlignment();
            }
        }
    else
        {
        // We shouldn't do that for pipe and object pipe args

        if ( ! pChild->IsPipeOrPipeReference() )
            {
            WireAlign = pChild->GetWireAlignment();
            }
        }

    // For context handles, generate an optimized code for the client side and
    // also an optimize code for common context handles at the server side but
    // except that for new context handle flavors the call is slightly different.

    if ( (ParamId == ID_CG_CONTEXT_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_CONTEXT_HDL)) )
        {
        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            Out_CContextHandleMarshall( pCCB,
                                        pParamName,
                                        (ParamId == ID_CG_PTR) );
            }
        else
            {
            CG_CONTEXT_HANDLE * pContextHandle;

            pContextHandle = (ParamId == ID_CG_PTR) ?
                             (CG_CONTEXT_HANDLE *) pChild->GetChild() :
                             (CG_CONTEXT_HANDLE *) pChild;

            pCCB->RegisterContextHandleType( pContextHandle->GetHandleType() );

            if ( pContextHandle->HasNewContextFlavor() )
                {
                Out_SContextHandleNewMarshall( pCCB,
                                               pParamName, 
                                               pContextHandle->GetRundownRtnName(),
                                               pContextHandle->GetFormatStringOffset() );
                }
            else
                {
                Out_SContextHandleMarshall( pCCB,
                                            pParamName, 
                                            pContextHandle->GetRundownRtnName() );
                }
            }

        return;
        }

    if ( pChild->GetCGID() == ID_CG_ENUM  ||  pChild->GetCGID() == ID_CG_INT3264 )
        {
        expr_proc_call *    pCall;
        FORMAT_CHARACTER    fc;
        expr_node       *   pExpr;

        if ( pChild->GetCGID() == ID_CG_ENUM )
            fc = ((CG_ENUM *)pChild)->GetFormatChar();
        else
            fc = ((CG_BASETYPE *)pChild)->GetSignedFormatChar();

        pCall = new expr_proc_call( "NdrSimpleTypeMarshall" );

        pExpr = new expr_u_address (
                         new expr_variable( STUB_MESSAGE_VAR_NAME ) );
        pExpr = MakeExpressionOfCastToTypeName(PSTUB_MESSAGE_TYPE_NAME , pExpr);

        pCall->SetParam( new expr_param( pExpr ) );

        pExpr =  new expr_u_address ( new expr_variable( pParamName ) );
        pExpr = MakeCastExprPtrToUChar( pExpr );

        pCall->SetParam( new expr_param( pExpr ) );

        // Don't emit names like FC_ENUM16 or FC_INT3264 as constants are not public.
        pCall->SetParam( new expr_param(
                         new expr_constant( (long)fc ) ) );

        pStream->NewLine();

        pCall->PrintCall( pStream, 0, 0 );

        return;
        }

    if ( pChild->IsSimpleType() )
        {
        pStream->NewLine();

        OutputNdrAlignment( pCCB, WireAlign );

        //
        // Now make the assignment expression and increment with cast, like :
        //
        //   *((<type> *)_StubMsg.Buffer)++ = <var>;
        //
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );

        pVar = new expr_variable( pParamName );

        pExpr = MakeExpressionOfCastPtrToType( pChild->GetType(), pBufVar );

        pExpr = new expr_post_incr( pExpr );
        pExpr = new expr_u_deref( pExpr );
        pExpr = new expr_assign( pExpr, pVar );

        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsPointerToBaseType() &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_ENUM)  &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_INT3264) )
        {
        CG_POINTER *        pPointer;
        CG_NDR *            pBasetype;
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pPointer = (CG_POINTER *) pChild;

        pBasetype = (CG_NDR *) pPointer->GetChild();

        if ( pBasetype->GetCGID() == ID_CG_GENERIC_HDL )
            pBasetype = (CG_NDR *) pBasetype->GetChild();

        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );

        pVar = new expr_variable( pParamName );

        pStream->NewLine();

        OutputNdrAlignment( pCCB, WireAlign );

        //
        // Now make the assignment expression and increment with cast, like :
        //
        //   *((<type>)_StubMsg.Buffer)++ = *<var>;
        //

        pExpr = MakeExpressionOfCastPtrToType( pBasetype->GetType(), pBufVar );

        pExpr = new expr_post_incr( pExpr );
        pExpr = new expr_u_deref( pExpr );
        pExpr = new expr_assign( pExpr, new expr_u_deref(pVar) );

        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();

        return;
        }

    GenNdrTopLevelAttributeSupport( pCCB );
    
    pFormatString = pCCB->GetFormatString();

    FormatOffset = pChild->GetFormatStringOffset();
    NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );

    //
    // If the param is a by-value struct or union then set the fTakeAddress
    // flag.
    //
    fTakeAddress =  pChild->IsStruct() || pChild->IsUnion()
                    || pChild->IsXmitRepOrUserMarshal();

    //
    // If the param is an array and we're in the server stub then we
    // must dereference it.
    //
    fDereference =  (pCCB->GetCodeGenSide() == CGSIDE_SERVER) &&
                    pChild->IsArray();

    //
    // If the param is an omitted cs_tag param, the marshalling code takes
    // care of handling the call to the tag routine to get the actual value.
    // Also, since we don't have the parameter on the stack we don't have a
    // name to pass to Marshall so just pass "0" (NULL)
    //
    if ( IsOmittedParam() )
        {
        PNAME pNewName = (PNAME) alloca( sizeof("0 /*  */") 
                                            + strlen(pParamName) );
        strcpy( pNewName, "0 /* ");
        strcat( pNewName, pParamName );
        strcat( pNewName, " */");
        pParamName = pNewName;
        fTakeAddress = FALSE;   // Probably don't need these but be safe
        fDereference = FALSE;
        }

    //
    // For ref pointers with no funky attributes, we optimize by calling
    // the pointee's routine directly.
    //
    if ( pChild->IsPointer() && ((CG_POINTER *)pChild)->IsBasicRefPointer() )
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) pChild;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetFormatStringOffset() + 2;
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_STRUCT_STRING_PTR :
                break;

            default :
                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;
            }
        }

    Out_NdrMarshallCall( pCCB,
                         pNdrRoutineNames[NameIndex],
                         pParamName,
                         FormatOffset,
                         fTakeAddress,
                         fDereference );
}

void
CG_PARAM::GenNdrUnmarshallCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr unmarshall routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );

    ISTREAM *           pStream;
    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    ID_CG               ParamId;
    long                NameIndex;
    long                FormatOffset;
    BOOL                fMustAllocFlag = FALSE;
    BOOL                fTakeAddress = TRUE;

    unsigned short WireAlign;

    pStream = pCCB->GetStream();

    pChild = (CG_NDR *)GetChild();

    ParamId = pChild->GetCGID();
    
    pParamName = GetResource()->GetResourceName();

    if ( IsParamPartialIgnore() &&
         ( pCCB->GetCodeGenSide() == CGSIDE_SERVER ) )
        {
        Out_PartialIgnoreServerUnmarshall( pCCB, pParamName );
        return;
        }

    if ( (ParamId == ID_CG_PRIMITIVE_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_PRIMITIVE_HDL)) )
        return;

    //
    // For a generic handle, get the handle data type and then continue.
    //
    if ( ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    BOOL IsOutOnly;

    IsOutOnly = ! IsParamIn() || (GetCGID() == ID_CG_RETURN);

    //
    // Since a ref pointer is not shipped, we must use it's child to figure
    // out the alignment action and next alignment state.
    //
    if ( pChild->IsPointer() &&
         (!pChild->IsInterfacePointer()) &&
         (pChild->GetCGID() != ID_CG_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_STRUCT_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_STRING_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_PTR) &&
         (pChild->GetCGID() != ID_CG_SIZE_LENGTH_PTR) &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) )
        {
        CG_NDR * pPtrChild = (CG_NDR *) pChild->GetChild();

        if ( ! (IsExtraStatusParam()  ||  pChild->IsPipeOrPipeReference()) )
            {
            WireAlign = pPtrChild->GetWireAlignment();
            }
        }
    else
        {
        // We should not do that for pipe or object pipe args
        // However, we do not support -Os pipes as yet.

        if ( ! pChild->IsPipeOrPipeReference() )
            {
            WireAlign = pChild->GetWireAlignment();
            }
        }

    // For context handles, generate an optimized code for the client side and
    // also an optimize code for common context handles at the server side but
    // except that for new context handle flavors the call is slightly different.

    if ( (ParamId == ID_CG_CONTEXT_HDL) ||
         ( (ParamId == ID_CG_PTR) &&
           (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_CONTEXT_HDL) ) )
        {
        if ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT )
            {
            BOOL    Initialize;

            Initialize = IsOutOnly && (ParamId == ID_CG_PTR);

            Out_CContextHandleUnmarshall( pCCB,
                                          pParamName,
                                          Initialize,
                                          GetCGID() == ID_CG_RETURN );
            }
        else
            {
            CG_CONTEXT_HANDLE * pContextHandle;

            pContextHandle = (ParamId == ID_CG_PTR) ?
                             (CG_CONTEXT_HANDLE *) pChild->GetChild() :
                             (CG_CONTEXT_HANDLE *) pChild;

            if ( pContextHandle->HasNewContextFlavor()  ||  
                 pCommand->GetNdrVersionControl().IsNdr50orLaterRequired() )
                {
                Out_SContextHandleNewUnmarshall( pCCB,
                                                 pParamName,   
                                                 IsOutOnly,
                                                 pContextHandle->GetFormatStringOffset() );
                }
            else
                {
                Out_SContextHandleUnmarshall( pCCB,
                                              pParamName,   
                                              IsOutOnly );
                }
            }

        return;
        }

    if ( pChild->GetCGID() == ID_CG_ENUM  ||  pChild->GetCGID() == ID_CG_INT3264 )
        {
        expr_proc_call *    pCall;
        FORMAT_CHARACTER    fc;
        expr_node       *   pExpr;

        if ( pChild->GetCGID() == ID_CG_ENUM )
            fc = ((CG_ENUM *)pChild)->GetFormatChar();
        else
            fc = ((CG_BASETYPE *)pChild)->GetSignedFormatChar();

        pCall = new expr_proc_call( "NdrSimpleTypeUnmarshall" );

        pExpr = new expr_u_address(new expr_variable(STUB_MESSAGE_VAR_NAME));
        pExpr = MakeExpressionOfCastToTypeName(PSTUB_MESSAGE_TYPE_NAME , pExpr);

        pCall->SetParam( new expr_param( pExpr ) );

        pExpr =  new expr_u_address ( new expr_variable( pParamName ) );
        pExpr = MakeCastExprPtrToUChar( pExpr );

        pCall->SetParam( new expr_param( pExpr ) );

        pCall->SetParam( new expr_param(
                         new expr_constant( (long)fc ) ) );

        pStream->NewLine();

        pCall->PrintCall( pStream, 0, 0 );

        return;
        }

    if ( pChild->IsSimpleType() )
        {
        pStream->NewLine();

        OutputNdrAlignment( pCCB, WireAlign );
        Out_CheckUnMarshallPastBufferEnd( pCCB, pChild->GetWireSize() );
        pStream->NewLine();

        //
        // Now make the assignment expression and increment with cast, like :
        //
        //   <var> = *((<type> *)_StubMsg.Buffer)++;
        //
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );

        pVar = new expr_variable( pParamName );

        pExpr = MakeExpressionOfCastPtrToType( pChild->GetType(), pBufVar );

        pExpr = new expr_post_incr( pExpr );
        pExpr = new expr_u_deref( pExpr );
        pExpr = new expr_assign( pVar, pExpr );

        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsPointerToBaseType() &&
         (((CG_POINTER *)pChild)->GetPtrType() == PTR_REF) &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_ENUM) &&
         (((CG_NDR *)pChild->GetChild())->GetCGID() != ID_CG_INT3264) )
        {
        CG_POINTER *        pPointer;
        CG_NDR *            pBasetype;
        expr_node *     pExpr;
        expr_variable * pBufVar;
        expr_variable * pVar;

        pStream->NewLine();

        pPointer = (CG_POINTER *) pChild;

        pBasetype = (CG_NDR *) pPointer->GetChild();

        if ( pBasetype->GetCGID() == ID_CG_GENERIC_HDL )
            pBasetype = (CG_NDR *) pBasetype->GetChild();
    
        pBufVar = new expr_variable( STUB_MSG_BUFFER_VAR_NAME );
    
        pVar = new expr_variable( pParamName );
    
        if ( IsExtraStatusParam() )
            {
            // For the extra (invisible) fault/comm status parameter, that 
            // does *not* go on the wire, we need to generate an assignment 
            // when unmarshaling on the client (the arg can only be [out]).
            // The value to be assigned is error_status_ok, which maps to 0.

            pExpr = new expr_constant( (long)0 );
            pExpr = new expr_assign( new expr_u_deref( pVar ), 
                                     pExpr );
    
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }
        else
            {
            // For other types generate unmarshaling assignment.

            OutputNdrAlignment( pCCB, WireAlign );

            //
            // Now make the assignment of the pointer to the current buffer
            // pointer (server) or copy the incomming referent's value (client)
            // and increment the buffer pointer.
            //
    
            pExpr = MakeExpressionOfCastPtrToType( pBasetype->GetType(), pBufVar );
    
            if ( pCCB->GetCodeGenSide() == CGSIDE_SERVER )
                {
                pExpr = new expr_assign( pVar, pExpr );
                }
            else
                {
                pExpr = new expr_post_incr( pExpr );
                pExpr = new expr_assign(
                            new expr_u_deref( pVar ),
                            new expr_u_deref( pExpr ) );
                }
    
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
    
            if ( pCCB->GetCodeGenSide() == CGSIDE_SERVER )
                {
                pStream->Write( STUB_MSG_BUFFER_VAR_NAME " += " );
    
                pExpr = new expr_sizeof( pBasetype->GetType() );

                // pExpr = new expr_b_arithmetic( OP_PLUS, pBufVar, pExpr );
                // pExpr = new expr_assign( pBufVar, pExpr );

                pExpr->Print( pStream );
                pStream->Write( ";" );
                pStream->NewLine();
                }
            }

        return;
        }

    if ( pChild->GetCGID() == ID_CG_BC_PTR )
        GenNdrTopLevelAttributeSupport( pCCB );
    
    pFormatString = pCCB->GetFormatString();

    //
    // If this is a by-value structure or union then use the mangled
    // local pointer variable to the same type.
    //
    if ( pChild->IsStruct() || pChild->IsUnion() ||
         pChild->IsXmitRepOrUserMarshal() )
        {
        if ( !( pCCB->GetCodeGenSide() == CGSIDE_CLIENT  && IsParamIn() ) )
            {
            char *  pName = new char[strlen(pParamName) + 10];

            strcpy( pName, LOCAL_NAME_POINTER_MANGLE );
            strcat( pName, pParamName );

            pParamName = pName;
            }

        //
        // If this is a regular structure or an encapsulated struct (union)
        // being returned, then zero it out.
        //
        if( (GetCGID() == ID_CG_RETURN) &&
            (pChild->IsStruct() || pChild->IsUnion()) )
            {
            Out_MemsetToZero( pCCB,
                              new expr_variable( pParamName, 0 ),
                              new expr_sizeof( pChild->GetType() ) );

            }
        }

    FormatOffset = pChild->GetFormatStringOffset();
    NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );

    //
    // For ref pointers with no funky attributes, we optimize by calling
    // the pointee's routine directly.
    //
    if ( pChild->IsPointer() && ((CG_POINTER *)pChild)->IsBasicRefPointer() )
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) pChild;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetFormatStringOffset() + 2;
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_STRUCT_STRING_PTR :
                break;

            default :
                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;
            }
        }

    //
    // If the param is an omitted cs_tag param, the marshalling code takes
    // care of handling the call to the tag routine to get the actual value.
    // Also, since we don't have the parameter on the stack we don't have a
    // name to pass to Unmarshall so just pass "0" (NULL)
    //
    if ( IsOmittedParam() )
        {
        PNAME pNewName = (PNAME) alloca( sizeof("0 /*  */") 
                                            + strlen(pParamName) );
        strcpy( pNewName, "0 /* ");
        strcat( pNewName, pParamName );
        strcat( pNewName, " */");
        pParamName = pNewName;
        fTakeAddress = FALSE;
        }

    Out_NdrUnmarshallCall( pCCB,
                           pNdrRoutineNames[NameIndex],
                           pParamName,
                           FormatOffset,
                           fTakeAddress,
                           fMustAllocFlag );
}

void
CG_PARAM::GenNdrBufferSizeCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr buffer sizing routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );


    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    ID_CG               ParamId;
    long                NameIndex;
    long                FormatOffset;
    BOOL                fTakeAddress;
    BOOL                fDereference;

    pChild = (CG_NDR *)GetChild();
    
    ParamId    = pChild->GetCGID();
    pParamName = GetResource()->GetResourceName();


    if ( IsParamPartialIgnore() &&
         ( pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) )
        {
        Out_PartialIgnoreClientBufferSize( pCCB, pParamName );
        return;
        }

    //
    // Primitive handle contributes no size.
    //
    if ( (ParamId == ID_CG_PRIMITIVE_HDL) ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_PRIMITIVE_HDL)) )
        return;

    //
    // For a generic handle, get the handle data type and then continue.
    //
    if ( ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *)pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    if ( ParamId == ID_CG_CONTEXT_HDL ||
         ((ParamId == ID_CG_PTR) &&
          (((CG_NDR *)pChild->GetChild())->GetCGID() == ID_CG_CONTEXT_HDL)) )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 20;" );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsSimpleType() )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 16;" );
        pStream->NewLine();

        return;
        }

    if ( pChild->IsPointerToBaseType() )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 24;" );
        pStream->NewLine();

        return;
        }

    GenNdrTopLevelAttributeSupport( pCCB );
    
    pFormatString = pCCB->GetFormatString();

    FormatOffset = pChild->GetFormatStringOffset();
    NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
    
    //
    // If the param is a by-value struct or union then set the fTakeAddress
    // flag.
    //
    fTakeAddress =  pChild->IsStruct() || pChild->IsUnion()
                    || pChild->IsXmitRepOrUserMarshal();

    //
    // If the param is an array and we're in the server stub then we
    // must dereference it.
    //
    fDereference = (pCCB->GetCodeGenSide() == CGSIDE_SERVER) &&
                   pChild->IsArray();

    //
    // For ref pointers with no funky attributes, we optimize by calling
    // the pointee's routine directly.
    //
    if ( pChild->IsPointer() && ((CG_POINTER *)pChild)->IsBasicRefPointer() )
        {
        CG_POINTER *    pPointer;

        pPointer = (CG_POINTER *) pChild;

        switch ( pPointer->GetCGID() )
            {
            case ID_CG_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetFormatStringOffset() + 2;
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_SIZE_STRING_PTR :
                if ( ((CG_STRING_POINTER *)pPointer)->IsStringableStruct() )
                    break;

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;

            case ID_CG_STRUCT_STRING_PTR :
                break;

            default :
                if ( ID_CG_CS_TAG == pPointer->GetChild()->GetCGID() )
                    {
                    ParamId = ID_CG_CS_TAG;
                    break;
                    }

                FormatOffset = pPointer->GetPointeeFormatStringOffset();
                NameIndex = (long) pFormatString->GetFormatChar( FormatOffset );
                break;
            }
        }

    if ( ID_CG_CS_TAG == ParamId )
        {
        ISTREAM *   pStream = pCCB->GetStream();

        pStream->WriteOnNewLine( STUB_MSG_LENGTH_VAR_NAME " += 4; /* " );
        pStream->Write( pParamName );
        pStream->Write( " */" );
        pStream->NewLine();

        return;
        }

    Out_NdrBufferSizeCall( pCCB,
                           pNdrRoutineNames[NameIndex],
                           pParamName,
                           FormatOffset,
                           fTakeAddress,
                           fDereference,
                           FALSE );     // _StubMsg
}


void
GenDontCallFreeInstAssign(
    CCB *   pCCB,
    int     SetupValue
    )
/*++
    a helper routine for GenNdrFreeCall.
    Generates an assignment that sets or resets StubMsg.fDontCallFreeInst.
--*/
{
    ISTREAM * pStream = pCCB->GetStream();

    pStream->NewLine();
    pStream->Write( STUB_MESSAGE_VAR_NAME );
    pStream->Write( ".fDontCallFreeInst = " );
    pStream->Write( SetupValue ? "1;"
                               : "0;" );
}

void
CG_PARAM::GenNdrFreeCall( CCB * pCCB )
/*++

Routine Description :

    Outputs a parameter's ndr free routine call.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{

    // BUG BUG, this needs to be cleaned up for NDR64
    MIDL_ASSERT( !pCommand->IsNDR64Run() );


    CG_PROC *           pProc;
    CG_NDR *            pChild;
    FORMAT_STRING *     pFormatString;
    PNAME               pParamName;
    long                Index;
    BOOL                fTakeAddress;
    BOOL                fDereference;

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    //
    // If the proc uses RpcSs then don't emit any freeing code.
    //
    if ( pProc->MustInvokeRpcSSAllocate() )
        return;

    pChild = (CG_NDR *) GetChild();

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *) pChild->GetChild();

    //
    // Check if we need to make a call to an NDR freeing routine for this data.
    //
    if ( pChild->ShouldFreeOffline() ||
         IsParamPartialIgnore() )
        {
        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        GenNdrTopLevelAttributeSupport( pCCB );
    
        pFormatString = pCCB->GetFormatString();

        Index = (long) pFormatString->GetFormatChar(
                                pChild->GetFormatStringOffset() );

        pParamName = GetResource()->GetResourceName();

        //
        // If the param is a by-value struct or union then set the fTakeAddress
        // flag.
        //
        fTakeAddress =  pChild->IsStruct() || pChild->IsUnion()
                        || pChild->IsXmitRepOrUserMarshal();

        fDereference = FALSE;

        if (  GetDontCallFreeInst() )
            GenDontCallFreeInstAssign( pCCB, 1 );

        Out_NdrFreeCall( pCCB,
                         pNdrRoutineNames[Index],
                         pParamName,
                         pChild->GetFormatStringOffset(),
                         fTakeAddress,
                         fDereference );

        if (  GetDontCallFreeInst() )
            GenDontCallFreeInstAssign( pCCB, 0 );
        }

    //
    // Now generate any needed inline freeing.
    //
    pChild->GenFreeInline( pCCB );
}

void
CG_PARAM::GenNdrTopLevelAttributeSupport(
    CCB *   pCCB,
    BOOL    fForClearOut )
/*++

Routine Description :

    Outputs the assignment(s) to the stub message MaxCount, ActualCount,
    and/or Offset fields, for support of top level conformant and/or
    varying arrays, attributed pointers, and non-encapsulated unions for
    mixed model stubs.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    CG_NDR *            pChild;
    ISTREAM *           pStream = pCCB->GetStream();
    expr_node *     pExpr;
    expr_node *     pSizeOrSwitchIsExpr;
    expr_node *     pFirstIsExpr;
    expr_node *     pLengthIsExpr;
    ID_CG               ParamId;

    pChild = (CG_NDR *)GetChild();
    ParamId = pChild->GetCGID();

    // Skip over pointers and generic handles.
    while ( ParamId == ID_CG_PTR || ParamId == ID_CG_GENERIC_HDL )
        {
        pChild = (CG_NDR *) pChild->GetChild();
        ParamId = pChild->GetCGID();
        }

    //
    // Multidimensional conformant/varying arrays and sized pointers of
    // sized pointers need some special handling.
    //
    if ( (pChild->IsArray() && ((CG_ARRAY *)pChild)->IsMultiConfOrVar()) ||
         (pChild->IsPointer() && ((CG_POINTER *)pChild)->IsMultiSize()) )
        {
        CSzBuffer Buffer;

        pStream->NewLine();

/*
        if ( (ParamId == ID_CG_CONF_ARRAY) ||
             (ParamId == ID_CG_CONF_VAR_ARRAY) ||
             (ParamId == ID_CG_SIZE_PTR) ||
             (ParamId == ID_CG_SIZE_LENGTH_PTR) )
*/
            {
            Buffer.Set(pChild->IsArray() ? "(unsigned long) " : "");
            Buffer.Append("_maxcount_");
            Buffer.Append(GetType()->GetSymName());

            if ( pChild->IsPointer() )
                pExpr = new expr_variable(
                                STUB_MESSAGE_VAR_NAME ".SizePtrCountArray" );
            else
                pExpr = new expr_variable(
                                STUB_MESSAGE_VAR_NAME ".MaxCount" );

            pExpr = new expr_assign( pExpr, new expr_variable( Buffer ) );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }
/*
        if ( (ParamId == ID_CG_CONF_VAR_ARRAY) ||
             (ParamId == ID_CG_VAR_ARRAY) ||
             (ParamId == ID_CG_SIZE_LENGTH_PTR) )
*/
            {
            Buffer.Set(pChild->IsArray() ? "(unsigned long) " : "");
            Buffer.Append("_offset_");
            Buffer.Append(GetType()->GetSymName());

            if ( pChild->IsPointer() )
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".SizePtrOffsetArray" );
            else
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".Offset" );

            pExpr = new expr_assign( pExpr, new expr_variable( Buffer ) );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();

            Buffer.Set(pChild->IsArray() ? "(unsigned long) " : "");
            Buffer.Append("_length_");
            Buffer.Append(GetType()->GetSymName());

            if ( pChild->IsPointer() )
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".SizePtrLengthArray" );
            else
                pExpr = new expr_variable(
                            STUB_MESSAGE_VAR_NAME ".ActualCount" );

            pExpr = new expr_assign( pExpr, new expr_variable( Buffer ) );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }

        return;
        }

    //
    // We check here if the parameter is a top level attributed array or
    // pointer, a non-encapsulated union or a pointer to a non-encapsulated
    // union.  If it isn't, then return.
    //
    switch ( ParamId )
        {
        case ID_CG_CONF_ARRAY :
        case ID_CG_CONF_VAR_ARRAY :
        case ID_CG_VAR_ARRAY :
        case ID_CG_CONF_STRING_ARRAY :
        case ID_CG_SIZE_PTR :
        case ID_CG_SIZE_LENGTH_PTR :
        case ID_CG_SIZE_STRING_PTR :
        case ID_CG_UNION :
            break;

        case ID_CG_BC_PTR :
            if ( pCCB->GetCodeGenSide() == CGSIDE_SERVER )
                return;

            {
            ISTREAM *       pStream = pCCB->GetStream();
            expr_node       *pExpr, *pSizeExpr;
            CG_BYTE_COUNT_POINTER *     pByteCount;

            pByteCount = (CG_BYTE_COUNT_POINTER *) pChild;

            pSizeExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                        new expr_variable(
                            pByteCount->GetByteCountParam()->GetSymName() ) );

            pExpr = new expr_assign(
                        new expr_variable( STUB_MESSAGE_VAR_NAME ".MaxCount" ),
                        pSizeExpr );

            pStream->NewLine();
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }

            return;

        case ID_CG_IIDIS_INTERFACE_PTR:
            {
            CG_IIDIS_INTERFACE_POINTER *  pIfPointer;
            ISTREAM *               pStream = pCCB->GetStream();

            pIfPointer = (CG_IIDIS_INTERFACE_POINTER *) pChild;

            if ( ! pIfPointer->GetIIDExpr() )
                return;

            pStream->NewLine();

            if ( pCommand->Is64BitEnv() )
                {
                // _StubMsg.MaxCount = (ULONG_PTR) ( riid );
                pStream->Write( STUB_MESSAGE_VAR_NAME
                                ".MaxCount = (ULONG_PTR) ( " );
                }
            else
                {
                // _StubMsg.MaxCount = (unsigned long) ( riid );
                pStream->Write( STUB_MESSAGE_VAR_NAME
                                ".MaxCount = (unsigned long) ( " );
                }

            pIfPointer->GetIIDExpr()->Print( pStream );
            pStream->Write( " );" );
            pStream->NewLine();
            }

            return;

        default :
            return;
        }
    
    pCCB->GetStream()->NewLine();

    switch ( pChild->GetCGID() )
        {
        case ID_CG_CONF_ARRAY :
            pSizeOrSwitchIsExpr =
                ((CG_CONFORMANT_ARRAY *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_CONF_VAR_ARRAY :
            pSizeOrSwitchIsExpr =
                ((CG_CONFORMANT_VARYING_ARRAY *)pChild)->GetSizeIsExpr();
            pFirstIsExpr =
                ((CG_CONFORMANT_VARYING_ARRAY *)pChild)->GetFirstIsExpr();
            pLengthIsExpr =
                ((CG_CONFORMANT_VARYING_ARRAY *)pChild)->GetLengthIsExpr();
            break;

        case ID_CG_VAR_ARRAY :
            pSizeOrSwitchIsExpr = NULL;
            pFirstIsExpr =
                ((CG_VARYING_ARRAY *)pChild)->GetFirstIsExpr();
            pLengthIsExpr =
                ((CG_VARYING_ARRAY *)pChild)->GetLengthIsExpr();
            break;

        case ID_CG_CONF_STRING_ARRAY :
            pSizeOrSwitchIsExpr =
                ((CG_CONFORMANT_STRING_ARRAY *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_SIZE_PTR :
            pSizeOrSwitchIsExpr =
                ((CG_SIZE_POINTER *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_SIZE_LENGTH_PTR :
            pSizeOrSwitchIsExpr =
                ((CG_SIZE_LENGTH_POINTER *)pChild)->GetSizeIsExpr();
            pFirstIsExpr =
                ((CG_SIZE_LENGTH_POINTER *)pChild)->GetFirstIsExpr();
            pLengthIsExpr =
                ((CG_SIZE_LENGTH_POINTER *)pChild)->GetLengthIsExpr();
            break;

        case ID_CG_SIZE_STRING_PTR :
            pSizeOrSwitchIsExpr =
                ((CG_SIZE_STRING_POINTER *)pChild)->GetSizeIsExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;

        case ID_CG_UNION :
        case ID_CG_PTR :
            pSizeOrSwitchIsExpr = GetSwitchExpr();
            pFirstIsExpr = NULL;
            pLengthIsExpr = NULL;
            break;
        }

    if ( pSizeOrSwitchIsExpr )
        {
        pSizeOrSwitchIsExpr = MakeAttrExprWithNullPtrChecks(
                                                     pSizeOrSwitchIsExpr );
        pSizeOrSwitchIsExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                     pSizeOrSwitchIsExpr );

        pExpr = new expr_assign(
                    new expr_variable( STUB_MESSAGE_VAR_NAME ".MaxCount" ),
                    pSizeOrSwitchIsExpr );
        pExpr->Print( pStream );
        pStream->Write( ';' );
        pStream->NewLine();
        }
        
    if ( pFirstIsExpr )
        {
        //
        // For NdrClearOutParams we ignore the first_is() & length_is()
        // attributes in case these are [out] and therefore unitialized.
        //
        if ( fForClearOut )
            {
            pStream->Write( STUB_MESSAGE_VAR_NAME ".Offset = 0;" );
            pStream->NewLine();
            }
        else
            {
            pFirstIsExpr = MakeAttrExprWithNullPtrChecks( pFirstIsExpr );

            pFirstIsExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                            pFirstIsExpr );

            pExpr = new expr_assign(
                        new expr_variable( STUB_MESSAGE_VAR_NAME ".Offset" ),
                        pFirstIsExpr );
            pExpr->Print( pStream );
            pStream->Write( ';' );
            pStream->NewLine();
            }

        //
        // Create a LengthIsExpr if one does not already exist.
        //
        if ( ! pLengthIsExpr )
            {
            expr_node * pSize;

            if ( pChild->IsPointer() )
                {
                // Size/length pointer.
                pSize = ((CG_SIZE_LENGTH_POINTER *)pChild)->GetSizeIsExpr();
                }
            else
                {
                // Conformant varying or varying array.
                pSize = ((CG_ARRAY *)pChild)->GetSizeIsExpr();
                }

            pLengthIsExpr =
                new expr_b_arithmetic( OP_MINUS,
                                        pSize,
                                        pFirstIsExpr );
            }
        }
        
    if ( pLengthIsExpr )
        {
        //
        // For NdrClearOutParams we ignore the first_is() & length_is()
        // attributes in case these are [out] and therefore unitialized.
        //
        if ( fForClearOut )
            {
            pStream->Write( STUB_MESSAGE_VAR_NAME ".ActualCount" " = (unsigned long) " );
            pStream->Write( STUB_MESSAGE_VAR_NAME ".MaxCount;" );
            pStream->NewLine();
            }
        else
            {
            pLengthIsExpr = MakeAttrExprWithNullPtrChecks( pLengthIsExpr );

            pLengthIsExpr = MakeExpressionOfCastToTypeName( "unsigned long", 
                                                            pLengthIsExpr );

            pExpr = new expr_assign(
                        new expr_variable(STUB_MESSAGE_VAR_NAME ".ActualCount"),
                        pLengthIsExpr );
            pExpr->Print( pStream );
            pStream->Write( ";" );
            pStream->NewLine();
            }
        }
}

expr_node *
CG_PROC::GenCoreNdrSingleClientCall(
    CCB *               pCCB,
    PROC_CALL_PLATFORM  Platform )

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Creates the real expression for the ndr single client call.

 Arguments:

    Platform    -  x86, IA64, alpha, etc.
                   An explicit enum type is used to indicate platform.

 Return Value:

    None.
    
 Notes:

    On risc machines, the compiler passes the parameters in registers,
    therefore the client stub is passed the parameters in registers. The
    interpreter needs arguments on the stack. In order to force a spill of the
    parameters from the registers to the stack, we need to pass addr all the
    parameters to NdrClientCall.

        stub_proc( p1, p2, p3 )
            {
            ...
            NdrClientCall( STUB_DESC *,
                           FORMAT_STRING *,
                           &p1,
                           &p2,
                           &p3 );
            ...
            }

    On Alpha the varargs is simply weird. The code generated needs to be

        stub_proc( p1, p2, p3 )
            {
            ...
            NdrClientCall( STUB_DESC *,
                           FORMAT_STRING *,
                           vlist.a0 );
            ...
            }

----------------------------------------------------------------------------*/
{
    char                FormatStringExpr[80];
    expr_proc_call  *   pCallExpr;
    expr_node       *   pExpr;
    CG_PARAM        *   pParam;
    PNAME               pFormatName;
    OPTIM_OPTION        OptimOptions;

    OptimOptions = GetOptimizationFlags();

    //
    // Now construct the expression for the Ndr call.
    //
    
    if ( HasAsyncUUID() )
        {
        if ( pCommand->NeedsNDR64Run() )
            pCallExpr = new expr_proc_call( C_NDR64_CALL_RTN_NAME_DCOM_ASYNC );
        else
            pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME_DCOM_ASYNC );
        }
    else if ( HasAsyncHandle() )
        {
        if ( pCommand->NeedsNDR64Run() )
            pCallExpr = new expr_proc_call( C_NDR64_CALL_RTN_NAME_ASYNC );
        else
            pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME_ASYNC );
        }
    else
        {
        if ( pCommand->NeedsNDR64Run() )
            pCallExpr = new expr_proc_call ( C_NDR64_CALL_RTN_NAME );
        else
            {
            if ( OptimOptions & OPTIMIZE_INTERPRETER_V2 )
                pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME_V2 );
            else
                pCallExpr = new expr_proc_call( C_NDR_CALL_RTN_NAME );
            }
        }

    if ( ! pCommand->NeedsNDR64Run() )
        {
        //
        // Stub Descriptor
        //

        pExpr = new expr_variable( pCCB->GetInterfaceCG()->GetStubDescName() );
        pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr = MakeExpressionOfCastToTypeName(PSTUB_DESC_STRUCT_TYPE_NAME, pExpr);

        pCallExpr->SetParam( new expr_param( pExpr ) );

        sprintf( FormatStringExpr,
                 "(PFORMAT_STRING) &%s[%d]",
                 PROC_FORMAT_STRING_STRING_FIELD,
                 GetFormatStringOffset() );

        pFormatName = new char [strlen( FormatStringExpr) + 1];
        strcpy( pFormatName, FormatStringExpr );
        pCallExpr->SetParam( new expr_param(
                             new expr_variable( pFormatName ) ) );

        }
    else
        {
        pExpr = new expr_variable ( pCCB->GetInterfaceCG()->GetProxyInfoName() );
        pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
        pExpr = MakeExpressionOfCastToTypeName(PMIDL_PROXY_INFO_TYPE_NAME, pExpr);

        pCallExpr->SetParam( new expr_param( pExpr ) );

        pExpr = new expr_constant( (long) ProcNum );

        pCallExpr->SetParam ( new expr_param ( pExpr ) );

        if ( HasComplexReturnType() && !HasAsyncHandle() )
            {
            pExpr = new expr_variable( RETURN_VALUE_VAR_NAME );
            pExpr = MakeAddressExpressionNoMatterWhat( pExpr );
            }
        else
            {
            pExpr = new expr_constant( (long) 0 );
            }

        pCallExpr->SetParam ( new expr_param ( pExpr ) );
        }

    // If this is an object interface the first param is an implicit
    // this param.
    
    if( IsObject() )
        {
        pExpr = new expr_variable("This");
        if( PROC_PLATFORM_IA64 != Platform )
            {
            pExpr = new expr_u_address( pExpr );
            }
        pExpr = MakeCastExprPtrToUChar( pExpr );
        pCallExpr->SetParam( new expr_param( pExpr ) );
        }
    
    /************************************************************************
     If this is a risc platform, then
        if there are actual parameters,
            take the address of each of them
        else
            if it is not an object interface,
                push a 0
            else
                do nothing. since we have already pushed &this.
    
    else // if this is not a risc platform
        if there are actual parameters
            take address of first.
        else
            if it is non object procedure,
                push a 0,
            else
                do nothing since for an object proc we have already pushed &this.
    ************************************************************************/
    
    if ( PROC_PLATFORM_IA64 == Platform )
    {

        ITERATOR I;
        if ( GetMembers(I))
        {
            while (ITERATOR_GETNEXT(I, pParam))
            {
                // Don't include cs_tag params when there is a tag routine
                if ( GetCSTagRoutine() && pParam->IsSomeCSTag() )
                    continue;

                // Don't push the fake parameter that was added for complex
                // return types
                if ( HasComplexReturnType() && NULL == pParam->GetSibling() )
                    continue;

                pExpr = new expr_variable(
                     pParam->GetResource()->GetResourceName());
                pCallExpr->SetParam(new expr_param(pExpr));
            }
        }
        else if ( !IsObject() )
        {
            pExpr = new expr_constant( 0L );
            pCallExpr->SetParam( new expr_param( pExpr ) );
        }

    }
    else if( !IsObject() )
        {
        pParam = (CG_PARAM *) GetChild();

        // Make sure that this is not a cs_tag parameter that is being 
        // omitted because there is a tag routine, 

        if ( GetCSTagRoutine() )
            {
            while ( pParam && pParam->IsSomeCSTag() )
                pParam = (CG_PARAM *) pParam->GetSibling();
            }

        if( pParam )
            {
            pExpr = new expr_u_address (
                                new expr_variable(
                                    pParam->GetResource()->GetResourceName()));

            pExpr = MakeCastExprPtrToUChar( pExpr );
            pCallExpr->SetParam( new expr_param( pExpr ) );
            }
        else
            {
            pExpr = new expr_constant( 0L );
            pExpr = MakeCastExprPtrToUChar( pExpr );
            pCallExpr->SetParam( new expr_param( pExpr ) );
            }
        }

    // Assign the return value if one exists.

    expr_node * pFinalExpr;
    
    if ( GetReturnType() && !HasComplexReturnType() )
        {
        if ( HasAsyncHandle() )
            {
            bool fIsErrorStatus = false;
            if ( GetReturnType()->GetChild()->GetCGID() != ID_CG_CONTEXT_HDL )
                {
                fIsErrorStatus = GetReturnType()->GetChild()->GetType()->GetBasicType()->NodeKind() == NODE_E_STATUS_T;
                }
            if ( fIsErrorStatus || GetCGID() == ID_CG_OBJECT_PROC )
                {
                pFinalExpr = new expr_assign(
                                    new expr_variable( RETURN_VALUE_VAR_NAME ),
                                    pCallExpr );
                }
            else
                {
                pFinalExpr = pCallExpr;
                }
            }
        else
            {
            pFinalExpr = new expr_assign(
                                new expr_variable( RETURN_VALUE_VAR_NAME ),
                                pCallExpr );
            }
        }
    else
        pFinalExpr = pCallExpr;
    
    return pFinalExpr;
}

void CG_PROC::SetupFormatStrings( CCB * pCCB )
{
    if (!cRefSaved++)
    {
        if(!pSavedProcFormatString)
        {
            pSavedProcFormatString = pCCB->GetProcFormatString();
            pSavedFormatString = pCCB->GetFormatString();
        }
    }
}

void CG_PROC::UnsetupFormatStrings(CCB * pCCB )
{
    if (cRefSaved)
        cRefSaved--;
    if (!cRefSaved)
    {
        pCCB->SetProcFormatString(pSavedProcFormatString);
        pCCB->SetFormatString(pSavedFormatString);
    }
}


// --------------------------------------------------
// Routine used for generation of NT 3.5 and NT 3.51
// procedure format strings.
// --------------------------------------------------
void
CG_PROC::GenNdrFormatV1( CCB * pCCB )
/*++

Routine Description :

    Generates the procedure format strings usable on NT 3.5 and
    NT 3.51 systems.

Arguments :

    pCCB     - pointer to the code control block

 --*/
{
    CG_ITERATOR         Iterator;
    CG_PARAM *          pParam;
    FORMAT_STRING *     pProcFormatString;
    CG_NDR *            pOldCGNodeContext;
    short               ParamNum;


    SetupFormatStrings(pCCB);
    
    if ( GetFormatStringOffset() != -1 )
    {
        UnsetupFormatStrings(pCCB);
        return;
    }

    pCCB->SetInObjectInterface( IsObject() );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    //
    // If this procedure uses an explicit handle then set the
    // NdrBindDescriptionOffset to 0 so that it will not try to output it's
    // description when given the GenNdrParamOffLine method in the loop below.
    // It's description must be part of the procedure description.
    //
    if ( GetHandleUsage() == HU_EXPLICIT )
        {
        CG_HANDLE * pHandle = GetHandleClassPtr();

        pHandle->SetNdrBindDescriptionOffset( 0 );

        if ( pHandle->GetCGID() == ID_CG_CONTEXT_HDL )
            {
            // The context handle directs the call.
            ((CG_CONTEXT_HANDLE *)pHandle)->SetCannotBeNull();
            }
        }

    GetMembers( Iterator );

    ParamNum = 0;

    //
    // Generate the offline portion of the format string for all of the params.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        if (pParam->IsAsyncHandleParam())
            continue;

        pParam->SetParamNumber( ParamNum++ );

        pChild = (CG_NDR *) pParam->GetChild();

        pCCB->SetCurrentParam( (CG_PARAM *) pParam );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamOffline( pCCB );

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // Generate the format string for the return type if needed.
    //
    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        GetReturnType()->SetParamNumber( ParamNum );
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        pCCB->SetCurrentParam( GetReturnType() );
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamOffline( pCCB );

        pCCB->SetCurrentParam( 0 );
        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    pProcFormatString = pCCB->GetProcFormatString();

    SetFormatStringOffset( pProcFormatString->GetCurrentOffset() );

    //
    // Generate procedure description stuff for the interpreter if needed.
    //
    if ( (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER)
         ||  HasAPicklingAttribute() )
        GenNdrFormatProcInfo( pCCB );

    ITERATOR_INIT( Iterator );

    SetFormatStringParamStart( pProcFormatString->GetCurrentOffset() );

    //
    // Now generate the param info at the end of the format string.
    //
    while( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;

        if ( pParam->IsExtraStatusParam() || pParam->IsAsyncHandleParam() )
            continue;

        pChild = (CG_NDR *) pParam->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        //
        // Ouput the param directional attribute.
        //

        if ( ! pParam->IsParamOut() )
            {
            if ( pParam->GetDontCallFreeInst() )
                pProcFormatString->PushFormatChar( FC_IN_PARAM_NO_FREE_INST );
            else
                if ( pChild->IsSimpleType() ||
                     pChild->GetCGID() == ID_CG_PRIMITIVE_HDL )
                    pProcFormatString->PushFormatChar( FC_IN_PARAM_BASETYPE );
                else
                    pProcFormatString->PushFormatChar( FC_IN_PARAM );
            }
        else
            {
            if ( pParam->IsParamPartialIgnore() )
               {
               pProcFormatString->PushFormatChar( FC_PARTIAL_IGNORE_PARAM );
               }

            else 
               {
               if ( ! pParam->IsParamIn() )
                   pProcFormatString->PushFormatChar( FC_OUT_PARAM );

               if ( pParam->IsParamIn() && pParam->IsParamOut() )
                   pProcFormatString->PushFormatChar( FC_IN_OUT_PARAM );
               }
            }
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pParam );

        pChild->GenNdrParamDescriptionOld( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    if ( GetReturnType() )
        {
        CG_NDR *    pChild;
        CG_NDR *    pOldPlaceholder;
        
        pChild = (CG_NDR *) GetReturnType()->GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *) pChild->GetChild();

        if ( pChild->IsSimpleType() )
            pProcFormatString->PushFormatChar( FC_RETURN_PARAM_BASETYPE );
        else
            pProcFormatString->PushFormatChar( FC_RETURN_PARAM );

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( GetReturnType() );

        pChild->GenNdrParamDescriptionOld( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }
    else
        {
        pProcFormatString->PushFormatChar( FC_END );
        pProcFormatString->PushFormatChar( FC_PAD );
        }

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    pCCB->SetInObjectInterface( FALSE );

    SetFormatStringEndOffset( pProcFormatString->GetCurrentOffset() );

    // save delta, in case the routine is optimized
    short   usParamStartDelta   = (short) ( GetFormatStringParamStart() -
                                            GetFormatStringOffset() );

    pProcFormatString->OptimizeFragment( this );

    // Set param start!!!
    SetFormatStringParamStart( GetFormatStringOffset() + usParamStartDelta );
    UnsetupFormatStrings(pCCB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\ptrndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-2000 Microsoft Corporation

 Module Name:

    ptrndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    pointer types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

static long StringToHex( char * str );
extern CMD_ARG          *   pCommand;
#define OUT_CORRELATION_DESC( x, y )    (x)->PushCorrelationFlagsShort(y)

BOOL
CG_POINTER::IsPointerToBaseType()
{
    BOOL fIsPointerToBaseType = FALSE;
    CG_NDR * pChild;

    if(GetCGID() == ID_CG_PTR)
        {
        pChild = (CG_NDR *)GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *)pChild->GetChild();

        if ( pChild->IsSimpleType() )
            { 
            if ( pChild->GetRangeAttribute() == NULL )
                fIsPointerToBaseType = TRUE;
            else
                {
                if (!pCommand->IsNDR64Run() )
                    RpcError( NULL, 0,  POINTER_TO_RANGE, pChild->GetSymName() );
                }
            }
        }

    return fIsPointerToBaseType;
}

BOOL
CG_POINTER::IsPointerToPointer()
{
    BOOL fIsPointerToPointer = FALSE;
    CG_NDR * pChild;

    if(GetCGID() == ID_CG_PTR)
        {
        pChild = (CG_NDR *)GetChild();

        if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
            pChild = (CG_NDR *)pChild->GetChild();

        if (pChild->IsPointer())
            fIsPointerToPointer = TRUE;
        }

    return fIsPointerToPointer;
}

BOOL
CG_POINTER::IsBasicRefPointer()
{
    short   Attributes;

    if ( ( IsInterfacePointer() ) ||
         (GetCGID() == ID_CG_BC_PTR) ||
         (GetCGID() == ID_CG_STRUCT_STRING_PTR) ||
         (GetPtrType() != PTR_REF) ||
         IsPointerToBaseType() )
        return FALSE;

    if ( ((GetCGID() == ID_CG_STRING_PTR) ||
          (GetCGID() == ID_CG_SIZE_STRING_PTR)) &&
         ((CG_STRING_POINTER *)this)->IsStringableStruct() )
        return FALSE;

    Attributes = GetAllocateDetails();

    if ( IsPointerToPointer() ||
         IS_ALLOCATE(Attributes, ALLOCATE_ALL_NODES) ||
         IS_ALLOCATE(Attributes, ALLOCATE_DONT_FREE) )
        return FALSE;

    return TRUE;
}

BOOL
CG_POINTER::IsMultiSize()
/*
    Count the sized pointers below a pointer.
    At least 2 are needed to come up with TRUE.
       size_is(a) and size_is(,b) should give false
       size_is(a,b) and size_is(,a,b) should give true
*/
{
    return (SizedDimensions() > 1);
}

long
CG_POINTER::SizedDimensions()
{
    CG_NDR *    pNdr;
    long        Dim;
    bool        SeenOne = false;

    // Accept (non-sized) pointers before a sized pointer but not after.
    // Checking for pointer breaks a recursion as well.

    Dim = 0;
    pNdr = this;

    while ( pNdr  &&  pNdr->IsPointer() )
        {
        if ( (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_STRING_PTR) )
            {
            Dim++;
            SeenOne = true;
            }
        else
            {
            if ( SeenOne )
                break;
            }
        pNdr = (CG_NDR *) pNdr->GetChild();
        }

    return Dim;
}

long
CG_POINTER::FixedBufferSize( CCB * pCCB )
{
    long    BufSize;

    //
    // Must give up on string or sized pointers.
    //
    if ( GetCGID() != ID_CG_PTR )
        return -1;

    BufSize = ((CG_NDR *)GetChild())->FixedBufferSize( pCCB );

    if ( BufSize == -1 )
        return -1;

    BufSize += ( MAX_WIRE_ALIGNMENT + SIZEOF_WIRE_PTR());

    return BufSize;
}

BOOL
CG_POINTER::InterpreterAllocatesOnStack(
    CCB *       pCCB,
    CG_PARAM *  pMyParam,
    long *      pAllocationSize )
{
    CG_NDR *    pNdr;
    long        OutSize;

    if ( ! pMyParam )
        return FALSE;

    pNdr = (CG_NDR *) GetChild();

    // 
    // [cs_tag] params that are omitted because of a tag routine can't be on
    // the allocated on the stack because they don't exist!
    //
    if ( pNdr->GetCGID() == ID_CG_CS_TAG )
        {
        CG_PROC *pProc = (CG_PROC *) pCCB->GetCGNodeContext();

        if ( pProc->GetCSTagRoutine() )
            {
            *pAllocationSize = 0;
            return FALSE;
            }
        }

    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
        pNdr = (CG_NDR *) pNdr->GetChild();

    if ( pNdr->GetCGID() == ID_CG_CONTEXT_HDL )
        {
        //
        // These get the "allocated on stack" attribute but a size of 0 since
        // they are allocated by calling NDRSContextUnmarshall.
        //
        *pAllocationSize = 0;
        return TRUE;
        }

    //
    // Make sure this pointer is a top level parameter and doesn't have
    // any allocate attributes.
    //
    if ( (pMyParam->GetCGID() == ID_CG_RETURN) ||
         (pMyParam->GetChild() != this) ||
         pMyParam->IsForceAllocate()    ||
         IS_ALLOCATE( GetAllocateDetails(), ALLOCATE_ALL_NODES ) ||
         IS_ALLOCATE( GetAllocateDetails(), ALLOCATE_DONT_FREE ) )
        return FALSE;

    OutSize = pCCB->GetInterpreterOutSize();

    //
    // Watch for [out] only ref to ref pointers as they should be
    // handled by NdrOutInit in the new interpreter, not on stack.
    //

    if ( ! pMyParam->IsParamIn()  &&  IsRef()  &&
         IsPointerToPointer()  &&  ((CG_POINTER *)pNdr)->IsRef() )
        return FALSE;

    //
    // Look for pointer to pointer, [out] only pointer to base type, or
    // pointer to enum16 of any direction.
    //
    if ( IsPointerToPointer() ||
         (IsPointerToBaseType() && ! pMyParam->IsParamIn()) ||
         (IsPointerToBaseType() &&
          (((CG_BASETYPE *)pNdr)->GetFormatChar() == FC_ENUM16) &&
          pMyParam->IsParamIn()) )
        {
        if ( (OutSize + 8) <= MAX_INTERPRETER_OUT_SIZE )
            {
            *pAllocationSize = 8;
            pCCB->SetInterpreterOutSize( pCCB->GetInterpreterOutSize() + 8 );
            return TRUE;
            }
        }

    //
    // Finished with [in], [in,out] cases now.
    //
    if ( pMyParam->IsParamIn() )
        return FALSE;

    //
    // This covers [out] pointers to structs and unions.  We don't allow
    // any one parameter to eat up too much of the total stack space
    // the interpreter has set aside for this optimization.
    //
    if ( pNdr->GetMemorySize() <= MAX_INTERPRETER_PARAM_OUT_SIZE )
        {
        OutSize += (pNdr->GetMemorySize() + 7) & ~0x7;

        if ( OutSize <= MAX_INTERPRETER_OUT_SIZE )
            {
            *pAllocationSize = (pNdr->GetMemorySize() + 7) & ~0x7;
            pCCB->SetInterpreterOutSize(
                        pCCB->GetInterpreterOutSize() + *pAllocationSize );
            return TRUE;
            }
        }

    return FALSE;
}

void
CG_POINTER::GetTypeAndFlags( CCB *pCCB, NDR64_POINTER_FORMAT *format )
{
    CG_PARAM *          pParam;
    short               Attributes;

    pParam = pCCB->GetCurrentParam();

    BOOL IsNDR64 = pCommand->IsNDR64Run();

    //
    // Set the pointer type.
    //
    switch ( GetPtrType() )
        {
        case PTR_REF :
            format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_RP : FC_RP);
            break;

        case PTR_UNIQUE :
            //
            // Check if this is a unique pointer in an OLE interface, but
            // is not the top most pointer.
            //
            if ( pCCB->IsInObjectInterface() &&
                 pParam->IsParamOut() &&
                 pParam->GetChild() != this )
                {
                format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_OP : FC_OP);
                }
            else
                {
                format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_UP : FC_UP);
                }

            break;

        case PTR_FULL :
            format->FormatCode = (NDR64_FORMAT_CHAR)(IsNDR64 ? FC64_FP : FC_FP);
            break;
        }

    //
    // Now the attributes.
    //
    format->Flags = 0;

    Attributes = GetAllocateDetails();

    if ( IS_ALLOCATE(Attributes, ALLOCATE_ALL_NODES) )
        format->Flags |= FC_ALLOCATE_ALL_NODES;
    
    if ( IS_ALLOCATE(Attributes, ALLOCATE_DONT_FREE) )
        format->Flags |= FC_DONT_FREE;

    if ( GetCGID() == ID_CG_PTR )
        {
        //
        // Check if we are allocated on the stack by the stub.  Currently this
        // only works for top level pointers.
        //
        if ( ! ShouldPointerFree() &&
             ! (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER) )
            {
            format->Flags |= FC_ALLOCED_ON_STACK;
            }

        //
        // For the interpreter we set the alloced on stack attribute for
        // those [out] pointers which we will be able to "allocate" on the
        // server interpreter's stack.  We also do this for [in,out] double
        // pointers.
        // The version 1 interpreter simply looks for pointers to context
        // handles.
        //
        if ( pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER )
            {
            if ( ! (pCCB->GetOptimOption() & OPTIMIZE_INTERPRETER_V2) )
                {
                if ( ((CG_NDR *)GetChild())->GetCGID() == ID_CG_CONTEXT_HDL )
                    format->Flags |= FC_ALLOCED_ON_STACK;
                }
            else
                {
                long    OutSize;

                if ( InterpreterAllocatesOnStack( pCCB, pParam, &OutSize ) )
                    format->Flags |= FC_ALLOCED_ON_STACK;
                }
            }
        }

    //
    // Check for a pointer to simple type, non-sized string, or pointer to
    // pointer.
    //
    if ( IsPointerToBaseType() || (GetCGID() == ID_CG_STRING_PTR) )
        format->Flags |= FC_SIMPLE_POINTER;

    if ( IsPointerToPointer() )
        format->Flags |= FC_POINTER_DEREF;

    SetFormatAttr( format->Flags );
}


void
CG_POINTER::GenNdrPointerType( CCB * pCCB )
/*++

Routine Description :

    Generates the first two bytes of a pointer's format string description.

Arguments :

    pCCB        - pointer to the code control block.

Return:

    Returns FALSE if the format string for the pointer type has already been
    generated, otherwise returns TRUE.

 --*/
{
    NDR64_POINTER_FORMAT    format;

    GetTypeAndFlags( pCCB, &format );

    pCCB->GetFormatString()->PushPointerFormatChar( (unsigned char) format.FormatCode );
    pCCB->GetFormatString()->PushByte( format.Flags );
}

void
CG_POINTER::RegisterRecPointerForFixup( 
    CCB * pCCB,
    long  OffsetAt )
/*++
    Register a simple pointer for fixup.
    Don't register qualified pointers, byte pointers etc.
--*/
{
    // This routine should be called only for ID_CG_PTR pointers, but check
    // just in case.

    if ( GetCGID() == ID_CG_PTR )
        {
        pCCB->RegisterRecPointerForFixup( (CG_NDR *) GetChild(), OffsetAt );
        }
} 


void
CG_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a pointer to anything.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{

    FORMAT_STRING *     pFormatString = pCCB->GetFormatString();
    long                StartOffset   = pFormatString->GetCurrentOffset();
    
    if ( GetFormatStringOffset() != -1 )
        return;

    SetFormatStringOffset( StartOffset );
    SetFormatStringEndOffset( StartOffset + 4 );

    if ( GenNdrFormatAlways( pCCB ) == 0 )
        {
        // Don't optimize out when the pointee hasn't been generated.
        return;
        }

    // here, we assume all pointers generate 4 bytes
    pFormatString->OptimizeFragment( this );

}

long
CG_POINTER::GenNdrFormatAlways( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a pointer to anything.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    long                Offset;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    GenNdrPointerType( pCCB );

    //
    // If it's an unattributed pointer to a simple type then the format
    // string is optimized.
    //
    if ( IsPointerToBaseType() )
        {
        GenNdrFormatPointee( pCCB );

        // True simple types are represented as 1 byte (e.g. FC_LONG) and thus
        // subsequent stuff needs to be aligned.  Ranges (which are also 
        // considered simpe types) get a more standard, already aligned
        // representation

        if ( pFormatString->GetCurrentOffset() & 1 )
            pFormatString->PushFormatChar( FC_PAD );

        // return something non-zero to mark it ok for optimizing out.
        return GetFormatStringOffset();
        }

    // Get the current offset.
    Offset = pFormatString->GetCurrentOffset();

    // Push a short for the offset to be filled in later.
    pFormatString->PushShortOffset( 0 );

    // Generate the pointee's format string.
    GenNdrFormatPointee( pCCB );

    // Now fill in the offset field correctly.  
    // Register for fixup if the offset isn't known yet. Note that we cannot
    // use RegisterComplexEmbeddedForFixups because it uses a relative offset.

    if ( 0 == GetPointeeFormatStringOffset() )
        RegisterRecPointerForFixup( pCCB, GetFormatStringOffset() + 2 );
    
    pFormatString->PushShortOffset( GetPointeeFormatStringOffset() - Offset,
                                    Offset );

    return GetPointeeFormatStringOffset();
}

void
CG_POINTER::GenNdrParamOffline( CCB * pCCB )
{
    GenNdrFormat( pCCB );
}

void
CG_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for the pointee of an
    unattributed pointer to anything.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_NDR *    pChild;

    pChild = (CG_NDR *)GetChild();

    if (pChild->IsProc())
    {
        MIDL_ASSERT(0);
    } 
    else
    {
        //
        // For unattributed pointers (no size or length), this is simply a
        // call to the child's GenNdrFormat method.
        //
        pChild->GenNdrFormat( pCCB );

        SetPointeeFormatStringOffset( pChild->GetFormatStringOffset() );
    }
}

BOOL
CG_POINTER::ShouldFreeOffline()
{
    CG_NDR *    pNdr;

    //
    // The order here is very, very important.
    //

    if ( IsAllocateDontFree() )
        return FALSE;

    pNdr = (CG_NDR *) GetChild();

    //
    // Skip past generic handle nodes.
    //
    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
        pNdr = (CG_NDR *) pNdr->GetChild();

    //
    // Check for handles.
    //
    if ( (pNdr->GetCGID() == ID_CG_CONTEXT_HDL) ||
         (pNdr->GetCGID() == ID_CG_PRIMITIVE_HDL) )
        return FALSE;

    //
    // Offline full pointers.
    //
    if ( GetPtrType() == PTR_FULL )
        return TRUE;

    switch ( GetCGID() )
        {
        case ID_CG_PTR :
        case ID_CG_SIZE_PTR :
            break;

        case ID_CG_STRING_PTR :
        case ID_CG_STRUCT_STRING_PTR :
            return FALSE;

        case ID_CG_SIZE_LENGTH_PTR :
        case ID_CG_LENGTH_PTR :
        case ID_CG_SIZE_STRING_PTR :
        case ID_CG_BC_PTR :
            return TRUE;

        default :
            MIDL_ASSERT(0);
        }

    if ( pNdr->IsSimpleType() )
        return FALSE;

    if ( pNdr->IsStruct() )
        return ((CG_STRUCT *)pNdr)->ShouldFreeOffline();

    return TRUE;
}

void
CG_POINTER::GenFreeInline( CCB * pCCB )
{
    CG_PARAM *  pParam;
    CG_NDR *    pNdr;
    BOOL        fFree;

    if ( ShouldFreeOffline() || IsAllocateDontFree() )
        return;

    //
    // We use the buffer for these since they have to be [in] or [in,out].
    //
    if ( GetCGID() == ID_CG_STRING_PTR )
        return;

    fFree = FALSE;

    pParam = (CG_PARAM *) pCCB->GetLastPlaceholderClass();

    pNdr = (CG_NDR *) GetChild();

    //
    // Skip past generic handle nodes.
    //
    if ( pNdr->GetCGID() == ID_CG_GENERIC_HDL )
        pNdr = (CG_NDR *) pNdr->GetChild();

    //
    // Check for handles.
    //
    if ( (pNdr->GetCGID() == ID_CG_CONTEXT_HDL) ||
         (pNdr->GetCGID() == ID_CG_PRIMITIVE_HDL) )
        return;

    //
    // Free a pointer to simple type only if it's a pointer to enum16 or int3264.
    //
    if ( pNdr->IsSimpleType() )
        fFree = ((pNdr->GetCGID() == ID_CG_ENUM) &&  !((CG_ENUM *)pNdr)->IsEnumLong()) 
                ||pNdr->GetCGID() == ID_CG_INT3264;

    //
    // Out only pointer is freed if it wasn't allocated on the server's stack.
    // We overwrite any previous freeing descision.
    //
    if ( ! pParam->IsParamIn() )
        fFree = ShouldPointerFree();

    if ( fFree )
        {
        //
        // Always check if the pointer is not null before freeing.
        //
        Out_FreeParamInline( pCCB );
        }
}

void CG_SIZE_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for the pointee of an
    sized pointer to anything.
    Since a sized pointer is really the same as a pointer to a conformant
    array in Ndr terms, we just create a CG_CONFORMANT_ARRAY class on the
    fly and tell it to generate it's code.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_CONFORMANT_ARRAY *   pConformantArray;
    CG_QUALIFIED_POINTER *  pOldSizePtr;

    if ( GetPointeeFormatStringOffset() != -1 )
        return;

#if 0
    //
    // This fixes the case below but causes regressions in ds bvt's.  Pull it
    // for now.
    //

    if ( GetPointee() && GetPointee()->GetFormatStringOffset() != -1 )
    {
        // This happens when the sized pointer is recursively defined.
        // e.g. struct f {long s; [size_is(s)] struct f *p;};

        SetPointeeFormatStringOffset( GetPointee()->GetFormatStringOffset() );
        return;
    }
#endif

    if ( IsMultiSize() )
        {
        CG_NDR * pChild = (CG_NDR *) GetChild();

        SetIsInMultiSized( TRUE );

        if ( (pChild->GetCGID() == ID_CG_SIZE_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_STRING_PTR) )
            {
            ((CG_QUALIFIED_POINTER *)pChild)->SetIsInMultiSized( TRUE );
            ((CG_QUALIFIED_POINTER *)pChild)->SetDimension(GetDimension() + 1);
            }
        }

    pOldSizePtr = pCCB->GetCurrentSizePointer();
    pCCB->SetCurrentSizePointer( this );

    pConformantArray = new CG_CONFORMANT_ARRAY( this );

    SetPointee( pConformantArray );

    pConformantArray->SetPtrType( PTR_REF );

    pConformantArray->SetChild( GetChild() );

    pConformantArray->SetIsInMultiDim( IsInMultiSized() );

    if ( IsInMultiSized() && !pCCB->GetCGNodeContext()->IsProc() )
        {
        pConformantArray->ForceComplex();
        }

    pConformantArray->SetFormatStringOffset( -1 );

    pConformantArray->GenNdrFormat( pCCB );

    SetPointeeFormatStringOffset( pConformantArray->GetFormatStringOffset() );

    pCCB->SetCurrentSizePointer( pOldSizePtr );
}

void CG_SIZE_LENGTH_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for the pointee of a
    size-length pointer to anything.
    Since a size-length pointer is really the same as a pointer to a conformant
    varying array in Ndr terms, we just create a CG_CONFORMANT_VARYING_ARRAY
    class on the fly and tell it to generate it's code.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_CONFORMANT_VARYING_ARRAY *   pConfVaryArray;
    CG_QUALIFIED_POINTER *          pOldSizePtr;

    if ( GetPointeeFormatStringOffset() != -1 )
        return;

    if ( IsMultiSize() )
        {
        CG_NDR * pChild = (CG_NDR *) GetChild();

        SetIsInMultiSized( TRUE );

        if ( (pChild->GetCGID() == ID_CG_SIZE_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
             (pChild->GetCGID() == ID_CG_SIZE_STRING_PTR) )
            {
            ((CG_QUALIFIED_POINTER *)pChild)->SetIsInMultiSized( TRUE );
            ((CG_QUALIFIED_POINTER *)pChild)->SetDimension(GetDimension() + 1);
            }
        }

    pOldSizePtr = pCCB->GetCurrentSizePointer();
    pCCB->SetCurrentSizePointer( this );

    pConfVaryArray = new CG_CONFORMANT_VARYING_ARRAY( this );

    SetPointee( pConfVaryArray );

    pConfVaryArray->SetPtrType( PTR_REF );

    pConfVaryArray->SetChild( GetChild() );

    pConfVaryArray->SetIsInMultiDim( IsInMultiSized() );

    if ( IsInMultiSized() && !pCCB->GetCGNodeContext()->IsProc() )
        {
        pConfVaryArray->ForceComplex();
        }

    pConfVaryArray->SetFormatStringOffset( -1 );

    pConfVaryArray->GenNdrFormat( pCCB );

    SetPointeeFormatStringOffset( pConfVaryArray->GetFormatStringOffset() );

    pCCB->SetCurrentSizePointer( pOldSizePtr );
}

// --------------------------------------------------------------------------
// Strings
// --------------------------------------------------------------------------

void
CG_STRING_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString = pCCB->GetFormatString();
    long            StartOffset   = pFormatString->GetCurrentOffset();
    
    if ( GetFormatStringOffset() != -1 )
        return;

    SetFormatStringOffset( StartOffset );
    SetFormatStringEndOffset( StartOffset + 4 );

    if ( GenNdrFormatAlways( pCCB ) == 0 )
        {
        // Don't optimize out if the pointee wasn't generated yet.
        return;
        }

    // here, we assume all pointers generate 4 bytes
    pFormatString->OptimizeFragment( this );
}

long
CG_STRING_POINTER::GenNdrFormatAlways( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    GenNdrPointerType( pCCB );

    if ( IsStringableStruct() )
        {
        FORMAT_STRING * pFormatString;
        long            Offset;

        pFormatString = pCCB->GetFormatString();

        //
        // For stringable struct's we must emit the offset to the pointee
        // description.  Regular string pointers have the actual description
        // immediately following.
        //

        Offset = pFormatString->GetCurrentOffset();
        pFormatString->PushShortOffset( 0 );

        GenNdrFormatPointee( pCCB );

        pFormatString->PushShortOffset( GetPointeeFormatStringOffset() - Offset,
                                        Offset );

        return GetPointeeFormatStringOffset();
        }

    GenNdrFormatPointee( pCCB );

    pCCB->GetFormatString()->PushFormatChar( FC_PAD );

    return GetPointeeFormatStringOffset();
}

void
CG_STRING_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generate the format string of the actual string type without the
    pointer attributes.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString;

    pFormatString = pCCB->GetFormatString();

    //
    // Check for stringable struct.
    //
    if ( IsStringableStruct() )
        {
        if ( GetPointeeFormatStringOffset() != -1 )
            return;

        SetPointeeFormatStringOffset( pFormatString->GetCurrentOffset() );

        pFormatString->PushFormatChar( FC_C_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );

        return;
        }

    //
    // Always generate the format string.  The description of a non-sized
    // string pointer is not shared.
    //

    switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
        {
        case FC_CHAR :
        case FC_BYTE :
            pFormatString->PushFormatChar( FC_C_CSTRING );
            break;
        case FC_WCHAR :
            pFormatString->PushFormatChar( FC_C_WSTRING );
            break;
        default :
            MIDL_ASSERT(0);
        }
}

void
CG_SIZE_STRING_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a sized string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString = pCCB->GetFormatString();
    long            StartOffset   = pFormatString->GetCurrentOffset();
    
    if ( GetFormatStringOffset() != -1 )
        return;

    SetFormatStringOffset( StartOffset );
    SetFormatStringEndOffset( StartOffset + 4 );

    if ( GenNdrFormatAlways( pCCB ) == 0 )
        {
        // Don't optimize out if the pointee wasn't generated yet.
        return;
        }

    // here, we assume all pointers generate 4 bytes
    pFormatString->OptimizeFragment( this );
}

long
CG_SIZE_STRING_POINTER::GenNdrFormatAlways( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a sized string pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    long                Offset;

    pFormatString = pCCB->GetFormatString();

    GenNdrPointerType( pCCB );

    // Get the current offset.
    Offset = pFormatString->GetCurrentOffset();

    // Push a short for the offset to be filled in later.
    pFormatString->PushShortOffset( 0 );

    // Generate the pointee's format string.
    GenNdrFormatPointee( pCCB );

    // Now fill in the offset field correctly.
    pFormatString->PushShortOffset( GetPointeeFormatStringOffset() - Offset,
                                    Offset );

    return GetPointeeFormatStringOffset();
}

void
CG_SIZE_STRING_POINTER::GenNdrFormatPointee( CCB * pCCB )
/*++

Routine Description :

    Generate the format string of the actual string type without the
    pointer attributes.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *         pFormatString;
    CG_QUALIFIED_POINTER *  pOldSizePtr;

    if ( GetPointeeFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetPointeeFormatStringOffset( pFormatString->GetCurrentOffset() );

    pOldSizePtr = pCCB->GetCurrentSizePointer();
    pCCB->SetCurrentSizePointer( this );

    //
    // Check for stringable struct.
    //
    if ( IsStringableStruct() )
        {
        pFormatString->PushFormatChar( FC_C_SSTRING );
        pFormatString->PushByte( ((CG_NDR *)GetChild())->GetWireSize() );
        pFormatString->PushFormatChar( FC_STRING_SIZED );
        pFormatString->PushFormatChar( FC_PAD );

        GenFormatStringConformanceDescription( pCCB, TRUE, IsInMultiSized() );

        pCCB->SetCurrentSizePointer( pOldSizePtr );
        return;
        }

    switch ( ((CG_BASETYPE *)GetChild())->GetFormatChar() )
        {
        case FC_CHAR :
        case FC_BYTE :
            pFormatString->PushFormatChar( FC_C_CSTRING );
            break;
        case FC_WCHAR :
            pFormatString->PushFormatChar( FC_C_WSTRING );
            break;
        default :
            MIDL_ASSERT(0);
        }

    pFormatString->PushFormatChar( FC_STRING_SIZED );

    //
    // Set the IsPointer parameter to TRUE.
    //
    GenFormatStringConformanceDescription( pCCB, TRUE, IsInMultiSized() );

    pCCB->SetCurrentSizePointer( pOldSizePtr );
}

void
CG_BYTE_COUNT_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a byte count pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_ITERATOR         Iterator;
    FORMAT_STRING *     pFormatString;
    CG_PROC *           pProc;
    CG_PARAM *          pParam;
    CG_NDR *            pChild;
    unsigned short      uConfFlags = 0;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    if ( ! pChild->IsSimpleType() || pChild->GetRangeAttribute() )
        pChild->GenNdrFormat( pCCB );

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pFormatString->PushFormatChar( FC_BYTE_COUNT_POINTER );

    if ( pChild->IsSimpleType() && !pChild->GetRangeAttribute() )
        pChild->GenNdrFormat( pCCB );
    else
        pFormatString->PushFormatChar( FC_PAD );

    pProc = (CG_PROC *) pCCB->GetCGNodeContext();

    pProc->GetMembers( Iterator );

    bool      fThisIsFirst = false;

    while ( ITERATOR_GETNEXT( Iterator, pParam ) )
        {
        if ( GetByteCountParam() == pParam->GetType() )
            {
            break;
            }
        if ( pParam->GetChild() == this )
            {
            fThisIsFirst = true;
            }
        }

    uConfFlags |= fThisIsFirst ? 0 : FC_EARLY_CORRELATION;

    MIDL_ASSERT( ((CG_NDR *)pParam->GetChild())->IsSimpleType() );

    CG_BASETYPE *   pCount = (CG_BASETYPE *) pParam->GetChild();
    unsigned char   Type;

    Type = (unsigned char) pCount->GetFormatChar();
    Type |= FC_TOP_LEVEL_CONFORMANCE;

    // Byte count description, just do it here.
    pFormatString->PushByte( Type );
    pFormatString->PushByte( 0 );
    pFormatString->PushShortStackOffset(
                        pParam->GetStackOffset( pCCB, I386_STACK_SIZING ) );

    if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) ) 
        {
        OUT_CORRELATION_DESC( pFormatString, uConfFlags );
        }
    if ( !pChild->IsSimpleType() || pChild->GetRangeAttribute() )
        {
        pFormatString->PushShortOffset( pChild->GetFormatStringOffset() -
                                          pFormatString->GetCurrentOffset() );
        }
}

void
CG_INTERFACE_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for an interface pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // There are two cases, the constant UUID and the [iid_is] expression.
    //
    // In the normal case, we will get the 16 byte UUID from the [uuid]
    // attribute on the interface node.  The 16 byte UUID is written to the
    // format string.  Note that the UUID in the format string is not aligned
    // in memory.  The UUID must be copied to a local structure before being
    // used.
    //

    // Get the interface node.
    pFormatString->PushFormatChar( FC_IP );

    //
    // Else handle a constant iid interface pointer.
    //

    MIDL_ASSERT( GetTheInterface()->NodeKind() == NODE_INTERFACE );

    pFormatString->PushFormatChar( FC_CONSTANT_IID );

    GenNdrFormatForGuid( pCCB );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );

}

void
CG_INTERFACE_POINTER::GenNdrFormatForGuid( CCB * pCCB )
{
    node_interface  *pInterface    = GetTheInterface();
    FORMAT_STRING   *pFormatString = pCCB->GetFormatString();
    node_guid       *pGuid;
    char            *p1, *p2, *p3, *p4, *p5;

    // Get the [uuid] from the interface node.
    pGuid = (node_guid *)pInterface->GetAttribute( ATTR_GUID );

    MIDL_ASSERT( pGuid && "No UUID for interface pointer" );

    pGuid->GetStrs( &p1, &p2, &p3, &p4, &p5 );

    pFormatString->PushLong( StringToHex( p1 ) );
    pFormatString->PushShort( StringToHex( p2 ) );
    pFormatString->PushShort( StringToHex( p3 ) );

    char    Buffer[20];
    char    String[4];
    int     i;

    strcpy( Buffer, p4 );
    strcat( Buffer, p5 );

    for ( i = 0; i < 16; i += 2 )
        {
        String[0] = Buffer[i];
        String[1] = Buffer[i+1];
        String[2] = '\0';

        pFormatString->PushByte( StringToHex( String ) );
        }
}

long
CG_INTERFACE_POINTER::GenNdrFormatAlways( CCB * pCCB )
{
    long    OldOffset;

    OldOffset = GetFormatStringOffset();

    SetFormatStringOffset( -1 );

    GenNdrFormat( pCCB );

    SetFormatStringOffset( OldOffset );

    // The Always methods return the offset to pointee to watch for 0.
    // This does not apply to intf pointer, so just return the current offset.
    //
    return GetFormatStringOffset();
}

void
CG_IIDIS_INTERFACE_POINTER::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for an interface pointer.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    //
    // There are two cases, the constant UUID and the [iid_is] expression.
    //
    // In the normal case, we will get the 16 byte UUID from the [uuid]
    // attribute on the interface node.  The 16 byte UUID is written to the
    // format string.  Note that the UUID in the format string is not aligned
    // in memory.  The UUID must be copied to a local structure before being
    // used.
    //

    // Get the interface node.
    pFormatString->PushFormatChar( FC_IP );

    MIDL_ASSERT( GetIIDExpr() );

        //
        // Interface pointer has [iid_is] applied to it.
        //
        pFormatString->PushFormatChar( FC_PAD );
        
        GenNdrFormatAttributeDescription( pCCB,
                                          0,
                                          GetIIDExpr(),
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          pCommand->IsSwitchDefined( SWITCH_ROBUST ),
                                          FC_IID_CORRELATION
                                          );
        return;

}

long
CG_IIDIS_INTERFACE_POINTER::GenNdrFormatAlways( CCB * pCCB )
{
    long    OldOffset;

    OldOffset = GetFormatStringOffset();

    SetFormatStringOffset( -1 );

    GenNdrFormat( pCCB );

    SetFormatStringOffset( OldOffset );

    // The Always methods return the offset to pointee to watch for 0.
    // This does not apply to intf pointer, so just return the current offset.
    //
    return GetFormatStringOffset();
}

static long
StringToHex( char * str )
{
    long    l;

    l = 0;

    for ( ; *str ; str++ )
        {
        l *= 16;

        if ( ('0' <= *str) && (*str <= '9') )
            {
            l += *str - '0';
            continue;
            }

        if ( ('a' <= *str) && (*str <= 'f') )
            {
            l += 10 + *str - 'a';
            continue;
            }

        if ( ('A' <= *str) && (*str <= 'F') )
            {
            l += 10 + *str - 'A';
            continue;
            }

        MIDL_ASSERT(0);
        }

    return l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\pungent.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

	pungent.cxx

 Abstract:

	Implementations of the pointer cg class unmarshalling methods.

 Notes:

	The pointer unmarshalling is a bit tricky, so put into another file.

 History:

 	Dec-10-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

//
// This method is also supposed to init any embedded pointers.
//

CG_STATUS
CG_POINTER::GenAllocateForUnMarshall(
	CCB		*	pCCB )
	{

	if( IsRef() )
		{
		Out_If_IfAllocRef(pCCB,
			 	   		pCCB->GetDestExpression(),
			 	   		pCCB->GetSourceExpression(),
		     	   //		FinalSizeExpression( pCCB )
		     	   		new expr_constant( 4L )
		   		  		);
		}
	else
		{
		Out_If_IfAlloc(pCCB,
			 	   		pCCB->GetDestExpression(),
			 	   		pCCB->GetSourceExpression(),
		     	   //		FinalSizeExpression( pCCB )
		     	   		new expr_constant( 4L )
		   		  		);
		}
	
	Out_Assign( pCCB,
				MakeDereferentExpressionIfNecessary(pCCB->GetDestExpression()),
				new expr_constant( 0L ) );

	Out_Endif( pCCB );
	return CG_OK;
	}

void
CG_POINTER::PointerChecks(
	CCB		*	pCCB )
	{
	short	CILevel = pCCB->GetCurrentIndirectionLevel();
	short	CELevel	= pCCB->GetCurrentEmbeddingLevel();
	BOOL	fClientSideTopLevelPtr = FALSE;

	if( !IsRef() )
		{
		if( (pCCB->GetCodeGenSide() == CGSIDE_CLIENT ) && (CILevel == 0) &&
			!pCCB->IsReturnContext()
		  )
		  fClientSideTopLevelPtr = TRUE;

		if( fClientSideTopLevelPtr )
			{
			Out_Comment( pCCB, "(Check TopLevelPtrInBufferOnly )" );
			Out_TLUPDecisionBufferOnly( pCCB,
										pCCB->GetPtrToPtrInBuffer(),
										MakeAddressOfPointer( pCCB->GetDestExpression() ) );
			}
		else if( CELevel == 0 )
			{
			Out_Comment( pCCB, "if( CheckTopLevelPtrInBufferAndMem )" );
			Out_TLUPDecision( pCCB,
							  pCCB->GetPtrToPtrInBuffer(),
							  MakeAddressOfPointer(pCCB->GetDestExpression()));
			}
		else
			{
			Out_UPDecision( pCCB,
							  pCCB->GetPtrToPtrInBuffer(),
							  MakeAddressOfPointer(pCCB->GetDestExpression()));
			}
		}
	}

void
CG_POINTER::EndPointerChecks(
	CCB		*	pCCB )
	{

	// If it is a ref pointer, no checks were made in the first place.

	if( !IsRef() )
		Out_Endif( pCCB );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\resdict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	resdict.cxx

 Abstract:

	resource dictionary class implementations, if needed.

 Notes:


 History:

 	VibhasC		Aug-08-1993		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

short
RESOURCE_DICT::GetListOfResources(
	ITERATOR&	ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get a list of resources into the specified iterator.

 Arguments:
	
	ListIter	- A reference to the iterator class where the list is
				  accumulated.

 Return Value:
	
	A count of the number of resources.

 Notes:

----------------------------------------------------------------------------*/
{
	RESOURCE	*	pR;
	Dict_Status		Status;
	short			Count	= 0;
	
	//
	// Get to the top of the dictionary.
	//

	Status = Dict_Next( (pUserType) 0 );

	//
	// Iterate till the entire dictionary is done.
	//

	while( SUCCESS == Status )
		{
		pR	= (RESOURCE *)Dict_Curr_Item();
		ITERATOR_INSERT( ListIter, pR );
		Count++;
		Status = Dict_Next( pR );
		}

	return Count;
}

void
RESOURCE_DICT::Clear()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Clear the dictionary of all resources allocated.

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{

	Dict_Status		Status;
	RESOURCE	*	pResource;

	//
	// The way to delete all elements is to get to the top and then
	// do a get next, delete each one.
	//

	//
	// Note: Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	while( SUCCESS == Status )
		{
		pResource = (RESOURCE *)Dict_Curr_Item();
		Status = Dict_Delete( (pUserType *) &pResource );
		delete pResource;
		}

}

RESOURCE *
RESOURCE_DICT::Insert(
	PNAME			pResourceName,
	node_skl	*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Insert a resource in the dictionary.

 Arguments:
	
	pName	- Name of the resource being inserted.

 Return Value:
	
 	The resource which was created and inserted.

 Notes:

	Search for the resource, if it already exists, dont insert. This
	may really be an overkill for the code generator, since the code
	generator usually knows when to insert a resource. If necessary
	we can remove this.
	
----------------------------------------------------------------------------*/
{

	RESOURCE	*	pResource;
	RESOURCE		DummyResource( pResourceName, (node_skl *)0 );
	Dict_Status		Status	= Dict_Find( &DummyResource );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			pResource = new RESOURCE( pResourceName, pType );
			Dict_Insert( (pUserType) pResource );
			return pResource;
		default:
			return (RESOURCE *)Dict_Curr_Item();
		}
}

RESOURCE *
RESOURCE_DICT::Search(
	PNAME				pResourceName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a resource in the dictionary.

 Arguments:
	
	pResourceName	- Name of the resource being searched for.

 Return Value:
	
	A		pointer to the resource expression if found.
	NULL	otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
	//
	// In order to search, we must create a dummy resource to compare
	// against.
	//
	RESOURCE	DummyResource( pResourceName, (node_skl *)0 );
	Dict_Status		Status;

	//
	// Search.
	//

	Status	= Dict_Find( &DummyResource );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (RESOURCE *)0;
		default:
			return (RESOURCE *)Dict_Curr_Item();
		}
}

SSIZE_T
RESOURCE_DICT::Compare(
	 void * p1,
	 void * p2 )
	{
	RESOURCE 	*	pRes1	= (RESOURCE *)p1;
	RESOURCE	*	pRes2 	= (RESOURCE *)p2;

	p1 = pRes1->GetResourceName();
	p2 = pRes2->GetResourceName();

	return strcmp((const char *)p1, (const char *)p2);
	}

void
PrintResourceKey( void * p )
	{
	((void)(p));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\sdesc.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	sdesc.cxx

 Abstract:

	stub descriptor manager implementation.

 Notes:


 History:

 	Nov-02-1993		VibhasC		Created

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

SDESC *
SDESCMGR::Register(
	PNAME		AllocRtnName,
	PNAME		FreeRtnName,
	PNAME		RundownRtnName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	The constructor.

 Arguments:
	
	AllocRtnName	- The allocator rtn name.
	FreeRtnName		- Free rtn name
	InterfaceName	- interface name without any mangling.
	RundownRtnName	- The context handle rundown in case necessary.

 Return Value:
	
	NA

 Notes:

	Make an entry into the dictionary if it does not exist.
----------------------------------------------------------------------------*/
{
	SDESC		NewDesc;
	SDESC	*	pNewDesc;
	Dict_Status	Status;

	NewDesc.AllocRtnName	= AllocRtnName;
	NewDesc.FreeRtnName		= FreeRtnName;
	NewDesc.RundownRtnName	= RundownRtnName;

	Status	= Dict_Find( &NewDesc );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			pNewDesc	= new SDESC;
			pNewDesc->AllocRtnName		= AllocRtnName;
			pNewDesc->FreeRtnName		= FreeRtnName;
			pNewDesc->RundownRtnName	= RundownRtnName;
			pNewDesc->ResetEmitted();

			Dict_Insert( (pUserType)pNewDesc );
			return pNewDesc;

		default:
			return (SDESC *)Dict_Curr_Item();

		}
}

SSIZE_T
SDESCMGR::Compare(
	pUserType	pFirst,
	pUserType	pSecond )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Compare stub descriptors.

 Arguments:

 	pFirst	- A pointer to the first stub descriptor.
 	pSecond	- A pointer to the second stub descriptor.
	
 Return Value:
	
 Notes:

	WE MAKE AN ASSUMPTION THAT THE ALLOC AND FREE AND RUNDOWN ROUTINE NAMES
	WILL NEVER BE NULL POINTERS. IF NOTHING, THEY MUST POINT TO NULL STRINGS
----------------------------------------------------------------------------*/
{
	SDESC	*	p1	= (SDESC *)pFirst;
	SDESC	*	p2	= (SDESC *)pSecond;
	int			Result;

	if( (Result = strcmp( (const char *)p1->AllocRtnName,
						 (const char *)p2->AllocRtnName ) ) == 0 )
		{
		if( (Result = strcmp( (const char *)p1->FreeRtnName,
						 	  (const char *)p2->FreeRtnName ) ) == 0 )
			{
			Result = strcmp( (const char *)p1->RundownRtnName,
						 	 (const char *)p2->RundownRtnName ); 
			}
		}

	return Result;
}
void
PrintSDesc( void * ) { }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\stcls.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    stcls.cxx

 Abstract:

    Implementation of offline methods for the structure code generation
    classes.

 Notes:

 History:

    Oct-1993	DKays		Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

CG_ARRAY *
CG_CONFORMANT_STRUCT::GetConformantArray()
/*++

Routine Description :

	Gets the conformant (varying/string) class pointer for a conformant
	structure.

Arguments :

	None.

 --*/
{
	CG_NDR *	pConf;
	
	if ( ! pConfFld )
		return 0;

	pConf = (CG_NDR *) pConfFld->GetChild();

	for (;;) 
		{
		if ( pConf->GetCGID() == ID_CG_CONF_ARRAY ||
			 pConf->GetCGID() == ID_CG_CONF_VAR_ARRAY ||
			 pConf->GetCGID() == ID_CG_CONF_STRING_ARRAY )
			break;

        if ( pConf->IsXmitRepOrUserMarshal() )
            {
            pConf = (CG_NDR *)pConf->GetChild();
            continue;
            }

		// else
		pConf = (CG_NDR *) 
				((CG_CONFORMANT_STRUCT *)pConf)->GetConformantField();
		pConf = (CG_NDR *) pConf->GetChild();
		}

	return (CG_ARRAY *) pConf;
}

BOOL
CG_COMPLEX_STRUCT::WarnAboutEmbeddedComplexStruct()
/*
    The only reason we have this method is to help with an engine bug.
    The bug is that for complex structs (FC_BOGUS_STRUCT code) that have an
    embedded conformant struct, the engine marshals incorrect wire format.

    Hence this method checks if the complex struct has an open array at the end,
    and if so, checks if the last member is another type of struct.
*/
{
    BOOL    HasIt = FALSE;
    
    if ( GetConformantArray() )
        {
        //
        // Get the last field.
        //
    	CG_ITERATOR	Iterator;
    	CG_FIELD *	pField;
        CG_NDR *    pNdr;

    	GetMembers( Iterator );

        while ( ITERATOR_GETNEXT( Iterator, pField ) )
        	;
        
        pNdr = (CG_NDR *) pField->GetChild();
        
        if ( pNdr->IsStruct() )
            {
            HasIt = TRUE;

            char * pSymName, * pEmbeddedName, * pNameContext;

            pSymName      = GetSymName()       ? GetSymName()       : "?";
            pEmbeddedName = pNdr->GetSymName() ? pNdr->GetSymName() : "?";

            size_t len = strlen( pSymName ) + strlen( pEmbeddedName ) + 20;

            pNameContext = new char[ len ];
            strcpy( pNameContext, pSymName );
            strcat( pNameContext, " embedding " );
            strcat( pNameContext, pEmbeddedName );

            if ( !pCommand->Is64BitEnv() )
                RpcError(NULL, 0, EMBEDDED_OPEN_STRUCT, pNameContext );
            }
        }

    return HasIt;
}

CG_FIELD *
CG_STRUCT::GetFinalField()
{
	CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
    CG_NDR *    pNdr;

	GetMembers( Iterator );

	//
	// Get the last field.
	//
	while ( ITERATOR_GETNEXT( Iterator, pField ) )
		;

    pNdr = (CG_NDR *) pField->GetChild();

    if ( pNdr->IsStruct() )
        pField = ((CG_STRUCT *)pNdr)->GetFinalField();

    return pField;
}

CG_FIELD *
CG_STRUCT::GetArrayField( CG_ARRAY * pArray )
{
      CG_ITERATOR        Iterator;
      CG_FIELD *      pField;
    CG_NDR *    pNdr;

      GetMembers( Iterator );

      while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr == pArray )
            return pField;

        //
        // Search inside of other structs only.
        //
        if ( pNdr->IsStruct() )
            {
            if ( (pField = ((CG_STRUCT *)pNdr)->GetArrayField(pArray)) != 0 )
                return pField;
            }
        }

    // Didn't find it.
    return 0;
}

BOOL
CG_STRUCT::IsHardStruct()
{
    // REVIEW: The previous comment implied that we we're going to do something
    //         else "after the PPC update".  Is this still relevant?
    //         -- MikeW 16-Jul-99

    return FALSE;
}

BOOL
CG_STRUCT::IsHardStructOld()
{
	CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
	CG_FIELD *	pPrevField;

    //
    // Cannot have a conformant array of any kind.
    //
    if ( (GetCGID() == ID_CG_CONF_STRUCT) ||
         (GetCGID() == ID_CG_CONF_VAR_STRUCT) )
        return FALSE;

    // 
    // Cannot have pointers.
    //
    if ( HasPointer() ) 
        return FALSE;

    //
    // Can't have more than one enum16.
    //
    if ( GetNumberOfEnum16s() > 1 )
        return FALSE;

    //
    // Can't have padding in the middle of the struct that differs in 
    // memory and on the wire.
    //
	GetMembers( Iterator );

    pPrevField = 0;

	//
	// Get the last field.
	//
	while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        if ( pField->GetSibling() )
		    pPrevField = pField;
        }

    //
    // Check if the last field in the struct has a different memory and wire
    // offset.  However, if there is a single union as the last field then 
    // we have to check the second to last fields's mem and wire offsets 
    // instead since a union's field's wire offsets are not accurate.
    //
    if ( pField->GetChild()->IsUnion() && pPrevField )
        pField = pPrevField;

    // This is complex.
	if ( pField->GetMemOffset() != pField->GetWireOffset() )
        return FALSE;

    //
    // Can have at most one union as the last field only.
    //
    switch ( GetNumberOfUnions() ) 
        {
        case 0 :
            break;
        case 1 : 
            //
            // The last field must be the union.
            //
            if ( ! GetFinalField()->GetChild()->IsUnion() )
                return FALSE;
            else
                return TRUE;
            break;
        default :
            return FALSE;
        }

    //
    // Now check again if we have just one enum16.
    //
    if ( GetNumberOfEnum16s() == 1 )
        return TRUE;

    // 
    // Check for end padding, which is ok for a hard struct.
    //
    if ( GetMemorySize() > GetWireSize() )
        return TRUE;

    //
    // It must be a nice struct.
    //
    return FALSE;
}

BOOL
CG_STRUCT::HasAFixedBufferSize()
{
    CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
	
	GetMembers( Iterator );
    
    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        if ( !pField->HasAFixedBufferSize() )
		    return FALSE;
        }
    return TRUE;
}

BOOL
CG_STRUCT::IsComplexStruct()
{
    CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
    CG_NDR *    pNdr;
    BOOL        IsConformant;

    IsConformant = (GetCGID() == ID_CG_CONF_STRUCT) ||
                   (GetCGID() == ID_CG_CONF_VAR_STRUCT);

    switch ( GetNumberOfEnum16s() ) 
        {
        case 0 :
            break;
        case 1 : 
            if ( HasPointer() || IsConformant ) 
                return TRUE;
            break;
        default :
            return TRUE;
        }

    switch ( GetNumberOfUnions() ) 
        {
        case 0 : 
            break;
        case 1 : 
            if ( ! GetFinalField()->GetChild()->IsUnion() || 
                 HasPointer() ||
                 IsConformant )
                return TRUE;
            break;
        default :
            return TRUE;
        }

    if ( (GetMemorySize() > GetWireSize()) && (HasPointer() || IsConformant) )
        return TRUE;

    GetMembers( Iterator );

    //
    // Check if there are any embedded structs or arrays which are 
    // complex.
    // On 64b platforms any pointer makes it complex as well.
    //
	while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr->IsArray() && ((CG_ARRAY *)pNdr)->IsComplex() ) 
            return TRUE;
            
        if ( pNdr->IsStruct() && ((CG_STRUCT *)pNdr)->IsComplexStruct() ) 
            return TRUE;

        // struct fields with [range] on them make the struct complex.
        if ( pNdr->GetRangeAttribute() )
            return TRUE;

        //if ( pNdr->IsPointer()  &&  pCommand->Is64BitEnv() )
        //    return TRUE;

        if ( ( pField->GetWireOffset() != pField->GetMemOffset() ) ||
             ( pField->GetWireSize() != pField->GetMemorySize() ) )
            return TRUE;

        }

    return IsHardStructOld();
}

bool
CG_STRUCT::IsHomogeneous(FORMAT_CHARACTER format)
{
    CG_ITERATOR Iterator;
    CG_FIELD   *pField;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ))
        {
        CG_NDR *pChild = (CG_NDR *) pField->GetChild();

        if ( !pChild->IsHomogeneous( format ) )
            return false;
        }

    return true;
}

long
CG_STRUCT::GetNumberOfPointers()
{
    CG_ITERATOR		Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;
	long			Count;

	Count = 0;

	GetMembers(Iterator);

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
    	{
        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() && 
             !pMember->IsInterfacePointer() )
            Count++;

		if ( pMember->IsStruct() )
			Count += ((CG_STRUCT *)pMember)->GetNumberOfPointers();
		}

	return Count;
}

long
CG_STRUCT::GetNumberOfEnum16s()
{
    CG_ITERATOR		Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pNdr;
	long			Count;
    long            Weight;

	Count = 0;

	GetMembers(Iterator);

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
    	{
        pNdr = (CG_NDR *) pField->GetChild();

        //
        // If an array contains a enum16 we count it as 100 enum16s, since
        // this routine is only interested in small enum16 counts.
        //
        if ( pNdr->IsArray() )
            {
            pNdr = (CG_NDR *) pNdr->GetChild();

            while ( pNdr->IsArray() )
                pNdr = (CG_NDR *) pNdr->GetChild();

            Weight = 100;
            }
        else
            Weight = 1;

        if ( pNdr->IsSimpleType() && 
             (((CG_BASETYPE *)pNdr)->GetFormatChar() == FC_ENUM16) )
            Count += Weight;

		if ( pNdr->IsStruct() )
			Count += Weight * ((CG_STRUCT *)pNdr)->GetNumberOfEnum16s();
		}

	return Count;
}

long
CG_STRUCT::GetNumberOfUnions()
{
    CG_ITERATOR		Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pNdr;
	long			Count;
    long            Weight;

	Count = 0;

	GetMembers(Iterator);

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
    	{
        pNdr = (CG_NDR *) pField->GetChild();

        //
        // If an array contains a union we count it as 100 unions, since
        // this routine is only interested in small union counts.
        //
        if ( pNdr->IsArray() )
            {
            pNdr = (CG_NDR *) pNdr->GetChild();

            while ( pNdr->IsArray() )
                pNdr = (CG_NDR *) pNdr->GetChild();

            Weight = 100;
            }
        else
            Weight = 1;

        if ( (pNdr->GetCGID() == ID_CG_UNION) ||
             (pNdr->GetCGID() == ID_CG_ENCAP_STRUCT) ) 
            Count += Weight;

		if ( pNdr->IsStruct() )
			Count += Weight * ((CG_STRUCT *)pNdr)->GetNumberOfUnions();
		}

	return Count;
}

long
CG_STRUCT::GetEnum16Offset()
{
    CG_ITERATOR	Iterator;
    CG_FIELD *  pField;
    CG_NDR *    pNdr;

    MIDL_ASSERT( GetNumberOfEnum16s() == 1 );

    GetMembers( Iterator );

    //
    // Search for the enum.  
    //
    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr->IsSimpleType() && 
             (((CG_BASETYPE *)pNdr)->GetFormatChar() == FC_ENUM16) )
            return pField->GetMemOffset();

        if ( pNdr->IsStruct() && 
             (((CG_STRUCT *)pNdr)->GetNumberOfEnum16s() == 1) )
            return pField->GetMemOffset() + 
                   ((CG_STRUCT *)pNdr)->GetEnum16Offset();
        }

    // Never get here.
    return 0;
}

void
CloneForUnrolling(
    CG_NDR * pParent,
    CG_NDR * pNdr )
/*
    This routine will clone pNdr and overwrite the original child at
    the parent if needed.
    It is assumed the parent has been cloned, too.
*/
{
    CG_POINTER *    pNewPointer;

    pNewPointer = 0;

    if ( pNdr->IsPointer() )
        {
        switch ( pNdr->GetCGID() ) 
            {
            case ID_CG_PTR :
                pNewPointer = new CG_POINTER( 
                                   (CG_POINTER *) pNdr );
                break;
            case ID_CG_BC_PTR :
                pNewPointer = new CG_BYTE_COUNT_POINTER( 
                                   (CG_BYTE_COUNT_POINTER *) pNdr );
                break;
            case ID_CG_STRING_PTR :
            case ID_CG_STRUCT_STRING_PTR :
                pNewPointer = new CG_STRING_POINTER( 
                                   (CG_STRING_POINTER *) pNdr );
                break;
            case ID_CG_SIZE_PTR :
                pNewPointer = new CG_SIZE_POINTER( 
                                   (CG_SIZE_POINTER *) pNdr );
                break;
            case ID_CG_LENGTH_PTR :
                pNewPointer = new CG_LENGTH_POINTER( 
                                (CG_LENGTH_POINTER *) pNdr );
                break;
            case ID_CG_SIZE_LENGTH_PTR :
                pNewPointer = new CG_SIZE_LENGTH_POINTER( 
                                (CG_SIZE_LENGTH_POINTER *) pNdr );
                break;
            case ID_CG_SIZE_STRING_PTR :
                pNewPointer = new CG_SIZE_STRING_POINTER( 
                                (CG_SIZE_STRING_POINTER *) pNdr );
                break;
            case ID_CG_INTERFACE_PTR :
                pNewPointer = new CG_INTERFACE_POINTER( 
                                   (CG_INTERFACE_POINTER *) pNdr );
                break;
            case ID_CG_IIDIS_INTERFACE_PTR :
                pNewPointer = new CG_IIDIS_INTERFACE_POINTER( 
                                   (CG_IIDIS_INTERFACE_POINTER *) pNdr );
                break;
            default :
                break;
            }

        if ( pNewPointer )
            {
            //
            // We have to re-set the new pointer's format string offset and 
            // pointee format string offset to -1 so that we get a new 
            // description!!!
            //
    
            if ( pNewPointer )
    
            pNewPointer->SetFormatStringOffset( -1 );
            pNewPointer->SetPointeeFormatStringOffset( -1 );
        
            pParent->SetChild( pNewPointer );
    
            if ( pNdr->GetChild() )
                CloneForUnrolling( pNewPointer, (CG_NDR*) pNdr->GetChild() );
            }
        }
}


void
CG_STRUCT::Unroll()
{
	ITERATOR		Iterator;
	CG_FIELD *		pPrevField;
	CG_FIELD *		pField;
	CG_NDR *		pNdr;
	CG_STRUCT *		pStruct;
	
	GetMembers( Iterator );

	pPrevField = 0;

	while ( ITERATOR_GETNEXT(Iterator,pField) )
		{
		pNdr = (CG_NDR *) pField->GetChild();

		if ( pNdr->IsStruct() && ((CG_STRUCT *)pNdr)->HasSizedPointer() )
			pStruct = (CG_STRUCT *) pNdr;
		else
			{
			pPrevField = pField;
			continue;
			}

		//
		// First force the embeded struct to unroll if needed.
		//
		pStruct->Unroll();

		ITERATOR	IteratorEmbeded;
		CG_FIELD *	pFieldNew;
		CG_FIELD *	pFieldEmbeded;
		CG_FIELD *	pFieldList;
		long		MemOffsetStart;
		long		WireOffsetStart;

		pStruct->GetMembers( IteratorEmbeded );

		MemOffsetStart = pField->GetMemOffset();
		WireOffsetStart = pField->GetWireOffset();

		// Get previous field node.
		pFieldList = pPrevField;

		// Remove current struct field node from the list.
		if ( pFieldList ) 
			pFieldList->SetSibling( pField->GetSibling() );
		else
			this->SetChild( pField->GetSibling() );

		// To be safe.
		pField->SetSibling( 0 );

        while ( ITERATOR_GETNEXT(IteratorEmbeded,pFieldEmbeded) )
            {
            pFieldNew = (CG_FIELD *) pFieldEmbeded->Clone();

            pNdr = (CG_NDR *) pFieldEmbeded->GetChild();

            CloneForUnrolling( pFieldNew, pNdr );

            //
            // Set the new field's memory and wire offset.
            //
            pFieldNew->SetMemOffset( pFieldEmbeded->GetMemOffset() + 
                                       MemOffsetStart );
            pFieldNew->SetWireOffset( pFieldEmbeded->GetWireOffset() + 
                                        WireOffsetStart );

            //    
            // Now add the imbeded struct's field name to the PrintPrefix of 
            // the new unrolled field.  We ask the imbeded struct's field 
            // for it's name.
            //
            pFieldNew->AddPrintPrefix( pField->GetType()->GetSymName() );

            if ( pFieldList )
                {
                pFieldNew->SetSibling( pFieldList->GetSibling() );
                pFieldList->SetSibling( pFieldNew );
                }
            else
                {
                pFieldNew->SetSibling( this->GetChild() );
                this->SetChild( pFieldNew );
                }

            pFieldList = pFieldNew;
            }

		//
		// Set pPrevField equal to the last field node that we entered into
		// the list.  The outermost Iterator only knows about fields that 
		// started in the struct's field list, so the last field node we
		// added will have a sibling equal to the next field node we'll get
		// from the outer iterator.
		//
		pPrevField = pFieldNew;
		}
}

BOOL
CG_STRUCT::HasSizedPointer()
{
	CG_ITERATOR	Iterator;
	CG_FIELD *	pField;
	CG_NDR *	pNdr;
	
	GetMembers( Iterator );

	while ( ITERATOR_GETNEXT(Iterator,pField) )
		{
		pNdr = (CG_NDR *) pField->GetChild();

        if ( pNdr->IsStruct() && ((CG_STRUCT *)pNdr)->HasSizedPointer() )
            return TRUE;

		if ( (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
			 (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) ||
			 (pNdr->GetCGID() == ID_CG_SIZE_STRING_PTR) )
			return TRUE;
		}

	return FALSE;
}

BOOL                    
CG_ENCAPSULATED_STRUCT::ShouldFreeOffline()
{
    CG_UNION * pUnion;

    pUnion = (CG_UNION *) GetChild()->GetSibling()->GetChild();

    return pUnion->HasPointer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\stgen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	stgen.cxx

 Abstract:

	structure marshalling / unmarshalling stuff.

 Notes:


 History:

 	Dec-15-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

CG_STATUS
CG_COMP::S_GenInitOutLocals(
	CCB		*	pCCB )
	{

	char Buffer[ 256 ];
	RESOURCE * pResource;
	PNAME		p;
	CG_NDR	*	pLPC = pCCB->GetLastPlaceholderClass();

	strcpy( Buffer,  pLPC->GetType()->GetSymName() );

	p = pCCB->GenTRNameOffLastParam( Buffer );

	pResource = pCCB->GetLocalResource( p );

	// There is a pointer for the top level structure.

	Out_Assign( pCCB,
				pCCB->GetSourceExpression(),
				MakeAddressExpressionNoMatterWhat( pResource )
			  );

	// Go zero out the pointers in the structure, for now.

	if( HasPointer() )
		{
		ITERATOR	I;
		CG_FIELD	*	pCG;
		expr_node	*	pSrc = pCCB->GetSourceExpression();

		// Get all the members in the struct which contain pointers. If the
		// structure has been unrolled by the format string generator, the 
		// print prefix contains the proper prefixed part of the unrolled path,
		// we just have to add the field name to it.

		GetPointerMembers( I );

		while( ITERATOR_GETNEXT( I, pCG ) )
			{
			char * pVarName =
                     new char[ strlen( ((CG_FIELD *)pCG)->GetPrintPrefix())+
                               strlen( pCG->GetType()->GetSymName())       +
                               1
                             ];

			strcpy( pVarName, ((CG_FIELD *)pCG)->GetPrintPrefix() );
            strcat( pVarName, pCG->GetType()->GetSymName() );

			expr_node * pExpr = new expr_pointsto(
											 pSrc,
											 new expr_variable( pVarName, 0 ));
			expr_node * pAss = new expr_assign(pExpr, new expr_constant(0L));

			pCCB->GetStream()->NewLine();
			pAss->PrintCall( pCCB->GetStream(), 0, 0 );
			pCCB->GetStream()->Write(';');

			// this memory area is no longer useful.
			delete []pVarName;
			}


		}

	return CG_OK;
	}

short
CG_COMP::GetPointerMembers(
	ITERATOR&	I )
	{
	CG_ITERATOR	M;
	CG_FIELD	*	pField;
	short		Count = 0;

	if( HasPointer() )
		{
		GetMembers( M );

		while( ITERATOR_GETNEXT( M, pField ) )
			{
			if( pField->GetChild()->IsPointer() )
				{
				ITERATOR_INSERT( I, pField );
				Count++;
				}
			}
		}
	return Count;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\resmgr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	resmgr.cxx

 Abstract:

	Stub and auxillary routine resource management helper routines.

 Notes:

	This file has a dependency on the type graph implementation.

 History:

	Sep-15-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop

void GenNdrCorrRes( ANALYSIS_INFO*  pAna );

void
CG_PROC::C_PreAllocateResources(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Pre-allocate stub resources like local variables, parameter variables
	etc for the client side stub.

 Arguments:

 	pAna	- A pointer to the analysis block.
	
 Return Value:
	
	None.

 Notes:

 	1. All parameters are declared as resources for the client stub.
 	2. Standard client side resources like the stub message, rpc message
 	   status etc are local resources.
 	
----------------------------------------------------------------------------*/
{
	node_id	*	pRpcMessageType	= new node_id( RPC_MESSAGE_VAR_NAME );
	node_id	*	pStubMessageType= new node_id( STUB_MESSAGE_VAR_NAME );
	node_id	*	pStatus			= new node_id( RPC_STATUS_VAR_NAME );
	CG_ITERATOR	ParamList;

	// Set up local copies of the stub message and the rpc message.

	pRpcMessageType->SetBasicType( (node_skl *)
									new node_def (RPC_MESSAGE_TYPE_NAME) );
	pRpcMessageType->SetEdgeType( EDGE_USE );
	pAna->AddLocalResource( RPC_MESSAGE_VAR_NAME,
						    (node_skl *) pRpcMessageType
						  );

	pStubMessageType->SetBasicType( (node_skl *)
									new node_def (STUB_MESSAGE_TYPE_NAME) );

	pStubMessageType->SetEdgeType( EDGE_USE );
	pAna->AddLocalResource( STUB_MESSAGE_VAR_NAME,
							(node_skl *) pStubMessageType
						  );

	if( HasStatuses() )
		{
		pStatus			= new node_id( RPC_STATUS_VAR_NAME );
		pStatus->SetBasicType( (node_skl *)
									new node_def (RPC_STATUS_TYPE_NAME) );

		pStatus->SetEdgeType( EDGE_USE );
		SetStatusResource( pAna->AddLocalResource( RPC_STATUS_VAR_NAME,
												(node_skl *) pStatus
						  						));
		}

    // resource for cache
    // /deny causes a switch to /Oicf. This code will not be executed
    if ( fHasDeny )
        {
        GenNdrCorrRes( pAna );
        }

	// Add all params as param resources only if necessary (at least one param).

	if( GetMembers( ParamList ) )
		{
		CG_PARAM	*	pParam;
		node_skl	*	pType;

		ITERATOR_INIT( ParamList );

		while( ITERATOR_GETNEXT( ParamList, pParam ) )
			{
			pType		= pParam->GetType();
			pAna->AddParamResource( (PNAME) pType->GetSymName(),
									pType->GetChild() //Yes not getbasictype()
								  );
			}
		}

    //
    // Check for a structure or union return type.  If one exists we must
	// allocate a local pointer with a munged name for the eventual 
	// Ndr unmarshall call.
    //
    CG_RETURN * pReturn;

	if ( (pReturn = GetReturnType()) == 0 )
		return;

    //
    // If this is a by-value structure or union then we allocate a
    // local which is a pointer to the same type.
    //
    if ( ((CG_NDR *)pReturn->GetChild())->IsStruct() ||
         ((CG_NDR *)pReturn->GetChild())->IsUnion()  ||
         ((CG_NDR *)pReturn->GetChild())->IsXmitRepOrUserMarshal() )
        {
        node_id *   pLocalType;
		char *		pName;

		pName = LOCAL_NAME_POINTER_MANGLE  RETURN_VALUE_VAR_NAME;

        pLocalType = MakePtrIDNodeFromTypeName( pName, "void", 0 );

        pAna->AddLocalResource( pName,
                                (node_skl *) pLocalType );
        }
}

void
CG_PROC::S_PreAllocateResources(
	ANALYSIS_INFO	*	pAna )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Pre-allocate variables that are needed on the server side.

 Arguments:

 	pAna			- A pointer to the analysis block.
	
 Return Value:
	
	None.

 Notes:

 	1. The rpc message is a parameter resource allocated on the server side.
 	2. All other local variables, are decided during/after the analysis phase.
 	
----------------------------------------------------------------------------*/
{
	node_id	*	pStubMessageType= new node_id( STUB_MESSAGE_VAR_NAME );
	node_param	*	pRpcMessageType	= new node_param();
    node_param  *   pDWordType      = new node_param();
	CG_ITERATOR	ParamList;

	// The local copy of the rpc message pointer.

	pRpcMessageType->SetSymName( PRPC_MESSAGE_VAR_NAME );
	pRpcMessageType->SetBasicType( (node_skl *)
									new node_def (PRPC_MESSAGE_TYPE_NAME) );
	pRpcMessageType->SetEdgeType( EDGE_USE );

	pAna->AddParamResource( PRPC_MESSAGE_VAR_NAME,
						    (node_skl *) pRpcMessageType
						  );

    // For object procs , one more param after the rpc message.

    if( IsObject() )
        {
        // DWORD * pDwPhase parameter

        pDWordType->SetSymName( "_pdwStubPhase" );
        pDWordType->SetBasicType( (node_skl *)new node_def( "DWORD *" ) );
        pDWordType->SetEdgeType( EDGE_USE );
        pAna->AddParamResource( "_pdwStubPhase", pDWordType );
        }

	// Add the stub message local variable.

	pStubMessageType->SetBasicType( (node_skl *)
									new node_def (STUB_MESSAGE_TYPE_NAME) );

	pStubMessageType->SetEdgeType( EDGE_USE );
	pAna->AddLocalResource( STUB_MESSAGE_VAR_NAME,
							(node_skl *) pStubMessageType
						  );

    if ( HasNotifyFlag() )
        {
        node_id * pNotifyFlag = new node_id( NOTIFY_FLAG_VAR_NAME );

        pNotifyFlag->SetBasicType( (node_skl *) new node_def( "boolean" ));
        pNotifyFlag->SetEdgeType( EDGE_USE );

        pAna->AddLocalResource( NOTIFY_FLAG_VAR_NAME,
                                (node_skl *) pNotifyFlag );
        }

    // resource for cache
    // /deny causes a switch to /Oicf. This code will not be executed
    if ( fHasDeny )
        {
        GenNdrCorrRes( pAna );
        }

    //
    // Check for by-value [in] structures and unions.  We must allocate 
    // a local which is a pointer to the same type for these.
    //
    // Also check for arrays so I can put a hack in until we get their
    // allocation figured out.
    //

	if( GetMembers( ParamList ) )
		{
		CG_PARAM	*	pParam;
		node_skl	*	pType;

		while( ITERATOR_GETNEXT( ParamList, pParam ) )
			{
			pType = pParam->GetType();

            CG_NDR * pChild = (CG_NDR *)pParam->GetChild();
            ID_CG ChildID = pChild->GetCGID();

            if ( ChildID == ID_CG_GENERIC_HDL )
                {
                pChild = (CG_NDR *)pChild->GetChild();
                ChildID = pChild->GetCGID();
                }

            //
            // If this is a by-value structure or union then we allocate a
            // local which is a pointer to the same type.
            //
			if ( pChild->IsStruct() || pChild->IsUnion()  ||
                 pChild->IsXmitRepOrUserMarshal()  )
				{
				char *		pName;
				node_id *	pLocalType;
				char *		pPlainName = pType->GetSymName();

				pName = new char[strlen( pPlainName ) + 10];

				strcpy( pName, LOCAL_NAME_POINTER_MANGLE );
				strcat( pName, (PNAME) pPlainName );

                pLocalType = MakePtrIDNodeFromTypeName( pName,
                                                        "void",
                                                        0 );
				pAna->AddLocalResource( pName,
										(node_skl *) pLocalType );
				}
			}
		}
}
/****************************************************************************
 utility fns
 ****************************************************************************/
node_id *
MakeIDNode(
    PNAME       pName,
    node_skl *  pType,
    expr_node * pExpr )
	{
	node_id * pID = new node_id( (char *)pName );
	pID->SetBasicType( pType );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNode(
	PNAME	pName,
    node_skl *  pType,
    expr_node * pExpr )
	{
	node_id * pID = new node_id( (char *)pName );
	node_pointer * pP = new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pP );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNodeWithCastedExpr(
	PNAME	pName,
    node_skl *  pType,
    expr_node * pExpr )
	{
	node_id * pID = new node_id( (char *)pName );
	node_pointer * pP = new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pP );
	pID->SetEdgeType( EDGE_USE );
    expr_cast * pCast = new expr_cast( pP, pExpr );
    pID->SetExpr( pCast );
	return pID;
	}

node_id *
MakeIDNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName,
    expr_node * pExpr )
	{
	node_id	*	pID	= new node_id( pName );
	node_def * pDef = new node_def(pTypeName);
	pID->SetBasicType( pDef );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName,
    expr_node * pExpr )
	{
	node_id	*	pID	= new node_id( pName );
	node_def * pDef = new node_def(pTypeName);
	node_pointer * pPtr = new node_pointer();
	pPtr->SetBasicType( pDef );
	pPtr->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pPtr );
	pID->SetEdgeType( EDGE_USE );
    pID->SetExpr( pExpr );
	return pID;
	}

node_id *
MakePtrIDNodeFromTypeNameWithCastedExpr(
	PNAME	pName,
	PNAME	pTypeName,
    expr_node * pExpr )
	{
	node_id	*	pID	= new node_id( pName );
	node_def * pDef = new node_def(pTypeName);
	node_pointer * pPtr = new node_pointer();
	pPtr->SetBasicType( pDef );
	pPtr->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pPtr );
	pID->SetEdgeType( EDGE_USE );
    expr_cast * pCast = new expr_cast( pPtr, pExpr );
    pID->SetExpr( pCast );
	return pID;
	}

node_param *
MakeParamNode(
	PNAME	pName,
	node_skl * pType )
	{
	node_param * pID = new node_param();
	pID->SetSymName( pName );
	pID->SetBasicType( pType );
	pID->SetEdgeType( EDGE_USE );
	return pID;
	}

node_param *
MakePtrParamNode(
	PNAME	pName,
	node_skl * pType )
	{
	node_param * pID = new node_param( );
	node_pointer * pP = new node_pointer();
	pID->SetSymName( pName );
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pP );
	pID->SetEdgeType( EDGE_USE );

	return pID;
	}
node_param *
MakeParamNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName )
	{
	node_param	*	pID	= new node_param();
	node_def * pDef = new node_def(pTypeName);
	pID->SetSymName( pName );
	pID->SetBasicType( pDef );
	pID->SetEdgeType( EDGE_USE );
	return pID;
	}
node_param *
MakePtrParamNodeFromTypeName(
	PNAME	pName,
	PNAME	pTypeName )
	{
	node_param	*	pID	= new node_param();
	node_def * pDef = new node_def(pTypeName);
	node_pointer * pPtr = new node_pointer();
	pID->SetSymName( pName );
	pPtr->SetBasicType( pDef );
	pPtr->SetEdgeType( EDGE_USE );
	pID->SetBasicType( pPtr );
	pID->SetEdgeType( EDGE_USE );
	return pID;
	}

node_proc *	MakeProcNodeWithNewName( 
	PNAME 			pName,
	node_proc *		pProc )
	{
	node_proc	*	pNewProc	= new node_proc( pProc );

	pNewProc->SetSymName( pName );
	return pNewProc;
	}

void
GenNdrCorrRes   (
                ANALYSIS_INFO*  pAna
                )
    {
    node_id*        pCacheType  = new node_id( NDR_CORR_CACHE_VAR_NAME );
    expr_node*      pExpr       = new expr_constant( unsigned long( NDR_CORR_CACHE_SIZE ) );
    node_array*     pArray      = new node_array( 0, pExpr );
    node_base_type* pBaseType   = new node_base_type( NODE_LONG, ATTR_UNSIGNED );

    pBaseType->SetSymName( "long" );
    pArray->SetBasicType( pBaseType );
    pArray->SetEdgeType( EDGE_USE );
    pCacheType->SetBasicType( pArray );
    pCacheType->SetEdgeType( EDGE_USE );

    pAna->AddLocalResource( NDR_CORR_CACHE_VAR_NAME, pCacheType );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\stndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-1999 Microsoft Corporation

 Module Name:

    stndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    structure types, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Oct-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

void
CG_STRUCT::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a simple, conformant,
    or conformant varying structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pOldCGNodeContext;
    CG_NDR *            pConformantArray;

    if ( GetFormatStringOffset() != -1 )
        return;

    //
    // Check if this structure is "complex".
    //
    if ( IsComplexStruct() )
        {
        GenNdrFormatComplex( pCCB );
        return;
        }

    //
    // Check if the structure is "hard".
    //
    if ( IsHardStruct() )
        {
        GenNdrFormatHard( pCCB );
        return;
        }

    Unroll();

    //
    // Temporarily set the format string offset to 0 in case this structure
    // has pointers to it's own type.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );

    CG_FIELD *pOldRegionField = NULL;
#if defined(NDR64_ON_DCE_HACK)
    if ( NULL != dynamic_cast<CG_REGION*>( this ) )
        {
        pOldRegionField = pCCB->StartRegion();
        }
    else
#endif
    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    pFormatString = pCCB->GetFormatString();


    //
    // Search the fields of the structure for embedded structures and generate
    // the format string for these.
    //
    CG_ITERATOR     Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        CG_NDR * pOldPlaceholder;

        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

        pMember = (CG_NDR *) pField->GetChild();

        //
        // If there is a structure or array member then generate
        // it's format string.  We don't have to check for a union, because
        // that will make the struct CG_COMPLEX_STRUCT.
        //
        if ( pMember->IsStruct() || pMember->IsArray() )
            pMember->GenNdrFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // If this is a conformant (varying) struct then generate the array's
    // description.
    //
    if ( GetCGID() == ID_CG_CONF_STRUCT ||
         GetCGID() == ID_CG_CONF_VAR_STRUCT )
        {
        CG_NDR * pOldPlaceholder;

        pOldPlaceholder =
            pCCB->SetLastPlaceholderClass(
              (CG_NDR *) ((CG_CONFORMANT_STRUCT *)this)->GetConformantField() );

        // Get the conformant array CG class.
        pConformantArray = (CG_NDR *)
                           ((CG_CONFORMANT_STRUCT *)this)->GetConformantArray();

        // Generate the format string for the array.
        pConformantArray->GenNdrFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    //
    // If there are pointers in the structure then before you can start
    // generating the format string for the structure, you must generate
    // the format string for all of the pointees.
    //
    if ( HasPointer() )
        {
        GenNdrStructurePointees( pCCB );
        }

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );
    SetInitialOffset(      pFormatString->GetCurrentOffset() );


    switch ( GetCGID() )
        {
        case ID_CG_STRUCT :
            pFormatString->PushFormatChar( HasPointer() ?
                                           FC_PSTRUCT : FC_STRUCT );
            break;

        case ID_CG_CONF_STRUCT :
            pFormatString->PushFormatChar( HasPointer() ?
                                           FC_CPSTRUCT : FC_CSTRUCT );
            break;

        case ID_CG_CONF_VAR_STRUCT :
            pFormatString->PushFormatChar( FC_CVSTRUCT );
            break;
        }

    // Set the alignment.
    pFormatString->PushByte( GetWireAlignment() - 1 );

    // Set the structure memory size.
    pFormatString->PushShort( (short)GetMemorySize() );

    //
    // If this is a conformant array then push the offset to the conformant
    // array's description.
    //
    if ( GetCGID() == ID_CG_CONF_STRUCT ||
         GetCGID() == ID_CG_CONF_VAR_STRUCT )
        {
        // Set the offset to the array description.
        pFormatString->PushShortOffset( pConformantArray->GetFormatStringOffset() -
                                          pFormatString->GetCurrentOffset() );
        }

    // Generate the pointer layout if needed.
    if ( HasPointer() )
        {
        GenNdrStructurePointerLayout( pCCB, FALSE, FALSE );
        }

    // Now generate the layout.
    GenNdrStructureLayout( pCCB );

    //
    // Now we have to fix up the offset for any recursive pointer to this
    // structure.
    //
    GenNdrPointerFixUp( pCCB, this );

#if defined(NDR64_ON_DCE_HACK)
    if ( NULL != dynamic_cast<CG_REGION*>( this ) )
        {
        pCCB->EndRegion(pOldRegionField);
        }
    else
#endif
    pCCB->SetCGNodeContext( pOldCGNodeContext );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
    SetInitialOffset( GetFormatStringOffset() );

    FixupEmbeddedComplex( pCCB );

    if ( GetDuplicatingComplex() )
        GetDuplicatingComplex()->FixupEmbeddedComplex( pCCB );
}

void
CG_STRUCT::GenNdrFormatHard( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a packed structure.  The
    description has the same format as for a complex struct.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString;
    CG_NDR *        pOldCGNodeContext;
    CG_NDR *        pUnion;
    CG_FIELD *      pFinalField;
    long            CopySize;
    long            MemoryIncrement;

    if ( GetFormatStringOffset() != -1 )
        return;

    //
    // Temporarily set the format string offset to 0 in case this structure
    // has pointers to it's own type.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    pFormatString = pCCB->GetFormatString();

    //
    // Search the fields of the structure for embedded structures and generate
    // the format string for these.
    //
    CG_ITERATOR     Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;
    CG_NDR *        pOldPlaceholder;

    GetMembers( Iterator );

    pOldPlaceholder = pCCB->GetLastPlaceholderClass();

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pMember = (CG_NDR *) pField->GetChild();

        //
        // If there is an embedded structure, array, or union then generate
        // it's format string.
        //
        if ( pMember->IsStruct() || pMember->IsArray() || pMember->IsUnion() )
            {
            pCCB->SetLastPlaceholderClass( pField );
            pMember->GenNdrFormat( pCCB );
            }
        }

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );
    SetInitialOffset(      pFormatString->GetCurrentOffset() );

    pFinalField = GetFinalField();

    //
    // See if we have a union.
    //
    if ( pFinalField->GetChild()->IsUnion() )
        pUnion = (CG_NDR *) pFinalField->GetChild();
    else
        pUnion = 0;

    //
    // Determine the copy size and memory increment for the copy.
    //
    if ( pUnion )
        {
        CG_STRUCT * pStruct;

        pStruct = this;
        CopySize = 0;

        for ( ;; )
            {
            pStruct->GetMembers( Iterator );

            while ( ITERATOR_GETNEXT( Iterator, pField ) )
                ;

            CopySize += pField->GetWireOffset();

            pMember = (CG_NDR *) pField->GetChild();

            if ( pMember->IsStruct() )
                {
                pStruct = (CG_STRUCT *) pMember;
                continue;
                }
            else
                break;
            }

        MemoryIncrement = GetMemorySize() - pUnion->GetMemorySize();
        }
    else
        {
        CopySize = GetWireSize();
        MemoryIncrement = GetMemorySize();
        }

    //
    // Format string generation.
    //

    pFormatString->PushFormatChar( FC_HARD_STRUCT );

    // The alignment.
    pFormatString->PushByte( GetWireAlignment() - 1 );

    // The structure's memory size.
    pFormatString->PushShort( (short)GetMemorySize() );

    // Reserved for future use.
    pFormatString->PushLong( 0 );

    //
    // Offset to enum in struct.
    //
    if ( GetNumberOfEnum16s() == 1 )
        pFormatString->PushShort( GetEnum16Offset() );
    else
        pFormatString->PushShort( (short) -1 );

    //
    // Copy size and memory increment.
    //
    pFormatString->PushShort( CopySize );
    pFormatString->PushShort( MemoryIncrement );

    //
    // Offset to union's format string description.
    //
    if ( pUnion )
        {
        pOldPlaceholder = pCCB->GetLastPlaceholderClass();
        pCCB->SetLastPlaceholderClass( pFinalField );

        pFormatString->PushShort( (short)
                                  (pUnion->GetFormatStringOffset() -
                                   pFormatString->GetCurrentOffset()) );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }
    else
        pFormatString->PushShort( (short) 0 );

    // Now generate the layout.
    GenNdrStructureLayout( pCCB );

    //
    // Now we have to fix up the offset for any recursive pointer to this
    // structure.
    //
    GenNdrPointerFixUp( pCCB, this );

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
    SetInitialOffset( GetFormatStringOffset() );

    FixupEmbeddedComplex( pCCB );
}

void
CG_STRUCT::GenNdrFormatComplex( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a packed structure.  The
    description has the same format as for a complex struct.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_CLASS *          pConfField;
    CG_COMPLEX_STRUCT * pComplex;

    if ( (GetCGID() == ID_CG_CONF_STRUCT) ||
         (GetCGID() == ID_CG_CONF_VAR_STRUCT) )
        pConfField = ((CG_CONFORMANT_STRUCT *)this)->GetConformantField();
    else
        pConfField = 0;

    //
    // Do the old duplication trick.
    //
    pComplex = new CG_COMPLEX_STRUCT( this, pConfField );

    SetDuplicatingComplex( pComplex );

    //
    // Now temporarily set our format string offset to 0 to handle recursive
    // definitions.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );
                        
    //
    // This call will set our format string offset correctly.
    //
    pComplex->GenNdrFormat( pCCB );

    // Don't delete since the expression evaluator might need this.
    // delete( pComplex );
}


bool IsEnum16UnionAlignBug( CG_STRUCT *pStruct ) 
{

    // Comment from old hack wacked on stub.
    // The NT 3.50 stubs had a problem with union alignment that affects
    // structs with 16b enum and a union as the only other thing.
    // The old, incorrect alignment was 2 (code 1), the correct alignment is 4 (code 3).
    // All the compilers since NT 3.51, i.e. MIDL 2.0.102 generate correct code,
    // however we needed to introduce the wrong alignment into newly compiled stubs
    // to get interoperability with the released dhcp client and server binaries.
    
    if ( 4 != pStruct->GetWireAlignment())
        return false;

    CG_ITERATOR StructElements;
    pStruct->GetMembers( StructElements );

    ITERATOR_INIT( StructElements );
    size_t Elements = ITERATOR_GETCOUNT( StructElements );

    if ( 2 != Elements )
        return false;

    ITERATOR_INIT( StructElements );
    
    CG_FIELD *pField1 = NULL;
    ITERATOR_GETNEXT( StructElements, pField1 );
    MIDL_ASSERT( NULL != pField1);

    // Is the first field a enum16?
    CG_ENUM *pEnum = dynamic_cast<CG_ENUM*>( pField1->GetChild() );
    if ( ( NULL == pEnum ) || pEnum->IsEnumLong() )
        return false;

    // Is the second field a union
    CG_FIELD *pField2 = NULL;
    ITERATOR_GETNEXT( StructElements, pField2 );
    MIDL_ASSERT( NULL != pField2 );

    if ( ! pField2->GetChild()->IsUnion())
        return false;

    // Ok. We have a 2 field structure were the first field is an enum16 and the second field is
    // and union.
    return true;
}



void
CG_COMPLEX_STRUCT::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string description for a complex structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING *     pFormatString;
    CG_NDR *            pOldCGNodeContext;
    CG_NDR *            pConformantArray;
    long                PointerLayoutOffset;

    if ( GetFormatStringOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    //
    // Temporarily set the format string offset to 0 in case this structure
    // has pointers to it's own type.
    //
    SetFormatStringOffset( 0 );
    SetInitialOffset(      0 );

    pOldCGNodeContext = pCCB->SetCGNodeContext( this );

    //
    // Search the fields of the structure for imbeded structures, arrays, and
    // and unions and generate the format string for these.
    //
    CG_ITERATOR     Iterator;
    CG_FIELD *      pField;
    CG_NDR *        pMember;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pMember = (CG_NDR *) pField->GetChild();

        //
        // If the field is anything other than a base type or a
        // non-interface pointer then generate it's description.
        //
        if ( ! pMember->IsSimpleType() &&
             ! ( pMember->IsPointer() &&
                 !pMember->IsInterfacePointer() ) &&
             (pMember->GetCGID() != ID_CG_IGN_PTR) ||
             pMember->GetRangeAttribute() )
            {
            CG_NDR * pOldPlaceholder;

            pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

            pMember->GenNdrFormat( pCCB );

            pCCB->SetLastPlaceholderClass( pOldPlaceholder );
            }
        }

    // Generate pointee format strings.
    GenNdrStructurePointees( pCCB );

    // Generate conformant array description.
    if ( ( pConformantArray = (CG_NDR *) GetConformantArray() ) != 0 )
        {
        CG_NDR * pOldPlaceholder;

        pOldPlaceholder = pCCB->SetLastPlaceholderClass(
                                (CG_NDR *) GetConformantField() );

        pConformantArray->GenNdrFormat( pCCB );

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        }

    // Now set the struct's format string offset.
    SetFormatStringOffset( pFormatString->GetCurrentOffset() );
    SetInitialOffset(      pFormatString->GetCurrentOffset() );

    //
    // Set the duplicated struct's format string offset if we were duplicated.
    //
    if ( GetDuplicatedStruct() )
        {
        GetDuplicatedStruct()->SetFormatStringOffset( GetFormatStringOffset() );
        GetDuplicatedStruct()->SetInitialOffset(      GetFormatStringOffset() );
        }

    pFormatString->PushFormatChar( FC_BOGUS_STRUCT );

    WarnAboutEmbeddedComplexStruct();

    //
    // Set the wire alignment.
    //
    if ( pCommand->WireCompat( WIRE_COMPAT_ENUM16UNIONALIGN ) &&
         IsEnum16UnionAlignBug(this) )
        {

        // Comment from old hack wacked on stub.
        // The NT 3.50 stubs had a problem with union alignment that affects
        // structs with 16b enum and a union as the only other thing.
        // The old, incorrect alignment was 2 (code 1), the correct alignment is 4 (code 3).
        // All the compilers since NT 3.51, i.e. MIDL 2.0.102 generate correct code,
        // however we needed to introduce the wrong alignment into newly compiled stubs
        // to get interoperability with the released dhcp client and server binaries.

        pFormatString->AddComment( pFormatString->GetCurrentOffset(), "/* 3 */ /* enum16unionalign Bug Compatibility */" );  
        pFormatString->PushByte( 1 );

        }
    else
        pFormatString->PushByte( GetWireAlignment() - 1 );

    // Set the structure memory size.
    pFormatString->PushShort( (short)GetMemorySize() );

    // Array description.
    if ( pConformantArray )
        pFormatString->PushShortOffset( pConformantArray->GetFormatStringOffset() -
                                          pFormatString->GetCurrentOffset() );
    else
        pFormatString->PushShort( (short) 0 );

    //
    // Remember where the offset_to_pointer_layout<> field will go and push
    // some space for it.
    //
    PointerLayoutOffset = pFormatString->GetCurrentOffset();

    pFormatString->PushShortOffset( 0 );

    // Now generate the structure's layout.
    GenNdrStructureLayout( pCCB );

    //
    // Now see if we have any plain pointer fields and if so generate a
    // pointer layout.  We can't use the HasAtLeastOnePointer() method
    // because this tells us TRUE if we have any embedded arrays, structs,
    // or unions which have pointers.  For complex structs we're only
    // interested in actual pointer fields.
    //
    GetMembers( Iterator );

    //
    // Fill in the offset_to_pointer_layout<2> field and generate a
    // pointer_layout<> if we have any pointer fields.  Interface pointers
    // do not reside in the pointer layout.
    //
    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        if ( pField->GetChild()->IsPointer() &&
             !pField->IsInterfacePointer() )
            {
            // This is an internal offset within the struct descriptor, namely
            // to the pointer layout field, not the offset to a type.

            // Surprisingly, this code may produce an offset to an array etc.
            // Hence, we push an offset to be backward compatible.

            pFormatString->PushShortOffset(
                pFormatString->GetCurrentOffset() - PointerLayoutOffset,
                PointerLayoutOffset );

            GenNdrStructurePointerLayout( pCCB );

            break;
            }

    pFormatString->Align();

    //
    // Now we have to fix up the offset for any recursive pointer to this
    // structure.
    //
    GenNdrPointerFixUp( pCCB, GetDuplicatedStruct() ? GetDuplicatedStruct() : this );

    pCCB->SetCGNodeContext( pOldCGNodeContext );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
    SetInitialOffset(      GetFormatStringOffset() );
    if ( GetDuplicatedStruct() )
        GetDuplicatedStruct()->SetFormatStringOffset( GetFormatStringOffset() );

    FixupEmbeddedComplex( pCCB );
    if ( GetDuplicatedStruct() )
        GetDuplicatedStruct()->FixupEmbeddedComplex( pCCB );

    // There is no call to the string optimizer here. If we wanted to put it in,
    // the code should check if the optimization is possible or not by checking the
    // result of GenNdrEmbeddedPointers via GenNdrStructurePointerLayout call.
}

void
CG_COMPLEX_STRUCT::GenNdrStructurePointerLayout( CCB * pCCB )
/*++

Routine Description :

    Generates the format string pointer layout section for a complex
    structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    CG_ITERATOR         Iterator;
    CG_FIELD *          pField;
    CG_NDR *            pMember;

    GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        CG_NDR *    pOldPlaceholder;
        
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() &&
             !pMember->IsInterfacePointer())
            {
            CG_POINTER *        pPointer;

            pPointer = (CG_POINTER *) pMember;

            // The pointer description.
            pPointer->GenNdrFormatEmbedded( pCCB );
            }

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        } // while
}

//---------------------------------------------------------------------------
// Methods shared by all or most structure classes.
//---------------------------------------------------------------------------

void
CG_STRUCT::GenNdrStructurePointerLayout( CCB *  pCCB,
                                         BOOL   fNoPP,
                                         BOOL   fNoType )
/*++

Routine Description :

    Generates the format string pointer layout section for a structure.
    This is the default routine for this used by the structure classes.
    Only CG_COMPLEX_STRUCT redefines this virtual method.

Arguments :

    pCCB        - pointer to the code control block.
    fNoPP       - TRUE if no FC_PP or FC_END should be emitted
    fNoType     - TRUE only the bare offset and description should be emitted
                  for each pointer

 --*/
{
    CG_ITERATOR         Iterator;
    FORMAT_STRING *     pFormatString;
    CG_FIELD *          pField;
    CG_NDR *            pMember;
    long                ImbedingMemSize;
    long                ImbedingBufSize;

    pFormatString = pCCB->GetFormatString();

    // Get/Save the current imbeding sizes.
    ImbedingMemSize = pCCB->GetImbedingMemSize();
    ImbedingBufSize = pCCB->GetImbedingBufSize();

    if ( ! fNoPP )
        {
        pFormatString->PushFormatChar( FC_PP );
        pFormatString->PushFormatChar( FC_PAD );
        }

    GetMembers( Iterator );

    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        CG_NDR *    pOldPlaceholder;
        
        pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() &&
             !pMember->IsInterfacePointer() )
            {
            CG_POINTER *        pPointer;

            pPointer = (CG_POINTER *) pMember;

            // Push the instance type.
            if ( ! fNoType )
                {
                pFormatString->PushFormatChar( FC_NO_REPEAT );
                pFormatString->PushFormatChar( FC_PAD );
                }

            pFormatString->PushShort( (short)
                            (ImbedingMemSize + pField->GetMemOffset()));
            pFormatString->PushShort( (short)
                            (ImbedingBufSize + pField->GetWireOffset()));

            // The actual pointer description.
            pPointer->GenNdrFormatEmbedded( pCCB );
            }

        //
        // Generate pointer descriptions for all embedded arrays and structs.
        // We don't have to check for unions because that will make the struct
        // complex.
        //
        if ( pMember->IsArray() )
            {
            CG_NDR * pNdr = (CG_NDR *) pMember->GetChild();

            //
            // For arrays we set the imbeded memory size equal to the
            // size of the whole imbededing structure.
            //
            pCCB->SetImbedingMemSize( ImbedingMemSize + GetMemorySize() );
            pCCB->SetImbedingBufSize( ImbedingBufSize + GetWireSize() );

            if ( (pNdr->IsPointer() && 
                  !pNdr->IsInterfacePointer() )
                 ||
                 ( pNdr->IsStruct() && ((CG_COMP *)pNdr)->HasPointer() )  )
                ((CG_ARRAY *)pMember)->GenNdrFormatArrayPointerLayout( pCCB,
                                                                       TRUE );
            }

        if ( pMember->IsStruct() )
            if ( ((CG_STRUCT *)pMember)->HasPointer() )
                {
                //
                // For embedded structs we add the embedded struct's offset to
                // the value of the current embeddeding size.
                //
                pCCB->SetImbedingMemSize( ImbedingMemSize +
                                          pField->GetMemOffset() );
                pCCB->SetImbedingBufSize( ImbedingBufSize +
                                          pField->GetWireOffset() );

                ((CG_STRUCT *)pMember)->GenNdrStructurePointerLayout( pCCB,
                                                                      TRUE,
                                                                      fNoType );
                }

        pCCB->SetLastPlaceholderClass( pOldPlaceholder );
        } // while

    if ( ! fNoPP )
        pFormatString->PushFormatChar( FC_END );

    // Re-set the old imbeding sizes.
    pCCB->SetImbedingMemSize( ImbedingMemSize );
    pCCB->SetImbedingBufSize( ImbedingBufSize );

    // There is no call to the string optimizer here. If we wanted to put it in,
    // the code should check if the optimization is possible or not by checking the 
    // result of GenNdrEmbeddedPointers via GenNdrStructurePointerLayout call.
}


CG_FIELD *
CG_STRUCT::GetPreviousField( CG_FIELD * pMarkerField )
/*++

Routine description:

    Finds the field immediately preceding the given field.

Argument:

    pMarkerField  -   the given field

Returns:

    The preceding field or NULL if the given field is the first one.
--*/
{
    CG_ITERATOR         Iterator;
    CG_FIELD            *pField, *pPreviousField = 0;

    GetMembers( Iterator );
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        if ( pField == pMarkerField )
            return( pPreviousField );

        pPreviousField = pField;
        }
    return( 0 );
}


void
CG_STRUCT::GenStructureMemPad( CCB * pCCB, unsigned long MemPad )
/*++

Routine Description :

    Generates the format string for memory padding in a structure layout.

Arguments :

    pCCB        - pointer to the code control block.
    MemPad      - Amount of required padding.
    
 --*/
{
   FORMAT_STRING * pFormatString = pCCB->GetFormatString();
   MIDL_ASSERT( MemPad < 0xFFFF ); // structures must be less then 64k

   switch( MemPad)
       {
       case 0:
           return; // No padding needed
       case 1:
           pFormatString->PushFormatChar( FC_STRUCTPAD1 );
           return;
       case 2:
           pFormatString->PushFormatChar( FC_STRUCTPAD2 );
           return;
       case 3:
           pFormatString->PushFormatChar( FC_STRUCTPAD3 );
           return;
       case 4:
           pFormatString->PushFormatChar( FC_STRUCTPAD4 );
           return;
       case 5:
           pFormatString->PushFormatChar( FC_STRUCTPAD5 );
           return;
       case 6:
           pFormatString->PushFormatChar( FC_STRUCTPAD6 );
           return;
       case 7:
           pFormatString->PushFormatChar( FC_STRUCTPAD7 );
           return;
       default:

           // NDR60 Feature

           // Pad an arbitrary amount
           // FC_STRUCTPADN 0 <unsigned short>
           pFormatString->Align();
           pFormatString->PushFormatChar( FC_STRUCTPADN );
           pFormatString->PushFormatChar( FC_ZERO );
           pFormatString->PushShort( (short)MemPad );

           pCommand->GetNdrVersionControl().SetHasStructPadN();
       }

}

void
CG_STRUCT::GenNdrStructureLayout( CCB * pCCB )
/*++

Routine Description :

    Generates the format string layout section for a structure.

Arguments :

    pCCB        - pointer to the code control block.

 --*/
{
    FORMAT_STRING * pFormatString = pCCB->GetFormatString();

    CG_NDR * pOldPlaceholder = pCCB->GetLastPlaceholderClass();

    CG_ITERATOR         Iterator;
    GetMembers( Iterator );

    CG_FIELD *    pField;
    CG_FIELD *    pPrevField = NULL;
    unsigned long BufferOffset = 0;
    bool          fSawUnknownRepAs = false;

    while( ITERATOR_GETNEXT( Iterator, pField ) ) 
        {
        if ( fSawUnknownRepAs && !pField->HasEmbeddedUnknownRepAs() )
            {
            switch ( pField->GetMemoryAlignment() )
                {
                case 2: pFormatString->PushFormatChar( FC_ALIGNM2 ); break;
                case 4: pFormatString->PushFormatChar( FC_ALIGNM4 ); break;
                case 8: pFormatString->PushFormatChar( FC_ALIGNM8 ); break;
                }        
            }
        else if ( !fSawUnknownRepAs && !pField->HasEmbeddedUnknownRepAs() )
            {
            unsigned long MemPad = pField->GetMemOffset() - BufferOffset;

            GenStructureMemPad( pCCB, MemPad );

            BufferOffset += MemPad;
            }

        pCCB->SetLastPlaceholderClass( pField );
        
        CG_NDR *pMember = (CG_NDR *) pField->GetChild();
        
        while ( pMember->GetCGID() == ID_CG_TYPEDEF )
            {
            pMember = ( CG_NDR* )pMember->GetChild();
            }
        
        // The ending conformat array is not included in the
        // size of the structure.
        // Note that this must be the last field.
        if ( pMember->GetCGID() == ID_CG_CONF_ARRAY ||
             pMember->GetCGID() == ID_CG_CONF_VAR_ARRAY ||
             pMember->GetCGID() == ID_CG_CONF_STRING_ARRAY )
            {
            break;
            }

        // Generate an embedded complex for embedded things.
        if ( pMember->IsStruct() ||
             pMember->IsUnion() ||
             pMember->IsArray() ||
             pMember->IsXmitRepOrUserMarshal() ||
             pMember->GetRangeAttribute() ||
             pMember->IsInterfacePointer() )
            {
            pFormatString->PushFormatChar( FC_EMBEDDED_COMPLEX );

            if ( pField->HasEmbeddedUnknownRepAs() )
                {
                pCCB->GetRepAsPadExprDict()->Register(
                            pFormatString->GetCurrentOffset(),
                            GetType(),
                            pField->GetType()->GetSymName(),
                            pPrevField ? pPrevField->GetType() : 0 );

                pFormatString->PushByteWithPadMacro();
                fSawUnknownRepAs = true;
                }
            else
                {
                pFormatString->PushByte( 0 ); //Padding is generated independently
                }

            if ( pMember->GetFormatStringOffset() == -1 ||
                 pMember->GetFormatStringOffset() == 0 )
                {
                RegisterComplexEmbeddedForFixup(
                    pMember,
                    pFormatString->GetCurrentOffset() - GetInitialOffset() );
                }

            pFormatString->PushShortOffset( pMember->GetFormatStringOffset() -
                                              pFormatString->GetCurrentOffset() );
            }

        else if (pMember->IsPointer() ||
                 ( pMember->GetCGID() == ID_CG_IGN_PTR ) )
            {
            if ( pMember->IsPointer() )
                {
                if ( GetCGID() == ID_CG_COMPLEX_STRUCT )
                    pFormatString->PushFormatChar( FC_POINTER );
                else
                    {
                    pFormatString->PushFormatChar( FC_LONG );
#if !defined(NDR64_ON_DCE_HACK )
                    MIDL_ASSERT( ! pCommand->Is64BitEnv() );
#endif
                    }
                }
            else
                pFormatString->PushFormatChar( FC_IGNORE );

            }
#if defined( NDR64_ON_DCE_HACK )
        else if ( NULL != dynamic_cast<CG_PAD*>( pMember ) )
            {
            pFormatString->PushFormatChar( FC_BUFFER_ALIGN );
            pFormatString->PushByte( pMember->GetWireAlignment() - 1);
            }
#endif
        else 
            {
            //
            // Must be a CG_BASETYPE if we get here.
            //
            FORMAT_CHARACTER FormatChar = ((CG_BASETYPE *)pMember)->GetFormatChar();
            pFormatString->PushFormatChar( FormatChar );
            }

        BufferOffset += pField->GetMemorySize();
        pPrevField = pField;
        }

    // Account for padding at the end of the structure.

    MIDL_ASSERT( GetMemorySize() >= BufferOffset );

    unsigned long EndingPad = GetMemorySize() - BufferOffset;

    // End padding is only allow on complex struct.
    MIDL_ASSERT( EndingPad  ? ( (GetCGID() == ID_CG_COMPLEX_STRUCT) ||
                                IsComplexStruct() || IsHardStruct() )
                            : true ); 

    GenStructureMemPad( pCCB, EndingPad );          

    //
    // If the format string is on a short boundary right now then push
    // a format character so that the format string will be properly aligned
    // following the FC_END.
    //
    if ( ! (pFormatString->GetCurrentOffset() % 2) )
        pFormatString->PushFormatChar( FC_PAD );

    pFormatString->PushFormatChar( FC_END );

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

}

void
CG_STRUCT::GenNdrStructurePointees( CCB * pCCB )
{
    CG_ITERATOR         Iterator;
    FORMAT_STRING *     pFormatString;
    CG_FIELD *          pField;
    CG_NDR *            pMember;

    pFormatString = pCCB->GetFormatString();

    GetMembers( Iterator );

    //
    // We only have to check for pointer fields here, because if the structure
    // has a struct or array field which has pointers, this will be handled
    // when we generate their format strings.
    //
    while( ITERATOR_GETNEXT( Iterator, pField ) )
        {   
        pMember = (CG_NDR *) pField->GetChild();

        if ( pMember->IsPointer() &&
             !pMember->IsInterfacePointer() )
            {
            CG_NDR * pOldPlaceholder;

            pOldPlaceholder = pCCB->SetLastPlaceholderClass( pField );

            //
            // Skip over an unattributed pointer to a simple type or string.
            //
            if ( ( ((CG_POINTER *)pMember)->IsPointerToBaseType() ) ||
                 ( pMember->GetCGID() == ID_CG_STRING_PTR ) )
                {
                pCCB->SetLastPlaceholderClass( pOldPlaceholder );
                continue;
                }

            ((CG_POINTER *)pMember)->GenNdrFormatPointee( pCCB );

            pCCB->SetLastPlaceholderClass( pOldPlaceholder );
            }
        }
}

BOOL
CG_STRUCT::ShouldFreeOffline()
{
    return ( (GetCGID() == ID_CG_COMPLEX_STRUCT) ||
             (GetCGID() == ID_CG_CONF_VAR_STRUCT) ||
             HasPointer() ||
             IsComplexStruct() ||
             IsHardStruct() );
}

void
CG_STRUCT::GenFreeInline( CCB* )
{
}

void
CG_NDR::GenNdrPointerFixUp( CCB * pCCB, CG_STRUCT * pStruct )
{
    CG_ITERATOR     Iterator;
    CG_NDR *        pMember;
    CG_NDR *        pNdr;
    long            Offset;

    if ( ! IsStruct() && ! IsArray()  &&  ! IsUnion() )
        return;

    if ( IsInFixUp() )
        return;

    SetFixUpLock( TRUE );

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pMember ) )
        {
        if ( IsStruct() )
            {
            pNdr = (CG_NDR *) pMember->GetChild();
            }
        else if ( IsUnion() )
            {
            // member of union is a case, then case->field->ndr

            if ( pMember->GetChild() &&  pMember->GetChild()->GetChild() )
                pNdr = (CG_NDR *) pMember->GetChild()->GetChild();
            else
                continue;
            }
        else // IsArray()
            {
            pNdr = pMember;

            //
            // See if the array's element is the structure we're looking for.
            //
            if ( pNdr == pStruct )
                {
                Offset = ((CG_ARRAY *)this)->GetElementDescriptionOffset() + 2;
                pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - Offset,
                        Offset );
                }
            }

        if (pNdr->GetCGID() == ID_CG_TYPEDEF )
            pNdr = (CG_NDR *)pNdr->GetChild();

        if ( (pNdr->GetCGID() == ID_CG_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
            {
            CG_POINTER * pPointer = (CG_POINTER *) pNdr;

            //
            // Check if we're ready for this guy yet.
            //
            if ( pPointer->GetFormatStringOffset() == -1 )
                continue;

            // Get the pointee.
            switch ( pPointer->GetCGID() )
                {
                case ID_CG_PTR :
                    pNdr = (CG_NDR *) pPointer->GetChild();
                    break;
                case ID_CG_SIZE_PTR :
                    pNdr = ((CG_SIZE_POINTER *)pPointer)->GetPointee();
                    break;
                case ID_CG_SIZE_LENGTH_PTR :
                    pNdr = ((CG_SIZE_LENGTH_POINTER *)pPointer)->GetPointee();
                    break;
                }
        
            //
            // If the pointer's pointee is the struct we're checking for,
            // then patch up the pointer's offset_to_description<2> field.
            //
            if ( pNdr == pStruct )
                {
                long    PointerOffset;

                //
                // Get the offset in the format string where the
                // offset_to_description<2> field of the pointer is.
                //
                PointerOffset = pPointer->GetFormatStringOffset() + 2;
/*
                printf( "    **MIDL_fixup: Non-Reg Actually fixing %s at %d with %d (%d)\n", 
                        pNdr->GetSymName(),
                        PointerOffset, 
                        pNdr->GetFormatStringOffset() - PointerOffset,                      
                        pNdr->GetFormatStringOffset() );
*/
                pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - PointerOffset,
                        PointerOffset );
                
                continue;
                }
            }

        //
        // This can happen sometimes because of structs which are promoted
        // to complex because of padding.
        //
        if ( pNdr == this )
            continue;

        //
        // Continue the chase if necessary.
        //
        if ( pNdr->IsStruct() || pNdr->IsUnion() || pNdr->IsArray() )
            pNdr->GenNdrPointerFixUp( pCCB, pStruct );
        }

    SetFixUpLock( FALSE );
}


void
CG_NDR::RegisterComplexEmbeddedForFixup(
    CG_NDR *    pEmbeddedComplex,
    long        RelativeOffset )
{
    if ( GetInitialOffset() == -1 )
        printf( "  Internal compiler problem with recursive embeddings\n" );

    MIDL_ASSERT( GetInitialOffset() != -1 );

    if ( pEmbeddedComplexFixupRegistry == NULL )
        {
        pEmbeddedComplexFixupRegistry = new TREGISTRY;
        }

//    printf( "MIDL_fixup: RegisterComplex %s\n", pEmbeddedComplex->GetSymName());

    EMB_COMPLEX_FIXUP * pFixup = new EMB_COMPLEX_FIXUP;

    pFixup->pEmbeddedNdr   = pEmbeddedComplex;
    pFixup->RelativeOffset = RelativeOffset;

    pEmbeddedComplexFixupRegistry->Register( (node_skl *)pFixup );
}


void
CG_NDR::FixupEmbeddedComplex(
    CCB * pCCB )
{
    if ( IsInComplexFixup() )
        return;

    SetComplexFixupLock( TRUE );

    // Go down first
    CG_ITERATOR     Iterator;
    CG_NDR *        pField;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        pField->FixupEmbeddedComplex( pCCB );

    // Now fix up this level description.

    if ( GetEmbeddedComplexFixupRegistry() )
        {
        ITERATOR            FixupList;
        EMB_COMPLEX_FIXUP * pFixup;
        long                FixAtOffset;
        FORMAT_STRING *     pFormatString =  pCCB->GetFormatString();
    
        GetListOfEmbeddedComplex( FixupList );
    
        while ( ITERATOR_GETNEXT( FixupList, pFixup ) )
            {
            FixAtOffset = GetFormatStringOffset() + pFixup->RelativeOffset;
    
            pFormatString->PushShortOffset(
                pFixup->pEmbeddedNdr->GetFormatStringOffset() - FixAtOffset,
                FixAtOffset );
/*
            printf( "    MIDL_fixup: Reg-Cmplx Actually fixing at %d with %d\n", 
                    FixAtOffset, 
                    pFixup->pEmbeddedNdr->GetFormatStringOffset() - FixAtOffset );
*/
            }
        }

    // Due to duplication, the list may be at the duplicating node.
        
    if ( IsStruct() )
        {
        CG_COMPLEX_STRUCT * pDuping = ((CG_STRUCT *)this)->GetDuplicatingComplex();
        if ( pDuping )
            pDuping->FixupEmbeddedComplex( pCCB );
        }

    SetComplexFixupLock( FALSE );
}

// All these different ways of fixing recursive pointers need to be cleaned up.
// The RecPointer registry seems to be the best solution in that it fixes 
// the pointers once per compilation while complex embed fixup calls walk the 
// tree several times recursively.
// Also, the reason the below registry is different from previously introduced 
// EmbeddedComplex fixup registry is that the emb cplx fixup registry uses 
// a relative pointer when fixing up while the bug we are trying to address now
// affects standalone pointers where absolute offset is appropriate.
// The basic scheme with "struct _S**" field shows up in VARIANT and LPSAFEARRAY.
// Rkk, May, 1999.

void
CCB::RegisterRecPointerForFixup(
    CG_NDR *    pNdr,
    long        AbsoluteOffset )
{
    if ( pRecPointerFixupRegistry == NULL )
        {
        pRecPointerFixupRegistry = new TREGISTRY;
        }

    POINTER_FIXUP * pFixup = new POINTER_FIXUP;

//    printf( "MIDL_fixup: Registering for %s at %d\n", pNdr->GetSymName(), AbsoluteOffset);

    pFixup->pNdr           = pNdr;
    pFixup->AbsoluteOffset = AbsoluteOffset;
    pFixup->fFixed         = false; 
    pRecPointerFixupRegistry->Register( (node_skl *)pFixup );
}


void
CCB::FixupRecPointers()
{
    if ( GetRecPointerFixupRegistry() )
        {
        ITERATOR            FixupList;
        POINTER_FIXUP *     pFixup;
        long                FixAtOffset;
        FORMAT_STRING *     pFormatString = GetFormatString();
    
        GetListOfRecPointerFixups( FixupList );
    
        while ( ITERATOR_GETNEXT( FixupList, pFixup ) )
            {
            FixAtOffset = pFixup->AbsoluteOffset;
    
            if ( ! pFixup->fFixed )
                {
                long Recorded = pFormatString->GetFormatShort(FixAtOffset) + FixAtOffset;
                long NdrOffset = pFixup->pNdr->GetFormatStringOffset();

                if (  0 == Recorded  &&   0 != NdrOffset  ||
                     -1 == Recorded  &&  -1 != NdrOffset  )
                    {
/*                    
                    printf( "    MIDL_fixup: Actually fixing %s at %d with %d (%d)\n", 
                            pFixup->pNdr->GetSymName(),
                            FixAtOffset, 
                            NdrOffset - FixAtOffset,
                            NdrOffset );
*/
                    pFormatString->PushShortOffset( NdrOffset - FixAtOffset,
                                                    FixAtOffset );

                    pFixup->fFixed = true;
                    }
/*
                else if ( 0 != Recorded  &&  -1 != Recorded )
                    {
                    printf( "     MIDL_fixup: %s at %d was already fixed to %d (%d)\n",
                            pFixup->pNdr->GetSymName(),
                            FixAtOffset, 
                            NdrOffset - FixAtOffset,
                            NdrOffset );

                    pFixup->fFixed = true;
                    }
                else
                    {
                    printf( "     MIDL_fixup: %s at %d has not been fixed to %d (%d)\n",
                            pFixup->pNdr->GetSymName(),
                            FixAtOffset, 
                            NdrOffset - FixAtOffset,
                            NdrOffset );
                    }
*/
                } // if ! fixed
            } // while
        }
}

long
CG_STRUCT::FixedBufferSize( CCB * pCCB )
{
    CG_ITERATOR Iterator;
    CG_FIELD *  pField;
    CG_NDR *    pNdr;
    CG_NDR *    pOldPlaceholder;
    long        TotalBufferSize;
    long        BufSize;

    //
    // Check for recursion.
    //
    if ( IsInFixedBufferSize() )
        return -1;

    if ( (GetCGID() == ID_CG_CONF_STRUCT) ||
         (GetCGID() == ID_CG_CONF_VAR_STRUCT) ||
         (GetCGID() == ID_CG_COMPLEX_STRUCT) ||
         IsComplexStruct() )
        return -1;

    if ( IsHardStruct() )
        {
        if ( GetNumberOfUnions() == 0 )
            return MAX_WIRE_ALIGNMENT + GetWireSize();
        else
            return -1;
        }

    SetInFixedBufferSize( TRUE );

    MIDL_ASSERT( GetCGID() == ID_CG_STRUCT );

    pOldPlaceholder = pCCB->SetLastPlaceholderClass( this );

    GetMembers( Iterator );

    TotalBufferSize = MAX_WIRE_ALIGNMENT + GetWireSize();

    while ( ITERATOR_GETNEXT( Iterator, pField ) )
        {
        pNdr = (CG_NDR *) pField->GetChild();

        // skip these nodes to get to the transmitted element type.
    
        if ( pNdr->IsXmitRepOrUserMarshal() )
            pNdr = (CG_NDR *)pNdr->GetChild();

        if ( pNdr->IsStruct() || pNdr->IsArray() || pNdr->IsPointer() )
            {
            BufSize = pNdr->FixedBufferSize( pCCB );

            if ( BufSize == -1 )
                {
                SetInFixedBufferSize( FALSE );
                return -1;
                }

            //
            // First subtract the basic size of this thing from the struct's
            // size and then add back the value it returned.
            //
            TotalBufferSize -= pNdr->GetWireSize();
            TotalBufferSize += BufSize;
            }
        }

    pCCB->SetLastPlaceholderClass( pOldPlaceholder );

    SetInFixedBufferSize( FALSE );

    // Success!
    return TotalBufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\typegen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	typegen.cxx

 Abstract:

	transmit_as etc routine.

 Notes:


 History:

 	Dec-08-1993		VibhasC		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "becls.hxx"
#pragma hdrstop
/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_TRANSMIT_AS::S_GenInitOutLocals(
	CCB	*	pCCB )
	{
	expr_node	*	pExpr;

	pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
	Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
	expr_node	*	pSrc = pCCB->GetSourceExpression();
	expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
	pProc->SetParam( new expr_param( pSrc ) );
	pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
	pProc->SetParam( new expr_param( new expr_sizeof( GetPresentedType())));
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	return CG_OK;
	}

/*****************************************************************************
 REPRESENT_AS routines
 *****************************************************************************/
CG_STATUS
CG_REPRESENT_AS::S_GenInitOutLocals(
	CCB	*	pCCB )
	{
	expr_node	*	pExpr;
	node_skl	*	pNode = new node_def( GetRepAsTypeName() );

	pExpr = MakeAddressExpressionNoMatterWhat( GetResource() );
	Out_Assign( pCCB, pCCB->GetSourceExpression(), pExpr );
	expr_node	*	pSrc = pCCB->GetSourceExpression();
	expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
	pProc->SetParam( new expr_param( pSrc ) );
	pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
	pProc->SetParam( new expr_param( new expr_sizeof( pNode ) ) );
	pCCB->GetStream()->NewLine();
	pProc->PrintCall( pCCB->GetStream(), 0, 0 );
	return CG_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\uniongen.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	uniongen.cxx

 Abstract:

	union base in-line stuff.

 Notes:


 History:

	Jan-06-1994		VibhasC		Created
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/


CG_STATUS
CG_UNION::S_GenInitOutLocals(
	CCB		*	pCCB )
	{
	char Buffer[ 256 ];
	RESOURCE * pResource;
	PNAME		p;
	CG_NDR	*	pLPC = pCCB->GetLastPlaceholderClass();

	sprintf( Buffer, "%s", pLPC->GetType()->GetSymName() );

	p = pCCB->GenTRNameOffLastParam( Buffer );

	pResource = pCCB->GetLocalResource( p );

	// There is a pointer for the top level structure.

	Out_Assign( pCCB,
				pCCB->GetSourceExpression(),
				MakeAddressExpressionNoMatterWhat( pResource )
			  );

	if( HasPointer() )
		{
		expr_node	*	pSrc = pCCB->GetSourceExpression();

		// BUGBUG: Embedded structure are not inited yet!!
		// It is enough to emit code to set just the first pointer field to
		// 0. Guess why ?. Base type fields need not be set to 0.

		expr_proc_call * pProc = new expr_proc_call( MIDL_MEMSET_RTN_NAME );
		pProc->SetParam( new expr_param( pSrc ) );
		pProc->SetParam( new expr_param( new expr_constant( 0L ) ) );
		pProc->SetParam( new expr_param( new expr_sizeof( GetType())));
		pCCB->GetStream()->NewLine();
		pProc->PrintCall( pCCB->GetStream(), 0, 0 );
		}

	return CG_OK;
	}

short
CG_UNION::GetPointerMembers(
	ITERATOR&	I )
	{
	CG_ITERATOR	M;
	CG_CASE	*	pCase;
	short		Count = 0;

	if( HasPointer() )
		{
		GetMembers( M );

		while( ITERATOR_GETNEXT( M, pCase ) )
			{
			CG_FIELD	*	pField = (CG_FIELD *)pCase->GetChild();

			if((pCase->FLastCase()||(pCase->GetCGID() == ID_CG_DEFAULT_CASE))&&
			    pField && (pField->GetChild()) &&
			    pField->GetChild()->IsPointer() )
				{
				ITERATOR_INSERT( I, pField );
				Count++;
				}
			}
		}
	return Count;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\typendr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-1999 Microsoft Corporation

 Module Name:

    typendr.cxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    transmit_as and represent_as types.

 Notes:

 History:

    DKays     Jan-1994        Created.
    RyszardK  Jan-07-1994     Added transmit_as and represent as routines.
    RyszardK  Jan-17-1995     Added support for user_marshal.

 ----------------------------------------------------------------------------*/

#include "becls.hxx"

extern CMD_ARG * pCommand;
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Method:     CG_TYPEDEF::GenXmitOrRepAsQuintuple
//
//  Synopsis:   Register this type so that we can generate the callback
//              routines for it later.
//
//  Returns:    The index of the this type in the table of callback routine
//              sets
//
//  Notes:      If the type is already registered, just return the previous
//              index.
//
//  REVIEW:     "Gen" is not really correct since we don't generate anything.
//              Since this is now a method instead of a stand alone function
//              we should be able to get rid of the fXmit parameter.
//              Consider adding a common ancestor class for transmit_as /
//              represent_as as a better place to put this method.
//
//---------------------------------------------------------------------------

unsigned short
CG_TYPEDEF::GenXmitOrRepAsQuintuple(
    CCB *       pCCB,
    BOOL        fXmit,
    CG_NDR *    pXmitNode,
    char *      pPresentedTypeName,
    node_skl *  pTypeForPrototype )
{
    unsigned short    Index;

    // Register the routine to be generated for future use.

    XMIT_AS_CONTEXT * pTransmitAsContext = new XMIT_AS_CONTEXT;

    pTransmitAsContext->fXmit     = fXmit;
    pTransmitAsContext->pXmitNode = pXmitNode;
    pTransmitAsContext->pTypeName = pPresentedTypeName;

    BOOL  Added = pCCB->GetQuintupleDictionary()->Add( pTransmitAsContext );

    Index = pTransmitAsContext->Index;

    if ( Added )
        {
        // We haven't serviced this type yet.
          // Register with the ccb so that the prototypes can be emitted later

        if ( fXmit )
            pCCB->RegisterPresentedType( pTypeForPrototype );
        else
            pCCB->RegisterRepAsWireType( pTypeForPrototype );

        // Register the transmit_as contex to be able to generate
        // the helper routines.

        pCCB->RegisterQuintuple( pTransmitAsContext );
        }
    else
        delete pTransmitAsContext;

    return Index;
}


// ========================================================================
//       Transmit As
// ========================================================================

void
GenXmitOrRepAsNdrFormat(
    CCB *       pCCB,
    BOOL        fXmit,
    CG_TYPEDEF *pXmitNode,
    char *      pPresentedTypeName,
    node_skl *  pPresentedType,
    node_skl *  pTransmittedType )
{
    FORMAT_STRING *    pFormatString;
    CG_NDR *        pChild;
    unsigned short  Index;
    long            ChildOffset;
    
    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) pXmitNode->GetChild();

    // Do this in case the child is a simple type.
    ChildOffset = pFormatString->GetCurrentOffset();

    pChild->GenNdrFormat( pCCB );

    // Again, do this in case the child is a simple type.
    pFormatString->Align();

    pXmitNode->SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    Index = pXmitNode->GenXmitOrRepAsQuintuple( pCCB,
                                     fXmit,
                                     pXmitNode,
                                     pPresentedTypeName,
                                     (fXmit ? pPresentedType
                                            : pTransmittedType) );

    pFormatString->PushFormatChar( fXmit ? FC_TRANSMIT_AS
                                         : FC_REPRESENT_AS );

    // Now the flag byte. Lower nibble keeps xmitted type alignment.
    // The upper one has the flag for -Oi when presented type is an array.

    unsigned char
    FlagByte = unsigned char( pChild->GetWireAlignment() - 1 );

    if ( pPresentedType )
        {
        if ( pPresentedType->GetBasicType()->NodeKind() == NODE_ARRAY )
            FlagByte |= PRESENTED_TYPE_IS_ARRAY;
        else
            {
            if ( pXmitNode->GetMemoryAlignment() == 4 )
                FlagByte |= PRESENTED_TYPE_ALIGN_4;
            if ( pXmitNode->GetMemoryAlignment() == 8 )
                FlagByte |= PRESENTED_TYPE_ALIGN_8;
            }
        }

    pFormatString->PushByte( FlagByte );
    pFormatString->PushShort( (short) Index );

    // Now the presented type memory size and transmitted type bufsize.

    if ( pPresentedType )
        pFormatString->PushShort( (short)pPresentedType->GetSize( ) );
    else
        {
        // unknown rep as type - will have to generate a sizing macro

        pCCB->GetRepAsSizeDict()->Register( pFormatString->GetCurrentOffset(),
                                            pPresentedTypeName );
        pFormatString->PushShortWithSizeMacro();
        }

    if ( pChild->HasAFixedBufferSize() )
        pFormatString->PushShort( (short) pChild->GetWireSize() );
    else
        pFormatString->PushShort( (short) 0 );

    if ( pChild->GetCGID() == ID_CG_GENERIC_HDL )
        pChild = (CG_NDR *)pChild->GetChild();

    if ( pChild->IsSimpleType() )
        {
        pFormatString->PushShortOffset(
                     ChildOffset - pFormatString->GetCurrentOffset() );
        }
    else
        {
        pFormatString->PushShortOffset(
                           pChild->GetFormatStringOffset() - 
                             pFormatString->GetCurrentOffset() );
        }

    pXmitNode->SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( pXmitNode );
}

void
CG_TRANSMIT_AS::GenNdrFormat( CCB * pCCB )
/*++
    The format string is now:

        FC_TRANSMIT_AS
        Oi array flag/alignment<1>
        quintuple index<2>
        pres type mem size<2>
        tran type buf size<2>
        <<offset>>
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    GenXmitOrRepAsNdrFormat( pCCB,
                             TRUE,      // transmit as
                             this,
                             GetPresentedType()->GetSymName(),
                             GetPresentedType(),
                             GetTransmittedType() );
}

long                    
CG_TRANSMIT_AS::GetStackSize()
{
    if ( pPresentedType->GetBasicType()->NodeKind() == NODE_ARRAY )
        return SIZEOF_MEM_PTR();
    else
        return GetMemorySize();
}

//========================================================================
//      Represent_as
//========================================================================

void
CG_REPRESENT_AS::GenNdrFormat( CCB * pCCB )
/*++
    The format string is now:

        FC_REPRESENT_AS
        Oi array flag/alignment<1>
        quintuple index<2>
        pres type mem size<2>
        tran type buf size<2>
        <<offset>>
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    GenXmitOrRepAsNdrFormat( pCCB,
                             FALSE,      // represent as
                             this,
                             GetRepAsTypeName(),
                             GetRepAsType(),
                             GetTransmittedType() );
}

long
CG_REPRESENT_AS::GetStackSize()
{
    //
    // A null representation type is ok here.  Unknown rep-as is not allowed
    // in the interpreter, so we just return 0 since the stack size will 
    // never actually be used for an -Os stub.
    //
    if ( ! pRepresentationType )
        return 0;

    if ( pRepresentationType->GetBasicType()->NodeKind() == NODE_ARRAY )
        return SIZEOF_MEM_PTR();
    else
        return GetMemorySize();
}

void
CG_REPRESENT_AS::GenNdrParamDescription( CCB * pCCB )
{
    // REVIEW: Why is this here?  The CG_NDR version would have been called
    //         if we hadn't overridden it.

    CG_NDR::GenNdrParamDescription( pCCB );

    // BUGBUG : Stack offsets of parameters after this guy are in trouble.
}

void
CG_REPRESENT_AS::GenNdrParamDescriptionOld( CCB * pCCB )
{
    FORMAT_STRING * pProcFormatString;

    if ( GetRepAsType() )
        {
        CG_NDR::GenNdrParamDescriptionOld( pCCB );
        return;
        }

    pProcFormatString = pCCB->GetProcFormatString();

    pProcFormatString->PushUnknownStackSize( GetRepAsTypeName() );

    pProcFormatString->PushShortTypeOffset( GetFormatStringOffset() );
}

void
CG_USER_MARSHAL::GenNdrFormat( CCB * pCCB )
/*++
    The format string is now:

        FC_USER_MARSHAL
        flags/alignment<1>
        quadruple index<2>
        pres type mem size<2>
        xmit type wire size<2>
        Offset to wire desc<2>
--*/
{
    if ( GetFormatStringOffset() != -1 ) 
        return;

    pCommand->GetNdrVersionControl().SetHasUserMarshal();

    FORMAT_STRING * pFormatString;
    CG_NDR *        pChild;
    long            ChildOffset;

    // Format offset

    pFormatString = pCCB->GetFormatString();

    pChild = (CG_NDR *) GetChild();

    MIDL_ASSERT( pChild );

    // Do this in case the child is a simple type.
    ChildOffset = pFormatString->GetCurrentOffset();

    pChild->GenNdrFormat( pCCB );

    // Again, do this in case the child is a simple type.
    pFormatString->Align();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    // Real stuff now

    pFormatString->PushFormatChar( FC_USER_MARSHAL );

    // Now the flag byte.
    // Top 2 bits convey the pointer info:
    //     0 - not a pointer
    //     1 - a ref
    //     2 - a unique

    unsigned char
    FlagByte = unsigned char( pChild->GetWireAlignment() - 1 );

    if ( pChild->IsPointer() )
        {
        CG_POINTER * pPtr = (CG_POINTER *)pChild;
        MIDL_ASSERT( ! pPtr->IsFull() );

        if ( pPtr->IsUnique() )
            FlagByte |= USER_MARSHAL_UNIQUE;
        else if ( pPtr->IsRef() )
            FlagByte |= USER_MARSHAL_REF;
        }

    pFormatString->PushByte( FlagByte );

    // Register the routine to be generated for future use.

    USER_MARSHAL_CONTEXT * pUserMarshalContext = new USER_MARSHAL_CONTEXT;

    pUserMarshalContext->pTypeName = GetRepAsTypeName();
    pUserMarshalContext->pType     = GetRepAsType();

    BOOL  Added = pCCB->GetQuadrupleDictionary()->Add( pUserMarshalContext );

    unsigned short Index = pUserMarshalContext->Index;

    pFormatString->PushShort( (short) Index );

    if ( ! Added )
        delete pUserMarshalContext;

    // Now the presented type memory size and transmitted type bufsize.

    if ( GetRepAsType() )
        pFormatString->PushShort( (short) GetRepAsType()->GetSize( ) );
    else
        {
        // Unknown user_marshall type - will have to generate a sizing macro
        // As represent_as and user_marshal are mutually exclusive,
        // we can use rep_as size dictionary.

        pCCB->GetRepAsSizeDict()->Register( pFormatString->GetCurrentOffset(),
                                            GetRepAsTypeName() );
        pFormatString->PushShortWithSizeMacro();
        }

    if ( pChild->HasAFixedBufferSize() )
        pFormatString->PushShort( (short) pChild->GetWireSize() );
    else
        pFormatString->PushShort( (short) 0 );

    if ( pChild->IsSimpleType() )
        {
        pFormatString->PushShortOffset(
                    ChildOffset - pFormatString->GetCurrentOffset() );
        }
    else
        {
        pFormatString->PushShortOffset(
                          pChild->GetFormatStringOffset() - 
                            pFormatString->GetCurrentOffset() );
        }

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
    pFormatString->OptimizeFragment( this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\szbuffer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       szbuffer.cxx
//
//  Contents:   simple class for a string buffer that dynamically reallocates
//              space for itself as necessary
//
//  Classes:    CSzBuffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

#include "becls.hxx"
#pragma hdrstop
#include "szbuffer.h"

#define INCREMENT_BUFFER 256
#define INITIAL_BUFFER (INCREMENT_BUFFER * 2);

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::CSzBuffer
//
//  Synopsis:   constructor
//
//  Arguments:  [sz] - data for initial string (may be NULL)
//
//  History:    4-22-96   stevebl   Created
//
//  Notes:      Throughout this class the actual size of the buffer allocated
//              is determined by the formula
//                  INITIAL_BUFFER + INCREMENT_BUFFER * n
//              where n is calculated to give the value closest to (but not
//              less than) the number of bytes required.
//              The allocated buffer is never shrunk, only grown as needed.
//              This keeps allocations and memory moves to a minimum.
//
//----------------------------------------------------------------------------

CSzBuffer::CSzBuffer(const char * sz)
{
    if (sz)
    {
        cchLength = (int) strlen(sz);
        cchBufSize = INITIAL_BUFFER;
        while ((cchLength + 1) > cchBufSize)
            cchBufSize += INCREMENT_BUFFER;
        szData = new char[cchBufSize];
        strcpy(szData,sz);
    }
    else
    {
        cchLength = 0;
        cchBufSize = INITIAL_BUFFER;
        szData = new char[cchBufSize];
        szData[0] = 0;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::CSzBuffer
//
//  Synopsis:   default constructor
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

CSzBuffer::CSzBuffer()
{
    cchLength = 0;
    cchBufSize = INITIAL_BUFFER;
    szData = new char[cchBufSize];
    szData[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::~CSzBuffer
//
//  Synopsis:   destructor
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

CSzBuffer::~CSzBuffer()
{
    delete [] szData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Set
//
//  Synopsis:   resets buffer and (optionally) initializes it
//
//  Arguments:  [sz] - data for initial string (may be NULL)
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//  Notes:      as mentioned above, the size of the actual buffer does not
//              shrink
//
//----------------------------------------------------------------------------

void CSzBuffer::Set(const char * sz)
{
    cchLength = 0;
    szData[0] = 0;
    Append(sz);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Append
//
//  Synopsis:   adds data to the end of the buffer
//
//  Arguments:  [sz] - string data to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Append(const char * sz)
{
    if (sz)
    {
        int cchLenSz = (int) strlen(sz);
        int cchNew = cchLenSz + cchLength;
        if ((cchNew + 1) > cchBufSize)
        {
            while ((cchNew + 1) > cchBufSize)
                cchBufSize += INCREMENT_BUFFER;
            char * szNew = new char[cchBufSize];
            strcpy(szNew,szData);
            delete [] szData;
            szData=szNew;
        }
        strcpy(&szData[cchLength], sz);
        cchLength = cchNew;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Prepend
//
//  Synopsis:   adds data to the front of the buffer
//
//  Arguments:  [sz] - string to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Prepend(const char * sz)
{
    if (sz)
    {
        int cchLenSz = (int) strlen(sz);
        int cchNew = cchLenSz + cchLength;
        if ((cchNew + 1) > cchBufSize)
        {
            while ((cchNew + 1) > cchBufSize)
                cchBufSize += INCREMENT_BUFFER;
            char * szNew = new char[cchBufSize];
            strcpy(szNew,szData);
            delete [] szData;
            szData=szNew;
        }
        memmove(&szData[cchLenSz], szData, cchLength);
        memmove(szData, sz, cchLenSz);
        szData[ cchNew ] = 0;
        cchLength = cchNew;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Append
//
//  Synopsis:   adds a decimal integer to the end of the buffer
//
//  Arguments:  [l] - value of integer to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Append(const long l)
{
    char sz[50];
    sprintf(sz, "%d", l);
    Append(sz);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::Prepend
//
//  Synopsis:   adds a decimal integer to the front of the buffer
//
//  Arguments:  [l] - value of integer to add
//
//  Returns:    nothing
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

void CSzBuffer::Prepend(const long l)
{
    char sz[50];
    sprintf(sz, "%d", l);
    Prepend(sz);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::GetData
//
//  Returns:    pointer to the string in the buffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

char * CSzBuffer::GetData()
{
    return szData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSzBuffer::GetLength
//
//  Returns:    length (in chars) of the string in the buffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

int CSzBuffer::GetLength()
{
    return cchLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\treg.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	treg.cxx

 Abstract:

	This file implements the type registry for header file generation.

 Notes:

 History:

	Oc-23-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "becls.hxx"
#pragma hdrstop


node_skl *
TREGISTRY::IsRegistered(
	node_skl	*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Register a type with the type registry.

 Arguments:

 	pType	- A pointer to the type being registered.
	
 Return Value:

 	The node that gets registered.
	
 Notes:

----------------------------------------------------------------------------*/
{
	Dict_Status	Status	= Dict_Find( pType );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (node_skl *)0;
		default:
			return (node_skl *)Dict_Curr_Item();
		}
}

node_skl *
TREGISTRY::Register(
	node_skl	*	pType )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Register a type with the dictionary.

 Arguments:
	
 	pType	- A pointer to the type node.

 Return Value:

 	The final inserted type.
	
 Notes:

----------------------------------------------------------------------------*/
{
	if( !IsRegistered( pType ) )
		{
		Dict_Insert( (pUserType) pType );
		return pType;
		}
	return (node_skl *)pType;
}

short
TREGISTRY::GetListOfTypes(
	ITERATOR&	ListIter )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the list of types in this registry.

 Arguments:

 	ListIter	- A pre- constructed iterator where the list of types is
 				  returned.
	
 Return Value:

 	The count of the number of items.
	
 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pN;
	Dict_Status		Status;
	short			Count = 0;

	// Get to the top of the dictionary.

	Status	= Dict_Next( (pUserType)0 );

	// make sure we start with a clean iterator
	ITERATOR_DISCARD( ListIter );

	// Iterate till the entire dictionary is looked at.

	while( SUCCESS == Status )
		{
		pN	= (node_skl *)Dict_Curr_Item();
		ITERATOR_INSERT( ListIter, pN );
		Count++;
		Status = Dict_Next( (pUserType)pN );
		}

	return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\codegen\unionndr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1993-1999 Microsoft Corporation

 Module Name:

    unionndr.hxx

 Abstract:

    Contains routines for the generation of the new NDR format strings for
    unions, and the new NDR marshalling and unmarshalling calls.

 Notes:


 History:

    DKays     Nov-1993     Created.
 ----------------------------------------------------------------------------*/

#include "becls.hxx"
#pragma hdrstop

void
CG_ENCAPSULATED_STRUCT::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string for an encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    FORMAT_STRING *     pFormatString;
    CG_BASETYPE *       pSwitchIsNode;
    CG_UNION *          pUnion;
    unsigned long       SwitchType;

    if ( GetFormatStringOffset() != -1 ) 
        return;

    pFormatString = pCCB->GetFormatString();

    //
    // The child of the struct's first field node is the switch_is node.
    //
    pSwitchIsNode = (CG_BASETYPE *) GetChild()->GetChild();

    //
    // The child of the struct's second field node is the union node.
    //
    pUnion = (CG_UNION *) GetChild()->GetSibling()->GetChild();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pFormatString->PushFormatChar( FC_ENCAPSULATED_UNION );

    //
    // The switch type field in the format string has the size of the switch_is
    // field (including any needed pading) in the upper four bits and the 
    // actual switch_is type in the lower four bits.
    //

    //
    // Get the amount to increment the memory pointer to the encapsulated
    // union's struct to get to the actual union.  This is the total struct
    // size minus the union's size (this may not simply be the size of the
    // switch_is member because of possible padding).
    //
    CG_FIELD *  pSwitchField;
    CG_FIELD *  pUnionField;

    pSwitchField = (CG_FIELD *) GetChild();
    pUnionField = (CG_FIELD *) pSwitchField->GetSibling();

    //
    // Set the memory increment part of the SwitchType field.
    //
    SwitchType = ( pUnionField->GetMemOffset() - pSwitchField->GetMemOffset() )
                 << 4;

    if ( pSwitchIsNode->GetFormatChar() == FC_ENUM16 ) 
        SwitchType |= FC_ENUM16;
    else
        SwitchType |= pSwitchIsNode->GetSignedFormatChar();

    pFormatString->PushByte( SwitchType );

    pUnion->GenNdrSizeAndArmDescriptions( pCCB );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
//  SetFormatStringOffset( pFormatString->OptimizeFragment( this ) );

}

void
CG_UNION::GenNdrFormat( CCB * pCCB )
/*++

Routine Description :

    Generates the format string for a non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    FORMAT_STRING *     pFormatString;
    long                Offset;

    SetCCB( pCCB );

    if ( GetFormatStringOffset() != -1 ) 
        return;

    pFormatString = pCCB->GetFormatString();

    SetFormatStringOffset( pFormatString->GetCurrentOffset() );

    pFormatString->PushFormatChar( FC_NON_ENCAPSULATED_UNION );

    if ( ((CG_BASETYPE *)pCGSwitchType)->GetFormatChar() == FC_ENUM16 ) 
        pFormatString->PushFormatChar( FC_ENUM16 );
    else
        {
        FORMAT_CHARACTER SwitchTypeFc;

        // Note that we take the signed format character this time.

        SwitchTypeFc = ((CG_BASETYPE *)pCGSwitchType)->GetSignedFormatChar();

#if defined(TARGET_RKK)
        if ( pCommand->GetTargetSystem() == NT35  &&
             SwitchTypeFc == FC_USMALL )
            {
            // The NT 807 NDR engine doesn't know about usmall.

            pFormatString->PushFormatChar( FC_BYTE );
            pFormatString->PushFormatChar( FC_SMALL );
            }
        else
#endif

        pFormatString->PushFormatChar( SwitchTypeFc );
        }

    GenNdrSwitchIsDescription( pCCB );

    Offset = pFormatString->GetCurrentOffset();

    pFormatString->PushShortOffset( 0 );

    GenNdrSizeAndArmDescriptions( pCCB );

    pFormatString->PushShortOffset( GetNdrSizeAndArmDescriptionOffset() - Offset,
                                    Offset );

    SetFormatStringEndOffset( pFormatString->GetCurrentOffset() );
//  SetFormatStringOffset( pFormatString->OptimizeFragment( this ) );

}

void
CG_UNION::GenNdrFormatArms( CCB * pCCB )
/*++

Routine Description :

    Generates the format string for the arms of an encapsulated or a
    non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    CG_ITERATOR Iterator;
    CG_CASE *   pCase;
    CG_NDR *    pNdr;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {
        if ( ! pCase->GetChild() ) 
            continue;

        //
        // The child of the CG_CASE is a CG_FIELD.   
        // The child of the CG_FIELD is the actual NDR entity.
        //
        pNdr = (CG_NDR *) pCase->GetChild()->GetChild();

        if ( ! pNdr ) 
            continue;

        if ( pNdr && ( ! pNdr->IsSimpleType() || pNdr->GetRangeAttribute() ) ) 
            pNdr->GenNdrFormat( pCCB );
        }
}

void
CG_UNION::GenNdrSizeAndArmDescriptions( CCB * pCCB )
/*++

Routine Description :

    Generates the memory size and arm description portion of the format 
    string for an encapsulated or a non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    FORMAT_STRING *     pFormatString;
    unsigned short      UnionArms;
    long                FormatOffset;

    if ( GetNdrSizeAndArmDescriptionOffset() != -1 )
        return;

    pFormatString = pCCB->GetFormatString();

    SetNdrSizeAndArmDescriptionOffset( pFormatString->GetCurrentOffset() );

#ifdef DUMP_UNION_INFO

    FILE * fUnionLog = NULL;

    fUnionLog = fopen("c:\\unioninfo.log", "a+t");

    if (fUnionLog) 
        {
        char *pName = GetSymName();
        unsigned long UnionArms = GetNumberOfArms();
        char *pUnionKind = NULL;
        unsigned long UnionFlavor = GetUnionFlavor();
        char *pFileName = "Unknown";
        char *pEnv = pCommand->Is64BitEnv() ? ("64") : ("32");
 
        switch(UnionFlavor)
        {
            case UNION_UNKNOWN:
                pUnionKind = "Union_Unknown";
                break;
            case UNION_ENCAP:
                pUnionKind = "Union_Encap";
                break;
            case UNION_NONENCAP_DCE:
                pUnionKind = "Union_NonEncap_DCE";
                break;
            case UNION_NONENCAP_MS:
                pUnionKind = "Union_NonEncap_MS";
                break;
            default: 
                pUnionKind = "Unknown";
                break;         
        }

        node_file * pFile = GetType()->GetDefiningFile();
        if (pFile && pFile->GetSymName())
           pFileName = pFile->GetSymName();
 
        fprintf(fUnionLog, "* %s FileName: %s, Symbol: %s, Kind %u(%s), Arms: %u \n",
                pEnv, pFileName, pName, UnionFlavor, pUnionKind, UnionArms); 
        }

#endif

    //
    // Set aside the space for the union's description.  Then we generate
    // the format string description for all the union's arms, and then 
    // we go back and patch up the the union's description to have the 
    // proper offsets.  This must be done to handle self referencing union
    // types.
    //

    // Memory size.
    pFormatString->PushShort( (short) GetMemorySize() );

    //
    // union_arms<2> 
    //
    UnionArms = (unsigned short) GetNumberOfArms();

    if ( GetUnionFlavor() == UNION_NONENCAP_MS )
        {
        // 
        // Microsoft union support.
        // Set the upper four bits of the union_arm<2> field with the 
        // the alignment of the largest aligned union arm.
        //
        UnionArms |= (GetWireAlignment() - 1) << 12;
        }

    pFormatString->PushShort( (short) UnionArms );

    // Get union arms again since we may have just munged it.
    UnionArms = (short) GetNumberOfArms();

    // The arms.
    for ( ; UnionArms-- > 0; ) 
        {
        pFormatString->PushLong( 0 );
        pFormatString->PushShortOffset( 0 );
        }

    // default_arm_description<2>
    pFormatString->PushShortOffset( 0 );

    //
    // Generate the format string descriptions of the arms.
    //
    GenNdrFormatArms( pCCB );

    // Find out where the arms' descriptions begin.
    FormatOffset = GetNdrSizeAndArmDescriptionOffset() + 4;

    CG_ITERATOR         Iterator;
    CG_CASE *           pCase;
    CG_NDR *            pNdr;
    CG_NDR *            pNdrDefaultCase;
    BOOL                DefaultCaseFound;
    
    GetMembers( Iterator );

    pNdrDefaultCase = NULL;
    DefaultCaseFound = FALSE;

    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {
        //
        // Check for the default case first.
        //
        if ( pCase->GetCGID() == ID_CG_DEFAULT_CASE )
            {
            pNdrDefaultCase = pCase->GetChild() ? 
                              (CG_NDR *) pCase->GetChild()->GetChild() : 0;

            DefaultCaseFound = TRUE;

#ifdef DUMP_UNION_INFO
  
            if (fUnionLog)
               {
               fprintf(fUnionLog, "DEFAULT\n"); 
               }
#endif

            continue;
            }

        //
        // Fill in the arm's case value.
        //
        if (NULL == pCase->GetExpr())
            {
            RpcError(NULL, 0, NO_CASE_EXPR, GetSymName());
            exit(NO_CASE_EXPR);
            }

#ifdef DUMP_UNION_INFO

        if (fUnionLog)
           fprintf(fUnionLog, "%d \n", (long)pCase->GetExpr()->GetValue());

#endif

        pFormatString->PushLong( (long)pCase->GetExpr()->GetValue(), FormatOffset );
        FormatOffset += 4;

        //
        // Check for a non-default case with an empty (;) arm.
        //
        if ( ! pCase->GetChild() || ! pCase->GetChild()->GetChild() )
            {
            //
            // Increment the FormatOffset past the arm description, which 
            // simply remains zero.
            //
            FormatOffset += 2;
            continue;
            }

        //
        // Else it's a regular case with a valid arm.
        //

        pNdr = (CG_NDR *) pCase->GetChild()->GetChild();

        // Emit a short with type or offset representation.
        // For simple types we push <0x80><type>, for others we push offset<2>.
        // The engine checks if the first byte is 0x80 to decide how it should
        // treat the short, hence the offset range is from 0x8100 to 7fff, i.e.
        // the offset of 0x80xx is invalid.

        if ( pNdr && pNdr->IsSimpleType() )
            {
            short   s;
            //
            // The offset in this case is the actual format character for 
            // the base type, but with a 1 in the upper bit of the short, to 
            // make it look negative.
            //
            s = (short) ((CG_BASETYPE *)pNdr)->GetFormatChar();
            s |= MAGIC_UNION_SHORT;

            pFormatString->PushMagicUnionShort( s, FormatOffset );
            }
        else
            {
            //
            // The offset pushed here is the usual relative offset, except
            // as explained above, it has to be >= 0x8100.
            //
            pFormatString->PushShortOffset( pNdr->GetFormatStringOffset() - 
                                            FormatOffset,
                                            FormatOffset );
            }

        FormatOffset += 2;
        }

    //
    // Finally, handle the default case.
    //
    if ( ! DefaultCaseFound )
        {
        // We push an offset here for easier stub reading as this is an offset.. 
        // However, this would prevent union optimization if we switched it on,
        // so at that stage an FS_ marker is needed to generate a comment.
        //
        pFormatString->PushShortOffset( -1, FormatOffset );
        }
    else
        {
        if ( ! pNdrDefaultCase )
            pFormatString->PushShortOffset( 0, FormatOffset );
        else
            {
            if ( pNdrDefaultCase->IsSimpleType() )
                {
                short s;
                s = (short) ((CG_BASETYPE *)pNdrDefaultCase)->GetFormatChar(); 
                s |= MAGIC_UNION_SHORT;
                pFormatString->PushMagicUnionShort( s, FormatOffset );
                }
            else
                pFormatString->PushShortOffset(
                    pNdrDefaultCase->GetFormatStringOffset() - FormatOffset,
                    FormatOffset );
            }
        }

#ifdef DUMP_UNION_INFO
    if (fUnionLog)
    {
        fprintf(fUnionLog, "+\n");
        fprintf(fUnionLog, "\n");
        fclose(fUnionLog);
    }
#endif

}

BOOL 
CG_UNION::CanUseBuffer()
{
    CG_ITERATOR Iterator;
    CG_CASE *   pCase;
    CG_NDR *    pNdr;
    unsigned long Size;
    long        Align;
    long        TempBufAlign;

    //
    // We will be very strict, since there is not much room for 
    // leeway.  Only return TRUE if all arms have the same size, the same
    // wire alignment, and matching wire/memory alignments & sizes.
    //
    // The real scenario we're after is a union with all pointer arms or
    // longs.  This is fairly common in NT.
    //

    GetMembers( Iterator );

    Size = 0;
    Align = 0;
    
    while ( ITERATOR_GETNEXT( Iterator, pCase ) )
        {
        if ( ! pCase->GetChild() || 
             (pNdr = (CG_NDR *) pCase->GetChild()->GetChild()) == 0 )
            continue;

        TempBufAlign = pNdr->GetWireAlignment();
        
        if ( (pNdr->GetWireSize() != pNdr->GetMemorySize()) ||
             (pNdr->GetMemoryAlignment() != TempBufAlign) )
            return FALSE;

        if ( ! Size ) 
            {
            Size = pNdr->GetWireSize();
            Align = TempBufAlign;
            continue;
            }
            
        if ( (Size != pNdr->GetWireSize()) || (Align != TempBufAlign) )
            return FALSE;
        }

    return TRUE;
}

void
CG_UNION::GenNdrSwitchIsDescription( CCB *  pCCB )
/*++

Routine Description :

    This routine generates the switch_type<1> and switch_is_description<4>
    field for a non-encapsulated union.

Arguments :

    pCCB    - pointer to the code control block

Return :
    
    None.

--*/
{
    CG_NDR *            pParamOrField;
    CG_FIELD *          pField;
    expr_node *     pSwitchExpr;
    BOOL                IsPointer;

    pParamOrField = pCCB->GetLastPlaceholderClass();

    //
    // Get the switch is expression.
    //
    switch ( pParamOrField->GetCGID() )
        {
        case ID_CG_PARAM :
            pSwitchExpr = ((CG_PARAM *)pParamOrField)->GetSwitchExpr();

            // If it's top level param then this flag doesn't matter.
            IsPointer = FALSE;

            break;

        case ID_CG_FIELD :
            pField = (CG_FIELD *) pParamOrField;

            pSwitchExpr = pField->GetSwitchExpr();
    
            // Check if the field is actually a pointer to a union.
            IsPointer = ((CG_NDR *)pField->GetChild())->IsPointer();
                
            break;

        default :
            MIDL_ASSERT(0);
        }

    GenNdrFormatAttributeDescription( pCCB,
                                      NULL,
                                      pSwitchExpr,
                                      IsPointer,
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      pCommand->IsSwitchDefined( SWITCH_ROBUST ) );
}

void                    
CG_UNION::SetFormatStringOffset( long Offset )
{
    CCB *       pCCB;
    CG_NDR *    pParamOrFieldNode;

    pCCB = GetCCB();

    pParamOrFieldNode = pCCB->GetLastPlaceholderClass();

    if ( pParamOrFieldNode->GetCGID() == ID_CG_PARAM )
        ((CG_PARAM *)pParamOrFieldNode)->SetUnionFormatStringOffset( Offset );
    else
        ((CG_FIELD *)pParamOrFieldNode)->SetUnionFormatStringOffset( Offset );
}

long                    
CG_UNION::GetFormatStringOffset()
{
    CCB *       pCCB;
    CG_NDR *    pParamOrFieldNode;

    pCCB = GetCCB();

    pParamOrFieldNode = pCCB->GetLastPlaceholderClass();

    if ( pParamOrFieldNode->GetCGID() == ID_CG_PARAM )
        return ((CG_PARAM *)pParamOrFieldNode)->GetUnionFormatStringOffset();
    else
        return ((CG_FIELD *)pParamOrFieldNode)->GetUnionFormatStringOffset();
}

void
CG_ENCAPSULATED_STRUCT::GenNdrPointerFixUp( CCB *       pCCB,
                                            CG_STRUCT * pStruct )
{
    //
    // For an encapsulated struct, call this method on the actual union. 
    // Remember that the encap struct's child is a CG_FIELD whose sibling's
    // child will be the actual union.
    //
    ((CG_UNION*)(GetChild()->GetSibling()->GetChild()))->
        GenNdrPointerFixUp( pCCB, pStruct );
}

void
CG_UNION::GenNdrPointerFixUp( CCB *       pCCB,
                              CG_STRUCT * pStruct )
{
    CG_ITERATOR     Iterator;
    CG_NDR *        pMember;
    CG_NDR *        pNdr;
    long            OffsetOffset;

    if ( IsInFixUp() )
        return;

    SetFixUpLock( TRUE );

    OffsetOffset = GetNdrSizeAndArmDescriptionOffset() + 4;

    GetMembers( Iterator );

    while ( ITERATOR_GETNEXT( Iterator, pMember ) )
        {
        if ( ! pMember->GetChild() ||
             ! pMember->GetChild()->GetChild() )
            {
            OffsetOffset += 6;
            continue;
            }

        //
        // Child of the case is a CG_FIELD - get it's child to get the 
        // actual Ndr entity.
        //
        pNdr = (CG_NDR *) pMember->GetChild()->GetChild();

        if ( pNdr == pStruct )
            {
            //
            // Patch up the offset.
            //
            OffsetOffset += 4;

            pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - OffsetOffset,
                        OffsetOffset );

            OffsetOffset += 2;
            continue;
            }

        if ( (pNdr->GetCGID() == ID_CG_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_PTR) ||
             (pNdr->GetCGID() == ID_CG_SIZE_LENGTH_PTR) )
            {
            CG_POINTER * pPointer = (CG_POINTER *) pNdr;

            //
            // Check if we're ready for this guy yet.
            //
            if ( pPointer->GetFormatStringOffset() == -1 ) 
                continue;

            // Get the pointee.
            pNdr = (CG_NDR *) pNdr->GetChild();

            //
            // If the pointer's pointee is the struct we're checking for,
            // then patch up the pointer's offset_to_description<2> field.
            //
            if ( pNdr == pStruct )
                {
                long    PointerOffset;

                //
                // Get the offset in the format string where the
                // offset_to_description<2> field of the pointer is.
                //
                PointerOffset = pPointer->GetFormatStringOffset() + 2;

                pCCB->GetFormatString()->PushShortOffset(
                        pStruct->GetFormatStringOffset() - PointerOffset,
                        PointerOffset );

                OffsetOffset += 6;
                continue;
                }
            }

        //
        // Continue the chase if necessary.
        //
        if ( pNdr->IsStruct() || pNdr->IsUnion() || pNdr->IsArray() )
            pNdr->GenNdrPointerFixUp( pCCB, pStruct );

        OffsetOffset += 6;
        }

    SetFixUpLock( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\cmdutil.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 4710 4706)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <direct.h>
#include <io.h>
#include <time.h>

#include "errors.hxx"
#include "cmdana.hxx"
#include "stream.hxx"
#include "midlvers.h"

extern    _swenum           SearchForSwitch( char ** );
extern    void              ReportUnimplementedSwitch( short );
extern    char    *         SwitchStringForValue( unsigned short );
extern    STATUS_T          SelectChoice( const CHOICE *, char *, short *);

const __int64 iMagic = 77736876677768;

CHOICE PrefixChoices[] =
    {
         { "client"         , PREFIX_CLIENT_STUB }
        ,{ "server"         , PREFIX_SERVER_MGR }
        ,{ "switch"         , PREFIX_SWICH_PROTOTYPE }
        ,{ "cstub"          , PREFIX_CLIENT_STUB }
        ,{ "sstub"          , PREFIX_SERVER_MGR }
        ,{ "all"            , PREFIX_ALL }
        ,{ 0                , 0 }
    };

_cmd_arg::_cmd_arg()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    The constructor

 Arguments:

    None.

 Return Value:

    NA.

 Notes:

----------------------------------------------------------------------------*/
{
    switch_def_vector[0]    = switch_def_vector[1] = switch_def_vector[2] =
                              switch_def_vector[3] = switch_def_vector[4] = 0;
    fClient                 = CLNT_STUB;
    fServer                 = SRVR_STUB;

    Env                     = ENV_WIN32;
    CharOption              = CHAR_SIGNED;
    fMintRun                = FALSE;
    fIsNDR64Run             = FALSE;
    fIsNDRRun               = FALSE;
    fIs2ndCodegenRun        = FALSE;
    fNeedsNDR64Header       = FALSE;
    
    MajorVersion            = rmj;
    MinorVersion            = rmm;
    UpdateNumber            = rup;

    ErrorOption             = ERROR_NONE;
    WireCompatOption        = 0;
    ConfigMask              = 0;
    MSCVersion              = 0;
    fShowLogo               = true;

    // NdrVersionControl has a default constructor so it gets initialized.

    OptimFlags              = OPTIMIZE_NONE;
    OptimLevel              = OPT_LEVEL_OS;
    TargetSystem            = NOTARGET;

    iArgV                   = 0;
    cArgs                   = 0;
    WLevel                  = 1;

    ZeePee                  = DEFAULT_ZEEPEE;
    EnumSize                = 4;
    LocaleId                = 0;

    fDoubleFor64            = FALSE;
    fHasAppend64            = FALSE;

    szCompileTime[0]        = 0;
    szCompilerVersion[0]    = 0;

    pInputFNSwitch          =
    pOutputPathSwitch       =
    pCStubSwitch            =
    pSStubSwitch            =
    pHeaderSwitch           =
    pAcfSwitch              = (filename_switch *)NULL;

    pIIDSwitch              =
    pDllDataSwitch          =
    pProxySwitch            =
    pProxyDefSwitch         =
    pTlibSwitch             =
    pNetmonStubSwitch       =
    pNetmonStubObjSwitch    =
    pRedirectOutputSwitch   = (filename_switch *)NULL;

    pSwitchPrefix           = new pair_switch( &PrefixChoices[0] );
    pSwitchSuffix           = (pair_switch *)0;

    pDSwitch                =
    pISwitch                =
    pUSwitch                = (multiple_switch *)NULL;

    pCppCmdSwitch           =
    pCppOptSwitch           =
    pMSCVerSwitch           =
    pDebug64Switch          =
    pDebug64OptSwitch       = (onetime_switch *) NULL;

}

BOOL
CMD_ARG::IsValidZeePee(
    long        NewZeePee
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Tests if the argument is a valid packing level.

 Arguments:

    NewZeePee    -    Packing level.

 Return Value:

    TRUE if the argument is valid.

 Notes:

    Valid packing levels are nonzero powers of 2 less then 2^16.


----------------------------------------------------------------------------*/
{

    switch( NewZeePee )
        {
        case (1 << 0):
        case (1 << 1):
        case (1 << 2):
        case (1 << 3):
        case (1 << 4):
        case (1 << 5):
        case (1 << 6):
        case (1 << 7):
        case (1 << 8):
        case (1 << 9):
        case (1 << 10):
        case (1 << 11):
        case (1 << 12):
        case (1 << 13):
        case (1 << 14):
        case (1 << 15):
            return TRUE;
        default:
            return FALSE;
        }

}

void
CMD_ARG::SwitchDefined(
    short    sw
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set switch to be defined.

 Arguments:

    sw    - switch number.

 Return Value:

    None.

 Notes:

    set the switch definition vector bit.
----------------------------------------------------------------------------*/
    {
    switch_def_vector[ sw / 32 ] |=
            (ulong)( (ulong)0x1 << (ulong)( (ulong)sw % 32 ) );
    }

char *
CMD_ARG::GetOutputPath()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the output path.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

    Reconstitute the path name from the outputpath switch, if nothing
    was specified, put in a path and a slash at the end.

----------------------------------------------------------------------------*/
{
    char        agName[ _MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    char    *    pOut;
    char        flag = 0;

    strcpy( agName, pOut = pOutputPathSwitch->GetFileName() );

    if( agName[0] == '\0' )
        {
        strcpy(agName, ".\\"), flag = 1;
        }

    if( flag )
        {
        pOut = new char [strlen( agName ) + 1];
        strcpy( pOut , agName );
        pOutputPathSwitch->SetFileName( pOut );
        }
    return pOut;
}

char *
CMD_ARG::GetMinusISpecification()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get the consolidate -i specification, without the -I characters in them

 Arguments:

    none.

 Return Value:

    pointer to  a buffer containing the consolidated -i options. If the -i
    is not specified, then return a null.

    the returned area (if the pointer returned is not null) can be deleted
    by the caller.

 Notes:

    GetConsolidatedLength will always return a buffer size including the -I
    characters. We can safely assume, that since we are stripping those
    characters, the length returned is sufficient, even if we are appending
    a ; after each -I option

    Also assume that the -I specification buffer always has the -I to start
    with.

----------------------------------------------------------------------------*/
{
    char    *    pMinusI;
    char    *    pTemp;

    if( IsSwitchDefined( SWITCH_I ) )
        {
        pMinusI        = new char[ pISwitch->GetConsolidatedLength() + 1];
        pMinusI[0]    = '\0';

        pISwitch->Init();

        size_t ActualOffset;
        while ( ( pTemp = pISwitch->GetNext( &ActualOffset ) ) != 0 )
            {
            strcat( pMinusI, pTemp+ActualOffset );
            strcat( pMinusI, ";");
            }
        return pMinusI;
        }
    else
        return (char *)0;
}

/*****************************************************************************
 *    filename_switch member functions
 *****************************************************************************/
filename_switch::filename_switch(
    char    *        pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    constructor

 Arguments:

    pointer to the filename argument.

 Return Value:

    NA.

 Notes:

    set the filename.

----------------------------------------------------------------------------*/
    {
    pFullName = (char *)NULL;
    if( pThisArg )
        {
        SetFileName( pThisArg );
        }
    }

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    consructor.

 Arguments:

    filename components.

 Return Value:

    NA.

 Notes:

    set the file names.

----------------------------------------------------------------------------*/
filename_switch::filename_switch(
    char    *    pD,
    char    *    pP,
    char    *    pN,
    char    *    pE,
    char    *    pS )
    {
    pFullName = (char *)NULL;
    SetFileName( pD, pP, pN, pE, pS );
    }

filename_switch::~filename_switch()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    KABOOOM !

 Arguments:

    None.

 Return Value:

    Huh ?

 Notes:

----------------------------------------------------------------------------*/
    {

    if( pFullName )
        delete pFullName;
    }


void
filename_switch::SetFileName(
    char    *    pName
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    set filename

 Arguments:

    pName    -    filename

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    if( pFullName )
        delete pFullName;
    pFullName = new char [strlen(pName) + 1];
    strcpy( pFullName, pName );
    }

void
filename_switch::SetFileName(
    char    *    pD,
    char    *    pP,
    char    *    pN,
    char    *    pE,
    char    *    pS
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    set file name, given its components.

 Arguments:

    pD    -    pointer to drive name ( can be null );
    pP    -    pointer to path name ( can be null );
    pN    -    pointer to name ( can be null );
    pE    -    pointer to extension name ( can be null );
    pS    -    pointer to suffix.

 Return Value:

    None.

 Notes:

    The suffix is added to the filename if necesary. This routine is useful
    if we need to set the filename in partial name set operations. Any
    filename components previously set are overriden.

----------------------------------------------------------------------------*/
{
    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_DIR ];
    char    agBaseName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];
    short    len = 0;


    if( pFullName )
        {
        // modify only those portions of the filename that the
        // caller passed in

        _splitpath( pFullName, agDrive, agPath, agBaseName, agExt );

        delete pFullName;
        }
    else
        {

        // this is the first time the name is being set up.

        agDrive[0] = agPath[0] = agBaseName[0] = agExt[0] = '\0';

        }
    
    if(!pD) pD = agDrive;
    if(!pP) pP = agPath;
    if(!pN) pN = agBaseName;
    if(!pS) pS = "";
    if(!pE) pE = agExt;
    

    len = short(strlen( pD ) + strlen( pP ) + strlen( pN ) + strlen( pS ) + strlen( pE ) + 1);
    pFullName = new char[ len ];

    strcpy( pFullName, pD );
    strcat( pFullName, pP );
    strcat( pFullName, pN );
    strcat( pFullName, pS );
    strcat( pFullName, pE );
    
}

void
filename_switch::TransformFileNameForOut(
    char    *    pD,
    char    *    pP)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    transform file name to incorporate the output path, given its drive
    and path components.

 Arguments:

    pD    -    pointer to drive name ( can be null );
    pP    -    pointer to path name ( can be null );

 Return Value:

    None.

 Notes:

    If the filename switch does not have the path component, the path specified
    by pP overrides it. If it does not have the drive component, the the drive
    specified by pD overrides it.
----------------------------------------------------------------------------*/
    {
    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_DIR ];
    char    agPath1[ _MAX_DIR ];
    char    agName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];
    BOOL    fTransformed = FALSE;

    if( pFullName )
        {
        _splitpath( pFullName, agDrive, agPath, agName, agExt );

        // if the original name did not have the  drive component, derive it
        // from the specified one.

        if( (agDrive[0] == '\0')    &&
            (agPath[0] != '\\' )    &&
            (agPath[0] != '/' ) )
            {
            if( pD  && (*pD) )
                strcpy( agDrive, pD );
            if( pP && (*pP ) )
                {
                strcpy( agPath1, pP );
                strcat( agPath1, agPath );
                }
            else
                strcpy( agPath1, agPath );

            fTransformed = TRUE;
            }
        }

    if( fTransformed )
        {
        delete pFullName;
        pFullName = new char [  strlen( agDrive )   +
                                strlen( agPath1 )   +
                                strlen( agName )    +
                                strlen( agExt )     +
                                1 ];
        strcpy( pFullName, agDrive );
        strcat( pFullName, agPath1 );
        strcat( pFullName, agName );
        strcat( pFullName, agExt );
        }
    }

char *
filename_switch::GetFileName()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Getfile name.

 Arguments:

    none.

 Return Value:

    the filename.

 Notes:

----------------------------------------------------------------------------*/
{
    return pFullName;
}

void
filename_switch::GetFileNameComponents(
    char    *    pD,
    char    *    pP,
    char    *    pN,
    char    *    pE
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get file name components.

 Arguments:

    pD    -    pointer to drive name area.
    pP    -    pointer to path name area.
    pN    -    pointer to name area.
    pE    -    pointer to extension area.

 Return Value:

    None.

 Notes:

    Assume that all pointers pass the right size buffers. I dont check here.
    Useful to get the filename components desired.

----------------------------------------------------------------------------*/
{

    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_DIR ];
    char    agBaseName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];


    _splitpath( pFullName ? pFullName : "" ,
                agDrive, agPath, agBaseName, agExt );

    if( pD ) strcpy( pD , agDrive );
    if( pP ) strcpy( pP , agPath );
    if( pN ) strcpy( pN , agBaseName );
    if( pE ) strcpy( pE , agExt );


}

/*****************************************************************************
 *    multiple_switch member functions
 *****************************************************************************
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    constructor.

 Arguments:

    argument to switch. Actual argument offset.

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
multiple_switch::multiple_switch(
    char    *    pArg,
    size_t       ActualArgOffset )
{
    pFirst = pCurrent = (OptList *)NULL;
    if ( pArg )
        {
        Add( pArg, ActualArgOffset );
        }
}

void
multiple_switch::Add(
    char    *    pValue,
    size_t       ActualOffset
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Add another argument to the multiple specification switch.

 Arguments:

    pValue    -    the argument.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    OptList    *    pOpt    = pFirst;
    OptList    *    pNew    = new OptList;

    pNew->pNext        = (OptList *)NULL;
    pNew->pStr         = pValue;
    pNew->ActualOffset = ActualOffset;

    // determine if argument needs quotes
    bool NeedsQuotes = false;
    // skip to the first character of the switch argument.
    pValue += ActualOffset;
    while( *pValue && !(NeedsQuotes = !!isspace(*pValue++)) ); 
    pNew->NeedsQuotes = NeedsQuotes;

    // link it up

    while( pOpt && pOpt->pNext ) pOpt = pOpt->pNext;

    if( !pOpt )
        pCurrent = pFirst = pNew;
    else
        pOpt->pNext = pNew;

    }

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Init a walk of the multiple input switch.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
void
multiple_switch::Init()
{
    pCurrent = pFirst;
}

char *
multiple_switch::GetNext( size_t *pActualOffset, bool *pNeedsQuotes )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the next argument to theis switch.

 Arguments:

    None.

 Return Value:

    pointer to the next argument.

 Notes:

----------------------------------------------------------------------------*/
    {
    char *  pValue = (char *)NULL;

    if(pCurrent)
        {
        pValue   = pCurrent->pStr;
        if ( pActualOffset )
            {
            *pActualOffset = pCurrent->ActualOffset;
            }
        if ( pNeedsQuotes )
            {
            *pNeedsQuotes = pCurrent->NeedsQuotes;
            }
        pCurrent = pCurrent->pNext;
        }
    return pValue;
    }

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get all the options to the multiple options switch, consolidated into
    a buffer.

 Arguments:

    None.

 Return Value:

    pointer to a buffer containing all the concatenated arguments.

 Notes:

----------------------------------------------------------------------------*/
char *
multiple_switch::GetConsolidatedOptions( bool AddQuotes )
    {
#define OPTION_GAP_STRING() (" ")
#define OPTION_GAP_LENGTH() (1)

    int         len;
    char   *    pReturn = 0;

    len = GetConsolidatedLength( AddQuotes );

    // consolidate the options into 1

    if ( len  && ( pReturn = new char[ len + 1] ) != 0 )
        {
        char *  pTemp;

        *pReturn = '\0';
        Init();

        size_t ActualOffset;
        bool NeedsQuotes;
        while ( ( pTemp = GetNext(&ActualOffset, &NeedsQuotes ) ) != 0)
            {

            if ( NeedsQuotes && AddQuotes )
                {
                char *pTempReturn = pReturn + strlen( pReturn );
                memcpy( pTempReturn, pTemp, ActualOffset );
                sprintf( pTempReturn + ActualOffset, 
                         "\"%s\"%s", pTemp + ActualOffset, OPTION_GAP_STRING() );
                }
            else 
                {
                strcat( pReturn, pTemp );
                strcat( pReturn, OPTION_GAP_STRING() );                
                }
            }
        }

    return pReturn;
    }

short
multiple_switch::GetConsolidatedLength( bool AddQuotes )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the length of the consolidated options.

 Arguments:

    None.

 Return Value:

    length of the options.

 Notes:

----------------------------------------------------------------------------*/
    {
    char    *   pReturn;
    short       len = 0;

    Init();
    bool NeedsQuotes;
    while ( ( pReturn = GetNext(NULL, &NeedsQuotes ) ) != 0 )
        {
        len = short(len + strlen( pReturn ) + OPTION_GAP_LENGTH());
        if ( AddQuotes && NeedsQuotes ) len += 2; //Add space for quotes
        }
    return len;
    }

#undef OPTION_GAP_STRING
#undef OPTION_GAP_LENGTH

/*****************************************************************************
 *    onetime_switch member functions
 *****************************************************************************/
onetime_switch::onetime_switch(
    char    *    pArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    constructor.

 Arguments:

    pArg    -    pointer to switch argument.

 Return Value:

    NA.

 Notes:

----------------------------------------------------------------------------*/
{
    if( pArg )
        {
        pOpt = new char[ strlen( pArg ) + 1];
        strcpy( pOpt, pArg );
        }
    else
        pOpt = (char *)NULL;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    destructor.

 Arguments:

    None.

 Return Value:

    NA.

 Notes:

----------------------------------------------------------------------------*/
onetime_switch::~onetime_switch()
{
    if( pOpt )
        delete pOpt;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the option string.

 Arguments:

    None.

 Return Value:

    the option string.

 Notes:

----------------------------------------------------------------------------*/
char *
onetime_switch::GetOption()
{
    return pOpt;
}

short
onetime_switch::GetLength()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get length of the option.

 Arguments:

    None.

 Return Value:

    the length of the option.

 Notes:

----------------------------------------------------------------------------*/
{
    return (short)strlen( pOpt );
}

typedef char*   PSTR;

pair_switch::pair_switch(
    const CHOICE * pValidChoices )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    pair_switch_constructor

 Arguments:

    pValidChoiceArray    - the array of valid choices (this is assumed
                          pre-allocated).

 Return Value:

    NA

 Notes:


----------------------------------------------------------------------------*/
{
    short        MaxIndex    = 0;
    CHOICE *    pCurChoice    = (CHOICE *) pValidChoices;

    pArrayOfChoices = pCurChoice;

    // find the size of the pair array
    while ( pCurChoice->pChoice )
        {
        if ( pCurChoice->Choice > MaxIndex )
            MaxIndex = pCurChoice->Choice;
        pCurChoice++;
        }

    ArraySize = short(MaxIndex + 1);
    pUserStrings = new PSTR [ ArraySize ];

    for ( int i = 0; i <= MaxIndex; i++ )
        pUserStrings[i] = NULL;

    Current = -1;
}

void
pair_switch::AddPair(
    short   Sys,
    char *  pUsr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    add another prefix pair

 Arguments:

    Sys    - the system-defined string key
    pUsr   - the user-defined string value.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{    
    pUserStrings[ Sys ] = pUsr;
}    

char *
pair_switch::GetUserDefinedEquivalent(
    short   Sys )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    get the user defined prefix corresponding to the system defined prefix.

 Arguments:

    pSystemDefined  - the system defined prefix for which the user defined
                      prefix is being searched.

 Return Value:

    The user defined prefix , if it is defined. If not, return the input

 Notes:

----------------------------------------------------------------------------*/
{
    return pUserStrings[ Sys ];

}
short
pair_switch::GetIndex(
    char    *    pGivenString )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    search is the array of choices, if this string is a valid system known
    string

 Arguments:

    pGivenString   - the string to be searched for.

 Return Value:

    an index into the array of choice , -1 if the given string is not found.

 Notes:

----------------------------------------------------------------------------*/
{
    int         i;
    char  *     p;

    for( i = 0; ( p = (char *)pArrayOfChoices[ i ].pChoice ) != 0 ; ++i )
        {
        if( strcmp( p, pGivenString ) == 0 )
            return pArrayOfChoices[ i ].Choice;
        }
    return -1;
}

BOOL
CMD_ARG::IsPrefixDifferentForStubs()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 see if any prefix for client or server or switch are different

 Arguments:

    None.

 Return Value:

    BOOL - true if different prefix strings.

 Notes:

----------------------------------------------------------------------------*/
{

    char * pCPrefix;
    char * pSPrefix;
    char * pSwPrefix;

    pCPrefix = GetUserPrefix( PREFIX_CLIENT_STUB );
    pSPrefix = GetUserPrefix( PREFIX_SERVER_MGR );
    pSwPrefix = GetUserPrefix( PREFIX_SWICH_PROTOTYPE );

    if ( !pCPrefix )
        pCPrefix = "";
    if ( !pSPrefix )
        pSPrefix = "";
    if ( !pSwPrefix )
        pSwPrefix = "";

    return (BOOL) strcmp( pCPrefix, pSPrefix ) ||
           (BOOL) strcmp( pCPrefix, pSwPrefix ) ||
           (BOOL) strcmp( pSPrefix, pSwPrefix );

}

short            
pair_switch::GetNext( char ** pSys, char ** pUser )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 Get the Next pair of system & user values

 Arguments:

    None.

 Return Value:

    index in array of user value

 Notes:

----------------------------------------------------------------------------*/
{
    
    // find the next non-null user string
    Current++;

    while ( ( Current < ArraySize) && !pUserStrings[ Current ] )
        Current++;

    if ( Current == ArraySize )
        return FALSE;

    // search for the first choice that matches this index
    *pUser = pUserStrings[Current];
    for ( short i = 0; i < ArraySize; i++ )
        {
        if ( ( pArrayOfChoices[i].Choice = Current ) != 0 )
            {
            *pSys = (char *)pArrayOfChoices[i].pChoice;
            return TRUE;
            }
        }
    return FALSE;
}


void
CMD_ARG::EmitConfirm(
    ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Emit confirm the arguments by dumping onto a stream in a more concise
    format.

 Arguments:

    pStream - the stream to dump it to.

 Return Value:

    None.

----------------------------------------------------------------------------*/
{
    short       Option;
    char       *pEnvName, *pOptFlagName;
    char        Buffer[100];

    pStream->Write( "/* Compiler settings for " );
    if ( !pCommand->IsSwitchDefined( SWITCH_NO_STAMP ) ) 
        {
        pStream->Write( GetInputFileName() );
        if ( IsSwitchDefined( SWITCH_ACF ) )
            {
            pStream->Write( ", " );
            pStream->Write( GetAcfFileName() );
            }
        }
    else
        {
        char FileName[_MAX_FNAME];
        char Ext[_MAX_EXT];
        GetInputFileNameComponents(NULL, NULL, FileName, Ext);
        pStream->Write(FileName);
        pStream->Write(Ext);
        if ( IsSwitchDefined( SWITCH_ACF ) )
            {
            pStream->Write( ", " );
            GetAcfFileNameComponents(NULL, NULL, FileName, Ext);
            pStream->Write(FileName);
            pStream->Write(Ext);
            }
        }

    pStream->Write( ":" );
    pStream->NewLine();

    pOptFlagName = "Os";
    if( GetOptimizationFlags() & OPTIMIZE_INTERPRETER )
        {
        if( OptimFlags & OPTIMIZE_INTERPRETER_IX )
            pOptFlagName= "Ox";
        else if( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
            pOptFlagName= "Oicf";
        else if( GetOptimizationFlags() & OPTIMIZE_STUBLESS_CLIENT )
            pOptFlagName= "Oic";
        else
            pOptFlagName= "Oi";
        }

    pEnvName = (GetEnv() == ENV_WIN64) ? "Win64" 
                                       : "Win32";

    sprintf( Buffer, "    %s, W%d, Zp%d, env=%s (%s%s)",
             pOptFlagName,
             GetWarningLevel(),
             GetZeePee(),
             pEnvName,
             (IsDoubleRunFor64() ? "64b run" : "32b run"),
             (HasAppend64() ? ",appending" : "") );
    pStream->Write( Buffer );

    pStream->NewLine();
    pStream->Write("    protocol : " );
    switch ( TargetSyntax )
        {
        case SYNTAX_DCE: 
            pStream->Write("dce ");
            break;
        case SYNTAX_NDR64:
            pStream->Write("ndr64 ");
            break;
        case SYNTAX_BOTH:
            pStream->Write("all ");
            break;
        }

    if ( IsSwitchDefined( SWITCH_MS_EXT))
        pStream->Write( ", ms_ext" );
    if ( IsSwitchDefined( SWITCH_APP_CONFIG))
        pStream->Write( ", app_config" );
    if ( IsSwitchDefined( SWITCH_C_EXT))
        pStream->Write( ", c_ext" );
    if ( IsSwitchDefined( SWITCH_MS_UNION))
        pStream->Write( ", ms_union" );
    if ( IsSwitchDefined( SWITCH_OLDNAMES))
        pStream->Write( ", oldnames" );
    if ( IsSwitchDefined( SWITCH_ROBUST ))
        pStream->Write( ", robust" );
    if ( IsSwitchDefined( SWITCH_MS_CONF_STRUCT))
        pStream->Write( ", ms_conf_struct" );

    pStream->NewLine();

    strcpy( Buffer, "    error checks: " );
    Option = GetErrorOption();
    if( Option != ERROR_NONE )
        {
        if( Option & ERROR_ALLOCATION )
            strcat( Buffer, "allocation ");
        if( Option & ERROR_REF )
            strcat( Buffer, "ref ");
        if( Option & ERROR_BOUNDS_CHECK )
            strcat( Buffer, "bounds_check ");
        if( Option & ERROR_ENUM )
            strcat( Buffer, "enum ");
        if( Option & ERROR_STUB_DATA )
            strcat( Buffer, "stub_data ");
        }
    else
        strcat( Buffer, "none" );
    pStream->Write( Buffer );

    if ( 0 != WireCompatOption)
        {
        pStream->WriteOnNewLine( "    wire_compat options: " );

        if( ErrorOption & WIRE_COMPAT_ENUM16UNIONALIGN )
            pStream->Write( "enum16unionalign ");
            
        pStream->NewLine();
        }

    if ( IsSwitchDefined( SWITCH_NO_FMT_OPT))
        pStream->Write( ", no_format_optimization" );
    if ( IsSwitchDefined( SWITCH_RPCSS))
        pStream->Write( ", memory management on" );
    if ( IsSwitchDefined( SWITCH_NETMON))
        pStream->Write( ", NetMon" );
    if ( IsSwitchDefined( SWITCH_USE_EPV))
        pStream->Write( ", use_epv" );
    if ( IsSwitchDefined( SWITCH_NO_DEFAULT_EPV))
        pStream->Write( ", no_default_epv" );

    pStream->NewLine();

    pStream->Write( "    VC __declspec() decoration level: " );
    if ( GetMSCVer() < 1100 )
        pStream->Write( "  none " );
    else 
        {
        pStream->NewLine();
        pStream->Write( "         __declspec(uuid()), __declspec(selectany), __declspec(novtable)\n" );
        pStream->Write( "         DECLSPEC_UUID(), MIDL_INTERFACE()" );
        }
    pStream->NewLine();

#if defined(TARGET_RKK)
    switch ( TargetSystem )
        {
        case NT35:
            pTarget = "NT 3.5";
            break;
        case NT351:
            pTarget = "NT 3.51 and Win95";
            break;
        case NT40:
            pTarget = "NT 4.0";
            break;
        default:
            pTarget = "NT ???";
        }

    pStream->Write( "    Release: this stub is compatible with " );
    pStream->Write( pTarget );
    pStream->Write( " release" );
    pStream->NewLine();
    pStream->Write( "             or a later version of MIDL and RPC" );
    pStream->NewLine();
#endif

    pStream->Write( "*/" );
    pStream->NewLine();

}


// ISSUE-2000/08/03-mikew
// The ia64 C++ compiler is incorrectly optimizing memcpy in some cases.
// Mark the source buffer as unaligned to work around it.  To repro just run
// midlc in a debugger and it will align fault while parsing the command file

#ifndef UNALIGNED
#ifdef IA64
#define UNALIGNED __unaligned
#else
#define UNALIGNED 
#endif
#endif


#define CopyIntFromBuffer( buffer, dest ) memcpy( &dest, (UNALIGNED char *) (buffer), sizeof( dest ) ), pBuffer += sizeof( dest )


#define CopyStrFromBuffer( buffer, dest )   { \
                                            char *sz = dest; \
                                            while ( *buffer ) *sz++ = *buffer++;\
                                            *sz++ = 0; \
                                            buffer++; \
                                            }

char*
AllocCopyStrFromBuffer( char* buffer, char*& dest )
    {
    unsigned long ulSize = 0; 
    char* szt = buffer; 
    while ( *szt++ ) ulSize++; 
    char* sz = ( ulSize ) ? new char[ ulSize + 1 ] : 0; 
    dest = sz; 
    if ( sz ) 
        memcpy( sz, buffer, ulSize+1 ); 
    return buffer+ulSize+1;
    }

void
filename_switch::StreamIn( char*& pBuffer )
    {
    pBuffer = AllocCopyStrFromBuffer( pBuffer, pFullName );
    }

void
filename_switch::StreamOut( STREAM* stream )
    {
    stream->Write(pFullName);
    }

void
onetime_switch::StreamIn( char*& pBuffer )
    {
    pBuffer = AllocCopyStrFromBuffer( pBuffer, pOpt );
    }

void
onetime_switch::StreamOut( STREAM *stream )
    {
    stream->Write( pOpt );
    }

void
multiple_switch::StreamIn( char*& pBuffer )
    {
    unsigned long   ulCount = 0;

    CopyIntFromBuffer( pBuffer, ulCount );

    while ( ulCount-- )
        {
        char* sz = 0;
        size_t ActualOffset;
        CopyIntFromBuffer( pBuffer, ActualOffset );
        pBuffer = AllocCopyStrFromBuffer( pBuffer, sz );
        Add( sz, ActualOffset );
        }
    }

void
multiple_switch::StreamOut( STREAM* stream )
    {
    OptList*    pTemp = pFirst;
    unsigned long ulCount = 0;

    while ( pTemp )
        {
        ulCount++;
        pTemp = pTemp->pNext;
        }

    stream->Write(&ulCount, sizeof(ulCount));
    pTemp = pFirst;
    while ( pTemp )
        {
        stream->Write( &pTemp->ActualOffset, sizeof( pTemp->ActualOffset ) );
        stream->Write( pTemp->pStr );
        pTemp = pTemp->pNext;
        }
    }

void
pair_switch::StreamIn( char*& pBuffer )
    {
    CopyIntFromBuffer( pBuffer, ArraySize );

    pUserStrings = new PSTR [ ArraySize ];
    if ( pUserStrings )
        {
        for ( short i = 0; i < ArraySize; i++ )
            {
            pBuffer = AllocCopyStrFromBuffer( pBuffer, pUserStrings[i] );
            }
        }
    }

void
pair_switch::StreamOut( STREAM *stream )
    {
    stream->Write( &ArraySize, sizeof( ArraySize ) );
    for ( short i = 0 ; i < ArraySize ; i++ )
        {
        stream->Write( pUserStrings[i] );
        }
    }

void 
CMD_ARG::StreamOut( STREAM *stream )
    {
#define Stream( x ) ( stream->Write( &x, sizeof( x ) ) )
    Stream( iMagic );
    Stream( MajorVersion );
    Stream( MinorVersion );
    Stream( UpdateNumber );
    Stream( fHasAppend64 );
    Stream( switch_def_vector );
    Stream( fClient );
    Stream( fServer );
    Stream( Env );
    Stream( CharOption );
    Stream( fMintRun );
    Stream( ErrorOption );
    Stream( WireCompatOption );
    Stream( ConfigMask );
    Stream( MSCVersion );
    Stream( fShowLogo );
    // BUGBUG: VersionControl is a class
    Stream( VersionControl );
    Stream( OptimFlags );
    Stream( OptimLevel );
    Stream( TargetSystem );
    Stream( iArgV );   
    Stream( cArgs );
    Stream( WLevel );
    Stream( ZeePee );
    Stream( EnumSize );
    Stream( LocaleId );
    Stream( fDoubleFor64 );
    Stream( TargetSyntax );
#undef Stream

    stream->Write( &szCompileTime[0] );
    stream->Write( &szCompilerVersion[0] );

    //
    // The following switches write a single NULL character is they are not
    // present on the command line
    //

#define StreamIfNecessary( x ) ( x ? x->StreamOut(stream) : stream->Write( '\0' ) )

    StreamIfNecessary( pInputFNSwitch );
    StreamIfNecessary( pOutputPathSwitch );
    StreamIfNecessary( pCStubSwitch );
    StreamIfNecessary( pSStubSwitch );
    StreamIfNecessary( pHeaderSwitch );
    StreamIfNecessary( pAcfSwitch );
    StreamIfNecessary( pIIDSwitch );
    StreamIfNecessary( pDllDataSwitch );
    StreamIfNecessary( pProxySwitch );
    StreamIfNecessary( pTlibSwitch );
    StreamIfNecessary( pNetmonStubSwitch );
    StreamIfNecessary( pNetmonStubObjSwitch );
    StreamIfNecessary( pRedirectOutputSwitch );

    StreamIfNecessary( pCppCmdSwitch );
    StreamIfNecessary( pCppOptSwitch );
    StreamIfNecessary( pMSCVerSwitch );
    StreamIfNecessary( pDebug64Switch );
    StreamIfNecessary( pDebug64OptSwitch );

#undef StreamIfNecessary


    // 
    // The following switches write (long) 0 if they are not present on
    // the command line
    //

#define StreamIfNecessary( x )                                          \
                    {                                                   \
                        unsigned long zero = 0;                         \
                        x  ? x->StreamOut(stream)                       \
                           : stream->Write( &zero, sizeof( zero ) );    \
                    }

    StreamIfNecessary( pSwitchPrefix );
    StreamIfNecessary( pSwitchSuffix );

    StreamIfNecessary( pDSwitch );
    StreamIfNecessary( pISwitch );
    StreamIfNecessary( pUSwitch );

#undef StreamIfNecessary
    }

STATUS_T
CMD_ARG::StreamIn( char* pBuffer )
    {
    __int64 magicNumber = 0;

    CopyIntFromBuffer( pBuffer, magicNumber );
    if ( magicNumber != iMagic )
        {
        return BAD_CMD_FILE;
        }

    CopyIntFromBuffer( pBuffer, MajorVersion );
    CopyIntFromBuffer( pBuffer, MinorVersion );
    CopyIntFromBuffer( pBuffer, UpdateNumber );

    if ( ( MajorVersion != rmj ) || 
         ( MinorVersion != rmm ) || 
         ( UpdateNumber != rup ) )
        {
        return INCONSIST_VERSION;
        }
        
    CopyIntFromBuffer( pBuffer, fHasAppend64 );
    CopyIntFromBuffer( pBuffer, switch_def_vector );
    CopyIntFromBuffer( pBuffer, fClient );
    CopyIntFromBuffer( pBuffer, fServer );
    CopyIntFromBuffer( pBuffer, Env );
    CopyIntFromBuffer( pBuffer, CharOption );
    CopyIntFromBuffer( pBuffer, fMintRun );
    CopyIntFromBuffer( pBuffer, ErrorOption );
    CopyIntFromBuffer( pBuffer, WireCompatOption );
    CopyIntFromBuffer( pBuffer, ConfigMask );
    CopyIntFromBuffer( pBuffer, MSCVersion );
    CopyIntFromBuffer( pBuffer, fShowLogo );
    CopyIntFromBuffer( pBuffer, VersionControl );
    CopyIntFromBuffer( pBuffer, OptimFlags );
    CopyIntFromBuffer( pBuffer, OptimLevel );
    CopyIntFromBuffer( pBuffer, TargetSystem );
    CopyIntFromBuffer( pBuffer, iArgV );
    CopyIntFromBuffer( pBuffer, cArgs );
    CopyIntFromBuffer( pBuffer, WLevel );
    CopyIntFromBuffer( pBuffer, ZeePee );
    CopyIntFromBuffer( pBuffer, EnumSize );   
    CopyIntFromBuffer( pBuffer, LocaleId );
    CopyIntFromBuffer( pBuffer, fDoubleFor64 );
    CopyIntFromBuffer( pBuffer, TargetSyntax );
        
    CopyStrFromBuffer( pBuffer, &szCompileTime[0] );
    CopyStrFromBuffer( pBuffer, &szCompilerVersion[0] );

    pInputFNSwitch          = new filename_switch();
    pOutputPathSwitch       = new filename_switch();
    pCStubSwitch            = new filename_switch();
    pSStubSwitch            = new filename_switch();
    pHeaderSwitch           = new filename_switch();
    pAcfSwitch              = new filename_switch();
    pIIDSwitch              = new filename_switch();
    pDllDataSwitch          = new filename_switch();
    pProxySwitch            = new filename_switch();
    pTlibSwitch             = new filename_switch();
    pNetmonStubSwitch       = new filename_switch();
    pNetmonStubObjSwitch    = new filename_switch();
    pRedirectOutputSwitch   = new filename_switch();

    pCppCmdSwitch           = new onetime_switch();
    pCppOptSwitch           = new onetime_switch();
    pMSCVerSwitch           = new onetime_switch();
    pDebug64Switch          = new onetime_switch();
    pDebug64OptSwitch       = new onetime_switch();

    pSwitchPrefix           = new pair_switch( &PrefixChoices[0] );
    pSwitchSuffix           = new pair_switch( &PrefixChoices[0] );

    pDSwitch                = new multiple_switch();
    pISwitch                = new multiple_switch();
    pUSwitch                = new multiple_switch();

    pInputFNSwitch->StreamIn( pBuffer );
    pOutputPathSwitch->StreamIn( pBuffer );
    pCStubSwitch->StreamIn( pBuffer );
    pSStubSwitch->StreamIn( pBuffer );
    pHeaderSwitch->StreamIn( pBuffer );
    pAcfSwitch->StreamIn( pBuffer );
    pIIDSwitch->StreamIn( pBuffer );
    pDllDataSwitch->StreamIn( pBuffer );
    pProxySwitch->StreamIn( pBuffer );
    pTlibSwitch->StreamIn( pBuffer );
    pNetmonStubSwitch->StreamIn( pBuffer );
    pNetmonStubObjSwitch->StreamIn( pBuffer );
    pRedirectOutputSwitch->StreamIn( pBuffer );

    pCppCmdSwitch->StreamIn( pBuffer );
    pCppOptSwitch->StreamIn( pBuffer );
    pMSCVerSwitch->StreamIn( pBuffer );
    pDebug64Switch->StreamIn( pBuffer );
    pDebug64OptSwitch->StreamIn( pBuffer );

    pSwitchPrefix->StreamIn( pBuffer );
    pSwitchSuffix->StreamIn( pBuffer );

    pDSwitch->StreamIn( pBuffer );
    pISwitch->StreamIn( pBuffer );
    pUSwitch->StreamIn( pBuffer );

    // HACK ALERT: we want to generate right header if 
    // -protocol all and no -env is specified. 
    if ( ( TargetSyntax == SYNTAX_BOTH ) && 
         ( Env == ENV_WIN32 ) && 
         !IsSwitchDefined( SWITCH_INTERNAL ) )
        {
        TargetSyntax = SYNTAX_DCE;
        if ( !IsSwitchDefined( SWITCH_ENV) )
            SetNeedsNDR64Header();
        }

    if ( NeedsNDR64Run() )
        GetNdrVersionControl().SetHasMultiTransferSyntax();
         
    
    return STATUS_OK;
    }

void
CMD_ARG::VerifyTargetSwitch()
{
    switch ( GetTargetSystem() )
        {
        case NT40:
            if ( GetNdrVersionControl().IsNdr50orLaterRequired() )
                MIDL_ASSERT( 0 );
            break;
        case NT50:
            if ( GetNdrVersionControl().IsNdr60orLaterRequired() )
                MIDL_ASSERT( 0 );
            break;
        default:
            break;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\debug.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    debug.cxx

 Abstract:

    assert and debugging routines

 Notes:


 Author:

    mzoran Feb-25-2000     Created.

 Notes:


 ----------------------------------------------------------------------------*/

 
#if defined(MIDL_ENABLE_ASSERTS)

#include "stdio.h"
#include "common.hxx"
#include "errors.hxx"

#include "windows.h"


#pragma warning(disable: 4702)      // unreachable code


int DisplayAssertMsg(char *pFileName, int LineNumber, char *pExpr )
{
    printf( "\nmidl : error MIDL%d : internal compiler problem -",
            I_ERR_UNEXPECTED_INTERNAL_PROBLEM );
    printf( " See documentation for suggestions on how to find a workaround.\n" );
    printf( "midl: Assertion failed: %s, file %s, line %d\n", pExpr, pFileName, LineNumber );

#if DBG
    if ( IsDebuggerPresent() )
        DebugBreak();
#endif

    exit( I_ERR_UNEXPECTED_INTERNAL_PROBLEM );

    // We return int because this fuction is called from the ternary operator
    // but it actually never returns because of the exit above.  Because it
    // returns int we can't use __declspec(noreturn).  Warnings about this 
    // unreachable return statement are supressed via pragma above.

    return I_ERR_UNEXPECTED_INTERNAL_PROBLEM;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\midldebug.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    midldebug.h

 Abstract:

    assert and debugging routines

 Notes:


 Author:

    mzoran Feb-25-2000     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#if !defined(__MIDLDEBUG_H__)
#define __MIDLDEBUG_H__

#if defined(MIDL_ENABLE_ASSERTS)

int DisplayAssertMsg(char *pFileName, int , char *pExpr );

#define MIDL_ASSERT( expr ) \
    ( ( expr ) ? 1 : DisplayAssertMsg( __FILE__ , __LINE__, #expr ) )
     
#else

#define MIDL_ASSERT( expr )

#endif

#endif // __MIDLDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\mem.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 )

#include "nulldefs.h"

#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include "common.hxx"
#include "errors.hxx"

unsigned long       TotalAllocation;

void * AllocateNew(
    size_t  size )
    {
    void * _last_allocation;

    if( (_last_allocation = malloc( size )) == 0 )
        {

        RpcError( 0,
                  0,
                  OUT_OF_MEMORY,
                  0 );

        exit( OUT_OF_MEMORY );
        }
    TotalAllocation += size;
    return _last_allocation;
    }

void  AllocateDelete( void * p )
{
if( p )
    free( (char *)p );
}

char * MIDLStrDup( char *p )
{

if (NULL == p)
   return p;

return strcpy( new char[ strlen(p) + sizeof('\0') ], p );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\errdb.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/****************************************************************************
 ZZZ	- error in all cases
 AZZ	- no error when : app_config
 AZM	- no error when : app_config + ms_ext
 ACZ	- no error when : app_config + c_ext
 ACM	- no error when : app_config + c_ext + ms_ext
 ZCZ	- no error when : c_ext
 ZCM	- no error when : c_ext + ms_ext
 ZZM	- no error when : ms_ext

 Therefore: The following are the configurations

 -ms_ext on:	 ZZM | ZCM | ACM | AZM
 ----------
 -c_ext on:		ZCM | ZCZ | ACM | ACZ
 ----------

 -ms_ext or -c_ext on:	ZZM | ZCM | ACM | AZM | ZCZ | ACZ 
 --------------------

 -app_config on : 	AZZ | AZM | ACZ | ACM
 ----------------
 ****************************************************************************/

#include "errors.hxx"

#define ERR_ALWAYS				( ZZZ )
#define MS_EXT_SET				( ZZM | ZCM | ACM | AZM )
#define C_EXT_SET				( ZCM | ZCZ | ACM | ACZ )
#define MS_OR_C_EXT_SET			( MS_EXT_SET | C_EXT_SET )
#define APP_CONFIG_SET			( AZZ | AZM | ACZ | ACM )

typedef struct errdb
	{
    unsigned int            inApplicableEnviron;

#ifdef RPCDEBUG
	unsigned	short	TestValue;
#endif // RPCDEBUG

	E_MASK					ErrMask;
	const char	*			pError;

	} ERRDB;

const ERRDB	ErrorDataBase[]	= {

 {
0, CHECK_ERR( NO_INPUT_FILE) 
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"missing source-file name"
}

,{
0, CHECK_ERR( INPUT_OPEN)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot open input file"
}

,{
0, CHECK_ERR( INPUT_READ)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"error while reading input file"
}

,{
0, CHECK_ERR( PREPROCESSOR_ERROR)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"error returned by the C preprocessor"
}

,{
0, CHECK_ERR( PREPROCESSOR_EXEC)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot execute C preprocessor"
}

,{
0, CHECK_ERR( NO_PREPROCESSOR)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot find C preprocessor"
}

,{
0, CHECK_ERR( PREPROCESSOR_INVALID )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"invalid C preprocessor executable"
}

,{
0, CHECK_ERR( SWITCH_REDEFINED)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"switch specified more than once on command line :"
}

,{
0, CHECK_ERR( UNKNOWN_SWITCH)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, NOWARN )
,"unknown switch"
}

,{
0, CHECK_ERR( UNKNOWN_ARGUMENT)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"unknown argument ignored"
}

,{
0, CHECK_ERR( UNIMPLEMENTED_SWITCH)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"switch not implemented"
}

,{
0, CHECK_ERR( MISSING_ARG)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"argument(s) missing for switch"
}

,{
0, CHECK_ERR( ILLEGAL_ARGUMENT)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"argument illegal for switch /"
}

,{
0, CHECK_ERR( BAD_SWITCH_SYNTAX)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"illegal syntax for switch"
}

,{
0, CHECK_ERR( NO_CPP_OVERRIDES)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"/no_cpp overrides /cpp_cmd and /cpp_opt"
}

,{
0, CHECK_ERR( NO_WARN_OVERRIDES)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"/W0 or /no_warn overrides warning-level switch"
}

,{
0, CHECK_ERR( INTERMEDIATE_FILE_CREATE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot create intermediate file"
}

,{
0, CHECK_ERR( UNUSED_ERROR_CODE1 )       // was SERVER_AUX_FILE_NOT_SPECIFIED        
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"Unused error message" 
}

,{
0, CHECK_ERR( OUT_OF_SYSTEM_FILE_HANDLES)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"out of system file handles"
}

,{
0, CHECK_ERR( UNUSED_ERROR_CODE2 )        // was BOTH_CSWTCH_SSWTCH
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"Unused error message"
}

,{
0, CHECK_ERR( CANNOT_OPEN_RESP_FILE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"cannot open response file"
}

,{
0, CHECK_ERR( ILLEGAL_CHAR_IN_RESP_FILE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"illegal character(s) found in response file"
}

,{
0, CHECK_ERR( MISMATCHED_PREFIX_PAIR)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"mismatch in argument pair for switch"
}

,{
0, CHECK_ERR( NESTED_RESP_FILE)
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"nested invocation of response files is illegal"
}


,{
0, CHECK_ERR( ABSTRACT_DECL )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"must specify /c_ext for abstract declarators" 
}

,{
0, CHECK_ERR( ACTUAL_DECLARATION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"instantiation of data is illegal; you must use \"extern\" or \"static\""
}

,{
0, CHECK_ERR( C_STACK_OVERFLOW)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"compiler stack overflow"
}

,{
0, CHECK_ERR( DUPLICATE_DEFINITION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"redefinition"
}

,{
0, CHECK_ERR( NO_HANDLE_DEFINED_FOR_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"[auto_handle] binding will be used"
}

,{
0, CHECK_ERR( OUT_OF_MEMORY) 
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"out of memory"
}

,{
0, CHECK_ERR( RECURSIVE_DEF)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"recursive definition"
}

,{
0, CHECK_ERR( REDUNDANT_IMPORT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"import ignored; file already imported :"
}

,{
0, CHECK_ERR( SPARSE_ENUM )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"sparse enums require /c_ext or /ms_ext"
}

,{
0, CHECK_ERR( UNDEFINED_SYMBOL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"undefined symbol"
}

,{
0, CHECK_ERR( UNDEFINED_TYPE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type used in ACF file not defined in IDL file"
}

,{
0, CHECK_ERR( UNRESOLVED_TYPE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unresolved type declaration"
}

,{
0, CHECK_ERR( WCHAR_CONSTANT_NOT_OSF )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of wide-character constants requires /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( WCHAR_STRING_NOT_OSF )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of wide character strings requires /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( WCHAR_T_ILLEGAL)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"inconsistent redefinition of type wchar_t"
}

,{
0, CHECK_ERR( TYPELIB_NOT_LOADED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"failed to load tlb in importlib:"
} 

,{
0, CHECK_ERR( TWO_LIBRARIES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"two library blocks"
}

,{
0, CHECK_ERR( NO_IDISPATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"the dispinterface statement requires a definition for IDispatch"
}

,{
0, CHECK_ERR( ERR_TYPELIB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error accessing type library"
}

,{
0, CHECK_ERR( ERR_TYPEINFO )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error accessing type info"
}

,{
0, CHECK_ERR( ERR_TYPELIB_GENERATION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error generating type library"
}

,{
0, CHECK_ERR( DUPLICATE_IID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicate id"
}

,{
0, CHECK_ERR( BAD_ENTRY_VALUE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal or missing value for entry attribute"
}

,{
0, CHECK_ERR( ASSUMING_CHAR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 5 )
,"error recovery assumes"
}

,{
0, CHECK_ERR( DISCARDING_CHAR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 5 )
,"error recovery discards"
}

,{
0, CHECK_ERR( BENIGN_SYNTAX_ERROR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"syntax error"
}

,{
0, CHECK_ERR( SYNTAX_ERROR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot recover from earlier syntax errors; aborting compilation"
}

,{
0, CHECK_ERR( UNKNOWN_PRAGMA_OPTION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"unknown pragma option"
}

,{
0, CHECK_ERR( UNIMPLEMENTED_FEATURE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"feature not implemented"
}

,{
0, CHECK_ERR( UNIMPLEMENTED_TYPE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type not implemented"
}

,{
0, CHECK_ERR( EXPR_DEREF_ON_NON_POINTER)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"non-pointer used in a dereference operation"
}

,{
0, CHECK_ERR( EXPR_DIV_BY_ZERO)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression has a divide by zero"
}

,{
0, CHECK_ERR( EXPR_INCOMPATIBLE_TYPES)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression uses incompatible types"
}

,{
0, CHECK_ERR( EXPR_INDEXING_NON_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"non-array expression uses index operator"
}

,{
0, CHECK_ERR( EXPR_LHS_NON_COMPOSITE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"left-hand side of expression does not evaluate to struct/union/enum"
}

,{
0, CHECK_ERR( EXPR_NOT_CONSTANT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"constant expression expected"
}

,{
0, CHECK_ERR( EXPR_NOT_EVALUATABLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression cannot be evaluated at compile time"
}

,{
0, CHECK_ERR( EXPR_NOT_IMPLEMENTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression not implemented"
}

,{
0, CHECK_ERR( NO_PTR_DEFAULT_ON_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"no [pointer_default] attribute specified, assuming [unique] for all unattributed pointers"
}

,{
ENV_WIN64, CHECK_ERR( NOT_OLEAUTOMATION_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater"
}

,{
0, CHECK_ERR( DERIVES_FROM_PTR_TO_CONF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] only parameter cannot be a pointer to an open structure"
}

,{
0, CHECK_ERR( DERIVES_FROM_UNSIZED_STRING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] only parameter cannot be an unsized string"
}

,{
0, CHECK_ERR( NON_PTR_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] parameter is not a pointer"
}

,{
0, CHECK_ERR( OPEN_STRUCT_AS_PARAM)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"open structure cannot be a parameter"
}

,{
0, CHECK_ERR( OUT_CONTEXT_GENERIC_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] context handle/generic handle must be specified as a pointer to that handle type"
}

,{
0, CHECK_ERR( CTXT_HDL_TRANSMIT_AS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"context handle must not derive from a type that has the [transmit_as] attribute"
}

,{
0, CHECK_ERR( PARAM_IS_ELIPSIS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot specify a variable number of arguments to a remote procedure"
}

,{
0, CHECK_ERR( VOID_PARAM_WITH_NAME)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"named parameter cannot be \"void\""
}

,{
0, CHECK_ERR( DERIVES_FROM_COCLASS_OR_MODULE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter derives from \"module\""
}

,{
0, CHECK_ERR( HANDLE_NOT_FIRST )
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"only the first parameter can be a binding handle; you must specify the /ms_ext switch"
}

,{
0, CHECK_ERR( PROC_PARAM_COMM_STATUS)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot use [comm_status] on both a parameter and a return type"
}

,{
0, CHECK_ERR( LOCAL_ATTR_ON_PROC)
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"[local] attribute on a procedure requires /ms_ext"
}

,{
0, CHECK_ERR( ILLEGAL_USE_OF_PROPERTY_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"property attributes may only be used with procedures"
}

,{
0, CHECK_ERR( MULTIPLE_PROPERTY_ATTRIBUTES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"a procedure may not have more than one property attribute"
}

,{
0, CHECK_ERR( ILLEGAL_COMBINATION_OF_ATTRIBUTES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"the procedure has an illegal combination of operation attributes"
}

,{
0, CHECK_ERR( CONFORMANT_ARRAY_NOT_LAST)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"field deriving from a conformant array must be the last member of the structure"
}

,{
0, CHECK_ERR( DUPLICATE_CASE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicate [case] label"
}

,{
0, CHECK_ERR( NO_UNION_DEFAULT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"no [default] case specified for discriminated union"
}

,{
0, CHECK_ERR( ATTRIBUTE_ID_UNRESOLVED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression cannot be resolved"
}

,{
0, CHECK_ERR( ATTR_MUST_BE_INT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression must be of integral type; no support for 64b expressions"
}

,{
0, CHECK_ERR( BYTE_COUNT_INVALID)
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"[byte_count] requires /ms_ext"
}
,{
0, CHECK_ERR( BYTE_COUNT_NOT_OUT_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[byte_count] can be applied only to out parameters of pointer type"
}

,{
0, CHECK_ERR( BYTE_COUNT_ON_CONF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[byte_count] cannot be specified on a pointer to a conformant array or structure"
}

,{
0, CHECK_ERR( BYTE_COUNT_PARAM_NOT_IN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter specifying the byte count is not [in] only or byte count parameter is not [out] only"
}

,{
0, CHECK_ERR( BYTE_COUNT_PARAM_NOT_INTEGRAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter specifying the byte count is not an integral type"
}

,{
0, CHECK_ERR( BYTE_COUNT_WITH_SIZE_ATTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[byte_count] cannot be specified on a parameter with size attributes"
}

,{
0, CHECK_ERR( CASE_EXPR_NOT_CONST)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[case] expression is not constant"
}

,{
0, CHECK_ERR( CASE_EXPR_NOT_INT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[case] expression is not of integral type"
}

,{
0, CHECK_ERR( CONTEXT_HANDLE_VOID_PTR )
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"specifying [context_handle] on a type other than void * requires /ms_ext"
}

,{
0, CHECK_ERR( ERROR_STATUS_T_REPEATED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot specify more than one parameter with each of comm_status/fault_status"
}

,{
0, CHECK_ERR( E_STAT_T_MUST_BE_PTR_TO_E )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"comm_status/fault_status parameter must be an [out] only pointer parameter"
}

,{
0, CHECK_ERR( ENDPOINT_SYNTAX)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"endpoint syntax error"
}

,{
0, CHECK_ERR( INAPPLICABLE_ATTRIBUTE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"inapplicable attribute"
}

,{
0, CHECK_ERR( ALLOCATE_INVALID)
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] requires /ms_ext"
}

,{
0, CHECK_ERR( INVALID_ALLOCATE_MODE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid [allocate] mode"
}

,{
0, CHECK_ERR( INVALID_SIZE_ATTR_ON_STRING)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"length attributes cannot be applied with string attribute"
}

,{
0, CHECK_ERR( LAST_AND_LENGTH)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[last_is] and [length_is] cannot be specified at the same time"
}

,{
0, CHECK_ERR( MAX_AND_SIZE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[max_is] and [size_is] cannot be specified at the same time"
}

,{
0, CHECK_ERR( NO_SWITCH_IS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"no [switch_is] attribute specified at use of union"
}

,{
0, CHECK_ERR( NO_UUID_SPECIFIED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"no [uuid] specified"
}

,{
0, CHECK_ERR( UUID_LOCAL_BOTH_SPECIFIED)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"[uuid] ignored on [local] interface"
}

,{
0, CHECK_ERR( SIZE_LENGTH_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"type mismatch between length and size attribute expressions"
}

,{
0, CHECK_ERR( STRING_NOT_ON_BYTE_CHAR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[string] attribute must be specified \"byte\" \"char\" or \"wchar_t\" array or pointer"
}

,{
0, CHECK_ERR( SWITCH_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"mismatch between the type of the [switch_is] expression and the switch type of the union"
}

,{
0, CHECK_ERR( TRANSMIT_AS_CTXT_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[transmit_as] must not be applied to a type that derives from a context handle"
}

,{
0, CHECK_ERR( TRANSMIT_AS_NON_RPCABLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[transmit_as] must specify a transmissible type"
}

,{
0, CHECK_ERR( TRANSMIT_AS_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"transmitted type for [transmit_as] and [reprsent_as] must not be a pointer or derive from a pointer"
}

,{
0, CHECK_ERR( TRANSMIT_TYPE_CONF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"presented type for [transmit_as] and [represent_as] must not derive from a conformant/varying array or a conformant/varying structure"
}
 
,{
0, CHECK_ERR( UUID_FORMAT)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[uuid] format is incorrect"
}

,{
0, CHECK_ERR( UUID_NOT_HEX)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"uuid is not a hex number"
}

,{
0, CHECK_ERR( OPTIONAL_PARAMS_MUST_BE_LAST)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"optional parameters must come after required parameters"
}

,{
0, CHECK_ERR( DLLNAME_REQUIRED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[dllname] required when [entry] is used:"
}

,{
0, CHECK_ERR( INVALID_USE_OF_BINDABLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[bindable] is invalid without [propget], [propput], or [propputref]"
}

,{
0, CHECK_ERR( INVALID_USE_OF_PROPPUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [propput] or [propputref] must have at least one parameter"
}

,{
0, CHECK_ERR( DISPATCH_ID_REQUIRED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[id] attribute is required"
}

,{
0, CHECK_ERR( ACF_INTERFACE_MISMATCH)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"interface name specified in the ACF file does not match that specified in the IDL file"
}

,{
0, CHECK_ERR( DUPLICATE_ATTR)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicated attribute"
}

,{
0, CHECK_ERR( INVALID_COMM_STATUS_PARAM )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter with [comm_status] or [fault_status] attribute must be a pointer to type error_status_t"
}

,{
0, CHECK_ERR( LOCAL_PROC_IN_ACF)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"a [local] procedure cannot be specified in ACF file"
}

,{
0, CHECK_ERR( TYPE_HAS_NO_HANDLE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"specified type is not defined as a handle"
}

,{
0, CHECK_ERR( UNDEFINED_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedure undefined"
}

,{
0, CHECK_ERR( UNDEF_PARAM_IN_IDL)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"this parameter does not exist in the IDL file"
}

,{
0, CHECK_ERR( ARRAY_BOUNDS_CONSTRUCT_BAD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"this array bounds construct is not supported"
}

,{
0, CHECK_ERR( ILLEGAL_ARRAY_BOUNDS)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array bound specification is illegal"
}

,{
0, CHECK_ERR( ILLEGAL_CONFORMANT_ARRAY)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointer to a conformant array or an array that contains a conformant array is not supported"
}

,{
0, CHECK_ERR( UNSIZED_ARRAY)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointee / array does not derive any size"
}

,{
0, CHECK_ERR( NOT_FIXED_ARRAY)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"only fixed arrays and SAFEARRAYs are legal in a type library"
}

,{
0, CHECK_ERR( SAFEARRAY_USE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"SAFEARRAYs are only legal inside a library block"
}

,{
0, CHECK_ERR( CHAR_CONST_NOT_TERMINATED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"badly formed character constant"
}

,{
0, CHECK_ERR( EOF_IN_COMMENT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"end of file found in comment"
}

,{
0, CHECK_ERR( EOF_IN_STRING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"end of file found in string"
}

,{
0, CHECK_ERR( ID_TRUNCATED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"identifier length exceeds 31 characters"
}

,{
0, CHECK_ERR( NEWLINE_IN_STRING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"end of line found in string"
}

,{
0, CHECK_ERR( STRING_TOO_LONG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"string constant exceeds limit of 255 characters"
}

,{
0, CHECK_ERR( IDENTIFIER_TOO_LONG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"identifier exceeds limit of 255 characters and has been truncated"
}

,{
0, CHECK_ERR( CONSTANT_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"constant too big"
}

,{
0, CHECK_ERR( ERROR_PARSING_NUMERICAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"numerical parsing error"
}

,{
0, CHECK_ERR( ERROR_OPENING_FILE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error in opening file"
}

,{
0, CHECK_ERR( ERR_BIND )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error binding to function"
}

,{
0, CHECK_ERR( ERR_INIT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error initializing OLE"
}

,{
0, CHECK_ERR( ERR_LOAD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error loading library"
}

,{
0, CHECK_ERR( UNIQUE_FULL_PTR_OUT_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] only parameter must not derive from a top-level [unique] or [ptr] pointer/array"
}

,{
0, CHECK_ERR( BAD_ATTR_NON_RPC_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute is not applicable to this non-rpcable union"
}

,{
0, CHECK_ERR( SIZE_SPECIFIER_CANT_BE_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression used for a size attribute must not derive from an [out] only parameter"
}

,{
0, CHECK_ERR( LENGTH_SPECIFIER_CANT_BE_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"expression used for a length attribute for an [in] parameter cannot derive from an [out] only parameter"
}

,{
0, CHECK_ERR( BAD_CON_INT )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"use of \"int\" needs /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_FIELD_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union field must not be \"void\""
}

,{
0, CHECK_ERR( BAD_CON_ARRAY_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array element must not be \"void\""
}

,{
0, CHECK_ERR( BAD_CON_MSC_CDECL )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"use of type qualifiers and/or modifiers needs /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_FIELD_FUNC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union field must not derive from a function"
}

,{
0, CHECK_ERR( BAD_CON_ARRAY_FUNC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array element must not be a function"
}

,{
0, CHECK_ERR( BAD_CON_PARAM_FUNC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not be a function"
}

,{
0, CHECK_ERR( BAD_CON_BIT_FIELDS )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union with bit fields needs /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_BIT_FIELD_NON_ANSI)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"bit field specification on a type other that \"int\" is a non-ANSI-compatible extension"
}

,{
0, CHECK_ERR( BAD_CON_BIT_FIELD_NOT_INTEGRAL)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"bit field specification can be applied only to simple, integral types"
}

,{
0, CHECK_ERR( BAD_CON_CTXT_HDL_FIELD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"struct/union field must not derive from handle_t or a context_handle"
}

,{
0, CHECK_ERR( BAD_CON_CTXT_HDL_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"array element must not derive from handle_t or a context-handle"
}

,{
0, CHECK_ERR( BAD_CON_NON_RPC_UNION )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"this specification of union needs /c_ext"
}

,{
ENV_WIN64, CHECK_ERR( NON_RPC_PARAM_INT )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from an \"int\" must have size specifier \"small\", \"short\", or \"long\" with the \"int\""
}

,{
0, CHECK_ERR( NON_RPC_PARAM_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type of the parameter cannot derive from void or void *"
}

,{
0, CHECK_ERR( NON_RPC_PARAM_BIT_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from a struct/union containing bit fields is not supported"
}

,{
0, CHECK_ERR( NON_RPC_PARAM_CDECL )
  MAKE_E_MASK( C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"use of a parameter deriving from a type containing type-modifiers/type-qualifiers needs /c_ext"
}

,{
0, CHECK_ERR( NON_RPC_PARAM_FUNC_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not derive from a pointer to a function"
}

,{
0, CHECK_ERR( NON_RPC_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not derive from a non-rpcable union"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_INT )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"return type derives from an \"int\". You must use size specifiers with the \"int\""
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a void pointer"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_BIT_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a struct/union containing bit-fields"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a non-rpcable union"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_FUNC_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a pointer to a function"
}

,{
0, CHECK_ERR( COMPOUND_INITS_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"compound initializers are not supported"
}

,{
0, CHECK_ERR( ACF_IN_IDL_NEEDS_APP_CONFIG )
  MAKE_E_MASK( APP_CONFIG_SET , C_MSG, CLASS_ERROR, NOWARN )
,"ACF attributes in the IDL file need the /app_config switch"
}

,{
0, CHECK_ERR( SINGLE_LINE_COMMENT )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_WARN, 1 )
,"single line comment needs /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( VERSION_FORMAT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[version] format is incorrect"
}

,{
0, CHECK_ERR( SIGNED_ILLEGAL )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"\"signed\" needs /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( ASSIGNMENT_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"mismatch in assignment type"
}

,{
0, CHECK_ERR( ILLEGAL_OSF_MODE_DECL )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"declaration must be of the form: const <type><declarator> = <initializing expression> "
}

,{
0, CHECK_ERR( OSF_DECL_NEEDS_CONST )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"declaration must have \"const\""
}

,{
0, CHECK_ERR( COMP_DEF_IN_PARAM_LIST )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"struct/union/enum must not be defined in a parameter type specification"
}

,{
0, CHECK_ERR( ALLOCATE_NOT_ON_PTR_TYPE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] attribute must be applied only on non-void pointer types"
}

,{
0, CHECK_ERR( ARRAY_OF_UNIONS_ILLEGAL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"array or equivalent pointer construct cannot derive from a non-encapsulated union"
}

,{
0, CHECK_ERR( BAD_CON_E_STAT_T_FIELD )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from an error_status_t type"
}

,{
0, CHECK_ERR( CASE_LABELS_MISSING_IN_UNION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"union has at least one arm without a case label"
}

,{
0, CHECK_ERR( BAD_CON_PARAM_RT_IGNORE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"parameter or return type must not derive from a type that has [ignore] applied to it"
}

,{
0, CHECK_ERR( MORE_THAN_ONE_PTR_ATTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"pointer already has a pointer-attribute applied to it"
}

,{
0, CHECK_ERR( RECURSION_THRU_REF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field/parameter must not derive from a structure that is recursive through a ref pointer"
}

,{
0, CHECK_ERR( BAD_CON_FIELD_VOID_PTR )
  MAKE_E_MASK( C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of field deriving from a void pointer needs /c_ext"
}

,{
0, CHECK_ERR( INVALID_OSF_ATTRIBUTE )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of this attribute needs /ms_ext"
}

,{
ENV_WIN64, CHECK_ERR( INVALID_NEWTLB_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"this attribute only allowed with new format type libraries"
}

,{
0, CHECK_ERR( WCHAR_T_INVALID_OSF )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"use of wchar_t needs /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_UNNAMED_FIELD )
  MAKE_E_MASK( MS_OR_C_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"unnamed fields need /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( BAD_CON_UNNAMED_FIELD_NO_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"unnamed fields can derive only from struct/union types"
}

,{
0, CHECK_ERR( BAD_CON_UNION_FIELD_CONF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field of a union cannot derive from a conformant/varying array or its pointer equivalent"
}

,{
0, CHECK_ERR( PTR_WITH_NO_DEFAULT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"no [pointer_default] attribute specified, assuming [ptr] for all unattributed pointers in interface"
}

,{
0, CHECK_ERR( RHS_OF_ASSIGN_NOT_CONST )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"initializing expression must resolve to a constant expression"
}

,{
0, CHECK_ERR( SWITCH_IS_TYPE_IS_WRONG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression must be of type integer, char, boolean or enum"
}

,{
0, CHECK_ERR( ILLEGAL_CONSTANT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"illegal constant"
}

,{
0, CHECK_ERR( IGNORE_UNIMPLEMENTED_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"attribute not implemented; ignored"
}

,{
0, CHECK_ERR( BAD_CON_REF_RT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from a [ref] pointer"
}

,{
0, CHECK_ERR( ATTRIBUTE_ID_MUST_BE_VAR )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"attribute expression must be a variable name or a pointer dereference expression in this mode. You must specify the /ms_ext switch"
}

,{
0, CHECK_ERR( RECURSIVE_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must not derive from a recursive non-encapsulated union"
}

,{
0, CHECK_ERR( BINDING_HANDLE_IS_OUT_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"binding-handle parameter cannot be [out] only"
}

,{
0, CHECK_ERR( PTR_TO_HDL_UNIQUE_OR_FULL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointer to a handle cannot be [unique] or [ptr]"
}

,{
0, CHECK_ERR( HANDLE_T_NO_TRANSMIT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter that is not a binding handle must not derive from handle_t"
}

,{
0, CHECK_ERR( UNEXPECTED_END_OF_FILE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unexpected end of file found"
}

,{
0, CHECK_ERR( HANDLE_T_XMIT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"type deriving from handle_t must not have [transmit_as] applied to it"
}

,{
0, CHECK_ERR( CTXT_HDL_GENERIC_HDL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[context_handle] must not be applied to a type that has [handle] applied to it"
}

,{
0, CHECK_ERR( GENERIC_HDL_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be specified on a type deriving from void or void *"
}

,{
0, CHECK_ERR( NO_EXPLICIT_IN_OUT_ON_PARAM )
  MAKE_E_MASK( MS_OR_C_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must have either [in], [out] or [in,out] in this mode. You must specify /ms_ext or /c_ext"
}

,{
0, CHECK_ERR( TRANSMIT_AS_VOID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"transmitted type may not derive from \"void\" for [transmit_as], [represent_as], [wire_marshal], [user_marshal]."
}

,{
0, CHECK_ERR( VOID_NON_FIRST_PARAM )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"\"void\" must be specified on the first and only parameter specification"
}

,{
0, CHECK_ERR( SWITCH_IS_ON_NON_UNION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[switch_is] must be specified only on a type deriving from a non-encapsulated union"
}

,{
0, CHECK_ERR( STRINGABLE_STRUCT_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"stringable structures are not implemented in this version"
}

,{
0, CHECK_ERR( SWITCH_TYPE_TYPE_BAD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"switch type can only be integral, char, boolean or enum"
}

,{
0, CHECK_ERR( GENERIC_HDL_HANDLE_T )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be specified on a type deriving from handle_t"
}

,{
0, CHECK_ERR( HANDLE_T_CANNOT_BE_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from handle_t must not be an [out] parameter"
}

,{
0, CHECK_ERR( SIZE_LENGTH_SW_UNIQUE_OR_FULL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"attribute expression derives from [unique] or [ptr] pointer dereference"
}

,{
0, CHECK_ERR( CPP_QUOTE_NOT_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"\"cpp_quote\" requires /ms_ext"
}

,{
0, CHECK_ERR( QUOTED_UUID_NOT_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"quoted uuid requires /ms_ext"
}

,{
0, CHECK_ERR( RETURN_OF_UNIONS_ILLEGAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"return type cannot derive from a non-encapsulated union"
}

,{
0, CHECK_ERR( RETURN_OF_CONF_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"return type cannot derive from a conformant structure"
}

,{
0, CHECK_ERR( XMIT_AS_GENERIC_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[transmit_as] must not be applied to a type deriving from a generic handle"
}

,{
0, CHECK_ERR( GENERIC_HANDLE_XMIT_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be applied to a type that has [transmit_as] applied to it"
}

,{
0, CHECK_ERR( INVALID_CONST_TYPE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"type specified for the const declaration is invalid"
}

,{
0, CHECK_ERR( INVALID_SIZEOF_OPERAND )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"operand to the sizeof operator is not supported"
}

,{
0, CHECK_ERR( NAME_ALREADY_USED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"this name already used as a const identifier name"
}

,{
0, CHECK_ERR( ERROR_STATUS_T_ILLEGAL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"inconsistent redefinition of type error_status_t"
}

,{
0, CHECK_ERR( CASE_VALUE_OUT_OF_RANGE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[case] value out of range of switch type"
}

,{
0, CHECK_ERR( WCHAR_T_NEEDS_MS_EXT_TO_RPC )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"parameter deriving from wchar_t needs /ms_ext"
}

,{
0, CHECK_ERR( INTERFACE_ONLY_CALLBACKS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"this interface has only callbacks"
}

,{
0, CHECK_ERR( REDUNDANT_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"redundantly specified attribute; ignored"
}

,{
0, CHECK_ERR( CTXT_HANDLE_USED_AS_IMPLICIT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"context handle type used for an implicit handle"
}

,{
0, CHECK_ERR( CONFLICTING_ALLOCATE_OPTIONS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"conflicting options specified for [allocate]"
}

,{
0, CHECK_ERR( ERROR_WRITING_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"error while writing to file"
}

,{
0, CHECK_ERR( NO_SWITCH_TYPE_AT_DEF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"no switch type found at definition of union, using the [switch_is] type"
}

,{
0, CHECK_ERR( ERRORS_PASS1_NO_PASS2 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"semantic check incomplete due to previous errors"
}

,{
0, CHECK_ERR( HANDLES_WITH_CALLBACK )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"handle parameter or return type is not supported on a [callback] procedure"
}

,{
0, CHECK_ERR( PTR_NOT_FULLY_IMPLEMENTED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[ptr] does not support aliasing in this version"
}

,{
0, CHECK_ERR( PARAM_ALREADY_CTXT_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"parameter already defined as a context handle"
}

,{
0, CHECK_ERR( CTXT_HDL_HANDLE_T )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[context_handle] must not derive from handle_t"
}

,{
0, CHECK_ERR( ARRAY_SIZE_EXCEEDS_64K )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"array size exceeds 65536 bytes"
}

,{
0, CHECK_ERR( STRUCT_SIZE_EXCEEDS_64K )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"struct size exceeds 65536 bytes"
}

,{
0, CHECK_ERR( NE_UNION_FIELD_NE_UNION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field of a non-encapsulated union cannot be another non-encapsulated union"
}

,{
0, CHECK_ERR( PTR_ATTRS_ON_EMBEDDED_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"pointer attribute(s) applied on an embedded array; ignored"
}

,{
0, CHECK_ERR( ALLOCATE_ON_TRANSMIT_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] is illegal on either the transmitted or presented type for [transmit_as], [represent_as], [wire_marshal], or [user_marshal]."
}

,{
0, CHECK_ERR( SWITCH_TYPE_REQD_THIS_IMP_MODE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[switch_type] must be specified in this import mode"
}

,{
0, CHECK_ERR( IMPLICIT_HDL_ASSUMED_GENERIC )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"[implicit_handle] type undefined; assuming generic handle"
}

,{
0, CHECK_ERR( E_STAT_T_ARRAY_ELEMENT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"array element must not derive from error_status_t"
}

,{
0, CHECK_ERR( ALLOCATE_ON_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[allocate] illegal on a type deriving from a primitive/generic/context handle"
}

,{
0, CHECK_ERR( TRANSMIT_AS_ON_E_STAT_T )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"transmitted or presented type must not derive from error_status_t"
}

,{
0, CHECK_ERR( IGNORE_ON_DISCRIMINANT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"discriminant of a union must not derive from a field with [ignore] applied to it"
}

,{
0, CHECK_ERR( NOCODE_WITH_SERVER_STUBS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 4 )
,"[nocode] ignored for server side since \"/server none\" not specified"
}

,{
0, CHECK_ERR( NO_REMOTE_PROCS_NO_STUBS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"no remote procedures specified in non-[local] interface; no client/server stubs will be generated"
}

,{
0, CHECK_ERR( TWO_DEFAULT_CASES )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"too many default cases specified for encapsulated union"
}

,{
0, CHECK_ERR( TWO_DEFAULT_INTERFACES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"too many default interfaces specified for coclass"
}

,{
0, CHECK_ERR( DEFAULTVTABLE_REQUIRES_SOURCE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"items with [defaultvtable] must also have [source]"
}

,{
0, CHECK_ERR( UNION_NO_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"union specification with no fields is illegal"
}

,{
0, CHECK_ERR( VALUE_OUT_OF_RANGE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"value out of range"
}

,{
0, CHECK_ERR( CTXT_HDL_NON_PTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[context_handle] must be applied on a pointer type"
}

,{
0, CHECK_ERR( NON_RPC_RTYPE_HANDLE_T )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"return type must not derive from handle_t"
}

,{
0, CHECK_ERR( GEN_HDL_CTXT_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[handle] must not be applied to a type deriving from a context handle"
}

,{
ENV_WIN64, CHECK_ERR( NON_RPC_FIELD_INT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field deriving from an \"int\" must have size specifier \"small\", \"short\", or \"long\" with the \"int\""
}

,{
0, CHECK_ERR( NON_RPC_FIELD_PTR_TO_VOID )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a void or void *"
}

,{
0, CHECK_ERR( NON_RPC_FIELD_BIT_FIELDS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a struct containing bit-fields"
}

,{
0, CHECK_ERR( NON_RPC_FIELD_NON_RPC_UNION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a non-rpcable union"
}

,{
0, CHECK_ERR( NON_RPC_FIELD_FUNC_PTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"field must not derive from a pointer to a function"
}

,{
0, CHECK_ERR( PROC_PARAM_FAULT_STATUS)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot use [fault_status] on both a parameter and a return type"
}

,{
0, CHECK_ERR( NON_OI_BIG_RETURN )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"return type too complicated for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_BIG_GEN_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"generic handle type too large for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( ALLOCATE_IN_OUT_PTR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 4 )
,"[allocate(all_nodes)] on an [in,out] parameter may orphan the original memory"
}

,{
0, CHECK_ERR( REF_PTR_IN_UNION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot have a [ref] pointer as a union arm"
}

,{
0, CHECK_ERR( NON_OI_CTXT_HDL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"return of context handles not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_ERR_STATS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"use of the extra [comm_status] or [fault_status] parameter not supported for /Oi* modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_UNK_REP_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"use of an unknown type for [represent_as] or [user_marshal] not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_XXX_AS_ON_RETURN )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"array types with [transmit_as] or [represent_as] not supported on return type for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_XXX_AS_BY_VALUE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"array types with [transmit_as] or [represent_as] not supported pass-by-value for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( CALLBACK_NOT_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"[callback] requires /ms_ext"
}

,{
0, CHECK_ERR( CIRCULAR_INTERFACE_DEPENDENCY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"circular interface dependency"
}

,{
0, CHECK_ERR( NOT_VALID_AS_BASE_INTF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"only IUnknown may be used as the root interface"
}

,{
0, CHECK_ERR( IID_IS_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[IID_IS] may only be applied to pointers to interfaces"
}

,{
0, CHECK_ERR( INTF_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"interfaces may only be used in pointer-to-interface constructs"
}

,{
0, CHECK_ERR( PTR_INTF_NO_GUID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"interface pointers must have a UUID/IID"
}

,{
0, CHECK_ERR( OUTSIDE_OF_INTERFACE )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"definitions and declarations outside of interface body requires /ms_ext"
}

,{
0, CHECK_ERR( MULTIPLE_INTF_NON_OSF )
  MAKE_E_MASK( MS_EXT_SET , C_MSG, CLASS_ERROR, NOWARN )
,"multiple interfaces in one file requires /ms_ext"
}

,{
0, CHECK_ERR( CONFLICTING_INTF_HANDLES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"only one of [implicit_handle], [auto_handle], or [explicit_handle] allowed"
}

,{
0, CHECK_ERR( IMPLICIT_HANDLE_NON_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[implicit_handle] references a type which is not a handle"
}

,{
0, CHECK_ERR( OBJECT_PROC_MUST_BE_WIN32 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[object] procs may only be used with \"/env win32\""
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_NON_OI_16BIT_CALLBACK )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,""
//,"[callback] with -env dos/win16 not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NON_OI_TOPLEVEL_FLOAT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1  )
,"float/double not supported as top-level parameter for /Oi mode, using /Os"
}

,{
0, CHECK_ERR( CTXT_HDL_MUST_BE_DIRECT_RETURN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pointers to context handles may not be used as return values"
}

,{
0, CHECK_ERR( OBJECT_PROC_NON_HRESULT_RETURN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures in an object interface must return an HRESULT"
}

,{
0, CHECK_ERR( DUPLICATE_UUID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"duplicate UUID. Same as"
}

,{
0, CHECK_ERR( ILLEGAL_INTERFACE_DERIVATION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[object] interfaces must derive from another [object] interface such as IUnknown"
}

,{
0, CHECK_ERR( ILLEGAL_BASE_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"(async) interface must derive from another (async) interface"
}

,{
0, CHECK_ERR( IID_IS_EXPR_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[IID_IS] expression must be a pointer to IID structure"
}

,{
0, CHECK_ERR( CALL_AS_NON_LOCAL_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[call_as] type must be a [local] procedure"
}

,{
0, CHECK_ERR( CALL_AS_UNSPEC_IN_OBJECT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"undefined [call_as] must not be used in an object interface"
}

,{
0, CHECK_ERR( ENCODE_AUTO_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[auto_handle] may not be used with [encode] or [decode]"
}

,{
0, CHECK_ERR( RPC_PROC_IN_ENCODE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"normal procs are not allowed in an interface with [encode] or [decode]"
}

,{
0, CHECK_ERR( ENCODE_CONF_OR_VAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"top-level conformance or variance not allowed with [encode] or [decode]"
}

,{
0, CHECK_ERR( CONST_ON_OUT_PARAM )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[out] parameters may not have \"const\""
}

,{
0, CHECK_ERR( CONST_ON_RETVAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"return values may not have \"const\""
}

,{
0, CHECK_ERR( INVALID_USE_OF_RETVAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid use of \"retval\" attribute"
}

,{
0, CHECK_ERR( MULTIPLE_CALLING_CONVENTIONS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"multiple calling conventions illegal"
}

,{
0, CHECK_ERR( INAPPROPRIATE_ON_OBJECT_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"attribute illegal on [object] procedure"
}

,{
0, CHECK_ERR( NON_INTF_PTR_PTR_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[out] interface pointers must use double indirection"
}

,{
0, CHECK_ERR( CALL_AS_USED_MULTIPLE_TIMES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"procedure used twice as the caller in [call_as]"
}

,{
0, CHECK_ERR( OBJECT_CALL_AS_LOCAL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[call_as] target must have [local] in an object interface"
}

,{
0, CHECK_ERR( CODE_NOCODE_CONFLICT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[code] and [nocode] may not be used together"
}

,{
0, CHECK_ERR( MAYBE_NO_OUT_RETVALS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [maybe] or [message] attributes may not [out] params or, "
 "return values must be of type HRESULT or error_status_t"
}

,{
0, CHECK_ERR( FUNC_NON_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"pointer to function must be used"
}

,{
0, CHECK_ERR( FUNC_NON_RPC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"functions may not be passed in an RPC operation"
}

,{
0, CHECK_ERR( NON_OI_RETVAL_64BIT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"hyper/double not supported as return value for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( MISMATCHED_PRAGMA_POP )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"#pragma pack( pop ) without matching #pragma pack( push )"
}

,{
0, CHECK_ERR( WRONG_TYPE_IN_STRING_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"stringable structure fields must be byte/char/wchar_t"
}

,{
0, CHECK_ERR( NON_OI_NOTIFY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[notify] not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( HANDLES_WITH_OBJECT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"handle parameter or return type is not supported on a procedure in an [object] interface"
}

,{
0, CHECK_ERR( NON_ANSI_MULTI_CONF_ARRAY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"ANSI C only allows the leftmost array bound to be unspecified"
}

,{
0, CHECK_ERR( NON_OI_UNION_PARM )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"by-value union parameters not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( OBJECT_WITH_VERSION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[version] attribute is ignored on an [object] interface"
}

,{
0, CHECK_ERR( SIZING_ON_FIXED_ARRAYS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[size_is] or [max_is] attribute is invalid on a fixed array"
}

,{
0, CHECK_ERR( PICKLING_INVALID_IN_OBJECT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[encode] or [decode] are invalid in an [object] interface"
}

,{
0, CHECK_ERR( TYPE_PICKLING_INVALID_IN_OSF )
  MAKE_E_MASK( MS_EXT_SET, C_MSG, CLASS_ERROR, NOWARN )
,"[encode] or [decode] on a type requires /ms_ext"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_INT_NOT_SUPPORTED_ON_INT16 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,""
//,"\"int\" not supported on /env win16 or /env dos"
}

,{
0, CHECK_ERR( BSTRING_NOT_ON_PLAIN_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[bstring] may only be applied to a pointer to \"char\" or \"wchar_t\""
}

,{
0, CHECK_ERR( INVALID_ON_OBJECT_PROC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute invalid on a proc in an [object] interface :"
}

,{
0, CHECK_ERR( INVALID_ON_OBJECT_INTF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"attribute invalid on an [object] interface :"
}

,{
ENV_WIN64, CHECK_ERR( STACK_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
  , ""
//,"too many parameters or stack too big for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( NO_ATTRS_ON_ACF_TYPEDEF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"no attributes on ACF file typedef, so no effect"
}

,{
0, CHECK_ERR( NON_OI_WRONG_CALL_CONV )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"calling conventions other than __stdcall or __cdecl not supported for /Oi modes, using /Os"
}

,{
0, CHECK_ERR( TOO_MANY_DELEGATED_PROCS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"too many delegation methods in the interface, requires Windows 2000 or greater "
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_NO_MAC_AUTO_HANDLES )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,""
//,"auto handles not supported with -env mac or -env powermac"
}

,{
0, CHECK_ERR( ILLEGAL_IN_MKTYPLIB_MODE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"statements outside library block are illegal in mktyplib compatability mode"
}

,{
0, CHECK_ERR( ILLEGAL_USE_OF_MKTYPLIB_SYNTAX)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal syntax unless using mktyplib compatibility mode"
}

,{
0, CHECK_ERR( ILLEGAL_SU_DEFINITION)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal definition, must use typedef in mktyplib compatibility mode"
}

,{
0, CHECK_ERR( INTF_EXPLICIT_PTR_ATTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"explicit pointer attribute [ptr] [ref] ignored for interface pointers"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_NO_OI_ON_MPPC )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,""
//,"Oi modes not implemented for PowerMac, switching to Os"
}

,{
0, CHECK_ERR( ILLEGAL_EXPRESSION_TYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal expression type used in attribute"
}

,{
0, CHECK_ERR( ILLEGAL_PIPE_TYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal type used in pipe"
}

,{
0, CHECK_ERR( REQUIRES_OI2 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"procedure uses pipes, using /Oicf"
}

,{
0, CHECK_ERR( ASYNC_REQUIRES_OI2 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"procedure has an attribute that requires use of /Oicf, switching modes"
}

,{
0, CHECK_ERR( CONFLICTING_OPTIMIZATION_REQUIREMENTS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"conflicting optimization requirements, cannot optimize"
}

,{
0, CHECK_ERR( ILLEGAL_PIPE_EMBEDDING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pipes cannot be array elements, or members of structures or unions"
}

,{
0, CHECK_ERR( ILLEGAL_PIPE_CONTEXT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid pipe usage"
}

,{
0, CHECK_ERR( CMD_REQUIRES_I2 )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"feature requires the advanced interpreted optimization option, use -Oicf :"
}

,{
0, CHECK_ERR( REQUIRES_I2 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 3 )
,"feature requires the advanced interpreted optimization option, use -Oicf :"
}

// The following 4 errors aren't used but sit here to get 
// the MSDN error numbers correct.

,{
0, CHECK_ERR( CMD_REQUIRES_NT40 )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT40 :"
}

,{
0, CHECK_ERR( CMD_REQUIRES_NT351 )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT351 :"
}

,{
0, CHECK_ERR( REQUIRES_NT40 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT40"
}

,{
0, CHECK_ERR( REQUIRES_NT351 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"feature invalid for the specified target system, use -target NT351"
}

,{
0, CHECK_ERR( CMD_OI1_PHASED_OUT )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -Oicf :"
}

,{
0, CHECK_ERR( CMD_OI2_OBSOLETE )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -Oicf :"
}

,{
0, CHECK_ERR( OI1_PHASED_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -ic "
}

,{
0, CHECK_ERR( OI2_OBSOLETE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"the optimization option is being phased out, use -icf"
}

,{
0, CHECK_ERR( ODL_OLD_NEW_OBSOLETE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"the -old and -new switches are obsolete, use -oldtlb and -newtlb"
}

,{
0, CHECK_ERR( ILLEGAL_ARG_VALUE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal argument value"
}

,{
0, CHECK_ERR( CONSTANT_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal expression type in constant"
}

,{
0, CHECK_ERR( ENUM_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"illegal expression type in enum"
}

,{
0, CHECK_ERR( UNSATISFIED_FORWARD )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unsatisfied forward declaration"
}

,{
0, CHECK_ERR( CONTRADICTORY_SWITCHES )
  MAKE_E_MASK( ERR_ALWAYS, D_MSG, CLASS_ERROR, NOWARN )
,"switches are contradictory "
}

,{
0, CHECK_ERR( NO_SWITCH_IS_HOOKOLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"MIDL cannot generate HOOKOLE information for the non-rpcable union"
}

,{
0, CHECK_ERR( NO_CASE_EXPR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"no case expression found for union"
}

,{
0, CHECK_ERR( USER_MARSHAL_IN_OI )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[user_marshal] and [wire_marshal] not supported with -Oi and -Oic flags, use -Os or -Oicf"
}

,{
0, CHECK_ERR( PIPES_WITH_PICKLING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"pipes can't be used with data serialization, i.e. [encode] and/or [decode]"
}

,{
0, CHECK_ERR( PIPE_INTF_PTR_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"all pipe interface pointers must use single indirection"
}

,{
0, CHECK_ERR( IID_WITH_PIPE_INTF_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"[iid_is()] cannot be used with a pipe interface pointer"
}

,{
0, CHECK_ERR( INVALID_LOCALE_ID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid or inapplicable -lcid switch: "
}

,{
0, CHECK_ERR( CONFLICTING_LCID )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, NOWARN )
,"the specified lcid is different from previous specification"
}

,{
0, CHECK_ERR( ILLEGAL_IMPORTLIB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"importlib is not allowed outside of a library block"
}

,{
0, CHECK_ERR( INVALID_FLOAT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"invalid floating point value"
}

,{
0, CHECK_ERR( INVALID_MEMBER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid member"
}

,{
0, CHECK_ERR( POSSIBLE_INVALID_MEMBER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, NOWARN )
,"possible invalid member"
}

,{
0, CHECK_ERR( INTERFACE_PIPE_TYPE_MISMATCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"mismatch in pipe and interface types"
}

,{
0, CHECK_ERR( PIPE_INCOMPATIBLE_PARAMS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"string, varying array, conformant array \n and full pointer parameters may be incompatible with pipe parameters \n during runtime. See MSDN for more details"
}

,{
0, CHECK_ERR( ASYNC_NOT_IN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter must be in"
}

,{
0, CHECK_ERR( OBJECT_ASYNC_NOT_DOUBLE_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter type of an [async] object must be a double pointer to an interface"
}

,{
0, CHECK_ERR( ASYNC_INCORRECT_TYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"incorrect async handle type"
}

,{
0, CHECK_ERR( INTERNAL_SWITCH_USED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, NOWARN )
,"the \"internal\" switch enables unsupported features, use with caution"
}

,{
0, CHECK_ERR( ASYNC_INCORRECT_BINDING_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"async procedures cannot use auto handle"
}

,{
0, CHECK_ERR( ASYNC_INCORRECT_ERROR_STATUS_T )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"error_status_t should have both [comm_status] and [fault_status]"
}

,{
0, CHECK_ERR( NO_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"this construct is only allowed within a library block"
}

,{
0, CHECK_ERR( INVALID_TYPE_REDEFINITION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid type redefinition"
}

,{
0, CHECK_ERR( NOT_VARARG_COMPATIBLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [vararg] attribute must have a SAFEARRAY(VARIANT) parameter; param order is [vararg], [lcid], [retval]"
}

,{
ENV_WIN64, CHECK_ERR( TOO_MANY_PROCS_FOR_NT4 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"too many methods in the interface, requires Windows NT 4.0 SP3 or greater"
}

,{
ENV_WIN64, CHECK_ERR( TOO_MANY_PROCS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"too many methods in the interface, requires Windows 2000 or greater"
}

,{
0, CHECK_ERR( OBSOLETE_SWITCH )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"switch is being phased out"
}

,{
0, CHECK_ERR( CANNOT_INHERIT_IADVISESINK )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"cannot derive from IAdviseSink, IAdviseSink2 or IAdviseSinkEx"
}

,{
0, CHECK_ERR( DEFAULTVALUE_NOT_ALLOWED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"cannot assign a default value"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_INVALID_TLB_ENV )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,""
//,"type library generation for DOS/Win16/MAC is not supported"
}

,{
0, CHECK_ERR( WARN_TYPELIB_GENERATION )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"error generating type library, ignored"
}

,{
ENV_WIN64, CHECK_ERR( OI_STACK_SIZE_EXCEEDED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
,"exceeded stack size for /Oi, using /Os"
}

,{
0, CHECK_ERR( ROBUST_REQUIRES_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"use of /robust requires /Oicf, switching modes"
}

,{
0, CHECK_ERR( INCORRECT_RANGE_DEFN )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"incorrect range specified"
}

,{
0, CHECK_ERR( ASYNC_INVALID_IN_OUT_PARAM_COMBO )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"invalid combination of [in] only and [out] parameters for [async_uuid] interface"
}

,{
ENV_WIN64, CHECK_ERR( _OBSOLETE_PLATFORM_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,""
//,"DOS, Win16 and MAC platforms are not supported with /robust"
}

,{
0, CHECK_ERR( OIC_SUPPORT_PHASED_OUT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"support for NT 3.51 style stubless proxies for object interfaces will be phased out; use /Oicf: "
}

,{
0, CHECK_ERR( ROBUST_PICKLING_NO_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[encode] or [decode] with /robust requires /Oicf"
}
,{
0, CHECK_ERR( _OBSOLETE_OS_SUPPORT_PHASING_OUT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,""
//,"support for DOS, Win16 and MAC platforms is being phased out."
}

,{
0, CHECK_ERR( CONFLICTING_ATTRIBUTES )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"conflicting attributes specified"
}

,{
0, CHECK_ERR( NO_CONTEXT_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[serialize], [noserialize] can be applied to context_handles"
}

,{
0, CHECK_ERR( FORMAT_STRING_LIMITS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"the compiler reached a limit for a format string representation. See documentation for advice."
}

,{
0, CHECK_ERR( EMBEDDED_OPEN_STRUCT )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"wire format may be incorrect, you may need to use -ms_conf_struct, see documentation for advice:"
}

,{
0, CHECK_ERR( STACK_SIZE_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"a stack size or an offset bigger than 64k limit. See documentation for advice."
}

,{
0, CHECK_ERR( WIN64_INTERPRETED )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 3 )
,"an interpreter mode forced for 64b platform"
}

,{
0, CHECK_ERR( ARRAY_ELEMENT_TOO_BIG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"The array element size is bigger than 64k limit."
}

,{
0, CHECK_ERR( INVALID_USE_OF_LCID )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"there can be only one [lcid] parameter in a method, and it should be last or, second to last if last parameter has [retval]"
}

,{
0, CHECK_ERR( PRAGMA_SYNTAX_ERROR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"incorrect syntax for midl_pragma"
}

,{
0, CHECK_ERR( INVALID_MODE_FOR_INT3264 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"__int3264 is not supported in /osf mode"
}

,{
0, CHECK_ERR( UNSATISFIED_HREF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unresolved symbol in type library"
}

,{
0, CHECK_ERR( ASYNC_PIPE_BY_REF )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"async pipes cannot be passed by value"
}

,{
0, CHECK_ERR( STACK_FRAME_SIZE_EXCEEDED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"parameter offset exceed 64k limit for interpreted procedures"
}

,{
0, CHECK_ERR( INVALID_ARRAY_ELEMENT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid array element"
}

,{
0, CHECK_ERR( DISPINTERFACE_MEMBERS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"dispinterface members must be methods, properties or interface"
}

,{
0, CHECK_ERR( LOCAL_NO_CALL_AS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 4 )
,"[local] procedure without [call_as]"
}

,{
0, CHECK_ERR( MULTI_DIM_VECTOR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"multi dimensional vector, switching to /Oicf"
}

,{
0, CHECK_ERR( NETMON_REQUIRES_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"use of /netmon requires /Oicf"
}

,{
ENV_WIN32, CHECK_ERR( NO_SUPPORT_IN_TLB )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"type or construct not supported in a library block because oleaut32.dll support for 64b polymorphic types is missing"
}

,{
0, CHECK_ERR( NO_OLD_INTERPRETER_64B )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"old interpreter code being generated for 64b"
}

,{
0, CHECK_ERR( SWITCH_NOT_SUPPORTED_ANYMORE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"the compiler switch is not supported anymore:"
}

,{
0, CHECK_ERR( SPAWN_ERROR )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"cannot execute MIDL engine"
}


,{
0, CHECK_ERR( BAD_CMD_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"invalid or corrupt intermediate compiler file :"
}

,{
0, CHECK_ERR( INAPPLICABLE_OPTIONAL_ATTRIBUTE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"for oleautomation, optional parameters should be VARIANT or VARIANT *"
}

,{
0, CHECK_ERR( DEFAULTVALUE_WITH_OPTIONAL )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"[defaultvalue] is applied to a non-VARIANT and [optional]. Please remove [optional]"
}

,{
0, CHECK_ERR( OPTIONAL_OUTSIDE_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"[optional] attribute is inapplicable outside of a library block"
}

,{
0, CHECK_ERR( LCID_SHOULD_BE_LONG )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"The data type of the [lcid] parameter must be long"
}

,{
0, CHECK_ERR( INVALID_PROP_PARAMS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [propput], [propget] or [propputref] can't have more than one required parameter after [optional] one"
}

,{
0, CHECK_ERR( COMMFAULT_PICKLING_NO_OICF )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"[comm_status] or [fault_status] with pickling requires -Oicf"
}

,{
0, CHECK_ERR( INCONSIST_VERSION )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"midl driver and compiler version mismatch"
}

,{
0, CHECK_ERR( NO_INTERMEDIATE_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"no intermediate file specified: use midl.exe"
}

,{
0, CHECK_ERR( FAILED_TO_GENERATE_PARAM )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"processing problem with a parameter in a procedure"
}

,{
0, CHECK_ERR( FAILED_TO_GENERATE_FIELD )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"processing problem with a field in a structure"
}

,{
0, CHECK_ERR( FORMAT_STRING_OFFSET_IS_ZERO )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"internal compiler inconsistency detected: the format string offset is invalid. See the documentation for more information."
}

,{
0, CHECK_ERR( TYPE_OFFSET_IS_ZERO )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
,"internal compiler inconsistency detected: the type offset is invalid. See the documentation for more information."
}

,{
0, CHECK_ERR( SAFEARRAY_NOT_SUPPORT_OUTSIDE_TLB )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 1 )
," SAFEARRAY(foo) syntax is not supported outside of the library block, use LPSAFEARRAY for proxy"
}

,{
0, CHECK_ERR( FAILED_TO_GENERATE_BIT_FIELD )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"bit fields are not supported"
}

,{
0, CHECK_ERR( PICKLING_RETVAL_FORCING_OI )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
,"floating point or complex return types with [decode] are not supported in -Oicf, using -Oi"
}

,{
0, CHECK_ERR( PICKLING_RETVAL_TO_COMPLEX64 )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"the return type is not supported for 64-bit when using [decode]"
}

,{
0, CHECK_ERR( WIRE_HAS_FULL_PTR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"transmitted type may not contain a full pointer for either [wire_marshal] or [user_marshal]"
}

,{
0, CHECK_ERR( WIRE_NOT_DEFINED_SIZE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"transmitted type must either be a pointer or have a constant size for [wire_marshal] and [user_marshal]"
}

,{
0, CHECK_ERR( INVALID_USE_OF_PROPGET )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"procedures with [propget] must have at least one parameter or a return value"
}

,{
0, CHECK_ERR( UNABLE_TO_OPEN_CMD_FILE )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_ERROR, NOWARN )
,"Unable to open intermediate compiler file"
}

// Errors marked with CSCHAR are relics from DCE international character
// support.  This feature was pulled because of fundamental problems with 
// the spec.

,{
0, CHECK_ERR( IN_TAG_WITHOUT_IN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"parameters with [cs_drtag] or [cs_stag] must be [in] parameters"
,""
}

,{
0, CHECK_ERR( OUT_TAG_WITHOUT_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"parameters with [cs_rtag] must be [out] parameters"
,""
}

,{
0, CHECK_ERR( NO_TAGS_FOR_IN_CSTYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"use of [cs_char] on [in] parameters requires parameters with [cs_stag]"
,""
}

,{
0, CHECK_ERR( NO_TAGS_FOR_OUT_CSTYPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"use of [cs_char] on [out] parameters requires parameters with [cs_drtag] and [cs_rtag]"
,""
}

,{
0, CHECK_ERR( CSCHAR_EXPR_MUST_BE_SIMPLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"size/length expressions for cs_char arrays must be simple variables or pointers to simple variables"
,""
}

,{
0, CHECK_ERR( SHARED_CSCHAR_EXPR_VAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR ,"size/length expressions for cs_char arrays may not share variables with other size/length expressions"
,""
}

,{
0, CHECK_ERR( MSCDECL_INVALID_ALIGN )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"The alignment specified in __declspec(align(N)) must be a power of two between 1 and 8192."
}

,{
0, CHECK_ERR( DECLSPEC_ALIGN_IN_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"__declspec(align(N)) is not supported in a TLB"
}

,{
0, CHECK_ERR( ENCAP_UNION_ARM_ALIGN_EXCEEDS_16 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"Encapsuled union arm alignment may not exceed 16"
}

,{
0, CHECK_ERR( ILLEGAL_MODIFIERS_BETWEEN_SEUKEYWORD_AND_BRACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Modifiers after the keywords \"struct\", \"union\", or \"enum\" are not supported"

}

,{
0, CHECK_ERR( TYPE_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Type is not supported"
}

,{
0, CHECK_ERR( UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Embedded unspecified user_marshal/represent_as is not supported"
}

,{
0, CHECK_ERR( INVALID_PACKING_LEVEL )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The packing level must be a power of two between and including 1 and 32768"
}


,{
0, CHECK_ERR( RETURNVAL_TOO_COMPLEX_FORCE_OS )
  MAKE_E_MASK( ERR_ALWAYS , C_MSG, CLASS_WARN, 2 )
, "Return value too complex, switching to /Os"
}

,{
0, CHECK_ERR( NO_CONFORMANT_CSCHAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR , "cs_char arrays may not be conformant"
,""
}

,{
0, CHECK_ERR( NO_MULTIDIMENSIONAL_CSCHAR )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
// CSCHAR , "cs_char arrays may not be multidimensional"
,""
}

,{
0, CHECK_ERR( BYTE_COUNT_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[byte_count] has been depreciated for ndr64"
}

,{
0, CHECK_ERR( SIZE_EXCEEDS_2GB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The size must be less then 2GB.  See documentation for details"
}

,{
0, CHECK_ERR( ARRAY_DIMENSIONS_EXCEEDS_255 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The array dimensions exceeds a compiler limit of 255.  See documention for details"
}
    
,{
0, CHECK_ERR( UNSPECIFIED_REP_OR_UMRSHL_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "Unspecifed [represent_as] and [user_marshal] has been depreciated for ndr64. Define the presented type" 
}

,{
0, CHECK_ERR( ASYNC_NDR64_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
, "async interface supports NDR64 only: only do this when you are sure the interface will not use DCE transfer syntax ever. use -protocol all if you are not sure" 
}

,{
0, CHECK_ERR( UNSUPPORT_NDR64_FEATURE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "ndr64 transfer syntax is not supported in 32bit platform yet"
}

,{
0, CHECK_ERR( UNSUPPORTED_LARGE_GENERIC_HANDLE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "large generic handles are not supported in the ndr64 protocol" 
}

,{
0, CHECK_ERR( OS_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The Os optimization mode is not supported in the ndr64 protocol"
}

,{
0, CHECK_ERR( UNEXPECTED_OS_IN_NDR64 )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "internal compiler inconsistency detected: Os optimization in ndr64 mode"
}

,{
0, CHECK_ERR( NDR64_ONLY_TLB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "type library needs to be generated in DCE protocol run"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_IN_OUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] can only be applied to [in, out] parameters"
}
                                     
,{
0, CHECK_ERR( PARTIAL_IGNORE_UNIQUE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] may only be used with [unique] pointers"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_PICKLING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] cannot be used with pickling"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_NO_OI )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "[partial_ignore] used in /Oi mode, switching to /Oicf mode"
}

,{
0, CHECK_ERR( PARTIAL_IGNORE_IN_TLB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "[partial_ignore] cannot be used in a TLB"
}

,{
0, CHECK_ERR( CORRELATION_DERIVES_FROM_IGNORE_POINTER )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "correlation expressions cannot use [ignore] pointers"
}

,{
0, CHECK_ERR( OUT_ONLY_FORCEALLOCATE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "[force_allocate] doesn't affect [out] only parameters"
}

,{
0, CHECK_ERR( FORCEALLOCATE_ON_PIPE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "[force_allocate] is not applicable to pipe argument"
}

,{
0, CHECK_ERR( FORCEALLOCATE_SUPPORTED_IN_OICF_ONLY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 2 )
, "use of [force_allocate] requires /Oicf, switching modes"
}

,{
0, CHECK_ERR( INVALID_FEATURE_FOR_TARGET )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "The feature cannot be used on the target system"
}

,{
0, CHECK_ERR( SAFEARRAY_IF_OUTSIDE_LIBRARY )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
, "SAFEARRAY(interface pointer) doesn't work using midl generated proxy"
}

,{
0, CHECK_ERR( OLEAUT_NO_CROSSPLATFORM_TLB )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "oleaut32.dll in build system doesn't support cross platform tlb generation"
}

,{
0, CHECK_ERR( INVALID_PROPPUT )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "property put function must have at least one argument and must have exactly one argument after any [optional] or [lcid] arguments"
}

,{
0, CHECK_ERR( UNSIZED_PARTIAL_IGNORE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
, "parameters with [partial_ignore] must have a well defined size"
}

,{
0, CHECK_ERR( NOT_DUAL_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 4 )
,"dual interface should be derived from IDispatch"
}

,{
0, CHECK_ERR( NEWLYFOUND_INAPPLICABLE_ATTRIBUTE)
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"inapplicable attribute"
}

,{
0, CHECK_ERR( WIRE_COMPAT_WARNING )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"wire_compat should be used for known compatibility problems only and should not be used for new code"
}

,{
0, CHECK_ERR( INVALID_VOID_IN_DISPINTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"invalid usage of void type in a dispinterface"
}

,{
0, CHECK_ERR( ACF_IN_OBJECT_INTERFACE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"acf attributes are not applicable in object interface"
}

,{
0, CHECK_ERR( CONF_BY_VALUE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"Structures containing conformant arrays must be passed by reference. See MSDN for more details"
}

,{
0, CHECK_ERR( TOP_LEVEL_POINTER_RANGE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"method contains top level ref pointer to types with range attribute. This does not work on versions of Windows before Windows 2000 SP3 and Windows XP SP1:"
}

,{
0, CHECK_ERR( POINTER_TO_RANGE )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"method contains pointer to types with range attribute. This does not work on versions of Windows before Windows 2000 SP3 and Windows XP SP1:"
}

,{
0, CHECK_ERR( OUT_PIPE_INCOMPATIBLE_PARAMS )
  MAKE_E_MASK( ERR_ALWAYS, C_MSG, CLASS_WARN, 1 )
,"[in] string, varying array, conformant array \n and full pointer parameters are incompatible with [out] pipe parameters \n before Windows Server 2003."
}

}; /* end of array of structs initialization */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\idict.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: idict.hxx
Title				: index based dictionary simulation
History				:
	04-Aug-1991	VibhasC	Created

*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/
#include "nulldefs.h"
extern	"C"	{
	#include <stdio.h>
	
}
#include "idict.hxx"

/****************************************************************************/

/****************************************************************************
	idict class implementation
 ****************************************************************************/
IDICT::IDICT(
	short	InitialSize,
	short	Increment )
	{
	IDICTELEMENT	*	pNewArray	= new
								IDICTELEMENT [ InitialSize ];
	iNextIndex		= 0;
	CurrentSize		= InitialSize;
	IDictIncrement	= Increment;
	SetArray( pNewArray );
	}

/****************************************************************************
 SetElement:
	Set the element in the array to the value that is passed in
 ****************************************************************************/
void
IDICT::SetElement(
	IDICTKEY		Key,
	IDICTELEMENT	Element )
	{
	if( Key < iNextIndex )
		{
		pArray[ Key ] = Element;
		}
	}

/****************************************************************************
 SetNewElement:
	Set the new element in the array to the value that is passed in
 ****************************************************************************/
IDICTKEY
IDICT::SetNewElement(
	IDICTELEMENT	Element )
	{
	pArray[ iNextIndex ] = Element;
	return iNextIndex++;
	}

/****************************************************************************
 ExpandArray:
	Expand the array to accomodate more elements coming in.
 ****************************************************************************/
 void
IDICT::ExpandArray()
	{
	IDICTELEMENT	*	pOldArray	= GetArray();
	IDICTELEMENT	*	pNewArray	= new
								IDICTELEMENT [(CurrentSize+IDictIncrement)];
	int			iIndex		= 0;

    //.. pOldArray moves, so we need pTemp to mark the beginning

	IDICTELEMENT	*	pTemp       = pOldArray;

	SetArray( pNewArray );
	CurrentSize	= short( CurrentSize + IDictIncrement );

	if( pOldArray )
		{
		while( iIndex++ < iNextIndex )
			{
			*pNewArray++ = *pOldArray++;
			}
		}

    delete pTemp;
	}
/***************************************************************************
 GetElement:
	return the element pointed to by the KEY (index)
 ***************************************************************************/
IDICTELEMENT
IDICT::GetElement(
	IDICTKEY	Key )
	{
	IDICTELEMENT	*	pArray	= GetArray();

	if( pArray && ( Key < iNextIndex ) )
		return pArray[ Key ];
	return (IDICTELEMENT) 0;
	}
/***************************************************************************
 IsElementPresent:
	return the element pointed to by the KEY (index)
 ***************************************************************************/
BOOL
IDICT::IsElementPresent(
	IDICTELEMENT	Element )
	{
	IDICTELEMENT	*	pArray	= GetArray();
	short				iIndex;

	if( pArray )
		{
		for( iIndex = 0; iIndex < iNextIndex; ++iIndex )
			{
			if( pArray[ iIndex ] == Element )
				return TRUE;
			}
		}
	return FALSE;
	}
/***************************************************************************
 AddElement:
	Basically SetNewElement, with checks for needed expansion. Notice how the
	array pointer is never accessed in this routine directly. This is becuase
	ExpandArray can potentially change the array underneath. So after evry
	expand call, must make sure that any local pointers to the array are
	updated.
 ***************************************************************************/
IDICTKEY
IDICT::AddElement(
	IDICTELEMENT	pNew )
	{
	if( iNextIndex >= CurrentSize )
		{
		ExpandArray();
		}
	return SetNewElement( pNew );
	}

/*****************************************************************************/

ISTACK::ISTACK(
	short MaxDepth )
	{
	InitNew( MaxDepth );
	CurrentElement = 0;
	}

void
ISTACK::InitNew(
	short MaxDepth )
	{
	MaxElements = MaxDepth;
	pStack = new IDICTELEMENT[ MaxElements ];
	}

IDICTELEMENT
ISTACK::Push( 
	IDICTELEMENT Element )
	{

	if( CurrentElement == MaxElements )
		{
		int 			i;
		IDICTELEMENT (*pStackOld);

		pStackOld = pStack;
		InitNew( short( MaxElements + 10 ) );

		for( i = 0;
			 i < CurrentElement;
			 ++i )
			{
			pStack[ i ] = pStackOld[ i ];
			}

		delete pStackOld;

		}

	pStack[ CurrentElement++ ] = Element;

	return Element;

	}

IDICTELEMENT
ISTACK::Pop()
	{
	MIDL_ASSERT( CurrentElement != 0 );
	return pStack[ --CurrentElement ];
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\midlvers.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define rmj             6
#define rmm             0
#define rup             361
#define szVerName       ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\errhndl.cxx ===
/*****************************************************************************
 *  Copyright (c) 1993-1999 Microsoft Corporation
 *
 *			RPC compiler: error handler
 *
 *	Author	: Vibhas Chandorkar
 *	Created	: 22nd Aug 1990
 *
 ****************************************************************************/

#pragma warning ( disable : 4514 )      // Unreferenced inline function

/****************************************************************************
 *			include files
 ***************************************************************************/

#include "nulldefs.h"
extern	"C"	
	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	}
#include "common.hxx"
#include "errors.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "pragma.hxx"

extern CMessageNumberList GlobalMainMessageNumberList;

#define ERROR_PREFIX "MIDL"

/****************************************************************************
 *			local definitions and macros
 ***************************************************************************/

#include "errdb.h"

const ERRDB	UnknownError = 
{
0, CHECK_ERR(I_ERR_UNKNOWN_ERROR)
 MAKE_E_MASK(ERR_ALWAYS, C_MSG, CLASS_ERROR, NOWARN )
,"unknown internal error"
};


extern CMD_ARG	*	pCommand;

/*** IsErrorRelevant ******************************************************
 * Purpose	: To decide whether the error is going to be ignored anyhow, and
 *          : cut out further processing
 * Input	: error value
 * Output	: nothing
 * Notes	: The error number itself is an indicator of the location of
 *			: the error, (user/compile-time,run-time) , and severity.
 ****************************************************************************/
ErrorInfo::ErrorInfo( STATUS_T ErrValue )
{
	ErrVal = ErrValue;

	// cast away the constness
	pErrorRecord	 = (ERRDB *) ErrorDataBase;

	if( ErrVal < D_ERR_MAX )
		{
		pErrorRecord += ( ErrVal - D_ERR_START ) + INDEX_D_ERROR();
		}
	else if( ErrVal < C_ERR_MAX )
		{
		pErrorRecord += ( ErrVal - C_ERR_START ) + INDEX_C_ERROR();
		}
	else if( ErrVal < A_ERR_MAX )
		{
		pErrorRecord += ( ErrVal - A_ERR_START ) + INDEX_A_ERROR();
		}
	else
		{
		pErrorRecord = NULL;
		}
}

int
ErrorInfo::IsRelevant()
{
	unsigned short	ErrorClass	= GET_ECLASS( pErrorRecord->ErrMask );
	unsigned short	ErrorWL		= GET_WL( pErrorRecord->ErrMask );
	unsigned short	ModeSwitchConfigI	= pCommand->GetModeSwitchConfigMask();
	unsigned short	CurWL		= pCommand->GetWarningLevel();

    if ( pCommand->GetEnv() & pErrorRecord->inApplicableEnviron )
        {
        return FALSE;
        }

	// if this is not relevant to this mode, return FALSE
	if( GET_SC(pErrorRecord->ErrMask) & ModeSwitchConfigI )
		return FALSE;

	// does this qualify to be a warning in this mode ? If not return.
	if ( ErrorClass == CLASS_WARN )
		{
		if( CurWL < ErrorWL ) 
			return FALSE;
        if ( !GlobalMainMessageNumberList.GetMessageFlag( ErrVal ) )
            return FALSE;
		}
	return TRUE;
}

/*** RpcError ***************************************************************
 * Purpose	: To report an error in a formatted fashion
 * Input	: filename where the error occured, line number, error value
 *			: error mesage suffix string if any
 *			: input filename ptr could be NULL if no filename
 *			: suffix string ptr could be null if no suffix string
 * Output	: nothing
 * Notes	: The error number itself is an indicator of the location of
 *			: the error, (user/compile-time,run-time) , and severity.
 *			: Filename and line number depend upon where the error occurs. If
 *			: the error is a user-error(command line), file and line number
 *			: does not make sense. The input can be a NULL for filename, and
 *			: 0 for line number in case of the command line errors
 ****************************************************************************/
void
RpcError(
	char			*	pFile,					// filename where error occured
	short				Line,					// line number
	STATUS_T 			ErrVal,					// error value
	char			*	pSuffix)				// error message suffix string
{
	ErrorInfo			ErrDescription( ErrVal );

	// does this qualify to be an error in this mode ? If not return.
	if ( !ErrDescription.IsRelevant() )
		return;
	
	// report the error
	ErrDescription.ReportError( pFile, Line, pSuffix );

}


/*** RpcReportError ***************************************************************
 * Purpose	: To report an error in a formatted fashion
 * Input	: filename where the error occured, line number, error value
 *			: error mesage suffix string if any
 *			: input filename ptr could be NULL if no filename
 *			: suffix string ptr could be null if no suffix string
 * Output	: nothing
 * Notes	: The error number itself is an indicator of the location of
 *			: the error, (user/compile-time,run-time) , and severity.
 *			: Filename and line number depend upon where the error occurs. If
 *			: the error is a user-error(command line), file and line number
 *			: does not make sense. The input can be a NULL for filename, and
 *			: 0 for line number in case of the command line errors
 ****************************************************************************/
void
ErrorInfo::ReportError(
	char			*	pFile,					// filename where error occured
	short				Line,					// line number
	char			*	pSuffix)				// error message suffix string
	{
	char	*		pSeverity	= "error";
	char	*		pPrefix;
	unsigned short	ErrorClass	= GET_ECLASS( pErrorRecord->ErrMask );

	if (!pErrorRecord)
		{
		fprintf( stdout
				, "%s %c%.4d\n"
				, "internal error"
				, 'I'
				, ErrVal
			   );
		return;
		}

	switch( ErrorClass )
		{
		case CLASS_WARN:
			// check if all warnings emitted are to be treated as error
			if( !pCommand->IsSwitchDefined( SWITCH_WX ) )
				{
				pSeverity = "warning";
				}
			else
				{
				// treat as error.
				ErrorClass = CLASS_ERROR;
				}
			break;

		case CLASS_ADVICE:
			// we report these as warnings, because we want tools like VC++ to understand
			// our error messages for "jump to line" actions.
			pSeverity = "warning";
			break;

		case CLASS_ERROR:
		default:
			break;
		}

	// now report the error
	if ( !pSuffix )
		pSuffix = "";

	// mark command line errors specially
	if( GET_MT(pErrorRecord->ErrMask)  == 'D' )
		pPrefix = "command line ";
	else
		pPrefix = "";
		
	// if it a warning , dont increment error count

	if( ErrorClass == CLASS_ERROR )
        IncrementErrorCount();

    // Print the file and line number ...
    // If no file, print something anyway - this is required for automatic 
    // build tools to be able to parse and log error lines correctly.

	if( pFile )
        {
        if ( Line )
    		fprintf(  stdout, "%s(%d) : ", pFile, Line );
        else
    		fprintf(  stdout, "%s : ", pFile );
        }
    else
        fprintf( stdout, "midl : " );

	// print the error message
	fprintf( stdout
			, "%s%s " ERROR_PREFIX "%.4d : %s %s\n"
			, pPrefix
			, pSeverity
			, ErrVal
			, pErrorRecord->pError
			, pSuffix );

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\nulldefs.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define _far
#define _near
#define _huge
#define _cdecl
#define _pascal
#define far
#define near
#define huge
#define cdecl
#define pascal
#define _syscall
#define _stdcall
#define _based(x)
#define _segment int
#define volatile
#define __far
#define __near
#define __huge
#define __cdecl
#define __pascal
#define __syscall
#define __based(x)
#define __segment int
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\pragma.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1997-1999 Microsoft Corporation

 Module Name:

    pragma.cxx

 Abstract:

    Implementation of the object that maintains flags for each warning/error
    message. The flag indicates whether or not the warning should be emitted.
    Error messages are always emitted.

 Notes:


 Author:

    NishadM Dec-30-1997     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4512 )

#include "Pragma.hxx"

CMessageNumberList::CMessageNumberList()
{
    SetAll();
}

void CMessageNumberList::SetAll()
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] = ( unsigned long ) -1;
        }
}

void CMessageNumberList::ResetAll()
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] = 0;
        }
}

unsigned long CMessageNumberList::BitIndex( unsigned long ulMsg )
{
    if ( ulMsg >= C_ERR_START && ulMsg <= C_ERR_MAX )
        {
        ulMsg = ulMsg - C_ERR_START + D_ERR_MAX - D_ERR_START + 2;
        }
    else if ( ulMsg >= D_ERR_START && ulMsg <= D_ERR_MAX )
        {
        ulMsg = ulMsg - D_ERR_START + 1;
        }
    else
        {
        ulMsg = 0;
        }
    return ulMsg;
}

void CMessageNumberList::SetMessageFlags( CMessageNumberList& list )
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] |= list.fMessageNumber[i];
        }
}

void CMessageNumberList::ResetMessageFlags( CMessageNumberList& list )
{
    for ( unsigned long i = 0; i < c_nMsgs; i++ )
        {
        fMessageNumber[i] &= ~(list.fMessageNumber[i]);
        }
}

/*
GlobalMainMessageNumberList contains the list of currently enabled/disabled warnings. 
*/
CMessageNumberList   GlobalMainMessageNumberList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\driver\cmdline.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef _CMDLINE_HXX_
#define _CMDLINE_HXX_

#include "idict.hxx"
#include "cmdana.hxx"

class CommandLine : public _cmd_arg
    {
    private:
        IDICT*    pArgDict;            // arguments dictionary
    public:
        CommandLine()
            {
            pArgDict = NULL;
            }

        // register argument vector with the command processor
        void            RegisterArgs( char *[], short );

        // process arguments. This is the command analyser main loop, so to speak.
        STATUS_T        ProcessArgs();

        // get the next argument from the argument vector.
        char    *       GetNextArg();

        // push back argument. Undo the effect of GetNextArg.
        void            UndoGetNextArg();

        // depending upon the switch argument type, bump the argument pointer to
        // the next switch.
        STATUS_T        BumpThisArg( char **, unsigned short );

        // set any post switch processing defaults

        STATUS_T        SetPostDefaults();
        void            SetPostDefaults64();

        // process a filename switch .

        STATUS_T        ProcessFilenameSwitch( short, char * );

        // process a multiple arguments switch.

        STATUS_T        ProcessMultipleSwitch( short, char *, char * );

        // process a onetime argument switch.

        STATUS_T        ProcessOnetimeSwitch( short, char * );

        // process an ordinary switch

        STATUS_T        ProcessOrdinarySwitch( short, char * );

        // process a simple switch multiply defined.

        STATUS_T        ProcessSimpleMultipleSwitch( short, char * );
        void            Confirm();
        STATUS_T        Help();
        char*           GetCompilerVersion();
        char*           GetCompileTime();
    };

#endif // _CMDLINE_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\driver\exec.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <windows.h>

#include "errors.hxx"

STATUS_T
Execute( char* szCmd, char* szCmdFile )
    {
    PROCESS_INFORMATION prc;
    STARTUPINFO         info;
    BOOL                fCreated;
    char                cmdLine[512];
    STATUS_T            status = STATUS_OK;

    ZeroMemory( &info, sizeof( info ) );
    info.cb = sizeof( info );
    info.hStdError = GetStdHandle( STD_ERROR_HANDLE );
    info.hStdInput = GetStdHandle( STD_INPUT_HANDLE );
    info.hStdOutput = GetStdHandle( STD_OUTPUT_HANDLE );

    strcpy( cmdLine, szCmd );
    strcat( cmdLine, " \"" );       // quote the command file in case it has
    strcat( cmdLine, szCmdFile );   // spaces in the path
    strcat( cmdLine, "\" " );

    fCreated = CreateProcess( NULL, cmdLine, 0, 0, TRUE, 0, 0, 0, &info, &prc );

    if ( fCreated )
        {
        WaitForSingleObject( prc.hProcess, INFINITE );
        GetExitCodeProcess( prc.hProcess, ( LPDWORD ) &status );

        CloseHandle( prc.hThread );
        CloseHandle( prc.hProcess );
        }
    else
        {
        status = SPAWN_ERROR;
        }

    return status;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\common\stream.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 4710 )

#include "nulldefs.h"
#include <basetsd.h>
#include <stdio.h>
#include <stdarg.h>

#include <string.h>
#include <share.h>
#include <memory.h>
#include <io.h>
#include <fcntl.h>
#include <limits.h>
#include "stream.hxx"
#include "errors.hxx"
#include "cmdana.hxx"

STREAM::~STREAM()
	{
	Close();
	}

STREAM::STREAM(
	IN		char		*	pFileName,
	IN		unsigned char 	SProt )
{

	ResetConsoleStream();
	ResetIgnore();
	pSpecialCommentString = NULL;

	// no alternate file to begin with
	StreamOpenStatus = FILE_STATUS_OK;

	if( !pFileName )
	    {
		SetStreamType( STREAM_NULL );
		ResetError();
		ResetEnd();
		return;
	    }
	else if( *(pFileName+2) == '-' )
		{
		S.F.pHandle = stdout;
		SetConsoleStream();
		}
	else	// named file stream
		{
		// if this is a not a file to overwrite, and it exists, don't overwrite it
		// substitute a temp file instead
		if ( (SProt != FILE_STREAM_OVERWRITE) && 
			 !_access( pFileName, 0 ) )
			{
			if ( SProt == FILE_STREAM_REWRITE )
				{
				// note that tmpfile is opened w+b
				S.F.pHandle = tmpfile();
				StreamOpenStatus = FILE_STATUS_TEMP;
				}
			else	// write-once file already exists, do nothing
				{
				S.F.pHandle = NULL;
				StreamOpenStatus = FILE_STATUS_NO_WRITE;
				SetStreamType( STREAM_NULL );
				ResetError();
				ResetEnd();
				return;
				}
			}
		else	// overwritable file...
			{
            if ( pCommand->HasAppend64() || pCommand->Is2ndCodegenRun() )
                {
    			S.F.pHandle = _fsopen( pFileName, "r+t", SH_DENYWR);
            	if( S.F.pHandle )
                    {
                    // Position at the end of the file.
                    if ( 0 != fseek( S.F.pHandle, 0, SEEK_END ) )
                        {
                        fclose( S.F.pHandle );
                        S.F.pHandle = NULL;
                        }
                    }
                else
                    {
                    // May be the file does not exist, let's open to write.
                    // (it happens only when -append64 is used in the first run).

        			S.F.pHandle = _fsopen( pFileName, "wt", SH_DENYWR);
                    }
                }
            else
	    		S.F.pHandle = _fsopen( pFileName, "wt", SH_DENYWR);
			}

		if ( S.F.pHandle )
			{
			setvbuf( S.F.pHandle, NULL, _IOFBF, 32768 );
			}
		}

	if( S.F.pHandle == (FILE *)0 )
		{
		RpcError( (char *)NULL,
				  	0,
				  	ERROR_WRITING_FILE,
				  	pFileName );
	
		exit( ERROR_WRITING_FILE );
		}
	else
		{
		SetStreamType( STREAM_FILE );
        SetStreamMode( STREAM_TEXT );
		ResetError();
		ResetEnd();
		}
}

STREAM::STREAM(
	IN		FILE	* pFile )
{
	S.F.pHandle = pFile;
    SetStreamType( STREAM_FILE );
    SetStreamMode( STREAM_TEXT );
	ResetError();
	ResetEnd();
	ResetIgnore();
    ResetConsoleStream();
	pSpecialCommentString = NULL;

	// no alternate file to begin with
	StreamOpenStatus = FILE_STATUS_OK;
}

STREAM::STREAM()
{
    S.F.pHandle = NULL;
	SetStreamType( STREAM_MEMORY );
    SetStreamMode( STREAM_TEXT );
	ResetEnd();
	ResetError();
	ResetIgnore();
    ResetConsoleStream();
	StreamOpenStatus = FILE_STATUS_OK;
    pSpecialCommentString = NULL;

	SetCurrentPtr( new char[ SetInitialSize( DEFAULT_MEM_SIZE_FOR_STREAM ) ] );
	SetInitialIncr( DEFAULT_MEM_INCR_FOR_STREAM );
	SetStart( GetCurrentPtr() );
	SetMemStreamEnd( GetCurrentPtr() + GetInitialSize() );
}

STREAM::STREAM(
	int		InitialSize,
	int		InitialIncr )
{
    S.F.pHandle = NULL;
	SetStreamType( STREAM_MEMORY );
    SetStreamMode( STREAM_TEXT );
	ResetEnd();
	ResetError();
	ResetIgnore();
    ResetConsoleStream();
	StreamOpenStatus = FILE_STATUS_OK;
    pSpecialCommentString = NULL;

	SetCurrentPtr( new char[ SetInitialSize( InitialSize ) ] );
	SetInitialIncr( InitialIncr );
	SetStart( GetCurrentPtr() );
	SetMemStreamEnd( GetCurrentPtr() + GetInitialSize() );
}

void
STREAM::SetStreamMode(
    STREAM_MODE mode)
{
    StreamMode = mode;
    int newmode = ( mode == STREAM_BINARY ) ? _O_BINARY : _O_TEXT;

    if (S.F.pHandle)
        _setmode( _fileno( S.F.pHandle ), newmode );
}

#if 0

void
STREAM::Write(
	IN		char	C )
{
	if( (GetStreamType() == STREAM_FILE ) && !IsError() )
		putc( C, S.F.pHandle );
	else
		{
		if( S.M.pCurrent >= S.M.pEnd )
			{
			Expand();
			}
		*(S.M.pCurrent)++ = C;
		}
}
#endif // 0

void 
STREAM::Write(
    IN      const void  *  p, 
    IN      int Len)
{
    if ( ( GetStreamType() == STREAM_NULL ) || IsError() || IsIgnore() )
        return;

    if( (GetStreamType() == STREAM_FILE ) )
        {
        fwrite( p, 1, Len, S.F.pHandle );
        if( IsConsoleStream() )
            fflush( S.F.pHandle );
        }
    else
        {
        if( (GetCurrentPtr() + Len) >= S.M.pEnd )
            {
            ExpandBy( short( Len + GetInitialIncr() ) );
            }
        memcpy( GetCurrentPtr(), p, Len );
        SetCurrentPtr( GetCurrentPtr() + Len );
        }
}

void 
STREAM::Write(
    IN      const char  *  const  string)
{
    if ( string )
        Write( (void *) string, strlen( string ) );

    if ( GetStreamMode() == STREAM_BINARY )
        Write( '\0' );
}

void
STREAM::WriteNumber(
	IN		const char	*	pFmt,
	IN		const unsigned long ul )
{
	char	buffer[128];

	if ( ( GetStreamType() == STREAM_NULL ) || IsError() || IsIgnore() )
		return;

	if( (GetStreamType() == STREAM_FILE ) )
		{
		fprintf(  S.F.pHandle, pFmt, ul );
		if( IsConsoleStream() )
			fflush( S.F.pHandle );
		}
	else
		{
		sprintf( buffer, pFmt, ul );

		short Len	= (short) strlen( buffer );

		if( (GetCurrentPtr() + Len) >= S.M.pEnd )
			{
			ExpandBy( short( Len + GetInitialIncr() ) );
			}
		memcpy( GetCurrentPtr(), buffer, Len );
		SetCurrentPtr( GetCurrentPtr() + Len );
		}
}

void
STREAM::WriteFormat(
        const char * pFmt,
        ... )
{

    char	buffer[128];    

	if ( ( GetStreamType() == STREAM_NULL ) || IsError() || IsIgnore() )
		return;
        
        va_list Arguments;
        va_start( Arguments, pFmt );        

	if( (GetStreamType() == STREAM_FILE ) )
		{
		vfprintf(  S.F.pHandle, pFmt, Arguments );
		if( IsConsoleStream() )
			fflush( S.F.pHandle );
		}
	else
		{
		vsprintf( buffer, pFmt, Arguments );

		short Len	= (short) strlen( buffer );

		if( (GetCurrentPtr() + Len) >= S.M.pEnd )
			{
			ExpandBy( short( Len + GetInitialIncr() ) );
			}
		memcpy( GetCurrentPtr(), buffer, Len );
		SetCurrentPtr( GetCurrentPtr() + Len );
		}

        va_end( Arguments );
}


void
STREAM::Flush()
{

	if( (GetStreamType() == STREAM_FILE ) && !IsError() )
		if( IsConsoleStream() )
			fflush( S.F.pHandle );
}

void
STREAM::Close()
{
	if( (GetStreamType() == STREAM_FILE ) )
		fclose( S.F.pHandle );
}

int
STREAM::SetInitialSize(
	int	InitialSize )
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.InitialSize = InitialSize);

	return 0;
}

int
STREAM::GetInitialSize()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.InitialSize;
	return 0;
}

int
STREAM::SetInitialIncr(
	int	InitialIncr )
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.Increment = InitialIncr);
	return 0;
}

int
STREAM::GetInitialIncr()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.Increment;

	return 0;
}

char *
STREAM::Expand()
{
	if( GetStreamType() == STREAM_MEMORY )
		{
		int	Len 	 = GetInitialSize();
		char * pTemp = GetStart();

		SetStart( new char[ SetInitialSize( Len + GetInitialIncr() ) ] );

		memcpy( GetStart(), pTemp, Len );
		SetCurrentPtr( GetStart() + Len );
		delete pTemp;
		return GetCurrentPtr();
		}

	return 0;
}
char *
STREAM::ExpandBy( short Amt)
{
	if( GetStreamType() == STREAM_MEMORY )
		{
		int	Len 	 = GetInitialSize();
		char * pTemp = GetStart();

		SetStart( new char[ SetInitialSize( Len + GetInitialIncr() + Amt ) ] );

		memcpy( GetStart(), pTemp, Len );
		SetCurrentPtr( GetStart() + Len );
		delete pTemp;
		return GetCurrentPtr();
		}

	return 0;
}
char *
STREAM::NewCopy()
	{
	if( GetStreamType() == STREAM_MEMORY )
		{
        MIDL_ASSERT( (S.M.pCurrent - S.M.pMem + 1) <= INT_MAX );
		int Len = (int) (S.M.pCurrent - S.M.pMem + 1);
		char * p = new char[ Len ]; 
		memcpy( p, S.M.pMem, Len );
		return p;
		}
	return 0;
	}

char *
STREAM::SetCurrentPtr(
	char * pCur)
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.pCurrent = pCur);
	return 0;
}

char *
STREAM::GetCurrentPtr()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.pCurrent;
	return 0;
}

long
STREAM::GetCurrentPosition()
{
    long Position = 0;

    if( GetStreamType() == STREAM_FILE )
        Position = ftell( S.F.pHandle );

    return Position;
}

void
STREAM::SetCurrentPosition( long Position)
{
    if( GetStreamType() == STREAM_FILE )
        if ( 0 != fseek( S.F.pHandle, Position, SEEK_SET ) )
            MIDL_ASSERT(!"fseek failed");

    return;
}


char *
STREAM::SetStart(
	char * pStart)
{
	if( GetStreamType() == STREAM_MEMORY )
		return (S.M.pMem = pStart);
	return 0;
}

char *
STREAM::GetStart()
{
	if( GetStreamType() == STREAM_MEMORY )
		return S.M.pMem;
	return 0;
}

#define MAX_INDENT (sizeof(SpaceBuffer) - 1)

static
char SpaceBuffer[] = "                                                      "
		 "                                                                  "
		 "                                                                  "
		 "                                                                  ";

#define MAX_NEWLINES (sizeof(NewLineBuffer) - 1)

static
char NewLineBuffer[] = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";


void
ISTREAM::NewLine()
{
	unsigned short	usIndent	= CurrentIndent;

	if (usIndent > MAX_INDENT )
		{
		usIndent = MAX_INDENT;
		};

	Write('\n');

	SpaceBuffer[usIndent] = '\0';
	Write( (char *) SpaceBuffer);

	SpaceBuffer[usIndent] = ' ';
}

void
ISTREAM::NewLine( unsigned short count )
{
	unsigned short	usIndent	= CurrentIndent;

	if (usIndent > MAX_INDENT )
		{
		usIndent = MAX_INDENT;
		};

	if ( count > MAX_NEWLINES )
		{
		count = MAX_NEWLINES;
		};

	NewLineBuffer[ count ] = '\0';
	Write( (char *) NewLineBuffer);
	NewLineBuffer[ count ] = '\n';

	SpaceBuffer[usIndent] = '\0';
	Write( (char *) SpaceBuffer);

	SpaceBuffer[usIndent] = ' ';
}


void
ISTREAM::Spaces(
	unsigned short NoOfSpaces )
{
	if (NoOfSpaces > MAX_INDENT )
		{
		NoOfSpaces = MAX_INDENT;
		};

	SpaceBuffer[NoOfSpaces] = '\0';
	Write( (char *) SpaceBuffer);

	SpaceBuffer[NoOfSpaces] = ' ';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\driver\main.cxx ===
#pragma warning ( disable : 4514 )

#include <stdio.h>
#include <malloc.h>
#include <excpt.h>
#include <process.h>
#include <string.h>

#include "cmdline.h"
#include "errdb.h"

#ifdef MIDL_INTERNAL
#define MIDL_FREE_BUILD  0
#define MIDL_INTERNAL_PRINTF(x)  printf(x)  
#else
#define MIDL_FREE_BUILD  1
#define MIDL_INTERNAL_PRINTF(x)  
#endif

const char *pSignon1 = "Microsoft (R) 32b/64b MIDL Compiler Version %s \n";
const char *pSignon2 = "Copyright (c) Microsoft Corporation 1991-2002. All rights reserved.\n";

STATUS_T Execute( char* szCmd, char* szCmdLine );
void RpcError( char* pFile, short Line, STATUS_T status, char* pSuffix );
void ReportError( STATUS_T status, char* szMsg );
void WriteCommandAnaFile(char *pszFilename, CommandLine *pCmdLine);

extern "C" long __stdcall GetTempPathA( long, char * );
extern "C" long __stdcall GetTempFileNameA( const char*, const char*, unsigned int, char * );

CMD_ARG*    pCommand;
bool        fCommandLineErrors = false;

inline bool BadIntermediateFileError( STATUS_T status )
{
    return    ( BAD_CMD_FILE            == status )
           || ( UNABLE_TO_OPEN_CMD_FILE == status );
}


int
main(
    int     argc,
    char**  argv
    )
    {
    STATUS_T        status = STATUS_OK;
    char            szTempCmdFile[_MAX_PATH];

    _try
        {
        CommandLine* pCmdLine = new CommandLine;
        pCommand = pCmdLine;

        // /nologo is specially detected by RegisterArgs
        pCmdLine->RegisterArgs( argv+1, short(argc -1) );
        char* szVersion = pCmdLine->GetCompilerVersion();
        pCmdLine->GetCompileTime();

        if ( pCmdLine->ShowLogo() )
            {
            // the signon
            fprintf( stderr, pSignon1, szVersion );
            fprintf( stderr, pSignon2 );
            fflush( stderr );
            }

        status = pCmdLine->ProcessArgs();

        if( status == STATUS_OK && ! fCommandLineErrors )
            {
            if( pCmdLine->IsSwitchDefined( SWITCH_CONFIRM ) )
                {
                pCmdLine->Confirm();
                }
            else if( pCmdLine->IsSwitchDefined( SWITCH_HELP ) )
                {
                pCmdLine->Help();
                }
            else
                {
                char path_buffer[_MAX_PATH];
                char drive[_MAX_DRIVE];
                char dir[_MAX_DIR];
                char fname[_MAX_FNAME];
                char ext[_MAX_EXT];

                // Create the core intermediate file

                GetTempPathA( _MAX_PATH, path_buffer );

                if ( !GetTempFileNameA(path_buffer, "MIDLC", 0, szTempCmdFile) )
                    {
                    status = INTERMEDIATE_FILE_CREATE;
                    RpcError( NULL, 0, status, path_buffer);
                    return status;
                    }

                WriteCommandAnaFile( szTempCmdFile, pCmdLine );
        
                // The path to midlc.exe should be the same as the path to
                // midl.exe

                _splitpath( argv[0], drive, dir, fname, ext );
                _makepath( path_buffer, drive, dir, "midlc", "exe" );

                // if -debugline is present, spit out the midlcore command
                // line and quit; the command ana file is preserved.

                if ( pCmdLine->IsSwitchDefined( SWITCH_DEBUGLINE ) )
                {
                    printf( "\ndebugline: %s %s\n", path_buffer, szTempCmdFile );
                    return 0;
                }

                // spawn 32b MIDL run

                status = ( STATUS_T ) Execute( path_buffer, szTempCmdFile );

                if ( ! BadIntermediateFileError( status ) )
                    _unlink( szTempCmdFile );

                if ( !pCmdLine->IsSwitchDefined( SWITCH_ENV ) && status == STATUS_OK )
                    {
                    // spawn 64b MIDL run
                    pCmdLine->SetEnv( ENV_WIN64 );
                    pCmdLine->SetHasAppend64( TRUE );
                    pCmdLine->SwitchDefined( SWITCH_APPEND64 );
                    pCmdLine->SetPostDefaults64();

                    if ( status == STATUS_OK && ! fCommandLineErrors )
                        {
                        WriteCommandAnaFile( szTempCmdFile, pCmdLine );

                        status = ( STATUS_T ) Execute( path_buffer, szTempCmdFile );

                        if ( ! BadIntermediateFileError( status ) )
                            _unlink( szTempCmdFile );
                        }
                    }
                }
            }

        if ( status == SPAWN_ERROR )
            {
            RpcError( 0, 0, status, 0 );
            }
        }
    __except( MIDL_FREE_BUILD && ! pCommand->IsSwitchDefined( SWITCH_DEBUGEXC ) )
        {
        // Catch exceptions only for free builds run without -debugexc switch.
        status = (STATUS_T) GetExceptionCode();
        printf( "\nmidl : error MIDL%d : internal compiler problem -",
                I_ERR_UNEXPECTED_INTERNAL_PROBLEM );
        printf( " See documentation for suggestions on how to find a workaround.\n" );
        }

    return status;
    }

void WriteCommandAnaFile(
    char *pszFilename, 
    CommandLine *pCmdLine
    )
    {
    STREAM stream( pszFilename );
    stream.SetStreamMode( STREAM_BINARY );
    pCmdLine->StreamOut( &stream );
    fflush( NULL );
    }    
    
void
IncrementErrorCount()
    {
    fCommandLineErrors = true;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\driver\cmdana.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    cmdana.cxx


 Abstract:

    This file handles all command (switch) processing for the MIDL compiler.

 Notes:


 Author:

    vibhasc

    Nov-12-1991    VibhasC        Modified to conform to coding style gudelines


 Notes:

    The command analysis is handled by a command analyser object. The MIDL
    compiler registers its arguments with the command analyser and calls the
    ProcessArgs functions. The ProcessArgs performs syntactic analysis of the
    switch specification by checking for (1) proper switch syntax, (2) duplicate
    definition of the switch, and (3) illegal switch specification. After all
    the switches are analysed, the SetPostDefault function is called to set the
    default compiler switch values etc.

    Currently switches fall into these categories:

        (1) one-time switches : these can be specified only once, and the
            redefinition results in a warning and the second defintion
            overrides the first. Examples are -cc_cmd / -cc_opt etc.

        (2) multiple definition switches: such switches can be specified
            multiple times. These include /I, /D, /U etc.

        (3) filename switches : this is switch class specialises in filename
            argument handling.

        (4) ordinary switches : all other switches fall into this category.
            Normally a redef of such a switch is also a warning. These are
            different from the one-time switch category just for convenience.
            These switches normally set some internal flag etc and do not need
            the user specified argument to be stored in string form like
            the -cc_cmd etc.

    A general word about the command analyser. Switch syntax comes in various
    flavours. Some switches take arguments, some do not. Switches which have
    arguments may have spaces necesary between the arguments and switch name,
    others may not. The most interesting case, however is when the switch
    may have as its argument a switch-like specification, which should not be
    confused with another MIDL switch. We keep a data-base of switches in the
    switch descriptor, which keeps info about the switch name, switch
    enumeration and the switch syntax descriptor. The core switch syntax
    analyser is BumpThisArg which uses this descriptor.

    Also, some switches like -W? and -Wx must really be separate switches
    because -W? and -Wx can co-exist at the same time. If we treat the switch
    recognition as the same, then the code must detect a separate definition,
    and set the command analyser flags.This approach results in unnecessary code
    all over the place. An alternative is to recognise the Wx as a separate
    switch in the SearchForSwitch routine and return a different switch to
    the command analyser. This is a much cleaner approach. Only, the parsing
    becomes tricky. Since -W? and -Wx look VERY similar, and SearchForSwitch
    stops at the first match, we need to define -Wx BEFORE -W in the switch
    descriptor table. This happens also with the client client_env and -server
    and -server_env switches. In any case it we remember to properly keep
    tables such that the longer string is kept first, this problem gets isolated
    to a very small, manageable part of the command analyser. I therefore
    chose this approach.

     Note: MIDL_INTERNAL is specified by a C preprocessor command line -D option.
     This corresponds to debugging builds for internal purposes only.
 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 *    include files
 ***************************************************************************/

#include "cmdline.h"
#include "stream.hxx"
#include "midlvers.h"

#include <string.h>
#include <io.h>
#include <time.h>

/****************************************************************************
 *    local definitions
 ***************************************************************************/

/**
 ** definitions for the type of switch arguments.
 ** switches may or may not expect arguments, there may be spaces
 ** between the switch and its argument(s). One special case is when the
 ** argument can be switch like, .ie have the - or / as the argument starter,
 ** so we need to treat such switches specially.
 **/

#define ARG_NONE            (0x01)        /* no arg for this switch */
#define ARG_YES             (0x02)        /* arg expected for this switch */
#define ARG_SPACE           (0x04)        /* (a) space(s) may be present */
#define ARG_NO_SPACE        (0x08)        /* no space is allowed */
#define ARG_SWITCH_LIKE     (0x10)        /* the arg may be switch-like */
#define ARG_OPTIONAL        (ARG_YES + ARG_NONE + ARG_SPACE)


#define ARG_SPACED            (ARG_YES + ARG_SPACE)
#define ARG_SPACE_NONE        (ARG_YES + ARG_NO_SPACE)
#define ARG_SPACE_OPTIONAL    (ARG_YES + ARG_NO_SPACE + ARG_SPACE)
#define ARG_CC_ETC            (ARG_SPACE_OPTIONAL + ARG_SWITCH_LIKE)

/***
 *** Preferably keep this table sorted by name.
 *** Also, partially matching names like -client / -client_env, -W/-Wx must
 *** be kept so that the longer sub-string appears first. The only
 *** reason to keep this sorted, is so that we can visually ensure this.
 ***/

const struct sw_desc
    {
    const char     *        pSwitchName;        // switch string
    unsigned short          flag;               // switch descriptor
    enum _swenum            SwitchValue;        // switch enum value
    } switch_desc[] = {
          { "",              ARG_NONE            , SWITCH_NOTHING }
        , { "?",             ARG_NONE            , SWITCH_HELP }
        , { "D",             ARG_SPACE_OPTIONAL  , SWITCH_D }
        , { "I",             ARG_SPACE_OPTIONAL  , SWITCH_I }
        , { "O",             ARG_SPACE_OPTIONAL  , SWITCH_O }
        , { "U",             ARG_SPACE_OPTIONAL  , SWITCH_U }
        , { "WX",            ARG_NONE            , SWITCH_WX }
        , { "W",             ARG_SPACE_NONE      , SWITCH_W }
        , { "Zp",            ARG_SPACE_NONE      , SWITCH_ZP }
        , { "Zs",            ARG_NONE            , SWITCH_ZS }
        , { "append64",      ARG_NONE            , SWITCH_APPEND64 }
        , { "acf",           ARG_SPACE_OPTIONAL  , SWITCH_ACF }
        , { "c_ext",         ARG_NONE            , SWITCH_C_EXT }
        , { "char",          ARG_SPACED          , SWITCH_CHAR }
        , { "client",        ARG_SPACED          , SWITCH_CLIENT }
        , { "confirm",       ARG_NONE            , SWITCH_CONFIRM }
        , { "nologo",        ARG_NONE            , SWITCH_NOLOGO }
        , { "cpp_cmd",       ARG_CC_ETC          , SWITCH_CPP_CMD }
        , { "cpp_opt",       ARG_CC_ETC          , SWITCH_CPP_OPT }
        , { "msc_ver",       ARG_SPACED          , SWITCH_MSC_VER }
        , { "cstub",         ARG_CC_ETC          , SWITCH_CSTUB }
        , { "nocstub",       ARG_NONE            , SWITCH_NO_CLIENT }

#ifdef MIDL_INTERNAL
        , { "dump",          ARG_NONE            , SWITCH_DUMP }
#endif // MIDL_INTERNAL

        , { "debugexc",      ARG_NONE            , SWITCH_DEBUGEXC }
        , { "debugline",     ARG_NONE            , SWITCH_DEBUGLINE }
        , { "debug64_opt",   ARG_SPACED          , SWITCH_DEBUG64_OPT }
        , { "debug64",       ARG_SPACED          , SWITCH_DEBUG64 }
        , { "dlldata",       ARG_CC_ETC          , SWITCH_DLLDATA }
        , { "env",           ARG_SPACED          , SWITCH_ENV }
        , { "error",         ARG_SPACED          , SWITCH_ERROR }
        , { "robust",        ARG_NONE            , SWITCH_ROBUST }
        , { "header",        ARG_CC_ETC          , SWITCH_HEADER }
        , { "help",          ARG_NONE            , SWITCH_HELP }
        , { "iid",           ARG_CC_ETC          , SWITCH_IID }
        , { "internal",      ARG_NONE            , SWITCH_INTERNAL }
        , { "lcid",          ARG_SPACED          , SWITCH_LOCALE_ID }
        , { "mktyplib203",   ARG_NONE            , SWITCH_MKTYPLIB }
        , { "newtlb",        ARG_NONE            , SWITCH_NEW_TLB }
        , { "no_cpp",        ARG_NONE            , SWITCH_NO_CPP }
        , { "no_def_idir",   ARG_NONE            , SWITCH_NO_DEF_IDIR }
        , { "no_warn",       ARG_NONE            , SWITCH_NO_WARN }
        , { "use_epv",       ARG_NONE            , SWITCH_USE_EPV }
        , { "no_default_epv",ARG_NONE            , SWITCH_NO_DEFAULT_EPV }
        , { "no_robust",     ARG_NONE            , SWITCH_NO_ROBUST }
        , { "no_stamp",      ARG_NONE            , SWITCH_NO_STAMP }
        , { "oldnames",      ARG_NONE            , SWITCH_OLDNAMES }
        , { "oldtlb",        ARG_NONE            , SWITCH_OLD_TLB }
        , { "osf",           ARG_NONE            , SWITCH_OSF }
        , { "out",           ARG_SPACE_OPTIONAL  , SWITCH_OUT }

#ifdef MIDL_INTERNAL
        , { "override",      ARG_NONE            , SWITCH_OVERRIDE }
#endif // MIDL_INTERNAL

        , { "pack",          ARG_SPACED          , SWITCH_PACK }
        , { "prefix",        ARG_SPACED          , SWITCH_PREFIX }
//        , { "suffix",        ARG_SPACED          , SWITCH_SUFFIX }
        , { "proxy",         ARG_CC_ETC          , SWITCH_PROXY }
        , { "noproxy",       ARG_NONE            , SWITCH_NO_PROXY }
        , { "proxydef",      ARG_CC_ETC          , SWITCH_PROXY_DEF }
        , { "noproxydef",    ARG_NONE            , SWITCH_NO_PROXY_DEF }
        , { "dlldef",        ARG_CC_ETC          , SWITCH_DLL_SERVER_DEF }
        , { "nodlldef",      ARG_NONE            , SWITCH_NO_DLL_SERVER_DEF }
        , { "dllmain",       ARG_CC_ETC          , SWITCH_DLL_SERVER_CLASS_GEN }
        , { "nodllmain",     ARG_NONE            , SWITCH_NO_DLL_SERVER_CLASS_GEN }
        , { "reg",           ARG_CC_ETC          , SWITCH_SERVER_REG }
        , { "noreg",         ARG_NONE            , SWITCH_NO_SERVER_REG }
        , { "exesuppt",      ARG_CC_ETC          , SWITCH_EXE_SERVER }
        , { "noexesuppt",    ARG_NONE            , SWITCH_NO_EXE_SERVER }
        , { "exemain",       ARG_CC_ETC          , SWITCH_EXE_SERVER_MAIN }
        , { "noexemain",     ARG_NONE            , SWITCH_NO_EXE_SERVER_MAIN }
        , { "testclient",    ARG_CC_ETC          , SWITCH_TESTCLIENT }
        , { "notestclient",  ARG_NONE            , SWITCH_NO_TESTCLIENT }
        , { "methods",       ARG_CC_ETC          , SWITCH_CLASS_METHODS }
        , { "nomethods",     ARG_NONE            , SWITCH_NO_CLASS_METHODS }
        , { "iunknown",      ARG_CC_ETC          , SWITCH_CLASS_IUNKNOWN }
        , { "noiunknown",    ARG_NONE            , SWITCH_NO_CLASS_IUNKNOWN }
        , { "class_hdr",     ARG_CC_ETC          , SWITCH_CLASS_HEADER }
        , { "noclass_hdr",   ARG_NONE            , SWITCH_NO_CLASS_HEADER }

        , { "savePP",        ARG_NONE            , SWITCH_SAVEPP }

        , { "server",        ARG_SPACED          , SWITCH_SERVER }
        , { "sstub",         ARG_CC_ETC          , SWITCH_SSTUB }
        , { "nosstub",       ARG_NONE            , SWITCH_NO_SERVER }
        , { "syntax_check",  ARG_NONE            , SWITCH_SYNTAX_CHECK }
        , { "target",        ARG_SPACED          , SWITCH_TARGET_SYSTEM }
        , { "warn",          ARG_SPACED          , SWITCH_W }

#ifdef MIDL_INTERNAL
        , { "x",             ARG_NONE            , SWITCH_X }
#endif // MIDL_INTERNAL

        , { "ms_ext",        ARG_NONE            , SWITCH_MS_EXT }
        , { "ms_conf_struct",ARG_NONE            , SWITCH_MS_CONF_STRUCT }
        , { "ms_union",      ARG_NONE            , SWITCH_MS_UNION }
        , { "no_format_opt", ARG_NONE            , SWITCH_NO_FMT_OPT }
        , { "app_config",    ARG_NONE            , SWITCH_APP_CONFIG }
        , { "rpcss",         ARG_NONE            , SWITCH_RPCSS }
        , { "hookole",       ARG_NONE            , SWITCH_HOOKOLE }
        , { "netmonstub",    ARG_CC_ETC          , SWITCH_NETMON_STUB_OUTPUT_FILE}
        , { "netmonobjstub", ARG_CC_ETC          , SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE}
        , { "netmon",        ARG_NONE            , SWITCH_NETMON }
        , { "version_stamp", ARG_NONE            , SWITCH_VERSION_STAMP }
// MKTYPLIB switches
        , { "tlb",           ARG_SPACED          , SWITCH_TLIB }
        , { "o",             ARG_SPACED          , SWITCH_REDIRECT_OUTPUT }
        , { "h",             ARG_CC_ETC          , SWITCH_HEADER }
        , { "align",         ARG_SPACE_OPTIONAL  , SWITCH_ZP }
        , { "nocpp",         ARG_NONE            , SWITCH_NO_CPP }
        , { "wire_compat"   ,ARG_SPACED          , SWITCH_WIRE_COMPAT }
        , { "wi",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // win16, win32, win64
        , { "do",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // dos
        , { "ma",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // mac
        , { "po",            ARG_SPACE_NONE      , SWITCH_ODL_ENV } // powermac

        , { "no_buffer_reuse", ARG_NONE          , SWITCH_NOREUSE_BUFFER }
        , { "use_vt_int_ptr",ARG_NONE            , SWITCH_USE_VT_INT_PTR }
        , { "notlb"         ,ARG_NONE            , SWITCH_NO_TLIB }
        , { "protocol"      ,ARG_SPACED          , SWITCH_TRANSFER_SYNTAX }
        , { "ms_ext64"      ,ARG_NONE            , SWITCH_MS_EXT64 }
        , { "debuginfo"     ,ARG_NONE            , SWITCH_DEBUGINFO }
    };

const CHOICE    CharChoice[] =
    {
         { "signed"         , CHAR_SIGNED }
        ,{ "unsigned"       , CHAR_UNSIGNED }
        ,{ "ascii7"         , CHAR_ANSI7 }
        ,{ 0                , 0 }
    };

const CHOICE    ErrorChoice[] =
    {
         { "all"            , ERROR_ALL }
        ,{ "allocation"     , ERROR_ALLOCATION }
        ,{ "bounds_check"   , ERROR_BOUNDS_CHECK }
        ,{ "enum"           , ERROR_ENUM }
        ,{ "ref"            , ERROR_REF }
        ,{ "stub_data"      , ERROR_STUB_DATA }
        ,{ "none"           , ERROR_NONE }
        ,{ 0                , 0 }
    };

const CHOICE    EnvChoice[] =
    {
         { "dos"            , ENV_OBSOLETE }
        ,{ "win16"          , ENV_OBSOLETE }
        ,{ "win32"          , ENV_WIN32 }
        ,{ "win64"          , ENV_WIN64 }
        ,{ "mac"            , ENV_OBSOLETE }
        ,{ "powermac"       , ENV_OBSOLETE }
        ,{ 0                , 0 }
    };

const CHOICE    SyntaxChoice[] =
    {
        { "dce"             , SYNTAX_DCE }
       ,{ "ndr64"           , SYNTAX_NDR64 }
       ,{ "all"             , SYNTAX_BOTH  }
       ,{ 0                 , 0 }
    };
    
const CHOICE    TargetChoice[] =
    {
         { "NT40"           , NT40 }
        ,{ "NT50"           , NT50 }
        ,{ "NT51"           , NT51 }
        ,{ 0                , 0 }
    };

const CHOICE    ClientChoice[]    =
    {
         { "stub"           , CLNT_STUB }
        ,{ "none"           , CLNT_NONE }
        ,{ 0                , 0 }
    };

const CHOICE    ServerChoice[]    =
    {
         { "stub"           , SRVR_STUB }
        ,{ "none"           , SRVR_NONE }
        ,{ 0                , 0 }
    };

const CHOICE    WireCompatChoice[]  =
    {
         { "enum16unionalign", WIRE_COMPAT_ENUM16UNIONALIGN }
        ,{ 0                 , 0 }
    };


#define IS_NUMERIC_1( pThisArg ) ((strlen( pThisArg) == 1 )  &&  \
                                  (isdigit( *pThisArg )) )

// this is now the same for ALL platforms
#define C_COMPILER_NAME()           ("cl.exe")
#define C_PREPROCESSOR_NAME()       ("cl.exe")
#define ADDITIONAL_CPP_OPT()        (" -E -nologo")

#define MIDL_HELP_FILE_NAME         ("midl.hlp")

/****************************************************************************
 *    local data
 ***************************************************************************/

/****************************************************************************
 *    externs
 ***************************************************************************/


extern    void              ReportUnimplementedSwitch( short );
extern    char    *         SwitchStringForValue( unsigned short );
extern    _swenum           SearchForSwitch( char ** );
extern    STATUS_T          SelectChoice( const CHOICE *, char *, short *);
extern    bool              PPCmdEngine( int argc, char *argv[], IDICT * );

extern    void              PrintArg( enum _swenum, char *, char * );

void CmdProcess( pair_switch*,  CommandLine*, char* );
/****************************************************************************/

void
CommandLine::RegisterArgs(
    char    *   pArgs[],
    short       cArguments
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine registers with the command analyser the argument vector
    and argument count for user supplied arguments.

 Arguments:

    pArgs        -    Array of pointers to arguments ( switches etc ).
    cArguments   -    count of arguments.

 Return Value:

    None.

 Notes:

    The process of registering the arguments consists of keeping a local
    copy of the argument vector pointer and count.

    The argument vector is passed such that the argv[1] is the first
    argument available to the command processor. Therefore , count is
    one less too.

    Why do we need registering the arguments ? In the process of parsing
    we might want to skip an argument back or forward. So we keep a local
    copy of the pointer to the arguments.


----------------------------------------------------------------------------*/
    {
    iArgV   = 0;
    pArgDict= new IDICT( 10, 5 );
    fShowLogo = PPCmdEngine( cArguments, pArgs, pArgDict );
    cArgs   = pArgDict->GetCurrentSize();
    }

char *
CommandLine::GetNextArg()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Get the next argument in the argument vector.


 Arguments:

    None.

 Return Value:

    returns a pointer to the next argument.

 Notes:

    if no more arguments
        return a null.
    else
        return the next argument pointer.
        decrement the count, increment the pointer to point to the next arg.

----------------------------------------------------------------------------*/
    {
    if(cArgs == 0 )
        return (char *)NULL;
    cArgs--;
    return (char *)pArgDict->GetElement( (IDICTKEY)iArgV++);
    }

void
CommandLine::UndoGetNextArg()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Undo the effect of the last GetNextArg call.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

    if this is not the first argument already
        Push back the argument pointer.
        Increment count.
    else
        Do nothing.

    This prepares the argument  vector to accept more GetNextArgCalls.
----------------------------------------------------------------------------*/
    {
    if(iArgV == 0)
        return;
    cArgs++;
    iArgV--;
    }

STATUS_T
CommandLine::ProcessArgs()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process command line arguments.

 Arguments:

    None.

 Return Value:

    STATUS_OK    - if all is well
    Error Status otherwise.

 Notes:

----------------------------------------------------------------------------*/
{
    char            *   pThisArg,
                   *    pThisArgSave;
    STATUS_T            Status, ReturnStatus    = STATUS_OK;
    enum _swenum        iSwitch;
    short               fSwitchDetected;
    unsigned short      SwitchValue;


    // loop till all arguments have been processed.

    while ( ( pThisArg = GetNextArg() ) != 0 )
        {

        fSwitchDetected    = 0;
        iSwitch            = SWITCH_NOTHING;
    
        // save this pointer, it is useful for error reporting.

        pThisArgSave = pThisArg;

        // if we saw a - or a / we have detected a switch. Get the index of
        // the switch in the switch descriptor table. If the returned index
        // was zero, either the switch was not a valid one, or we saw an input
        // which is taken as an input filename specification. If the input
        // filename has already been specified, this is an error.

        if( *pThisArg == '-' || *pThisArg == '/' )
            {
            pThisArg++;
            fSwitchDetected    = 1;
            iSwitch            = SearchForSwitch( &pThisArg );
            }

        if( iSwitch == SWITCH_NOTHING )
            {

            if( fSwitchDetected || IsSwitchDefined( BASE_FILENAME ) )
                {
                char    *    p = new char[ strlen(pThisArg)+2+1 ];

                sprintf(p, "\"%s\"", pThisArg );

                RpcError( (char *)NULL,
                          0,
                          fSwitchDetected ? UNKNOWN_SWITCH : UNKNOWN_ARGUMENT,
                          p);

                delete []p;
                }
            else
                {

                // the only way we can get here is if he did not specify a
                // switch like input AND the input filename has not been
                // defined yet. Hence this must be the input filename.

                pInputFNSwitch = new filename_switch( pThisArg);

                SwitchDefined( BASE_FILENAME );

                }

            continue;

            }


        // bump the input pointer to point to the argument. Depending on
        // what type of argument this switch takes ( spaced, non-spaced,
        // switch-like etc ) bump the argument pointer to the actual argument.

        SwitchValue = unsigned short ( switch_desc[ iSwitch ].SwitchValue );

        Status = BumpThisArg( &pThisArg, switch_desc[ iSwitch ].flag );

        if( Status != STATUS_OK )
            {
            RpcError( (char *)NULL,
                      0,
                      Status,
                      pThisArgSave );
            continue;
            }

        MIDL_ASSERT(NULL != pThisArg);

        // Process the switch. The input pointer is pointing to the
        // argument to the switch, after the '-' or '/'.

        switch( SwitchValue )
            {
            case SWITCH_CSTUB:
            case SWITCH_HEADER:
            case SWITCH_ACF:
            case SWITCH_SSTUB:
            case SWITCH_OUT:
            case SWITCH_IID:
            case SWITCH_PROXY:
            case SWITCH_TESTCLIENT:
            case SWITCH_CLASS_METHODS:
            case SWITCH_CLASS_HEADER:
            case SWITCH_CLASS_IUNKNOWN:
            case SWITCH_PROXY_DEF:
            case SWITCH_DLL_SERVER_DEF:
            case SWITCH_DLL_SERVER_CLASS_GEN:
            case SWITCH_SERVER_REG:
            case SWITCH_EXE_SERVER:
            case SWITCH_EXE_SERVER_MAIN:
            case SWITCH_DLLDATA:
            case SWITCH_TLIB:
            case SWITCH_REDIRECT_OUTPUT:
            case SWITCH_NETMON_STUB_OUTPUT_FILE:
            case SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE:
                Status = ProcessFilenameSwitch( SwitchValue, pThisArg );
                break;

            case SWITCH_LOCALE_ID:
            case SWITCH_PACK:
            case SWITCH_ZP:
            case SWITCH_NO_WARN:
            case SWITCH_USE_EPV:
            case SWITCH_NO_DEFAULT_EPV:
            case SWITCH_DEBUGEXC:
            case SWITCH_DEBUGLINE:
            case SWITCH_SYNTAX_CHECK:
            case SWITCH_ZS:
            case SWITCH_NO_CPP:
            case SWITCH_CLIENT:
            case SWITCH_SERVER:
            case SWITCH_ENV:
            case SWITCH_TARGET_SYSTEM:
            case SWITCH_RPCSS:
            case SWITCH_NETMON:
            case SWITCH_VERSION_STAMP:
            case SWITCH_DUMP:
            case SWITCH_OVERRIDE:
            case SWITCH_SAVEPP:
            case SWITCH_NO_DEF_IDIR:
            case SWITCH_VERSION:
            case SWITCH_CONFIRM:
            case SWITCH_NOLOGO:
            case SWITCH_CHAR:
            case SWITCH_HELP:
            case SWITCH_W:
            case SWITCH_WX:
            case SWITCH_X:
            case SWITCH_O:
            case SWITCH_APPEND64:
            case SWITCH_APP_CONFIG:
            case SWITCH_MS_EXT:
            case SWITCH_MS_CONF_STRUCT:
            case SWITCH_MS_UNION:
            case SWITCH_OLDNAMES:
            case SWITCH_NO_FMT_OPT:
            case SWITCH_GUARD_DEFS:
            case SWITCH_INTERNAL:
            case SWITCH_NO_STAMP:
            case SWITCH_ROBUST:
            case SWITCH_NO_ROBUST:
            case SWITCH_C_EXT:
            case SWITCH_OSF:
            case SWITCH_MKTYPLIB:
            case SWITCH_OLD_TLB:
            case SWITCH_NEW_TLB:
            case SWITCH_NOREUSE_BUFFER:
            case SWITCH_USE_VT_INT_PTR:
            case SWITCH_NO_TLIB:
            case SWITCH_TRANSFER_SYNTAX:
            case SWITCH_MS_EXT64:
            case SWITCH_DEBUGINFO:
                Status = ProcessOrdinarySwitch( SwitchValue, pThisArg );
                break;
            
            case SWITCH_ODL_ENV:
                Status = ProcessOrdinarySwitch( SwitchValue, pThisArg );
                SwitchValue = SWITCH_ENV;
                break;

            case SWITCH_ERROR:
            case SWITCH_WIRE_COMPAT:                
                Status = ProcessSimpleMultipleSwitch( SwitchValue, pThisArg );
                break;

            case SWITCH_D:
            case SWITCH_I:
            case SWITCH_U:

                // specifically for -D/-I/-U we want the two characters
                // -I / -D / -U inside too, so that we can pass it as such to
                // the c preprocessor.

                Status = ProcessMultipleSwitch( SwitchValue, pThisArgSave, pThisArg );
                break;


            case SWITCH_MSC_VER:
            case SWITCH_CPP_CMD:
            case SWITCH_CPP_OPT:
            case SWITCH_DEBUG64_OPT:
            case SWITCH_DEBUG64:
                Status = ProcessOnetimeSwitch( SwitchValue, pThisArg );
                break;

            case SWITCH_PREFIX:

                CmdProcess( pSwitchPrefix, this, pThisArg );
                break;

            case SWITCH_HOOKOLE:
                RpcError( NULL, 0, SWITCH_NOT_SUPPORTED_ANYMORE, "hookole" );
                break;

            default:

                ReportUnimplementedSwitch( SwitchValue );
                continue;
            }

        // set up the defintion vector, to indicate that the switch has been
        // defined.

        if( Status == ILLEGAL_ARGUMENT )
            ReturnStatus = ILLEGAL_ARGUMENT;

        SwitchDefined( SwitchValue );

        }

    if (!IsSwitchDefined(SWITCH_OSF))
        {
            SwitchDefined(SWITCH_C_EXT);
            SwitchDefined(SWITCH_MS_EXT);
        }

    // if the user has asked for output to be redirected, redirect stdout
    if (IsSwitchDefined(SWITCH_REDIRECT_OUTPUT))
        {
        FILE * pFH;
        char * newfile = pRedirectOutputSwitch->GetFileName();

        if ( HasAppend64() || Is2ndCodegenRun() )
            {
            pFH = freopen(newfile, "r+", stdout);

            if ( pFH )
                {
                if ( 0 != fseek( pFH, 0, SEEK_END ) )
                    RpcError( NULL, 0, ERROR_OPENING_FILE, newfile );
                }
            else
                pFH = freopen(newfile, "a+", stdout);
            }
        else
            pFH = freopen(newfile, "w", stdout);

        if ( NULL == pFH )
            RpcError( NULL, 0, ERROR_OPENING_FILE, newfile );
        }

    // if he has not specified the input filename, report
    // error, but only if the confirm switch is not specified. If it is,
    // processing will not occur anyway.

    if(!IsSwitchDefined(BASE_FILENAME) )
        {
        if( IsSwitchDefined( SWITCH_CONFIRM ) )
            {
            pInputFNSwitch = new filename_switch( "sample.idl");
            SwitchDefined( BASE_FILENAME );
            }
        else if( IsSwitchDefined( SWITCH_HELP ))
            return STATUS_OK;
        else
            {
            RpcError((char *)NULL,0,NO_INPUT_FILE, (char *)NULL);
            return NO_INPUT_FILE;
            }
        }

    // set post switch processing defaults

    ReturnStatus = SetPostDefaults();

    return ReturnStatus;
}

STATUS_T
CommandLine::BumpThisArg(
    char            **    ppArg,
    unsigned short        flag
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Bump the argument pointer to the start of the argument that this switch
    expects.

 Arguments:

    ppArg    -    pointer to the argument pointer.
    flag    -    descriptor of the type of argument expected by the switch.

 Return Value:

    ILLEGAL_ARGUMENT    -    if the switch did not expect this argument
    BAD_SWITCH_SYNTAX    -     if the switch + arg. syntax is improper.
    MISSING_ARGUMENT    -    a mandatory arg. is missing.
    STATUS_OK            -    evrything is hunky dory.

 Notes:

    In the routine below, fHasImmediateArg is a flag which is true if the
    switch argument follws the switch name without any spaces in between.
    Optional space is indicated in the switch descriptor as ARG_SPACE +
    ARG_NO_SPACE, so it gets reflected in fSpaceOptional as fMustNotHaveSpace
    && fMustHaveSpace.

    Other flags have self-explanatory names.

    This routine forms the core syntax checker for the switches.

----------------------------------------------------------------------------*/
    {
    char   *    pArg                = *ppArg;
    BOOL        fMustHaveArg        = (BOOL) !(flag & ARG_NONE);
    BOOL        fOptionalArg        = (flag & ARG_NONE) && (flag & ARG_YES);
    BOOL        fMustHaveSpace      = (BOOL) ((flag & ARG_SPACE) != 0 );
    BOOL        fMustNotHaveSpace   = (BOOL) ((flag & ARG_NO_SPACE) != 0 );
    BOOL        fSpaceOptional      = (BOOL) (fMustNotHaveSpace &&
                                              fMustHaveSpace );
    BOOL        fSwitchLike         = (BOOL) ((flag & ARG_SWITCH_LIKE) != 0 );
    BOOL        fHasImmediateArg    = (*pArg != 0);
    BOOL        fMustGetNextArg     = FALSE;


    // first deal with the case of the switch having an optional argument.
    // If the switch has an optional argument, then check the next argument
    // to see if it is switch like. If it is, then this switch was specified
    // without an argument. If it is not, then the next argument is taken to
    // be the argument for the switch.

    if( fOptionalArg )
        {

        pArg = GetNextArg();
        if(!fSwitchLike && pArg && ((*pArg == '-') || (*pArg == '/') ) )
            {
            UndoGetNextArg();
            pArg = (char *)0;
            }
        *ppArg = pArg;
        return STATUS_OK;
        }

    // if the switch must not have an immediate argument and has one,
    // it is an error.

    if( !fMustHaveArg && fHasImmediateArg )

        return ILLEGAL_ARGUMENT;

    else if ( fMustHaveArg )
        {

        // if it needs an argument, and has an immediate argument, it is bad
        // if the switch must have space.

        if( fHasImmediateArg )
            {

            if( fMustHaveSpace && !fSpaceOptional )
                return BAD_SWITCH_SYNTAX;

            }
        else    
            {

            // This is the case when the switch must have an argument and
            // does not seem to have an immediate argument. This is fine only
            // if space was either optional or expected. In either case, we must
            // assume that the next argument is the argument for this switch.

            // If switch must not have any space then this is a case of
            // bad switch syntax.


            if( fSpaceOptional || fMustHaveSpace   )
                fMustGetNextArg    = TRUE;
            else
                return BAD_SWITCH_SYNTAX;
            }
        }

    if( fMustGetNextArg )
        {

        // we arrive here if the switch expects an argument and
        // space between the switch and the argument is optional.

        // Note that the flag fHasImmediateArg now specifies whether
        // the argument is present at all.

        pArg = GetNextArg();

        fHasImmediateArg = (BOOL) ( pArg && (*pArg != 0) );

        if( fHasImmediateArg )
            {

            // we got the next argument.
            // If we get something that looks like a switch, and this switch
            // does not expect switch_like arguments, then this is illegal
            // argument for the switch.

            if(!fSwitchLike && ((*pArg == '-') || (*pArg == '/') ) )
                {
                UndoGetNextArg();
                return ILLEGAL_ARGUMENT;
                }
            }
        else
            // well, we expect an argument, and didnt get one. He just
            // shot himself is all I can say.

            return MISSING_ARG;
        }

    // we have found the right argument.

    *ppArg = pArg;

    // finally ! out of this mess.

    return STATUS_OK;
}

STATUS_T
CommandLine::ProcessOnetimeSwitch(
    short        SwitchNo,
    char    *    pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process a onetime switch.

 Arguments:

    SwitchNo        -    switch number being processed.
    pThisArg        -    pointer to the argument for this switch.

 Return Value:

    None.

 Notes:

    Check for duplicate definition of this switch. If there is a duplicate
    definition, override the previous one after warning him.

----------------------------------------------------------------------------*/
    {
    onetime_switch    **    ppSSwitch;

    switch( SwitchNo )
        {
        case SWITCH_CPP_CMD:    ppSSwitch = &pCppCmdSwitch; break;
        case SWITCH_CPP_OPT:    ppSSwitch = &pCppOptSwitch; break;
        case SWITCH_MSC_VER:
            ppSSwitch = &pMSCVerSwitch;
            MSCVersion = (unsigned short) atoi( pThisArg );
            break;
        case SWITCH_DEBUG64:    ppSSwitch = &pDebug64Switch; break;
        case SWITCH_DEBUG64_OPT:ppSSwitch = &pDebug64OptSwitch; break;
        default:                return STATUS_OK;
        }

    if( IsSwitchDefined(SwitchNo) )
        {
        RpcError( (char *)NULL,
                      0,
                      SWITCH_REDEFINED,
                    SwitchStringForValue( SwitchNo ) );

        delete *ppSSwitch;
        }

    (*ppSSwitch) = new onetime_switch( pThisArg );
    return STATUS_OK;

    }

STATUS_T
CommandLine::ProcessMultipleSwitch(
    short        SwitchNo,
    char    *    pThisArg,
    char    *    pActualArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process a multiple occurrence switch.

 Arguments:

    SwitchNo    -    switch number being processed.
    pThisArg    -    pointer to the argument for this switch.
    pActualArg  -    pointer to the actual argument to -I/-D etc

 Return Value:

    None.

 Notes:

    Multiple specifications can occur. Dont check for duplicate definitions.

----------------------------------------------------------------------------*/
    {

    char             *    pTemp     = pThisArg;
    multiple_switch  **   ppMSwitch;

    switch( SwitchNo )
        {
        case SWITCH_D:  ppMSwitch = &pDSwitch; break;
        case SWITCH_I:  ppMSwitch = &pISwitch; break;
        case SWITCH_U:  ppMSwitch = &pUSwitch; break;
        default:        return STATUS_OK;
        }

    // now set the switches. Space is optional
    // If no space exists between the -I/-D value of pActualArg will point to
    // the byte next to the end of -I/-D etc. If there is at least one space,
    // the pActualArg will point further away. This fact can be used to decide
    // how the argument needs to be presented to the c preprocessor.
    // If we need the space, then create a new buffer with the space between the
    // -I/-D etc.

    // I assume the assumptions above will hold true even for segmented
    // architectures.

    size_t ActualArgOffset = pActualArg - pThisArg;

    if( ( pActualArg - (pThisArg+2) ) != 0 )
        {

        // we need a space
        ActualArgOffset = strlen( pThisArg ) + 1; // 1 for space
        pTemp = new char [ ActualArgOffset      +
                           strlen( pActualArg ) +
                           1                         // 1 for terminator.
                         ];
        sprintf( pTemp, "%s %s", pThisArg, pActualArg );
        }

    if(!(*ppMSwitch) )
        *ppMSwitch = new multiple_switch( pTemp, ActualArgOffset );
    else
        (*ppMSwitch)->Add( pTemp, ActualArgOffset );

    return STATUS_OK;
    }

STATUS_T
CommandLine::ProcessFilenameSwitch(
    short       SwitchNo,
    char    *   pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Process a filename switch.

 Arguments:

    SwitchNo    -    switch number being processed.
    pThisArg    -    pointer to the argument for this switch.

 Return Value:

    STATUS_OK if all is well, error otherwise.

 Notes:

    This is like a single occurrence switch too. Warn if duplicate definition
    and override the previous specification.

----------------------------------------------------------------------------*/
    {

    filename_switch    **        ppFNSwitch;
    BOOL                    fCheck = TRUE;
    char                    agBaseName[ _MAX_FNAME ];

    switch( SwitchNo )
        {
        case SWITCH_CSTUB:                ppFNSwitch = &pCStubSwitch;  break;
        case SWITCH_HEADER:               ppFNSwitch = &pHeaderSwitch; break;
        case SWITCH_ACF:                  ppFNSwitch = &pAcfSwitch;    break;
        case SWITCH_SSTUB:                ppFNSwitch = &pSStubSwitch;  break;
        case SWITCH_OUT:                  ppFNSwitch = &pOutputPathSwitch; fCheck=FALSE; break;
        case SWITCH_IID:                  ppFNSwitch = &pIIDSwitch;    break;
        case SWITCH_PROXY:                ppFNSwitch = &pProxySwitch;  break;
        case SWITCH_DLLDATA:              ppFNSwitch = &pDllDataSwitch;  break;
        case SWITCH_TLIB:                 ppFNSwitch = &pTlibSwitch;     break;
        case SWITCH_REDIRECT_OUTPUT:      ppFNSwitch = &pRedirectOutputSwitch; break;
        case SWITCH_NETMON_STUB_OUTPUT_FILE:     ppFNSwitch = &pNetmonStubSwitch; break;
        case SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE: ppFNSwitch = &pNetmonStubObjSwitch; break;
        default:                          return STATUS_OK;
        }

    if( IsSwitchDefined(SwitchNo) )
        {
        RpcError( (char *)NULL,
                      0,
                      SWITCH_REDEFINED,
                    SwitchStringForValue( SwitchNo ) );

        delete *ppFNSwitch;
        }

    (*ppFNSwitch)    = new filename_switch( pThisArg );

    // check for validity of the switch. All switches other than the
    // out switch must have a base name specified.

    if( fCheck )
        {
        (*ppFNSwitch)->GetFileNameComponents( (char *)NULL,
                                              (char *)NULL,
                                              agBaseName,
                                              (char *)NULL );

        if( agBaseName[ 0 ] == '\0' )
            {
            RpcError( (char *)NULL,
                      0,
                      ILLEGAL_ARGUMENT,
                      SwitchStringForValue( SwitchNo ) );
            }
        }
    return STATUS_OK;
    }

STATUS_T
CommandLine::ProcessOrdinarySwitch(
    short        SWValue,
    char    *    pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    process ordinary switch catrgory.

 Arguments:

    SWValue        -    switch value
    pThisArg    -    the users argument to this switch.

 Return Value:

 Notes:

    check and warn for redefinition of the switch. Switch Warn is a special
    case, the warn can be redefined. The last specified warning level is
    valid.

    Generally we let the user who redefines a switch off the hook. When the
    arguments to a switch are wrong, we report an error and return an illegal
    argument status.

----------------------------------------------------------------------------*/
{
    short        Temp;
    STATUS_T    Status    = STATUS_OK;

    if( IsSwitchDefined( SWValue ) && (SWValue != SWITCH_O) )
        {
        RpcError( (char *)NULL,
                  0,
                  SWITCH_REDEFINED,
                  SwitchStringForValue( SWValue ) );
        }

    switch( SWValue )
        {
        case SWITCH_PACK:
            SwitchDefined( SWITCH_ZP );
            // fall through
        case SWITCH_ZP:
            {
               int TempZeePee = atoi( pThisArg );
               if (!TempZeePee || !IsValidZeePee( TempZeePee ) )
                   goto illarg;
               ZeePee = (unsigned short)TempZeePee;               
            }
            break;

        case SWITCH_LOCALE_ID:
             
            SwitchDefined( SWITCH_LOCALE_ID );
            LocaleId = atoi( pThisArg );
            /*
            if ( ! CurrentCharSet.SetDbcsLeadByteTable( LocaleId ) )
                {
                char temp[20];

                sprintf( temp, "%d", LocaleId );
                RpcError( NULL, 0, INVALID_LOCALE_ID, temp );
                }
            */
            break;

        case SWITCH_W:

                // warning level of 0 specifies no warnings.

                Temp = short( *pThisArg - '0' );

                if( ( !IS_NUMERIC_1( pThisArg ) )    ||
                    ( Temp > WARN_LEVEL_MAX ) )
                    goto illarg;

                WLevel = Temp;

            break;

        case SWITCH_O:
            {    
            if ( ! *pThisArg )
                goto illarg;

            if ( OptimFlags & 
                 (OPTIMIZE_SIZE | OPTIMIZE_ANY_INTERPRETER) )
                RpcError( (char *)NULL,
                          0,
                          SWITCH_REDEFINED,
                          SwitchStringForValue( SWValue ) );

            if ( strcmp( pThisArg, "s" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_SIZE );
                OptimLevel = OPT_LEVEL_OS;
                }
            else if ( strcmp( pThisArg, "i" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_INTERPRETER );
                OptimLevel = OPT_LEVEL_OI;
                }
            else if ( strcmp( pThisArg, "ic" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I1_FLAGS );
                OptimLevel = OPT_LEVEL_OIC;
                RpcError( 0, 0, OIC_SUPPORT_PHASED_OUT, "Oi1");
                }
            else if ( strcmp( pThisArg, "i1" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I1_FLAGS );
                OptimLevel = OPT_LEVEL_OIC;
                RpcError( NULL, 0, CMD_OI1_PHASED_OUT, "Oi1");
                }
            else if ( strcmp( pThisArg, "icf" ) == 0  ||
                      strcmp( pThisArg, "if" ) == 0  )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
                OptimLevel = OPT_LEVEL_OICF;
                }
            else if ( strcmp( pThisArg, "i2" ) == 0 )
                {
                SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
                OptimLevel = OPT_LEVEL_OICF;
                RpcError( NULL, 0, CMD_OI2_OBSOLETE, "Oi2");
                }
            else
                goto illarg;
                
            }
            break;

        case SWITCH_ODL_ENV:
            pThisArg -= 2; // back up past the first three characters of the switch "win"
            SWValue = SWITCH_ENV; // to ensure that the right thing gets reported if an error occurs
            // fall through to SWITCH_ENV

        case SWITCH_ENV:
            
            if( SelectChoice( EnvChoice,pThisArg, &Temp ) != STATUS_OK )
                goto illarg;

            Env = (unsigned char) Temp;

            if (ENV_OBSOLETE == Env)
                RpcError( NULL, 0, SWITCH_NOT_SUPPORTED_ANYMORE, pThisArg );

            break;

        case SWITCH_TARGET_SYSTEM:
            
            if( SelectChoice( TargetChoice, pThisArg, &Temp ) != STATUS_OK )
                goto illarg;
            TargetSystem = (TARGET_ENUM) Temp;
            GetNdrVersionControl().SetTargetSystem(TargetSystem);
            break;

        case SWITCH_TRANSFER_SYNTAX:
            if ( SelectChoice( SyntaxChoice, pThisArg, &Temp ) != STATUS_OK )
                goto illarg;
            TargetSyntax = (SYNTAX_ENUM) Temp;
            break;

        case SWITCH_NO_WARN:
            
            WLevel = 0; // was WARN_LEVEL_MAX
            break;

        case SWITCH_INTERNAL:
            RpcError( 0, 0, INTERNAL_SWITCH_USED, NULL );

        case SWITCH_NO_STAMP:
        case SWITCH_NETMON:
        case SWITCH_VERSION_STAMP:
        case SWITCH_DEBUGEXC:
        case SWITCH_DEBUGLINE:
        case SWITCH_SYNTAX_CHECK:
        case SWITCH_ZS:
        case SWITCH_NO_CPP:
        case SWITCH_SAVEPP:
        case SWITCH_DUMP:
        case SWITCH_OVERRIDE:
        case SWITCH_NO_DEF_IDIR:
        case SWITCH_USE_EPV:
        case SWITCH_NO_DEFAULT_EPV:
        case SWITCH_VERSION:
        case SWITCH_CONFIRM:
        case SWITCH_NOLOGO:
        case SWITCH_HELP:
        case SWITCH_WX:
        case SWITCH_X:
        case SWITCH_APPEND64:
        case SWITCH_APP_CONFIG:
        case SWITCH_MS_EXT:
        case SWITCH_MS_CONF_STRUCT:
        case SWITCH_MS_UNION:
        case SWITCH_OLDNAMES:
        case SWITCH_NO_FMT_OPT:
        case SWITCH_GUARD_DEFS:
        case SWITCH_C_EXT:
        case SWITCH_OSF:
        case SWITCH_MKTYPLIB:
        case SWITCH_OLD_TLB:
        case SWITCH_NEW_TLB:
        case SWITCH_NO_SERVER:
        case SWITCH_NO_CLIENT:
        case SWITCH_NO_HEADER:
        case SWITCH_NO_IID:
        case SWITCH_NO_DLLDATA:
        case SWITCH_NO_PROXY:
        case SWITCH_NO_CLASS_METHODS:
        case SWITCH_NO_CLASS_IUNKNOWN:
        case SWITCH_NO_CLASS_HEADER:
        case SWITCH_NO_PROXY_DEF:
        case SWITCH_NO_DLL_SERVER_DEF:
        case SWITCH_NO_DLL_SERVER_CLASS_GEN:
        case SWITCH_NO_SERVER_REG:
        case SWITCH_NO_EXE_SERVER:
        case SWITCH_NO_EXE_SERVER_MAIN:
        case SWITCH_NO_TESTCLIENT:
        case SWITCH_RPCSS:
        case SWITCH_ROBUST:
        case SWITCH_NO_ROBUST:
        case SWITCH_NOREUSE_BUFFER:
        case SWITCH_USE_VT_INT_PTR:
        case SWITCH_NO_TLIB:
        case SWITCH_MS_EXT64:
        case SWITCH_DEBUGINFO:
            SwitchDefined( SWValue );
            break;

        case SWITCH_CPP_CMD:
        case SWITCH_CPP_OPT:
        case SWITCH_MSC_VER:
        case SWITCH_DEBUG64:
        case SWITCH_DEBUG64_OPT:

            ProcessOnetimeSwitch( SWValue, pThisArg );
            break;

        case SWITCH_CLIENT:

            if( SelectChoice( ClientChoice, pThisArg ,&Temp ) != STATUS_OK )
                goto illarg;
            fClient = (unsigned char) Temp;
            break;

        case SWITCH_SERVER:

            if( SelectChoice( ServerChoice, pThisArg ,&Temp ) != STATUS_OK )
                goto illarg;
            fServer = (unsigned char) Temp;
            break;

        case SWITCH_CHAR:

            if( SelectChoice( CharChoice, pThisArg ,&Temp ) != STATUS_OK )
                goto illarg;
            CharOption = (unsigned char) Temp;
            break;

        default:
            break;
        }

    return Status;

illarg:
        RpcError( (char *)NULL,
                  0,
                  Status = ILLEGAL_ARGUMENT,
                  SwitchStringForValue( SWValue ) );
return Status;
}

STATUS_T
CommandLine::ProcessSimpleMultipleSwitch(
    short        SWValue,
    char    *    pThisArg
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    process simple switches which can be multiply defined.

 Arguments:

    SWValue        -    switch value
    pThisArg    -    the users argument to this switch.

 Return Value:

 Notes:

    check and warn for redefinition of the switch. Switch Warn is a special
    case, the warn can be redefined. The last specified warning level is
    valid.

    Generally we let the user who redefines a switch off the hook. When the
    arguments to a switch are wrong, we report an error and return an illegal
    argument status.

----------------------------------------------------------------------------*/
{
    short       Temp;
    STATUS_T    Status    = STATUS_OK;

    switch( SWValue )
        {
        case SWITCH_ERROR:
            Temp = ERROR_NONE;
            if( pThisArg && SelectChoice( ErrorChoice, pThisArg ,&Temp ) != STATUS_OK )
                {
                Status = ILLEGAL_ARGUMENT;
                RpcError( (char *)0,
                          0,
                          Status,
                          SwitchStringForValue( SWValue )
                          );
                }
            if( Temp == ERROR_NONE)
                ErrorOption = ERROR_NONE;
            else
                ErrorOption |= Temp;
            break;

        case SWITCH_WIRE_COMPAT:
            if( !pThisArg || ( SelectChoice( WireCompatChoice, pThisArg ,&Temp ) != STATUS_OK ) )
                {
                Status = ILLEGAL_ARGUMENT;
                RpcError( (char *)0,
                          0,
                          Status,
                          SwitchStringForValue( SWValue )
                          );
                }
            else
                WireCompatOption |= Temp;
            break;

        default:
            break;
        }
    return Status;
}

STATUS_T
CommandLine::SetPostDefaults()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set compiler switch defaults for switches not specified.

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    char    agDrive[ _MAX_DRIVE ];
    char    agPath[ _MAX_PATH ];
    char    agBaseName[ _MAX_FNAME ];
    char    agExt[ _MAX_EXT ];
    char    agBuffer[ _MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT + 1 ];


    if( !IsSwitchDefined( SWITCH_OUT ) )
        {
        strcpy( agDrive, "");
        strcpy( agPath, ".\\");
        }
    else
        {
        _splitpath( pOutputPathSwitch->GetFileName(),
                    agDrive,
                    agPath,
                    agBaseName,
                    agExt );
        strcat( agPath, agBaseName );
        strcat( agPath, agExt );
        delete pOutputPathSwitch;
        }

    agBaseName[0]    = '\0';
    agExt[0]        = '\0';

    _makepath( agBuffer, agDrive, agPath, agBaseName, agExt );


    pOutputPathSwitch    = new filename_switch( agBuffer );

    _splitpath( agBuffer, agDrive, agPath, agBaseName, agExt );

    // we have all the components but the base filename must be the
    // filename of the input file. So we get this component of the base
    // filename

    pInputFNSwitch->GetFileNameComponents( (char *)NULL,
                                           (char *)NULL,
                                           agBaseName,
                                           (char *)NULL );

    // if the cstub switch is not set, set the default.

    if(!IsSwitchDefined( SWITCH_CSTUB ) )
        {
        pCStubSwitch = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".c",
                                            "_c" );
        }
    else
        pCStubSwitch->TransformFileNameForOut( agDrive, agPath );

    // if the sstub switch is not set, set the default

    if(!IsSwitchDefined( SWITCH_SSTUB ) )
        {
        pSStubSwitch = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".c",
                                            "_s" );
        }
    else
        pSStubSwitch->TransformFileNameForOut( agDrive, agPath );


    // if the IID switch is not set, set it
    if(!IsSwitchDefined( SWITCH_IID ) )
        {
        pIIDSwitch = new filename_switch( agDrive,
                                          agPath,
                                          agBaseName,
                                          ".c",
                                          "_i" );
        }
    else
        pIIDSwitch->TransformFileNameForOut( agDrive, agPath );

    // if the Proxy switch is not set, set it
    if(!IsSwitchDefined( SWITCH_PROXY ) )
        {
        pProxySwitch = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".c",
                                            "_p" );
        }
    else
        pProxySwitch->TransformFileNameForOut( agDrive, agPath );

    if (!IsSwitchDefined( SWITCH_TLIB ) )
        {
        pTlibSwitch = new filename_switch( agDrive,
                                           agPath,
                                           agBaseName,
                                           ".tlb",
                                           "" );
        }
    else
        pTlibSwitch->TransformFileNameForOut(agDrive, agPath);

    // if the DllData switch is not set, set it
    if(!IsSwitchDefined( SWITCH_DLLDATA ) )
        {
        pDllDataSwitch = new filename_switch( agDrive,
                                              agPath,
                                              "dlldata",
                                              ".c",
                                              "" );
        }
    else
        pDllDataSwitch->TransformFileNameForOut( agDrive, agPath );

    // if the acf switch is not set, set it

    if(!IsSwitchDefined( SWITCH_ACF ) )
        {
        pAcfSwitch   = new filename_switch( agDrive,
                                            agPath,
                                            agBaseName,
                                            ".acf",
                                            (char *)NULL );
        }

    // if the header switch is not set, set it

    if(!IsSwitchDefined( SWITCH_HEADER ) )
        {
        pHeaderSwitch   = new filename_switch( agDrive,
                                               agPath,
                                               agBaseName,
                                               ".h",
                                               (char *)NULL );
        }
    else
        pHeaderSwitch->TransformFileNameForOut( agDrive, agPath );

    // set up the cpp options.

    if( !IsSwitchDefined( SWITCH_CPP_CMD ) )
        {
        pCppCmdSwitch = new onetime_switch( C_PREPROCESSOR_NAME() );
        }

    if( !IsSwitchDefined( SWITCH_MSC_VER ) )
        {
        pMSCVerSwitch = new onetime_switch( "1100" );
        MSCVersion = 1100;
        }

    // set up the cpp_opt and cc_opt. If he did not specify a cpp_opt
    // then we will pass onto the preprocessor the /I , /D and /U options.
    // if he did specify a cpp_opt, then he knows best, take his options
    // and dont make your own assumptions.

    if ( ! IsSwitchDefined( SWITCH_CPP_OPT ) )
        {
        int          Len = 0;
        char    *    pTemp,
                *    pTemp1;

        Len    += (int) strlen( ADDITIONAL_CPP_OPT() );
        if( !pISwitch && IsSwitchDefined( SWITCH_NO_DEF_IDIR ) )
            Len += (int) strlen( "-I." ) + 1;

        if( pISwitch )    Len    += pISwitch->GetConsolidatedLength( true ); // Room for quotes
        if( pDSwitch )    Len    += pDSwitch->GetConsolidatedLength();
        if( pUSwitch )    Len    += pUSwitch->GetConsolidatedLength();


        pTemp = new char[ Len + 1 ]; pTemp[0] = '\0';

        if( !pISwitch && IsSwitchDefined( SWITCH_NO_DEF_IDIR ) )
            {
            strcat( pTemp, "-I." );
            }

        if( pISwitch )
            {
            strcat( pTemp, pTemp1 = pISwitch->GetConsolidatedOptions( true ) ); // Get quotes
            delete pTemp1;
            }

        if( pDSwitch )
            {
            strcat( pTemp, pTemp1 = pDSwitch->GetConsolidatedOptions() );
            delete pTemp1;
            }

        if( pUSwitch )
            {
            strcat( pTemp, pTemp1 = pUSwitch->GetConsolidatedOptions() );
            delete pTemp1;
            }

        strcat( pTemp, ADDITIONAL_CPP_OPT() );

        pCppOptSwitch   = new onetime_switch( pTemp );

        delete []pTemp;
        }

    // if he specified the cpp_cmd or cpp_opt switches, then no_cpp
    // overrides them if specified.

    if( IsSwitchDefined( SWITCH_NO_CPP ) )
        {
        if( IsSwitchDefined( SWITCH_CPP_CMD) ||
            IsSwitchDefined( SWITCH_CPP_OPT) )
            {
            RpcError( (char *)NULL,
                      0,
                      NO_CPP_OVERRIDES,
                      (char *)NULL );
            }
        }


    // if the client switch is not defined, define it

    if( !IsSwitchDefined( SWITCH_CLIENT ) )
        {
        fClient = CLNT_STUB;
        }

    // if warnlevel and no_warn is defined, then errors

    if( IsSwitchDefined( SWITCH_W ) &&
        (IsSwitchDefined( SWITCH_NO_WARN ) || (WLevel == 0) ) )
        {
        //
        // if we set the no_warn switch already then this warning will itself
        // not be emitted. Make the current warning level 1 so that this warning
        // will be spit out. WLevel is made 0 anyways after that.
        //

        WLevel = 1;

        RpcError( (char *)NULL,
                   0,
                   NO_WARN_OVERRIDES,
                   (char *)NULL );
        WLevel = 0;
        }

    // if the error switch is not defined, define it.

    if( !IsSwitchDefined( SWITCH_ERROR ) )
        {
        ErrorOption = ERROR_ALL;
        }
    else if ( GetNdrVersionControl().TargetIsNT40OrLater() )
        {
        if ( ERROR_ALL != ErrorOption )
            {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-error vs. -target" );
            }
        }

    /////////////////////////////////////////////////////////////////////

    // if he defined env, then he may want to compile for a platform different
    // from what he is building for. Take care of platform dependent switches
    // for the proper platforms.

    // 64 bit additions:
    // -append64 means forcing the appending on the current run
    //     .. it should be the second run, but it always forces with win32 or 64
    // -win32 or -win64 means 32 or 64 bit run only, respectively.
    //

    if ( !IsSwitchDefined( SWITCH_ENV )
         && NT40 == GetNdrVersionControl().GetTargetSystem() )
        {
        SetEnv( ENV_WIN32 ); 
        SwitchDefined( SWITCH_ENV );
        }

    if( IsSwitchDefined( SWITCH_ENV ) )
        {
        if( !IsSwitchDefined( SWITCH_ZP ) )
            {
            switch( GetEnv() )
                {
                case ENV_WIN32: ZeePee = DEFAULT_ZEEPEE; break;
                case ENV_WIN64: ZeePee = DEFAULT_ZEEPEE; break;
                default:        ZeePee = DEFAULT_ZEEPEE; break;
                }
            }

        // EnumSize is set to 4 by default
        }

    if ( NT40 == GetNdrVersionControl().GetTargetSystem() 
         && ENV_WIN32 != GetEnv() 
          )
        {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-win64 vs. -target NT40" );
        }

    if ( !IsSwitchDefined ( SWITCH_TRANSFER_SYNTAX ) )
        {
        if ( GetNdrVersionControl().TargetIsNT51OrLater() )
            TargetSyntax = SYNTAX_BOTH;
        else
            TargetSyntax = SYNTAX_DCE;
        }

    if ( GetNdrVersionControl().TargetIsNT51OrLater() )
        {
        if ( SYNTAX_BOTH != TargetSyntax )
            {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-protocol vs. -target NT51" );
            }
        }

    if ( GetNdrVersionControl().TargetIsLessThanNT51() &&
        (TargetSyntax != SYNTAX_DCE ) )
        {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-protocol ndr(all) vs. -target NT40/NT50, use -target NT51 with -protocol ndr64(all)" );
        }
    // we support ndr64 on 32bit platform only when -internal is specified.
    if ( ( TargetSyntax == SYNTAX_NDR64 ) &&
         ( GetEnv() == ENV_WIN32 ) &&
         !IsSwitchDefined( SWITCH_INTERNAL ) )
        {
        RpcError( NULL, 0, UNSUPPORT_NDR64_FEATURE, 0 );   
        }

    // ndr64 is not supported in /Osf mode        
    if ( IsSwitchDefined(SWITCH_OSF) && TargetSyntax != SYNTAX_DCE )
        {
        RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-osf vs. -protocol ndr64 or -protocol all" );
        }        
    
     if  ( GetEnv() == ENV_WIN64  || GetEnv() == ENV_WIN32 )
         {
         if ( IsSwitchDefined( SWITCH_APPEND64 ) )
             {
             SetHasAppend64( TRUE );
             SetEnv( ENV_WIN64 );
             }
         }

    if ( GetEnv() == ENV_WIN64 )
        {
        // -ms_ext64 is set by default in 64bit.
        SwitchDefined( SWITCH_MS_EXT64 );
        }

    if ( IsSwitchDefined( SWITCH_MS_EXT64 ) )
        GetNdrVersionControl().SetHasMsExt64();       
    
        
    if ( IsSwitchDefined(SWITCH_OSF) && IsSwitchDefined(SWITCH_C_EXT)  ||
         IsSwitchDefined(SWITCH_OSF) && IsSwitchDefined(SWITCH_MS_EXT) )
        {
        RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-osf vs. -ms_ext or -c_ext" );
        }


    // BIG CHANGE! default becomes -Oicf
    if ( !IsSwitchDefined( SWITCH_O ) )
        {
            SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
            OptimLevel = OPT_LEVEL_OICF;
            SwitchDefined( SWITCH_O );
        }
    else if ( GetNdrVersionControl().TargetIsNT40OrLater() )
        {
        if ( OptimLevel != OPT_LEVEL_OICF )
            {
            RpcError( 
                    NULL, 
                    0, 
                    CONTRADICTORY_SWITCHES, 
                    "-Os/Oi/Oic vs. -target" );
            }
        }

    //robust is on unless specified otherwise. 
    // robust is not supported in NT4 variaties. 
    if ( ( OptimLevel == OPT_LEVEL_OICF ) && 
         !IsSwitchDefined( SWITCH_NO_ROBUST ) && 
         ( GetNdrVersionControl().GetTargetSystem() != NT40 ) )
            SwitchDefined( SWITCH_ROBUST );

    if ( GetEnv() == ENV_WIN64 )
        {
        SetPostDefaults64();        
        }

    if ( ( GetOptimizationFlags() != OPTIMIZE_ALL_I2_FLAGS ) && 
         ( TargetSyntax != SYNTAX_DCE ) )
        {
        RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-Os/Oi/Oic vs. -protocol ndr64 or -protocol all" );
        }
        
    // Force /Oicf when ( /Oi or /Os ) are used with /robust

    if ( GetNdrVersionControl().TargetIsNT50OrLater() )
        {
        if ( IsSwitchDefined( SWITCH_NO_ROBUST ) )
            RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-no_robust vs. -target" );
        else
            SwitchDefined( SWITCH_ROBUST );
        }

    if ( IsSwitchDefined( SWITCH_ROBUST ) )
        {
        if ( IsSwitchDefined( SWITCH_NO_ROBUST ) )
            RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-robust vs. -no_robust" );

        if ( NT40 == GetNdrVersionControl().GetTargetSystem() )
            RpcError( NULL, 0, CONTRADICTORY_SWITCHES, "-robust vs. -target NT40" );

        GetNdrVersionControl().SetHasDOA();
        
        if ( ( GetOptimizationFlags() & OPTIMIZE_ALL_I2_FLAGS )  != OPTIMIZE_ALL_I2_FLAGS )
            {
            RpcError( 0, 0, ROBUST_REQUIRES_OICF, 0 );
            }
            
        SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
        }

    if ( !IsSwitchDefined( SWITCH_INTERNAL ) ) 
        {
        // Make sure netmon switches also use -internal
        if ( IsSwitchDefined( SWITCH_NETMON ) )
            {
            ReportUnimplementedSwitch( SWITCH_NETMON );
            }
        else if ( IsSwitchDefined( SWITCH_NETMON_STUB_OUTPUT_FILE ) )
            {
            ReportUnimplementedSwitch( SWITCH_NETMON_STUB_OUTPUT_FILE );
            }
        else if ( IsSwitchDefined( SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE ) )
            {
            ReportUnimplementedSwitch( SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE );
            }
        }    

    // Make sure -netmon is only used with -Oicf and setup output files

    if ( IsSwitchDefined( SWITCH_NETMON )) 
        {
        if ( ! ( ( GetOptimizationFlags() & OPTIMIZE_ALL_I2_FLAGS ) &&
            OptimLevel == OPT_LEVEL_OICF ) )
            {
            RpcError( 0, 0, NETMON_REQUIRES_OICF, 0 );
            }
        
        if (!IsSwitchDefined (SWITCH_NETMON_STUB_OUTPUT_FILE)) 
            {
            pNetmonStubSwitch = new filename_switch( agDrive,
                agPath,
                agBaseName,
                ".c",
                "_netmon_stub" );
            } 
        else 
            {
            pNetmonStubSwitch->TransformFileNameForOut( agDrive, agPath );
            }
        
        if (!IsSwitchDefined (SWITCH_NETMON_STUB_OBJ_OUTPUT_FILE)) 
            {
            pNetmonStubObjSwitch = new filename_switch( agDrive,
                agPath,
                agBaseName,
                ".c",
                "_netmon_stub_obj" );
            
            } 
        else 
            {
            pNetmonStubObjSwitch->TransformFileNameForOut( agDrive, agPath );
            }
        }


    // Check if the target system is consistent with other switches.

    if ( TargetSystem < NT40  &&  IsSwitchDefined( SWITCH_NETMON) )
        RpcError( NULL, 0, CMD_REQUIRES_NT40, "netmon" );

    // If the -no_default_epv switch is specified then -epv switch is auto
    // enabled.

    if( IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ) )
        SwitchDefined( SWITCH_USE_EPV );
    
    // if he specified all, set them all
    if ( IsSwitchDefined( SWITCH_PREFIX ) )
        {
        char *    pAll = pSwitchPrefix->GetUserDefinedEquivalent( PREFIX_ALL );
        if ( pAll )
            {
            for ( short j = 0; j < PREFIX_ALL; j++ )
                {
                if ( !pSwitchPrefix->GetUserDefinedEquivalent( j ) )
                    pSwitchPrefix->AddPair( j, pAll );
                }
            }
        }

    SetModeSwitchConfigMask();

    return STATUS_OK;
    }

void
CommandLine::SetPostDefaults64()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Set switch defaults for 64 bit runs

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    GetNdrVersionControl().SetHas64BitSupport();

    if ( IsSwitchDefined( SWITCH_O ) )
        {
        // For 64b force any interpreter mode to be -Oicf.
        //
        if ( OptimFlags == OPTIMIZE_SIZE )
            {
//                    RpcError( NULL, 0, WIN64_INTERPRETED, "-Oicf" );
            }
        else if ( OptimLevel != OPT_LEVEL_OICF )
            {
            RpcError( NULL, 0, WIN64_INTERPRETED, ": -Oicf" );
            SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
            OptimLevel = OPT_LEVEL_OICF;
            }
        }
    else
        {
        // Default for the -O switch is -Oicf on 64b
        SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
        OptimLevel = OPT_LEVEL_OICF;
        }
    
    // Disable -no_robust switch for 277.
    // if ( ! IsSwitchDefined( SWITCH_NO_ROBUST ) &&
    
    if ( GetOptimizationFlags() & OPTIMIZE_ALL_I2_FLAGS )
        {
        // Default 64b processing to robust, when -Oicf, unless -no_robust
        GetNdrVersionControl().SetHasDOA();
        SwitchDefined( SWITCH_ROBUST );
        }

}
    
/*****************************************************************************
 *    utility functions
 *****************************************************************************/
void
ReportUnimplementedSwitch(
    short    SWValue
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    report an unimplemented switch error.

 Arguments:

    SWValue    -    switch value.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
    {
    char    buf[ 50 ];
    strcpy(buf, SwitchStringForValue( SWValue ) );
    RpcError((char *)NULL,0,UNIMPLEMENTED_SWITCH, buf);
    }

STATUS_T
SelectChoice(
    const CHOICE *  pCh,
    char     *      pUserInput,
    short    *      pChoice)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Search for the given multiple choice table for the given choice.

 Arguments:

    pCh           -    pointer to multiple choice table.
    pUserInput    -    user input string.
    pChoice       -    return the choice value.

 Return Value:

    ILLEGAL_ARGUMENT   if the user input did not represent a valid choice
                       for the switch.

    STATUS_OK          if everything is hunky dory.

 Notes:

----------------------------------------------------------------------------*/
{

    char    *    pChStr;

    while ( pCh && ( pChStr = (char *) pCh->pChoice ) != 0 )
        {
        if( strcmp( pChStr, pUserInput ) == 0 )
            {
            *pChoice = pCh->Choice;
            return STATUS_OK;
            }
        pCh++;
        }
    return ILLEGAL_ARGUMENT;
}

enum _swenum
SearchForSwitch(
    char    **    ppArg )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Search for the switch, given the users input as switch name.

 Arguments:

    ppArg    - pointer to users input pointer.

 Return Value:

    the switch value, if found, SWITCH_NOTHING otherwise.

 Notes:

    search for exact switch name match, and if found, bump the pointer to
    point to the character after the switch name, so that any input to the
    switch can be looked at after the switch string is out of the way.

    Checking the exact length may be a problem, because some switches like
    -I can take no space between the arg. In these cases, ignore the length
    match.

----------------------------------------------------------------------------*/
    {
    short               Len , LenArg, iIndex = 0;
    BOOL                fLengthIsOk;
    char            *   pSrc;
    struct sw_desc  *   pSwDesc = (struct sw_desc*) &switch_desc[0];

    LenArg = (short)strlen( *ppArg );

    while( iIndex < (sizeof(switch_desc) / sizeof( struct sw_desc ) ) )
        {
        pSrc        = (char *) pSwDesc->pSwitchName;
        Len         = (short)strlen( pSrc );
        fLengthIsOk =
            ((pSwDesc->flag & ARG_SPACE_OPTIONAL) || (Len==LenArg));

        if(fLengthIsOk && strncmp( pSrc, *ppArg, Len ) == 0 )
            {
            *ppArg += Len;
            return (_swenum) iIndex;
            }
        iIndex++;
        pSwDesc++;
        }
    return SWITCH_NOTHING;
    }

char*
SwitchStringForValue(
    unsigned short SWValue
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    return the switch string given the value of the switch.

 Arguments:

    SWValue    - switch value.


 Return Value:

    pointer to the switch string. pointer to a null string if not found.

 Notes:

----------------------------------------------------------------------------*/
    {
#define SWITCH_DESC_SIZE (sizeof(switch_desc) / sizeof(struct sw_desc))
    struct sw_desc  *   pDesc  = (struct sw_desc*) &switch_desc[0],
                    *   pDescEnd = (struct sw_desc*) &switch_desc[0] + SWITCH_DESC_SIZE;

    while( pDesc < pDescEnd )
        {
        if( pDesc->SwitchValue == (enum _swenum ) SWValue)
            return (char *) pDesc->pSwitchName;
        pDesc++;
        }
    return "";
    }

inline
char *
YesOrNoString( BOOL Yes )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 return "Yes" for true, "No" for false

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    return Yes ? "Yes" : "No";
}

void
CommandLine::Confirm()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 confirm the arguments by dumping onto the screen

 Arguments:

    None.

 Return Value:

    None.

 Notes:

----------------------------------------------------------------------------*/
{
    short       Option;
    char   *    p;
    char        Buffer[100];

    fprintf( stdout, "%s bit arguments", 
                     (Is64BitEnv() ? "64" : "32" )
           );

    PrintArg( BASE_FILENAME, GetInputFileName() , 0 );
    if( IsSwitchDefined( SWITCH_ACF ) )
        PrintArg( SWITCH_ACF , GetAcfFileName(), 0);

    PrintArg( SWITCH_APP_CONFIG,
              YesOrNoString(IsSwitchDefined( SWITCH_APP_CONFIG)), 0);

    PrintArg( SWITCH_C_EXT,
              YesOrNoString(IsSwitchDefined( SWITCH_C_EXT)), 0);

    Option    = GetClientSwitchValue();
    PrintArg( SWITCH_CLIENT,
              (Option == CLNT_STUB) ? "stub" : "none", 0);

    Option = GetCharOption();

    PrintArg( SWITCH_CHAR, (Option == CHAR_SIGNED ) ? "signed" :
                           (Option == CHAR_UNSIGNED ) ? "unsigned" : "ascii7",0);
                        
    if( IsSwitchDefined(SWITCH_CONFIRM) )
        PrintArg( SWITCH_CONFIRM, "Yes" , 0);

    PrintArg( SWITCH_CPP_CMD, GetCPPCmd() , 0);
    PrintArg( SWITCH_CPP_OPT, GetCPPOpt() , 0);
    _itoa( GetMSCVer(), Buffer, 10 );
    PrintArg( SWITCH_MSC_VER, Buffer , 0);

    if ( ( p = GetCstubFName() ) != 0 )
        PrintArg( SWITCH_CSTUB, p , 0);

    if( IsSwitchDefined( SWITCH_D ) )
        PrintArg( SWITCH_D, pDSwitch->GetConsolidatedOptions(), 0 );

    Option = GetEnv();
    PrintArg( SWITCH_ENV,
              (Option == ENV_WIN64)  ? "win64"
                                     : "win32",
              0 );

    PrintArg( SWITCH_APPEND64,
              YesOrNoString(IsSwitchDefined( SWITCH_APPEND64)), 0);

    Option = GetErrorOption();

    Option = (short)IsRpcSSAllocateEnabled();

    PrintArg( SWITCH_RPCSS,
              YesOrNoString(IsSwitchDefined( SWITCH_RPCSS)), 0);

#ifdef MIDL_INTERNAL
    PrintArg( SWITCH_NETMON,
              YesOrNoString(IsSwitchDefined( SWITCH_NETMON)), 0);
#endif

    PrintArg( SWITCH_USE_EPV, YesOrNoString(IsSwitchDefined( SWITCH_USE_EPV )), 0);

    PrintArg( SWITCH_NO_DEFAULT_EPV, YesOrNoString(IsSwitchDefined( SWITCH_NO_DEFAULT_EPV )), 0);

    //
    // error options.
    //


    Buffer[0] = '\0';

    if( ErrorOption != ERROR_NONE )
        {
        if( ErrorOption & ERROR_ALLOCATION )
            strcat( Buffer, "allocation ");
        if( ErrorOption & ERROR_REF )
            strcat( Buffer, "ref ");
        if( ErrorOption & ERROR_BOUNDS_CHECK )
            strcat( Buffer, "bounds_check ");
        if( ErrorOption & ERROR_ENUM )
            strcat( Buffer, "enum ");
        if( ErrorOption & ERROR_STUB_DATA )
            strcat( Buffer, "stub_data ");
        }
    else
        strcat( Buffer, "none" );
            
    PrintArg( SWITCH_ERROR, Buffer, 0 );


    if ( ( p = GetHeader() ) != 0 )
        PrintArg( SWITCH_HEADER, p , 0);

    if( IsSwitchDefined( SWITCH_I ) )
        PrintArg( SWITCH_I, pISwitch->GetConsolidatedOptions(), 0 );

    PrintArg( SWITCH_NOLOGO,
              YesOrNoString(IsSwitchDefined( SWITCH_NOLOGO)), 0);

    PrintArg( SWITCH_MS_EXT,
              YesOrNoString(IsSwitchDefined( SWITCH_MS_EXT)), 0);

    PrintArg( SWITCH_MS_UNION,
              YesOrNoString(IsSwitchDefined( SWITCH_MS_UNION)), 0);

    PrintArg( SWITCH_NO_FMT_OPT,
              YesOrNoString(IsSwitchDefined( SWITCH_NO_FMT_OPT)), 0);

#ifdef MIDL_INTERNAL
    PrintArg( SWITCH_GUARD_DEFS,
              YesOrNoString(IsSwitchDefined( SWITCH_GUARD_DEFS)), 0);
#endif

    PrintArg( SWITCH_OLDNAMES,
              YesOrNoString(IsSwitchDefined( SWITCH_OLDNAMES)), 0);

    if ( 0 != WireCompatOption)
        {
        Buffer[0] = '\0';

        if( ErrorOption & WIRE_COMPAT_ENUM16UNIONALIGN )
            strcat( Buffer, "enum16unionalign ");
            
        PrintArg( SWITCH_WIRE_COMPAT, Buffer, 0 );
        }

    if( IsSwitchDefined( SWITCH_NO_CPP ) )
        PrintArg( SWITCH_NO_CPP, "Yes" , 0);

    if( IsSwitchDefined( SWITCH_NO_DEF_IDIR ) )
        PrintArg( SWITCH_NO_DEF_IDIR, "Yes", 0 );

    if( IsSwitchDefined( SWITCH_NO_WARN ) )
        PrintArg( SWITCH_NO_WARN, "Yes" , 0);

    if( IsSwitchDefined( SWITCH_USE_EPV ) )
        PrintArg( SWITCH_USE_EPV, "Yes" , 0);
    
    if( IsSwitchDefined( SWITCH_NO_DEFAULT_EPV ) )
        PrintArg( SWITCH_NO_DEFAULT_EPV, "Yes" , 0);
    

    if ( ( p = GetOutputPath() ) != 0 )
        PrintArg( SWITCH_OUT, GetOutputPath(), 0 );

    Option    = GetZeePee();

    if( IsSwitchDefined( SWITCH_PACK ) )
        PrintArg( SWITCH_PACK,
                  (Option == 1) ? "1"    :
                  (Option == 2) ? "2"    :
                  (Option == 4) ? "4"    : "8" , 0);

    if( IsSwitchDefined( SWITCH_PREFIX ) )
        {
        char    *    pSys;
        char    *    pUser;
        char    *    pAll    = pSwitchPrefix->GetUserDefinedEquivalent( PREFIX_ALL );
        short        Cur;
        while( (Cur = pSwitchPrefix->GetNext( &pSys, &pUser ) ) >= 0 )
            {
            // if he specified all, don't report others that are the same
            if ( ( Cur == PREFIX_ALL ) ||
                 !pAll ||
                 strcmp( pAll, pUser ) )
                {
                PrintArg( SWITCH_PREFIX,
                          pSys,
                          pUser );
                }
            }
        }

    Option    = GetServerSwitchValue();

    PrintArg( SWITCH_SERVER,
              (Option == SRVR_STUB) ? "stub" : "none" , 0 );

    if ( ( p = GetSstubFName() ) != 0 )
        PrintArg( SWITCH_SSTUB, p , 0);

    if ( IsSwitchDefined( SWITCH_SYNTAX_CHECK ) )
        PrintArg( SWITCH_SYNTAX_CHECK, "Yes", 0 );

    if ( IsSwitchDefined( SWITCH_U ) )
        PrintArg( SWITCH_U, pUSwitch->GetConsolidatedOptions(), 0 );

    PrintArg( SWITCH_O,
              GetOptimizationFlags() == OPTIMIZE_SIZE
                                     ?  "inline stubs"
                                     :  "interpreted stubs",
                  0 );

    Option    = GetWarningLevel();
    PrintArg( SWITCH_W,
              (Option == 0 ) ? "0" :
              (Option == 1 ) ? "1" :
              (Option == 2 ) ? "2" :
              (Option == 3 ) ? "3" :
              (Option == 4 ) ? "4" :
              (Option == 5 ) ? "5" : "6" , 0);
        
    if( IsSwitchDefined( SWITCH_WX ) )
        PrintArg( SWITCH_WX, "Yes", 0 );

    Option = GetZeePee();

    PrintArg( SWITCH_ZP,
              (Option == 1) ? "1"    :
              (Option == 2) ? "2"    :
              (Option == 4) ? "4"    : "8" , 0);

    if( IsSwitchDefined( SWITCH_ZS ) )
        PrintArg( SWITCH_ZS, "Yes", 0 );

    if( IsSwitchDefined( SWITCH_MS_CONF_STRUCT ) )
        PrintArg( SWITCH_MS_CONF_STRUCT, "Yes", 0 );

    fprintf(stdout, "\n" );
}

char *            
CommandLine::GetCompilerVersion()
    {
    if ( !szCompilerVersion[0] )
        {
        sprintf( szCompilerVersion, "%d.%02d.%04d", rmj, rmm, rup );
        }
    return szCompilerVersion;
    }

// note that this string ends with a newline.
char *            
CommandLine::GetCompileTime()
    {
    if ( !szCompileTime[0] )
        {
        time_t        LocalTime;
        // fetch the time
        time( &LocalTime );
        // convert to a string
        strcpy( szCompileTime, ctime( &LocalTime ) );
        }
    return szCompileTime;
    }


// ----------------------------------------------------------------------------
//    The help screen(s)
//

const char *HelpArray[] = {
 "                       -MIDL COMPILER OPTIONS-"
,"                                -MODE-"
,"/ms_ext            Microsoft extensions to the IDL language (default)"
,"/c_ext             Allow Microsoft C extensions in the IDL file (default)"
,"/osf               OSF mode - disables /ms_ext and /c_ext options"
,"/app_config        Allow selected ACF attributes in the IDL file"
,"/mktyplib203       MKTYPLIB Version 2.03 compatiblity mode"
,""
,"                               -INPUT-"
,"/acf filename      Specify the attribute configuration file"
,"/I directory-list  Specify one or more directories for include path"
,"/no_def_idir       Ignore the current and the INCLUDE directories"
,""
,"                       -OUTPUT FILE GENERATION-"
,"/client none       Do not generate client files"
,"/client stub       Generate client stub file only"
,"/out directory     Specify destination directory for output files"
,"/server none       Generate no server files"
,"/server stub       Generate server stub file only"
,"/syntax_check      Check syntax only; do not generate output files"
,"/Zs                Check syntax only; do not generate output files"
,"/oldtlb            Generate old format type libraries"
,"/newtlb            Generate new format type libraries (default)"
,"/notlb             Don't generate the tlb file"
,""
,"                         -OUTPUT FILE NAMES-"
,"/cstub filename    Specify client stub file name"
,"/dlldata filename  Specify dlldata file name"
,"/h filename        Specify header file name"
,"/header filename   Specify header file name"
,"/iid filename      Specify interface UUID file name"
,"/proxy filename    Specify proxy file name"
,"/sstub filename    Specify server stub file name"
,"/tlb filename      Specify type library file name"
#ifdef MIDL_INTERNAL
,"/netmonstub filename     Specify Netmon classic interface stub file name"
,"/netmonobjstub filename  Specify Netmon object interface stub file name"
#endif // MIDL_INTERNAL
,""
,"                -C COMPILER AND PREPROCESSOR OPTIONS-"
,"/cpp_cmd cmd_line  Specify name of C preprocessor (default: cl.exe)"
,"/cpp_opt options   Specify additional C preprocessor options"
,"/D name[=def]      Pass #define name, optional value to C preprocessor"
,"/no_cpp            Turn off the C preprocessing option"
,"/nocpp             Turn off the C preprocessing option"
,"/U name            Remove any previous definition (undefine)"
,"/msc_ver <nnnn>    Microsoft C/C++ compiler version"
,"/savePP            Save the preprocessed temporary file(s)"
,""
,"                            -ENVIRONMENT-"
,"/char signed       C compiler default char type is signed"
,"/char unsigned     C compiler default char type is unsigned"
,"/char ascii7       Char values limited to 0-127"
,"/env win32         Target environment is Microsoft Windows 32-bit (NT)"
,"/env win64         Target environment is Microsoft Windows 64-bit (NT)"
,"/lcid              Locale id for international locales"
,"/ms_union          Use Midl 1.0 non-DCE wire layout for non-encapsulated unions"
,"/oldnames          Do not mangle version number into names"
,"/rpcss             Automatically activate rpc_sm_enable_allocate"
,"/use_epv           Generate server side application calls via entry-pt vector"
,"/no_default_epv    Do not generate a default entry-point vector"
,"/prefix client str Add \"str\" prefix to client-side entry points"
,"/prefix server str Add \"str\" prefix to server-side manager routines"
,"/prefix switch str Add \"str\" prefix to switch routine prototypes"
,"/prefix all str    Add \"str\" prefix to all routines"
,"/win32             Target environment is Microsoft Windows 32-bit (NT)"
,"/win64             Target environment is Microsoft Windows 64-bit (NT)"
,"/protocol dce      Use DCE NDR transfer syntax (default for 32b)"
,"/protocol all      Use all supported transfer syntaxes"
,"/protocol ndr64    Use Microsoft extension NDR64 transfer syntax"
,"/target {system}   Set the minimum target system"

,""
,"                     -RUNTIME ERROR CHECKING BY STUBS-"
,"/error all         Turn on all the error checking options, the best flavor"
,"/error none        Turn off all the error checking options"
,"/error allocation  Check for out of memory errors"
,"/error bounds_check   Check size vs transmission length specification"
,"/error enum        Check enum values to be in allowable range"
,"/error ref         Check ref pointers to be non-null"
,"/error stub_data   Emit additional check for server side stub data validity"
,"/robust            Generate additonal information to validate parameters. "
,"                   Requires Windows 2000 and after (default)"
,"/no_robust         turn off /robust feature"
,""
,"                            -OPTIMIZATION-"
,"/align {N}         Designate packing level of structures"
,"/pack {N}          Designate packing level of structures"
,"/Zp {N}            Designate packing level of structures"
,"/no_format_opt     Skip format string reusage optimization"
,"/Oi                Generate fully interpreted stubs, old style"
,"                   -Oicf is usually better"
,"/Oic               Generate fully interpreted stubs for standard interfaces and"
,"                   stubless proxies for object interfaces as of NT 3.51 release"
,"                   using -Oicf instead is usually better"
,"/Oicf              Generate fully interpreted stubs with extensions and stubless"
,"                   proxies for object interfaces as of NT 4.0 release (default)"
,"/Oif               Same as -Oicf"
,"/Os                Generate inline stubs"
#ifdef MIDL_INTERNAL
,"/netmon            Generate stubs for Netmon debugging (requires -Oicf)"
#endif // MIDL_INTERNAL
,""
,"                           -MISCELLANEOUS-"
,"@response_file     Accept input from a response file"
,"/?                 Display a list of MIDL compiler switches"
,"/confirm           Display options without compiling MIDL source"
,"/help              Display a list of MIDL compiler switches"
,"/nologo            Supress displaying of the banner lines"
,"/o filename        Redirects output from screen to a file"
,"/W{0|1|2|3|4}      Specify warning level 0-4 (default = 1)"
,"/WX                Report warnings at specified /W level as errors"
,"/no_warn           Suppress compiler warning messages"
};

STATUS_T
CommandLine::Help()
    {
    int         i,LineCount,MaxLineCount = 23;

    for(i = 0; i < sizeof(HelpArray)/sizeof(char *) ;)
        {
        for( LineCount = 0;
             (LineCount < MaxLineCount) && (i < sizeof(HelpArray)/sizeof(char *)) ;
             LineCount++,++i )
            {
            fprintf(stdout, "%s\n", HelpArray[i] );
            }

        //
        // if all the help strings are displayed, then no need for user input.
        //

        if( i < (sizeof( HelpArray ) / sizeof( char *)) )
            {
            if( _isatty( MIDL_FILENO( stdout ) ) )
                {
                fprintf( stdout, "[ Press <return> to continue ]" );
                MIDL_FGETCHAR();
                }
            }
        }

    return STATUS_OK;
    }

void
PrintArg(
    enum _swenum Switch,
    char    *    pFirst,
    char    *    pSecond )
{
    char *    pL        = "",
         *    pR        = "",
         *    pComma    = "";
    char *    pSwString = (Switch == BASE_FILENAME) ? "input file" :
                        SwitchStringForValue( (unsigned short)Switch );

    if( pSecond )
        {
        pL    = "(";
        pR    = ")";
        pComma    = ",";
        }
    else
        pSecond = "";

    fprintf( stdout, "\n%20s - %s %s %s %s %s"
            , pSwString
            , pL
            , pFirst
            , pComma
            , pSecond
            , pR );
}

void
CmdProcess(
    pair_switch*    pPair,
    CommandLine*    pCmdAna,
    char*           pFirstOfPair)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    pair_switch command analyzer

 Arguments:

    pCmdAna                - a ptr to the command analyser object calling this.
    pFirstOfPair        - the first argument after the -prefix switch.

 Return Value:

    NA

 Notes:

    Use the GetNextArg and UndoGetNextArg functions as necessary.

    1. We start with the input argument, which is the first of the
       arguments to the prefix switch, ie first of the first pair.

    2. If we find an argument starting with a '-' or  '/' it is definitely the
       end of the prefix specification. If the switch starter is seen at the end
       of a pair it is a proper end of the prefix switch, else the prefix switch
       pair specification is illegal.

    3. In either case, as soon as a switch starter is seen, we must
       UndoGetNextArg.

    This class needs a pointer to the command analyser object that is calling
    it, since it has to get and undoget argument from there

----------------------------------------------------------------------------*/
{
    short        PairCheck    = 0;
    char    *    pNextOfPair;
    char    *    pTemp;
    STATUS_T     Status       = STATUS_OK;
    short        i;


    while( pFirstOfPair &&  (*pFirstOfPair != '-') && (*pFirstOfPair != '/' ) )
        {

        // the first of the pair is a system defined string. Is it a valid one?

        if( (i = pPair->GetIndex( pFirstOfPair )) >= 0 )
            {

            // we know the first of the pair is valid. Check the next before
            // allocating any memory.

            PairCheck++;
            pTemp = pCmdAna->GetNextArg();

            if( pTemp && (*pTemp != '-') && (*pTemp != '/') )
                {
                pNextOfPair = new char [ strlen( pTemp ) + 1 ];
                strcpy( pNextOfPair, pTemp );

                // update the list

                pPair->AddPair( i, pNextOfPair );
                PairCheck++;
                }
            else
                break;
            }
        else
            break;
        pFirstOfPair = pCmdAna->GetNextArg();

        if( PairCheck == 0 )
            {
            Status = ILLEGAL_ARGUMENT;
            }
        else if( (PairCheck % 2) != 0 )
            {
            Status = MISMATCHED_PREFIX_PAIR;
            }
    
        if( Status != STATUS_OK )
            {
            RpcError( (char *)NULL,
                      0,
                      Status,
                      SwitchStringForValue( SWITCH_PREFIX ) );

            }
    
    }

    // if we read ahead, push the argument back
    if ( pFirstOfPair )
        pCmdAna->UndoGetNextArg();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\driver\ppcmd.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    ppcmd.cxx

 Abstract:

    This file preprocesses the command line to check for response file
    input.

 Notes:

    This file extends the register args routine from the command analyser to
    incorporate the response files.

 Author:

    vibhasc 03-16-91 Created to conform to coding guidelines.
    NishadM 02-03-97 rewrite to simplify, allow DBCS, remove bugs

 ----------------------------------------------------------------------------*/

#if 0
                            Notes
                            -----
    We want to make implementations of the response file completely transparent 
    to the rest of the compiler. The response file is specified to midl using 
    the syntax:

        midl <some switches> @full response file path name <more switches>.

    We dont want to restrict the user from specifyin the response file at any
    place in the command line, any number of times. At the same time we do not
    want the command analyser to even bother about the response file, to keep
    implementation very localised. In order to do that, we do a preprocessing
    on the command line to look for the response file command. 

    The command analyser expects the arguments in an argv like array. The 
    preprocessor will creates this array, expanding all response file commands
    into this array, so that the command analyser does not even notice the 
    difference. 

    We use our fancy dynamic array implementation to create this argv-like
    array.

    Things to keep in mind:

    1. The response file needs to be parsed.
    2. Each option must be completely specified in a command line. i.e
       the option cannot be continued in a separate line using the continuation
       character or anything.
    3. Each switch must be presented just the same way that the os command 
       processor does. We need to analyse the string for escaped '"'

#endif // 0

#pragma warning ( disable : 4514 )

/*****************************************************************************
            local defines and includes
 *****************************************************************************/

#include "nulldefs.h"
extern  "C" {
    #include <stdio.h>
    #include <string.h>
    #include <ctype.h>
}
#include "common.hxx"
#include "errors.hxx"
#include "idict.hxx"

extern BOOL                     fNoLogo;
extern void                     RpcError( char *, short, STATUS_T, char *);

bool
AnalyseResponseFile (
                    char*   p,
                    IDICT*  pIDict
                    );
char *
ParseResponseFile   (
                    FILE*           h,
                    unsigned int    uLineNumber,
                    char*           szFilename
                    );

/*****************************************************************************/

bool
PPCmdEngine(
    int         argc,
    char    *   argv[],
    IDICT   *   pIDict )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    command preprocessor engine.

 Arguments:

    argc    - count of the number of arguments
    argv    - vector of arguments to the program
    pIDict  - dictionary of arguments to be returned.

 Return Value:

    Pointer to an indexed dictionary (actually a dynamic array ), containing
    the entire set of arguments, including the ones from the response file.

 Notes:

    Go thru each of the arguments. If you find a response file switch, pick up
    the arguments from the response file and add to the argument list.

----------------------------------------------------------------------------*/
    {
    int         iArg;
    char    *   p,
            *   q;

    bool        fNoLogo = false;

    for( iArg = 0; iArg < argc ; ++iArg )
        {
        p   = argv[ iArg ];

        switch( *p )
            {
            case '@':
                fNoLogo |= AnalyseResponseFile( p, pIDict );
                break;
            case '/':
            case '-':
                // detect /nologo early in the cmd parse
                if ( !strcmp( p+1, "nologo" ) )
                    fNoLogo = true;
                // fall through
            default:
                q   = new char[ strlen( p ) + 1 ];
                strcpy( q, p );
                pIDict->AddElement( (IDICTELEMENT) q );
                break;
            }
        }
    return !fNoLogo;
    }

bool
AnalyseResponseFile (
                    char*   p,
                    IDICT*  pIDict
                    )
{
    FILE*   pResponseFile;
    bool    fNoLogo = false;
    
    // try to open the response file.
    // ++p to skip '@' preceding the filename.
    if ( ( pResponseFile = fopen( ++p, "r") ) == (FILE *)NULL )
        {
        RpcError( (char *)0, 1, CANNOT_OPEN_RESP_FILE, p );
        }
    else
        {
        char*           szArg = 0;
        unsigned int    uLineNumber = 1;

        // the response file successfully opened. parse it.
        while ( ( szArg = ParseResponseFile(
                                            pResponseFile,
                                            uLineNumber,
                                            p
                                            ) ) != 0 )
            {
            if ( 0 == strcmp(szArg, "-nologo")
                 || 0 == strcmp(szArg, "/nologo") )
                {
                fNoLogo = true;
                }

            pIDict->AddElement( szArg );
            }

        fclose( pResponseFile );
        }

    return fNoLogo;
}

char *
ParseResponseFile   (
                    FILE*           h,
                    unsigned int    uLineNumber,
                    char*           szFilename
                    )
{
    char    szTempArg[1024];
    char*   p  = szTempArg;
    int     ch = 0;

    // initialize pTempArg
    *p = 0;

    // remove all the leading spaces
    do
        {
        ch = fgetc( h );
        if ( ch == '\n' )
            {
            uLineNumber++;
            }
        }
    while ( isspace( ch ) );

    if ( ch == '"' )
        {
        // if the argument is within quotes,
        // all chars including spaces make up the
        // argument. The quote is treated as a delimiter
        do
            {
            ch = fgetc( h );
            *p++ = (char) ch;
            if ( ch == '\\' )
                {
                // double back slash is interpreted as one.
                ch = fgetc( h );
                *p++ = (char) ch;
                if ( ch == '\\' )
                    {
                    p--;
                    }
                }
            else if ( ch == '\n' )
                {
                uLineNumber++;
                }
            }
        while ( ch != '"' && ch != EOF );
        *(p - 1) = 0;
        }
    else if ( ch == '@' )
        {
        // first char of the argument is a '@'
        // this means a response file with a response
        // file. Flag an error.
        RpcError( szFilename,
                  (short)uLineNumber,
                  NESTED_RESP_FILE,
                  (char *)0 );
        }
    else if ( ch != EOF )
        {
        // if the argument is not with in quotes,
        // white spaces are delimiters.
        *p++ = (char)ch;
        do
            {
            ch = fgetc( h );
            *p++ = (char)ch;
            if ( ch == '\n' )
                {
                uLineNumber++;
                }
            }
        while ( !isspace( ch ) && ch != EOF );
        *(p - 1) = 0;
        }

    size_t  nSize = strlen( szTempArg );
    char*   szRet = 0;

    if ( nSize != 0 )
        {
        szRet = new char[nSize+1];
        if ( szRet != 0 )
            {
            strcpy( szRet, szTempArg );
            }
        }
    return szRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\expr\expr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    expr.cxx

 Abstract:

    expression evaluator routines implementation.

 Notes:


 History:

    VibhasC     Aug-05-1993     Created

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *  include files
 ***************************************************************************/
#include "nulldefs.h"

extern "C"
    {
    #include <stdio.h>
    
    #include <string.h>
    }

#include "expr.hxx"
#include "listhndl.hxx"
#include "nodeskl.hxx"
#include "semantic.hxx"
#include "symtable.hxx"
#include "cmdana.hxx"
#include <excpt.h>
#include <float.h>

/****************************************************************************
 *  extern definitions
 ***************************************************************************/
/****************************************************************************
 *  extern data
 ***************************************************************************/
extern  SymTable        *   pBaseSymTbl;
extern  CMD_ARG         *   pCommand;

/****************************************************************************
 *  local definitions
 ***************************************************************************/
/****************************************************************************
 *  local data
 ***************************************************************************/
/***************************************************************************/

short
expr_node::MakeListOfVars(
    ITERATOR & 
    )
{
    return( 0 );
}

short
expr_named_constant::MakeListOfVars(
    ITERATOR & 
    )
{
    return( 0 );
}

short
expr_variable::MakeListOfVars(
    ITERATOR & pList
    )
{
    pList.Insert( this );
    return( 1 );
}

short
expr_op_unary::MakeListOfVars(
    ITERATOR & pList
    )
{
    short VarCount = 0;

    if ( GetLeft() )
        VarCount = GetLeft()->MakeListOfVars( pList );
    return( VarCount );
}

short
expr_sizeof::MakeListOfVars(
    ITERATOR & 
    )
/*++
    expr_sizeof is a unary_op but it doesn't have a child!
--*/
{
    return( 0 );
}

short
expr_alignof::MakeListOfVars(
    ITERATOR & 
    )
/*++
    expr_alignof is a unary_op but it doesn't have a child!
--*/
{
    return( 0 );
}

short
expr_op_binary::MakeListOfVars(
    ITERATOR & pList
    )
{
    short VarCount;

    VarCount = GetLeft()->MakeListOfVars( pList );
    if ( GetRight() )
        {
        VarCount = short( VarCount + GetRight()->MakeListOfVars( pList ) );
        }
    return( VarCount );
}

short
expr_ternary::MakeListOfVars(
    ITERATOR & pList
    )
{
    short VarCount;

    VarCount = GetLeft()->MakeListOfVars( pList );
    if ( GetRight() )
        {
        VarCount = short( VarCount + GetRight()->MakeListOfVars( pList ) );
        }
    if ( GetRelational() )
        {
        VarCount = short( VarCount + GetRelational()->MakeListOfVars( pList ) );
        }
    return( VarCount );
}

/***************************************************************************/
void
expr_node::DecorateWithPrefix(
    char *      pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine decorates all the variable nodes in the expression
    with a prefix.

 Arguments:

    pPrefix     - the prefix to be prepended to each variable

 Return Value:

 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR  VarList;
    expr_variable * pVarNode = 0;

    short VarCount = MakeListOfVars( VarList );
    if ( VarCount )
        {
        VarList.Init();
        while ( ITERATOR_GETNEXT( VarList, pVarNode ) )
            pVarNode->SetPrefix( pPrefix );
        }
    return;
}

expr_index::expr_index(
    expr_node * pL,
    expr_node * pR ) : expr_op_binary( OP_INDEX, pL, pR )
    {
    SetType( pL->GetType() );
    }

expr_param *
expr_proc_call::SetParam(
    expr_param  *   pParam )
    {
    expr_param  *   p   = GetFirstParam();

    IncrNoOfParams();
    if( p )
        {
        return p->SetLastPeerParam( pParam );
        }
    else
        return SetFirstParam( pParam );
    }
expr_param *
expr_proc_call::SetParam(
    expr_node * pExpr )
    {
    return SetParam( new expr_param( pExpr ));
    }

expr_param *
expr_param::SetLastPeerParam(
    expr_param  *   pParam )
    {
    expr_param  *   p   = GetNextParam();

    if( p )
        {
        return p->SetLastPeerParam( pParam );
        }
    else
        {
        return SetNextParam( pParam );
        }
    }


/**
 ** This routine attempts to recreate the string to be eaten by c compilers.
 ** If the user specified a string with a quote inside, substitute with an
 ** escape character. The new string with possible escapes will ALWAYS be
 ** smaller than the older one, so allocating the same amount of space is
 ** enough.
 **/

char *
MakeNewStringWithProperQuoting(
    char    *   pSrc )
    {
    char    *   pResult = new char [ strlen( pSrc ) + 1];
    char        ch;
    char    *   pDest   = pResult;

    while( ( ch = *pSrc++ ) != 0 )
        {

        *pDest = ch;

        if( ch == '\\')
            {
            if( ( ch = *pSrc++ ) != 0 )
                {
                if( (ch == '"') || ( ch == '\\') )
                    {
                    *pDest = ch;
                    }
                else
                    {
                    *pDest++ = '\\';
                    *pDest   = ch;
                    }
                }
            else
                break;
            }
        pDest++;
        }
    *pDest = '\0';
    return pResult;
    }

// routines for expr_variable...

// constructor - see if the type is constant
expr_variable::expr_variable( PNAME p, node_skl * pT )
{
    SetName( p );
    SetType( pT );
    SetConstant( FALSE );
    SetPrefix( NULL );
}

// resolve forwards on GetType
node_skl        *
expr_variable::GetType( void )
{
    if ( pType )
        {
        if ( pType->NodeKind() == NODE_FORWARD )
            {
            node_forward*   pFwd = (node_forward *) pType;
            // (permanently) resolve the forward
            pType = pFwd->ResolveFDecl();
            // if it couldn't be resolved, put back the forward
            if ( !pType )
                {
                pType = pFwd;
                }
            }
        }
    return pType;
}

// named constant routines...

// evaluate the variable if it is a constant
EXPR_VALUE
expr_named_constant::GetValue()
{
    node_skl *  pT      = GetType();
    NODE_T      Kind    = ( pT ) ? (NODE_T) pT->NodeKind()
                                 : (NODE_T) NODE_ILLEGAL;

    if ( !IsConstant() )
        return 0;

    // identifiers may be const... Forwards are assumed NOT const
    if ( Kind == NODE_ID )
        {
        node_id *       pId     = (node_id *) pT;
        node_skl    *   pType   = pId->GetBasicType();
        EXPR_VALUE      Result  = (pId->GetExpr()->GetValue() );

        return (pType) ? pType->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
        }
    else if ( Kind == NODE_LABEL )
        {
        return ( (node_label *) pT)->GetValue();
        }

    MIDL_ASSERT(FALSE);
    return 0; // for the compiler...
}

// evaluate the variable if it is a constant
expr_node *
expr_named_constant::GetExpr()
{
    node_skl *  pT      = GetType();
    NODE_T      Kind    = ( pT ) ? (NODE_T) pT->NodeKind()
                                 : (NODE_T) NODE_ILLEGAL;

    if ( !IsConstant() )
        return 0;

    // identifiers may be const... Forwards are assumed NOT const
    if ( Kind == NODE_ID )
        {
        node_id *       pId = (node_id *) pT;

        return pId->GetExpr();
        }
    else if ( Kind == NODE_LABEL )
        {
        return ( (node_label *) pT)->pExpr;
        }

    MIDL_ASSERT(FALSE);
    return 0; // for the compiler...
}

/******************************************************************************
 *  expression list handler
 *****************************************************************************/
expr_list::expr_list()
    {
    SetConstant( TRUE );
    }

STATUS_T
expr_list::GetPeer(
    expr_node   **  ppExpr )
    {
    return (GetNext( (void **)ppExpr ) );
    }
STATUS_T
expr_list::SetPeer(
    expr_node   *   pExpr )
    {
    if ( pExpr && !pExpr->IsConstant() )
        SetConstant( FALSE );

    return Insert( (void *) pExpr );
    }

EXPR_VALUE
expr_u_arithmetic::GetValue()
{
        EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
        EXPR_VALUE  Result;

        switch ( GetOperator() )
            {
            case OP_UNARY_PLUS:
                {
                Result = LeftValue;
                break;
                }
            case OP_UNARY_MINUS:
                {
                if (IsStringConstant())
                    {
                    char * szVal = (char *)LeftValue;
                    char * szNewVal = new char[strlen(szVal)+2];
                    szNewVal[0] = '-';
                    strcpy(szNewVal + 1, szVal);
                    Result = (EXPR_VALUE) szNewVal;
                    }
                else
                    {
                    Result = -LeftValue;
                    }    
                break;
                }
            default:
                {
                Result = 0;
                break;
                }
            }
        return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
}

EXPR_VALUE
expr_u_not::GetValue()
{
    EXPR_VALUE  Result = !GetLeft()->GetValue();

    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
}

EXPR_VALUE
expr_u_complement::GetValue()
{
    EXPR_VALUE  Result = ~ GetLeft()->GetValue();

    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
}

EXPR_VALUE
expr_cast::GetValue()
{
    return GetType()->
                ConvertMyKindOfValueToEXPR_VALUE(GetLeft()->GetValue());
}

EXPR_VALUE
expr_constant::GetValue()
{
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Value.I64) 
                       : Value.I64;
}


EXPR_VALUE
expr_sizeof::GetValue()
    {
    return  (pType) ? pType->GetSize() : 0;
    }

EXPR_VALUE
expr_alignof::GetValue()
    {
    return  (pType) ? pType->GetAlign() : 0;  
    }

EXPR_VALUE
expr_b_arithmetic::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        case OP_PLUS:
            {
            Result = LeftValue + RightValue;
            break;
            }
        case OP_MINUS:
            {
            Result = LeftValue - RightValue;
            break;
            }
        case OP_STAR:
            {
            Result = LeftValue * RightValue;
            break;
            }
        case OP_SLASH:
            {
            if (RightValue == 0)
                Result = 1;
            else
                Result = LeftValue / RightValue;
            break;
            }
        case OP_MOD:
            {
                        if ( 0 == RightValue )
                                Result = 1;
                        else
                    Result = LeftValue % RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result ;
    }

EXPR_VALUE
expr_b_logical::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        case OP_LOGICAL_AND:
            {
            Result = LeftValue && RightValue;
            break;
            }
        case OP_LOGICAL_OR:
            {
            Result = LeftValue || RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result ;
    }

EXPR_VALUE
expr_relational::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        // gaj - we implicitly assume signed types
        case OP_LESS:
            {
            Result = LeftValue < RightValue;
            break;
            }
        case OP_LESS_EQUAL:
            {
            Result = LeftValue <= RightValue;
            break;
            }
        case OP_GREATER_EQUAL:
            {
            Result = LeftValue >= RightValue;
            break;
            }
        case OP_GREATER:
            {
            Result = LeftValue > RightValue;
            break;
            }
        case OP_EQUAL:
            {
            Result = LeftValue == RightValue;
            break;
            }
        case OP_NOT_EQUAL:
            {
            Result = LeftValue != RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
    }

EXPR_VALUE
expr_shift::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        // gaj - we implicitly assume signed types
        case OP_LEFT_SHIFT:
            {
            Result = LeftValue << RightValue;
            break;
            }
        case OP_RIGHT_SHIFT:
            {
            Result = LeftValue >> RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
    }

EXPR_VALUE
expr_bitwise::GetValue()
    {
    EXPR_VALUE  LeftValue   = GetLeft()->GetValue();
    EXPR_VALUE  RightValue  = GetRight()->GetValue();
    EXPR_VALUE  Result;

    switch ( GetOperator() )
        {
        // gaj - we implicitly assume signed types
        case OP_AND:
            {
            Result = LeftValue & RightValue;
            break;
            }
        case OP_OR:
            {
            Result = LeftValue | RightValue;
            break;
            }
        case OP_XOR:
            {
            Result = LeftValue ^ RightValue;
            break;
            }
        default:
            {
            Result = 0;
            break;
            }
        }
    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result ;
    }

EXPR_VALUE
expr_ternary::GetValue()
    {
    EXPR_VALUE  RelValue    = GetRelational()->GetValue();
    EXPR_VALUE  Result;

    if ( RelValue )
        Result = GetLeft()->GetValue();
    else
        Result = GetRight()->GetValue();

    return (GetType()) ? GetType()->ConvertMyKindOfValueToEXPR_VALUE(Result) : Result;
    }

////////////////////////////////////////////////////////////////////////
// analysis of expressions
//

void
expr_node::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
    }

//
// determine the type of the expression
//

void
expr_op_unary::DetermineType()
{
    node_skl    *   pLeftType;

    if ( !GetLeft() )
        {
        return;
        }

    pLeftType = GetLeft()->AlwaysGetType();
    SetConstant( GetLeft()->IsConstant() );

    switch ( GetOperator() )
        {
        case OP_UNARY_PLUS:
        case OP_UNARY_COMPLEMENT:
        case OP_UNARY_MINUS:
        case OP_PRE_INCR:
        case OP_PRE_DECR:
        case OP_POST_INCR:
        case OP_POST_DECR:
            {
            // same type
            SetType( pLeftType );
            break;
            }
        case OP_UNARY_NOT:
            {
            node_skl *  pTmpType;

            GetBaseTypeNode( &pTmpType, SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN );

            SetType( pTmpType );
            break;
            }
        case OP_UNARY_CAST:
            {
            SetType( GetType() );
            break;
            }
        case OP_UNARY_SIZEOF:
                case OP_UNARY_ALIGNOF:
            {
            node_skl *  pTmpType;

            GetBaseTypeNode( &pTmpType, SIGN_SIGNED, SIZE_UNDEF, TYPE_INT );

            SetType( pTmpType );
            SetConstant( TRUE );
            break;
            }
        case OP_UNARY_INDIRECTION:
            {
            node_skl *  pNode = pLeftType;

            if ( pNode->NodeKind() != NODE_POINTER )
                {
                // probably the param or field; look down
                pNode = pNode->GetBasicType();
                }

            // now get the pointee
            pNode = pNode->GetBasicType();

            SetType( pNode );
            break;
            }
        case OP_UNARY_AND:
            {
            node_pointer    *   pPtr    = new node_pointer;

            pPtr->SetChild( pLeftType );
            SetType( pPtr );
            break;
            }
        default:
            {
            break;
            }
        }   // end of switch
}

void
expr_op_unary::ExprAnalyze( EXPR_CTXT * pExprCtxt )
{
    EXPR_CTXT           LeftCtxt( pExprCtxt );

    if ( GetLeft() )
        {
        GetLeft()->ExprAnalyze( &LeftCtxt );
        pExprCtxt->MergeUpFlags( &LeftCtxt );
        SetConstant( GetLeft()->IsConstant() );
        }
    else if ( GetOperator() != OP_UNARY_SIZEOF && GetOperator() != OP_UNARY_ALIGNOF)
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    // do type compatibility stuff

    switch ( GetOperator() )
        {
        case OP_UNARY_PLUS:
        case OP_UNARY_COMPLEMENT:
            {
            // same type
            pExprCtxt->pType = LeftCtxt.pType;
            pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
            pExprCtxt->fIntegral = LeftCtxt.fIntegral;
            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_MINUS:
            {
            node_skl    *   pTmp;

            pExprCtxt->pType = LeftCtxt.pType;
            pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
            pExprCtxt->TypeInfo.TypeSign = SIGN_SIGNED;
            pExprCtxt->fIntegral = LeftCtxt.fIntegral;
            GetBaseTypeNode( &pTmp, pExprCtxt->TypeInfo );
            if ( pTmp )
                pExprCtxt->pType = pTmp;

            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_NOT:
            {
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_BOOLEAN;
            pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
            GetBaseTypeNode( &(pExprCtxt->pType ), pExprCtxt->TypeInfo );

            pExprCtxt->fIntegral = TRUE;
            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_CAST:
            {
            SetType( GetType() );
            break;
            }
        case OP_UNARY_SIZEOF:
                case OP_UNARY_ALIGNOF:
            {
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_INT;
            pExprCtxt->TypeInfo.TypeSign = SIGN_SIGNED;
            GetBaseTypeNode( &(pExprCtxt->pType ), pExprCtxt->TypeInfo);

            pExprCtxt->fIntegral = TRUE;
            SetType( pExprCtxt->pType );
            break;
            }
        case OP_UNARY_INDIRECTION:
            {
            node_skl    *       pNode       = GetLeft()->GetType();
            node_skl    *       pOrigNode   = pNode;
            node_ptr_attr   *   pPtrAttr;
            PTRTYPE             PtrKind     = PTR_UNKNOWN;

            if ( pNode->FInSummary( ATTR_PTR_KIND ) )
                {
                pPtrAttr = (node_ptr_attr *)
                            ((named_node *)pNode)->GetAttribute( ATTR_PTR_KIND );
                PtrKind = pPtrAttr->GetPtrKind();
                }

            if ( pNode->FInSummary( ATTR_IGNORE ) )
                {
                SEM_ANALYSIS_CTXT * pCtxt = pExprCtxt->GetCtxt();

                // Only complain about this on the actual type, not every
                // single use of the type.

                if ( !pCtxt->AnyAncestorBits( IN_PARAM_LIST ) )
                    {
                    SemError( 
                            pNode, 
                            *pCtxt, 
                            CORRELATION_DERIVES_FROM_IGNORE_POINTER, 
                            NULL );
                    }
                }

            if ( pNode->NodeKind() != NODE_POINTER )
                {
                // probably the param or field; look down
                pNode = pNode->GetBasicType();
                }

            if ( pNode->NodeKind() != NODE_POINTER )
                {
                // error
                pNode = NULL;
                }
            else
                {
                // check things about type of pointer
                if ( PtrKind == PTR_UNKNOWN )
                    {
                    node_interface  *   pIntf   = pOrigNode->GetMyInterfaceNode();

                    if ( pOrigNode->NodeKind() == NODE_PARAM )
                        PtrKind = PTR_REF;
                    else if ( pIntf->FInSummary( ATTR_PTR_KIND ) )
                        {
                        pPtrAttr = (node_ptr_attr *)
                                        pIntf->GetAttribute( ATTR_PTR_KIND );
                        PtrKind = pPtrAttr->GetPtrKind();
                        }
                    else
                        {
                        pIntf = pExprCtxt->GetCtxt()->GetInterfaceNode();
                        if ( pIntf->FInSummary( ATTR_PTR_KIND ) )
                            {
                            pPtrAttr = (node_ptr_attr *)
                                            pIntf->GetAttribute( ATTR_PTR_KIND );
                            PtrKind = pPtrAttr->GetPtrKind();
                            }
                        else
                            {
                            if (pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
                                {
                                PtrKind = PTR_UNIQUE;
                                }
                            else
                                {
                                PtrKind = PTR_FULL;
                                }
                            }
                        }
                    }

                if ( ( PtrKind == PTR_FULL ) ||
                     ( PtrKind == PTR_UNIQUE ) )
                    {
                    SEM_ANALYSIS_CTXT * pCtxt   = pExprCtxt->GetCtxt();

                    pExprCtxt->SetUpFlags( EX_PTR_FULL_UNIQUE );
                    SemError( pCtxt->GetParent(),
                              *pCtxt,
                              SIZE_LENGTH_SW_UNIQUE_OR_FULL,
                              NULL );
                    }

                pNode = pNode->GetBasicType();
                }

            SetType( pNode );
            break;
            }
        case OP_UNARY_AND:
            {
            if ( GetType() )
                break;

            node_pointer    *   pPtr    = new node_pointer;

            pPtr->SetChild( GetLeft()->GetType() );
            SetType( pPtr );
            break;
            }
        case OP_PRE_INCR:
        case OP_PRE_DECR:
        case OP_POST_INCR:
        case OP_POST_DECR:
            {
            SetType( GetLeft()->GetType() );
            break;
            }
        default:
            {
            break;
            }
        }   // end of switch

    pExprCtxt->pType = GetType();

    // compute the value
    if ( !pExprCtxt->AnyUpFlags( EX_VALUE_INVALID ) )
        {
        // tbd - update value from LeftCtxt
        EXPR_VALUE  &   LeftValue   = LeftCtxt.Value();
        EXPR_VALUE  &   Result      = pExprCtxt->Value();


        switch ( GetOperator() )
            {
            case OP_UNARY_PLUS:
                {
                Result = LeftValue;
                break;
                }
            case OP_UNARY_MINUS:
                {
                Result = -LeftValue;
                break;
                }
            case OP_UNARY_NOT:
                {
                Result = !LeftValue;
                break;
                }
            case OP_UNARY_COMPLEMENT:
                {
                Result = ~LeftValue;
                break;
                }
            case OP_UNARY_CAST:
                {
                Result = LeftValue;
                break;
                }
            case OP_UNARY_SIZEOF:
                        case OP_UNARY_ALIGNOF:
                {
                Result = GetValue();
                break;
                }
            case OP_UNARY_INDIRECTION:
            case OP_UNARY_AND:
            case OP_PRE_INCR:
            case OP_PRE_DECR:
            case OP_POST_INCR:
            case OP_POST_DECR:
                {
                SetConstant( FALSE );
                pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
                break;
                }
            default:
                {
                SetConstant( FALSE );
                Result = 0;
                break;
                }
            }   // end of case

        }  // end of if valid


}

//
// determine the type of the expression
//

void
expr_op_binary::DetermineType()
{
    node_skl    *   pLeftType   = NULL;
    node_skl    *   pRightType  = NULL;


    if ( GetLeft() )
        pLeftType   = GetLeft()->AlwaysGetType();
    if ( GetRight() )
        pRightType  = GetRight()->AlwaysGetType();

    SetConstant( GetRight()->IsConstant() && GetLeft()->IsConstant() );

    ////////////////////////////////////////////////////////////////////////
    // do type compatibility stuff

    switch ( GetOperator() )
        {
        case OP_PLUS:
        case OP_MINUS:
        case OP_STAR:
        case OP_MOD:
        // gaj - we implicitly assume signed types
        case OP_LEFT_SHIFT:
        case OP_RIGHT_SHIFT:
        case OP_AND:
        case OP_OR:
        case OP_XOR:
        case OP_SLASH:
            {
            // tbd - for now, just grab one of the types
            if ( !pRightType ||
                 (pLeftType &&
                        (pLeftType->GetSize() >= pRightType->GetSize() ) ) )
                {
                SetType( pLeftType );
                }
            else if ( pRightType )
                {
                SetType( pRightType );
                }

            break;
            }
        case OP_LOGICAL_AND:
        case OP_LOGICAL_OR:
        // gaj - we implicitly assume signed types
        case OP_LESS:
        case OP_LESS_EQUAL:
        case OP_GREATER_EQUAL:
        case OP_GREATER:
        case OP_EQUAL:
        case OP_NOT_EQUAL:
            {
            node_skl *  pTmpType;

            GetBaseTypeNode( &pTmpType, SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN );

            SetType( pTmpType );
            break;
            }
        default:
            {
            break;
            }
        }



}

void
expr_op_binary::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    EXPR_CTXT           LeftCtxt( pExprCtxt );
    EXPR_CTXT           RightCtxt( pExprCtxt );

    if ( GetLeft() )
        {
        GetLeft()->ExprAnalyze( &LeftCtxt );
        pExprCtxt->MergeUpFlags( &LeftCtxt );
        SetConstant( IsConstant() && GetLeft()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    if ( GetRight() )
        {
        GetRight()->ExprAnalyze( &RightCtxt );
        pExprCtxt->MergeUpFlags( &RightCtx