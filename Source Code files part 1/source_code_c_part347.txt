      ple = pMixerSink->EventQueue.Flink ;
           while ( ple != &pMixerSink->EventQueue ) {
               pPosEventEntry = (PPOSITION_EVENT_ENTRY) CONTAINING_RECORD ( ple,
                                                                KSEVENT_ENTRY,
                                                                ListEntry ) ;
               ple = ple->Flink ;
               if ( pPosEventEntry->EventType == PositionEvent ) {
                    EventSamplePos = (pPosEventEntry->Position)/BytesPerSample ;
                    if ( (EventSamplePos >= CurPos) && (EventSamplePos < NewPos) ) {
#ifdef REALTIME_THREAD
                        if (!pFilterInstance->RealTimeThread) {
#endif            
                            KsGenerateEvent ( &pPosEventEntry->EventEntry ) ;
#ifdef REALTIME_THREAD
                        } else {
                            pPosEventEntry->fRtTrigger = TRUE;
                        }
#endif                   
                    }
                }
           }

       }
       // This is more efficient than MOD
       if ( NewPos >= pMixerSink->BufferLength ) {
           pMixerSink->CurTime.Time = NewPos - pMixerSink->BufferLength ;
       }
       else {
           pMixerSink->CurTime.Time = NewPos ;
       }
       KeReleaseSpinLock ( &pMixerSink->EventLock, OldIrql ) ;
   }
   else {
       pMixerSink->CurTime.Time += Increment ;
   }
   pMixerSink->WriteOffset = pMixerSink->CurTime.Time * BytesPerSample ;
}

NTSTATUS
GetWriteAndPlayOffsets
(
   PFILTER_INSTANCE        pFilterInstance,
   PMIXER_SINK_INSTANCE    pMixerSink,
   PKSAUDIO_POSITION       pPosition,
   BOOL                    fReading
)
{
    ULONGLONG               RenderPos ;
    ULONG                   DeltaSave, Delta ;
    ULONG                   SinkIndex, SourceIndex ;
    ULONG                   SourceBytes, SinkBytes ;
    ULONG                   Numerator, Denominator ;
    PMIXER_SOURCE_INSTANCE  pMixerSource ;
    ULONG                   NumberOfLoops ;
    KIRQL                   OldIrql ;
    ULONG                   NumPendingBlocks ;
    PKTHREAD                CurrentThread;
    KPRIORITY               OldPriority;

    CurrentThread = KeGetCurrentThread();
    OldPriority = KeSetPriorityThread(CurrentThread, pFilterInstance->WorkerThreadPriority);

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

    if ( pMixerSink->fSetCurrentPosition ) {
        pPosition->WriteOffset = pMixerSink->CurTime.Time *
                              (pMixerSink->WaveFormatEx.nChannels*
                              (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;
    }
    else {
        pPosition->WriteOffset = pMixerSink->WriteOffset ;
    }
    pPosition->PlayOffset = pPosition->WriteOffset ;

    if (fReading) {
        KeAcquireSpinLock(&pFilterInstance->MixSpinLock, &OldIrql) ;
        NumPendingBlocks = pFilterInstance->NumPendingIos +
                            pFilterInstance->NumBuffersToMix ;
        KeReleaseSpinLock(&pFilterInstance->MixSpinLock, OldIrql) ;
        pPosition->PlayOffset += NumPendingBlocks *
           (pMixerSink->BytesPerSample*MIXBUFFERDURATION*
             pMixerSink->WaveFormatEx.nSamplesPerSec) / 1000 ;
    }
    
    pMixerSource = (PMIXER_SOURCE_INSTANCE)
            CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                               MIXER_INSTHDR,
                               NextInstance) ;
    if ( !NT_SUCCESS(GetRenderPos(pFilterInstance, &RenderPos)) ) {
        RenderPos = pMixerSource->BytesSubmitted ;
    }

    ASSERT(pMixerSource->BytesSubmitted >= RenderPos) ;
    if ( RenderPos > pMixerSource->BytesSubmitted ) {
        RenderPos = pMixerSource->BytesSubmitted ;
    }
    DeltaSave = Delta = (ULONG) (pMixerSource->BytesSubmitted - RenderPos) ;

    SourceIndex = pMixerSource->BlockInfoIndex ;
    SinkIndex = pMixerSink->BlockInfoIndex ;
    NumberOfLoops = 0 ;
    if (fReading && pMixerSink->InterfaceId != KSINTERFACE_STANDARD_LOOPED_STREAMING) {
        // Delta is how many source bytes it will be until we reach pPosition->PlayOffset
        // Calculate number of sink bytes before reaching pPosition->PlayOffset
        Numerator = (Delta *
                     pMixerSink->pInfo->Src.UpSampleRate *
                     pMixerSink->BytesPerSample) ;
        Denominator = (pMixerSink->pInfo->Src.DownSampleRate *
                       pMixerSource->BytesPerSample) ;

        if ( Denominator == 0 ) {
            // This means the down-sample rate was never set.
            // Should never happen, but we'll be safe anyway.
            // so set the play position to zero and get out of here
            pPosition->PlayOffset = 0 ;
        } else {
            SinkBytes = Numerator/Denominator ;
            if ( Numerator%Denominator ) {
                SinkBytes++ ;
            }

            // Now we subtract the sink bytes from pPosition->PlayOffset to get the current position
            if (pPosition->PlayOffset > SinkBytes) {
                pPosition->PlayOffset -= SinkBytes;
            } else {
                pPosition->PlayOffset = 0;
            }
        }

        // Clip to the end of the buffer
        if (pPosition->PlayOffset > pMixerSink->BytesSubmitted) {
            pPosition->PlayOffset = pMixerSink->BytesSubmitted;
        } else if (pPosition->PlayOffset < pMixerSink->WriteOffset) {
            pPosition->PlayOffset = pMixerSink->WriteOffset;
        }
    } else {
        while ( Delta ) {
            if (NumberOfLoops > MAXNUMMIXBUFFERS) {
                break ;
            }
            SourceBytes = pMixerSource->BlockInfo[SourceIndex].NumBytes ;
            if ( SourceBytes > Delta ) {
                SourceBytes = Delta ;
            }
            Numerator = (SourceBytes *
                         pMixerSink->pInfo->BlockInfo[SinkIndex].DownSampleRate *
                         pMixerSink->pInfo->BlockInfo[SinkIndex].BytesPerSample) ;
            Denominator = (pMixerSink->pInfo->BlockInfo[SinkIndex].UpSampleRate *
                           pMixerSource->BlockInfo[SourceIndex].BytesPerSample) ;

            if ( Denominator == 0 ) {
                // this means we ran out of bytes in the sink
                // (because upsamplerate was never set)
                // so set the play position to zero and get out of here
                pPosition->PlayOffset = 0 ;
                break ;
            }
            SinkBytes = Numerator/Denominator ;
            if ( Numerator%Denominator) {
                SinkBytes++ ;
            }

            if ( SinkBytes > pMixerSink->pInfo->BlockInfo[SinkIndex].NumBytes ) {
                SinkBytes = pMixerSink->pInfo->BlockInfo[SinkIndex].NumBytes ;
            }

            if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
                while ( pPosition->PlayOffset < SinkBytes ) {
                    pPosition->PlayOffset = pPosition->PlayOffset +
                        (pMixerSink->BufferLength*pMixerSink->BytesPerSample) ;
                }
                pPosition->PlayOffset -= SinkBytes ;
            }
            else {
                if ( SinkBytes < pPosition->PlayOffset ) {
                    pPosition->PlayOffset -= SinkBytes ;
                }
                else {
                    pPosition->PlayOffset = 0 ;
                    break ; // break out of the while loop
                }
            }
            SinkIndex = (SinkIndex+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS ;
            SourceIndex = (SourceIndex+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS ;
            Delta -= SourceBytes ;
            NumberOfLoops++ ;
        }
    }

    ZDbgPrint("'KMIXER: GetWriteAndPlayOffsets play=%d, write=%d, sinksub=%d, sourcesub=%d, render=%d\n",
        (ULONG)pPosition->PlayOffset, 
        (ULONG)pPosition->WriteOffset, 
        (ULONG)pMixerSink->BytesSubmitted,
        (ULONG)pMixerSource->BytesSubmitted,
        (ULONG)RenderPos
        );

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    KeSetPriorityThread(CurrentThread, OldPriority);

    return ( STATUS_SUCCESS ) ;
}

VOID
MxCancelIrp
(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
)
{

    Irp->IoStatus.Status = STATUS_CANCELLED ;
    KsCancelRoutine ( DeviceObject, Irp ) ;
    MxCleanupRequest ( Irp ) ;
    IoCompleteRequest ( Irp, IO_AUD_INCREMENT ) ;
}

VOID MxCleanupRequest
(
PIRP    pIrp
)
{
    PWAVEHDREX              phdrex;
    PLOOPPACKET             pLoopPacket;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSSTREAM_HEADER        pStreamHeader ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = pIrpStack->FileObject->FsContext;
    if ( (KSINTERFACE_STANDARD_STREAMING == pMixerSink->InterfaceId) ||
         (KSINTERFACE_STANDARD_LOOPED_STREAMING == pMixerSink->InterfaceId) ) {
        pStreamHeader = (PKSSTREAM_HEADER)pIrp->AssociatedIrp.SystemBuffer ;
        if (pStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM){
            MxGenerateEndOfStreamEvents(pMixerSink) ;
        }
    }
    if ( KSINTERFACE_STANDARD_LOOPED_STREAMING == pMixerSink->InterfaceId ) {
        pLoopPacket = (PLOOPPACKET) InterlockedExchangePointer(
                        &pIrpStack->Parameters.Others.Argument3,
                        NULL ) ;
        if ( pLoopPacket ) {
            FreeMdlList ( pIrp->MdlAddress ) ;
            // Attach the locked MDLs to the IRP & Free the rest
            pIrp->MdlAddress = NULL ;
            AttachLockedMdlsToIrp( pLoopPacket, pIrp ) ;
            FreeMdlList ( pLoopPacket->FirstMdl ) ;
            ExFreePool ( pLoopPacket ) ;
        }
    }
    else if ( KSINTERFACE_MEDIA_WAVE_QUEUED == pMixerSink->InterfaceId ) {
        phdrex = (PWAVEHDREX) InterlockedExchangePointer(
                            &pIrpStack->Parameters.Others.Argument3,
                            NULL ) ;
        if ( phdrex ) {
            ExFreePool ( phdrex ) ;
        }

        if (pMixerSink->LoopIrp == pIrp) {
            // The current loop irp is this one! Get rid of the loop irp.
            pMixerSink->LoopIrp = NULL;
        }
    }
}

#define LOCKEDMDL(pMdl) ((pMdl->MdlFlags)&(MDL_PAGES_LOCKED|MDL_MAPPED_TO_SYSTEM_VA))

VOID AttachLockedMdlsToIrp
(
    PLOOPPACKET pLoopPacket,
    PIRP        pIrp
)
{
    PMDL        prevMdl, curMdl, nextMdl ;

    curMdl = prevMdl = pLoopPacket->FirstMdl ;

    while ( curMdl ) {
        nextMdl = curMdl->Next ;
        if (LOCKEDMDL(curMdl)) {
            if (curMdl == pLoopPacket->FirstMdl) {
                pLoopPacket->FirstMdl = nextMdl ;
            }
            else {
                prevMdl->Next = nextMdl ;
            }
            curMdl->Next = pIrp->MdlAddress ;
            pIrp->MdlAddress = curMdl ;
        }
        else {
            prevMdl = curMdl ;
        }
        curMdl = nextMdl ;
    }
}

VOID FreeMdlList
(
    PMDL    pMdl
)
{
    PMDL    NextMdl ;

    while ( pMdl ) {
        NextMdl = pMdl->Next ;
        MxUnlockMdl(pMdl);         
        IoFreeMdl ( pMdl ) ;
        pMdl = NextMdl ;
    }
}

VOID MxUnlockMdl
(
    PMDL    pMdl
)
{
    if (LOCKEDMDL(pMdl)) {
        MmUnlockPages(pMdl);
    }
}

NTSTATUS
GetRenderPos
(
    PFILTER_INSTANCE    pFilterInstance,
    PULONGLONG          pPos
)
{
    KSPROPERTY          PosProperty ;
    KSAUDIO_POSITION    Position ;
    NTSTATUS            Status ;
    ULONG               BytesReturned ;

    PosProperty.Set = KSPROPSETID_Audio ;
    PosProperty.Id = KSPROPERTY_AUDIO_POSITION ;
    PosProperty.Flags = KSPROPERTY_TYPE_GET ;


    Status = KsSynchronousIoControlDevice (
                   pFilterInstance->pNextFileObject,
                   KernelMode,
                   IOCTL_KS_PROPERTY,
                   &PosProperty,
                   sizeof (KSPROPERTY),
                   &Position,
                   sizeof (KSAUDIO_POSITION),
                   &BytesReturned ) ;

    if ( NT_SUCCESS(Status) ) {
        if ( BytesReturned != sizeof(KSAUDIO_POSITION) ) {
            Status = STATUS_INVALID_DEVICE_REQUEST ;
        }
        else {
            *pPos = Position.PlayOffset ;
        }
    }
    return ( Status ) ;
}

#ifdef DRM_KMIXER
//----------------------------------------------------------------------------
//
// DRM
//
//----------------------------------------------------------------------------

NTSTATUS DrmUpdateMixedContent
(
 IN PFILTER_INSTANCE pFilter
)
{
    PLIST_ENTRY		 ple;
    PMIXER_SINK_INSTANCE pMixerSink;
    ULONG		 NewMixedContentId;
    PULONG		 paContentId;
    int			 cPins;
    NTSTATUS	         Status;

    // !!!Note, we must not fail if DrmForwardContent succeeds!!!
    // Assumes pFilter->ControlMutex is owned

    // Create new ID for mixed content
    //  - walk through sink connections, build an array of DRM content IDs
    //  - pass this array to DRM to create a new mixed content ID
    cPins = 0;
    for (ple = pFilter->SinkConnectionList.Flink;
         ple != &pFilter->SinkConnectionList;
         ple = ple->Flink)
    {
        cPins++;
    }

    if (cPins > 0) {
        paContentId = ExAllocatePoolWithTag(NonPagedPool, cPins * sizeof(*paContentId), 'XIMK');
        Status = paContentId ? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES;
    } else {
        paContentId = NULL;
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        int cDrmPins = 0;
        for (ple = pFilter->SinkConnectionList.Flink;
             ple != &pFilter->SinkConnectionList;
            ple = ple->Flink)
        {
            pMixerSink = (PMIXER_SINK_INSTANCE)CONTAINING_RECORD(ple, MIXER_INSTHDR, NextInstance);
            ASSERT(cDrmPins < cPins);
            if (0 != pMixerSink->DrmContentId) {
                paContentId[cDrmPins++] = pMixerSink->DrmContentId;
            }
        }
        ASSERT(cDrmPins <= cPins);

        if (cDrmPins > 0) {
            Status = DrmCreateContentMixed(paContentId, cDrmPins, &NewMixedContentId);
        } else {
            NewMixedContentId = 0;
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status))
        {
            ASSERT(pFilter->pNextFileObject);
    
            // If the old or new ID is not zero then forward the new mixed
            // content ID to downstream filter
            if (0 != pFilter->DrmMixedContentId || 0 != NewMixedContentId) {
            	DRMFORWARD DrmForward;

            	DrmForward.Flags = 0;
            	DrmForward.DeviceObject = pFilter->pNextDevice;
            	DrmForward.FileObject = pFilter->pNextFileObject;
            	DrmForward.Context = (PVOID)pFilter->pNextFileObject;
            	
            	Status = DrmForwardContentToDeviceObject(NewMixedContentId, NULL, &DrmForward);
            }
    
            if (NT_SUCCESS(Status))
            {
                // Destroy previous mixed content ID, if we had one
                if (0 != pFilter->DrmMixedContentId) {
                    NTSTATUS s;
                    s = DrmDestroyContent(pFilter->DrmMixedContentId);
                    ASSERT(NT_SUCCESS(s));
                }
                // Save new mixed content ID
                pFilter->DrmMixedContentId = NewMixedContentId;
            } else {
                if (0 != NewMixedContentId) {
                    NTSTATUS s;
                    // The new mixed content could not be forwarded. Destroy it since
                    // we're not going to use it.
                    s = DrmDestroyContent(NewMixedContentId);
                    ASSERT(NT_SUCCESS(s));
                }
            }

        }

        if (paContentId) ExFreePool(paContentId);
    }

    return Status;
}

NTSTATUS DrmAudioStream_SetContentId
(
 IN PIRP		pIrp,
 IN PKSPROPERTY	pProperty,
 IN PVOID		pvData
)
{
    PIO_STACK_LOCATION		pIrpStack;
    PMIXER_INSTHDR              pHeader;
    PFILTER_INSTANCE		pFilterInstance;
    NTSTATUS			Status;
    
    if ( pIrp->RequestorMode != KernelMode ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pHeader = (PMIXER_INSTHDR)pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE)pHeader->pFilterFileObject->FsContext;
    
    Status = KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     NULL ) ;
    ASSERT(NT_SUCCESS(Status));
    
    if (pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        PMIXER_SINK_INSTANCE    pMixerSink;
        ULONG                   DrmContentIdOld;

        pMixerSink = (PMIXER_SINK_INSTANCE)pHeader;
    
        // Store the content ID entering this pin, but save the old
        // content ID in case we need to restore it due to error
        DrmContentIdOld = pMixerSink->DrmContentId;
        pMixerSink->DrmContentId = *(PULONG)pvData;
    
        // If we were interested in the actual rights settings, we would
        //  get them like this:
        // DrmRights = *(PDRMRIGHTS)(((PULONG)pvData) + 1);

        Status = DrmUpdateMixedContent(pFilterInstance);
    
        // If SetContentId fails, we must restore the old content ID
        if (!NT_SUCCESS(Status)) pMixerSink->DrmContentId = DrmContentIdOld;
    
    } else {
        // Pin was not type PIN_ID_WAVEOUT_SINK
        Status = STATUS_PROPSET_NOT_FOUND;
    }

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    
    return Status;
}
#endif

NTSTATUS
GetRenderState
(
    PFILTER_INSTANCE    pFilterInstance,
    PKSSTATE            pState
)
{
    KSPROPERTY          PosProperty ;
    NTSTATUS            Status ;
    ULONG               BytesReturned ;

    PosProperty.Set = KSPROPSETID_Connection ;
    PosProperty.Id = KSPROPERTY_CONNECTION_STATE ;
    PosProperty.Flags = KSPROPERTY_TYPE_GET ;


    Status = KsSynchronousIoControlDevice (
                   pFilterInstance->pNextFileObject,
                   KernelMode,
                   IOCTL_KS_PROPERTY,
                   &PosProperty,
                   sizeof (KSPROPERTY),
                   pState,
                   sizeof (KSSTATE),
                   &BytesReturned ) ;

    if ( NT_SUCCESS(Status) && BytesReturned != sizeof(KSSTATE) ) {
        Status = STATUS_INVALID_DEVICE_REQUEST ;
    }
    return ( Status ) ;
}


//---------------------------------------------------------------------------
//  End of File: pins.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rfcvec.inl ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rfcrcvec.inl

Abstract:

    This includes the inline functions 
    for the real float circular vector

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/


#if !defined(RFCVEC_INLINE)
#define RFCVEC_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !DBG
#define INLINE __forceinline
#else // DBG
#define INLINE
#endif // DBG

// ---------------------------------------------------------------------------
// Real FLOAT circular vector


// "Regular" constructor
INLINE NTSTATUS RfcVecCreate
( 
    IN PRFCVEC* Vec,
    IN UINT  Size,  
    IN BOOL  Initialize,
    IN FLOAT InitValue
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ASSERT(Size > 0);

    *Vec = ExAllocatePoolWithTag( PagedPool, Size*sizeof(FLOAT), 'XIMK');

    if (*Vec) {
        RfcVecFullInit(*Vec, Size, InitValue);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(Status);
}

// Destructor
INLINE VOID RfcVecDestroy
(
    PRFCVEC Vec
)
{
    if (Vec) {
        if(Vec->Start) {
            ExFreePool(Vec->Start);
        }
        Vec->Start = NULL;
        ExFreePool(Vec);
    }
}

// Get buffer size
INLINE UINT RfcVecGetSize
(
    PRFCVEC Vec
) 
{

    return (UINT)((Vec->End - Vec->Start) + 1);
}

// Read item LIFO, advance buffer pointer, wrap around if necessary
INLINE FLOAT RfcVecLIFORead
(
    PRFCVEC Vec
)
{
    return RfcVecPreviousRead(Vec);
}

// Read item FIFO, advance buffer pointer, wrap around if necessary
INLINE FLOAT RfcVecFIFORead
(
    PRFCVEC Vec
)
{
    return RfcVecReadNext(Vec);
}

// Write item, advance buffer pointer, wrap around if necessary
INLINE VOID RfcVecWrite
( 
    PRFCVEC Vec,
    FLOAT Value
)
{
    RfcVecWriteNext(Vec, Value);
}

// Read item from current buffer position (decremented before item was read)
INLINE FLOAT RfcVecPreviousRead
(
    PRFCVEC Vec
)
{
//    CHECK_POINTER(Vec->Index);

    RfcVecLIFONext(Vec);
    return *Vec->Index;
}

// Read item from current buffer position (decremented before item was read)
INLINE FLOAT RfcVecReadNext
(
    PRFCVEC Vec
)
{
    FLOAT Value;

    ASSERT(Vec->Index);

    Value = *(Vec->Index);
    RfcVecFIFONext(Vec);
    return Value;
}

// Write item to current buffer position (incremented after item is written)
INLINE VOID RfcVecWriteNext
( 
    PRFCVEC Vec,
    FLOAT Value
)
{
    ASSERT(Vec->Index);

    *Vec->Index = Value;
    RfcVecSkipForward(Vec);
}

// Increments current buffer position by one, wraps around if necessary
INLINE VOID RfcVecFIFONext
(
    PRFCVEC Vec
)
{
    // Wrap around if necessary
    if (++Vec->Index > Vec->End)
        Vec->Index = Vec->Start;
}

// Skip forward one element
INLINE VOID RfcVecSkipForward
(
    PRFCVEC Vec
)
{
    RfcVecFIFONext(Vec);
}

// Decrements current buffer position by one, wraps around if necessary
INLINE VOID RfcVecLIFONext
(
    PRFCVEC Vec
)
{

    // Wrap around if necessary
    if (--Vec->Index < Vec->Start)
        Vec->Index = Vec->End;
}

// Skip back one element
INLINE VOID RfcVecSkipBack
(
    PRFCVEC Vec
)
{
    RfcVecLIFONext(Vec);
}

// Get current index
INLINE UINT RfcVecGetIndex
(
    PRFCVEC Vec
) 
{

    return (UINT)(Vec->Index - Vec->Start);
}

// Set current index
INLINE VOID RfcVecSetIndex
( 
    PRFCVEC Vec,
    UINT Index
)
{
    ASSERT(Index < RfcVecGetSize(Vec));

    Vec->Index = Vec->Start + Index;
}

// Set end pointer
INLINE VOID RfcVecSetEndPointer
( 
    PRFCVEC Vec,
    UINT Size
)
{
    Vec->End = Vec->Start + Size - 1;
}

// Fill with contents from other buffer, 
// updating indices but not touching lengths (LIFO)
INLINE VOID RfcVecLIFOFill
(
    PRFCVEC Vec,
    PRFCVEC rhs
)
{

//    RfcVecWriteLoop(Vec, rhs, RfcVecLIFORead);
}

// Fill with contents from other buffer, 
// updating indices but not touching lengths (FIFO)
INLINE VOID RfcVecFIFOFill
(
    PRFCVEC Vec,
    PRFCVEC rhs
)
{

//    RfcVecWriteLoop(Vec, rhs, RfcVecFIFORead);
}

#endif

// End of RFCVEC.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rfiir.inl ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rfiir.inl

Abstract:


Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/


#if !defined(FLOATIIR_INLINE)
#define FLOATIIR_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !DBG
#define INLINE __forceinline
#else // DBG
#define INLINE
#endif // DBG

// ---------------------------------------------------------------------------
// Floating-point canonical form IIR filter

// Set maximum number of A coefficients
INLINE NTSTATUS RfIirSetMaxCoeffsA
( 
    PRFIIR Iir, 
    UINT MaxCoeffs
)
{
    ASSERT(MaxCoeffs <= MaxCanonicalCoeffs);

    return(RfIirAssignMaxCoeffs(Iir, MaxCoeffs, tagCanonicalA));
}

// Set maximum number of B coefficients
INLINE NTSTATUS RfIirSetMaxCoeffsB
( 
    PRFIIR Iir,
    UINT MaxCoeffs
)
{
    ASSERT(MaxCoeffs > 0);
    ASSERT(MaxCoeffs <= MaxCanonicalCoeffs);

    return(RfIirAssignMaxCoeffs(Iir, MaxCoeffs, tagCanonicalB));
}

// Set A coefficients
INLINE NTSTATUS RfIirSetCoeffsA
( 
    PRFIIR  Iir,
    PFLOAT  Coeffs,  
    UINT    NumCoeffs
)
{
#if DBG
    ASSERT(NumCoeffs <= MaxCanonicalCoeffs);
    if (NumCoeffs > 0)
        ASSERT(Coeffs);
#endif // DBG

    return(RfIirAssignCoeffs(Iir, Coeffs, NumCoeffs, tagCanonicalA, TRUE));
}

// Set B coefficients
INLINE NTSTATUS RfIirSetCoeffsB
( 
    PRFIIR  Iir,
    PFLOAT  Coeffs,  
    UINT NumCoeffs
)
{
    ASSERT(Coeffs);
    ASSERT(NumCoeffs > 0);
    ASSERT(NumCoeffs <= MaxCanonicalCoeffs);

    return(RfIirAssignCoeffs(Iir, Coeffs, NumCoeffs, tagCanonicalB, TRUE));
}

INLINE VOID IsValidFloatCoef
(
    FLOAT   Coef,
    BOOL    Stop
)  
{
    if((MIN_VALID_COEF>Coef) || (Coef>MAX_VALID_COEF)) { 
        _DbgPrintF( DEBUGLVL_TERSE, ("Coef = %d.%d\n", FpUpper(Coef),FpLower(Coef)) ); 
    }

    if(Stop)
    { 
        ASSERT((MIN_VALID_COEF<=Coef) && (Coef<=MAX_VALID_COEF)); 
    }
}

INLINE VOID IsValidFloatData
(
    FLOAT   Data,
    BOOL    Stop
)  
{
    if((MIN_VALID_DATA>Data) || (Data>MAX_VALID_DATA)) { 
        _DbgPrintF( DEBUGLVL_TERSE, ("Data = %d.%d\n", FpUpper(Data),FpLower(Data)) ); 
    }

    if(Stop)
    {
        ASSERT((MIN_VALID_DATA<=Data) && (Data<=MAX_VALID_DATA)); 
    }
}


#endif

// End of FLOATIIR.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rfiir.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rfiir.h

Abstract:

    This is the header for the real, FLOAT IIR filter 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(PFLOATIIR_HEADER)
#define PFLOATIIR_HEADER
#pragma once

// Project-specific INCLUDEs
//#include "dsplib.h"
#include "vmaxhead.h"

// ---------------------------------------------------------------------------
// Enumerations

// Canonical coefficient types
typedef enum {
    tagCanonicalB,
    tagCanonicalA,
    ecanonicalcoefftypeCount
} ECanonicalCoeffType;

// ---------------------------------------------------------------------------
// Pre-Declarations

typedef struct _RFIIR *PRFIIR;

// ---------------------------------------------------------------------------
// Defines




#define NumBiquadsToNumCanonicalCoeffs(expr) (4 * expr + 1)
#define NumBiquadsToNumCanonicalCoeffsHalf(expr) (2 * expr + 1)

#define MaxCanonicalCoeffs NumBiquadsToNumCanonicalCoeffs(MAX_BIQUADS)  

#define MAX_VALID_DATA  32768.0f
#define MIN_VALID_DATA  -MAX_VALID_DATA
#define MAX_VALID_COEF  100.0f
#define MIN_VALID_COEF  -MAX_VALID_COEF


// ---------------------------------------------------------------------------
// Floating-point canonical form IIR filter state

typedef struct _FLOAT_IIR_STATE {
    UINT  NumCoeffs[ecanonicalcoefftypeCount];
    FLOAT Coeffs[ecanonicalcoefftypeCount][MaxCanonicalCoeffs];
    FLOAT Buffer[ecanonicalcoefftypeCount][MaxCanonicalCoeffs];
} FLOAT_IIR_STATE, *PFLOAT_IIR_STATE;

typedef VOID (*PFNFloatFilter)(
    PRFIIR  Iir,
    PFLOAT InData, 
    PFLOAT OutData, 
    UINT   NumSamples
);

typedef struct _RFIIR {
    PFLOAT_IIR_STATE    IirStateOld;
    PRFCVEC             CircVec[ecanonicalcoefftypeCount];
    PFLOAT              Coeffs[ecanonicalcoefftypeCount];
    UINT                MaxCoeffs[ecanonicalcoefftypeCount];
    UINT                NumCoeffs[ecanonicalcoefftypeCount];
    BOOL                DoOverlap;
    PFNFloatFilter      FunctionFilter;
    UINT                NumFloat[ecanonicalcoefftypeCount];
    PFLOAT              FloatVector[ecanonicalcoefftypeCount];
} RFIIR, *PRFIIR;

// ---------------------------------------------------------------------------
// Floating-point canonical form IIR filter

NTSTATUS RfIirCreate(PRFIIR*);
VOID RfIirDestroy(PRFIIR);
    
VOID RfIirInitTapDelayLine(PFLOAT_IIR_STATE, FLOAT);
NTSTATUS RfIirSetMaxCoeffsA(PRFIIR, UINT);
NTSTATUS RfIirSetMaxCoeffsB(PRFIIR, UINT);
NTSTATUS RfIirSetCoeffs(PRFIIR, PFLOAT, UINT, BOOL);
NTSTATUS RfIirSetCoeffsA(PRFIIR, PFLOAT, UINT);
NTSTATUS RfIirSetCoeffsB(PRFIIR, PFLOAT, UINT);
VOID RfIirGetAllState(PRFIIR, PFLOAT_IIR_STATE, BOOL);
VOID RfIirGetState(PRFIIR, PFLOAT_IIR_STATE, ECanonicalCoeffType, BOOL);
NTSTATUS RfIirSetState(PRFIIR, PFLOAT_IIR_STATE, BOOL);
NTSTATUS RfIirInitData(PRFIIR, ULONG, ULONG, KSDS3D_HRTF_FILTER_QUALITY);
NTSTATUS RfIirInitBCoeffs(PRFIIR);
NTSTATUS RfIirAssignCoeffs(PRFIIR, PFLOAT, UINT, ECanonicalCoeffType, BOOL);
NTSTATUS RfIirAssignMaxCoeffs(PRFIIR, UINT, ECanonicalCoeffType);
VOID RfIirFilterC(PRFIIR, PFLOAT, PFLOAT, UINT);
VOID RfIirFilterShelfC(PRFIIR, PFLOAT, PFLOAT, UINT);
VOID RfIirFilterBiquadC(PRFIIR, PFLOAT, PFLOAT, UINT);
VOID IsValidFloatCoef(FLOAT,BOOL);
VOID IsValidFloatData(FLOAT,BOOL);



// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

#if !DBG
#include "rfiir.inl"
#endif // DBG

#endif // PFLOATIIR_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rfiir.c ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rfiir.c

Abstract:

    This module implements the real FLOAT
    infinite impulse filter 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

// Project-specific INCLUDEs
#include "common.h"

// ---------------------------------------------------------------------------
// Constants

#define SizeOfFloat sizeof(FLOAT)
#define NumCoeffsAInit 0
#define NumCoeffsBInit 1
#define CoeffsBInit 0.25f
#define CircVecInit 0.0f
#define MaxCanonicalCoeffMagnitude 50.0f

// ---------------------------------------------------------------------------
// Floating-point canonical form IIR filter

VOID RfIirInitTapDelayLine
(
    PFLOAT_IIR_STATE IirState, 
    FLOAT            InitialSample
)
{
    UINT    numCoeffsA;
    UINT    numCoeffsB;
    UINT    coeff;
    FLOAT   numeratorSum;
    FLOAT   denominatorSum;
    PFLOAT  pCoeffs;
    PFLOAT  pBuffer;
    FLOAT   factor;

    ASSERT(IirState);

    // Calculate the sum of the numerator coefficients
    numeratorSum = 0.0f;
    pCoeffs = &(IirState->Coeffs[tagCanonicalB][0]); 
    numCoeffsB = IirState->NumCoeffs[tagCanonicalB];
    for (coeff=0; coeff<numCoeffsB; coeff++) {
        numeratorSum += *pCoeffs;        
        pCoeffs++;
    }

    // Calculate the sum of the denominator coefficients
    denominatorSum = 0.0f;
    pCoeffs = &(IirState->Coeffs[tagCanonicalA][0]); 
    numCoeffsA = IirState->NumCoeffs[tagCanonicalA];
    for (coeff=0; coeff<numCoeffsA; coeff++) {
        denominatorSum += *pCoeffs;        
        pCoeffs++;
    }

    // Initialize the numerator tap delay line
    pBuffer = &(IirState->Buffer[tagCanonicalB][0]); 
    for (coeff=0; coeff<numCoeffsB; coeff++) {
        *pBuffer = InitialSample;
        pBuffer++;
    }

    // Initialize the denominator tap delay line
    factor = InitialSample * numeratorSum / (1 + denominatorSum);

    pBuffer = &(IirState->Buffer[tagCanonicalA][0]); 
    for (coeff=0; coeff<numCoeffsA; coeff++) {
        *pBuffer = factor;
        pBuffer++;
    }

}


// Constructor with same number of A and B coefficients
NTSTATUS RfIirCreate
(
    PRFIIR* ppRfIir
)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    *ppRfIir = ExAllocatePoolWithTag(PagedPool, sizeof(RFIIR), 'XIMK' );

    if(*ppRfIir) {
        RtlZeroMemory(*ppRfIir, sizeof(RFIIR)) ;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES; 
    }

    if(NT_SUCCESS(Status)) {
        (*ppRfIir)->IirStateOld = ExAllocatePoolWithTag(PagedPool, sizeof(FLOAT_IIR_STATE), 'XIMK');
    
        if((*ppRfIir)->IirStateOld) {
            RtlZeroMemory((*ppRfIir)->IirStateOld, sizeof(FLOAT_IIR_STATE)) ;
        } else {
            ExFreePool(*ppRfIir);
            *ppRfIir = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES; 
        }
    }

    return Status;
}

// Destructor
VOID RfIirDestroy
(
    PRFIIR Iir
)
{
    UINT ui;

    if (Iir) {
        if (Iir->IirStateOld) {
            ExFreePool(Iir->IirStateOld);
            Iir->IirStateOld = NULL;
        }

        for (ui=0; ui<ecanonicalcoefftypeCount; ++ui)
        {
            if (Iir->FloatVector[ui]) {
                ExFreePool(Iir->FloatVector[ui]);
                Iir->FloatVector[ui] = NULL;
            }
            Iir->NumFloat[ui] = 0;

            if (Iir->Coeffs[ui]) {
                ExFreePool(Iir->Coeffs[ui]);
                Iir->Coeffs[ui] = NULL;
            }
            if (Iir->CircVec[ui]) {
                RfcVecDestroy(Iir->CircVec[ui]);
                Iir->CircVec[ui] = NULL;
            }
        }
        ExFreePool(Iir);
    }
}

// Set coefficients
NTSTATUS RfIirSetCoeffs
(
    PRFIIR Iir,
    PFLOAT Coeffs, 
    UINT NumCoeffs,
    BOOL DoOverlap
)
{
    UINT        NumCoeffsHalf;
    NTSTATUS    Status;

    ASSERT(Iir);
    ASSERT(Coeffs);
    ASSERT(NumCoeffs > 0);
    ASSERT((NumCoeffs & 1) != 0);
    ASSERT(NumCoeffs <= MaxCanonicalCoeffs);

    Iir->DoOverlap = DoOverlap;

    NumCoeffsHalf = (NumCoeffs + 1) / 2;
    Status = RfIirSetCoeffsB(Iir, Coeffs, NumCoeffsHalf);

    if(NT_SUCCESS(Status)){
        Status = RfIirSetCoeffsA(Iir, Coeffs + NumCoeffsHalf, NumCoeffsHalf - 1);
    }

    /*
    if(NT_SUCCESS(Status)){
        if(3 == NumCoeffs) {
            Iir->FunctionFilter = RfIirFilterShelfC;
        }
        else if(5 == NumCoeffs) {
            Iir->FunctionFilter = RfIirFilterBiquadC;
        }
        else {
            Iir->FunctionFilter = RfIirFilterC;
        }
    }
    */

    return Status;
}


#if 1 // {
// Filter a block of samples
VOID RfIirFilterC
(
    PRFIIR  Iir,
    PFLOAT InData, 
    PFLOAT OutData, 
    UINT   NumSamples
)
{
    FLOAT Accumulator;
    FLOAT Data;
    PFLOAT Coef;
    UINT  Sample;
    UINT  st, ui;
    
    ASSERT(Iir);
    ASSERT(InData);
    ASSERT(OutData);

    /*  Allocate the floating point vectors.
     */
    for (ui=0; ui<ecanonicalcoefftypeCount; ++ui) {
        if (NumSamples > Iir->NumFloat[ui])
        {
            Iir->NumFloat[ui] = NumSamples; // Overwrite if necessary.

            if (Iir->FloatVector[ui])
                ExFreePool(Iir->FloatVector[ui]);

            Iir->FloatVector[ui] = ExAllocatePoolWithTag
                (PagedPool, (NumSamples+20+Iir->NumCoeffs[ui])*sizeof(FLOAT), 'XIMK');
            if(!Iir->FloatVector[ui]) {
                Iir->NumFloat[ui] = 0;
            }
        }
    }

    /*  There is enough room.
     */
    if (Iir->FloatVector[tagCanonicalA] && Iir->FloatVector[tagCanonicalB])
    {
        PFLOAT  pReadA, pWriteA, pReadB, pWriteB, pCoefA, pCoefB;
        INT     iCoefA, iCoefB, cnt;

        /*  Load up the coefficients.
         */
        pWriteA = Iir->FloatVector[tagCanonicalA] + NumSamples + 10;
        pWriteB = Iir->FloatVector[tagCanonicalB] + NumSamples + 10;

        pCoefA = Iir->Coeffs[tagCanonicalA];
        pCoefB = Iir->Coeffs[tagCanonicalB];

        cnt      = Iir->NumCoeffs[tagCanonicalA];
        pReadA   = pWriteA + cnt;
        pCoefA  += cnt;
        iCoefA   = - cnt;

        for (Coef = pWriteA; cnt > 0; --cnt)
            *Coef++ = RfcVecLIFORead(Iir->CircVec[tagCanonicalA]);

        cnt      = Iir->NumCoeffs[tagCanonicalB];
        pReadB   = pWriteB + cnt;
        pCoefB  += cnt;
        iCoefB   = - cnt;

        for (Coef = pWriteB + 1; cnt > 0; --cnt)
            *Coef++ = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]);

        ASSERT(iCoefA > -30);
        ASSERT(iCoefB > -30);

#ifdef _X86_ // {
#if 0 // {
#define COEF(addsub, x)	\
/*Coef_x:*/ \
	_asm { fld		DWORD PTR [ecx - (4 * x)]    }; \
	_asm { fmul	    DWORD PTR [edx - (4 * x)]    }; \
	_asm { addsub	st(1), st(0)       }; 
{
        static FLOAT Zero = 0.0f;

		DWORD CoefADist, CoefBDist;

		InData  += NumSamples;
		OutData += NumSamples;
    
        _asm {
            mov     eax, NumSamples
            neg     eax
            je      Done
    
            lea     esi, CoefB_29
            lea     edi, CoefB_30
            sub     esi, edi

			mov		ebx, iCoefA
			add		ebx, 30
			imul	ebx, esi
			lea		ecx, CoefA_30
			add		ebx, ecx
			mov		CoefADist, ebx

			mov		ebx, iCoefB
			add		ebx, 30
			imul	ebx, esi
			lea		ecx, CoefB_30
			add		ebx, ecx
			mov		CoefBDist, ebx

			mov		esi, pWriteA
            mov     edi, pWriteB

            //      esi, edi, eax used.  ebx, ecx, edx available.
Start:
            mov     ebx, InData
            mov     ecx, [ebx+eax*4]
            mov     [edi], ecx
            sub     edi, 4

            //  Start up floating point overlaps...

            mov     ecx, pCoefB
            
            fld     DWORD PTR Zero            // Acc
			mov		edx, pReadB
            jmp     CoefBDist
            }
CoefB_30:
			COEF(faddp, 30)
CoefB_29:
			COEF(faddp, 29)
			COEF(faddp, 28)
			COEF(faddp, 27)
			COEF(faddp, 26)
			COEF(faddp, 25)
			COEF(faddp, 24)
			COEF(faddp, 23)
			COEF(faddp, 22)
			COEF(faddp, 21)
			COEF(faddp, 20)
			COEF(faddp, 19)
			COEF(faddp, 18)
			COEF(faddp, 17)
			COEF(faddp, 16)
			COEF(faddp, 15)
			COEF(faddp, 14)
			COEF(faddp, 13)
			COEF(faddp, 12)
			COEF(faddp, 11)
			COEF(faddp, 10)
			COEF(faddp,  9)
			COEF(faddp,  8)
			COEF(faddp,  7)
			COEF(faddp,  6)
			COEF(faddp,  5)
			COEF(faddp,  4)
			COEF(faddp,  3)
			COEF(faddp,  2)
			COEF(faddp,  1)

        _asm {
			sub		edx, 4
			mov		pReadB, edx

			//	Now do iCoefA

			mov		edx, iCoefA
			test	edx, edx
			je		Store

            //  Start up floating point overlaps...

            mov     ecx, pCoefA
            
			mov		edx, pReadA
            jmp     CoefADist
            }

CoefA_30:
			COEF(fsubp, 30)
			COEF(fsubp, 29)
			COEF(fsubp, 28)
			COEF(fsubp, 27)
			COEF(fsubp, 26)
			COEF(fsubp, 25)
			COEF(fsubp, 24)
			COEF(fsubp, 23)
			COEF(fsubp, 22)
			COEF(fsubp, 21)
			COEF(fsubp, 20)
			COEF(fsubp, 19)
			COEF(fsubp, 18)
			COEF(fsubp, 17)
			COEF(fsubp, 16)
			COEF(fsubp, 15)
			COEF(fsubp, 14)
			COEF(fsubp, 13)
			COEF(fsubp, 12)
			COEF(fsubp, 11)
			COEF(fsubp, 10)
			COEF(fsubp,  9)
			COEF(fsubp,  8)
			COEF(fsubp,  7)
			COEF(fsubp,  6)
			COEF(fsubp,  5)
			COEF(fsubp,  4)
			COEF(fsubp,  3)
			COEF(fsubp,  2)
			COEF(fsubp,  1)

        _asm {
			sub		esi, 4
			fst		DWORD PTR [esi]       // Acc

			sub		edx, 4
			mov		pReadA, edx
Store:
			mov		ebx, OutData
            fstp    DWORD PTR [ebx+eax*4] // Empty
            inc     eax
            jl      Start

			mov		pWriteA, esi
            mov     pWriteB, edi
Done:
        }
    }
#else // }{
#define COEF(addsub, x)	\
/*Coef_x:*/ \
	_asm { fmul	    DWORD PTR [edx - (4 * x)]    }; \
	_asm { fxch	    st(2)			   }; \
	_asm { addsub	st(1), st(0)       }; \
	_asm { fld		DWORD PTR [ecx - (4 * (x-1))]};
{
        static FLOAT Zero = 0.0f;

		DWORD CoefADist, CoefASkip, CoefBDist;

        ASSERT(iCoefB);     // It must be non-zero, otherwise a check is needed.

		InData  += NumSamples;
		OutData += NumSamples;
    
        _asm {
            mov     eax, NumSamples
            neg     eax
            je      Done
    
            lea     esi, CoefB_29
            lea     edi, CoefB_30
            sub     esi, edi

			mov		ebx, iCoefA
            test    ebx, ebx
            lea     ecx, Store
            je      NoCoefA
            lea     ecx, CoefA
NoCoefA:
            mov     CoefASkip, ecx
			add		ebx, 30
			imul	ebx, esi
			lea		ecx, CoefA_30
			add		ebx, ecx
			mov		CoefADist, ebx

			mov		ebx, iCoefB
			add		ebx, 30
			imul	ebx, esi
			lea		ecx, CoefB_30
			add		ebx, ecx
			mov		CoefBDist, ebx

			mov		esi, pWriteA
            mov     edi, pWriteB

            //      esi, edi, eax used.  ebx, ecx, edx available.
Start:
            mov     ebx, InData
            sub     edi, 4

            mov     ecx, [ebx+eax*4]
			mov		edx, iCoefB

            mov     [edi+4], ecx
            mov     ecx, pCoefB

            //  Start up floating point overlaps...
            
            fld     DWORD PTR Zero            // Zero
            fld     DWORD PTR Zero            // Zero, Acc
			fld		DWORD PTR [ecx+edx*4]		// Zero, Acc, pCoefB[iCoefB]
			mov		edx, pReadB
            jmp     CoefBDist
            }

// i.e.		fmul	[edx-120]	// Zero, Acc, pCoefB[iCoefB]*pReadB[-30]
//			fxch	st(2)		// pCB[iCoefB]*pRB[-30], Acc, Zero
//			faddp	st(1), st(0)// pCB[iCoefB]*pRB[-30], Acc
//			fld		[ecx-116]	// pCB[iCoefB]*pRB[-30], Acc, pCB[-29]
CoefB_30:
			COEF(faddp, 30)
CoefB_29:
			COEF(faddp, 29)
			COEF(faddp, 28)
			COEF(faddp, 27)
			COEF(faddp, 26)
			COEF(faddp, 25)
			COEF(faddp, 24)
			COEF(faddp, 23)
			COEF(faddp, 22)
			COEF(faddp, 21)
			COEF(faddp, 20)
			COEF(faddp, 19)
			COEF(faddp, 18)
			COEF(faddp, 17)
			COEF(faddp, 16)
			COEF(faddp, 15)
			COEF(faddp, 14)
			COEF(faddp, 13)
			COEF(faddp, 12)
			COEF(faddp, 11)
			COEF(faddp, 10)
			COEF(faddp,  9)
			COEF(faddp,  8)
			COEF(faddp,  7)
			COEF(faddp,  6)
			COEF(faddp,  5)
			COEF(faddp,  4)
			COEF(faddp,  3)
			COEF(faddp,  2)

        _asm {
//CoefB_01:
			fmul	DWORD PTR [edx-4]		// Zero, Acc, pCB[-1]*pRB[-1]
			fxch	st(2)		// pCB[-1]*pRB[-1], Acc, Zero

			faddp	st(1), st(0)// pCB[-1]*pRB[-1], Acc
			sub		edx, 4

			faddp	st(1), st(0)// Acc
			mov		pReadB, edx

			//	Now do iCoefA

			mov		ebx, OutData
            jmp     CoefASkip
CoefA:

            //  Start up floating point overlaps...

            mov     ecx, pCoefA
			mov		edx, iCoefA
            
            fld     DWORD PTR Zero            // Acc, Zero
			fxch	st(1)

			fld		DWORD PTR [ecx+edx*4]		// Zero, Acc, pCoefA[iCoefA]
			mov		edx, pReadA

            jmp     CoefADist
            }

CoefA_30:
			COEF(fsubp, 30)
			COEF(fsubp, 29)
			COEF(fsubp, 28)
			COEF(fsubp, 27)
			COEF(fsubp, 26)
			COEF(fsubp, 25)
			COEF(fsubp, 24)
			COEF(fsubp, 23)
			COEF(fsubp, 22)
			COEF(fsubp, 21)
			COEF(fsubp, 20)
			COEF(fsubp, 19)
			COEF(fsubp, 18)
			COEF(fsubp, 17)
			COEF(fsubp, 16)
			COEF(fsubp, 15)
			COEF(fsubp, 14)
			COEF(fsubp, 13)
			COEF(fsubp, 12)
			COEF(fsubp, 11)
			COEF(fsubp, 10)
			COEF(fsubp,  9)
			COEF(fsubp,  8)
			COEF(fsubp,  7)
			COEF(fsubp,  6)
			COEF(fsubp,  5)
			COEF(fsubp,  4)
			COEF(fsubp,  3)
			COEF(fsubp,  2)

        _asm {
//CoefA_01:
			fmul	DWORD PTR [edx-4]		// Zero, Acc, pCA[-1]*pRA[-1]
			fxch	st(2)		// pCA[-1]*pRA[-1], Acc, Zero
			fsubp	st(1), st(0)// pCA[-1]*pRA[-1], Acc
			fsubrp	st(1), st(0)// Acc
//CoefA_00:
			sub		esi, 4
			sub		edx, 4

			fst		DWORD PTR [esi]       // Acc
			mov		pReadA, edx
Store:
            fstp    DWORD PTR [ebx+eax*4] // Empty
            inc     eax

            jl      Start

			mov		pWriteA, esi
            mov     pWriteB, edi
Done:
        }
    }
#endif // }
#else // }{
		InData  += NumSamples;
		OutData += NumSamples;
    
        for (Sample = 0 - NumSamples; (INT)Sample < 0; ++Sample)
        {
            static FLOAT Zero = 0.0;
            *pWriteB--  = InData[Sample];

            Accumulator = 0.0f;

#if 1 // {
            switch (iCoefB) {
                default:
                    for (cnt = iCoefB; cnt < -30; cnt++)
                    {
                        Accumulator += *(pCoefB + cnt) * *(pReadB + cnt) / Zero;
                    }
            
                case -30: Accumulator += *(pCoefB - 30) * *(pReadB - 30); 
                case -29: Accumulator += *(pCoefB - 29) * *(pReadB - 29); 
                case -28: Accumulator += *(pCoefB - 28) * *(pReadB - 28); 
                case -27: Accumulator += *(pCoefB - 27) * *(pReadB - 27); 
                case -26: Accumulator += *(pCoefB - 26) * *(pReadB - 26); 
                case -25: Accumulator += *(pCoefB - 25) * *(pReadB - 25); 
                case -24: Accumulator += *(pCoefB - 24) * *(pReadB - 24); 
                case -23: Accumulator += *(pCoefB - 23) * *(pReadB - 23); 
                case -22: Accumulator += *(pCoefB - 22) * *(pReadB - 22); 
                case -21: Accumulator += *(pCoefB - 21) * *(pReadB - 21); 
                case -20: Accumulator += *(pCoefB - 20) * *(pReadB - 20); 
                case -19: Accumulator += *(pCoefB - 19) * *(pReadB - 19); 
                case -18: Accumulator += *(pCoefB - 18) * *(pReadB - 18); 
                case -17: Accumulator += *(pCoefB - 17) * *(pReadB - 17); 
                case -16: Accumulator += *(pCoefB - 16) * *(pReadB - 16); 
                case -15: Accumulator += *(pCoefB - 15) * *(pReadB - 15); 
                case -14: Accumulator += *(pCoefB - 14) * *(pReadB - 14); 
                case -13: Accumulator += *(pCoefB - 13) * *(pReadB - 13); 
                case -12: Accumulator += *(pCoefB - 12) * *(pReadB - 12); 
                case -11: Accumulator += *(pCoefB - 11) * *(pReadB - 11); 
                case -10: Accumulator += *(pCoefB - 10) * *(pReadB - 10); 
                case - 9: Accumulator += *(pCoefB -  9) * *(pReadB -  9); 
                case - 8: Accumulator += *(pCoefB -  8) * *(pReadB -  8); 
                case - 7: Accumulator += *(pCoefB -  7) * *(pReadB -  7); 
                case - 6: Accumulator += *(pCoefB -  6) * *(pReadB -  6);
                case - 5: Accumulator += *(pCoefB -  5) * *(pReadB -  5);
                case - 4: Accumulator += *(pCoefB -  4) * *(pReadB -  4);
                case - 3: Accumulator += *(pCoefB -  3) * *(pReadB -  3);
                case - 2: Accumulator += *(pCoefB -  2) * *(pReadB -  2);
                case - 1: Accumulator += *(pCoefB -  1) * *(pReadB -  1);
                case   0: ;
            }
            pReadB--;

            if (iCoefA) 
                switch (iCoefA) {
                    default:
                        for (cnt = iCoefA; cnt < -30; cnt++)
                        {
                            Accumulator -= *(pCoefA + cnt) * *(pReadA + cnt) / Zero;
                        }
    
                    case -30: Accumulator -= *(pCoefA - 30) * *(pReadA - 30); 
                    case -29: Accumulator -= *(pCoefA - 29) * *(pReadA - 29); 
                    case -28: Accumulator -= *(pCoefA - 28) * *(pReadA - 28); 
                    case -27: Accumulator -= *(pCoefA - 27) * *(pReadA - 27); 
                    case -26: Accumulator -= *(pCoefA - 26) * *(pReadA - 26); 
                    case -25: Accumulator -= *(pCoefA - 25) * *(pReadA - 25); 
                    case -24: Accumulator -= *(pCoefA - 24) * *(pReadA - 24); 
                    case -23: Accumulator -= *(pCoefA - 23) * *(pReadA - 23); 
                    case -22: Accumulator -= *(pCoefA - 22) * *(pReadA - 22); 
                    case -21: Accumulator -= *(pCoefA - 21) * *(pReadA - 21); 
                    case -20: Accumulator -= *(pCoefA - 20) * *(pReadA - 20); 
                    case -19: Accumulator -= *(pCoefA - 19) * *(pReadA - 19); 
                    case -18: Accumulator -= *(pCoefA - 18) * *(pReadA - 18); 
                    case -17: Accumulator -= *(pCoefA - 17) * *(pReadA - 17); 
                    case -16: Accumulator -= *(pCoefA - 16) * *(pReadA - 16); 
                    case -15: Accumulator -= *(pCoefA - 15) * *(pReadA - 15); 
                    case -14: Accumulator -= *(pCoefA - 14) * *(pReadA - 14); 
                    case -13: Accumulator -= *(pCoefA - 13) * *(pReadA - 13); 
                    case -12: Accumulator -= *(pCoefA - 12) * *(pReadA - 12); 
                    case -11: Accumulator -= *(pCoefA - 11) * *(pReadA - 11); 
                    case -10: Accumulator -= *(pCoefA - 10) * *(pReadA - 10); 
                    case - 9: Accumulator -= *(pCoefA -  9) * *(pReadA -  9); 
                    case - 8: Accumulator -= *(pCoefA -  8) * *(pReadA -  8); 
                    case - 7: Accumulator -= *(pCoefA -  7) * *(pReadA -  7); 
                    case - 6: Accumulator -= *(pCoefA -  6) * *(pReadA -  6);
                    case - 5: Accumulator -= *(pCoefA -  5) * *(pReadA -  5);
                    case - 4: Accumulator -= *(pCoefA -  4) * *(pReadA -  4);
                    case - 3: Accumulator -= *(pCoefA -  3) * *(pReadA -  3);
                    case - 2: Accumulator -= *(pCoefA -  2) * *(pReadA -  2);
                    case - 1: Accumulator -= *(pCoefA -  1) * *(pReadA -  1);
    
                        *--pWriteA = Accumulator;
                         pReadA--;
    
                    case   0: ;
                    }
#else // }{
            for (cnt = iCoefB; cnt < 0; cnt++)
            {
                Accumulator += *(pCoefB + cnt) * *(pReadB + cnt);
            }
            pReadB--;
            
         	if (iCoefA) {
                for (cnt = iCoefA; cnt < 0; cnt++)
                {
                    Accumulator -= *(pCoefA + cnt) * *(pReadA + cnt);
                }
                *--pWriteA = Accumulator;
                pReadA--;
	        }
#endif // }

            OutData[Sample] = Accumulator;
        }
#endif // }

        /*  Write the coefficients back out.
         */
        for (cnt = - iCoefA; cnt > 0; cnt--)
            RfcVecWrite(Iir->CircVec[tagCanonicalA], *(pWriteA + cnt - 1));

        for (cnt = - iCoefB; cnt > 0; cnt--)
            RfcVecWrite(Iir->CircVec[tagCanonicalB], *(pWriteB + cnt));

        return;
    }

    /*  This is the OOM case now.
     */
    for (Sample=0; Sample<NumSamples; ++Sample) {

        // Write current value to the X buffer
        RfcVecWrite(Iir->CircVec[tagCanonicalB], InData[Sample]);

        // Accumulate X/b values
        Accumulator = 0.0f;

        Coef = Iir->Coeffs[tagCanonicalB];
        for (st=0; st<Iir->NumCoeffs[tagCanonicalB]; ++st)
        {
            Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]); 
            Accumulator += *Coef * Data;
            Coef++;
        }
        
        // Don't do zero-sized circular buffers
        Coef = Iir->Coeffs[tagCanonicalA];
        if (Iir->NumCoeffs[tagCanonicalA] > 0) {
            // Accumulate Y/a values
            for (st=0; st<Iir->NumCoeffs[tagCanonicalA]; ++st) 
            {
                Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalA]); 
                Accumulator -= *Coef * Data;
                Coef++;
            }

            // Write result to the Y buffer
            RfcVecWrite(Iir->CircVec[tagCanonicalA], Accumulator);
        }

        // Store output
        OutData[Sample] = Accumulator;
    }
}
#else // }{
// Filter a block of samples
VOID RfIirFilterC
(
    PRFIIR  Iir,
    PFLOAT InData, 
    PFLOAT OutData, 
    UINT   NumSamples
)
{
    FLOAT Accumulator;
    FLOAT Data;
    PFLOAT Coef;
    UINT  Sample;
    UINT  st;

    ASSERT(Iir);
    ASSERT(InData);
    ASSERT(OutData);

#if DBG && defined(VERIFY_HRTF_PROCESSING)
    _DbgPrintF( DEBUGLVL_VERBOSE, ("RfIirFilterC"));
#endif // DBG  and VERIFY_HRTF_PROCESSING
    for (Sample=0; Sample<NumSamples; ++Sample) {

        // Write current value to the X buffer
        RfcVecWrite(Iir->CircVec[tagCanonicalB], InData[Sample]);

        // Accumulate X/b values
        Accumulator = 0.0f;

        Coef = Iir->Coeffs[tagCanonicalB];
        for (st=0; st<Iir->NumCoeffs[tagCanonicalB]; ++st)
        {
            Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
            IsValidFloatCoef(*Coef,FALSE);
            IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING
            Accumulator += *Coef * Data;
            Coef++;
        }
        
        // Don't do zero-sized circular buffers
        Coef = Iir->Coeffs[tagCanonicalA];
        if (Iir->NumCoeffs[tagCanonicalA] > 0) {
            // Accumulate Y/a values
            for (st=0; st<Iir->NumCoeffs[tagCanonicalA]; ++st) 
            {
                Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalA]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
                IsValidFloatCoef(*Coef,FALSE);
                IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING
                Accumulator -= *Coef * Data;
                Coef++;
            }

            // Write result to the Y buffer
            RfcVecWrite(Iir->CircVec[tagCanonicalA], Accumulator);
        }

#if DBG
        // Timo included the saturation on the filter,
        // I (JS) think it should only be done at the output
        // for floating point. So we'll monitor overflow
        // for Debug only
        // Saturate to maximum
        if (Accumulator > MaxSaturation) {
            Accumulator = MaxSaturation;
            _DbgPrintF( DEBUGLVL_VERBOSE, 
                        ("Sample exceeded maximum saturation value\n"));
        }
        
        // Saturate to minimum
        if (Accumulator < MinSaturation) {
            Accumulator = MinSaturation;
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded minimum saturation value\n"));
        }
#endif // DBG

        // Store output
        OutData[Sample] = Accumulator;
    }
}
#endif // }

// Filter a block of samples
VOID RfIirFilterBiquadC
(
    PRFIIR  Iir,
    PFLOAT InData, 
    PFLOAT OutData, 
    UINT   NumSamples
)
{
    FLOAT Accumulator;
    FLOAT Data;
    PFLOAT Coef;
    UINT  Sample;
    UINT  st;

    ASSERT(Iir);
    ASSERT(InData);
    ASSERT(OutData);

    for (Sample=0; Sample<NumSamples; ++Sample) {

        // Write current value to the X buffer
        RfcVecWrite(Iir->CircVec[tagCanonicalB], InData[Sample]);

        // Accumulate X/b values
        Accumulator = 0.0f;

        // B0
        Coef = Iir->Coeffs[tagCanonicalB];
        Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
        IsValidFloatCoef(*Coef,FALSE);
        IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING
        Accumulator += *Coef * Data;
        
        // B1
        Coef++;
        Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
        IsValidFloatCoef(*Coef,FALSE);
        IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING
        Accumulator += *Coef * Data;

        // B2
        Coef++;
        Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
        IsValidFloatCoef(*Coef,FALSE);
        IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING
        Accumulator += *Coef * Data;


        if (Iir->NumCoeffs[tagCanonicalA] > 0) {
            // A1
            Coef = Iir->Coeffs[tagCanonicalA];
            Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalA]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
            IsValidFloatCoef(*Coef,FALSE);
            IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING
            Accumulator -= *Coef * Data;

            // A2
            Coef = Iir->Coeffs[tagCanonicalA];
            Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalA]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
            IsValidFloatCoef(*Coef,FALSE);
            IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING
            Accumulator -= *Coef * Data;

#if DBG && defined(VERIFY_HRTF_PROCESSING)
            IsValidFloatData(Accumulator,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

            // Write result to the Y buffer
            RfcVecWrite(Iir->CircVec[tagCanonicalA], Accumulator);
        }

#if DBG
        // Timo included the saturation on the filter,
        // I (JS) think it should only be done at the output
        // for floating point. So we'll monitor overflow
        // for Debug only

        // Saturate to maximum
        if (Accumulator > MaxSaturation) {
            Accumulator = MaxSaturation;
            _DbgPrintF( DEBUGLVL_VERBOSE, 
                        ("Sample exceeded maximum saturation value\n"));
        }
        
        // Saturate to minimum
        if (Accumulator < MinSaturation) {
            Accumulator = MinSaturation;
            _DbgPrintF( DEBUGLVL_VERBOSE, 
                        ("Sample exceeded minimum saturation value\n"));
        }
#endif // DBG 

        // Store output
        OutData[Sample] = Accumulator;
    }
}

// Filter a block of samples
VOID RfIirFilterShelfC
(
    PRFIIR  Iir,
    PFLOAT InData, 
    PFLOAT OutData, 
    UINT   NumSamples
)
{
    FLOAT Accumulator;
    FLOAT Data;
    PFLOAT Coef;
    UINT  Sample;
    UINT  st;

    ASSERT(Iir);
    ASSERT(InData);
    ASSERT(OutData);

    for (Sample=0; Sample<NumSamples; ++Sample) {

        // Write current value to the X buffer
        RfcVecWrite(Iir->CircVec[tagCanonicalB], InData[Sample]);

        // Accumulate X/b values
        Accumulator = 0.0f;

        // B0
        Coef = Iir->Coeffs[tagCanonicalB];
        Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
        IsValidFloatCoef(*Coef,FALSE);
        IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

        Accumulator += *Coef * Data;
        
        // B1
        Coef++;
        Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalB]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
        IsValidFloatCoef(*Coef,FALSE);
        IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

        Accumulator += *Coef * Data;

        // A1
        if (Iir->NumCoeffs[tagCanonicalA] > 0) {
            Coef = Iir->Coeffs[tagCanonicalA];
            Data = RfcVecLIFORead(Iir->CircVec[tagCanonicalA]); 
#if DBG && defined(VERIFY_HRTF_PROCESSING)
            IsValidFloatCoef(*Coef,FALSE);
            IsValidFloatData(Data,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

            Accumulator -= *Coef * Data;

#if DBG && defined(VERIFY_HRTF_PROCESSING)
            IsValidFloatData(Accumulator,FALSE);
#endif // DBG  and VERIFY_HRTF_PROCESSING


            // Write result to the Y buffer
            RfcVecWrite(Iir->CircVec[tagCanonicalA], Accumulator);
        }

#if DBG
        // Timo included the saturation on the filter,
        // I (JS) think it should only be done at the output
        // for floating point. So we'll monitor overflow
        // for Debug only

        // Saturate to maximum
        if (Accumulator > MaxSaturation) {
            Accumulator = MaxSaturation;
            _DbgPrintF( DEBUGLVL_VERBOSE, 
                        ("Sample exceeded maximum saturation value\n"));
        }
        
        // Saturate to minimum
        if (Accumulator < MinSaturation) {
            Accumulator = MinSaturation;
            _DbgPrintF( DEBUGLVL_VERBOSE, 
                        ("Sample exceeded minimum saturation value\n"));
        }
#endif // DBG 

        // Store output
        OutData[Sample] = Accumulator;
    }
}


// Get filter state
VOID RfIirGetAllState
(
    PRFIIR  Iir,
    PFLOAT_IIR_STATE IirState, 
    BOOL CopyCircVec
)
{
    UINT i;

    ASSERT(Iir);
    ASSERT(IirState);

    // Fill complete filter state structure
    for (i=0; i<ecanonicalcoefftypeCount; ++i) {
        RfIirGetState(Iir, IirState, (ECanonicalCoeffType)(i), CopyCircVec);
    }
}

// Get filter state
VOID RfIirGetState
(
    PRFIIR  Iir,
    PFLOAT_IIR_STATE IirState, 
    ECanonicalCoeffType CoeffType, 
    BOOL CopyCircVec
)
{
    UINT NumCoeffs;
    UINT st;
    
    ASSERT(Iir);
    ASSERT(IirState);
    ASSERT(CoeffType >= 0 && CoeffType < ecanonicalcoefftypeCount);
    
    // Copy number of coefficients
    NumCoeffs = Iir->NumCoeffs[CoeffType];

    ASSERT(NumCoeffs <= MaxCanonicalCoeffs);
    IirState->NumCoeffs[CoeffType] = NumCoeffs;
    
    if (NumCoeffs > 0) {
        // Copy coefficients
        ASSERT(IirState->Coeffs[CoeffType]);
        RtlCopyBytes
        (
            IirState->Coeffs[CoeffType], 
            Iir->Coeffs[CoeffType], 
            NumCoeffs * sizeof(FLOAT)
        );
    
        // Only copy circular vector if requested
        if (CopyCircVec == TRUE)
            for (st=0; st<NumCoeffs; ++st) {
//                ASSERT(fabs(IirState->Coeffs[CoeffType][st]) < MaxCanonicalCoeffMagnitude);
                IirState->Buffer[CoeffType][st] = RfcVecFIFORead(Iir->CircVec[CoeffType]);
            }
    }
}

// Set filter state
NTSTATUS RfIirSetState
(
    PRFIIR Iir,
    PFLOAT_IIR_STATE IirState, 
    BOOL CopyCircVec
)
{
    UINT CoeffType;
    UINT st;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Iir);
    ASSERT(IirState);

    for (CoeffType=0; CoeffType<ecanonicalcoefftypeCount; ++CoeffType) {
        // Update coefficients and possibly resize 
        // buffers from filter state structure
        Status = RfIirAssignCoeffs 
                 (
                     Iir,
                     &IirState->Coeffs[CoeffType][0], 
                     IirState->NumCoeffs[CoeffType], 
                     (ECanonicalCoeffType)(CoeffType), 
                     FALSE
                 );

        if(!NT_SUCCESS(Status)) {
            if(Iir->Coeffs[CoeffType]) {
                ExFreePool(Iir->Coeffs[CoeffType]);
                Iir->Coeffs[CoeffType] = NULL;
            }
            break;
        }


#if DBG
        // Make sure coefficient assignment has been successful
        ASSERT(IirState->NumCoeffs[CoeffType] == Iir->NumCoeffs[CoeffType]);
        ASSERT(IirState->NumCoeffs[CoeffType] <= MaxCanonicalCoeffs);
        if (Iir->NumCoeffs[CoeffType] > 0) {
            // Only check circular vector size if a circular vector exists
            ASSERT(RfcVecGetSize(Iir->CircVec[CoeffType]) == Iir->NumCoeffs[CoeffType]);
        } else {
            ASSERT(CoeffType == tagCanonicalA);
        }
#endif // DBG

        if (CopyCircVec == TRUE)
            // Check whether there are A coefficients and thus a circular vector exists and thus its contents need to be copied
            if (IirState->NumCoeffs[CoeffType] > 0)
                // Update circular vectors from filter state structure
                for (st=0; st<IirState->NumCoeffs[CoeffType]; ++st)
                    RfcVecWrite(Iir->CircVec[CoeffType], IirState->Buffer[CoeffType][st]);
#if DBG
            else
                ASSERT(CoeffType == tagCanonicalA);
#endif // DBG
    }

    return Status;
}

// Initialize data
NTSTATUS RfIirInitData
(
    PRFIIR Iir,
    ULONG  MaxNumOrder,
    ULONG  MaxDenOrder,
    KSDS3D_HRTF_FILTER_QUALITY Quality
)
{
    UINT Type;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Iir);


    
    if(FULL_FILTER == Quality)
    {
        Iir->FunctionFilter = RfIirFilterC;
    }
    else if(LIGHT_FILTER == Quality)
    {
        Iir->FunctionFilter = RfIirFilterC;
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
    }
   
    if(NT_SUCCESS(Status)) {
        // Initialize numerator coefficients with reasonable value
        if((Iir->MaxCoeffs[tagCanonicalB] < MaxNumOrder) || !Iir->Coeffs[tagCanonicalB])
        {
            if(Iir->Coeffs[tagCanonicalB])
                ExFreePool(Iir->Coeffs[tagCanonicalB]);
                
            Iir->Coeffs[tagCanonicalB] = ExAllocatePoolWithTag(PagedPool, (MaxNumOrder+1)*sizeof(FLOAT), 'XIMK');
            if(!Iir->Coeffs[tagCanonicalB]) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }


    if(NT_SUCCESS(Status)) {
        if(Iir->CircVec[tagCanonicalB])
            RfcVecDestroy(Iir->CircVec[tagCanonicalB]);
            
        Status = 
            RfcVecCreate
            (
                &(Iir->CircVec[tagCanonicalB]), 
                MaxNumOrder+1, 
                TRUE, 
                0.0f
            );
    }

    if(NT_SUCCESS(Status)) {
        Status = RfIirInitBCoeffs(Iir);
    }

    if(NT_SUCCESS(Status)) {
        Status = RfcVecSetSize(Iir->CircVec[tagCanonicalB], NumCoeffsBInit, 0.0f);
    }
    
    if(NT_SUCCESS(Status)) {
        if((Iir->MaxCoeffs[tagCanonicalA] < MaxDenOrder) || !Iir->Coeffs[tagCanonicalA])
        {
            if(Iir->Coeffs[tagCanonicalA])
                ExFreePool(Iir->Coeffs[tagCanonicalA]);
                
            // Initialize denominator coefficients with reasonable value
            Iir->Coeffs[tagCanonicalA] = ExAllocatePoolWithTag(PagedPool, (MaxDenOrder+1)*sizeof(FLOAT), 'XIMK');
            if(!Iir->Coeffs[tagCanonicalA]) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if(NT_SUCCESS(Status)) {
        Iir->DoOverlap = FALSE;
        Iir->MaxCoeffs[tagCanonicalB] = MaxNumOrder;
        Iir->MaxCoeffs[tagCanonicalA] = MaxDenOrder;
    }

    if(NT_SUCCESS(Status)) {
        Iir->NumCoeffs[tagCanonicalA] = NumCoeffsAInit;

        if(Iir->CircVec[tagCanonicalA])
            ExFreePool(Iir->CircVec[tagCanonicalA]);
            
        Status = 
            RfcVecCreate
            (
                &(Iir->CircVec[tagCanonicalA]), 
                MaxDenOrder+1, 
                TRUE, 
                0.0f
            );
    }

    if(NT_SUCCESS(Status)) {

        RfcVecReset(Iir->CircVec[tagCanonicalA]);

        // Initialize state
        RfIirGetAllState(Iir, Iir->IirStateOld, TRUE);
    }

    /*  Create a default size for the FloatVector sizes,
     *  in case there are allocation problems down the road.
     */
    if (NT_SUCCESS(Status)) {
        if(Iir->FloatVector[tagCanonicalA])
            ExFreePool(Iir->FloatVector[tagCanonicalA]);
            
        Iir->FloatVector[tagCanonicalA] = ExAllocatePoolWithTag
            (PagedPool, (500+20+Iir->NumCoeffs[tagCanonicalA])*sizeof(FLOAT), 'XIMK');
        if(!Iir->Coeffs[tagCanonicalA]) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else Iir->NumFloat[tagCanonicalA] = 500;
    }
    if (NT_SUCCESS(Status)) {
        if(Iir->FloatVector[tagCanonicalB])
            ExFreePool(Iir->FloatVector[tagCanonicalB]);
        Iir->FloatVector[tagCanonicalB] = ExAllocatePoolWithTag
            (PagedPool, (500+20+Iir->NumCoeffs[tagCanonicalB])*sizeof(FLOAT), 'XIMK');
        if(!Iir->Coeffs[tagCanonicalB]) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else Iir->NumFloat[tagCanonicalB] = 500;
    }
    return Status;
}

// Initialize B coefficients
NTSTATUS RfIirInitBCoeffs
(
    PRFIIR  Iir
)
{
    UINT        ui;
    NTSTATUS    Status = STATUS_SUCCESS;

    ASSERT(Iir);

    Iir->NumCoeffs[tagCanonicalB] = NumCoeffsBInit;
    for (ui=0; ui<NumCoeffsBInit; ++ui)
        Iir->Coeffs[tagCanonicalB][ui] = CoeffsBInit;

    return Status;
}

// Assign coefficients
NTSTATUS RfIirAssignCoeffs
(
    PRFIIR  Iir, 
    PFLOAT  Coeffs, 
    UINT    NumCoeffs, 
    ECanonicalCoeffType CoeffType, 
    BOOL    DoOverlap
)
{
    UINT        st;
    NTSTATUS    Status = STATUS_SUCCESS;

    ASSERT(Iir);
    ASSERT(Coeffs);
    ASSERT(NumCoeffs <= MaxCanonicalCoeffs);
#if DBG
    if (NumCoeffs > 0) {
        ASSERT(Coeffs);
    } else {
        ASSERT(CoeffType == tagCanonicalA);
    }
#endif // DBG
    ASSERT(CoeffType >= 0 && CoeffType < ecanonicalcoefftypeCount);

    // Process overlap request
    if (DoOverlap == TRUE) {
        // Save current (i.e. old after this function is complete) 
        // filter state for overlap processing
        RfIirGetState(Iir, Iir->IirStateOld, CoeffType, TRUE);
        
        // Set overlap flag so that at next Filter() 
        // call the overlap buffer will be processed
        Iir->DoOverlap = TRUE;
    }

    // Check if coefficient storage is sufficient
    if (Iir->MaxCoeffs[CoeffType] == 0 || 
        NumCoeffs > Iir->MaxCoeffs[CoeffType]) {
        // Reallocate memory
        if(Iir->Coeffs[CoeffType]) {
            ExFreePool(Iir->Coeffs[CoeffType]);
        }
        if (NumCoeffs > 0)
            Iir->Coeffs[CoeffType] = ExAllocatePoolWithTag(PagedPool, NumCoeffs*sizeof(FLOAT), 'XIMK');
        else
            Iir->Coeffs[CoeffType] = NULL;

        if(!Iir->Coeffs[CoeffType] && NumCoeffs > 0) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        
        // Keep maximum up-to-date
        if (Iir->MaxCoeffs[CoeffType] != 0)
            Iir->MaxCoeffs[CoeffType] = NumCoeffs;
    }
    
    if(NT_SUCCESS(Status))
    {
        // Assign size and coefficients
        Iir->NumCoeffs[CoeffType] = NumCoeffs;
        RtlCopyBytes(Iir->Coeffs[CoeffType], Coeffs, NumCoeffs * sizeof(FLOAT));
#if DBG
        for (st=0; st<NumCoeffs; ++st)
            ASSERT(fabs(Iir->Coeffs[CoeffType][st]) < MaxCanonicalCoeffMagnitude);
#endif // DBG
    
        // Size and reset (i.e. fill with zero) circular vectors
        switch (CoeffType) {
            case tagCanonicalB:
                ASSERT(NumCoeffs > 0);
                Status = RfcVecSetSize(Iir->CircVec[CoeffType], NumCoeffs, CircVecInit);
                break;
            
            case tagCanonicalA:
                // Don't allocate circular vector if there are no A coefficients
                if (NumCoeffs > 0)
                    Status = RfcVecSetSize(Iir->CircVec[CoeffType], NumCoeffs, CircVecInit);
                break;
    
            default:
                Status = STATUS_INVALID_PARAMETER;
                break;
    
        }
    }

    return Status;
}

// Assign maximum number of coefficients
NTSTATUS RfIirAssignMaxCoeffs(
    PRFIIR Iir,
    UINT  MaxCoeffs, 
    ECanonicalCoeffType CoeffType
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Iir);
    ASSERT(MaxCoeffs > 0);
    ASSERT(MaxCoeffs <= MaxCanonicalCoeffs);
    ASSERT(CoeffType >= 0 && CoeffType < ecanonicalcoefftypeCount);

    // Reallocate memory
    Iir->MaxCoeffs[CoeffType] = MaxCoeffs;
    ExFreePool(Iir->Coeffs[CoeffType]);
    if (MaxCoeffs > 0) {
        // Allocate memory
        Iir->Coeffs[CoeffType] = ExAllocatePoolWithTag(PagedPool, MaxCoeffs*sizeof(FLOAT), 'XIMK');
        if(!Iir->Coeffs[CoeffType]) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if(NT_SUCCESS(Status)) {
            if (CoeffType == tagCanonicalB) {
                Status = RfIirInitBCoeffs(Iir);
            }

            // Preallocate memory in circular vector
            Iir->CircVec[CoeffType]->PreallocSize = MaxCoeffs;
        }
    }
    else {
        ASSERT(CoeffType == tagCanonicalA);
        Iir->Coeffs[CoeffType] = NULL;
    }

    return Status;
}

// ---------------------------------------------------------------------------
// Include inline definitions out-of-line in debug version

#if DBG
#include "rfiir.inl"
#endif // DBG

// End of FLOATIIR.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rsiir.c ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rsiir.c

Abstract:

    This module implements the real SHORT
    infinite impulse filter

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

// Project-specific INCLUDEs
#include "common.h"

// ---------------------------------------------------------------------------
// Constants

#define NumBiquadsInit 1
#define BiquadCoeffScalingDivisor 8

// ---------------------------------------------------------------------------
// Fixed-point biquad IIR filter

VOID RsIirInitTapDelayLine
(
    PSHORT_IIR_STATE iirstate,
    LONG             InitialSample
)
{
    UINT    biquad;
    LONG    numeratorSum;
    LONG    denominatorSum;
    LONG    runningNumeratorSum;
    LONG    runningDenominatorSum;
    PBIQUAD_COEFFS pBiquad, pBiquadB0;
    PBIQUAD_STATE pState;
    LONG    factor;
    LONG    partialFactor;

    ASSERT(iirstate);

    runningNumeratorSum = 0;
    runningDenominatorSum = 0;
    factor = 1;
    partialFactor = 1;

    for (biquad=0; biquad<iirstate->NumBiquads; biquad++) {

        // Calculate the sum of the numerator coefficients
        pBiquad = &(iirstate->biquadCoeffs[biquad]);
        pBiquadB0 = &(iirstate->biquadB0Coeffs[biquad]);
        numeratorSum = pBiquadB0->sB0;
        numeratorSum += pBiquad->sB1;
        numeratorSum += pBiquad->sB2;

        // Calculate the sum of the denominator coefficients
        denominatorSum = 1;
        denominatorSum -= pBiquad->sA1;
        denominatorSum -= pBiquad->sA2;

        factor = denominatorSum * partialFactor;

        // Initialize the tap delay line
        pState = &(iirstate->biquadState[biquad]);
        pState->lW1 = factor;
        pState->lW2 = factor;

        // Update the intermediate value
        partialFactor = numeratorSum / denominatorSum;
    }

}


// "Regular" constructor
NTSTATUS RsIirCreate
(
    PRSIIR* ppRsIir
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT Type;
    PRSIIR Iir;

    *ppRsIir = ExAllocatePoolWithTag(PagedPool, sizeof(RSIIR), 'XIMK' );

    if(*ppRsIir) {
        Iir = *ppRsIir;
        RtlZeroMemory ( *ppRsIir, sizeof ( RSIIR ) ) ;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

// Destructor
VOID RsIirDestroy
(
    PRSIIR Iir
)
{
    if (Iir) {
        if (Iir->biquadCoeffs) {
            ExFreePool(Iir->biquadCoeffs);
            Iir->biquadCoeffs = NULL;
        }

        if (Iir->biquadB0Coeffs) {
            ExFreePool(Iir->biquadB0Coeffs);
            Iir->biquadB0Coeffs = NULL;
        }

        if (Iir->biquadState) {
            ExFreePool(Iir->biquadState);
            Iir->biquadState = NULL;
        }

        ExFreePool(Iir);
    }
}

// Filter a block of samples
VOID RsIirFilterC
(
    PRSIIR Iir,
    PLONG  InData,
    PLONG  OutData,
    UINT   NumSamples
)
{
    LONG  Data;
    PSHORT Coef;
    UINT  st;
    LONG  lXSample;
    LONG  lYValue;
    SHORT Gain;
    UINT  Biquad;
    PBIQUAD_STATE State;
    PBIQUAD_COEFFS Coeffs, CoeffsB0;

    ASSERT(Iir);
    ASSERT(InData);
    ASSERT(OutData);

    Gain = Iir->Gain;

    // Go through samples
    for (st=0; st<NumSamples; ++st) {
        // Get X sample
        lXSample = InData[st];

        // Go through biquads
        for (Biquad=0; Biquad<Iir->NumBiquads; ++Biquad) {
            // Get references to current biquad and state
            State    = &(Iir->biquadState[Biquad]);
            Coeffs   = &(Iir->biquadCoeffs[Biquad]);
            CoeffsB0 = &(Iir->biquadB0Coeffs[Biquad]);

            // Get Y value
            lYValue = (lXSample * CoeffsB0->sB0 + State->lW1) / 16384;

            // Update W1
            State->lW1 = lXSample * Coeffs->sB1 + lYValue * Coeffs->sA1 + State->lW2;

            // Update W2
            State->lW2 = lXSample * Coeffs->sB2 + lYValue * Coeffs->sA2;

            // Output of current biquad is input into next biquad
            lXSample = lYValue;
        }

        lXSample *= Gain;
        lXSample /= 32768;

        // Saturate to maximum
        if (lXSample > MaxSaturation) {
            lXSample = MaxSaturation;
            _DbgPrintF( DEBUGLVL_TERSE, ("Sample exceeded maximum saturation value rsiir 1") );
        }

        // Saturate to minimum
        if (lXSample < MinSaturation) {
            lXSample = MinSaturation;
            _DbgPrintF( DEBUGLVL_TERSE, ("Sample exceeded maximum saturation value rsiir 1") );
        }

        // Store output
        OutData[st] = lXSample;
    }
}

#if _X86_ // {

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

// Filter a block of samples
VOID RsIirFilterMmx
(
    PRSIIR Iir,
    PLONG  InData,
    PLONG  OutData,
    UINT   NumSamples
)
{
    LONG  Data;
    PSHORT Coef;
    UINT  st;
    UINT  BitsPerShortMinus1;
    UINT  BitsPerShortMinus2;
    LONG  lXSample;
    LONG  lYValue;
    SHORT Gain;
    UINT  Biquad;
    PBIQUAD_STATE State;
    PBIQUAD_COEFFS Coeffs, CoeffsB0;

    ASSERT(Iir);
    ASSERT(InData);
    ASSERT(OutData);

    Gain = Iir->Gain;

    {
    UINT  NumBiquads = Iir->NumBiquads;
    static SHORT GainArray[]={0,0,0,0};

    State    = &(Iir->biquadState   [0]);
    Coeffs   = &(Iir->biquadCoeffs  [0]);
    CoeffsB0 = &(Iir->biquadB0Coeffs[0]);
    GainArray[0]  = Gain;

    _asm {
    mov    edi, DWORD PTR NumSamples
    test    edi, edi
    jbe    $L8502x

    mov    ecx, DWORD PTR InData
    mov ebx, DWORD PTR OutData

    pxor        mm0, mm0        // Need a zero register.
    movd        mm3, GainArray
    lea         ecx, [ecx+edi*4]
    lea         ebx, [ebx+edi*4]
    neg         edi

    mov         eax, Coeffs
    mov         edx, CoeffsB0
    mov         esi, NumBiquads

    push        ebp
    mov         ebp, State
    lea         eax, [eax+esi*8]
    lea         edx, [edx+esi*8]
    lea         ebp, [ebp+esi*8]
    neg         esi
    push        esi             // Save index value

$L8682x:
    pop         esi

    movd        mm6, [ecx+edi*4]  // 0,    Xvalue
    packssdw    mm6, mm0    // 0, 0, 0,        XvalueLo
    movq        mm7, mm6    // YvalueLo

    push        esi

$Lab:
    movd        mm4, [ebp+esi*8+0]  // W1
    movd        mm5, [ebp+esi*8+4]  // W2

    movq        mm2, [edx+esi*8]    // CoeffsB0
    movq        mm1, [eax+esi*8]    // Coeffs

    pmaddwd     mm7, mm2    // 0,    XvalueLo * B0
    paddd       mm7, mm4    // 0,    XvalueLo * B0 + W1
    psrad       mm7, 14     // 0,    Yvalue = (XvalueLo * B0) >> 15
    packssdw    mm7, mm0    // 0, 0, 0,        YvalueLo
    movq        mm4, mm7    // 0, 0, 0,        YvalueLo

    punpcklwd   mm4, mm6    // 0,        0,             XvalueLo, YvalueLo
    punpckldq   mm4, mm4    // XvalueLo, YvalueLo,      XvalueLo, YvalueLo
    pmaddwd     mm4, mm1    // XvalueLo*B2-YvalueLo*A2, XvalueLo*B1-YvalueLo*A1
    paddd       mm4, mm5    // W2 += 0,                 W1 += W2

    movq        mm5, mm4

    punpckldq   mm4, mm0
    movq        mm6, mm7    // XvalueLo = YvalueLo

    punpckhdq   mm5, mm0

    movd    [ebp+esi*8+0], mm4
    movd    [ebp+esi*8+4], mm5

    inc         esi
    jne         $Lab

    pmaddwd     mm7, mm3    // 0, Gain * YvalueLo
    psrad       mm7, 15     // 0, Xvalue = (Gain * YvalueLo) >> 14
    packssdw    mm7, mm0    // 0, 0, 0, XvalueLo

    pslld       mm7, 16
    psrad       mm7, 16

    movd        [ebx+edi*4], mm7

    inc    edi
    jne    SHORT $L8682x

    pop esi
    pop ebp

    emms
$L8502x:
    }
    }
}
#endif // }

// Filter a block of samples
VOID RsIirFilterShelfC
(
    PRSIIR Iir,
    PLONG  InData,
    PLONG  OutData,
    UINT   NumSamples
)
{
    LONG  Data;
    PSHORT Coef;
    UINT  st;
    LONG  lXSample;
    LONG  lYValue, lGain;
    SHORT Gain;
    UINT  Biquad;
    PBIQUAD_STATE State;
    PBIQUAD_COEFFS Coeffs, CoeffsB0;

#ifdef _X86_ // {
    Gain = Iir->Gain;
        // Get references to current biquad and state
        State    = &(Iir->biquadState   [0]);
        Coeffs   = &(Iir->biquadCoeffs  [0]);
        CoeffsB0 = &(Iir->biquadB0Coeffs[0]);
#if 1   // { This is the fastest ASM version
    {
    LONG lB0, lB1, lB2, lA1, lA2;
    lB0 = CoeffsB0->sB0;
    lB1 = Coeffs  ->sB1;
    lB2 = Coeffs  ->sB2;
    lA1 = Coeffs  ->sA1;
    lA2 = Coeffs  ->sA2;

    lGain = Gain;
    _asm {
    mov    esi, DWORD PTR State
    mov    edi, DWORD PTR NumSamples
    test    edi, edi
    jbe    $L8502

    mov edi, [esi+4]
    mov esi, [esi]

    mov    ecx, DWORD PTR InData

$L8682:
    mov        ebx, DWORD PTR [ecx]
    mov     edx, lB0

    mov        eax, ebx
    imul    eax, edx
    add        eax, esi
    mov     esi, lB1
    sar        eax, 15
    mov     edx, lA1

    imul    esi, ebx
    imul    edx, eax
    add    esi, edx
    mov     edx, lA2
    add    esi, edi

    mov     edi, lB2
    imul    edi, ebx
    imul    edx, eax
    imul    eax, lGain
    add    edi, edx

    sar        eax, 14

    cmp    eax, 32767                ; 00007fffH
    jle    SHORT $L8503
    mov    eax, 32767                ; 00007fffH
    jmp    SHORT $L8505
$L8503:
    cmp    eax, -32768                ; ffff8000H
    jge    SHORT $L8505
    mov    eax, -32768                ; ffff8000H
$L8505:

    movsx    edx, ax
    mov    eax, OutData
    add    ecx, 4
    mov    DWORD PTR [eax], edx
    add    OutData, 4
    dec    NumSamples
    jne    SHORT $L8682

    mov eax, State
    mov [eax], esi
    mov [eax+4], edi
$L8502:
    }
    }
#else   // }{
#if 0   // { This version is used to build the MMX version from.
    {
    LONG lB0, lB1, lB2, lA1, lA2;
    lB0 = CoeffsB0->sB0;
    lB1 = Coeffs  ->sB1;
    lB2 = Coeffs  ->sB2;
    lA1 = Coeffs  ->sA1;
    lA2 = Coeffs  ->sA2;

    lGain = Gain;
    _asm {
    mov    esi, DWORD PTR State
    mov    edi, DWORD PTR NumSamples
    test    edi, edi
    jbe    $L8502

    mov edi, [esi+4]
    mov esi, [esi]

    mov    ecx, DWORD PTR InData
$L8682:
    // Base MMX off of this code.
    mov     edx, lB0
    mov        ebx, DWORD PTR [ecx]

    mov        eax, ebx
    imul    eax, edx
    add        eax, esi
    sar        eax, 15

    mov     esi, lB1
    imul    esi, ebx
    mov     edx, lA1
    imul    edx, eax
    add    esi, edx
    add    esi, edi

    mov     edi, lB2
    imul    edi, ebx
    mov     edx, lA2
    imul    edx, eax
    add    edi, edx

    imul    eax, lGain
    sar        eax, 14

    cmp    eax, 32767                ; 00007fffH
    jle    SHORT $L8503
    mov    eax, 32767                ; 00007fffH
    jmp    SHORT $L8505
$L8503:
    cmp    eax, -32768                ; ffff8000H
    jge    SHORT $L8505
    mov    eax, -32768                ; ffff8000H
$L8505:

    movsx    edx, ax
    mov    eax, OutData
    add    ecx, 4
    mov    DWORD PTR [eax], edx
    add    OutData, 4
    dec    NumSamples
    jne    SHORT $L8682

    mov eax, State
    mov [eax], esi
    mov [eax+4], edi
$L8502:
    }
    }
#endif  // }
#endif  // }
#else   // }{
    ASSERT(Iir);
    ASSERT(InData);
    ASSERT(OutData);

    Gain = Iir->Gain;
    // Get references to current biquad and state
    State    = &(Iir->biquadState   [0]);
    Coeffs   = &(Iir->biquadCoeffs  [0]);
    CoeffsB0 = &(Iir->biquadB0Coeffs[0]);

    // Go through samples
    for (st=0; st<NumSamples; ++st) {
        // Get X sample
        lXSample = InData[st];

        // Go through biquads

        // Get Y value
        lYValue = (lXSample * CoeffsB0->sB0 + State->lW1) / 32768;

        // Update W1
        State->lW1 = lXSample * Coeffs->sB1 + lYValue * Coeffs->sA1 + State->lW2;

        // Update W2
        State->lW2 = lXSample * Coeffs->sB2 + lYValue * Coeffs->sA2;

        // Output of current biquad is input into next biquad
        lXSample = lYValue;

        lXSample *= Gain;
        lXSample /= 16384;

        // Saturate to maximum
        if (lXSample > MaxSaturation) {
            lXSample = MaxSaturation;
        }

        // Saturate to minimum
        else if (lXSample < MinSaturation) {
            lXSample = MinSaturation;
        }

        // Store output
        OutData[st] = (SHORT)(lXSample);
    }
#endif // }
}

#ifdef _X86_ // {
// Filter a block of samples
VOID RsIirFilterShelfMmx
(
    PRSIIR Iir,
    PLONG  InData,
    PLONG  OutData,
    UINT   NumSamples
)
{
    LONG  Data;
    PSHORT Coef;
    UINT  st;
    UINT  BitsPerShortMinus1;
    UINT  BitsPerShortMinus2;
    LONG  lXSample;
    LONG  lYValue, lGain;
    SHORT Gain;
    UINT  Biquad;
    PBIQUAD_STATE State;
    PBIQUAD_COEFFS Coeffs, CoeffsB0;

    Gain = Iir->Gain;
        // Get references to current biquad and state
        State    = &(Iir->biquadState   [0]);
        Coeffs   = &(Iir->biquadCoeffs  [0]);
        CoeffsB0 = &(Iir->biquadB0Coeffs[0]);
    {
    static SHORT GainArray[]={0,0,0,0};
    SHORT CoeffArray[4];

    GainArray[0]  = Gain;

    _asm {
    mov    esi, DWORD PTR State
    mov    edi, DWORD PTR NumSamples
    test    edi, edi
    jbe    $L8502

    mov    ecx, DWORD PTR InData
    mov ebx, DWORD PTR OutData

    pxor        mm0, mm0        // Need a zero register.
    mov         edx, Coeffs
    movq        mm1, [edx]
    mov         edx, CoeffsB0
    movq        mm2, [edx]
    movd        mm3, GainArray
    movd        mm4, [esi+0]
    movd        mm5, [esi+4]
    lea         ecx, [ecx+edi*4]
    lea         ebx, [ebx+edi*4]
    neg         edi

$L8682:

    movd        mm6, [ecx+edi*4]  // 0,    Xvalue
    packssdw    mm6, mm0    // 0, 0, 0,        XvalueLo
    movq        mm7, mm6    // YvalueLo

    pmaddwd     mm7, mm2    // 0,    XvalueLo * B0
    paddd       mm7, mm4    // 0,    XvalueLo * B0 + W1
    psrad       mm7, 15     // 0,    Yvalue = (XvalueLo * B0) >> 15
    packssdw    mm7, mm0    // 0, 0, 0,        YvalueLo
    movq        mm4, mm7    // 0, 0, 0,        YvalueLo

    punpcklwd   mm4, mm6    // 0,        0,             XvalueLo, YvalueLo
    punpckldq   mm4, mm4    // XvalueLo, YvalueLo,      XvalueLo, YvalueLo
    pmaddwd     mm4, mm1    // XvalueLo*B2-YvalueLo*A2, XvalueLo*B1-YvalueLo*A1
    paddd       mm4, mm5    // W2 += 0,                 W1 += W2

    pmaddwd     mm7, mm3    // 0, Gain * YvalueLo
    psrad       mm7, 14     // 0, Xvalue = (Gain * YvalueLo) >> 14
    packssdw    mm7, mm0    // 0, 0, 0, XvalueLo

    pslld       mm7, 16
    movq        mm5, mm4

    psrad       mm7, 16

    punpckldq   mm4, mm0
    movd        [ebx+edi*4], mm7

    punpckhdq   mm5, mm0

    inc    edi
    jne    SHORT $L8682

    movd    [esi+0], mm4
    movd    [esi+4], mm5
    emms
$L8502:
    }
    }
}
#endif  // }


// Get filter state
VOID RsIirGetState
(
    PRSIIR Iir,
    PSHORT_IIR_STATE State,
    BOOL CopyBiquadState
)
{
    ASSERT(Iir);
    ASSERT(State);

    // Copy number of biquads
    State->NumBiquads = Iir->NumBiquads;

    if (Iir->NumBiquads > 0) {
        // Copy biquad coefficients
//        CHECK_POINTER(m_pbiquadCoeffs);
        RtlCopyBytes(State->biquadCoeffs, Iir->biquadCoeffs, sizeof(BIQUAD_COEFFS) * Iir->NumBiquads);
        RtlCopyBytes(State->biquadB0Coeffs, Iir->biquadB0Coeffs, sizeof(BIQUAD_COEFFS) * Iir->NumBiquads);

        // Copy biquad states only if requested
        if (CopyBiquadState == TRUE)
            RtlCopyBytes(State->biquadState, Iir->biquadState, sizeof(BIQUAD_STATE) * Iir->NumBiquads);
    }
}

// Set filter state
NTSTATUS RsIirSetState
(
    PRSIIR Iir,
    PSHORT_IIR_STATE State,
    BOOL CopyBiquadState
)
{
    NTSTATUS Status;

    ASSERT(Iir);
    ASSERT(State);

    // Allocate memory
    Status = RsIirAllocateMemory(Iir, State->NumBiquads);

    if(NT_SUCCESS(Status)) {
        // Copy number of biquads
        Iir->NumBiquads = State->NumBiquads;

        // Copy biquad coefficients
        RtlCopyBytes(Iir->biquadCoeffs, State->biquadCoeffs, sizeof(BIQUAD_COEFFS) * Iir->NumBiquads);
        RtlCopyBytes(Iir->biquadB0Coeffs, State->biquadB0Coeffs, sizeof(BIQUAD_COEFFS) * Iir->NumBiquads);

        // Copy biquad states only if requested
        if (CopyBiquadState == TRUE)
            RtlCopyBytes(Iir->biquadState, State->biquadState, sizeof(BIQUAD_STATE) * Iir->NumBiquads);
    }

    return Status;
}

// Set coefficients
NTSTATUS RsIirSetCoeffs
(
    PRSIIR Iir,
    PSHORT Coeffs,
    UINT   NumBiquadCoeffs,
    SHORT  Gain,
    BOOL   DoOverlap
)
{
    UINT        BiquadIndex;
    UINT        NumBiquads;
    UINT        st;
    NTSTATUS    Status;

    ASSERT(Iir);
    ASSERT(Coeffs);
//    ASSERT(NumBiquadCoeffs > 0);
    ASSERT(NumBiquadCoeffs <= NumBiquadsToNumBiquadCoeffs(MAX_BIQUADS));

    // Save current (i.e. old after this function is complete) filter state for overlap processing
    RsIirGetState(Iir, &(Iir->iirstateOld), TRUE);

    // Set overlap flag so that at next Filter()
    // call the overlap buffer will be processed, if requested
    Iir->DoOverlap = DoOverlap;

    // Allocate memory
    NumBiquads = NumBiquadCoeffsToNumBiquads(NumBiquadCoeffs);
    Status = RsIirAllocateMemory(Iir, NumBiquads);

    if(NT_SUCCESS(Status)) {
        // Assign size and biquad coefficients
        Iir->NumBiquads = NumBiquads;
        for (st=0; st<NumBiquads; ++st) {
            // Initialize biquad
            BiquadIndex = ebiquadcoefftypeCount * st;
            Iir->biquadCoeffs[st].sB2 =   Coeffs[BiquadIndex + tagBiquadB2];
            Iir->biquadCoeffs[st].sB1 =   Coeffs[BiquadIndex + tagBiquadB1];
            Iir->biquadCoeffs[st].sA2 = - Coeffs[BiquadIndex + tagBiquadA2];
            Iir->biquadCoeffs[st].sA1 = - Coeffs[BiquadIndex + tagBiquadA1];

            Iir->biquadB0Coeffs[st].sB0 = Coeffs[BiquadIndex + tagBiquadB0];
            Iir->biquadB0Coeffs[st].sZero1 = 0;
            Iir->biquadB0Coeffs[st].sZero2 = 0;
            Iir->biquadB0Coeffs[st].sZero3 = 0;

            // Initialize state
            Iir->biquadState[st].lW1 = 0;
            Iir->biquadState[st].lW2 = 0;
        }

        // Assign the gain
        Iir->Gain = Gain;
    }

    return Status;
}

// Initialize data
NTSTATUS RsIirInitData
(
    PRSIIR  Iir,
    UINT    MaxNumBiquads,
    KSDS3D_HRTF_FILTER_QUALITY Quality
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Iir);

    Iir->DoOverlap = FALSE;

    if(FULL_FILTER == Quality)
    {
#if 0
#ifdef _X86_
        if (MmxPresent())
            Iir->FunctionFilter = RsIirFilterMmx;
        else
#endif
#endif
            Iir->FunctionFilter = RsIirFilterC;
    }
    else if(LIGHT_FILTER == Quality)
    {
#ifdef _X86_
        if (MmxPresent())
            Iir->FunctionFilter = RsIirFilterShelfMmx;
        else
#endif
            Iir->FunctionFilter = RsIirFilterShelfC;

    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(Status)) {
        if((Iir->MaxBiquads < MaxNumBiquads) || !Iir->biquadCoeffs)
        {
            if(Iir->biquadCoeffs)
            {
                ExFreePool(Iir->biquadCoeffs);
            }

            Iir->biquadCoeffs =
                ExAllocatePoolWithTag
                (
                    PagedPool,
                    MaxNumBiquads*sizeof(BIQUAD_COEFFS),
                    'XIMK'
                );

            if(!Iir->biquadCoeffs) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        if((Iir->MaxBiquads < MaxNumBiquads) || !Iir->biquadB0Coeffs)
        {
            if(Iir->biquadB0Coeffs)
            {
                ExFreePool(Iir->biquadB0Coeffs);
            }

            Iir->biquadB0Coeffs = ExAllocatePoolWithTag(PagedPool, MaxNumBiquads*sizeof(BIQUAD_COEFFS), 'XIMK');
            if(!Iir->biquadB0Coeffs) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        if((Iir->MaxBiquads < MaxNumBiquads) || !Iir->biquadState)
        {
            if(Iir->biquadState)
            {
                ExFreePool(Iir->biquadState);
            }

            Iir->biquadState = ExAllocatePoolWithTag(PagedPool, MaxNumBiquads*sizeof(BIQUAD_STATE), 'XIMK');
            if(!Iir->biquadState) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        Iir->MaxBiquads = MaxNumBiquads;
        Iir->NumBiquads = MaxNumBiquads;
        RsIirInitCoeffs(Iir);
    }

    if (NT_SUCCESS(Status)) {
        // Initialize state
        RsIirGetState(Iir, &(Iir->iirstateOld), TRUE);
    }

    if (!NT_SUCCESS(Status)) {
        RsIirDeleteMemory(Iir);
    }

    return Status;
}

// Allocate coefficient/state memory
NTSTATUS RsIirAllocateMemory
(
    PRSIIR Iir,
    UINT   NumBiquads
)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    ASSERT(Iir);
//    ASSERT(NumBiquads > 0);
    ASSERT(NumBiquads <= MAX_BIQUADS);

    // Check if memory is sufficient
    if (Iir->MaxBiquads == 0 || NumBiquads > Iir->MaxBiquads) {
        // Re-allocate memory
        Status = RsIirReallocateMemory(Iir, NumBiquads);

        // Keep maximum up-to-date
        if (Iir->MaxBiquads != 0)
            Iir->MaxBiquads = NumBiquads;
    } else {
        Iir->NumBiquads = NumBiquads;
        RsIirInitCoeffs(Iir);
    }

    return Status;
}

// Reallocate coefficient/state memory
NTSTATUS RsIirReallocateMemory
(
    PRSIIR  Iir,
    UINT    NumBiquads
)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    ASSERT(Iir);

    RsIirDeleteMemory(Iir);

    Iir->biquadCoeffs = ExAllocatePoolWithTag(PagedPool, NumBiquads*sizeof(BIQUAD_COEFFS), 'XIMK');
    if(!Iir->biquadCoeffs) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    Iir->biquadB0Coeffs = ExAllocatePoolWithTag(PagedPool, NumBiquads*sizeof(BIQUAD_COEFFS), 'XIMK');
    if(!Iir->biquadB0Coeffs) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(NT_SUCCESS(Status)) {
        Iir->biquadState = ExAllocatePoolWithTag(PagedPool, NumBiquads*sizeof(BIQUAD_STATE), 'XIMK');
        if(!Iir->biquadState) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if(NT_SUCCESS(Status)) {
        Iir->DoOverlap = FALSE;
        Iir->MaxBiquads = NumBiquads;
        Iir->NumBiquads = NumBiquads;
        RsIirInitCoeffs(Iir);
    }

    if(!NT_SUCCESS(Status)) {
        RsIirDeleteMemory(Iir);
    }

    return Status;
}

// Delete coefficient/state memory
VOID RsIirDeleteMemory
(
    PRSIIR Iir
)
{
    ASSERT(Iir);

    if (Iir->biquadCoeffs) {
        ExFreePool(Iir->biquadCoeffs);
        Iir->biquadCoeffs = NULL;
    }

    if (Iir->biquadB0Coeffs) {
        ExFreePool(Iir->biquadB0Coeffs);
        Iir->biquadB0Coeffs = NULL;
    }

    if (Iir->biquadState) {
        ExFreePool(Iir->biquadState);
        Iir->biquadState = NULL;
    }
}

// Initialize coefficients
VOID RsIirInitCoeffs
(
    PRSIIR Iir
)
{
    ASSERT(Iir);
//    ASSERT(Iir->NumBiquads > 0);

    if (0<Iir->NumBiquads) {
        Iir->biquadCoeffs[0].sB2 = 0;
        Iir->biquadCoeffs[0].sB1 = 0;
        Iir->biquadCoeffs[0].sA2 = 0;
        Iir->biquadCoeffs[0].sA1 = 0;

        Iir->biquadB0Coeffs[0].sB0 = SHRT_MAX / BiquadCoeffScalingDivisor;

        Iir->biquadState[0].lW1 = 0;
        Iir->biquadState[0].lW2 = 0;
    }
}

// ---------------------------------------------------------------------------
// Include inline definitions out-of-line in debug version

#if DBG
#include "rsiir.inl"
#endif // DBG

// End of SHORTIIR.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rsiir.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rsiir.h

Abstract:

    This is the header for the real, SHORT IIR filter

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(SHORTIIR_HEADER)
#define SHORTIIR_HEADER
#pragma once

// Project-specific INCLUDEs
#include "vmaxhead.h"

// ---------------------------------------------------------------------------
// Defines
#define BitsPerShort 16


// ---------------------------------------------------------------------------
// Enumerations

// Biquad coefficients
typedef enum {
    tagBiquadB2,
    tagBiquadB1,
    tagBiquadB0,
    tagBiquadA2,
    tagBiquadA1,
    ebiquadcoefftypeCount
} EBiquadCoeffType;

// ---------------------------------------------------------------------------
// Pre-Declarations

typedef struct _RSIIR *PRSIIR;

// ---------------------------------------------------------------------------
// Structures

// Biquad coefficients
typedef struct _BIQUAD_COEFFS {
#if 1
    union { SHORT sA1; SHORT sB0; };
    union { SHORT sB1; SHORT sZero1; };
    union { SHORT sA2; SHORT sZero2; };
    union { SHORT sB2; SHORT sZero3; };
#else
    SHORT sB2;
    SHORT sB1;
    SHORT sB0;
    SHORT sA2;
    SHORT sA1;
#endif
} BIQUAD_COEFFS, *PBIQUAD_COEFFS;

// Biquad state
typedef struct _BIQUAD_STATE {
    LONG lW1;
    LONG lW2;
}BIQUAD_STATE, *PBIQUAD_STATE;

// Filter state
typedef struct _SHORT_IIR_STATE {
    UINT NumBiquads;
    BIQUAD_COEFFS biquadCoeffs[MAX_BIQUADS];
    BIQUAD_COEFFS biquadB0Coeffs[MAX_BIQUADS];
    BIQUAD_STATE biquadState[MAX_BIQUADS];
} SHORT_IIR_STATE, *PSHORT_IIR_STATE;

typedef VOID (*PFNShortFilter)(
    PRSIIR  Iir,
    PLONG   InData, 
    PLONG   OutData, 
    UINT    NumSamples
);

typedef struct _RSIIR {
    SHORT_IIR_STATE iirstateOld;
    PBIQUAD_COEFFS  biquadCoeffs;
    PBIQUAD_COEFFS  biquadB0Coeffs;
    SHORT           Gain;
    PBIQUAD_STATE   biquadState;
    UINT            MaxBiquads;
    UINT            NumBiquads;
    BOOL            DoOverlap;
    PFNShortFilter  FunctionFilter;
} RSIIR, *PRSIIR;


// ---------------------------------------------------------------------------
// Fixed-point biquad IIR filter

NTSTATUS RsIirCreate(PRSIIR*);
VOID RsIirDestroy(PRSIIR);

VOID RsIirInitTapDelayLine(PSHORT_IIR_STATE, LONG);

NTSTATUS RsIirSetCoeffs(PRSIIR, PSHORT, UINT, SHORT, BOOL);
VOID RsIirGetState(PRSIIR, PSHORT_IIR_STATE, BOOL);
NTSTATUS RsIirSetState(PRSIIR, PSHORT_IIR_STATE, BOOL);

NTSTATUS RsIirInitData(PRSIIR, UINT, KSDS3D_HRTF_FILTER_QUALITY);
NTSTATUS RsIirAllocateMemory(PRSIIR, UINT);
NTSTATUS RsIirReallocateMemory(PRSIIR, UINT);
VOID RsIirDeleteMemory(PRSIIR);
VOID RsIirInitCoeffs(PRSIIR);

UINT NumBiquadsToNumBiquadCoeffs(UINT);
UINT NumBiquadCoeffsToNumBiquads(UINT);
SHORT FloatBiquadCoeffToShortBiquadCoeff(FLOAT);


// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

#if !DBG
#include "rsiir.inl"
#endif // DBG

#endif

// End of SHORTIIR.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rsiir.inl ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rsiir.inl

Abstract:


Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/


#if !defined(SHORTIIR_INLINE)
#define SHORTIIR_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !DBG
#define INLINE __forceinline
#else // DBG
#define INLINE 
#endif // DBG

// ---------------------------------------------------------------------------
// Fixed-point biquad IIR filter

// Convert number of biquads to corresponding number of biquad coefficients
INLINE UINT NumBiquadsToNumBiquadCoeffs(UINT NumBiquads)
{
	return NumBiquads * ebiquadcoefftypeCount;
}

// Convert number of biquad coefficients to corresponding number of biquads
INLINE UINT NumBiquadCoeffsToNumBiquads(UINT NumBiquadCoeffs)
{
	return NumBiquadCoeffs / ebiquadcoefftypeCount;
}

// Convert floating-point biquad coefficient to SHORT biquad coefficient (by scaling)
INLINE SHORT FloatBiquadCoeffToShortBiquadCoeff(FLOAT BiquadCoeff)
{
	return (SHORT)(SHRT_MAX * BiquadCoeff);
}

#endif

// End of SHORTIIR.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\scenario.c ===
//---------------------------------------------------------------------------
//
//  Module:   scenario.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fir.h"

BOOL gfDsoundMix = FALSE;

extern ULONG gFixedSamplingRate ;

#ifndef DEBUG
#pragma optimize("xt", on)
#endif

// Convert stage
// Bit map:
// b0:  on when mix instead of copy
// b1:  on when output buffer is float
// b2:  on when 16-bit or 32-bit (depending on HiRes flag)
// b3:  on when channel conversion is included, or FLOAT (for HiRes formats)
// b4:  on when input is stereo (only used for channel conversion)
// b5:  on when input is HiRes (24 or 32-bit)
// b2-b5 map as follows:
//      0000 = 8-bit n channels
//      0001 = 16-bit n channels
//      0010 = mono-to-stereo 8-bit
//      0011 = mono-to-stereo 16-bit
//      0100 = stereo 8-bit
//      0101 = stereo 16-bit
//      0110 = stereo-to-mono 8-bit
//      0111 = stereo-to-mono 16-bit
//      1x00 = 24-bit n channels
//      1x01 = 32-bit n channels
//      1x1x = Float n channels
#define CONVERT_FLAG_MIX              0x1
#define CONVERT_FLAG_FLOAT            0x2
#define CONVERT_FLAG_16BIT            0x4
#define CONVERT_FLAG_CHANGE_CHANNELS  0x8
#define CONVERT_FLAG_FLOAT_INPUT      0x8
#define CONVERT_FLAG_STEREO_INPUT     0x10
#define CONVERT_FLAG_HI_RESOLUTION    0x20

#define CONVERT_FLAG_MONO_TO_STEREO   (CONVERT_FLAG_CHANGE_CHANNELS)
#define CONVERT_FLAG_STEREO_TO_MONO   (CONVERT_FLAG_CHANGE_CHANNELS | CONVERT_FLAG_STEREO_INPUT)

PFNStage ConvertFunction[MAXNUMCONVERTFUNCTIONS] = {
    Convert8, QuickMix8, Convert8toFloat, QuickMix8toFloat,
    Convert16, QuickMix16, Convert16toFloat, QuickMix16toFloat,
    ConvertMonoToStereo8, QuickMixMonoToStereo8, ConvertMonoToStereo8toFloat, QuickMixMonoToStereo8toFloat,
    ConvertMonoToStereo16, QuickMixMonoToStereo16, ConvertMonoToStereo16toFloat, QuickMixMonoToStereo16toFloat,
    Convert8, QuickMix8, Convert8toFloat, QuickMix8toFloat,
    Convert16, QuickMix16, Convert16toFloat, QuickMix16toFloat,
    ConvertStereoToMono8, QuickMixStereoToMono8, ConvertStereoToMono8toFloat, QuickMixStereoToMono8toFloat,
    ConvertStereoToMono16, QuickMixStereoToMono16, ConvertStereoToMono16toFloat, QuickMixStereoToMono16toFloat,
    Convert24, QuickMix24, Convert24toFloat, QuickMix24toFloat,
    Convert32, QuickMix32, Convert32toFloat, QuickMix32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
    Convert24, QuickMix24, Convert24toFloat, QuickMix24toFloat,
    Convert32, QuickMix32, Convert32toFloat, QuickMix32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
};

#ifdef _X86_
// MMX-optimized convert functions
PFNStage MmxConvertFunction[MAXNUMCONVERTFUNCTIONS] = {
    Convert8, QuickMix8, Convert8toFloat, QuickMix8toFloat,
    Convert16, QuickMix16, Convert16toFloat, QuickMix16toFloat,
    MmxConvertMonoToStereo8, MmxQuickMixMonoToStereo8, ConvertMonoToStereo8toFloat, QuickMixMonoToStereo8toFloat,
    MmxConvertMonoToStereo16, MmxQuickMixMonoToStereo16, ConvertMonoToStereo16toFloat, QuickMixMonoToStereo16toFloat,
    Convert8, QuickMix8, Convert8toFloat, QuickMix8toFloat,
    Convert16, QuickMix16, Convert16toFloat, QuickMix16toFloat,
    ConvertStereoToMono8, QuickMixStereoToMono8, ConvertStereoToMono8toFloat, QuickMixStereoToMono8toFloat,
    ConvertStereoToMono16, QuickMixStereoToMono16, ConvertStereoToMono16toFloat, QuickMixStereoToMono16toFloat,
    Convert24, QuickMix24, Convert24toFloat, QuickMix24toFloat,
    Convert32, QuickMix32, Convert32toFloat, QuickMix32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
    Convert24, QuickMix24, Convert24toFloat, QuickMix24toFloat,
    Convert32, QuickMix32, Convert32toFloat, QuickMix32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
    ConvertFloat32, QuickMixFloat32, ConvertFloat32toFloat, QuickMixFloat32toFloat,
};
#endif

// 3D Effects stage
// Bit map:
// b0:  on when mix instead of copy
// b1:  on when output buffer is float
// b2:  on when INPUT is stereo
#define EFFECTS_3D_FLAG_STEREO_INPUT   0x4
PFNStage FunctionItd3D[] = {
    StageMonoItd3D, StageMonoItd3DMix, StageMonoItd3DFloat, StageMonoItd3DFloatMix,
    StageStereoItd3D, StageStereoItd3DMix, StageStereoItd3DFloat, StageStereoItd3DFloatMix
};

PFNStage FunctionIir3D[] = {
    StageMonoIir3D, StageMonoIir3DMix, StageMonoIir3DFloat, StageMonoIir3DFloatMix,
    StageStereoIir3D, StageStereoIir3DMix, StageStereoIir3DFloat, StageStereoIir3DFloatMix
};

// Super-mix stage
// Bit map:
// b0:  on when mix instead of copy
// b1:  on when output buffer is float

PFNStage SuperFunction[] = {
    SuperCopy, SuperMix, SuperCopyFloat, SuperMixFloat
};

// Zero stage
PFNStage ZeroFunction[] = {
    ZeroBuffer32
};

// SRC stage
// Bit map:
// b0:  on when mix instead of copy
// b2-b1: Quality: 00=Bad, 01=Low, 10=Med, 11=High
// b3:  on for stereo, off otherwise
// b4:  on for up-sample
#define SRC_MASK_QUALITY    0x6
#define SRC_FLAG_STEREO     0x8
#define SRC_FLAG_UPSAMPLE   0x10

PFNStage SrcFunction[MAXNUMSRCFUNCTIONS] = {
    Src_Worst, SrcMix_Worst, Src_Linear, SrcMix_Linear,
    Src_Basic, SrcMix_Basic, Src_Advanced, SrcMix_Advanced,
    Src_Worst, SrcMix_Worst, Src_StereoLinear, SrcMix_StereoLinear, 
    Src_Basic, SrcMix_Basic, Src_Advanced, SrcMix_Advanced,
    Src_Worst, SrcMix_Worst, Src_Linear, SrcMix_Linear, 
    Src_Basic, SrcMix_Basic, Src_Advanced, SrcMix_Advanced,
    Src_StereoUpNoFilter, SrcMix_StereoUpNoFilter, Src_StereoLinear, SrcMix_StereoLinear, 
    Src_StereoUpBasic, SrcMix_StereoUpBasic, Src_StereoUpAdvanced, SrcMix_StereoUpAdvanced
};

#ifdef _X86_
PFNStage MmxSrcFunction[MAXNUMSRCFUNCTIONS] = {
    Src_Worst, SrcMix_Worst, Src_Linear, SrcMix_Linear,
    Src_Basic, SrcMix_Basic, MmxSrc_Filtered, MmxSrcMix_Filtered,
    Src_Worst, SrcMix_Worst, MmxSrc_StereoLinear, MmxSrcMix_StereoLinear, 
    Src_Basic, SrcMix_Basic, MmxSrc_Filtered, MmxSrcMix_Filtered,
    Src_Worst, SrcMix_Worst, Src_Linear, SrcMix_Linear, 
    Src_Basic, SrcMix_Basic, MmxSrc_Filtered, MmxSrcMix_Filtered,
    Src_StereoUpNoFilter, SrcMix_StereoUpNoFilter, MmxSrc_StereoLinear, MmxSrcMix_StereoLinear,
    Src_StereoUpBasic, SrcMix_StereoUpBasic, MmxSrc_Filtered, MmxSrcMix_Filtered
};
#endif

ULONG __forceinline
ConvertX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
   	ULONG					BitsPerSample,
   	BOOL					fMixOutput,
   	ULONG					nChannels,
   	BOOL                    fFloatOutput,
   	BOOL                    fApplyScaling
)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PSHORT  pIn16 = CurStage->pInputBuffer;
    PBYTE	pIn8 = CurStage->pInputBuffer;
    ULONG   i;
    LONG    temp;
    FLOAT   ftemp;

#define GTW_OPTS
#ifdef GTW_OPTS
	samplesleft = SampleCount;
    if (fApplyScaling) {
		while (SampleCount--) {
		
			for (i=0; i<nChannels; i++)	{
				if (BitsPerSample == 8) {
					temp = ((LONG)(*pIn8) - 0x80)*256;
					pIn8++;
				} else if (BitsPerSample == 16) {
					temp = (LONG)(*pIn16);
					pIn16++;
				} else if (BitsPerSample == 24) {
					temp = pIn8[0] + pIn8[1]*256 + pIn8[2]*65536L;
					temp <<= 8;
					ftemp = (FLOAT) temp*(1.0f/65536.0f);
					temp /= 65536L;
					pIn8 += 3;
				} else {
					// BitsPerSample == 32
					temp = (*((PLONG) pIn8));
					ftemp = (FLOAT) temp*(1.0f/65536.0f);
					temp /= 65536L;
					pIn8 += 4;
				}

				temp = (CurSink->pVolumeTable[i] * temp) / 32768L;
				if (BitsPerSample >= 24) {
                    ftemp *= (FLOAT) CurSink->pVolumeTable[i]*(1.0f/32768.0f);
                }

				if (fMixOutput) {
					if (fFloatOutput) {
    				    if (BitsPerSample >= 24) {
    				        *pFloatBuffer += ftemp;
    				    } else {
        					*pFloatBuffer += (FLOAT)temp;
    				    }
						pFloatBuffer++;
					} else {
						*pOutputBuffer += temp;
						pOutputBuffer++;
					}
				} else {
					if (fFloatOutput) {
    				    if (BitsPerSample >= 24) {
    				        *pFloatBuffer = ftemp;
    				    } else {
        					*pFloatBuffer = (FLOAT)temp;
    				    }
						pFloatBuffer++;
					} else {
						*pOutputBuffer = temp;
						pOutputBuffer++;
					}
				}
			}
		}
	}
	else {
		ULONG SC;
		SampleCount *= nChannels;
		SC = SampleCount >> 3;

		if (SC) {
			SampleCount &= 0x7;
			while (SC--) {
#define ONESAMPLE(x) \
				if (BitsPerSample == 8) { \
					temp = ((LONG)(pIn8[x]) - 0x80)*256; \
				} else if (BitsPerSample == 16) { \
					temp = (LONG)(pIn16[x]); \
				} else if (BitsPerSample == 24) { \
					temp = pIn8[x*3] + pIn8[x*3+1]*256 + pIn8[x*3+2]*65536L; \
					temp <<= 8; \
					ftemp = (FLOAT) temp*(1.0f/65536.0f); \
					temp /= 65536L; \
				} else { \
					temp = (((PLONG) pIn8)[x]); \
					ftemp = (FLOAT) temp*(1.0f/65536.0f); \
					temp /= 65536L; \
				} \
 				\
				if (fMixOutput) { \
					if (fFloatOutput) { \
    				    if (BitsPerSample >= 24) { \
    				        pFloatBuffer[x] += ftemp; \
    				    } else { \
        					pFloatBuffer[x] += (FLOAT)temp; \
    				    } \
					} else { \
						pOutputBuffer[x] += temp; \
					} \
				} else { \
					if (fFloatOutput) { \
    				    if (BitsPerSample >= 24) { \
    				        pFloatBuffer[x] = ftemp; \
    				    } else { \
        					pFloatBuffer[x] = (FLOAT)temp; \
    				    } \
					} else { \
						pOutputBuffer[x] = temp; \
					} \
				}

				ONESAMPLE(0);
				ONESAMPLE(1);
				ONESAMPLE(2);
				ONESAMPLE(3);
				ONESAMPLE(4);
				ONESAMPLE(5);
				ONESAMPLE(6);
				ONESAMPLE(7);

				if (BitsPerSample == 8) {
					pIn8+=8;
				} else if (BitsPerSample == 16) {
					pIn16+=8;
				} else if (BitsPerSample == 24) {
					pIn8 += 3*8;
				} else {
					pIn8 += 4*8;
				}

				if (fMixOutput) {
					if (fFloatOutput) {
						pFloatBuffer+=8;
					} else {
						pOutputBuffer+=8;
					}
				} else {
					if (fFloatOutput) {
						pFloatBuffer+=8;
					} else {
						pOutputBuffer+=8;
					}
				}
			}
		}
		while (SampleCount--) {
			if (BitsPerSample == 8) {
				temp = ((LONG)(*pIn8) - 0x80)*256;
				pIn8++;
			} else if (BitsPerSample == 16) {
				temp = (LONG)(*pIn16);
				pIn16++;
			} else if (BitsPerSample == 24) {
				temp = pIn8[0] + pIn8[1]*256 + pIn8[2]*65536L;
				temp <<= 8;
				ftemp = (FLOAT) temp*(1.0f/65536.0f);
				temp /= 65536L;
				pIn8 += 3;
			} else {
				// BitsPerSample == 32
				temp = (*((PLONG) pIn8));
				ftemp = (FLOAT) temp*(1.0f/65536.0f);
				temp /= 65536L;
				pIn8 += 4;
			}

			if (fMixOutput) {
				if (fFloatOutput) {
				    if (BitsPerSample >= 24) {
				        *pFloatBuffer += ftemp;
				    } else {
    					*pFloatBuffer += (FLOAT)temp;
				    }
					pFloatBuffer++;
				} else {
					*pOutputBuffer += temp;
					pOutputBuffer++;
				}
			} else {
				if (fFloatOutput) {
				    if (BitsPerSample >= 24) {
				        *pFloatBuffer = ftemp;
				    } else {
    					*pFloatBuffer = (FLOAT)temp;
				    }
					pFloatBuffer++;
				} else {
					*pOutputBuffer = temp;
					pOutputBuffer++;
				}
			}
		}
	}
#else
    samplesleft = SampleCount;
	while (SampleCount--) {
	
	    for (i=0; i<nChannels; i++)	{
			if (BitsPerSample == 8) {
			    temp = ((LONG)(*pIn8) - 0x80)*256;
			    pIn8++;
			} else if (BitsPerSample == 16) {
			    temp = (LONG)(*pIn16);
			    pIn16++;
			} else if (BitsPerSample == 24) {
			    temp = pIn8[0] + pIn8[1]*256 + pIn8[2]*65536L;
			    temp <<= 8;
			    ftemp = (FLOAT) temp*(1.0f/65536.0f);
                temp /= 65536L;
                pIn8 += 3;
			} else {
			    // BitsPerSample == 32
			    temp = (*((PLONG) pIn8));
			    ftemp = (FLOAT) temp*(1.0f/65536.0f);
			    temp /= 65536L;
			    pIn8 += 4;
			}

            if (fApplyScaling) {
                temp = (CurSink->pVolumeTable[i] * temp) / 32768L;
                ftemp *= (FLOAT) CurSink->pVolumeTable[i]*(1.0f/32768.0f);
            }

		    if (fMixOutput) {
		        if (fFloatOutput) {
				    if (BitsPerSample >= 24) {
				        *pFloatBuffer += ftemp;
				    } else {
    					*pFloatBuffer += (FLOAT)temp;
				    }
		            pFloatBuffer++;
		        } else {
		            *pOutputBuffer += temp;
		            pOutputBuffer++;
		        }
			} else {
		        if (fFloatOutput) {
				    if (BitsPerSample >= 24) {
				        *pFloatBuffer = ftemp;
				    } else {
    					*pFloatBuffer = (FLOAT)temp;
				    }
		            pFloatBuffer++;
		        } else {
		            *pOutputBuffer = temp;
		            pOutputBuffer++;
		        }
			}
		}
	}
#endif

	return samplesleft;
}
	
ULONG __forceinline
ConvertMonoToStereoX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
   	ULONG					BitsPerSample,
   	BOOL					fMixOutput,
   	BOOL                    fFloatOutput
)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PSHORT  pIn16 = CurStage->pInputBuffer;
    PBYTE	pIn8 = CurStage->pInputBuffer;
    LONG    temp, tempL, tempR;

    samplesleft = SampleCount;
#ifdef GTW_OPTS
	{
		ULONG SC = SampleCount >> 3;
		SampleCount &= 0x7;
		while (SC--) {
#define ONEMSSAMPLE(x) \
			if (BitsPerSample == 8) { \
				temp = ((LONG)(pIn8[x]) - 0x80)*256; \
			} else { \
				temp = (LONG)(pIn16[x]); \
			} \
 			\
			tempL = (CurSink->pVolumeTable[0] * temp) / 32768L; \
			tempR = (CurSink->pVolumeTable[1] * temp) / 32768L; \
 			\
			if (fMixOutput) { \
				if (fFloatOutput) { \
					pFloatBuffer[x*2]   += (FLOAT)tempL; \
					pFloatBuffer[x*2+1] += (FLOAT)tempR; \
				} else { \
					pOutputBuffer[x*2]   += tempL; \
					pOutputBuffer[x*2+1] += tempR; \
				} \
			} else { \
				if (fFloatOutput) { \
					pFloatBuffer[x*2]   = (FLOAT)tempL; \
					pFloatBuffer[x*2+1] = (FLOAT)tempR; \
				} else { \
					pOutputBuffer[x*2] = tempL; \
					pOutputBuffer[x*2+1] = tempR; \
				} \
			}

			ONEMSSAMPLE(0);
			ONEMSSAMPLE(1);
			ONEMSSAMPLE(2);
			ONEMSSAMPLE(3);
			ONEMSSAMPLE(4);
			ONEMSSAMPLE(5);
			ONEMSSAMPLE(6);
			ONEMSSAMPLE(7);

			if (BitsPerSample == 8) {
				pIn8+=8;
			} else {
				pIn16+=8;
			}

			if (fMixOutput) {
				if (fFloatOutput) {
					pFloatBuffer+=16;
				} else {
					pOutputBuffer+=16;
				}
			} else {
				if (fFloatOutput) {
					pFloatBuffer+=16;
				} else {
					pOutputBuffer+=16;
				}
			}
		}
	}
#endif
	while (SampleCount--) {
		if (BitsPerSample == 8) {
		    temp = ((LONG)(*pIn8) - 0x80)*256;
		    pIn8++;
		} else {
		    temp = (LONG)(*pIn16);
		    pIn16++;
		}

        tempL = (CurSink->pVolumeTable[0] * temp) / 32768L;
        tempR = (CurSink->pVolumeTable[1] * temp) / 32768L;

	    if (fMixOutput) {
	        if (fFloatOutput) {
	            *pFloatBuffer += (FLOAT)tempL;
	            pFloatBuffer++;
	            *pFloatBuffer += (FLOAT)tempR;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer += tempL;
	            pOutputBuffer++;
	            *pOutputBuffer += tempR;
	            pOutputBuffer++;
	        }
		} else {
	        if (fFloatOutput) {
	            *pFloatBuffer = (FLOAT)tempL;
	            pFloatBuffer++;
	            *pFloatBuffer = (FLOAT)tempR;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer = tempL;
	            pOutputBuffer++;
	            *pOutputBuffer = tempR;
	            pOutputBuffer++;
	        }
		}
	}

	return samplesleft;
}
	
ULONG __forceinline
ConvertStereoToMonoX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
   	ULONG					BitsPerSample,
   	BOOL					fMixOutput,
   	BOOL                    fFloatOutput
)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PSHORT  pIn16 = CurStage->pInputBuffer;
    PBYTE	pIn8 = CurStage->pInputBuffer;
    LONG    tempL, tempR;

    samplesleft = SampleCount;
#ifdef GTW_OPTS_DONT_USE		// Not used enough...
	{
		ULONG SC = SampleCount >> 3;
		SampleCount &= 0x7;
		while (SC--) {
#define ONESMSAMPLE(x) \
			if (BitsPerSample == 8) { \
				tempL = ((LONG)(pIn8[x*2]) - 0x80)*256; \
				pIn8++; \
				tempR = ((LONG)(pIn8[x*2+1]) - 0x80)*256; \
				pIn8++; \
			} else { \
				tempL = (LONG)(pIn16[x*2]); \
				pIn16++; \
				tempR = (LONG)(pIn16[x*2+1]); \
				pIn16++; \
			} \
 			\
			tempL = (CurSink->pVolumeTable[0] * tempL) / 32768L; \
			tempR = (CurSink->pVolumeTable[1] * tempR) / 32768L; \
 			\
			if (fMixOutput) { \
				if (fFloatOutput) { \
					pFloatBuffer[x] += (FLOAT)tempL; \
					pFloatBuffer[x] += (FLOAT)tempR; \
				} else { \
					pOutputBuffer[x] += tempL; \
					pOutputBuffer[x] += tempR; \
				} \
			} else { \
				if (fFloatOutput) { \
					pFloatBuffer[x] = (FLOAT)tempL; \
					pFloatBuffer[x] += (FLOAT)tempR; \
				} else { \
					pOutputBuffer[x] = tempL; \
					pOutputBuffer[x] += tempR; \
				} \
			}

			ONESMSAMPLE(0);
			ONESMSAMPLE(1);
			ONESMSAMPLE(2);
			ONESMSAMPLE(3);
			ONESMSAMPLE(4);
			ONESMSAMPLE(5);
			ONESMSAMPLE(6);
			ONESMSAMPLE(7);

			if (BitsPerSample == 8) {
				pIn8+=16;
			} else {
				pIn16+=16;
			}

			if (fMixOutput) {
				if (fFloatOutput) {
					pFloatBuffer+=8;
				} else {
					pOutputBuffer+=8;
				}
			} else {
				if (fFloatOutput) {
					pFloatBuffer+=8;
				} else {
					pOutputBuffer+=8;
				}
			}
		}
	}
#else
	while (SampleCount--) {
		if (BitsPerSample == 8) {
		    tempL = ((LONG)(*pIn8) - 0x80)*256;
		    pIn8++;
		    tempR = ((LONG)(*pIn8) - 0x80)*256;
		    pIn8++;
		} else {
		    tempL = (LONG)(*pIn16);
		    pIn16++;
		    tempR = (LONG)(*pIn16);
		    pIn16++;
		}

        tempL = (CurSink->pVolumeTable[0] * tempL) / 32768L;
        tempR = (CurSink->pVolumeTable[1] * tempR) / 32768L;

	    if (fMixOutput) {
	        if (fFloatOutput) {
	            *pFloatBuffer += (FLOAT)tempL;
	            *pFloatBuffer += (FLOAT)tempR;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer += tempL;
	            *pOutputBuffer += tempR;
	            pOutputBuffer++;
	        }
		} else {
	        if (fFloatOutput) {
	            *pFloatBuffer = (FLOAT)tempL;
	            *pFloatBuffer += (FLOAT)tempR;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer = tempL;
	            *pOutputBuffer += tempR;
	            pOutputBuffer++;
	        }
		}
	}
#endif

	return samplesleft;
}

#ifdef _X86_
#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

ULONG __forceinline
AsmConvertMonoToStereo8toX
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft
)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pMappingTable;

    _asm {
        mov ecx, SampleCount
        xor ebx, ebx

        cmp ecx, 0
        jz Done1
        
        xor eax, eax
        dec ecx

        mov edi, pOutputBuffer
        mov esi, pIn16

        push ebp
        mov ebp, pMap
        
        mov al, BYTE PTR [esi]
        lea edi, [edi+ecx*8]
        
        lea esi, [esi+ecx]
        neg ecx
        
        jz Final1

Loop1:
        mov ebx, DWORD PTR [ebp+eax*4+256]
        mov edx, [edi+ecx*8]
        
        mov [edi+ecx*8], ebx
        mov ebx, DWORD PTR [ebp+eax*4+1280+256]

        mov [edi+ecx*8+4], ebx
        mov al, BYTE PTR [esi+ecx+1]
        
        inc ecx
        jnz Loop1

Final1:
        mov ebx, DWORD PTR [ebp+eax*4+256]

        mov [edi+ecx*8], ebx
        mov ebx, DWORD PTR [ebp+eax*4+1280+256]

        mov [edi+ecx*8+4], ebx
        pop ebp
Done1:
    }

    return SampleCount;
    
}
#endif
	
ULONG __forceinline
ConvertFloatX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
   	BOOL					fMixOutput,
   	BOOL                    fFloatOutput
)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   nChannels = CurStage->nOutputChannels;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PFLOAT pIn32 = CurStage->pInputBuffer;
    FLOAT    temp;

    // Does not scale: supermix is used for this.
    samplesleft = SampleCount;
    SampleCount *= nChannels;
#ifdef GTW_OPTS		
	{
		ULONG SC = SampleCount >> 3;
		SampleCount &= 0x7;
		while (SC--) {
#define ONEFSAMPLE(x) \
			temp = (FLOAT) ((pIn32[x])*32767.4f); \
 			\
			if (fMixOutput) { \
				if (fFloatOutput) { \
					pFloatBuffer[x] += temp; \
				} else { \
					pOutputBuffer[x] += DitherFloatToLong(temp,1); \
				} \
			} else { \
				if (fFloatOutput) { \
					pFloatBuffer[x] = temp; \
				} else { \
					pOutputBuffer[x] = DitherFloatToLong(temp,1); \
				} \
			}

			ONEFSAMPLE(0);
			ONEFSAMPLE(1);
			ONEFSAMPLE(2);
			ONEFSAMPLE(3);
			ONEFSAMPLE(4);
			ONEFSAMPLE(5);
			ONEFSAMPLE(6);
			ONEFSAMPLE(7);

			pIn32+=8;

			if (fMixOutput) {
				if (fFloatOutput) {
					pFloatBuffer+=8;
				} else {
					pOutputBuffer+=8;
				}
			} else {
				if (fFloatOutput) {
					pFloatBuffer+=8;
				} else {
					pOutputBuffer+=8;
				}
			}
		}
	}
#endif
	while (SampleCount--) {
	    temp = (FLOAT) ((*pIn32)*32767.4f);
	    pIn32++;

	    if (fMixOutput) {
	        if (fFloatOutput) {
	            *pFloatBuffer += temp;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer += DitherFloatToLong(temp,1);
	            pOutputBuffer++;
	        }
		} else {
	        if (fFloatOutput) {
	            *pFloatBuffer = temp;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer = DitherFloatToLong(temp,1);
	            pOutputBuffer++;
	        }
		}
	}

	return samplesleft;
}

ULONG __forceinline
ConvertFloatY
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
   	BOOL					fMixOutput,
   	BOOL                    fFloatOutput
)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   nChannels = CurStage->nOutputChannels;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PFLOAT pIn32 = CurStage->pInputBuffer;
    FLOAT    temp;

    // Does not scale: supermix is used for this.
    samplesleft = SampleCount;
    SampleCount *= nChannels;
#ifdef GTW_OPTS_DONT_USE	// Does not happen enough
	{
		ULONG SC = SampleCount >> 3;
		SampleCount &= 0x7;
		while (SC--) {
#define ONEFSAMPLE(x) \
			temp = (FLOAT) ((pIn32[x])*32767.4f); \
 			\
			if (fMixOutput) { \
				if (fFloatOutput) { \
					pFloatBuffer[x] += temp; \
				} else { \
					pOutputBuffer[x] += DitherFloatToLong(temp,1); \
				} \
			} else { \
				if (fFloatOutput) { \
					pFloatBuffer[x] = temp; \
				} else { \
					pOutputBuffer[x] = DitherFloatToLong(temp,1); \
				} \
			}

			ONEFSAMPLE(0);
			ONEFSAMPLE(1);
			ONEFSAMPLE(2);
			ONEFSAMPLE(3);
			ONEFSAMPLE(4);
			ONEFSAMPLE(5);
			ONEFSAMPLE(6);
			ONEFSAMPLE(7);

			pIn32+=8;

			if (fMixOutput) {
				if (fFloatOutput) {
					pFloatBuffer+=8;
				} else {
					pOutputBuffer+=8;
				}
			} else {
				if (fFloatOutput) {
					pFloatBuffer+=8;
				} else {
					pOutputBuffer+=8;
				}
			}
		}
	}
#endif
	while (SampleCount--) {
	    temp = (FLOAT) ((*pIn32)*32767.4f);
	    pIn32++;

	    if (fMixOutput) {
	        if (fFloatOutput) {
	            *pFloatBuffer += temp;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer += DitherFloatToLong(temp,1);
	            pOutputBuffer++;
	        }
		} else {
	        if (fFloatOutput) {
	            *pFloatBuffer = temp;
	            pFloatBuffer++;
	        } else {
	            *pOutputBuffer = DitherFloatToLong(temp,1);
	            pOutputBuffer++;
	        }
		}
	}

	return samplesleft;
}

ULONG ZeroBuffer32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    RtlFillMemory(  CurStage->pOutputBuffer,
                    samplesleft * sizeof(LONG) * CurStage->nOutputChannels,
                    0 );
                    
	return SampleCount;
}

ULONG ConvertFloat32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertFloatY(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG QuickMixFloat32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertFloatY(CurStage, SampleCount, samplesleft, TRUE, FALSE);
}

ULONG ConvertFloat32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertFloatX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG QuickMixFloat32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertFloatX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
}

ULONG QuickMix16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;
	return ConvertX(CurStage, SampleCount, samplesleft,	16, TRUE, nChannels, FALSE, FALSE);
}
	
ULONG QuickMixMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pMappingTable;

    if (pMap) {
        _asm {
            mov ecx, SampleCount
            xor ebx, ebx

            cmp ecx, 0
            jz Done1
            
            xor eax, eax
            dec ecx
            
            mov edi, pOutputBuffer
            mov esi, pIn16
            
            push ebp
            mov ebp, pMap
            
            mov al, BYTE PTR [esi+ecx*2]
            mov bl, BYTE PTR [esi+ecx*2+1]
            
            jz Final1

    Loop1:
            mov edx, DWORD PTR [ebp+ebx*4+256]
            mov ebx, [edi+ecx*8]

            add edx, ebx
            xor ebx, ebx
            
            mov al, BYTE PTR [ebp+eax]
            mov bl, BYTE PTR [esi+ecx*2+1]
            
            add edx, eax
            mov al, BYTE PTR [esi+ecx*2]
            
            mov [edi+ecx*8], edx
            mov edx, DWORD PTR [ebp+ebx*4+1288+256]

            mov al, BYTE PTR [ebp+1288+eax]
            mov ebx, [edi+ecx*8+4]

            add edx, ebx
            xor ebx, ebx
            
            add edx, eax
            mov al, BYTE PTR [esi+ecx*2-2]

            mov [edi+ecx*8+4], edx
            mov bl, BYTE PTR [esi+ecx*2-1]

            dec ecx
            jnz Loop1

    Final1:
            mov edx, DWORD PTR [ebp+ebx*4+256]
            mov ebx, [edi+ecx*8]

            add edx, ebx
            xor ebx, ebx
            
            mov al, BYTE PTR [ebp+eax]
            mov bl, BYTE PTR [esi+ecx*2+1]

            add edx, eax
            mov al, BYTE PTR [esi+ecx*2]
            
            mov [edi+ecx*8], edx
            mov edx, DWORD PTR [ebp+ebx*4+1288+256]

            mov al, BYTE PTR [ebp+1288+eax]
            mov ebx, [edi+ecx*8+4]

            add edx, ebx

            add edx, eax

            mov [edi+ecx*8+4], edx

            pop ebp
    Done1:
        }
    } else {
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, TRUE, FALSE);
    }

    return SampleCount;
    
#else    
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, TRUE, FALSE);
#endif	
}
	
ULONG QuickMixStereoToMono16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	16, TRUE, FALSE);
}

ULONG QuickMix8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;
	return ConvertX(CurStage, SampleCount, samplesleft,	8, TRUE, nChannels, FALSE, FALSE);
}

ULONG QuickMixMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pMappingTable;

    if (pMap) {
        _asm {
            mov ecx, SampleCount
            xor ebx, ebx

            cmp ecx, 0
            jz Done1
            
            xor eax, eax
            dec ecx
            
            mov edi, pOutputBuffer
            mov esi, pIn16
            
            push ebp
            mov ebp, pMap
            
            mov al, BYTE PTR [esi+ecx]
            jz Final1

    Loop1:
            mov ebx, DWORD PTR [ebp+eax*4+256]
            mov edx, [edi+ecx*8]

            add edx, ebx
            mov ebx, DWORD PTR [ebp+eax*4+1280+256]

            mov [edi+ecx*8], edx
            mov edx, [edi+ecx*8+4]

            mov al, BYTE PTR [esi+ecx-1]
            add edx, ebx

            mov [edi+ecx*8+4], edx
            dec ecx
            
            jnz Loop1

    Final1:
            mov ebx, DWORD PTR [ebp+eax*4+256]
            mov edx, [edi+ecx*8]

            add edx, ebx
            mov ebx, DWORD PTR [ebp+eax*4+1280+256]

            mov [edi+ecx*8], edx
            mov edx, [edi+ecx*8+4]

            add edx, ebx
            
            mov [edi+ecx*8+4], edx
            pop ebp
    Done1:
    	}
    } else {
    	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, TRUE, FALSE);
    }

	return SampleCount;
	
#else	
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, TRUE, FALSE);
#endif
}

ULONG QuickMixStereoToMono8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	8, TRUE, FALSE);
}

ULONG Convert16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;
#if defined(GTW_OPTS) && defined(_X86_)
	if (MmxPresent()) {
		PLONG   pOutputBuffer = CurStage->pOutputBuffer;
		PSHORT  pIn16 = CurStage->pInputBuffer;
		LONG    temp;

		ULONG SC;
		samplesleft  = SampleCount;
		SampleCount *= nChannels;

		while (((DWORD)pIn16 & 0x07) && SampleCount) {
			temp = (LONG)(*pIn16);
			pIn16++;

			*pOutputBuffer = temp;
			pOutputBuffer++;
			SampleCount--;
		}

		SC = SampleCount >> 3;

		if (SC) {
			SampleCount &= 0x7;
#if 0
			while (SC--) {
#undef  ONESAMPLE
#define ONESAMPLE(x) \
				temp = (LONG)(pIn16[x]); \
				pOutputBuffer[x] = temp;

				ONESAMPLE(0);
				ONESAMPLE(1);
				ONESAMPLE(2);
				ONESAMPLE(3);
				ONESAMPLE(4);
				ONESAMPLE(5);
				ONESAMPLE(6);
				ONESAMPLE(7);

				pIn16+=8;
				pOutputBuffer+=8;
			}
#else	
			_asm {
				mov		esi, DWORD PTR pIn16;
				mov 	edi, DWORD PTR pOutputBuffer;
				mov		eax, DWORD PTR SC

				shl		eax, 3				// * 8.

				lea		esi, [esi+eax*2]	// Ending address...
				lea		edi, [edi+eax*4]

				mov		DWORD PTR pIn16, esi
				mov		DWORD PTR pOutputBuffer, edi

				cmp		eax, 8
				je		onetime

				neg		eax
				
#if 1
				movq		mm0, QWORD PTR [esi+eax*2]
				movq		mm2, QWORD PTR [esi+eax*2+8]

				punpckhwd	mm1, mm0
				punpckhwd	mm3, mm2

				punpcklwd	mm0, mm0
				punpcklwd	mm2, mm2

				psrad		mm0, 16
				add			eax, 8

				psrad		mm1, 16
				movq		QWORD PTR [edi+eax*4  -32], mm0

				psrad		mm2, 16
				movq		QWORD PTR [edi+eax*4+8-32], mm1

				psrad		mm3, 16

			lab:
				movq		QWORD PTR [edi+eax*4+16-32],mm2
				movq		mm0, QWORD PTR [esi+eax*2]

				punpckhwd	mm1, mm0
				movq		QWORD PTR [edi+eax*4+24-32], mm3

				punpcklwd	mm0, mm0
				movq		mm2, QWORD PTR [esi+eax*2+8]

				punpckhwd	mm3, mm2

				punpcklwd	mm2, mm2

				psrad		mm0, 16
				add			eax, 8

				movq		QWORD PTR [edi+eax*4  -32], mm0
				psrad		mm1, 16

				psrad		mm2, 16
				movq		QWORD PTR [edi+eax*4+8-32], mm1

				psrad		mm3, 16
				jl			lab

				movq		QWORD PTR [edi+eax*4+16-32],mm2
				movq		QWORD PTR [edi+eax*4+24-32], mm3
				jmp	 		done
#else
			lab:
				movq		mm0, QWORD PTR [esi+eax*2]
				movq		mm2, QWORD PTR [esi+eax*2+8]

				punpckhwd	mm1, mm0
				punpckhwd	mm3, mm2

				punpcklwd	mm0, mm0
				punpcklwd	mm2, mm2

				psrad		mm0, 16
				psrad		mm1, 16
				movq		QWORD PTR [edi+eax*4   ], mm0
				psrad		mm2, 16
				movq		QWORD PTR [edi+eax*4+8 ], mm1
				psrad		mm3, 16
				movq		QWORD PTR [edi+eax*4+16], mm2
				add			eax, 8
				movq		QWORD PTR [edi+eax*4+24-32], mm3
				jl			lab
				jmp	 		done

#endif
			onetime:
				movq	mm0, QWORD PTR [esi  -16]
				movq	mm2, QWORD PTR [esi+8-16]

				punpckhwd	mm1, mm0
				punpckhwd	mm3, mm2

				punpcklwd	mm0, mm0
				punpcklwd	mm2, mm2

				psrad		mm0, 16
				psrad		mm1, 16
				movq		QWORD PTR [edi   -32], mm0
				psrad		mm2, 16
				movq		QWORD PTR [edi+8 -32], mm1
				psrad		mm3, 16
				movq		QWORD PTR [edi+16-32], mm2
				movq		QWORD PTR [edi+24-32], mm3
			done:
				emms
			}
#endif
		}
		while (SampleCount--) {
			temp = (LONG)(*pIn16);
			pIn16++;

			*pOutputBuffer = temp;
			pOutputBuffer++;
		}

		return samplesleft;
	}
#endif

	return ConvertX(CurStage, SampleCount, samplesleft,	16, FALSE, nChannels, FALSE, FALSE);
}

ULONG ConvertMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pMappingTable;

    if (pMap) {
        _asm {
            mov ecx, SampleCount
            xor ebx, ebx

            cmp ecx, 0
            jz Done1
            
            xor eax, eax
            dec ecx
            
            mov edi, pOutputBuffer
            mov esi, pIn16
            
            push ebp
            mov ebp, pMap
            
            mov al, BYTE PTR [esi+ecx*2]
            mov bl, BYTE PTR [esi+ecx*2+1]
            
            jz Final1

    Loop1:
            mov edx, DWORD PTR [ebp+ebx*4+256]
            mov al, BYTE PTR [ebp+eax]

            add edx, eax
            mov al, BYTE PTR [esi+ecx*2]
            
            mov [edi+ecx*8], edx
            mov edx, DWORD PTR [ebp+ebx*4+1288+256]

            mov al, BYTE PTR [ebp+1288+eax]
            xor ebx, ebx

            add edx, eax
            mov al, BYTE PTR [esi+ecx*2-2]

            mov [edi+ecx*8+4], edx
            mov bl, BYTE PTR [esi+ecx*2-1]

            dec ecx
            jnz Loop1

    Final1:
            mov edx, DWORD PTR [ebp+ebx*4+256]
            mov al, BYTE PTR [ebp+eax]

            add edx, eax
            mov al, BYTE PTR [esi+ecx*2]
            
            mov [edi+ecx*8], edx
            mov edx, DWORD PTR [ebp+ebx*4+1288+256]

            mov al, BYTE PTR [ebp+1288+eax]

            add edx, eax

            mov [edi+ecx*8+4], edx

            pop ebp
    Done1:
        }
    } else {
    	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, FALSE, FALSE);
    }

    return SampleCount;
    
#else    
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, FALSE, FALSE);
#endif
}
	
ULONG ConvertStereoToMono16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	16, FALSE, FALSE);
}

ULONG Convert8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;
#if defined(GTW_OPTS) && defined(_X86_)
	if (MmxPresent()) {
		PLONG   pOutputBuffer = CurStage->pOutputBuffer;
		PBYTE	pIn8 = CurStage->pInputBuffer;
		LONG    temp;

		ULONG SC;
		samplesleft  = SampleCount;
		SampleCount *= nChannels;

		while (((DWORD)pIn8 & 0x07) && SampleCount) {
			temp = ((LONG)(*pIn8) - 0x80)*256;
			pIn8++;

			*pOutputBuffer = temp;
			pOutputBuffer++;
			SampleCount--;
		}

		SC = SampleCount >> 3;

		if (SC) {
			SampleCount &= 0x7;
#if 0
			while (SC--) {
#undef  ONESAMPLE
#define ONESAMPLE(x) \
				temp = ((LONG)(*pIn8) - 0x80)*256; \
				pOutputBuffer[x] = temp;

				ONESAMPLE(0);
				ONESAMPLE(1);
				ONESAMPLE(2);
				ONESAMPLE(3);
				ONESAMPLE(4);
				ONESAMPLE(5);
				ONESAMPLE(6);
				ONESAMPLE(7);

				pIn8+=8;
				pOutputBuffer+=8;
			}
#else	
			_asm {
				mov			eax, DWORD PTR SC
				mov			esi, DWORD PTR pIn8;

				shl			eax, 3				// * 8.
				mov 		edi, DWORD PTR pOutputBuffer;

				mov			edx, 128
				lea			esi, [esi+eax]	// Ending address...

				movd		mm4, edx	//   0,   0, 128, 128
				lea			edi, [edi+eax*4]

				punpcklwd	mm4, mm4	//   0,   0, 128, 128
				mov			DWORD PTR pIn8, esi

				punpckldq	mm4, mm4	// 128, 128, 128, 128
				pxor		mm7, mm7

				cmp			eax, 8
				mov			DWORD PTR pOutputBuffer, edi

				je			onetime

				neg			eax
				
#if 1
				movq		mm0, QWORD PTR [esi+eax]

				movq		mm2, mm0
				punpcklbw	mm0, mm7

				punpckhbw	mm2, mm7
				psubw		mm0, mm4

				psubw		mm2, mm4
				psllw		mm0, 8

				psllw		mm2, 8

				punpckhwd	mm1, mm0
				punpckhwd	mm3, mm2

				punpcklwd	mm0, mm0
				punpcklwd	mm2, mm2

				psrad		mm0, 16
				add			eax, 8

				psrad		mm1, 16
				movq		QWORD PTR [edi+eax*4  -32], mm0

				psrad		mm2, 16

			lab:

				psrad		mm3, 16
				movq		QWORD PTR [edi+eax*4+16-32],mm2

				movq		mm0, QWORD PTR [esi+eax]

				movq		mm2, mm0
				punpcklbw	mm0, mm7

				punpckhbw	mm2, mm7
				psubw		mm0, mm4

				psllw		mm0, 8
				psubw		mm2, mm4

				psllw		mm2, 8
				movq		QWORD PTR [edi+eax*4+8-32], mm1

				punpckhwd	mm1, mm0
				movq		QWORD PTR [edi+eax*4+24-32], mm3

				punpcklwd	mm0, mm0

				punpckhwd	mm3, mm2

				punpcklwd	mm2, mm2

				psrad		mm0, 16
				add			eax, 8

				movq		QWORD PTR [edi+eax*4  -32], mm0
				psrad		mm1, 16

				psrad		mm2, 16
				jl			lab

				movq		QWORD PTR [edi+eax*4+8-32], mm1
				psrad		mm3, 16

				movq		QWORD PTR [edi+eax*4+16-32],mm2
				movq		QWORD PTR [edi+eax*4+24-32], mm3
				jmp	 		done
#else
			lab:
				movq		mm0, QWORD PTR [esi+eax]

				movq		mm2, mm0
				punpcklbw	mm0, mm7
				punpckhbw	mm2, mm7
				psubw		mm0, mm4
				psubw		mm2, mm4
				psllw		mm0, 8
				psllw		mm2, 8

				punpckhwd	mm1, mm0
				punpckhwd	mm3, mm2

				punpcklwd	mm0, mm0
				punpcklwd	mm2, mm2

				psrad		mm0, 16
				psrad		mm1, 16
				movq		QWORD PTR [edi+eax*4   ], mm0
				psrad		mm2, 16
				movq		QWORD PTR [edi+eax*4+8 ], mm1
				psrad		mm3, 16
				movq		QWORD PTR [edi+eax*4+16], mm2
				add			eax, 8
				movq		QWORD PTR [edi+eax*4+24-32], mm3
				jl			lab
				jmp	 		done
#endif

			onetime:
				movq		mm0, QWORD PTR [esi  -8]

				movq		mm2, mm0
				punpcklbw	mm0, mm7
				punpckhbw	mm2, mm7
				psubw		mm0, mm4
				psubw		mm2, mm4
				psllw		mm0, 8
				psllw		mm2, 8

				punpckhwd	mm1, mm0
				punpcklwd	mm0, mm0

				punpckhwd	mm3, mm2
				punpcklwd	mm2, mm2

				psrad		mm0, 16
				psrad		mm1, 16
				movq		QWORD PTR [edi   -32], mm0
				psrad		mm2, 16
				movq		QWORD PTR [edi+8 -32], mm1
				psrad		mm3, 16
				movq		QWORD PTR [edi+16-32], mm2
				movq		QWORD PTR [edi+24-32], mm3
			done:
				emms
			}
#endif
		}
		while (SampleCount--) {
			temp = ((LONG)(*pIn8) - 0x80)*256;
			pIn8++;

			*pOutputBuffer = temp;
			pOutputBuffer++;
		}

		return samplesleft;
	}
#endif
	return ConvertX(CurStage, SampleCount, samplesleft,	8, FALSE, nChannels, FALSE, FALSE);
}

ULONG ConvertMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pMap = CurSink->pMappingTable;

    if (pMap) {
        return AsmConvertMonoToStereo8toX(CurStage, SampleCount, samplesleft);
    } else {
    	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, FALSE, FALSE);
    }
#else
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, FALSE, FALSE);
#endif
}
	
ULONG ConvertStereoToMono8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	8, FALSE, FALSE);
}

ULONG QuickMix16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;
	return ConvertX(CurStage, SampleCount, samplesleft,	16, TRUE, nChannels, TRUE, FALSE);
}

ULONG QuickMixMonoToStereo16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PSHORT  pIn16 = CurStage->pInputBuffer;
    PFLOAT  pMap = (PFLOAT)CurSink->pMappingTable;

    if (pMap) {
        _asm {
            mov ecx, SampleCount
            mov edx, pMap

            mov esi, pIn16
            mov edi, pFloatBuffer
            
            fld dword ptr [edx+1288+1280]
          	fld dword ptr [edx+1280]  

    		sub ecx, 2
    		jb Final1

    		mov edx, ecx

    Loop1:
    		fild word ptr [esi+ecx*2+2]	// x0
    		fild word ptr [esi+ecx*2+2]	// y0, x0
    		fxch st(1)                  // x0, y0
    		fmul st, st(2)              // x0*L, y0
    		fild word ptr [esi+ecx*2]	// x1, x0*L, y0
    		fild word ptr [esi+ecx*2]	// y1, x1, x0*L, y0
    		fxch st(1)		            // x1, y1, x0*L, y0
    		fmul st, st(4)              // x1*L, y1, x0*L, y0
    		fxch st(2)                  // x0*L, y1, x1*L, y0
    		fadd dword ptr [edi+ecx*8+8]    // x0*L+sumx0, y1, x1*L, y0
    		fxch st(3)                      // y0, y1, x1*L, x0*L+sumx0
    		fmul st, st(5)                  // y0*R, y1, x1*L, x0*L+sumx0
    		fxch st(2)                      // x1*L, y1, y0*R, x0*L+sumx0
    		fadd dword ptr [edi+ecx*8]      // x1*L+sumx1, y1, y0*R, x0*L+sumx0
    		fxch st(1)                      // y1, x1*L+sumx1, y0*R, x0*L+sumx0
    		fmul st, st(5)                  // y1*R, x1*L+sumx1, y0*R, x0*L+sumx0
    		fxch st(2)                      // y0*R, x1*L+sumx1, y1*R, x0*L+sumx0
    		fadd dword ptr [edi+ecx*8+12]   // y0*R+sumy0, x1*L+sumx1, y1*R, x0*L+sumx0
    		fxch st(3)                      // x0*L+sumx0, x1*L+sumx1, y1*R, y0*R+sumy0
    		fstp dword ptr [edi+ecx*8+8]    // x1*L+sumx1, y1*R, y0*R+sumy0
    		fstp dword ptr [edi+ecx*8]      // y1*R, y0*R+sumy0
    		fadd dword ptr [edi+ecx*8+4]    // y1*R+sumy1, y0*R+sumy0
    		fxch st(1)                      // y0*R+sumy0, y1*R+sumy1
    		fstp dword ptr [edi+ecx*8+12]   // y1*R+sumy1
    		sub ecx, 2
    		fstp dword ptr [edi+edx*8+4]

            mov edx, ecx
    		jae Loop1
    Final1:
    		and ecx, 1
    		jz Done1

    		fild word ptr [esi]		// x0
    		fild word ptr [esi]	    // y0, x0
    		fxch st(1)				// x0, y0
    		fmul st, st(2)			// x0*L, y0
    		fxch st(1)				// y0, x0*L
    		fmul st, st(3)			// y0*R, x0*L
    		fxch st(1)				// x0*L, y0*R
    		fadd dword ptr [edi]    // x0*L+sumx0, y0*R
    		fxch st(1)              // y0*R, x0*L+sumx0
    		fadd dword ptr [edi+4]  // y0*R+sumy0, x0*L+sumx0
    		fxch st(1)              // x0*L+sumx0, y0*R+sumy0
    		fstp dword ptr [edi]	// y0*R+sumy0
    		fstp dword ptr [edi+4]
    Done1:
            fstp st(0)                      // R
            fstp st(0)
        }
    } else {
    	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, TRUE, TRUE);
    }
    return SampleCount;
#else
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, TRUE, TRUE);
#endif
}
	
ULONG QuickMixStereoToMono16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	16, TRUE, TRUE);
}

ULONG QuickMix8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;
	return ConvertX(CurStage, SampleCount, samplesleft,	8, TRUE, nChannels, TRUE, FALSE);
}

ULONG QuickMixMonoToStereo8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pMappingTable;

    if (pMap) {
        _asm {
            mov ecx, SampleCount
            xor ebx, ebx

            cmp ecx, 0
            jz Done1
            
            xor eax, eax
            dec ecx
            
            mov edi, pOutputBuffer
            mov esi, pIn16
            
            push ebp
            mov ebp, pMap
            
            mov al, BYTE PTR [esi+ecx]
            mov bl, BYTE PTR [esi+ecx]
            
            jz Final1

    Loop1:
            fld dword ptr [ebp+ebx*4+1280+256]
            fadd dword ptr [edi+ecx*8+4]
            mov bl, BYTE PTR [esi+ecx-1]
            dec ecx
            fld dword ptr [ebp+eax*4+256]
            fadd dword ptr [edi+ecx*8+8]
            fxch st(1)
            fstp dword ptr [edi+ecx*8+12]
            fstp dword ptr [edi+ecx*8+8]
            
            mov al, BYTE PTR [esi+ecx]
            jnz Loop1

    Final1:
            fld dword ptr [ebp+ebx*4+1280+256]
            fadd dword ptr [edi+ecx*8+4]
            fld dword ptr [ebp+eax*4+256]
            fadd dword ptr [edi+ecx*8]
            fxch st(1)
            fstp dword ptr [edi+ecx*8+4]
            fstp dword ptr [edi+ecx*8]

            pop ebp
    Done1:
        }
    } else {
    	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, TRUE, TRUE);
    }

    return SampleCount;
#else
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, TRUE, TRUE);
#endif
}
	
ULONG QuickMixStereoToMono8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	8, TRUE, TRUE);
}

ULONG Convert16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PSHORT  pIn16 = CurStage->pInputBuffer;
    
	// convert to float asap
	samplesleft = SampleCount;
	SampleCount *= CurStage->nOutputChannels;
	_asm {
		mov esi, pIn16
		mov ecx, SampleCount

		mov edi, pFloatBuffer

		sub ecx, 8
		js LessThanEight

Loop8:
		fild WORD PTR [esi+ecx*2]
		fild WORD PTR [esi+ecx*2+2]
		fild WORD PTR [esi+ecx*2+4]
		fild WORD PTR [esi+ecx*2+6]
		fild WORD PTR [esi+ecx*2+8]
		fild WORD PTR [esi+ecx*2+10]
		fild WORD PTR [esi+ecx*2+12]
		fild WORD PTR [esi+ecx*2+14]
		fxch st(1)
		fstp DWORD PTR [edi+ecx*4+24]
		fstp DWORD PTR [edi+ecx*4+28]
		fstp DWORD PTR [edi+ecx*4+20]
		fstp DWORD PTR [edi+ecx*4+16]
		fstp DWORD PTR [edi+ecx*4+12]
		fstp DWORD PTR [edi+ecx*4+8]
		fstp DWORD PTR [edi+ecx*4+4]
		fstp DWORD PTR [edi+ecx*4]

		sub ecx, 8
		jns Loop8

LessThanEight:
		add ecx, 4
		js LessThanFour

		fild WORD PTR [esi+ecx*2]
		fild WORD PTR [esi+ecx*2+2]
		fild WORD PTR [esi+ecx*2+4]
		fild WORD PTR [esi+ecx*2+6]
		fxch st(1)
		fstp DWORD PTR [edi+ecx*4+8]
		fstp DWORD PTR [edi+ecx*4+12]
		fstp DWORD PTR [edi+ecx*4+4]
		fstp DWORD PTR [edi+ecx*4]

		sub ecx, 4

LessThanFour:
		add ecx, 2
		js LessThanTwo

		fild WORD PTR [esi+ecx*2]
		fild WORD PTR [esi+ecx*2+2]
		fxch st(1)
		fstp DWORD PTR [edi+ecx*4]
		fstp DWORD PTR [edi+ecx*4+4]

		sub ecx, 2

LessThanTwo:
		add ecx, 1
		js AllDone

		fild WORD PTR [esi+ecx*2]
		fstp DWORD PTR [edi+ecx*4]

AllDone:
	}
	
	return samplesleft;
#else	
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;

	return ConvertX(CurStage, SampleCount, samplesleft,	16, FALSE, nChannels, TRUE, FALSE);
#endif	
}

ULONG ConvertMonoToStereo16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    PSHORT  pIn16 = CurStage->pInputBuffer;
    PFLOAT  pMap = (PFLOAT)CurSink->pMappingTable;

    if (pMap) {
        _asm {
            mov ecx, SampleCount

            cmp ecx, 0
            jz Done1
            
            dec ecx
            mov edx, pMap
            
            mov edi, pFloatBuffer
            mov esi, pIn16
            
            fld DWORD PTR [edx+1288+1280]   // R
            fld DWORD PTR [edx+1280]        // L, R
            fild WORD PTR [esi+ecx*2]       // x, L, R
            fild WORD PTR [esi+ecx*2]       // x, x, L, R
            fxch st(1)                      // x, x, L, R
            fmul st, st(2)                  // x*L, x, L, R
            fxch st(1)                      // x, x*L, L, R
            jz Final1

    Loop1:
            fmul st, st(3)                  // x*R, x*L, L, R
            fxch st(1)                      // x*L, y*R, L, R
            fstp DWORD PTR [edi+ecx*8]      // x*R, L, R
            fstp DWORD PTR [edi+ecx*8+4]    // L, R
            fild WORD PTR [esi+ecx*2-2]     // x, L, R
            fild WORD PTR [esi+ecx*2-2]     // x, x, L, R
            fxch st(1)                      // x, x, L, R
            fmul st, st(2)                  // x*L, y, L, R
            fxch st(1)                      // x, x*L, L, R
            dec ecx
            jnz Loop1
    Final1:
            fmul st, st(3)                  // x*R, x*L, L, R
            fxch st(1)                      // x*L, x*R, L, R
            fstp DWORD PTR [edi+ecx*8]      // x*R, L, R
            fstp DWORD PTR [edi+ecx*8+4]    // L, R
            
            fstp st(0)                      // R
            fstp st(0)
    Done1:
        }
    } else {
    	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, FALSE, TRUE);
    }
    return SampleCount;
#else
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	16, FALSE, TRUE);
#endif
}
	
ULONG ConvertStereoToMono16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	16, FALSE, TRUE);
}

ULONG Convert8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
	ULONG nChannels = CurStage->nOutputChannels;
	return ConvertX(CurStage, SampleCount, samplesleft,	8, FALSE, nChannels, TRUE, FALSE);
}

ULONG ConvertMonoToStereo8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
#ifdef _X86_
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pMap = CurSink->pMappingTable;

    if (pMap) {
        return AsmConvertMonoToStereo8toX(CurStage, SampleCount, samplesleft);
    } else {
    	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, FALSE, TRUE);
    }
#else
	return ConvertMonoToStereoX(CurStage, SampleCount, samplesleft,	8, FALSE, TRUE);
#endif
}
	
ULONG ConvertStereoToMono8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertStereoToMonoX(CurStage, SampleCount, samplesleft,	8, FALSE, TRUE);
}

ULONG Convert24(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	24, FALSE, CurStage->nOutputChannels, FALSE, FALSE);
}

ULONG QuickMix24(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	24, TRUE, CurStage->nOutputChannels, FALSE, FALSE);
}

ULONG Convert24toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	24, FALSE, CurStage->nOutputChannels, TRUE, FALSE);
}

ULONG QuickMix24toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	24, TRUE, CurStage->nOutputChannels, TRUE, FALSE);
}

ULONG Convert32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	32, FALSE, CurStage->nOutputChannels, FALSE, FALSE);
}

ULONG QuickMix32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	32, TRUE, CurStage->nOutputChannels, FALSE, FALSE);
}

ULONG Convert32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	32, FALSE, CurStage->nOutputChannels, TRUE, FALSE);
}

ULONG QuickMix32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
	return ConvertX(CurStage, SampleCount, samplesleft,	32, TRUE, CurStage->nOutputChannels, TRUE, FALSE);
}

#if 0
	// This is the pseudo-C version of the MMX super mix
		// Do all the processing in integer, using the MMX tables
    samplesleft = SampleCount;
    SampleCount++;

	while (SampleCount--) {
		pSequence = pMixerSink->pSuperMixBlock;

		for (i=OutChannels; i > 0; i -= 4) {
			mm0 = 0; mm1 = 0;
			j = (pSequence->SequenceSize / sizeof(SUPERMIX_BLOCK))-1;
			InputChannel = pSequence[j+1].InputChannel;
			mm2 = *(pInputBuffer+InputChannel*4);
			mm3 = mm2;
			packssdw(mm2, mm2);
			pmaddwd(mm2, &pSequence[j].wMixLevel[0][0]);
			packssdw(mm3, mm3);
			pmaddwd(mm3, &pSequence[j].wMixLevel[2][0]);
			InputChannel = pSequence[j].InputChannel;

			for (; j; j--) {
				paddd(mm2, mm0);
				mm0 = *(pInputBuffer+InputChannel*4);
				paddd(mm3, mm1);
				mm1 = mm0;
				packssdw(mm0, mm0);
				pmaddwd(mm0, &pSequence[j-1].wMixLevel[0][0]);
				packssdw(mm1, mm1);
				pmaddwd(mm1, &pSequence[j-1].wMixLevel[2][0]);
				InputChannel = pSequence[j-1].InputChannel;
			}
				
			paddd(mm2, mm0);
			paddd(mm3, mm1);
			psrad(mm2, 14);
			pSequence += (pSequence->SequenceSize+sizeof(SUPERMIX_BLOCK));
			switch (i) {
				case 1:
					*(pOutputBuffer) = mm2;
					pOutputBuffer += 4;
					break;
				case 2:
					*(pOutputBuffer) = mm2;
					pOutputBuffer += 8;
					break;
				case 3:
					*(pOutputBuffer) = mm2;
					*(pOutputBuffer+16) = mm3;
					pOutputBuffer += 12;
					break;
				default: // i >= 4
					*(pOutputBuffer) = mm2;
					psrad(mm3, 14);
					*(pOutputBuffer+8) = mm3;
					pOutputBuffer += 16;
					break;
			}
		}

		pInputBuffer += InChannels*4;
	}
        
#endif    

#ifdef _X86_
ULONG
x86SuperMixUsingInt1x1
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = CurStage->nOutputChannels;
    ULONG	Zero = 0;
    PSUPERMIX_BLOCK	pSuperBlock;

	// 32-bit integer version
    samplesleft = SampleCount;
    pSuperBlock = pMixerSink->pSuperMixBlock;
    SampleCount++;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx

NextSample:
        mov ebx, SampleCount
        mov ecx, InChannels
        
        mov edi, pSuperBlock
        dec ebx

        mov SampleCount, ebx
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        jz AllDone

NextSeq:
        mov edx, DWORD PTR [edi+8]	// Size of this MAC block sequence
        mov ecx, [eax]

		shl ecx, 14
		mov pOutputBuffer, eax
		
        mov eax, DWORD PTR [edi+edx]	// Input channel number for this block

        // stall: 1 cycle for AGI on eax

Loop1:
		mov eax, [esi+eax*4]
		
		imul eax, [edi+edx-16]		// 11 cycles

		add ecx, eax
		mov eax, DWORD PTR [edi+edx-32]

		sub edx, 32
		jnz Loop1

		mov eax, pOutputBuffer
        mov edx, DWORD PTR [edi+8]
        
		sar ecx, 14
		dec ebx
        
        lea edi, [edi+edx+32]
        mov [eax], ecx

        lea eax, [eax+4]
        jnz NextSeq
        
        jmp NextSample

AllDone:
    }
		
    return samplesleft;
}

ULONG
x86SuperMixUsingFloat4x1
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = CurStage->nOutputChannels;
    ULONG	Zero = 0;
    PSUPERMIX_BLOCK	pSuperBlock;

	// This is the float version of the supermix block algorithm
    samplesleft = SampleCount;
    pSuperBlock = pMixerSink->pSuperMixBlock;
    SampleCount++;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx

NextSample:
        mov ebx, SampleCount
        mov ecx, InChannels
        
        mov edi, pSuperBlock
        dec ebx

        mov SampleCount, ebx
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        jz AllDone

NextSeq:
        mov edx, DWORD PTR [edi+8]	// Size of this MAC block sequence

		// Zero out the sums for the four output channels
		fld Zero
		fld Zero
		fld Zero
		fld Zero

        mov ecx, DWORD PTR [edi+edx]	// Input channel number for this block

Loop1:
		// Load the input sample four times
		fild DWORD PTR [esi+ecx*4]	// 3
		fild DWORD PTR [esi+ecx*4]	// 2,3
		fild DWORD PTR [esi+ecx*4]	// 1,2,3
		fld st(2)					// 0,1,2,3

		fmul DWORD PTR [edi+edx-16]	// Multiply by the mix level 0
		fxch st(1)					// 1,0,2,3

		// stall: 1 cycle for back-to-back fmul
		
		fmul DWORD PTR [edi+edx-12]	// Multiply by the mix level 1
		fxch st(1)					// 0,1,2,3

		faddp st(4), st				// Add to channel N+0
		fxch st(2)					// 3,2,1

		fmul DWORD PTR [edi+edx-4]	// Multiply by the mix level 3
		fxch st(2)					// 1,2,3

		faddp st(4), st				// Add to channel N+1
		
		fmul DWORD PTR [edi+edx-8]	// Multiply by the mix level 2
		fxch st(1)					// 3,2

		faddp st(5), st				// Add to channel N+3

		// stall: 1 cycle for dependency on previous fmul
        mov ecx, DWORD PTR [edi+edx-32]

		faddp st(3), st				// Add to channel N+2
		
		sub edx, 32
        jnz Loop1

        mov edx, DWORD PTR [edi+8]
        sub ebx, 4
        
        lea edi, [edi+edx+32]
        js NotFour

		// This is for MIX, not COPY!!!
		fadd DWORD PTR [eax]		// 0,1,2,3
		fxch st(1)					// 1,0,2,3
		fadd DWORD PTR [eax+4]
		fxch st(2)					// 2,0,1,3
		fadd DWORD PTR [eax+8]
		fxch st(3)					// 3,0,1,2
		fadd DWORD PTR [eax+12]
		fxch st(1)					// 0,3,1,2

		fistp DWORD PTR [eax]		// 3,1,2
		fistp DWORD PTR [eax+12]	// 1,2
		fistp DWORD PTR [eax+4]		// 2
		fistp DWORD PTR [eax+8]
        
        lea eax, [eax+16]
        jnz NextSeq

        jmp NextSample

NotFour:
		// ebx < 0
        add ebx, 2
        js Last1

		jz Last2
		
		// ebx == -1
		fadd DWORD PTR [eax]		// 0,1,2,3
		fxch st(1)					// 1,0,2,3
		fadd DWORD PTR [eax+4]
		fxch st(2)					// 2,0,1,3
		fadd DWORD PTR [eax+8]
		fxch st(3)					// 3,0,1,2
		fstp st(0)					// 0,1,2
		fistp DWORD PTR [eax]		// 1,2
		fistp DWORD PTR [eax+4]		// 2
		fistp DWORD PTR [eax+8]
		
        add eax, 12
        jmp NextSample

Last2:
		// ebx == -2
		fadd DWORD PTR [eax]		// 0,1,2,3
		fxch st(1)					// 1,0,2,3
		fadd DWORD PTR [eax+4]
		fxch st(2)					// 2,0,1,3
		fstp st(0)					// 0,1,3
		fistp DWORD PTR [eax]		// 1,3
		fistp DWORD PTR [eax+4]		// 3
		fstp st(0)

        lea eax, [eax+8]
        jmp NextSample

Last1:
		// ebx == -3
		fadd DWORD PTR [eax]		// 0,1,2,3
		fxch st(3)					// 3,1,2,0
		fstp st(0)					// 1,2,0
		fstp st(0)					// 2,0
		fstp st(0)					// 0
		fistp DWORD PTR [eax]
		
        add eax, 4
        jmp NextSample

AllDone:
    }
		
    return samplesleft;
}

ULONG
x86SuperMixUsingFloat2x2
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = CurStage->nOutputChannels;
    ULONG	Zero = 0;
    PSUPERMIX_BLOCK	pSuperBlock;

	// This is the float version of the supermix block algorithm
    samplesleft = SampleCount;
    pSuperBlock = pMixerSink->pSuperMixBlock;
    SampleCount++;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx

NextSample:
        mov ebx, SampleCount
        mov ecx, InChannels
        
        mov edi, pSuperBlock
        dec ebx

        mov SampleCount, ebx
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        jz AllDone

NextSeq:
        mov edx, DWORD PTR [edi+8]	// Size of this MAC block sequence

		// Zero out the sums for the two output channels
		fld Zero
		fld Zero

        mov ecx, DWORD PTR [edi+edx]	// Input channel number for this block

Loop1:
		// Load the input samples
		fild DWORD PTR [esi+ecx*4]		// 0
		fild DWORD PTR [esi+ecx*4+4]	// 3,0
		fild DWORD PTR [esi+ecx*4+4]	// 2,3,0
		fld st(2)						// 1,2,3,0

		// mix level (x,y) = Output Channel x, Input Channel y
		fmul DWORD PTR [edi+edx-8]	// Multiply by the mix level 1,0
		fxch st(1)					// 2,1,3,0

		// stall: 1 cycle for back-to-back fmul
		
		fmul DWORD PTR [edi+edx-12]	// Multiply by the mix level 0,1
		fxch st(1)					// 1,2,3,0

		faddp st(5), st				// Add to channel N+1
		fxch st(2)					// 0,3,2
		
		fmul DWORD PTR [edi+edx-16]	// Multiply by the mix level 0,0
		fxch st(2)					// 2,3,0

		faddp st(3), st				// Add to channel N+0
		
		fmul DWORD PTR [edi+edx-4]	// Multiply by the mix level 1,1
		fxch st(1)					// 0,3

		faddp st(2), st				// Add to channel N+0

		// stall: 1 cycle for dependency on previous fmul
        mov ecx, DWORD PTR [edi+edx-32]

		faddp st(2), st				// Add to channel N+1
		
		sub edx, 32
        jnz Loop1

        mov edx, DWORD PTR [edi+8]
        sub ebx, 2
        
        lea edi, [edi+edx+32]
        js Last1

		// Write out the output samples
		// This is for MIX, not COPY!!!
		fild DWORD PTR [eax]		// x,0,1
		fild DWORD PTR [eax+4]		// y,x,0,1
		fxch st(1)					// x,y,0,1
		faddp st(2),st				// y,0,1
		faddp st(2),st				// 0,1

		// stall: 1 cycle for dependency on first fadd

		fistp DWORD PTR [eax]		// 1
		fistp DWORD PTR [eax+4]
        
        lea eax, [eax+8]
        jnz NextSeq

        jmp NextSample

Last1:
		// ebx == -1
		fild DWORD PTR [eax]		// x,0,1
		fxch st(2)					// 1,0,x
		fstp st(0)					// 0,x
		faddp st(1),st				// 0
		fistp DWORD PTR [eax]
		
        add eax, 4
        jmp NextSample

AllDone:
    }
		
    return samplesleft;
}

ULONG
x86SuperMixSingleBlockUsingFloat2x2
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = CurStage->nOutputChannels;
    ULONG	Zero = 0;
    PSUPERMIX_BLOCK	pSuperBlock;

	// This is the float version of the supermix block algorithm
    samplesleft = SampleCount;
    pSuperBlock = pMixerSink->pSuperMixBlock;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx
        mov edx, SampleCount

		// If we have nothing to do, get out of here.
        test edx,edx
        jz AllDone

        // We want to do SampleCount-1 iterations of the fast loop (because we can touch the next sample)

NextSample:
        mov ecx, InChannels
        dec edx
        
        mov edi, pSuperBlock
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        mov ecx, DWORD PTR [edi+32]		// Input channel number for this block
        
        jz LastSample

NextSeq:
		// Load the input samples
		fild DWORD PTR [esi+ecx*4]		// 1
		fild DWORD PTR [eax+4]			// y,1
		fild DWORD PTR [eax]			// x,y,1
		fild DWORD PTR [esi+ecx*4+4]	// 2,x,y,1
		fld st(3)						// 0,2,x,y,1
		fmul DWORD PTR [edi+16]			// Multiply by mix level 0,0
		fxch st(1)						// 2,a0,x,y,1

		fld st(0)						// 3,2,a0,x,y,1
		
		fmul DWORD PTR [edi+28]			// Multiply by mix level 1,1: d3,2,a0,x,y,1
		fxch st(1)						// 2,d3,a0,x,y,1

		// stall: 1 cycle for back-to-back fmul
		
		fmul DWORD PTR [edi+24]			// Multiply by mix level 0,1: c2,d3,a0,x,y,1
		fxch st(2)						// a0,d3,c2,x,y,1

		faddp st(3),st					// d3,c2,x,y,1
		fxch st(4)						// 1,c2,x,y,d3

		fmul DWORD PTR [edi+20]			// Multiply by mix level 1,0: b1,c2,x,y,d3
		fxch st(4)						// d3,c2,x,y,b1

		faddp st(3),st					// c2,x,y,b1

		faddp st(1),st					// x,y,b1
		fxch st(2)						// b1,y,x

		// stall: 1 cycle for fadd
        sub ebx, 2
        lea edi, [edi+64]
		
		faddp st(1),st					// y,x
		fxch st(1)						// x,y

		fistp DWORD PTR [eax]			// y

        mov ecx, DWORD PTR [edi+32]		// Input channel number for this block
        js Last1

		fistp DWORD PTR [eax+4]
        
        lea eax, [eax+8]
        jnz NextSeq

        mov ecx, InChannels
        dec edx
        
        mov edi, pSuperBlock
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        mov ecx, DWORD PTR [edi+32]		// Input channel number for this block

		jnz NextSeq
        
        jmp LastSample
		
Last1:
		// ebx == -1
		fstp st(0)
		
        add eax, 4
        jmp NextSample

LastSample:
        mov ecx, DWORD PTR [edi+32]		// Input channel number for this block

		// Load the input samples
		fild DWORD PTR [esi+ecx*4]		// 1
		fild DWORD PTR [eax]			// x,1
		fild DWORD PTR [esi+ecx*4+4]	// 2,x,1
		fld st(2)						// 0,2,x,1
		fmul DWORD PTR [edi+16]			// Multiply by mix level 0,0
		fxch st(1)						// 2,a0,x,1

		fld st(0)						// 3,2,a0,x,1
		
		fmul DWORD PTR [edi+28]			// Multiply by mix level 1,1: d3,2,a0,x,1
		fxch st(1)						// 2,d3,a0,x,1

		// stall: 1 cycle for back-to-back fmul
		
		fmul DWORD PTR [edi+24]			// Multiply by mix level 0,1: c2,d3,a0,x,1
		fxch st(2)						// a0,d3,c2,x,1

		faddp st(3),st					// d3,c2,x,1
		fxch st(3)						// 1,c2,x,d3

		fmul DWORD PTR [edi+20]			// Multiply by mix level 1,0: b1,c2,x,d3
		fxch st(1)						// c2,b1,x,d3

		// stall: 1 cycle for fadd

		faddp st(2),st					// b1,x,d3

		faddp st(2),st					// x,d3+b1

		// stall: 1 cycle for fadd
        sub ebx, 2
		
		fistp DWORD PTR [eax]			// d3+b1

        lea edi, [edi+64]
        js LastFinal1

		fild DWORD PTR [eax+4]			// y,d3+b1

		// stall: 2 cycles for fild

		faddp st(1),st					// y

		// stall: 2 cycles for fadd
		
		fistp DWORD PTR [eax+4]
        
        lea eax, [eax+8]
        jnz LastSample

        jmp AllDone

LastFinal1:
		// ebx == -1
		fstp st(0)

AllDone:
    }
		
    return samplesleft;
}

ULONG
x86SuperMixFloatSingleBlock2x2
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = CurStage->nOutputChannels;
    ULONG	Zero = 0;
    PSUPERMIX_BLOCK	pSuperBlock;

	// This is the float version of the supermix block algorithm
    samplesleft = SampleCount;
    pSuperBlock = pMixerSink->pSuperMixBlock;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx
        mov edx, SampleCount

		// If we have nothing to do, get out of here.
        test edx,edx
        jz AllDone

        // We want to do SampleCount-1 iterations of the fast loop (because we can touch the next sample)

NextSample:
        mov ecx, InChannels
        dec edx
        
        mov edi, pSuperBlock
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        mov ecx, DWORD PTR [edi+32]		// Input channel number for this block
        
        jz LastSample

NextSeq:
		// Load the input samples
		fld DWORD PTR [esi+ecx*4+4]	// 1
		fld DWORD PTR [esi+ecx*4]	// 2,1
		fld st(0)					// 0,2,1
		fmul DWORD PTR [edi+16]		// Multiply by mix level 0,0
		fxch st(1)					// 2,a0,1
		
		fld st(2)					// 3,2,a0,1
		
		fmul DWORD PTR [edi+28]		// Multiply by mix level 1,1: d3,2,a0,1
		fxch st(1)					// 2,d3,a0,1

		// stall: 1 cycle for back-to-back fmul
		
		fmul DWORD PTR [edi+24]		// Multiply by mix level 0,1: c2,d3,a0,1
		fxch st(2)					// a0,d3,c2,1

		fadd DWORD PTR [eax]		// x,d3,c2,1
		fxch st(3)					// 1,d3,c2,x

		fmul DWORD PTR [edi+20]		// Multiply by mix level 1,0: b1,d3,c2,x
		fxch st(1)					// d3,b1,c2,x

		fadd DWORD PTR [eax+4]		// y,b1,c2,x
		fxch st(2)					// c2,b1,y,x

		faddp st(3),st				// b1,y,x

		// stall: 1 cycle for fadd
        sub ebx, 2
        lea edi, [edi+64]
		
		faddp st(1),st				// y,x
		fxch st(1)					// x,y

		fstp DWORD PTR [eax]		// y

        mov ecx, DWORD PTR [edi+32]	// Input channel number for this block
        js Last1

		fstp DWORD PTR [eax+4]
        
        lea eax, [eax+8]
        jnz NextSeq

        mov ecx, InChannels
        dec edx
        
        mov edi, pSuperBlock
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        mov ecx, DWORD PTR [edi+32]	// Input channel number for this block

		jnz NextSeq
        
        jmp LastSample
		
Last1:
		// ebx == -1
		fstp st(0)
		
        add eax, 4
        jmp NextSample

LastSample:
        mov ecx, DWORD PTR [edi+32]		// Input channel number for this block

		// Load the input samples
		fld DWORD PTR [esi+ecx*4+4]	// 1
		fld DWORD PTR [esi+ecx*4]	// 2,1
		fld st(0)					// 0,2,1
		fmul DWORD PTR [edi+16]		// Multiply by mix level 0,0
		fxch st(1)					// 2,a0,1

		fld st(2)					// 3,2,a0,1
		
		fmul DWORD PTR [edi+28]		// Multiply by mix level 1,1: d3,2,a0,1
		fxch st(1)					// 2,d3,a0,1

		// stall: 1 cycle for back-to-back fmul
		
		fmul DWORD PTR [edi+24]		// Multiply by mix level 0,1: c2,d3,a0,1
		fxch st(2)					// a0,d3,c2,1

		fadd DWORD PTR [eax]		// x,d3,c2,1
		fxch st(3)					// 1,d3,c2,x

		fmul DWORD PTR [edi+20]		// Multiply by mix level 1,0: b1,d3,c2,x
		fxch st(2)					// c2,d3,b1,x

		// stall: 1 cycle for fadd

		faddp st(3),st				// d3,b1,x

		faddp st(1),st				// d3+b1,x
		fxch st(1)					// x,d3+b1

		// stall: 1 cycle for fadd
        sub ebx, 2
		
		fstp DWORD PTR [eax]		// d3+b1

        lea edi, [edi+64]
        js LastFinal1

		fadd DWORD PTR [eax+4]			// y

		// stall: 2 cycles for fadd
		
		fstp DWORD PTR [eax+4]
        
        lea eax, [eax+8]
        jnz LastSample

        jmp AllDone

LastFinal1:
		// ebx == -1
		fstp st(0)

AllDone:
    }
		
    return samplesleft;
}
#endif // _X86_


ULONG __forceinline
Super_X
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
   	BOOL					fMixOutput,
   	BOOL                    fFloatOutput
)
{
    ULONG   i;
    PFLOAT  pMixLevel;
    ULONG   j;
    FLOAT   sum;
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = CurStage->nOutputChannels;
    ULONG	Zero = 0;
    PSUPERMIX_BLOCK	pSuperBlock = pMixerSink->pSuperMixBlock;

    samplesleft = SampleCount;
	if (fFloatOutput) {
#ifdef _X86_
		if (!MmxPresent()) {
			// This is the x86 version of the supermix block algorithm
	        if (OutChannels <= BLOCK_SIZE_OUT && pSuperBlock[0].SequenceSize == sizeof(SUPERMIX_BLOCK)) {
	            // Single block
			    if (!fMixOutput) {
			        // We just clear the output buffer first.
			        ZeroBuffer32(CurStage, SampleCount, samplesleft);
			    }

	            return x86SuperMixFloatSingleBlock2x2(CurStage, SampleCount, samplesleft);
	        }
        }
#endif // not _X86_

	    // Remember: pMixLevelArray[x*OutChannels + y]
	    // 			 is the gain for input channel x before it is mixed to y
	    while (SampleCount--) {
	        for (i = 0; i < OutChannels; i++) {
	            pMixLevel = pMixerSink->pMixLevelArray+i;
	            sum = 0;
	            for ( j=0; j<InChannels; j++ ) {
                    sum += (*pMixLevel)*(pInputBuffer[j]);
	                pMixLevel += OutChannels;
	            }
	            
	            if (fMixOutput) {
                    *pOutputBuffer += sum;
	            } else {
                    *pOutputBuffer = sum;
	            }

	            pOutputBuffer++;
	        }
					
	        // Increment to next set of samples
	        pInputBuffer += InChannels;
	    }
    } else {
#ifdef _X86_
		if (!MmxPresent()) {
			// This is the x86 version of the supermix block algorithm
		    if (!fMixOutput) {
		        // We just clear the output buffer first.
		        ZeroBuffer32(CurStage, SampleCount, samplesleft);
		    }

	        if (OutChannels <= BLOCK_SIZE_OUT && pSuperBlock[0].SequenceSize == sizeof(SUPERMIX_BLOCK)) {
	            // Single block
	            return x86SuperMixSingleBlockUsingFloat2x2(CurStage, SampleCount, samplesleft);
	        } else {
	            // More than one block
	            return x86SuperMixUsingFloat2x2(CurStage, SampleCount, samplesleft);
	        }
	    }
#else // not _X86_
	    // Remember: pMixLevelArray[x*OutChannels + y]
	    // 			 is the gain for input channel x before it is mixed to y
	    samplesleft = SampleCount;
	    while (SampleCount--) {
	        for (i = 0; i < OutChannels; i++) {
	            pMixLevel = pMixerSink->pMixLevelArray+i;
	            sum = 0;
	            for ( j=0; j<InChannels; j++ ) {
                    sum += (*pMixLevel)*(((PLONG)pInputBuffer)[j]);
	                pMixLevel += OutChannels;
	            }
	            
	            if (fMixOutput) {
                    MixFloat((PLONG)pOutputBuffer, sum);
	            } else {
                    *((PLONG)pOutputBuffer) = ConvertFloatToLong(sum);
	            }

	            pOutputBuffer++;
	        }
					
	        // Increment to next set of samples
	        pInputBuffer += InChannels;
	    }
#endif // _X86_
    }
		
    return samplesleft;
}

#ifdef _X86_
ULONG __forceinline
MmxSuperMixSingleBlock
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PSUPERMIX_BLOCK  pMixLevel;
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = pMixerSink->nOutputChannels;

    // Always 2 channels out of the 3D stage
    if (pMixerSink->fEnable3D) {
        InChannels = 2;
    }
	
    // Remember: pMixLevelArray[x*OutChannels + y]
    // 			 is the gain for input channel x before it is mixed to y
    samplesleft = SampleCount;
    pMixLevel = pMixerSink->pSuperMixBlock;
    SampleCount++;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx
        mov edx, SampleCount
        
        mov ebx, OutChannels    // ebx == OutChannels <= 4
        mov edi, pMixLevel

        mov ecx, [edi+32]

        lea esi, [esi+ecx*4]
        mov ecx, InChannels

        lea esi, [esi+ecx*4]
        dec edx
        
		movq	mm6, qword ptr [edi+16]
		movq	mm7, qword ptr [edi+24]
        jz AllDone

        // Note: we assume here that the buffer is big enough for 4 extra samples
//#define GTW_OPTS_SUPER	not enough of a win, 1.5 fewer instr/loop
#ifdef GTW_OPTS_SUPER
		push	edx
		sar		edx, 1
		jz		OnlyOne

NextSeq:
        movq mm2, qword ptr [esi]
        movq mm4, [eax]

        packssdw mm2, mm2
        movq mm5, [eax+8]

        movq mm3, mm2
        pmaddwd mm2, mm6

        psrad mm2, 14
        pmaddwd mm3, mm7

        movq mm0, qword ptr [esi+ecx*4]
        paddd mm2, mm4

        psrad mm3, 14
        movq qword ptr [eax], mm2

        paddd mm3, mm5
        packssdw mm0, mm0

        movq qword ptr [eax+8], mm3
        movq mm3, mm0

        dec edx
        pmaddwd mm0, mm6

        movq mm4, [eax+ebx*4]
        pmaddwd mm3, mm7

        psrad mm0, 14
        movq mm5, [eax+ebx*4+8]

        paddd mm0, mm4
        psrad mm3, 14

        movq qword ptr [eax+ebx*4], mm0
        paddd mm3, mm5

        movq qword ptr [eax+ebx*4+8], mm3
        lea eax, [eax+ebx*8]

        lea esi, [esi+ecx*8]
        jnz NextSeq

OnlyOne:
		pop 	edx
		test	edx, 1
		jz AllDone

        movq mm2, qword ptr [esi]
        packssdw mm2, mm2

        movq mm3, mm2
        pmaddwd mm2, mm6

        pmaddwd mm3, mm7
        movq mm4, [eax]

        movq mm5, [eax+8]
        psrad mm2, 14

        paddd mm2, mm4
        psrad mm3, 14
        
        movq qword ptr [eax], mm2
        paddd mm3, mm5

        movq qword ptr [eax+8], mm3
#else
NextSeq:

        movq mm2, qword ptr [esi]
        lea esi, [esi+ecx*4]

        packssdw mm2, mm2
        dec edx

        movq mm3, mm2
        pmaddwd mm2, mm6

        movq mm4, [eax]
        pmaddwd mm3, mm7

        movq mm5, [eax+8]
        psrad mm2, 14

        paddd mm2, mm4
        psrad mm3, 14
        
        movq qword ptr [eax], mm2
        paddd mm3, mm5

        movq qword ptr [eax+8], mm3
        lea eax, [eax+ebx*4]

        jnz NextSeq
#endif

AllDone:    emms
    }
        
    return samplesleft;
}

ULONG __forceinline
MmxSuperMix
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PSUPERMIX_BLOCK  pMixLevel;
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = pMixerSink->nOutputChannels;

    // Always 2 channels out of the 3D stage
    if (pMixerSink->fEnable3D) {
        InChannels = 2;
    }
	
    // Remember: pMixLevelArray[x*OutChannels + y]
    // 			 is the gain for input channel x before it is mixed to y
    samplesleft = SampleCount;
    pMixLevel = pMixerSink->pSuperMixBlock;
    SampleCount++;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx

NextSample:
        mov ebx, SampleCount
        mov ecx, InChannels
        
        mov edi, pMixLevel
        dec ebx

        mov SampleCount, ebx
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        jz AllDone

NextSeq:
        pxor mm0, mm0
        mov edx, [edi+8]          // Size of this MAC block sequence

        pxor mm1, mm1
        mov ecx, [edi+edx]       // Input channel number for this block

        movq mm2, qword ptr [esi+ecx*4]
        sub edx, 32

        packssdw mm2, mm2
        movq mm3, mm2
        
        pmaddwd mm2, qword ptr [edi+edx+16]
        mov ecx, [edi+edx]

        pmaddwd mm3, qword ptr [edi+edx+24]
        jz SeqDone

Loop1:
        paddd mm2, mm0
        sub edx, 32

        movq mm0, qword ptr [esi+ecx*4]
        paddd mm3, mm1

        packssdw mm0, mm0
        movq mm1, mm0
        
        pmaddwd mm0, qword ptr [edi+edx+16]
        mov ecx, [edi+edx]

        pmaddwd mm1, qword ptr [edi+edx+24]
        jnz Loop1

SeqDone:
        mov edx, [edi+8]
        paddd mm2, mm0

        sub ebx, 4
        paddd mm3, mm1
        
        psrad mm2, 14
        
        lea edi, [edi+edx+32]
        js NotFour

        movq mm4, [eax]
        psrad mm3, 14

        movq mm5, [eax+8]
        lea eax, [eax+16]

        paddd mm2, mm4
        paddd mm3, mm5

        movq qword ptr [eax-16], mm2
        movq qword ptr [eax-8], mm3
        
        jnz NextSeq

        jmp NextSample

NotFour:
        add ebx, 2
        js Last1

        movq mm4, [eax]
        lea eax, [eax+8]

        paddd mm2, mm4
        
        movq qword ptr [eax-8], mm2
        jz NextSample

        movd mm5, [eax]
        add eax, 4

        paddd mm3, mm5

        movd [eax-4], mm3

        jmp NextSample

Last1:
        movd mm4, [eax]
        add eax, 4

        paddd mm2, mm4
        
        movd [eax-4], mm2
        jmp NextSample

AllDone:    emms
    }
        
    return samplesleft;
}
#endif

ULONG SuperMix(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PSUPERMIX_BLOCK  pMixLevel = pMixerSink->pSuperMixBlock;
    ULONG   OutChannels = pMixerSink->nOutputChannels;

#if _X86_
    if (MmxPresent()) {
        if (OutChannels <= 4 && pMixLevel[0].SequenceSize == sizeof(SUPERMIX_BLOCK)) {
            // Single block
            return MmxSuperMixSingleBlock(CurStage, SampleCount, samplesleft);
        } else {
            // More than one block
            return MmxSuperMix(CurStage, SampleCount, samplesleft);
        }
    }
#endif
    return Super_X(CurStage, SampleCount, samplesleft, TRUE, FALSE);
}

#ifdef _X86_
ULONG __forceinline
MmxSuperCopySingleBlock
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PSUPERMIX_BLOCK  pMixLevel;
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = pMixerSink->nOutputChannels;

    // Always 2 channels out of the 3D stage
    if (pMixerSink->fEnable3D) {
        InChannels = 2;
    }
	
    // Remember: pMixLevelArray[x*OutChannels + y]
    // 			 is the gain for input channel x before it is mixed to y
    samplesleft = SampleCount;
    pMixLevel = pMixerSink->pSuperMixBlock;
    SampleCount++;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx
        mov edx, SampleCount
        
        mov ebx, OutChannels    // ebx == OutChannels <= 4
        mov edi, pMixLevel

        mov ecx, [edi+32]

        lea esi, [esi+ecx*4]
        mov ecx, InChannels

        lea esi, [esi+ecx*4]
        dec edx
        
		movq	mm4, qword ptr [edi+16]
		movq	mm5, qword ptr [edi+24]
        jz AllDone

        // Note: we assume here that the buffer is big enough for 4 extra samples
#ifdef GTW_OPTS_SUPER
		push	edx
		sar		edx, 1
		jz		OnlyOne

NextSeq:
        movq mm2, qword ptr [esi]           // x1, x0
        dec edx

        packssdw mm2, mm2                   // x1, x0, x1, x0
        movq mm0, qword ptr [esi+ecx*4]           // x1, x0

        movq mm3, mm2                       // x1, x0
        pmaddwd mm2, mm4     				// x1*b1+x0*b0, x1*a1+x0*a0

        psrad mm2, 14                       // x1*b1+x0*b0, x1*a1+x0*a0
        pmaddwd mm3, mm5					// x1*d1+x0*d0, x1*c1+x0*c0
        
        movq qword ptr [eax], mm2
        psrad mm3, 14

        movq qword ptr [eax+8], mm3
        packssdw mm0, mm0                   // x1, x0, x1, x0

        movq mm3, mm0                       // x1, x0
        pmaddwd mm0, mm4     				// x1*b1+x0*b0, x1*a1+x0*a0

        psrad mm0, 14                       // x1*b1+x0*b0, x1*a1+x0*a0
        pmaddwd mm3, mm5					// x1*d1+x0*d0, x1*c1+x0*c0
        
        movq qword ptr [eax+ebx*4], mm0
        psrad mm3, 14

        movq qword ptr [eax+ebx*4+8], mm3
        lea esi, [esi+ecx*8]
        
        lea eax, [eax+ebx*8]
        jnz NextSeq

OnlyOne:
		pop		edx
		test	edx, 1
		jz		AllDone

        movq mm2, qword ptr [esi]           // x1, x0

        packssdw mm2, mm2                   // x1, x0, x1, x0
        movq mm3, mm2                       // x1, x0
        
        pmaddwd mm2, mm4     				// x1*b1+x0*b0, x1*a1+x0*a0

        pmaddwd mm3, mm5					// x1*d1+x0*d0, x1*c1+x0*c0
        psrad mm2, 14                       // x1*b1+x0*b0, x1*a1+x0*a0
        
        movq qword ptr [eax], mm2
        psrad mm3, 14

        movq qword ptr [eax+8], mm3
#else
NextSeq:
        movq mm2, qword ptr [esi]           // x1, x0
        lea esi, [esi+ecx*4]

        packssdw mm2, mm2                   // x1, x0, x1, x0
        movq mm3, mm2                       // x1, x0
        
        pmaddwd mm2, mm4     				// x1*b1+x0*b0, x1*a1+x0*a0
        dec edx

        pmaddwd mm3, mm5					// x1*d1+x0*d0, x1*c1+x0*c0
        psrad mm2, 14                       // x1*b1+x0*b0, x1*a1+x0*a0
        
        movq qword ptr [eax], mm2
        psrad mm3, 14

        movq qword ptr [eax+8], mm3
        
        lea eax, [eax+ebx*4]
        jnz NextSeq
#endif

AllDone:    emms
    }
        
    return samplesleft;
}

ULONG __forceinline
MmxSuperCopy
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft
)
{
    PSUPERMIX_BLOCK  pMixLevel;
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = pMixerSink->nOutputChannels;

    // Always 2 channels out of the 3D stage
    if (pMixerSink->fEnable3D) {
        InChannels = 2;
    }
	
    // Remember: pMixLevelArray[x*OutChannels + y]
    // 			 is the gain for input channel x before it is mixed to y
    samplesleft = SampleCount;
    pMixLevel = pMixerSink->pSuperMixBlock;
    SampleCount++;
    _asm {
        mov esi, pInputBuffer
        mov ebx, InChannels

        shl ebx, 2
        mov eax, pOutputBuffer
        
        sub esi, ebx

NextSample:
        mov ebx, SampleCount
        mov ecx, InChannels
        
        mov edi, pMixLevel
        dec ebx

        mov SampleCount, ebx
        mov ebx, OutChannels

        lea esi, [esi+ecx*4]
        jz AllDone

NextSeq:
        pxor mm0, mm0
        mov edx, [edi+8]          // Size of this MAC block sequence

        pxor mm1, mm1
        mov ecx, [edi+edx]       // Input channel number for this block

        sub edx, 32
        movq mm2, qword ptr [esi+ecx*4]

        packssdw mm2, mm2
        movq mm3, mm2
        
        pmaddwd mm2, qword ptr [edi+edx+16]
        mov ecx, [edi+edx]

        pmaddwd mm3, qword ptr [edi+edx+24]
        jz SeqDone

Loop1:
        paddd mm2, mm0
        sub edx, 32

        movq mm0, qword ptr [esi+ecx*4]
        paddd mm3, mm1

        packssdw mm0, mm0
        movq mm1, mm0
        
        pmaddwd mm0, qword ptr [edi+edx+16]
        mov ecx, [edi+edx]

        pmaddwd mm1, qword ptr [edi+edx+24]
        jnz Loop1

SeqDone:
        mov edx, [edi+8]
        paddd mm2, mm0

        sub ebx, 4
        paddd mm3, mm1
        
        psrad mm2, 14
        
        lea edi, [edi+edx+32]
        js NotFour

        movq qword ptr [eax], mm2
        psrad mm3, 14

        movq qword ptr [eax+8], mm3
        
        lea eax, [eax+16]
        jnz NextSeq

        jmp NextSample

NotFour:
        add ebx, 2
        js Last1
        
        movq qword ptr [eax], mm2

        lea eax, [eax+8]
        jz NextSample

        movd [eax], mm3
        add eax, 4

        jmp NextSample

Last1:
        movd [eax], mm2
        add eax, 4

        jmp NextSample

AllDone:    emms
    }
        
    return samplesleft;
}

#endif

ULONG SuperCopy(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PFLOAT   pInputBuffer = (PFLOAT) CurStage->pInputBuffer;
    PFLOAT   pOutputBuffer = (PFLOAT) CurStage->pOutputBuffer;
    PMIXER_SINK_INSTANCE    pMixerSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PSUPERMIX_BLOCK  pMixLevel = pMixerSink->pSuperMixBlock;
    ULONG   InChannels = CurStage->nInputChannels;
    ULONG   OutChannels = pMixerSink->nOutputChannels;

    // Always 2 channels out of the 3D stage
    if (pMixerSink->fEnable3D) {
        InChannels = 2;
    }
	
    // Remember: pMixLevelArray[x*OutChannels + y]
    // 			 is the gain for input channel x before it is mixed to y
    samplesleft = SampleCount;
#if _X86_
    if (MmxPresent()) {
        if (OutChannels <= 4 && pMixLevel[0].SequenceSize == sizeof(SUPERMIX_BLOCK)) {
            // Single block
            return MmxSuperCopySingleBlock(CurStage, SampleCount, samplesleft);
        } else {
            // More than one block
            return MmxSuperCopy(CurStage, SampleCount, samplesleft);
        }
    }
#endif

    return Super_X(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG SuperMixFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    return Super_X(CurStage, SampleCount, samplesleft, TRUE, TRUE);
}

ULONG SuperCopyFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    return Super_X(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

#ifdef SURROUND_ENCODE

ULONG __forceinline
DolbyEncodeX
( 
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft,
    ULONG BitsPerSample,
    BOOL  fFloatOutput,
    BOOL  fMix
)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG  pOut = CurStage->pOutputBuffer;
    PFLOAT pFloat = CurStage->pOutputBuffer;
    PSHORT  pHistory, pIn16 = CurStage->pInputBuffer;
    PBYTE   pIn8 = CurStage->pInputBuffer;
    PLONG  pMap = CurSink->pVolumeTable;
    FLOAT   LeftVol, RightVol, CenterVol, SurroundVol;
    FLOAT    LeftSample, RightSample, CenterSample, SurroundSample;
    ULONG   i;
    FLOAT TinyFilter[] = {0.226664723532f,0.273335276468f,0.273335276468f,0.226664723532f};


    // Take the mono input and convert it to dolby pro-logic-encoded stereo
    LeftVol = (FLOAT) (pMap[0]/32768.0f);
    RightVol = (FLOAT) (pMap[1]/32768.0f);
    CenterVol = CurSink->CenterVolume;
    SurroundVol = CurSink->SurroundVolume;
    pHistory = &CurSink->SurHistory[0];
    for (i=0; i<SampleCount; i++) {
        pHistory[0] = pHistory[1];
        pHistory[1] = pHistory[2];
        pHistory[2] = pHistory[3];

        if (BitsPerSample == 16) {
            pHistory[3] = (SHORT) (pIn16[i]*SurroundVol);
            LeftSample = pIn16[i]*LeftVol;
            RightSample = pIn16[i]*RightVol;
            CenterSample = pIn16[i]*CenterVol;
        } else {
            pHistory[3] = (SHORT) ((pIn8[i] - 0x80)*256*SurroundVol);
            LeftSample = ((pIn8[i] - 0x80)*256*LeftVol);
            RightSample = ((pIn8[i] - 0x80)*256*RightVol);
            CenterSample = (pIn8[i] - 0x80)*256*CenterVol;
        }
        
        SurroundSample =  pHistory[3] * TinyFilter[0] +
                        pHistory[2] * TinyFilter[1] +
                        pHistory[1] * TinyFilter[2] +
                        pHistory[0] * TinyFilter[3];

        LeftSample = (LeftSample + SURSCALE*CenterSample - SURSCALE*SurroundSample)*0.4f;
        RightSample = (RightSample + SURSCALE*CenterSample + SURSCALE*SurroundSample)*0.4f;
                
        if (fMix) {
            if (fFloatOutput) {
                pFloat[i*2] += LeftSample;
                pFloat[i*2+1] += RightSample;
            } else {
                pOut[i*2] += (LONG) LeftSample;
                pOut[i*2+1] += (LONG) RightSample;
            }
        } else {
            if (fFloatOutput) {
                pFloat[i*2] = LeftSample;
                pFloat[i*2+1] = RightSample;
            } else {
                pOut[i*2] = (LONG) LeftSample;
                pOut[i*2+1] = (LONG) RightSample;
            }
        }
    }
    return SampleCount;
}

ULONG ConvertMono16toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 16, FALSE, FALSE );
}

ULONG ConvertMono8toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 8, FALSE, FALSE );
}

ULONG QuickMixMono16toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 16, FALSE, TRUE );
}

ULONG QuickMixMono8toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 8, FALSE, TRUE );
}

ULONG ConvertMono16toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 16, TRUE, FALSE );
}

ULONG ConvertMono8toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 8, TRUE, FALSE );
}

ULONG QuickMixMono16toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 16, TRUE, TRUE );
}

ULONG QuickMixMono8toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return DolbyEncodeX( CurStage, SampleCount, samplesleft, 8, TRUE, TRUE );
}

#ifdef NEW_SURROUND
#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4730)			
    // mixing _m64 and floating point expressions may result in incorrect code
    // Shouldn't be a problem here since only one of mmx or FP is actually used...
#pragma warning(disable:4799)
#endif

ULONG ConvertQuad32toDolby
( 
    PMIXER_SOURCE_INSTANCE  pMixerSource,
    PLONG   pIn,
    PLONG   pOut,
    ULONG   SampleCount
)
{
    PLONG  pHistory;
#ifndef _X86_    
    FLOAT  LeftSample, RightSample, CenterSample, SurroundSample;
#endif    
    ULONG  i;
    FLOAT TinyFilter[] = {0.226664723532f,0.273335276468f,0.273335276468f,0.226664723532f};
    FLOAT OptFilter[] = { 0.829255288453f,1.205901263367f,0.273335276468f,0.226664723532f};
    WORD MmxFilter[] = { 14854, 0, 17913, 0, 17913, 0, 14854, 0};
    LARGE_INTEGER MmxMask = { 0xffffffff, 0xffffffff };
    FLOAT   SurScale = SURSCALE;
    PFLOAT  pCoeff = &OptFilter[0];
    PWORD pMmxCoeff = &MmxFilter[0];
    KFLOATING_SAVE     FloatSave;

    SaveFloatState(&FloatSave);

    // Take the mono input and convert it to dolby pro-logic-encoded stereo
    pHistory = &pMixerSource->SurHistory[0];
#ifdef _X86_
    if (MmxPresent()) {
        _asm {
            mov esi, pHistory

            movq mm6, qword ptr [esi]

            movq mm7, qword ptr [esi+8]
        }
    }
#endif
    for (i=0; i<SampleCount; i++) {
#ifndef _X86_    
        pHistory[0] = pHistory[1];
        pHistory[1] = pHistory[2];
        pHistory[2] = pHistory[3];

        LeftSample = (FLOAT) pIn[i*4];
        RightSample = (FLOAT) pIn[i*4+1];
        CenterSample = (FLOAT) pIn[i*4+2];
        pHistory[3] = pIn[i*4+3];
        
        SurroundSample =  pHistory[3] * TinyFilter[0] +
                        pHistory[2] * TinyFilter[1] +
                        pHistory[1] * TinyFilter[2] +
                        pHistory[0] * TinyFilter[3];

        LeftSample = LeftSample + CenterSample - SurroundSample;
        RightSample = RightSample + CenterSample + SurroundSample;
                
        pOut[i*2] = ConvertFloatToLong(LeftSample);
        pOut[i*2+1] = ConvertFloatToLong(RightSample);
#else
    if (MmxPresent()) {
        _asm {
            // 18 cycles
            // assumes mm6 holds x1, x0
            // and mm7 holds x3, x2
            mov esi, pHistory
            mov edi, pIn

            mov ecx, i
            mov edx, pMmxCoeff

            shl ecx, 1
            
            movq mm4, [edx]         // 0, c1, 0, c0
            psrlq mm6, 32           // 0, x1
            
            movq mm5, [edx+8]       // 0, c3, 0, c2
            punpckldq mm6, mm7      // x2, x1

            punpckhdq mm7, qword ptr [edi+ecx*8+8]  // x4, x3
            movq mm0, mm6

            movq mm1, mm7
            pmaddwd mm0, mm4    // x1*c1, x0*c0

            movq mm3, [edi+ecx*8+8]   // S, C
            pmaddwd mm1, mm5    // x3*c3, x2*c2

            movq mm2, [edi+ecx*8]     // R, L
            punpckldq mm3, mm3  // C, C

            // extra cycle

            paddd mm0, mm1      // x1*c1+x3*c3, x0*c0+x2*c2

            movq mm1, mm0       // x1*c1+x3*c3, x0*c0+x2*c2
            psrlq mm0, 32       // 0, x1*c1+x3*c3

            paddd mm1, mm0      // x1*c1+x3*c3, S
            paddd mm2, mm3      // R+C, L+C

            pand mm1, MmxMask    // 0, S

            psrad mm1, 16
            mov eax, pOut

            psubd mm2, mm1      // R+C, L+C-S = Lt
            psllq mm1, 32       // S, 0

            paddd mm2, mm1      // R+C+S = Rt, Lt

            movq [eax+ecx*4], mm2
        }        
    } else {
        _asm {
            // 44 cycles
            mov esi, pHistory
            mov edi, pIn

            mov ecx, i
            mov edx, pCoeff

            shl ecx, 1
            mov eax, dword ptr [esi+4]
            
            mov ebx, dword ptr [esi+8]
            mov dword ptr [esi], eax
            
            mov eax, dword ptr [esi+12]
            mov dword ptr [esi+4], ebx
            
            mov dword ptr [esi+8], eax

            fild dword ptr [edi+ecx*8]      // L
            fild dword ptr [edi+ecx*8+4]    // R, L
            fild dword ptr [edi+ecx*8+12]   // x3, R, L
            fild dword ptr [edi+ecx*8+8]    // C, x3, R, L
            fld dword ptr [esi+8]           // x2, C, x3, R, L
            fmul dword ptr [edx+4]          // x2*c1/c3, C, x3, R, L
            fxch st(2)                      // x3, C, x2*c1/c3, R, L
            fst dword ptr [esi+12]          // x3, C, x2*c1/c3, R, L
            fmul dword ptr [edx]            // x3*c0/c2, C, x2*c1/c3, R, L
            fxch st(2)                      // x2*c1/c3, C, x3*c0/c2, R, L
            fadd dword ptr [esi]            // x0+x2*c1/c3, C, x3*c0/c2, R, L
            fxch st(2)                      // x3*c0/c2, C, x0+x2*c1/c3, R, L

            // extra cycle
            
            fadd dword ptr [esi+4]          // x1+x3*c0/c2, C, x0+x2*c1/c3, R, L
            fxch st(2)                      // x0+x2*c1/c3, C, x1+x3*c0/c2, R, L
            fmul dword ptr [edx+12]         // c3*x0+x2*c1, C, x1+x3*c0/c2, R, L
            fxch st(1)                      // C, c3*x0+x2*c1, x1+x3*c0/c2, R, L
            fadd st(4), st                  // C, c3*x0+x2*c1, x1+x3*c0/c2, R, L+C
            fxch st(2)                      // x1+x3*c0/c2, c3*x0+x2*c1, C, R, L+C
            fmul dword ptr [edx+8]          // x1*c2+x3*c0, c3*x0+x2*c1, C, R, L+C
            fxch st(2)                      // C, c3*x0+x2*c1, x1*c2+x3*c0, R, L+C
            faddp st(3), st                 // c3*x0+x2*c1, x1*c2+x3*c0, R+C, L+C

            // extra cycle

            faddp st(1), st                 // x0*c3+x1*c2+x2*c1+x3*c0 = S, R+C, L+C
            fxch st(2)                      // L+C, R+C, S

            // extra cycle
            
            mov edi, pOut

            fsub st, st(2)                  // Lt, R+C, S
            fxch st(2)                      // S, R+C, Lt
            faddp st(1), st                 // Rt, Lt
            fxch st(1)                      // Lt, Rt

            // extra cycle

            fistp dword ptr [edi+ecx*4]     // Rt
            fistp dword ptr [edi+ecx*4+4]
            }
        }
#endif
    }

#ifdef _X86_
    if (MmxPresent()) {
        _asm {
            mov esi, pHistory

            movq qword ptr [esi], mm6

            movq qword ptr [esi+8], mm7
            
            emms
        }
    }
#endif

    RestoreFloatState(&FloatSave);
    
    return SampleCount;
}
#endif

#endif

VOID __forceinline
AddStage
(
    PMIXER_SINK_INFO    pInfo,
    PVOID   pInputBuffer,
    PVOID   pfnStage,
    PVOID   Context,
    LONG    Index,
    ULONG   nOutputChannels
)
{
        if (pInfo->nStages) {
            pInfo->Stage[pInfo->nStages - 1].pOutputBuffer = pInputBuffer;
            pInfo->Stage[pInfo->nStages].nInputChannels = pInfo->Stage[pInfo->nStages - 1].nOutputChannels;
        }
            
        pInfo->Stage[pInfo->nStages].pInputBuffer = pInputBuffer;
        if (Index >= 0) {
            pInfo->Stage[pInfo->nStages].pfnStage = ((PFNStage *)pfnStage)[Index];
        } else {
            pInfo->Stage[pInfo->nStages].pfnStage = (PFNStage)pfnStage;
        }
        pInfo->Stage[pInfo->nStages].Context = Context;
        pInfo->Stage[pInfo->nStages].Index = Index;
        pInfo->Stage[pInfo->nStages].pOutputBuffer = NULL;
        pInfo->Stage[pInfo->nStages].FunctionArray = pfnStage;
        pInfo->Stage[pInfo->nStages].nOutputChannels = nOutputChannels;
#ifdef PERF_COUNT
		pInfo->Stage[pInfo->nStages].AverageTicks = 0;
#endif
        pInfo->nStages++;
}

VOID
GetOptimizerFlags
(
	PMIXER_SINK_INSTANCE 	CurSink,
	PMIXER_SOURCE_INSTANCE	pMixerSource,
	POPTIMIZER_FLAGS		pFlags
)
{
    // Set-up the optimization
    pFlags->InChannels = CurSink->WaveFormatEx.nChannels;
    pFlags->OutChannels = pMixerSource->WaveFormatEx.nChannels;
    pFlags->BitsPerSample = CurSink->WaveFormatEx.wBitsPerSample;
    
    pFlags->fEnableSrc = (CurSink->pInfo->Src.UpSampleRate != CurSink->pInfo->Src.DownSampleRate);
    pFlags->fEnableDoppler = (CurSink->fCreate3D && CurSink->pInfo->Doppler.UpSampleRate != CurSink->pInfo->Doppler.DownSampleRate);
    
    pFlags->fFloatInput = (CurSink->WaveFormatEx.wFormatTag == WAVE_FORMAT_IEEE_FLOAT);
    pFlags->fFloatInput |= (CurSink->WaveFormatEx.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
                    IsEqualGUID( &(CurSink->WaveFormatExt.SubFormat), &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT ) );
    
    if (pMixerSource->Header.PinId == PIN_ID_WAVEIN_SOURCE) {
        pFlags->InChannels = pMixerSource->WaveFormatEx.nChannels;
        pFlags->OutChannels = CurSink->WaveFormatEx.nChannels;
        pFlags->BitsPerSample = pMixerSource->WaveFormatEx.wBitsPerSample;
        pFlags->fFloatInput = (pMixerSource->WaveFormatEx.wFormatTag == WAVE_FORMAT_IEEE_FLOAT);
        pFlags->fFloatInput |= (pMixerSource->WaveFormatEx.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
                        IsEqualGUID( &(pMixerSource->WaveFormatExt.SubFormat), &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT ) );
    }
    pFlags->fEnableHiRes = (pFlags->BitsPerSample==24 || pFlags->BitsPerSample==32);
    
    pFlags->fEnableFloat = (CurSink->pInfo->Src.fRequiresFloat);
    pFlags->fEnableFloat |= (CurSink->fCreate3D && CurSink->pInfo->Doppler.fRequiresFloat);
    pFlags->fEnableFloat |= (pFlags->fFloatInput && !pFlags->fEnableSrc && !pFlags->fEnableDoppler);
    pFlags->fEnableFloat |= (pFlags->fEnableHiRes && !pFlags->fEnableSrc && !pFlags->fEnableDoppler);

    pFlags->fChannelConversion = (pFlags->InChannels != pFlags->OutChannels && 
                          pFlags->InChannels <= 2 && 
                          pFlags->OutChannels <=2 &&
                          !CurSink->fEnable3D &&
                          !pFlags->fEnableHiRes);

    // If the first SRC is being used, we must not convert channels first.                          
    if (CurSink->fCreate3D && 
        CurSink->pInfo->Doppler.UpSampleRate != CurSink->pInfo->Doppler.DownSampleRate) {
        pFlags->fChannelConversion = FALSE;
    }
    
    // The only case where super mix is NOT used is mono-to-stereo or stereo-to-mono.                       
    pFlags->fEnableSuperMix = (pFlags->fChannelConversion == FALSE);

	// If non-MMX supermix is required, use Float paths (unless SRC requires integer)
    pFlags->fEnableFloat |= (
#ifdef _X86_
                              !MmxPresent() && 
#endif
                              pFlags->fEnableSuperMix && 
                              !pFlags->fEnableSrc && 
                              !pFlags->fEnableDoppler);

    return;
}

VOID
OptimizeSink
(
    PMIXER_SINK_INSTANCE CurSink,
    PMIXER_SOURCE_INSTANCE  pMixerSource
)
{
    OPTIMIZER_FLAGS	Flags;
    LONG    Index;
    
    // Clear the current scenario
    CurSink->pInfo->nStages = 0;

    // Set-up the optimization
    GetOptimizerFlags(CurSink, pMixerSource, &Flags);

    CurSink->pActualSrc = &(CurSink->pInfo->Src);

    pMixerSource->fUsesFloat |= Flags.fEnableFloat;

    // Apply the best conversion
    // Assemble the index into the convert function pointer array
    // Convert stage
    // Bit map:
    // b0:  on when mix instead of copy
    // b1:  on when output buffer is float
    // b2:  on when 16-bit or 32-bit (depending on HiRes flag)
    // b3:  on when channel conversion is included, or FLOAT (for HiRes formats)
    // b4:  on when input is stereo (only used for channel conversion)
    // b5:  on when input is HiRes (24 or 32-bit)
    // b2-b5 map as follows:
    //      0000 = 8-bit n channels
    //      0001 = 16-bit n channels
    //      0010 = mono-to-stereo 8-bit
    //      0011 = mono-to-stereo 16-bit
    //      0100 = stereo 8-bit
    //      0101 = stereo 16-bit
    //      0110 = stereo-to-mono 8-bit
    //      0111 = stereo-to-mono 16-bit
    //      1x00 = 24-bit n channels
    //      1x01 = 32-bit n channels
    //      1x1x = Float n channels
    Index = (Flags.fEnableFloat ? CONVERT_FLAG_FLOAT : 0);
    Index |= ((Flags.BitsPerSample==16 || Flags.BitsPerSample==32) ? CONVERT_FLAG_16BIT : 0);
    Index |= (Flags.fChannelConversion ? CONVERT_FLAG_CHANGE_CHANNELS : 0);
    Index |= (Flags.fFloatInput ? CONVERT_FLAG_FLOAT_INPUT : 0);
    Index |= ((Flags.InChannels==2 && Flags.fChannelConversion) ? CONVERT_FLAG_STEREO_INPUT : 0);
    Index |= (Flags.fEnableHiRes ? CONVERT_FLAG_HI_RESOLUTION : 0);

    // Pick the function
    AddStage(CurSink->pInfo, 
         NULL, 
         ConvertFunction, 
         CurSink, 
         Index, 
         (Flags.fChannelConversion ? Flags.OutChannels : Flags.InChannels) );
    
    // Doppler, if necessary
    if (Flags.fEnableDoppler) {
        // Doppler SRC stage
        // Bit map:
        // b1-b0: Quality: 00=Bad, 01=Low, 10=Med, 11=High
        // b2:  on for stereo, off otherwise
        // b3:  on for up-sample
        Index = ((CurSink->pInfo->Doppler.Quality << 1) & SRC_MASK_QUALITY);
        Index |= (Flags.InChannels == 2 ? SRC_FLAG_STEREO : 0);
        Index |= (CurSink->pInfo->Doppler.UpSampleRate > CurSink->pInfo->Doppler.DownSampleRate ? SRC_FLAG_UPSAMPLE : 0);
        AddStage(CurSink->pInfo, 
                 CurSink->pInfo->Doppler.pInputBuffer, 
                 SrcFunction, 
                 &CurSink->pInfo->Doppler,
                 Index,
                 Flags.InChannels);
    }

    if (CurSink->fEnable3D) {
        // 3D effect
        Index = (Flags.fEnableFloat ? CONVERT_FLAG_FLOAT : 0);
        Index |= (CurSink->WaveFormatEx.nChannels == 2 ? EFFECTS_3D_FLAG_STEREO_INPUT : 0);
        AddStage(CurSink->pInfo, 
                 pMixerSource->pScratch2, 
                 (CurSink->fUseIir3d ? FunctionIir3D : FunctionItd3D), 
                 CurSink, 
                 Index,
                 2);
    }

    // SuperMix, if necessary
    if (Flags.fEnableSuperMix) {
        Index = (Flags.fEnableFloat ? CONVERT_FLAG_FLOAT : 0);
        AddStage(CurSink->pInfo, pMixerSource->pScratchBuffer, SuperFunction, CurSink, Index, Flags.OutChannels);
    }
        
    // SRC, if necessary
    if (Flags.fEnableSrc) {
        // SRC stage
        // Bit map:
        // b1-b0: Quality: 00=Bad, 01=Low, 10=Med, 11=High
        // b2:  on for stereo, off otherwise
        // b3:  on for up-sample
        Index = ((CurSink->pInfo->Src.Quality << 1) & SRC_MASK_QUALITY);
        Index |= (Flags.OutChannels == 2 ? SRC_FLAG_STEREO : 0);
        Index |= (CurSink->pInfo->Src.UpSampleRate > CurSink->pInfo->Src.DownSampleRate ? SRC_FLAG_UPSAMPLE : 0);

        AddStage(CurSink->pInfo, 
                 CurSink->pInfo->Src.pInputBuffer, 
                 SrcFunction, 
                 &CurSink->pInfo->Src, 
                 Index, 
                 Flags.OutChannels);
    }

    // The final output buffer is not known yet
    CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer = NULL;
    if (Flags.fEnableFloat) {
        CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer = pMixerSource->pFloatMixBuffer;
    }

    // For capture, the final output buffer is pMixerSource->pScratch2 for integers
    if (pMixerSource->Header.PinId == PIN_ID_WAVEIN_SOURCE && !Flags.fEnableFloat) {
        CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer = pMixerSource->pScratch2;
    }

    CurSink->pInfo->Stage[0].nInputChannels = Flags.InChannels;
}

ULONG
FinalMixFloatToInt32
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    MixFloatToInt32( CurStage->pInputBuffer,
                     CurStage->pOutputBuffer,
                     (SampleCount * CurStage->nOutputChannels));
    return SampleCount;
}

ULONG
FinalMixInt32toFloat
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    PLONG   pLongBuffer = CurStage->pInputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;

    samplesleft = SampleCount;
    SampleCount *= CurStage->nOutputChannels;
#ifdef GTW_OPTS
	{
	ULONG SC = SampleCount >> 3;

	if (SC) {
		SampleCount &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) pFloatBuffer[x] += pLongBuffer[x];
		while (SC--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pLongBuffer += 8;
			pFloatBuffer += 8;
		}
	}
    while (SampleCount--) {
		ONESAMPLE(0);

        pFloatBuffer++;
		pLongBuffer++;
    }
	}
#else
    while (SampleCount--) {
        pFloatBuffer[SampleCount] += pLongBuffer[SampleCount];
    }
#endif
    return samplesleft;
}

ULONG
FinalCopyFloatToInt32
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    CopyFloatToInt32( CurStage->pInputBuffer,
                     CurStage->pOutputBuffer,
                     (SampleCount * CurStage->nOutputChannels));
    return SampleCount;
}

ULONG
FinalCopyInt32toFloat
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    PLONG   pLongBuffer = CurStage->pInputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;

    samplesleft = SampleCount;
    SampleCount *= CurStage->nOutputChannels;
#ifdef GTW_OPTS
	{
	ULONG SC = SampleCount >> 3;

	if (SC) {
		SampleCount &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) pFloatBuffer[x] = (FLOAT)pLongBuffer[x];
		while (SC--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pLongBuffer += 8;
			pFloatBuffer += 8;
		}
	}
    while (SampleCount--) {
		ONESAMPLE(0);

        pFloatBuffer++;
		pLongBuffer++;
    }
	}
#else
    while (SampleCount--) {
        pFloatBuffer[SampleCount] = (FLOAT)pLongBuffer[SampleCount];
    }
#endif
    return samplesleft;
}

#ifdef _X86_
ULONG
MmxFinalPeg32to16
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    MmxPeg32to16( CurStage->pInputBuffer,
                  CurStage->pOutputBuffer,
                  (SampleCount * CurStage->nOutputChannels),
                  2 );
    return SampleCount;
}
#endif

ULONG
FinalPeg32to16
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    Peg32to16( CurStage->pInputBuffer,
               CurStage->pOutputBuffer,
               (SampleCount * CurStage->nOutputChannels),
               2 );
    return SampleCount;
}

ULONG
FinalPeg32to8
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    Peg32to8( CurStage->pInputBuffer,
              CurStage->pOutputBuffer,
              (SampleCount * CurStage->nOutputChannels),
              2 );
    return SampleCount;
}

ULONG
FinalPeg32toFloat
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    PLONG  pMixBuffer = CurStage->pInputBuffer;
    PFLOAT pWriteBuffer = CurStage->pOutputBuffer;
    LONG    lSample ;

    samplesleft = SampleCount;
    SampleCount *= CurStage->nOutputChannels;
#ifdef GTW_OPTS
	{
	ULONG SC = SampleCount >> 3;

	if (SC) {
		SampleCount &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) \
        	lSample = pMixBuffer[x]; \
        	pWriteBuffer[x] = (FLOAT) (lSample / 32768L);

		while (SC--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pMixBuffer += 8;
			pWriteBuffer += 8;
		}
	}
    while (SampleCount--) {
		ONESAMPLE(0);

        pMixBuffer++;
		pWriteBuffer++;
    }
	}
#else
    while (SampleCount--) {
        lSample = *pMixBuffer;
        pMixBuffer++;
        *pWriteBuffer++ = (FLOAT) (lSample / 32768L);
    }
#endif

    return samplesleft;
}

ULONG
FinalPegFloatToFloat
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    PFLOAT  pMixBuffer = CurStage->pInputBuffer;
    PFLOAT pWriteBuffer = CurStage->pOutputBuffer;
    FLOAT    Sample ;

    samplesleft = SampleCount;
    SampleCount *= CurStage->nOutputChannels;
#ifdef GTW_OPTS
	{
	ULONG SC = SampleCount >> 3;

	if (SC) {
		SampleCount &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) \
        	Sample = pMixBuffer[x]; \
        	pWriteBuffer[x] = (FLOAT) (Sample / 32768L);

		while (SC--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pMixBuffer += 8;
			pWriteBuffer += 8;
		}
	}
    while (SampleCount--) {
		ONESAMPLE(0);

        pMixBuffer++;
		pWriteBuffer++;
    }
	}
#else
    while (SampleCount--) {
        Sample = *pMixBuffer;
        pMixBuffer++;
        *pWriteBuffer++ = (FLOAT) (Sample / 32768L);
    }
#endif

    return samplesleft;
}

ULONG
FinalPegFloatTo24
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    PFLOAT  pMixBuffer = CurStage->pInputBuffer;
    PBYTE   pWriteBuffer = CurStage->pOutputBuffer;
    LONG    Sample ;
    ULONG   DitherScale;
    PWAVEFORMATEXTENSIBLE   pFormat = (PWAVEFORMATEXTENSIBLE) CurStage->Context;

    DitherScale = (0x80000000 >> (pFormat->Samples.wValidBitsPerSample - 1));

    samplesleft = SampleCount;
    SampleCount *= CurStage->nOutputChannels;
#ifdef GTW_OPTS
	{
	ULONG SC = SampleCount >> 3;

	if (SC) {
		SampleCount &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) \
        	Sample = DitherFloatToLong((pMixBuffer[x])*65536,DitherScale); \
			\
        	pWriteBuffer[3*x+0] = ((PBYTE) &Sample)[1]; \
        	pWriteBuffer[3*x+1] = ((PBYTE) &Sample)[2]; \
        	pWriteBuffer[3*x+2] = ((PBYTE) &Sample)[3];

		while (SC--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pMixBuffer += 8;
			pWriteBuffer += 3*8;
		}
	}
    while (SampleCount--) {
		ONESAMPLE(0);

        pMixBuffer++;
		pWriteBuffer += 3;
    }
	}
#else
    while (SampleCount--) {
        Sample = DitherFloatToLong((*pMixBuffer)*65536,DitherScale);
        pMixBuffer++;

        pWriteBuffer[0] = ((PBYTE) &Sample)[1];
        pWriteBuffer[1] = ((PBYTE) &Sample)[2];
        pWriteBuffer[2] = ((PBYTE) &Sample)[3];
        pWriteBuffer += 3;
    }
#endif

    return samplesleft;
}

ULONG
FinalPegFloatTo32
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    PFLOAT  pMixBuffer = CurStage->pInputBuffer;
    PLONG   pWriteBuffer = CurStage->pOutputBuffer;
    LONG    Sample ;
    ULONG   DitherScale;
    PWAVEFORMATEXTENSIBLE   pFormat = (PWAVEFORMATEXTENSIBLE) CurStage->Context;

    DitherScale = (0x80000000 >> (pFormat->Samples.wValidBitsPerSample - 1));

    samplesleft = SampleCount;
    SampleCount *= CurStage->nOutputChannels;
#ifdef GTW_OPTS
	{
	ULONG SC = SampleCount >> 3;

	if (SC) {
		SampleCount &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) \
        	Sample = DitherFloatToLong((pMixBuffer[x])*65536L,DitherScale); \
        	pWriteBuffer[x] = Sample;

		while (SC--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pMixBuffer += 8;
			pWriteBuffer += 8;
		}
	}
    while (SampleCount--) {
		ONESAMPLE(0);

        pMixBuffer++;
		pWriteBuffer++;
    }
	}
#else
    while (SampleCount--) {
        Sample = DitherFloatToLong((*pMixBuffer)*65536L,DitherScale);
        pMixBuffer++;
        *pWriteBuffer++ = Sample;
    }
#endif

    return samplesleft;
}

#ifdef NEW_SURROUND
ULONG
FinalConvertQuad32toDolby
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    return ConvertQuad32toDolby( (PMIXER_SOURCE_INSTANCE) CurStage->Context,
                                 CurStage->pInputBuffer,
                                 CurStage->pOutputBuffer,
                                 SampleCount );
}

ULONG
FinalConvertQuadFloatToDolby
(
    PMIXER_OPERATION CurStage, 
    ULONG SampleCount, 
    ULONG samplesleft 
)
{
    PMIXER_SOURCE_INSTANCE  pMixerSource = (PMIXER_SOURCE_INSTANCE) CurStage->Context;
    PFLOAT   pIn = CurStage->pInputBuffer;
    PFLOAT   pOut = CurStage->pOutputBuffer;
    PFLOAT  pHistory;
#ifndef _X86_    
    FLOAT  LeftSample, RightSample, CenterSample, SurroundSample;
#endif    
    ULONG  i;
    FLOAT TinyFilter[] = {0.226664723532f,0.273335276468f,0.273335276468f,0.226664723532f};
    FLOAT OptFilter[] = { 0.829255288453f,1.205901263367f,0.273335276468f,0.226664723532f};
    WORD MmxFilter[] = { 14854, 0, 17913, 0, 17913, 0, 14854, 0};
    LARGE_INTEGER MmxMask = { 0xffffffff, 0xffffffff };
    FLOAT   SurScale = SURSCALE;
    PFLOAT  pCoeff = &OptFilter[0];
    PWORD pMmxCoeff = &MmxFilter[0];
    KFLOATING_SAVE     FloatSave;

    SaveFloatState(&FloatSave);

    // Take the mono input and convert it to dolby pro-logic-encoded stereo
    pHistory = (PFLOAT) &pMixerSource->SurHistory[0];
    for (i=0; i<SampleCount; i++) {
#ifndef _X86_    
        pHistory[0] = pHistory[1];
        pHistory[1] = pHistory[2];
        pHistory[2] = pHistory[3];

        LeftSample = pIn[i*4];
        RightSample = pIn[i*4+1];
        CenterSample = pIn[i*4+2];
        pHistory[3] = pIn[i*4+3];
        
        SurroundSample =  pHistory[3] * TinyFilter[0] +
                        pHistory[2] * TinyFilter[1] +
                        pHistory[1] * TinyFilter[2] +
                        pHistory[0] * TinyFilter[3];

        LeftSample = LeftSample + CenterSample - SurroundSample;
        RightSample = RightSample + CenterSample + SurroundSample;
                
        pOut[i*2] = LeftSample;
        pOut[i*2+1] = RightSample;
#else
        _asm {
            // 44 cycles
            mov esi, pHistory
            mov edi, pIn

            mov ecx, i
            mov edx, pCoeff

            shl ecx, 1
            mov eax, dword ptr [esi+4]
            
            mov ebx, dword ptr [esi+8]
            mov dword ptr [esi], eax
            
            mov eax, dword ptr [esi+12]
            mov dword ptr [esi+4], ebx
            
            mov dword ptr [esi+8], eax

            fld dword ptr [edi+ecx*8]      // L
            fld dword ptr [edi+ecx*8+4]    // R, L
            fld dword ptr [edi+ecx*8+12]   // x3, R, L
            fld dword ptr [edi+ecx*8+8]    // C, x3, R, L
            fld dword ptr [esi+8]           // x2, C, x3, R, L
            fmul dword ptr [edx+4]          // x2*c1/c3, C, x3, R, L
            fxch st(2)                      // x3, C, x2*c1/c3, R, L
            fst dword ptr [esi+12]          // x3, C, x2*c1/c3, R, L
            fmul dword ptr [edx]            // x3*c0/c2, C, x2*c1/c3, R, L
            fxch st(2)                      // x2*c1/c3, C, x3*c0/c2, R, L
            fadd dword ptr [esi]            // x0+x2*c1/c3, C, x3*c0/c2, R, L
            fxch st(2)                      // x3*c0/c2, C, x0+x2*c1/c3, R, L

            // extra cycle
            
            fadd dword ptr [esi+4]          // x1+x3*c0/c2, C, x0+x2*c1/c3, R, L
            fxch st(2)                      // x0+x2*c1/c3, C, x1+x3*c0/c2, R, L
            fmul dword ptr [edx+12]         // c3*x0+x2*c1, C, x1+x3*c0/c2, R, L
            fxch st(1)                      // C, c3*x0+x2*c1, x1+x3*c0/c2, R, L
            fadd st(4), st                  // C, c3*x0+x2*c1, x1+x3*c0/c2, R, L+C
            fxch st(2)                      // x1+x3*c0/c2, c3*x0+x2*c1, C, R, L+C
            fmul dword ptr [edx+8]          // x1*c2+x3*c0, c3*x0+x2*c1, C, R, L+C
            fxch st(2)                      // C, c3*x0+x2*c1, x1*c2+x3*c0, R, L+C
            faddp st(3), st                 // c3*x0+x2*c1, x1*c2+x3*c0, R+C, L+C

            // extra cycle

            faddp st(1), st                 // x0*c3+x1*c2+x2*c1+x3*c0 = S, R+C, L+C
            fxch st(2)                      // L+C, R+C, S

            // extra cycle
            
            mov edi, pOut

            fsub st, st(2)                  // Lt, R+C, S
            fxch st(2)                      // S, R+C, Lt
            faddp st(1), st                 // Rt, Lt
            fxch st(1)                      // Lt, Rt

            // extra cycle

            fstp dword ptr [edi+ecx*4]     // Rt
            fstp dword ptr [edi+ecx*4+4]
        }
#endif
    }

    RestoreFloatState(&FloatSave);
    
    return SampleCount;
}
#endif

VOID
OptimizeSource
(
    PFILTER_INSTANCE pFilterInstance
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PWAVEFORMATEX           pOutFormat;
    ULONG                   OutChannels;
    PVOID                   pMixBuffer, pfnFinalStage;
    BOOL                    fFloatOutput, fHighRes, fReading;
    
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (
                        pFilterInstance->SourceConnectionList.Flink, 
                        MIXER_INSTHDR, 
                        NextInstance) ;
                        
    // Clear the current scenario.
    pMixerSource->Info.nStages = 0;
    pOutFormat = &pMixerSource->WaveFormatEx;
    OutChannels = pMixerSource->WaveFormatEx.nChannels ;
    pMixBuffer = NULL;

    if (fReading = (pMixerSource->Header.PinId == PIN_ID_WAVEIN_SOURCE)) {
        if (pFilterInstance->ActiveSinkList.Flink != &pFilterInstance->ActiveSinkList) {
            pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD (
                        pFilterInstance->ActiveSinkList.Flink, 
                        MIXER_SINK_INSTANCE, 
                        ActiveQueue ) ;

            OutChannels = pMixerSink->WaveFormatEx.nChannels;
            pOutFormat = &pMixerSink->WaveFormatEx;
            pMixBuffer = pMixerSource->pScratch2;
        }
    }

    fFloatOutput = (pOutFormat->wFormatTag == WAVE_FORMAT_IEEE_FLOAT);
    fFloatOutput |= (pOutFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
         IsEqualGUID( &(((PWAVEFORMATEXTENSIBLE)pOutFormat)->SubFormat), &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT ) );

    fHighRes = (pOutFormat->wBitsPerSample == 24 || pOutFormat->wBitsPerSample == 32);

    // If the output should be high quality, mix the integer buffer into float.
    if (fFloatOutput || fHighRes) {
        pfnFinalStage = (fReading || !pMixerSource->fUsesFloat)?FinalCopyInt32toFloat:FinalMixInt32toFloat;        
        AddStage( &pMixerSource->Info,
                  pMixBuffer,
                  pfnFinalStage,
                  pMixerSource,
                  -1L,
                  OutChannels);
        pMixBuffer = pMixerSource->pFloatMixBuffer;
    } else if (pMixerSource->fUsesFloat) {
        pfnFinalStage = fReading?FinalCopyFloatToInt32:FinalMixFloatToInt32;
        AddStage( &pMixerSource->Info,
                  pMixerSource->pFloatMixBuffer,
                  pfnFinalStage,
                  pMixerSource,
                  -1L,
                  OutChannels);
    }
    
#ifdef NEW_SURROUND    
    if (pMixerSource->fSurround) {
        OutChannels = 2;
        AddStage( &pMixerSource->Info,
                  pMixBuffer,
                  ((fFloatOutput || fHighRes) ? FinalConvertQuadFloatToDolby : FinalConvertQuad32toDolby),
                  pMixerSource,
                  -1L,
                  OutChannels );
    }
#endif

    if (fFloatOutput) {
        // We need to produce a float buffer.
        AddStage( &pMixerSource->Info,
                  pMixBuffer,
                  FinalPegFloatToFloat,
                  pMixerSource,
                  -1L,
                  OutChannels);
    } else if (fHighRes) {
        AddStage( &pMixerSource->Info,
                  pMixBuffer,
                  (pOutFormat->wBitsPerSample == 24 ? FinalPegFloatTo24 : FinalPegFloatTo32),
                  pOutFormat,
                  -1L,
                  OutChannels);
    } else {
#ifdef _X86_
        if (MmxPresent()) {
            // Fill-in all the function pointers to use MMX.
            AddStage( &pMixerSource->Info,
                      pMixBuffer,
                      (pOutFormat->wBitsPerSample == 16 ? MmxFinalPeg32to16 : FinalPeg32to8),
                      pMixerSource,
                      -1L,
                      OutChannels);
        } else
#endif
            AddStage( &pMixerSource->Info,
                      pMixBuffer,
                      (pOutFormat->wBitsPerSample == 16 ? FinalPeg32to16 : FinalPeg32to8),
                      pMixerSource,
                      -1L,
                      OutChannels);
    }

    pMixerSource->Info.Stage[0].nInputChannels = OutChannels;
}

NTSTATUS
ChangeOutputRate
(
    PFILTER_INSTANCE 		pFilterInstance,
    PMIXER_SOURCE_INSTANCE  pMixerSource
)
{
    PMIXER_SINK_INSTANCE CurSink;
    PLIST_ENTRY     	ple ;
    KSPROPERTY          RateProperty ;
    NTSTATUS            Status, status ;
    ULONG               BytesReturned ;
    KSDATAFORMAT_WAVEFORMATEXTENSIBLE   WaveFormat;

    RateProperty.Set = KSPROPSETID_Connection ;
    RateProperty.Id = KSPROPERTY_CONNECTION_DATAFORMAT ;
    RateProperty.Flags = KSPROPERTY_TYPE_SET ;

    if (pMixerSource->WaveFormatEx.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        WaveFormat.DataFormat.FormatSize = sizeof(KSDATAFORMAT_WAVEFORMATEXTENSIBLE);
        WaveFormat.DataFormat.SubFormat = pMixerSource->WaveFormatExt.SubFormat;
    } else {
        WaveFormat.DataFormat.FormatSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        INIT_WAVEFORMATEX_GUID( &WaveFormat.DataFormat.SubFormat,
                                pMixerSource->WaveFormatEx.wFormatTag );
    }
    WaveFormat.DataFormat.Flags = 0;
    WaveFormat.DataFormat.SampleSize = 0;
    WaveFormat.DataFormat.Reserved = 0;
    WaveFormat.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    WaveFormat.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    WaveFormat.WaveFormatExt = pMixerSource->WaveFormatExt;
    WaveFormat.WaveFormatExt.Format.nSamplesPerSec = pMixerSource->MaxSampleRate;
    WaveFormat.WaveFormatExt.Format.nAvgBytesPerSec = 
        pMixerSource->MaxSampleRate * 
        WaveFormat.WaveFormatExt.Format.nChannels * 
        WaveFormat.WaveFormatExt.Format.wBitsPerSample / 8;
#ifdef NEW_SURROUND
    if (pMixerSource->fSurround) {
        WaveFormat.WaveFormatExt.Format.nChannels = 2;
    }
#endif

    Status = KsSynchronousIoControlDevice (
               pFilterInstance->pNextFileObject,
               KernelMode,
               IOCTL_KS_PROPERTY,
               &RateProperty,
               sizeof (KSPROPERTY),
               &WaveFormat,
               WaveFormat.DataFormat.FormatSize,
               &BytesReturned ) ;

    if (Status == STATUS_SUCCESS) {
        pMixerSource->WaveFormatEx.nSamplesPerSec = pMixerSource->MaxSampleRate;
        pMixerSource->WaveFormatEx.nAvgBytesPerSec = WaveFormat.WaveFormatExt.Format.nAvgBytesPerSec;
        pMixerSource->csMixBufferSize = (pMixerSource->MaxSampleRate * MIXBUFFERDURATION)/1000 + 1 ;
        pMixerSource->LeftOverFraction = 0;
    
        // Now we have to completely re-optimize...
        ple = pFilterInstance->SinkConnectionList.Flink ;
        pMixerSource->fZeroBufferFirst = TRUE;
        while ( ple != &pFilterInstance->SinkConnectionList ) {
            CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_INSTHDR, NextInstance ) ;
            if (CurSink->fEnable3D && !CurSink->fUseIir3d && CurSink->fCreate3D) {
                CurSink->pItdContextLeft->iSmoothFreq = pMixerSource->WaveFormatEx.nSamplesPerSec;
                CurSink->pItdContextRight->iSmoothFreq = pMixerSource->WaveFormatEx.nSamplesPerSec;
            }
            status = ChangeSrc(pFilterInstance, CurSink, pMixerSource, CurSink->pInfo->Src.Quality);
            if (status != STATUS_SUCCESS) {
                CurSink->fMuted = TRUE;
                CurSink->pInfo->fSrcChanged = TRUE;
            }
            ple = CurSink->Header.NextInstance.Flink ;
		}
	}

	return Status;
}

VOID
OptimizeMix
(
    PFILTER_INSTANCE pFilterInstance
)
{
    PMIXER_SINK_INSTANCE CurSink, FinalSink;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PMIXER_OPERATION    pLast, TempLast;
    PLIST_ENTRY     ple;
    ULONG           Index;
    NTSTATUS        status;
    BOOL            fOutputRateValid, fMixBufferUsed, fFloatBufferUsed, fScratchBufferUsed;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (
                        pFilterInstance->SourceConnectionList.Flink, 
                        MIXER_INSTHDR, 
                        NextInstance) ;

    // Optimize each sink
    fOutputRateValid = FALSE;
    pMixerSource->fUsesFloat = FALSE ;
    ple = pFilterInstance->ActiveSinkList.Flink ;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, 
                        MIXER_SINK_INSTANCE, 
                        ActiveQueue ) ;

        OptimizeSink(CurSink, pMixerSource);

        Index = SrcIndex(&CurSink->pInfo->Src);
        pMixerSource->TempCount[CurSink->pInfo->Src.Quality][Index] = 0;
        if ((CurSink->SinkState == KSSTATE_RUN) &&
        	(!CurSink->fMuted)) {
            pMixerSource->pLastSink[CurSink->pInfo->Src.Quality][Index] = CurSink;
        }
        
        if (CurSink->WaveFormatEx.nSamplesPerSec == 
            pMixerSource->WaveFormatEx.nSamplesPerSec) {
            fOutputRateValid = TRUE;
        }
        ple = CurSink->ActiveQueue.Flink ;
    }
    
    OptimizeSource(pFilterInstance);

    // Eliminate extra SRC's
    ple = pFilterInstance->ActiveSinkList.Flink ;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;

        if (CurSink->SinkState == KSSTATE_RUN &&
            !CurSink->fMuted &&
            CurSink->pInfo->Src.UpSampleRate != CurSink->pInfo->Src.DownSampleRate) {

            // If this is not the first one, change to mix.
            Index = SrcIndex(&CurSink->pInfo->Src);
            if (pMixerSource->TempCount[CurSink->pInfo->Src.Quality][Index] > 0) {
                // Change it to mix
                TempLast = &CurSink->pInfo->Stage[CurSink->pInfo->nStages - 2];
                TempLast->Index |= CONVERT_FLAG_MIX;
                TempLast->pfnStage = TempLast->FunctionArray[TempLast->Index];
            }

            // Increment the count for this SRC
            pMixerSource->TempCount[CurSink->pInfo->Src.Quality][Index]++;

            // If this is not the last one, get rid of the SRC
            if (CurSink != pMixerSource->pLastSink[CurSink->pInfo->Src.Quality][Index]) {
                // Disable its SRC
                CurSink->pInfo->nStages--;
                
                // Change the sink to use the final SRC's context
                FinalSink = pMixerSource->pLastSink[CurSink->pInfo->Src.Quality][Index];
                CurSink->pActualSrc = &(FinalSink->pInfo->Src);
            }
        }
        ple = CurSink->ActiveQueue.Flink ;
    }

    // Change subsequent sinks to mix rather than initialize.
    ple = pFilterInstance->ActiveSinkList.Flink ;
    fMixBufferUsed = FALSE;
    fFloatBufferUsed = FALSE;
    fScratchBufferUsed = FALSE;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, 
                    MIXER_SINK_INSTANCE, 
                    ActiveQueue ) ;

        if (CurSink->SinkState == KSSTATE_RUN && !CurSink->fMuted) {
            // Look at the last stage for this pin
            pLast = &CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1];

            if (pLast->pOutputBuffer == NULL) {
                // If this buffer was used previously, change the last stage to mix.
                if (fMixBufferUsed) {
                    // Change to mix
                    pLast->Index |= CONVERT_FLAG_MIX;
                    pLast->pfnStage = pLast->FunctionArray[pLast->Index];
                }
                fMixBufferUsed = TRUE;
            } else if (pLast->pOutputBuffer == pMixerSource->pFloatMixBuffer) {
                // If this buffer was used previously, change the last stage to mix.
                if (fFloatBufferUsed) {
                    // Change to mix
                    pLast->Index |= CONVERT_FLAG_MIX;
                    pLast->pfnStage = pLast->FunctionArray[pLast->Index];
                }
                fFloatBufferUsed = TRUE;
            } else if (pLast->pOutputBuffer == pMixerSource->pScratch2) {
                // If this buffer was used previously, change the last stage to mix.
                if (fScratchBufferUsed) {
                    // Change to mix
                    pLast->Index |= CONVERT_FLAG_MIX;
                    pLast->pfnStage = pLast->FunctionArray[pLast->Index];
                }
                fScratchBufferUsed = TRUE;
            }
        }
        
        ple = CurSink->ActiveQueue.Flink ;
    }

    pMixerSource->fZeroBufferFirst = (fMixBufferUsed == FALSE);
    if (pMixerSource->Header.PinId == PIN_ID_WAVEIN_SOURCE) {
        pMixerSource->fZeroBufferFirst = FALSE;
    }

    // Adjust the output rate, if necessary
    if (!gFixedSamplingRate &&
        pMixerSource->MaxSampleRate && 
        pMixerSource->MaxSampleRate != pMixerSource->WaveFormatEx.nSamplesPerSec &&
        pMixerSource->Header.PinId != PIN_ID_WAVEIN_SOURCE &&
        pMixerSource->fNewMaxRate) {

        pMixerSource->fNewMaxRate = FALSE;

        // Try the max rate
        status = ChangeOutputRate( pFilterInstance, pMixerSource );
        if (status == STATUS_SUCCESS) {
        	// We have to re-optimize
            OptimizeMix(pFilterInstance);
            return;
        }

		// Try the original rate
        if (pMixerSource->MaxSampleRate > pMixerSource->OriginalSampleRate &&
			pMixerSource->OriginalSampleRate > pMixerSource->WaveFormatEx.nSamplesPerSec) {
			// See if we can change it to the original rate
			pMixerSource->MaxSampleRate = pMixerSource->OriginalSampleRate;
			status = ChangeOutputRate( pFilterInstance, pMixerSource );
	        if (status == STATUS_SUCCESS) {
	        	// We have to re-optimize
	            OptimizeMix(pFilterInstance);
	            return;
	        }
		}

		// Give up and stick to the current rate.
        if (pMixerSource->MaxSampleRate > pMixerSource->WaveFormatEx.nSamplesPerSec) {
            pMixerSource->MaxSampleRate = pMixerSource->WaveFormatEx.nSamplesPerSec;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\slocal.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    slocal.h

Abstract:

    This is the header for the short, HRTF 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(SHORTLOCALIZER_HEADER)
#define SHORTLOCALIZER_HEADER
#pragma once

// Project-specific INCLUDEs
#include "vmaxhead.h"

typedef struct _SHORT_LOCALIZER 
{
    PRSIIR RsIir[efilterCount];
    PLONG  FilterOut[efilterCount];
    PLONG  OverlapBuffer[efilterCount];
    UINT   PreviousNumSamples;
    BOOL   SwapChannels;
    BOOL   ZeroAzimuth;
    PLONG  TempLongBuffer;
    UINT   FilterOverlapLength;
    UINT   FilterMuteLength;
    BOOL   FirstUpdate;
    UINT   OutputOverlapLength;
    BOOL   CrossFadeOutput;
    SHORT  ZeroCoeffs[5];
} SHORT_LOCALIZER, *PSHORT_LOCALIZER;


// ---------------------------------------------------------------------------
// Fixed-point localizer

NTSTATUS ShortLocalizerCreate(PSHORT_LOCALIZER*);
VOID ShortLocalizerDestroy(PSHORT_LOCALIZER);

VOID ShortLocalizerLocalize(PSHORT_LOCALIZER, PLONG, PLONG, UINT, BOOL);
NTSTATUS ShortLocalizerInitData(PSHORT_LOCALIZER, KSDS3D_HRTF_FILTER_METHOD, UINT, KSDS3D_HRTF_FILTER_QUALITY, UINT, UINT, UINT);
VOID ShortLocalizerFilterOverlap(PSHORT_LOCALIZER, UINT, PLONG, PLONG, UINT);
VOID ShortLocalizerFreeBufferMemory(PSHORT_LOCALIZER);
NTSTATUS ShortLocalizerUpdateCoeffs(PSHORT_LOCALIZER, UINT, PSHORT, SHORT, UINT, PSHORT, SHORT, BOOL, BOOL, BOOL);
NTSTATUS ShortLocalizerSetTransitionBufferLength(PSHORT_LOCALIZER, UINT, UINT);
NTSTATUS ShortLocalizerSetOverlapLength(PSHORT_LOCALIZER, UINT);
VOID ShortLocalizerSumDiff(PSHORT_LOCALIZER, PLONG, PLONG, UINT, BOOL);

#endif

// End of SHORTLOCALIZER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\slocal.c ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    slocal.c

Abstract:

    This module implements short, IIR 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/


// Project-specific INCLUDEs
#include "common.h"

#if defined(LOG_TO_FILE) && defined(LOG_HRTF_DATA)
extern PFILTER_INSTANCE	gpFilterInstance;
#endif

// ---------------------------------------------------------------------------
// Constants

#define ECoeffFormat tagShort
#define SizeOfShort sizeof(SHORT)

// ---------------------------------------------------------------------------
// Fixed-point localizer

// "Regular" constructor
NTSTATUS ShortLocalizerCreate
(
    PSHORT_LOCALIZER* ppLocalizer
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    *ppLocalizer = ExAllocatePoolWithTag( PagedPool, sizeof(SHORT_LOCALIZER), 'XIMK' );

    if(*ppLocalizer) {
        RtlZeroMemory(*ppLocalizer, sizeof(SHORT_LOCALIZER));
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES; 
    }

    return Status;
}

// Destructor
VOID ShortLocalizerDestroy
(
    PSHORT_LOCALIZER Localizer
)
{
    UINT Filter;

    if (Localizer) {
        // Free resources
        if (Localizer->TempLongBuffer) {
            ExFreePool(Localizer->TempLongBuffer);
            Localizer->TempLongBuffer = NULL;
        }
        ShortLocalizerFreeBufferMemory(Localizer);
        for (Filter=0; Filter<efilterCount; ++Filter) {
            if(Localizer->OverlapBuffer[Filter]) {
                ExFreePool(Localizer->OverlapBuffer[Filter]);
                Localizer->OverlapBuffer[Filter] = NULL;
            }
            RsIirDestroy(Localizer->RsIir[Filter]);
            Localizer->RsIir[Filter] = NULL;
        }
        ExFreePool(Localizer);
    }
}

// Localize
VOID ShortLocalizerLocalize
(
    PSHORT_LOCALIZER Localizer,
    PLONG  InData, 
    PLONG  OutData, 
    UINT  NumSamples,
    BOOL   MixOutput
)
{
    UINT        Filter;
    PLONG       OutLeft;
    PLONG       OutRight;
    LONG        FilterLeft;
    LONG        FilterRight;
    LONG        Sum;
    LONG        Difference;
    UINT        ChannelOffset;
    LONG        FilterOut;
    UINT        st;
    UINT        OutputOverlapLength;
    WORD        NumOverlapSamplesFactor;
    EChannel    eLeft;
    EChannel    eRight;
    WORD        CrossFadeFactor;
    WORD        InverseCrossFadeFactor;
    LONG        TempSum;
    LONG        TempDifference;
    SHORT       BitsPerShortMinus1;

    ASSERT(InData);
    ASSERT(OutData);
    ASSERT(NumSamples > 0);

    // Mute if Localizer is bad
    if(!Localizer) {
        for (st=0; st<2*NumSamples; ++st) {
            OutData[st] = 0;
        }
        return;
    }

#ifndef REALTIME_THREAD
    // Reallocate (dynamically grow) memory, if necessary
    if (NumSamples > Localizer->PreviousNumSamples ||
        !Localizer->FilterOut[tagSigma] ||
        !Localizer->FilterOut[tagDelta]) {

        Localizer->PreviousNumSamples = NumSamples;
        ShortLocalizerFreeBufferMemory(Localizer);

        Localizer->FilterOut[tagSigma] = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                NumSamples*sizeof(LONG), 
                'XIMK'
            );

        if(!Localizer->FilterOut[tagSigma]) { 

            for (st=0; st<2*NumSamples; ++st) {
                OutData[st] = 0;
            }
    
            return;
        }

        Localizer->FilterOut[tagDelta] = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                NumSamples*sizeof(LONG), 
                'XIMK'
            );

        if(!Localizer->FilterOut[tagDelta]) {

            ExFreePool(Localizer->FilterOut[tagSigma]);
            Localizer->FilterOut[tagSigma] = NULL;
    
            for (st=0; st<2*NumSamples; ++st) {
                OutData[st] = 0;
            }

            return;
        }

    }
#else
        if(NumSamples > Localizer->PreviousNumSamples ||
           !Localizer->FilterOut[tagSigma] ||
           !Localizer->FilterOut[tagDelta]) { 

            for (st=0; st<2*NumSamples; ++st) {
                OutData[st] = 0;
            }
    
            return;
        }
#endif

    // Perform fixed-point filtering
    for (Filter=0; Filter<efilterCount; ++Filter) {
        ASSERT(Localizer->RsIir[Filter]);
        ShortLocalizerFilterOverlap(Localizer,
                                    Filter,
                                    InData, 
                                    Localizer->FilterOut[Filter], 
                                    NumSamples);

    }
    
    BitsPerShortMinus1 = BitsPerShort - 1;

	// Calculate overlap length
    if (Localizer->CrossFadeOutput) {
		// Calculate overlap length
		if (Localizer->OutputOverlapLength > NumSamples)
			OutputOverlapLength = NumSamples;
		else
			OutputOverlapLength = Localizer->OutputOverlapLength;
		NumOverlapSamplesFactor = (WORD)(SHRT_MAX / (OutputOverlapLength - 1));
	}
    
    // Inverse sigma/delta operation
    // Swap channels if azimuth is negative
    if (TRUE == Localizer->SwapChannels) {
        eLeft  = tagRight;
        eRight = tagLeft;
    } else {
        eLeft  = tagLeft;
        eRight = tagRight;
    }
    
    
    // Process both (sigma and delta) filters
    // Non-zero angle: Process delta filter
    OutLeft = &OutData[eLeft];
    OutRight = &OutData[eRight];
    
    for (st=0; st<NumSamples; ++st) {
        // Calculate sum and difference
        ChannelOffset = (st * echannelCount);
        FilterLeft = *(Localizer->FilterOut[tagLeft] + st);
        FilterRight = *(Localizer->FilterOut[tagRight] + st);
    
        Sum = FilterRight + FilterLeft;
        Difference = FilterRight - FilterLeft;
    
        // Saturate sum to maximum
        if (Sum > MaxSaturation) {
            Sum = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded maximum saturation value\n")
            );
        }
        
        // Saturate sum to minimum
        if (Sum < MinSaturation) {
            Sum = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded minimum saturation value\n")
            );
        }
    
        // Saturate difference to maximum
        if (Difference > MaxSaturation) {
            Difference = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded maximum saturation value\n")
            );
        }
        
        // Saturate difference to minimum
        if (Difference < MinSaturation) {
            Difference = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded minimum saturation value\n")
            );
        }
    
        // Check for zero azimuth transition
        if (Localizer->CrossFadeOutput && st<OutputOverlapLength) {
            // Cross-fade left/right channel switch transition
            // Calculate cross-fade factor
            CrossFadeFactor = (WORD)(st * NumOverlapSamplesFactor);
            ASSERT(CrossFadeFactor >= 0 && CrossFadeFactor <= SHRT_MAX);
            InverseCrossFadeFactor = SHRT_MAX - CrossFadeFactor;
            ASSERT(InverseCrossFadeFactor >= 0 && InverseCrossFadeFactor <= SHRT_MAX);
    
            // Calculate cross-faded sample
            TempDifference = Difference;
            TempSum = Sum;
            Difference = ((TempSum * InverseCrossFadeFactor) / 32768) 
                         + ((TempDifference * CrossFadeFactor) / 32768);
            Sum = ((TempDifference * InverseCrossFadeFactor) / 32768)  
                  + ((TempSum * CrossFadeFactor) / 32768);
    
        }

        // Saturate sum to maximum
        if (Sum > MaxSaturation) {
            Sum = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded maximum saturation value\n")
            );
        }
        
        // Saturate sum to minimum
        if (Sum < MinSaturation) {
            Sum = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded minimum saturation value\n")
            );
        }
    
        // Saturate difference to maximum
        if (Difference > MaxSaturation) {
            Difference = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded maximum saturation value\n")
            );
        }
        
        // Saturate difference to minimum
        if (Difference < MinSaturation) {
            Difference = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded minimum saturation value\n")
            );
        }
    
        // Assign sum and difference
        if (!MixOutput) {
            OutLeft[ChannelOffset] = Difference;
            OutRight[ChannelOffset] = Sum;
        } else {
            OutLeft[ChannelOffset] += Difference;
            OutRight[ChannelOffset] += Sum;
        }
    }

    Localizer->CrossFadeOutput = FALSE;  // Make sure we don't cross fade output a second time

#if defined(LOG_TO_FILE) && defined(LOG_HRTF_DATA)
    FileIoRoutine (gpFilterInstance,
                   OutData,
                   2*NumSamples*sizeof(LONG));
#endif

}

#ifdef _X86_
VOID
ShortLocalizerSumDiff
(
    PSHORT_LOCALIZER Localizer,
    PLONG  OutLeft,
    PLONG  OutRight,
    UINT   NumSamples,
    BOOL   MixOutput
){ LONG        FilterLeft;
    LONG        FilterRight;
    LONG        Sum;
    LONG        Difference;
    UINT        ChannelOffset = 0;
    UINT        st;
    PLONG       pFilterLeft, pFilterRight;

    ASSERT(echannelCount == 2);

    pFilterLeft  = Localizer->FilterOut[tagLeft];
    pFilterRight = Localizer->FilterOut[tagRight];

    if (MixOutput) {
#if 0
    _asm {

    mov    ecx, DWORD PTR NumSamples
    test    ecx, ecx
    jbe    $L8544

    mov esi, pFilterLeft
    mov edi, pFilterRight
    mov    eax, DWORD PTR OutRight
    mov    ebx, DWORD PTR OutLeft

    lea esi, [esi+ecx*4]
    lea edi, [edi+ecx*4]
    lea eax, [eax+ecx*8]
    lea ebx, [ebx+ecx*8]
    neg ecx

    //  edx are free.

    pxor        mm0, mm0

$L8534:
    movd        mm2, DWORD PTR [edi+ecx*4]    // Right
    movd        mm1, DWORD PTR [esi+ecx*4]    // Left

    movq        mm3, mm2
    paddd       mm2, mm1        // Right + Left

    packssdw    mm2, mm0    // Sum
    psubd       mm3, mm1        // Right - Left

    pslld       mm2, 16
    movd        mm4, DWORD PTR [eax+ecx*8]    // Right

    psrad       mm2, 16
    
    packssdw    mm3, mm0    // Difference
    movd        mm5, DWORD PTR [ebx+ecx*8]    // Left

    pslld       mm3, 16
    paddd       mm4, mm2            // Right += Sum

    psrad       mm3, 16
    movd        DWORD PTR [eax+ecx*8], mm4

    paddd       mm5, mm3            // Left  += Difference
    inc    ecx

    movd        DWORD PTR [ebx+ecx*8-8], mm5
    jne    SHORT $L8534

$L8544:
    emms
    }
#else
        for (st=0; st<NumSamples; ++st) {
            // Calculate sum and difference
            FilterLeft = *(pFilterLeft + st);
            FilterRight = *(pFilterRight + st);
            Sum = FilterRight + FilterLeft;
            Difference = FilterRight - FilterLeft;
            
            // Saturate sum to maximum
            if (Sum > MaxSaturation) {
                Sum = MaxSaturation;
            }
            
            // Saturate sum to minimum
            if (Sum < MinSaturation) {
                Sum = MinSaturation;
            }

            // Saturate difference to maximum
            if (Difference > MaxSaturation) {
                Difference = MaxSaturation;
            }
            
            // Saturate difference to minimum
            if (Difference < MinSaturation) {
                Difference = MinSaturation;
            }

            OutLeft[ChannelOffset] += Difference;
            OutRight[ChannelOffset] += Sum;
            ChannelOffset += echannelCount;
        }
#endif
    }
    else {
#if 0
    _asm {

    mov    ecx, DWORD PTR NumSamples
    test    ecx, ecx
    jbe    $L8544a

    mov esi, pFilterLeft
    mov edi, pFilterRight
    mov    eax, DWORD PTR OutRight
    mov    ebx, DWORD PTR OutLeft

    lea esi, [esi+ecx*4]
    lea edi, [edi+ecx*4]
    lea eax, [eax+ecx*8]
    lea ebx, [ebx+ecx*8]
    neg ecx

    //  edx are free.

    pxor        mm0, mm0

$L8534a:
    movd        mm2, DWORD PTR [edi+ecx*4]    // Right
    movd        mm1, DWORD PTR [esi+ecx*4]    // Left

    movq        mm3, mm2
    paddd       mm2, mm1        // Right + Left

    packssdw    mm2, mm0    // Sum
    psubd       mm3, mm1        // Right - Left

    pslld       mm2, 16

    psrad       mm2, 16
    
    packssdw    mm3, mm0    // Difference

    pslld       mm3, 16

    psrad       mm3, 16
    movd        DWORD PTR [eax+ecx*8], mm2

    inc    ecx

    movd        DWORD PTR [ebx+ecx*8-8], mm3
    jne    SHORT $L8534a

$L8544a:
    emms
    }
#else
        for (st=0; st<NumSamples; ++st) {
            // Calculate sum and difference
            FilterLeft = *(pFilterLeft + st);
            FilterRight = *(pFilterRight + st);
            Sum = FilterRight + FilterLeft;
            Difference = FilterRight - FilterLeft;
            
            // Saturate sum to maximum
            if (Sum > MaxSaturation) {
                Sum = MaxSaturation;
            }
            
            // Saturate sum to minimum
            if (Sum < MinSaturation) {
                Sum = MinSaturation;
            }

            // Saturate difference to maximum
            if (Difference > MaxSaturation) {
                Difference = MaxSaturation;
            }
            
            // Saturate difference to minimum
            if (Difference < MinSaturation) {
                Difference = MinSaturation;
            }

            // Assign sum and difference

            OutLeft[ChannelOffset] = Difference;
            OutRight[ChannelOffset] = Sum;
            ChannelOffset += echannelCount;
        }
#endif
    }
}
#else
VOID
ShortLocalizerSumDiff
(
    PSHORT_LOCALIZER Localizer,
    PLONG  OutLeft,
    PLONG  OutRight,
    UINT   NumSamples,
    BOOL   MixOutput
){ LONG        FilterLeft;
    LONG        FilterRight;
    LONG        Sum;
    LONG        Difference;
    UINT        ChannelOffset = 0;
    UINT        st;
    PLONG       pFilterLeft, pFilterRight;

    pFilterLeft  = Localizer->FilterOut[tagLeft];
    pFilterRight = Localizer->FilterOut[tagRight];

    if (MixOutput) {
        for (st=0; st<NumSamples; ++st) {
            // Calculate sum and difference
            ChannelOffset = st * echannelCount;
            FilterLeft = *(Localizer->FilterOut[tagLeft] + st);
            FilterRight = *(Localizer->FilterOut[tagRight] + st);
            Sum = FilterRight + FilterLeft;
            Difference = FilterRight - FilterLeft;
            
            // Saturate sum to maximum
            if (Sum > MaxSaturation) {
                Sum = MaxSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Sum exceeded maximum saturation value\n")
                );
            }
            
            // Saturate sum to minimum
            if (Sum < MinSaturation) {
                Sum = MinSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Sum exceeded minimum saturation value\n")
                );
            }

            // Saturate difference to maximum
            if (Difference > MaxSaturation) {
                Difference = MaxSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Difference exceeded maximum saturation value\n")
                );
            }
            
            // Saturate difference to minimum
            if (Difference < MinSaturation) {
                Difference = MinSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Difference exceeded minimum saturation value\n")
                );
            }

            OutLeft[ChannelOffset] += Difference;
            OutRight[ChannelOffset] += Sum;
        }
    }
    else {
        for (st=0; st<NumSamples; ++st) {
            // Calculate sum and difference
            ChannelOffset = st * echannelCount;
            FilterLeft = *(Localizer->FilterOut[tagLeft] + st);
            FilterRight = *(Localizer->FilterOut[tagRight] + st);
            Sum = FilterRight + FilterLeft;
            Difference = FilterRight - FilterLeft;
            
            // Saturate sum to maximum
            if (Sum > MaxSaturation) {
                Sum = MaxSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Sum exceeded maximum saturation value\n")
                );
            }
            
            // Saturate sum to minimum
            if (Sum < MinSaturation) {
                Sum = MinSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Sum exceeded minimum saturation value\n")
                );
            }

            // Saturate difference to maximum
            if (Difference > MaxSaturation) {
                Difference = MaxSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Difference exceeded maximum saturation value\n")
                );
            }
            
            // Saturate difference to minimum
            if (Difference < MinSaturation) {
                Difference = MinSaturation;
                _DbgPrintF
                (
                    DEBUGLVL_VERBOSE,
                    ("Difference exceeded minimum saturation value\n")
                );
            }

            // Assign sum and difference
            OutLeft[ChannelOffset] = Difference;
            OutRight[ChannelOffset] = Sum;
        }
    }
}
#endif


// Initialize data
NTSTATUS ShortLocalizerInitData
(
    PSHORT_LOCALIZER            Localizer,
    KSDS3D_HRTF_FILTER_METHOD   FilterMethod, 
    UINT                        MaxSize,
    KSDS3D_HRTF_FILTER_QUALITY  Quality,
    UINT                        FilterMuteLength,
    UINT                        FilterOverlapLength,
    UINT                        OutputOverlapLength  
)
{
    UINT Filter;
    NTSTATUS Status;

    ASSERT(FilterMethod >= 0 && FilterMethod < KSDS3D_FILTER_METHOD_COUNT);

    ShortLocalizerFreeBufferMemory(Localizer);
    
    Localizer->PreviousNumSamples = 0;
    Localizer->FirstUpdate = TRUE;
    Localizer->OutputOverlapLength = OutputOverlapLength;

    Status = ShortLocalizerSetTransitionBufferLength
             ( 
                 Localizer, 
                 FilterMuteLength,
                 FilterOverlapLength 
             ); 

    for (Filter=0; Filter<efilterCount && NT_SUCCESS(Status); ++Filter) {
        // Check for filter method
        switch (FilterMethod) {
            case CASCADE_FORM:
                // cascade form is supported
                if(Localizer->RsIir[Filter])
                    RsIirDestroy(Localizer->RsIir[Filter]);
                    
                Status = RsIirCreate(&(Localizer->RsIir[Filter]));
                
                if(NT_SUCCESS(Status)) {
                    Status = RsIirInitData(Localizer->RsIir[Filter], MAX_BIQUADS, Quality);
                }
                
            break;
    
            default:
                // All others are not supported
                Localizer->RsIir[Filter] = NULL;
                Status = STATUS_INVALID_PARAMETER;
                ASSERT(0);
            break;

        }

        Localizer->FilterOut[Filter] = NULL;
    }

    // If failure, free other memory.
    if (!NT_SUCCESS(Status)) {
        for (Filter=0; Filter<efilterCount; ++Filter) {
            if(Localizer->OverlapBuffer[Filter]) {
                ExFreePool(Localizer->OverlapBuffer[Filter]);
                Localizer->OverlapBuffer[Filter] = NULL;
            }
            RsIirDestroy(Localizer->RsIir[Filter]);
            Localizer->RsIir[Filter] = NULL;
        }
    }


    return Status;
}


// Update Filter Coefficients 
NTSTATUS ShortLocalizerUpdateCoeffs
(
    PSHORT_LOCALIZER    Localizer,
    UINT                NumSigmaCoeffs,
    PSHORT              pSigmaCoeffs,
    SHORT               SigmaGain,
    UINT                NumDeltaCoeffs,
    PSHORT              pDeltaCoeffs,
    SHORT               DeltaGain,
    BOOL                SwapChannels,
    BOOL                ZeroAzimuth,
    BOOL                CrossFadeOutput
)
{
    NTSTATUS    Status;
    BOOL        DoOverlap;

    Localizer->SwapChannels = SwapChannels;
    Localizer->ZeroAzimuth = ZeroAzimuth;
    Localizer->CrossFadeOutput = CrossFadeOutput;

    if(!Localizer->FirstUpdate)
    {
        DoOverlap = TRUE;
    }
    else
    {
        DoOverlap = FALSE;
        Localizer->FirstUpdate = FALSE;
    }

    Status = RsIirSetCoeffs(Localizer->RsIir[tagSigma], pSigmaCoeffs, NumSigmaCoeffs, SigmaGain, DoOverlap);
    if (NT_SUCCESS(Status) && ZeroAzimuth == FALSE) {
        if(!ZeroAzimuth) {
            Status = RsIirSetCoeffs(Localizer->RsIir[tagDelta], pDeltaCoeffs, NumDeltaCoeffs, DeltaGain, DoOverlap);
        } else {
            Status = RsIirSetCoeffs(Localizer->RsIir[tagDelta], &(Localizer->ZeroCoeffs[0]), 5, 0, DoOverlap);
        }
    }

    return Status;
}


// Free buffer memory
VOID ShortLocalizerFreeBufferMemory
(
    PSHORT_LOCALIZER Localizer
)
{
    UINT Filter;

    for (Filter=0; Filter<efilterCount; ++Filter) {
        if(Localizer->FilterOut[Filter]) {
            ExFreePool(Localizer->FilterOut[Filter]);
            Localizer->FilterOut[Filter] = NULL;
        }
    }
}

// Set transition buffer length
NTSTATUS ShortLocalizerSetTransitionBufferLength
(
    PSHORT_LOCALIZER Localizer,
    UINT MuteLength,
    UINT OverlapLength
)
{
    NTSTATUS Status;

    ASSERT(OverlapLength > 0);
    ASSERT(MuteLength > 0);
    ASSERT(OverlapLength > MuteLength);
    
    Status = ShortLocalizerSetOverlapLength(Localizer,OverlapLength);
    if(NT_SUCCESS(Status)) {
        Localizer->FilterMuteLength = MuteLength;
    }

    return(Status);
}

// Set overlap buffer length
NTSTATUS ShortLocalizerSetOverlapLength
(
    PSHORT_LOCALIZER Localizer,
    UINT OverlapLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLONG SigmaOverlapBuffer;
    PLONG DeltaOverlapBuffer;

    ASSERT(OverlapLength > 0);

    // Grow overlap buffer if necessary
    if (!Localizer->OverlapBuffer[tagSigma] ||
        !Localizer->OverlapBuffer[tagDelta] ||
        OverlapLength > Localizer->FilterOverlapLength) {

        SigmaOverlapBuffer = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                OverlapLength*sizeof(LONG), 
                'XIMK'
            );

        if(!SigmaOverlapBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if(NT_SUCCESS(Status)) {
            
            DeltaOverlapBuffer = 
                ExAllocatePoolWithTag
                (
                    PagedPool, 
                    OverlapLength*sizeof(LONG), 
                    'XIMK'
                );

            if(!DeltaOverlapBuffer) {
                ExFreePool(SigmaOverlapBuffer);
                SigmaOverlapBuffer = NULL;
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if(NT_SUCCESS(Status)) {
            if (Localizer->OverlapBuffer[tagSigma]) {
                ExFreePool(Localizer->OverlapBuffer[tagSigma]);
            }
            Localizer->OverlapBuffer[tagSigma] = SigmaOverlapBuffer;

            if (Localizer->OverlapBuffer[tagDelta]) {
                ExFreePool(Localizer->OverlapBuffer[tagDelta]);
            }
            Localizer->OverlapBuffer[tagDelta] = DeltaOverlapBuffer;

            Localizer->FilterOverlapLength = OverlapLength;
        }

    }

    return(Status);

}


// Filter a block of samples
VOID ShortLocalizerFilterOverlap
(
    PSHORT_LOCALIZER Localizer,
    UINT    Filter,
    PLONG   InData, 
    PLONG   OutData, 
    UINT    NumSamples
)
{
    SHORT_IIR_STATE iirstateNew;
    PRSIIR Iir;
    PLONG OverlapBuffer;
    UINT NumOverlapSamples;
    WORD NumOverlapSamplesFactor;
    UINT FilterMuteLength;
    UINT st;
    WORD CrossFadeFactor;
    LONG CrossFadeSample;
    UINT BitsPerShortMinus1;

    ASSERT(InData);
    ASSERT(OutData);

    Iir = Localizer->RsIir[Filter];
    OverlapBuffer = Localizer->OverlapBuffer[Filter];

    // Process overlap, if necessary
    if (TRUE == Iir->DoOverlap) {
        // Save current (i.e. new) filter state (with the new coefficients), 
        // don't copy biquad state information because it's all zeros anyway
        RsIirGetState(Iir, &iirstateNew, FALSE);

        // Reset old filter state, including biquad state information
        RsIirSetState(Iir, &(Iir->iirstateOld), TRUE);

        // Determine size of overlap buffer
        if (NumSamples >= Localizer->FilterOverlapLength)
            NumOverlapSamples = Localizer->FilterOverlapLength;
        else
            NumOverlapSamples = NumSamples;
        
        // Filter overlap buffer
        Iir->FunctionFilter(Iir, InData, OverlapBuffer, NumOverlapSamples);  

        // Initialize the filter's tap delay line
        RsIirInitTapDelayLine(&iirstateNew, InData[0]);
        
        // Set back to current (i.e. new) filter state 
        // without biquad state information because we will initialize it explicitly
        RsIirSetState(Iir, &iirstateNew, TRUE);

    }


    // Filter "real" data
    Iir->FunctionFilter(Iir, InData, OutData, NumSamples);
    
    // Process overlap buffer
    if (Iir->DoOverlap == TRUE) {
        // Clamp length down
        ASSERT(Localizer->FilterMuteLength < Localizer->FilterOverlapLength);
        if (Localizer->FilterMuteLength > NumOverlapSamples)
            FilterMuteLength = NumOverlapSamples;
        else
            FilterMuteLength = Localizer->FilterMuteLength;

        // Copy data from old filter for transient mute length
        RtlCopyBytes(OutData, OverlapBuffer, FilterMuteLength * sizeof(LONG));
        
        if (NumOverlapSamples > FilterMuteLength) {
            // Cross-fade into new filter data for rest of buffer
            NumOverlapSamplesFactor = (WORD)(SHRT_MAX / (NumOverlapSamples - FilterMuteLength + 1));
            BitsPerShortMinus1 = BitsPerShort - 1;
            for (st=FilterMuteLength; st<NumOverlapSamples; ++st) {

                // Calculate cross-faded sample
                CrossFadeFactor = (WORD)((st - FilterMuteLength) * NumOverlapSamplesFactor);
                CrossFadeSample = (LONG)((((LONG)(CrossFadeFactor) * OutData[st]) / 32768) 
                                  + (((LONG)(SHRT_MAX - CrossFadeFactor) * OverlapBuffer[st]) / 32768));

                // Saturate to maximum
                if (CrossFadeSample > MaxSaturation) {
                    CrossFadeSample = MaxSaturation;
                    _DbgPrintF
                    (
                        DEBUGLVL_VERBOSE,
                        ("Cross-fade exceeded maximum saturation value\n")
                    );
                }
                
                // Saturate to minimum
                if (CrossFadeSample < MinSaturation) {
                    CrossFadeSample = MinSaturation;
                    _DbgPrintF
                    (
                        DEBUGLVL_VERBOSE,
                        ("Cross-fade exceeded minimum saturation value\n")
                    );
                }
                
                // Store cross-faded sample
                OutData[st] = CrossFadeSample;
            }
        }


        // Reset overlap flag
        Iir->DoOverlap = FALSE;
    }
    
}

// End of SHORTLOCALIZER.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\slocal.inl ===
//
//    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//    Author :: Jay Stokes
//

#if !defined(SHORTLOCALIZER_INLINE)
#define SHORTLOCALIZER_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !defined(_DEBUG)
#define INLINE __forceinline
#else
#define INLINE
#endif

// ---------------------------------------------------------------------------
// Constants

const enum EFilterMethod CeShortFilterMethodInit(tagJackson);

// ---------------------------------------------------------------------------
// Fixed-point localizer

// Default constructor
INLINE CShortLocalizer::CShortLocalizer()
{
	STATUS status;
	InitData(CeShortFilterMethodInit, &status);
	ASSERT(status == STATUS_OK);
}

// "Partial" constructor
INLINE CShortLocalizer::CShortLocalizer(const EFilterMethod CeFilterMethod, STATUS* const CpStatus)
{
	ASSERT(CeFilterMethod >= 0 && CeFilterMethod < efiltermethodCount);
	CHECK_POINTER(CpStatus);

	InitData(CeFilterMethod, CpStatus);
}

#endif

// End of SHORTLOCALIZER.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\topology.h ===
//---------------------------------------------------------------------------
//
//  Module:   topology.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     D.J. Sisolak
//	   J. Taylor
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//
// Topology Constants
//
#define TOTAL_NUM_CATEGORIES	3
#define TOTAL_NUM_NODES         11
#define TOTAL_NUM_CONNECTIONS   (TOTAL_NUM_NODES+2)

#define NODE_ID_VOLUME_SINK		0
#define NODE_ID_DOPPLER_SRC     1
#define NODE_ID_3D_EFFECTS      2
#define NODE_ID_SUPERMIX		3
#define NODE_ID_VOLUME_PAN      4
#define NODE_ID_SRC_SINK		5
#define NODE_ID_SUM				6
#define NODE_ID_VOLUME_SOURCE	7
#define NODE_ID_MATRIX_ENCODER  8
#define NODE_ID_INPUT_SUPERMIX  9 
#define NODE_ID_INPUT_SRC       10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\topology.c ===
//---------------------------------------------------------------------------
//
//  Module:   topology.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     D.J. Sisolak
//	   J. Taylor
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "topology.h"

static GUID NodeGUIDs[TOTAL_NUM_NODES] = {  { STATICGUIDOF(KSNODETYPE_VOLUME) },
                                            { STATICGUIDOF(KSNODETYPE_SRC) },
                                            { STATICGUIDOF(KSNODETYPE_3D_EFFECTS) },
											{ STATICGUIDOF(KSNODETYPE_SUPERMIX) },
											{ STATICGUIDOF(KSNODETYPE_VOLUME) },
											{ STATICGUIDOF(KSNODETYPE_SRC) },
											{ STATICGUIDOF(KSNODETYPE_SUM) },
											{ STATICGUIDOF(KSNODETYPE_VOLUME) },
                                            { STATICGUIDOF(KSNODETYPE_PROLOGIC_ENCODER) },
                                            { STATICGUIDOF(KSNODETYPE_SUPERMIX) },
                                            { STATICGUIDOF(KSNODETYPE_SRC) },
									 	 };

static const KSTOPOLOGY_CONNECTION Connections[TOTAL_NUM_CONNECTIONS] =
   { { KSFILTER_NODE,     PIN_ID_WAVEOUT_SINK, NODE_ID_VOLUME_SINK,   NODE_INPUT_PIN },
     { NODE_ID_VOLUME_SINK,   NODE_OUTPUT_PIN, NODE_ID_DOPPLER_SRC, NODE_INPUT_PIN },
     { NODE_ID_DOPPLER_SRC, NODE_OUTPUT_PIN, NODE_ID_3D_EFFECTS, NODE_INPUT_PIN },
     { NODE_ID_3D_EFFECTS,    NODE_OUTPUT_PIN, NODE_ID_SUPERMIX,      NODE_INPUT_PIN },
     { NODE_ID_SUPERMIX,      NODE_OUTPUT_PIN, NODE_ID_VOLUME_PAN,    NODE_INPUT_PIN },
     { NODE_ID_VOLUME_PAN,    NODE_OUTPUT_PIN, NODE_ID_SRC_SINK,      NODE_INPUT_PIN },
     { NODE_ID_SRC_SINK,      NODE_OUTPUT_PIN, NODE_ID_SUM,           NODE_INPUT_PIN },
     { NODE_ID_SUM,           NODE_OUTPUT_PIN, NODE_ID_MATRIX_ENCODER, NODE_INPUT_PIN },
     { NODE_ID_MATRIX_ENCODER, NODE_OUTPUT_PIN, NODE_ID_VOLUME_SOURCE, NODE_INPUT_PIN },
     { NODE_ID_VOLUME_SOURCE, NODE_OUTPUT_PIN, KSFILTER_NODE,  PIN_ID_WAVEOUT_SOURCE },
     { KSFILTER_NODE,           PIN_ID_WAVEIN_SOURCE,   NODE_ID_INPUT_SUPERMIX, NODE_INPUT_PIN },
     { NODE_ID_INPUT_SUPERMIX,  NODE_OUTPUT_PIN,        NODE_ID_INPUT_SRC,      NODE_INPUT_PIN },
     { NODE_ID_INPUT_SRC,       NODE_OUTPUT_PIN,        KSFILTER_NODE,          PIN_ID_WAVEIN_SINK }
};

static GUID CategoryGUIDs[TOTAL_NUM_CATEGORIES] = { { STATICGUIDOF(KSCATEGORY_MIXER) },
                                                    { STATICGUIDOF(KSCATEGORY_AUDIO) },
                                                    { STATICGUIDOF(KSCATEGORY_DATATRANSFORM) }
                                                  };
                                                    

static const KSTOPOLOGY KmixerTopology = { TOTAL_NUM_CATEGORIES,
                              			   CategoryGUIDs,
                              			   TOTAL_NUM_NODES,
                              			   NodeGUIDs,
                              			   TOTAL_NUM_CONNECTIONS,
                              			   Connections
                            		     };


NTSTATUS
FilterTopologyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
)
{
    NTSTATUS Status;

    Status = KsTopologyPropertyHandler(pIrp, pProperty, pData, &KmixerTopology);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\src.c ===
//---------------------------------------------------------------------------
//
//  Module:   src.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fir.h"

#pragma LOCKED_DATA
DWORD	PreferredQuality;
DWORD	CaptureQuality = KSAUDIO_QUALITY_ADVANCED;
DWORD   AverageTicksPerInitSrc = 0;

ULONG   FilterSizeFromQuality[] = { FILTER_SIZE_NONE, 
                                    FILTER_SIZE_LOW, 
                                    FILTER_SIZE_BASIC, 
                                    FILTER_SIZE_ADVANCED };
                                    
PFLOAT   FilterTableFromQuality[] = { DuplicatingFilter, LowQualityFilter, BasicFilter, AdvancedFilter };

extern DWORD AverageTicksPerBuffer;
extern DWORD AverageFrequency;

/*
Speaker	Location    (x,y,z)
Front Left	        (-4, 0, 4)
Front Right	        (4,0,4)
Front Center	    (0,0,4)
Sub	                (1000, 1000, 1000) // (0, 0, 0)
Back Left	        (-4,0,-4)
Back Right	        (4,0,-4)
Front Left of Center	(-2,0,4)
Front Right of Center	(2,0,4)
Back Center	        (0,0,-4)
Side Left	        (-4,0,0)
Side Right	        (4,0,0)
Top Center	        (0,4,0)
Top Front Left	    (-4,4,4)
Top Front Center	(0,4,4)
Top Front Right	    (4,4,4)
Top Back Left	    (-4,4,-4)
Top Back Center	    (0,4,-4)
Top Back Right	    (4,4,-4)
*/
FLOAT   SpeakerLocation[][3] = {
    {-4, 0, 4 },
    {4, 0, 4},
    {0, 0, 4},
    {1000, 1000, 1000}, //{0, 0, 0},
    {-4, 0, -4},
    {4, 0, -4},
    {-2, 0, 4},
    {2, 0, 4},
    {0, 0, -4},
    {-4, 0, 0},
    {4, 0, 0},
    {0, 4, 0},
    {-4, 4, 4},
    {0, 4, 4},
    {4, 4, 4},
    {-4, 4, -4},
    {0, 4, -4},
    {4, 4, -4}
};

ULONG ChannelMask[] = {
    SPEAKER_FRONT_LEFT            ,
    SPEAKER_FRONT_RIGHT           ,
    SPEAKER_FRONT_CENTER          ,
    SPEAKER_LOW_FREQUENCY         ,
    SPEAKER_BACK_LEFT             ,
    SPEAKER_BACK_RIGHT            ,
    SPEAKER_FRONT_LEFT_OF_CENTER  ,
    SPEAKER_FRONT_RIGHT_OF_CENTER ,
    SPEAKER_BACK_CENTER           ,
    SPEAKER_SIDE_LEFT             ,
    SPEAKER_SIDE_RIGHT            ,
    SPEAKER_TOP_CENTER            ,
    SPEAKER_TOP_FRONT_LEFT        ,
    SPEAKER_TOP_FRONT_CENTER      ,
    SPEAKER_TOP_FRONT_RIGHT       ,
    SPEAKER_TOP_BACK_LEFT         ,
    SPEAKER_TOP_BACK_CENTER       ,
    SPEAKER_TOP_BACK_RIGHT
};

ULONG   nPossibleSpeakers = (sizeof(ChannelMask)/sizeof(ULONG));

FLOAT   SpeakerMap[32][32];

DWORD   UpFraction[160] = {
    10485760L, 5242880L, 3495253L, 2621440L, 2097152L, 1747627L, 1497966L, 1310720L, 1165084L,
    1048576L, 953251L, 873813L, 806597L, 748983L, 699051L, 655360L, 616809L, 582542L,
    551882L, 524288L, 499322L, 476625L, 455903L, 436907L, 419430L, 403298L, 388361L,
    374491L, 361578L, 349525L, 338250L, 327680L, 317750L, 308405L, 299593L, 291271L,
    283399L, 275941L, 268866L, 262144L, 255750L, 249661L, 243855L, 238313L, 233017L,
    227951L, 223101L, 218453L, 213995L, 209715L, 205603L, 201649L, 197845L, 194181L,
    190650L, 187246L, 183961L, 180789L, 177725L, 174763L, 171898L, 169125L, 166441L,
    163840L, 161319L, 158875L, 156504L, 154202L, 151968L, 149797L, 147687L, 145636L,
    143641L, 141699L, 139810L, 137971L, 136179L, 134433L, 132731L, 131072L, 129454L,
    127875L, 126334L, 124830L, 123362L, 121927L, 120526L, 119156L, 117818L, 116508L,
    115228L, 113976L, 112750L, 111551L, 110376L, 109227L, 108101L, 106998L, 105917L,
    104858L, 103819L, 102802L, 101803L, 100825L, 99864L, 98922L, 97998L, 97090L,
    96200L, 95325L, 94466L, 93623L, 92794L, 91980L, 91181L, 90394L, 89622L,
    88862L, 88116L, 87381L, 86659L, 85949L, 85250L, 84563L, 83886L, 83220L,
    82565L, 81920L, 81285L, 80660L, 80044L, 79438L, 78840L, 78252L, 77672L,
    77101L, 76538L, 75984L, 75437L, 74898L, 74367L, 73843L, 73327L, 72818L,
    72316L, 71820L, 71332L, 70850L, 70374L, 69905L, 69442L, 68985L, 68534L,
    68089L, 67650L, 67216L, 66788L, 66366L, 65948L, 65536L
    };

DWORD   DownFraction[160] = {
    410L, 819L, 1229L, 1638L, 2048L, 2458L, 2867L, 3277L, 3686L,
    4096L, 4506L, 4915L, 5325L, 5734L, 6144L, 6554L, 6963L, 7373L,
    7782L, 8192L, 8602L, 9011L, 9421L, 9830L, 10240L, 10650L, 11059L,
    11469L, 11878L, 12288L, 12698L, 13107L, 13517L, 13926L, 14336L, 14746L,
    15155L, 15565L, 15974L, 16384L, 16794L, 17203L, 17613L, 18022L, 18432L,
    18842L, 19251L, 19661L, 20070L, 20480L, 20890L, 21299L, 21709L, 22118L,
    22528L, 22938L, 23347L, 23757L, 24166L, 24576L, 24986L, 25395L, 25805L,
    26214L, 26624L, 27034L, 27443L, 27853L, 28262L, 28672L, 29082L, 29491L,
    29901L, 30310L, 30720L, 31130L, 31539L, 31949L, 32358L, 32768L, 33178L,
    33587L, 33997L, 34406L, 34816L, 35226L, 35635L, 36045L, 36454L, 36864L,
    37274L, 37683L, 38093L, 38502L, 38912L, 39322L, 39731L, 40141L, 40550L,
    40960L, 41370L, 41779L, 42189L, 42598L, 43008L, 43418L, 43827L, 44237L,
    44646L, 45056L, 45466L, 45875L, 46285L, 46694L, 47104L, 47514L, 47923L,
    48333L, 48742L, 49152L, 49562L, 49971L, 50381L, 50790L, 51200L, 51610L,
    52019L, 52429L, 52838L, 53248L, 53658L, 54067L, 54477L, 54886L, 55296L,
    55706L, 56115L, 56525L, 56934L, 57344L, 57754L, 58163L, 58573L, 58982L,
    59392L, 59802L, 60211L, 60621L, 61030L, 61440L, 61850L, 62259L, 62669L,
    63078L, 63488L, 63898L, 64307L, 64717L, 65126L, 65536L
    };

// Pseudo-equivalent to duplicating samples
FLOAT	DuplicatingFilter[] = {
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
	};

// Designed with Hamming Window, 1 Hz cutoff specified
FLOAT    LowQualityFilter[] = {
    1.567341E-06f,4.736425E-06f,7.968684E-06f,1.128541E-05f,1.470836E-05f,1.825971E-05f,
    2.196204E-05f,2.583832E-05f,2.991184E-05f,3.420622E-05f,3.874538E-05f,4.355348E-05f,
    4.865491E-05f,5.407425E-05f,5.983625E-05f,6.596577E-05f,7.248777E-05f,7.942729E-05f,
    8.680938E-05f,9.465909E-05f,1.030014E-04f,1.118612E-04f,1.212635E-04f,1.312327E-04f,
    1.417934E-04f,1.529698E-04f,1.647860E-04f,1.772656E-04f,1.904322E-04f,2.043086E-04f,
    2.189176E-04f,2.342813E-04f,2.504215E-04f,2.673593E-04f,2.851156E-04f,3.037104E-04f,
    3.231633E-04f,3.434931E-04f,3.647181E-04f,3.868559E-04f,4.099232E-04f,4.339360E-04f,
    4.589098E-04f,4.848588E-04f,5.117966E-04f,5.397362E-04f,5.686890E-04f,5.986663E-04f,
    6.296777E-04f,6.617323E-04f,6.948382E-04f,7.290021E-04f,7.642301E-04f,8.005272E-04f,
    8.378967E-04f,8.763417E-04f,9.158637E-04f,9.564629E-04f,9.981388E-04f,1.040890E-03f,
    1.084712E-03f,1.129602E-03f,1.175555E-03f,1.222563E-03f,1.270619E-03f,1.319714E-03f,
    1.369838E-03f,1.420980E-03f,1.473126E-03f,1.526264E-03f,1.580378E-03f,1.635452E-03f,
    1.691468E-03f,1.748409E-03f,1.806254E-03f,1.864983E-03f,1.924573E-03f,1.985002E-03f,
    2.046245E-03f,2.108276E-03f,2.171070E-03f,2.234597E-03f,2.298831E-03f,2.363740E-03f,
    2.429295E-03f,2.495464E-03f,2.562213E-03f,2.629510E-03f,2.697319E-03f,2.765606E-03f,
    2.834333E-03f,2.903465E-03f,2.972962E-03f,3.042786E-03f,3.112897E-03f,3.183257E-03f,
    3.253822E-03f,3.324553E-03f,3.395407E-03f,3.466341E-03f,3.537312E-03f,3.608277E-03f,
    3.679192E-03f,3.750013E-03f,3.820693E-03f,3.891189E-03f,3.961454E-03f,4.031444E-03f,
    4.101113E-03f,4.170414E-03f,4.239303E-03f,4.307731E-03f,4.375653E-03f,4.443025E-03f,
    4.509799E-03f,4.575930E-03f,4.641371E-03f,4.706078E-03f,4.770006E-03f,4.833109E-03f,
    4.895343E-03f,4.956665E-03f,5.017030E-03f,5.076394E-03f,5.134717E-03f,5.191955E-03f,
    5.248067E-03f,5.303012E-03f,5.356751E-03f,5.409244E-03f,5.460451E-03f,5.510337E-03f,
    5.558863E-03f,5.605994E-03f,5.651694E-03f,5.695930E-03f,5.738669E-03f,5.779878E-03f,
    5.819527E-03f,5.857586E-03f,5.894025E-03f,5.928819E-03f,5.961938E-03f,5.993360E-03f,
    6.023060E-03f,6.051016E-03f,6.077205E-03f,6.101609E-03f,6.124209E-03f,6.144986E-03f,
    6.163925E-03f,6.181013E-03f,6.196235E-03f,6.209581E-03f,6.221038E-03f,6.230601E-03f,
    6.238258E-03f,6.244007E-03f,6.247842E-03f,6.249760E-03f
    };

// Parks-McLellan
FLOAT BasicFilter[] = {
    -9.160633e-006f,-9.160633e-006f,-9.105556e-006f,-9.338961e-006f,-9.259826e-006f,-9.476174e-006f,-9.370993e-006f,
    -9.575547e-006f,-9.443120e-006f,-9.647232e-006f,-9.487786e-006f,-9.717719e-006f,-9.533750e-006f,-9.864323e-006f,-9.658475e-006f,
    -1.054493e-005f,-9.982673e-006f,-9.580004e-006f,-9.913700e-006f,-9.786861e-006f,-9.832148e-006f,-9.765807e-006f,-9.735353e-006f,
    -9.681824e-006f,-9.610846e-006f,-9.558508e-006f,-9.467371e-006f,-9.419735e-006f,-9.333107e-006f,-9.303290e-006f,-9.256796e-006f,
    -9.215418e-006f,-8.798675e-006f,-8.898468e-006f,-8.677027e-006f,-8.602642e-006f,-8.382921e-006f,-8.276985e-006f,-8.040300e-006f,
    -7.908497e-006f,-7.655775e-006f,-7.504598e-006f,-7.244080e-006f,-7.081988e-006f,-6.823563e-006f,-6.645749e-006f,-6.374977e-006f,
    -6.052994e-006f,-5.770171e-006f,-5.580995e-006f,-5.193900e-006f,-4.962792e-006f,-4.569512e-006f,-4.305015e-006f,-3.892758e-006f,
    -3.602357e-006f,-3.173073e-006f,-2.864805e-006f,-2.423051e-006f,-2.101680e-006f,-1.641120e-006f,-1.291685e-006f,-7.691069e-007f,
    -3.736922e-007f,7.200906e-008f,5.187566e-007f,1.031290e-006f,1.474897e-006f,2.020546e-006f,2.485369e-006f,3.055744e-006f,
    3.539921e-006f,4.129118e-006f,4.629018e-006f,5.235686e-006f,5.755703e-006f,6.392456e-006f,6.948481e-006f,7.624929e-006f,
    8.150384e-006f,8.842208e-006f,9.441539e-006f,1.013306e-005f,1.075602e-005f,1.147366e-005f,1.211762e-005f,1.285602e-005f,
    1.351830e-005f,1.427403e-005f,1.495493e-005f,1.573133e-005f,1.643953e-005f,1.724373e-005f,1.797991e-005f,1.878077e-005f,
    1.951801e-005f,2.038206e-005f,2.113198e-005f,2.200412e-005f,2.278481e-005f,2.367269e-005f,2.447382e-005f,2.537706e-005f,
    2.619553e-005f,2.711490e-005f,2.795329e-005f,2.889399e-005f,2.975571e-005f,3.071386e-005f,3.158296e-005f,3.253944e-005f,
    3.345302e-005f,3.443266e-005f,3.534290e-005f,3.634919e-005f,3.727360e-005f,3.829332e-005f,3.923073e-005f,4.026236e-005f,
    4.121265e-005f,4.225831e-005f,4.322404e-005f,4.428471e-005f,4.526071e-005f,4.632611e-005f,4.730171e-005f,4.839058e-005f,
    4.939193e-005f,5.047020e-005f,5.148681e-005f,5.257833e-005f,5.359900e-005f,5.469858e-005f,5.572452e-005f,5.683088e-005f,
    5.786372e-005f,5.897754e-005f,6.001664e-005f,6.113277e-005f,6.217019e-005f,6.328346e-005f,6.432866e-005f,6.545950e-005f,
    6.649240e-005f,6.762116e-005f,6.866471e-005f,6.978748e-005f,7.083141e-005f,7.195195e-005f,7.299492e-005f,7.411393e-005f,
    7.515593e-005f,7.627150e-005f,7.730780e-005f,7.841364e-005f,7.944170e-005f,8.054353e-005f,8.157649e-005f,8.266426e-005f,
    8.367980e-005f,8.477008e-005f,8.577236e-005f,8.685033e-005f,8.784344e-005f,8.890962e-005f,8.989273e-005f,9.094708e-005f,
    9.191755e-005f,9.295600e-005f,9.390885e-005f,9.493007e-005f,9.586959e-005f,9.688115e-005f,9.780261e-005f,9.878495e-005f,
    9.969663e-005f,1.006607e-004f,1.015470e-004f,1.024930e-004f,1.033575e-004f,1.042826e-004f,1.051251e-004f,1.060267e-004f,
    1.068434e-004f,1.077178e-004f,1.085079e-004f,1.093586e-004f,1.101264e-004f,1.109504e-004f,1.116812e-004f,1.124803e-004f,
    1.131881e-004f,1.139502e-004f,1.146306e-004f,1.153625e-004f,1.160117e-004f,1.167120e-004f,1.173278e-004f,1.179928e-004f,
    1.185724e-004f,1.192018e-004f,1.197480e-004f,1.203441e-004f,1.208541e-004f,1.214066e-004f,1.218785e-004f,1.224004e-004f,
    1.228279e-004f,1.233102e-004f,1.237015e-004f,1.241430e-004f,1.244951e-004f,1.248944e-004f,1.252039e-004f,1.255592e-004f,
    1.258259e-004f,1.261393e-004f,1.263646e-004f,1.266331e-004f,1.268099e-004f,1.270305e-004f,1.271686e-004f,1.273404e-004f,
    1.274285e-004f,1.275581e-004f,1.275978e-004f,1.276805e-004f,1.276723e-004f,1.277056e-004f,1.276482e-004f,1.276327e-004f,
    1.275279e-004f,1.274644e-004f,1.273094e-004f,1.271929e-004f,1.269855e-004f,1.268229e-004f,1.265654e-004f,1.263461e-004f,
    1.260419e-004f,1.257713e-004f,1.254142e-004f,1.250918e-004f,1.246813e-004f,1.243063e-004f,1.238439e-004f,1.234179e-004f,
    1.229044e-004f,1.224253e-004f,1.218570e-004f,1.213238e-004f,1.207056e-004f,1.201224e-004f,1.194466e-004f,1.188132e-004f,
    1.180880e-004f,1.173995e-004f,1.166230e-004f,1.158808e-004f,1.150519e-004f,1.142577e-004f,1.133780e-004f,1.125327e-004f,
    1.116008e-004f,1.107020e-004f,1.097179e-004f,1.087696e-004f,1.077375e-004f,1.067351e-004f,1.056525e-004f,1.046046e-004f,
    1.034700e-004f,1.023730e-004f,1.011901e-004f,1.000440e-004f,9.881398e-005f,9.762101e-005f,9.634439e-005f,9.510364e-005f,
    9.377891e-005f,9.249116e-005f,9.112230e-005f,8.979129e-005f,8.837617e-005f,8.699882e-005f,8.554475e-005f,8.412278e-005f,
    8.262478e-005f,8.116219e-005f,7.962239e-005f,7.812070e-005f,7.654215e-005f,7.500196e-005f,7.338443e-005f,7.180511e-005f,
    7.015001e-005f,6.853542e-005f,6.684624e-005f,6.519582e-005f,6.347021e-005f,6.178946e-005f,6.003190e-005f,5.831599e-005f,
    5.652925e-005f,5.478267e-005f,5.296701e-005f,5.119302e-005f,4.935029e-005f,4.754924e-005f,4.567996e-005f,4.385382e-005f,
    4.196201e-005f,4.011414e-005f,3.820005e-005f,3.632922e-005f,3.439684e-005f,3.250905e-005f,3.055531e-005f,2.865160e-005f,
    2.668294e-005f,2.476401e-005f,2.278277e-005f,2.085047e-005f,1.885713e-005f,1.691301e-005f,1.491008e-005f,1.295830e-005f,
    1.094919e-005f,8.990598e-006f,6.974988e-006f,5.012706e-006f,2.996588e-006f,1.029786e-006f,-9.874146e-007f,-2.951448e-006f,
    -4.967662e-006f,-6.927690e-006f,-8.939552e-006f,-1.089526e-005f,-1.290155e-005f,-1.485009e-005f,-1.684688e-005f,-1.878488e-005f,
    -2.077105e-005f,-2.269809e-005f,-2.467080e-005f,-2.658144e-005f,-2.853974e-005f,-3.043547e-005f,-3.237284e-005f,-3.424989e-005f,
    -3.616644e-005f,-3.802136e-005f,-3.991557e-005f,-4.174651e-005f,-4.361546e-005f,-4.541914e-005f,-4.725980e-005f,-4.903510e-005f,
    -5.084681e-005f,-5.259111e-005f,-5.436912e-005f,-5.608032e-005f,-5.782592e-005f,-5.949922e-005f,-6.120713e-005f,-6.284351e-005f,
    -6.451118e-005f,-6.610842e-005f,-6.773495e-005f,-6.928930e-005f,-7.087114e-005f,-7.238007e-005f,-7.391622e-005f,-7.537918e-005f,
    -7.686731e-005f,-7.828044e-005f,-7.971828e-005f,-8.108242e-005f,-8.246684e-005f,-8.377603e-005f,-8.510776e-005f,-8.636107e-005f,
    -8.763703e-005f,-8.883389e-005f,-9.005156e-005f,-9.118911e-005f,-9.234607e-005f,-9.342320e-005f,-9.451901e-005f,-9.553375e-005f,
    -9.656528e-005f,-9.751573e-005f,-9.848359e-005f,-9.936824e-005f,-1.002671e-004f,-1.010859e-004f,-1.019168e-004f,-1.026662e-004f,
    -1.034283e-004f,-1.041067e-004f,-1.047973e-004f,-1.054040e-004f,-1.060227e-004f,-1.065572e-004f,-1.071025e-004f,-1.075624e-004f,
    -1.080329e-004f,-1.084187e-004f,-1.088138e-004f,-1.091216e-004f,-1.094409e-004f,-1.096731e-004f,-1.099141e-004f,-1.100696e-004f,
    -1.102319e-004f,-1.103083e-004f,-1.103914e-004f,-1.103890e-004f,-1.103934e-004f,-1.103117e-004f,-1.102358e-004f,-1.100740e-004f,
    -1.099187e-004f,-1.096770e-004f,-1.094396e-004f,-1.091171e-004f,-1.088011e-004f,-1.083971e-004f,-1.080006e-004f,-1.075164e-004f,
    -1.070384e-004f,-1.064740e-004f,-1.059155e-004f,-1.052713e-004f,-1.046326e-004f,-1.039081e-004f,-1.031895e-004f,-1.023863e-004f,
    -1.015888e-004f,-1.007058e-004f,-9.982891e-005f,-9.886950e-005f,-9.791424e-005f,-9.687659e-005f,-9.584474e-005f,-9.472937e-005f,
    -9.362124e-005f,-9.243060e-005f,-9.124785e-005f,-8.998260e-005f,-8.872511e-005f,-8.738626e-005f,-8.605633e-005f,-8.464581e-005f,
    -8.324383e-005f,-8.176210e-005f,-8.029164e-005f,-7.874143e-005f,-7.720116e-005f,-7.558423e-005f,-7.397646e-005f,-7.229326e-005f,
    -7.062100e-005f,-6.887380e-005f,-6.713869e-005f,-6.532912e-005f,-6.353253e-005f,-6.166313e-005f,-5.980762e-005f,-5.787971e-005f,
    -5.596663e-005f,-5.398397e-005f,-5.201726e-005f,-4.997988e-005f,-4.796122e-005f,-4.587306e-005f,-4.380379e-005f,-4.166789e-005f,
    -3.955134e-005f,-3.736934e-005f,-3.520745e-005f,-3.298208e-005f,-3.077848e-005f,-2.851273e-005f,-2.626935e-005f,-2.396526e-005f,
    -2.168585e-005f,-1.934779e-005f,-1.703363e-005f,-1.466303e-005f,-1.231912e-005f,-9.918665e-006f,-7.547899e-006f,-5.122011e-006f,
    -2.726637e-006f,-2.778809e-007f,2.139338e-006f,4.607457e-006f,7.042396e-006f,9.526992e-006f,1.197705e-005f,1.447417e-005f,
    1.693480e-005f,1.944229e-005f,2.191217e-005f,2.442513e-005f,2.690035e-005f,2.941631e-005f,3.189215e-005f,3.440804e-005f,
    3.688187e-005f,3.939387e-005f,4.186181e-005f,4.436636e-005f,4.682544e-005f,4.931922e-005f,5.176519e-005f,5.424359e-005f,
    5.667353e-005f,5.913493e-005f,6.154436e-005f,6.398394e-005f,6.637077e-005f,6.878435e-005f,7.114498e-005f,7.353032e-005f,
    7.586089e-005f,7.821404e-005f,8.051034e-005f,8.282811e-005f,8.508755e-005f,8.736600e-005f,8.958410e-005f,9.182011e-005f,
    9.399494e-005f,9.618451e-005f,9.831080e-005f,1.004515e-004f,1.025261e-004f,1.046140e-004f,1.066349e-004f,1.086666e-004f,
    1.106301e-004f,1.126025e-004f,1.145052e-004f,1.164151e-004f,1.182538e-004f,1.200977e-004f,1.218695e-004f,1.236456e-004f,
    1.253473e-004f,1.270507e-004f,1.286799e-004f,1.303084e-004f,1.318610e-004f,1.334128e-004f,1.348863e-004f,1.363576e-004f,
    1.377494e-004f,1.391379e-004f,1.404459e-004f,1.417486e-004f,1.429694e-004f,1.441841e-004f,1.453165e-004f,1.464409e-004f,
    1.474810e-004f,1.485129e-004f,1.494598e-004f,1.503963e-004f,1.512481e-004f,1.520878e-004f,1.528414e-004f,1.535821e-004f,
    1.542359e-004f,1.548760e-004f,1.554283e-004f,1.559659e-004f,1.564150e-004f,1.568491e-004f,1.571937e-004f,1.575215e-004f,
    1.577598e-004f,1.579817e-004f,1.581122e-004f,1.582266e-004f,1.582495e-004f,1.582545e-004f,1.581683e-004f,1.580636e-004f,
    1.578676e-004f,1.576521e-004f,1.573451e-004f,1.570188e-004f,1.566012e-004f,1.561634e-004f,1.556335e-004f,1.550834e-004f,
    1.544423e-004f,1.537800e-004f,1.530266e-004f,1.522531e-004f,1.513874e-004f,1.505021e-004f,1.495251e-004f,1.485285e-004f,
    1.474406e-004f,1.463329e-004f,1.451344e-004f,1.439167e-004f,1.426088e-004f,1.412811e-004f,1.398638e-004f,1.384282e-004f,
    1.369033e-004f,1.353597e-004f,1.337286e-004f,1.320785e-004f,1.303417e-004f,1.285872e-004f,1.267464e-004f,1.248890e-004f,
    1.229458e-004f,1.209873e-004f,1.189443e-004f,1.168863e-004f,1.147445e-004f,1.125889e-004f,1.103513e-004f,1.081010e-004f,
    1.057691e-004f,1.034263e-004f,1.010032e-004f,9.856948e-005f,9.605794e-005f,9.353656e-005f,9.093879e-005f,8.833253e-005f,
    8.565138e-005f,8.296367e-005f,8.020260e-005f,7.743577e-005f,7.459705e-005f,7.175493e-005f,6.884296e-005f,6.592824e-005f,
    6.294584e-005f,5.996294e-005f,5.691306e-005f,5.386534e-005f,5.075260e-005f,4.764332e-005f,4.447132e-005f,4.130443e-005f,
    3.807723e-005f,3.485668e-005f,3.157773e-005f,2.830753e-005f,2.498148e-005f,2.166631e-005f,1.829689e-005f,1.494019e-005f,
    1.153240e-005f,8.138560e-006f,4.696098e-006f,1.270570e-006f,-2.202164e-006f,-5.655355e-006f,-9.153411e-006f,-1.262954e-005f,
    -1.614814e-005f,-1.964321e-005f,-2.317831e-005f,-2.668689e-005f,-3.023263e-005f,-3.375028e-005f,-3.730297e-005f,-4.082444e-005f,
    -4.437883e-005f,-4.790006e-005f,-5.145055e-005f,-5.496631e-005f,-5.850868e-005f,-6.201361e-005f,-6.554269e-005f,-6.903178e-005f,
    -7.254284e-005f,-7.601140e-005f,-7.949915e-005f,-8.294176e-005f,-8.640120e-005f,-8.981346e-005f,-9.323951e-005f,-9.661575e-005f,
    -1.000040e-004f,-1.033392e-004f,-1.066839e-004f,-1.099737e-004f,-1.132698e-004f,-1.165090e-004f,-1.197516e-004f,-1.229353e-004f,
    -1.261200e-004f,-1.292426e-004f,-1.323637e-004f,-1.354210e-004f,-1.384746e-004f,-1.414615e-004f,-1.444420e-004f,-1.473543e-004f,
    -1.502572e-004f,-1.530893e-004f,-1.559105e-004f,-1.586581e-004f,-1.613924e-004f,-1.640510e-004f,-1.666942e-004f,-1.692597e-004f,
    -1.718071e-004f,-1.742745e-004f,-1.767216e-004f,-1.790872e-004f,-1.814303e-004f,-1.836894e-004f,-1.859244e-004f,-1.880735e-004f,
    -1.901956e-004f,-1.922310e-004f,-1.942369e-004f,-1.961540e-004f,-1.980404e-004f,-1.998358e-004f,-2.015989e-004f,-2.032690e-004f,
    -2.049049e-004f,-2.064466e-004f,-2.079525e-004f,-2.093624e-004f,-2.107345e-004f,-2.120097e-004f,-2.132457e-004f,-2.143826e-004f,
    -2.154795e-004f,-2.164763e-004f,-2.174308e-004f,-2.182846e-004f,-2.190949e-004f,-2.198034e-004f,-2.204669e-004f,-2.210274e-004f,
    -2.215421e-004f,-2.219532e-004f,-2.223175e-004f,-2.225770e-004f,-2.227886e-004f,-2.228952e-004f,-2.229527e-004f,-2.229044e-004f,
    -2.228072e-004f,-2.226027e-004f,-2.223489e-004f,-2.219879e-004f,-2.215766e-004f,-2.210579e-004f,-2.204882e-004f,-2.198112e-004f,
    -2.190832e-004f,-2.182476e-004f,-2.173606e-004f,-2.163663e-004f,-2.153206e-004f,-2.141675e-004f,-2.129629e-004f,-2.116517e-004f,
    -2.102887e-004f,-2.088193e-004f,-2.072991e-004f,-2.056723e-004f,-2.039951e-004f,-2.022117e-004f,-2.003786e-004f,-1.984404e-004f,
    -1.964528e-004f,-1.943607e-004f,-1.922197e-004f,-1.899756e-004f,-1.876835e-004f,-1.852889e-004f,-1.828477e-004f,-1.803051e-004f,
    -1.777164e-004f,-1.750284e-004f,-1.722951e-004f,-1.694636e-004f,-1.665881e-004f,-1.636159e-004f,-1.606016e-004f,-1.574918e-004f,
    -1.543411e-004f,-1.510967e-004f,-1.478132e-004f,-1.444376e-004f,-1.410245e-004f,-1.375216e-004f,-1.339830e-004f,-1.303561e-004f,
    -1.266959e-004f,-1.229495e-004f,-1.191713e-004f,-1.153095e-004f,-1.114181e-004f,-1.074456e-004f,-1.034455e-004f,-9.936635e-005f,
    -9.526194e-005f,-9.108138e-005f,-8.687802e-005f,-8.260057e-005f,-7.830280e-005f,-7.393426e-005f,-6.954737e-005f,-6.509246e-005f,
    -6.062241e-005f,-5.608633e-005f,-5.153819e-005f,-4.692704e-005f,-4.230676e-005f,-3.762658e-005f,-3.293969e-005f,-2.819606e-005f,
    -2.344875e-005f,-1.864805e-005f,-1.384658e-005f,-8.994813e-006f,-4.145579e-006f,7.508872e-007f,5.641931e-006f,1.057627e-005f,
    1.550252e-005f,2.046884e-005f,2.542340e-005f,3.041482e-005f,3.539103e-005f,4.040103e-005f,4.539251e-005f,5.041392e-005f,
    5.541341e-005f,6.043957e-005f,6.544046e-005f,7.046397e-005f,7.545884e-005f,8.047336e-005f,8.545516e-005f,9.045312e-005f,
    9.541536e-005f,1.003894e-004f,1.053245e-004f,1.102677e-004f,1.151688e-004f,1.200746e-004f,1.249344e-004f,1.297951e-004f,
    1.346064e-004f,1.394152e-004f,1.441710e-004f,1.489205e-004f,1.536137e-004f,1.582969e-004f,1.629201e-004f,1.675302e-004f,
    1.720764e-004f,1.766059e-004f,1.810682e-004f,1.855101e-004f,1.898818e-004f,1.942292e-004f,1.985031e-004f,2.027494e-004f,
    2.069188e-004f,2.110571e-004f,2.151152e-004f,2.191391e-004f,2.230795e-004f,2.269819e-004f,2.307982e-004f,2.345731e-004f,
    2.382583e-004f,2.418994e-004f,2.454477e-004f,2.489488e-004f,2.523539e-004f,2.557085e-004f,2.589644e-004f,2.621671e-004f,
    2.652682e-004f,2.683127e-004f,2.712532e-004f,2.741345e-004f,2.769088e-004f,2.796214e-004f,2.822245e-004f,2.847626e-004f,
    2.871893e-004f,2.895487e-004f,2.917943e-004f,2.939700e-004f,2.960293e-004f,2.980168e-004f,2.998856e-004f,3.016804e-004f,
    3.033545e-004f,3.049524e-004f,3.064279e-004f,3.078250e-004f,3.090979e-004f,3.102910e-004f,3.113575e-004f,3.123427e-004f,
    3.132003e-004f,3.139746e-004f,3.146201e-004f,3.151805e-004f,3.156111e-004f,3.159554e-004f,3.161687e-004f,3.162943e-004f,
    3.162880e-004f,3.161933e-004f,3.159656e-004f,3.156484e-004f,3.151978e-004f,3.146568e-004f,3.139817e-004f,3.132161e-004f,
    3.123157e-004f,3.113243e-004f,3.101978e-004f,3.089800e-004f,3.076274e-004f,3.061831e-004f,3.046041e-004f,3.029336e-004f,
    3.011285e-004f,2.992320e-004f,2.972013e-004f,2.950797e-004f,2.928242e-004f,2.904781e-004f,2.879995e-004f,2.854308e-004f,
    2.827301e-004f,2.799402e-004f,2.770193e-004f,2.740104e-004f,2.708716e-004f,2.676458e-004f,2.642915e-004f,2.608518e-004f,
    2.572850e-004f,2.536338e-004f,2.498575e-004f,2.459988e-004f,2.420162e-004f,2.379532e-004f,2.337686e-004f,2.295049e-004f,
    2.251222e-004f,2.206624e-004f,2.160860e-004f,2.114348e-004f,2.066690e-004f,2.018311e-004f,1.968812e-004f,1.918618e-004f,
    1.867331e-004f,1.815374e-004f,1.762356e-004f,1.708694e-004f,1.654003e-004f,1.598701e-004f,1.542394e-004f,1.485510e-004f,
    1.427656e-004f,1.369256e-004f,1.309924e-004f,1.250077e-004f,1.189333e-004f,1.128111e-004f,1.066029e-004f,1.003503e-004f,
    9.401561e-005f,8.764056e-005f,8.118718e-005f,7.469713e-005f,6.813338e-005f,6.153658e-005f,5.486998e-005f,4.817485e-005f,
    4.141396e-005f,3.462896e-005f,2.778237e-005f,2.091599e-005f,1.399275e-005f,7.053996e-006f,6.287588e-008f,-6.939450e-006f,
    -1.398930e-005f,-2.104573e-005f,-2.814516e-005f,-3.524628e-005f,-4.238572e-005f,-4.952249e-005f,-5.669214e-005f,-6.385447e-005f,
    -7.104479e-005f,-7.822299e-005f,-8.542441e-005f,-9.260854e-005f,-9.981088e-005f,-1.069911e-004f,-1.141844e-004f,-1.213505e-004f,
    -1.285246e-004f,-1.356667e-004f,-1.428115e-004f,-1.499192e-004f,-1.570250e-004f,-1.640882e-004f,-1.711441e-004f,-1.781527e-004f,
    -1.851485e-004f,-1.920922e-004f,-1.990178e-004f,-2.058862e-004f,-2.127314e-004f,-2.195143e-004f,-2.262688e-004f,-2.329558e-004f,
    -2.396094e-004f,-2.461905e-004f,-2.527329e-004f,-2.591981e-004f,-2.656195e-004f,-2.719584e-004f,-2.782489e-004f,-2.844518e-004f,
    -2.906012e-004f,-2.966583e-004f,-3.026567e-004f,-3.085582e-004f,-3.143962e-004f,-3.201324e-004f,-3.258003e-004f,-3.313617e-004f,
    -3.368501e-004f,-3.422273e-004f,-3.475270e-004f,-3.527112e-004f,-3.578126e-004f,-3.627945e-004f,-3.676894e-004f,-3.724604e-004f,
    -3.771400e-004f,-3.816913e-004f,-3.861473e-004f,-3.904707e-004f,-3.946946e-004f,-3.987819e-004f,-4.027658e-004f,-4.066096e-004f,
    -4.103458e-004f,-4.139382e-004f,-4.174195e-004f,-4.207530e-004f,-4.239718e-004f,-4.270397e-004f,-4.299892e-004f,-4.327848e-004f,
    -4.354585e-004f,-4.379753e-004f,-4.403672e-004f,-4.425990e-004f,-4.447030e-004f,-4.466441e-004f,-4.484547e-004f,-4.500999e-004f,
    -4.516119e-004f,-4.529563e-004f,-4.541648e-004f,-4.552033e-004f,-4.561043e-004f,-4.568329e-004f,-4.574218e-004f,-4.578365e-004f,
    -4.581095e-004f,-4.582071e-004f,-4.581611e-004f,-4.579381e-004f,-4.575702e-004f,-4.570242e-004f,-4.563319e-004f,-4.554603e-004f,
    -4.544417e-004f,-4.532429e-004f,-4.518959e-004f,-4.503688e-004f,-4.486929e-004f,-4.468361e-004f,-4.448304e-004f,-4.426434e-004f,
    -4.403076e-004f,-4.377904e-004f,-4.351243e-004f,-4.322775e-004f,-4.292820e-004f,-4.261062e-004f,-4.227822e-004f,-4.192788e-004f,
    -4.156279e-004f,-4.117982e-004f,-4.078224e-004f,-4.036693e-004f,-3.993708e-004f,-3.948967e-004f,-3.902787e-004f,-3.854869e-004f,
    -3.805528e-004f,-3.754466e-004f,-3.702002e-004f,-3.647839e-004f,-3.592296e-004f,-3.535076e-004f,-3.476501e-004f,-3.416276e-004f,
    -3.354719e-004f,-3.291542e-004f,-3.227065e-004f,-3.160993e-004f,-3.093652e-004f,-3.024752e-004f,-2.954614e-004f,-2.882955e-004f,
    -2.810090e-004f,-2.735743e-004f,-2.660229e-004f,-2.583270e-004f,-2.505184e-004f,-2.425694e-004f,-2.345120e-004f,-2.263186e-004f,
    -2.180211e-004f,-2.095925e-004f,-2.010641e-004f,-1.924093e-004f,-1.836597e-004f,-1.747884e-004f,-1.658274e-004f,-1.567498e-004f,
    -1.475878e-004f,-1.383147e-004f,-1.289623e-004f,-1.195044e-004f,-1.099728e-004f,-1.003414e-004f,-9.064191e-005f,-8.084857e-005f,
    -7.099327e-005f,-6.105016e-005f,-5.105075e-005f,-4.097020e-005f,-3.083945e-005f,-2.063380e-005f,-1.038439e-005f,-6.635264e-008f,
    1.028865e-005f,2.070573e-005f,3.115324e-005f,4.165597e-005f,5.218244e-005f,6.275712e-005f,7.334884e-005f,8.398161e-005f,
    9.462436e-005f,1.053014e-004f,1.159811e-004f,1.266876e-004f,1.373898e-004f,1.481114e-004f,1.588216e-004f,1.695436e-004f,
    1.802469e-004f,1.909548e-004f,2.016364e-004f,2.123151e-004f,2.229600e-004f,2.335944e-004f,2.441875e-004f,2.547624e-004f,
    2.652887e-004f,2.757891e-004f,2.862331e-004f,2.966439e-004f,3.069904e-004f,3.172959e-004f,3.275298e-004f,3.377146e-004f,
    3.478204e-004f,3.578694e-004f,3.678319e-004f,3.777299e-004f,3.875338e-004f,3.972655e-004f,4.068954e-004f,4.164457e-004f,
    4.258867e-004f,4.352403e-004f,4.444774e-004f,4.536196e-004f,4.626378e-004f,4.715538e-004f,4.803383e-004f,4.890133e-004f,
    4.975496e-004f,5.059690e-004f,5.142427e-004f,5.223923e-004f,5.303891e-004f,5.382547e-004f,5.459608e-004f,5.535287e-004f,
    5.609300e-004f,5.681864e-004f,5.752697e-004f,5.822012e-004f,5.889533e-004f,5.955469e-004f,6.019548e-004f,6.081980e-004f,
    6.142491e-004f,6.201294e-004f,6.258114e-004f,6.313167e-004f,6.366179e-004f,6.417365e-004f,6.466456e-004f,6.513662e-004f,
    6.558717e-004f,6.601837e-004f,6.642752e-004f,6.681677e-004f,6.718349e-004f,6.752981e-004f,6.785314e-004f,6.815558e-004f,
    6.843458e-004f,6.869224e-004f,6.892603e-004f,6.913804e-004f,6.932579e-004f,6.949137e-004f,6.963230e-004f,6.975067e-004f,
    6.984407e-004f,6.991456e-004f,6.995973e-004f,6.998171e-004f,6.997805e-004f,6.995092e-004f,6.989789e-004f,6.982111e-004f,
    6.971822e-004f,6.959134e-004f,6.943815e-004f,6.926077e-004f,6.905692e-004f,6.882871e-004f,6.857385e-004f,6.829452e-004f,
    6.798845e-004f,6.765777e-004f,6.730030e-004f,6.691816e-004f,6.650916e-004f,6.607547e-004f,6.561489e-004f,6.512962e-004f,
    6.461749e-004f,6.408070e-004f,6.351713e-004f,6.292895e-004f,6.231408e-004f,6.167469e-004f,6.100875e-004f,6.031844e-004f,
    5.960170e-004f,5.886078e-004f,5.809365e-004f,5.730251e-004f,5.648542e-004f,5.564454e-004f,5.477797e-004f,5.388790e-004f,
    5.297244e-004f,5.203380e-004f,5.107010e-004f,5.008357e-004f,4.907234e-004f,4.803866e-004f,4.698073e-004f,4.590074e-004f,
    4.479692e-004f,4.367154e-004f,4.252278e-004f,4.135294e-004f,4.016026e-004f,3.894699e-004f,3.771145e-004f,3.645588e-004f,
    3.517861e-004f,3.388190e-004f,3.256410e-004f,3.122749e-004f,2.987044e-004f,2.849524e-004f,2.710028e-004f,2.568784e-004f,
    2.425639e-004f,2.280818e-004f,2.134169e-004f,1.985920e-004f,1.835919e-004f,1.684399e-004f,1.531208e-004f,1.376580e-004f,
    1.220365e-004f,1.062795e-004f,9.037273e-005f,7.433910e-005f,5.816475e-005f,4.187263e-005f,2.544878e-005f,8.916652e-006f,
    -7.737536e-006f,-2.449074e-005f,-4.135597e-005f,-5.831047e-005f,-7.536699e-005f,-9.250250e-005f,-1.097299e-004f,-1.270258e-004f,
    -1.444030e-004f,-1.618383e-004f,-1.793441e-004f,-1.968971e-004f,-2.145096e-004f,-2.321585e-004f,-2.498555e-004f,-2.675776e-004f,
    -2.853368e-004f,-3.031096e-004f,-3.209078e-004f,-3.387081e-004f,-3.565220e-004f,-3.743264e-004f,-3.921324e-004f,-4.099171e-004f,
    -4.276913e-004f,-4.454321e-004f,-4.631502e-004f,-4.808227e-004f,-4.984603e-004f,-5.160400e-004f,-5.335722e-004f,-5.510342e-004f,
    -5.684362e-004f,-5.857555e-004f,-6.030024e-004f,-6.201538e-004f,-6.372200e-004f,-6.541784e-004f,-6.710388e-004f,-6.877788e-004f,
    -7.044079e-004f,-7.209039e-004f,-7.372762e-004f,-7.535026e-004f,-7.695927e-004f,-7.855240e-004f,-8.013061e-004f,-8.169169e-004f,
    -8.323654e-004f,-8.476299e-004f,-8.627195e-004f,-8.776123e-004f,-8.923175e-004f,-9.068132e-004f,-9.211088e-004f,-9.351822e-004f,
    -9.490428e-004f,-9.626689e-004f,-9.760695e-004f,-9.892235e-004f,-1.002139e-003f,-1.014796e-003f,-1.027203e-003f,-1.039339e-003f,
    -1.051212e-003f,-1.062802e-003f,-1.074117e-003f,-1.085137e-003f,-1.095871e-003f,-1.106298e-003f,-1.116428e-003f,-1.126238e-003f,
    -1.135739e-003f,-1.144911e-003f,-1.153762e-003f,-1.162271e-003f,-1.170449e-003f,-1.178276e-003f,-1.185759e-003f,-1.192880e-003f,
    -1.199647e-003f,-1.206042e-003f,-1.212073e-003f,-1.217722e-003f,-1.222996e-003f,-1.227878e-003f,-1.232376e-003f,-1.236471e-003f,
    -1.240174e-003f,-1.243464e-003f,-1.246353e-003f,-1.248821e-003f,-1.250877e-003f,-1.252505e-003f,-1.253712e-003f,-1.254482e-003f,
    -1.254824e-003f,-1.254720e-003f,-1.254181e-003f,-1.253189e-003f,-1.251754e-003f,-1.249858e-003f,-1.247512e-003f,-1.244699e-003f,
    -1.241429e-003f,-1.237686e-003f,-1.233479e-003f,-1.228793e-003f,-1.223638e-003f,-1.217997e-003f,-1.211882e-003f,-1.205277e-003f,
    -1.198192e-003f,-1.190613e-003f,-1.182548e-003f,-1.173985e-003f,-1.164933e-003f,-1.155379e-003f,-1.145332e-003f,-1.134779e-003f,
    -1.123730e-003f,-1.112172e-003f,-1.100116e-003f,-1.087549e-003f,-1.074481e-003f,-1.060899e-003f,-1.046815e-003f,-1.032216e-003f,
    -1.017114e-003f,-1.001495e-003f,-9.853718e-004f,-9.687325e-004f,-9.515878e-004f,-9.339271e-004f,-9.157612e-004f,-8.970799e-004f,
    -8.778941e-004f,-8.581937e-004f,-8.379903e-004f,-8.172737e-004f,-7.960555e-004f,-7.743264e-004f,-7.520979e-004f,-7.293609e-004f,
    -7.061275e-004f,-6.823885e-004f,-6.581561e-004f,-6.334219e-004f,-6.081980e-004f,-5.824763e-004f,-5.562691e-004f,-5.295687e-004f,
    -5.023875e-004f,-4.747184e-004f,-4.465737e-004f,-4.179464e-004f,-3.888495e-004f,-3.592763e-004f,-3.292394e-004f,-2.987329e-004f,
    -2.677696e-004f,-2.363438e-004f,-2.044684e-004f,-1.721380e-004f,-1.393661e-004f,-1.061471e-004f,-7.249479e-005f,-3.840401e-005f,
    -3.888512e-006f,3.105625e-005f,6.641668e-005f,1.021967e-004f,1.383826e-004f,1.749784e-004f,2.119698e-004f,2.493605e-004f,
    2.871366e-004f,3.253007e-004f,3.638392e-004f,4.027546e-004f,4.420327e-004f,4.816760e-004f,5.216700e-004f,5.620170e-004f,
    6.027025e-004f,6.437284e-004f,6.850800e-004f,7.267588e-004f,7.687503e-004f,8.110557e-004f,8.536601e-004f,8.965646e-004f,
    9.397543e-004f,9.832300e-004f,1.026976e-003f,1.070994e-003f,1.115268e-003f,1.159799e-003f,1.204571e-003f,1.249584e-003f,
    1.294823e-003f,1.340288e-003f,1.385964e-003f,1.431849e-003f,1.477929e-003f,1.524202e-003f,1.570655e-003f,1.617284e-003f,
    1.664075e-003f,1.711027e-003f,1.758124e-003f,1.805365e-003f,1.852734e-003f,1.900229e-003f,1.947836e-003f,1.995552e-003f,
    2.043361e-003f,2.091262e-003f,2.139240e-003f,2.187291e-003f,2.235400e-003f,2.283566e-003f,2.331772e-003f,2.380016e-003f,
    2.428282e-003f,2.476568e-003f,2.524858e-003f,2.573150e-003f,2.621427e-003f,2.669687e-003f,2.717915e-003f,2.766108e-003f,
    2.814249e-003f,2.862337e-003f,2.910355e-003f,2.958300e-003f,3.006157e-003f,3.053923e-003f,3.101583e-003f,3.149132e-003f,
    3.196557e-003f,3.243852e-003f,3.291005e-003f,3.338010e-003f,3.384852e-003f,3.431529e-003f,3.478026e-003f,3.524338e-003f,
    3.570451e-003f,3.616361e-003f,3.662055e-003f,3.707527e-003f,3.752764e-003f,3.797761e-003f,3.842505e-003f,3.886991e-003f,
    3.931207e-003f,3.975146e-003f,4.018797e-003f,4.062155e-003f,4.105206e-003f,4.147946e-003f,4.190363e-003f,4.232451e-003f,
    4.274198e-003f,4.315600e-003f,4.356644e-003f,4.397325e-003f,4.437633e-003f,4.477561e-003f,4.517098e-003f,4.556240e-003f,
    4.594975e-003f,4.633298e-003f,4.671199e-003f,4.708672e-003f,4.745707e-003f,4.782299e-003f,4.818438e-003f,4.854119e-003f,
    4.889331e-003f,4.924071e-003f,4.958328e-003f,4.992098e-003f,5.025370e-003f,5.058142e-003f,5.090404e-003f,5.122150e-003f,
    5.153373e-003f,5.184068e-003f,5.214226e-003f,5.243843e-003f,5.272911e-003f,5.301425e-003f,5.329379e-003f,5.356767e-003f,
    5.383583e-003f,5.409822e-003f,5.435477e-003f,5.460545e-003f,5.485017e-003f,5.508893e-003f,5.532163e-003f,5.554825e-003f,
    5.576873e-003f,5.598304e-003f,5.619111e-003f,5.639291e-003f,5.658840e-003f,5.677753e-003f,5.696027e-003f,5.713657e-003f,
    5.730640e-003f,5.746973e-003f,5.762651e-003f,5.777671e-003f,5.792031e-003f,5.805727e-003f,5.818756e-003f,5.831116e-003f,
    5.842803e-003f,5.853816e-003f,5.864152e-003f,5.873810e-003f,5.882785e-003f,5.891078e-003f,5.898686e-003f,5.905607e-003f,
    5.911841e-003f,5.917385e-003f,5.922239e-003f,5.926401e-003f,5.929871e-003f,5.932648e-003f,5.934731e-003f,5.936120e-003f,
    5.936815e-003f
};

// Parks-McLellan
// 9600 taps
// 4.800618e-007f
FLOAT AdvancedFilter[] = {
    3.9847312634000005e-008f,3.9847312634000005e-008f,3.9165786115999997e-008f,4.0926324065999996e-008f,
    4.0219386691000004e-008f,4.1948547176999993e-008f,4.1235476529999994e-008f,4.2950181604999998e-008f,
    4.2265888448000001e-008f,4.3994715603999994e-008f,4.3392232740000001e-008f,4.5162992809999995e-008f,
    4.4701897421000001e-008f,4.6465457562999999e-008f,4.6140194149000001e-008f,4.7091162416999998e-008f,
    4.6195315819999999e-008f,4.8684313152000001e-008f,4.7511758210999995e-008f,4.9501371647999994e-008f,
    4.8561625490000002e-008f,5.0464695348000000e-008f,4.9592059630000005e-008f,5.1466663106000001e-008f,
    5.0629882584999996e-008f,5.2476408564000002e-008f,5.1629183702999998e-008f,5.3400688209999998e-008f,
    5.2476153010999999e-008f,5.4149202946999996e-008f,5.3230012138999997e-008f,5.5216470051999995e-008f,
    5.4105458940000002e-008f,5.5822486214000000e-008f,5.4930095138000001e-008f,5.6586834126000005e-008f,
    5.5683287605999993e-008f,5.7320371234999996e-008f,5.6393358283000003e-008f,5.7990464534000004e-008f,
    5.7019896461999996e-008f,5.8569603186999997e-008f,5.7566802103999994e-008f,5.9112664422999995e-008f,
    5.8126552062000004e-008f,5.9695103043000007e-008f,5.8591414080000003e-008f,6.0045166209000006e-008f,
    5.9096042367000002e-008f,6.0487161789000000e-008f,5.9469783073999997e-008f,6.0858080302000002e-008f,
    5.9790924306999996e-008f,6.1140455255999998e-008f,6.0033221884000006e-008f,6.1351575366999999e-008f,
    6.0223875533000002e-008f,6.1522551434999991e-008f,6.0368407421000001e-008f,6.1613672745999995e-008f,
    6.0394451605000005e-008f,6.1599017337000002e-008f,6.0438206723000001e-008f,6.1564951010999997e-008f,
    6.0304508060000001e-008f,6.1444496660000003e-008f,6.0119387688999997e-008f,6.1213965632000002e-008f,
    5.9850801485999994e-008f,6.0907990914000003e-008f,5.9508893793999999e-008f,6.0522461436000001e-008f,
    5.9073453703999997e-008f,6.0033121885000003e-008f,5.8544003443000001e-008f,5.9478316321999998e-008f,
    5.7970842507999996e-008f,5.8824178418999996e-008f,5.7232427669999997e-008f,5.8097407909000000e-008f,
    5.6444346662000000e-008f,5.7250560822000000e-008f,5.5564033243000003e-008f,5.6320314568999999e-008f,
    5.4586820792999994e-008f,5.5293147063000003e-008f,5.3509220457999996e-008f,5.4173436038000000e-008f,
    5.2349176502999998e-008f,5.2975536906000001e-008f,5.1092211294999999e-008f,5.1651061261999996e-008f,
    4.9707769584000001e-008f,5.0262352926999994e-008f,4.8252873022000005e-008f,4.8737145956999997e-008f,
    4.6699677442999999e-008f,4.7120106571999994e-008f,4.5029849697000001e-008f,4.5404379284999997e-008f,
    4.3265267342999996e-008f,4.3596964025999999e-008f,4.1407308145000004e-008f,4.1684994257000004e-008f,
    3.9431861232999994e-008f,3.9655803437999997e-008f,3.7359804176000002e-008f,3.7552668914000000e-008f,
    3.5188770330999999e-008f,3.5313069087999999e-008f,3.2922304107000001e-008f,3.2987192347000002e-008f,
    3.0536305744999998e-008f,3.0565105456999997e-008f,2.8065374899000000e-008f,2.8048530622999996e-008f,
    2.5493278398000001e-008f,2.5422734658999997e-008f,2.2814760738999999e-008f,2.2701317429000001e-008f,
    2.0052955024000000e-008f,1.9890489981999999e-008f,1.7181661514999998e-008f,1.6963719250000000e-008f,
    1.4230402139000001e-008f,1.3956260436000000e-008f,1.1167043884000000e-008f,1.0862343597700001e-008f,
    8.0229408809000004e-009f,7.6754799110999995e-009f,4.7896698806000000e-009f,4.3947671629999995e-009f,
    1.4693475286000000e-009f,1.0347122083299998e-009f,-1.9320262351000002e-009f,-2.4152658470999999e-009f,
    -5.4276268342999995e-009f,-5.9466116444000002e-009f,-8.9856001431000011e-009f,-9.5511022657999993e-009f,
    -1.2637140294000000e-008f,-1.3223901093000000e-008f,-1.6350292051000001e-008f,-1.6976674675999997e-008f,
    -2.0126032071000000e-008f,-2.0788547668000000e-008f,-2.3968326981000000e-008f,-2.4665586674999998e-008f,
    -2.7876621231000000e-008f,-2.8608013917000001e-008f,-3.1842026021000001e-008f,-3.2595229599999995e-008f,
    -3.5851274816999994e-008f,-3.6638422500999999e-008f,-3.9921456336999996e-008f,-4.0718348367999995e-008f,
    -4.4026226399999999e-008f,-4.4848107069999997e-008f,-4.8161751711000000e-008f,-4.9004921057000003e-008f,
    -5.2335721081999996e-008f,-5.3202179083999996e-008f,-5.6548590064000004e-008f,-5.7424381306000000e-008f,
    -6.0776625560999998e-008f,-6.1660450055999997e-008f,-6.5024494192999996e-008f,-6.5921740775999993e-008f,
    -6.9288273777000001e-008f,-7.0182498167999991e-008f,-7.3553831121000000e-008f,-7.4455666547000002e-008f,
    -7.7813666300000002e-008f,-7.8720712784999995e-008f,-8.2080279189000007e-008f,-8.2982447944999999e-008f,
    -8.6340358809999998e-008f,-8.7231049903000002e-008f,-9.0574760909999992e-008f,-9.1456040986000000e-008f,
    -9.4791807628000002e-008f,-9.5658810068999988e-008f,-9.8974776908999991e-008f,-9.9820657339000007e-008f,
    -1.0312236876600001e-007f,-1.0394962716000000e-007f,-1.0722143888600000e-007f,-1.0802978635800000e-007f,
    -1.1128255383000000e-007f,-1.1205754608000000e-007f,-1.1528506936000000e-007f,-1.1602939525000000e-007f,
    -1.1922547440000002e-007f,-1.1993346731999999e-007f,-1.2309332461000000e-007f,-1.2376265125000000e-007f,
    -1.2688084229000001e-007f,-1.2751072487999999e-007f,-1.3059013853000001e-007f,-1.3117435490999999e-007f,
    -1.3420354684000000e-007f,-1.3474298588999999e-007f,-1.3772851159000001e-007f,-1.3820761791000000e-007f,
    -1.4114592186000001e-007f,-1.4157169537999999e-007f,-1.4445266657000000e-007f,-1.4481888513000000e-007f,
    -1.4763330143000000e-007f,-1.4793407619999998e-007f,-1.5068971530999998e-007f,-1.5092771293000001e-007f,
    -1.5361724159000000e-007f,-1.5378235104999998e-007f,-1.5639943599000000e-007f,-1.5649521281000001e-007f,
    -1.5904074291000002e-007f,-1.5905507610000000e-007f,-1.6152727360000000e-007f,-1.6146660754000000e-007f,
    -1.6385180590999998e-007f,-1.6370791846000000e-007f,-1.6600522881999999e-007f,-1.6577378668999998e-007f,
    -1.6798654234000002e-007f,-1.6767154549000000e-007f,-1.6979330204999999e-007f,-1.6938163950000002e-007f,
    -1.7141050809999998e-007f,-1.7090673536000002e-007f,-1.7283960492000002e-007f,-1.7223527762999998e-007f,
    -1.7407203703999999e-007f,-1.7336971073000000e-007f,-1.7509591569000000e-007f,-1.7429136818000000e-007f,
    -1.7591190753000000e-007f,-1.7500113886000001e-007f,-1.7651579037999999e-007f,-1.7549646724000001e-007f,
    -1.7690200873999999e-007f,-1.7577313113999998e-007f,-1.7706422934000002e-007f,-1.7582413062999999e-007f,
    -1.7699867443999999e-007f,-1.7564346576999999e-007f,-1.7670245518000001e-007f,-1.7523091434000000e-007f,
    -1.7616390500999998e-007f,-1.7457558756000000e-007f,-1.7538991274999999e-007f,-1.7367759653999999e-007f,
    -1.7437058960999997e-007f,-1.7253505240999998e-007f,-1.7310382449999998e-007f,-1.7114884404999999e-007f,
    -1.7159339515999999e-007f,-1.6950963822000000e-007f,-1.6982385730000000e-007f,-1.6761632381999999e-007f,
    -1.6780398861000001e-007f,-1.6546845640999999e-007f,-1.6552323363999998e-007f,-1.6306236936000001e-007f,
    -1.6298903676000000e-007f,-1.6039484048000000e-007f,-1.6019217583999999e-007f,-1.5746998084000001e-007f,
    -1.5713720638999998e-007f,-1.5428912376000000e-007f,-1.5382479506999998e-007f,-1.5084549152999998e-007f,
    -1.5024605308000000e-007f,-1.4713752860999997e-007f,-1.4641075809999999e-007f,-1.4317190159999999e-007f,
    -1.4231302129999999e-007f,-1.3894627719000000e-007f,-1.3795817596000001e-007f,-1.3445798873999999e-007f,
    -1.3334344433000001e-007f,-1.2971870279999999e-007f,-1.2847504857000000e-007f,-1.2472586383999999e-007f,
    -1.2335387755999999e-007f,-1.1947758299000001e-007f,-1.1798093129000000e-007f,-1.1397963796999999e-007f,
    -1.1235898751000001e-007f,-1.0823661762299999e-007f,-1.0649502392800000e-007f,-1.0225178858300000e-007f,
    -1.0038886276800000e-007f,-9.6025384181000000e-008f,-9.4048159508999995e-008f,-8.9571893160999998e-008f,
    -8.7476991888000004e-008f,-8.2888026667000008e-008f,-8.0680893183000001e-008f,-7.5980117968999998e-008f,
    -7.3665874444999994e-008f,-6.8856433650999997e-008f,-6.6435057864999992e-008f,-6.1519629242000002e-008f,
    -5.8999021114999997e-008f,-5.3983271273000001e-008f,-5.1360919718999996e-008f,-4.6246381975999995e-008f,
    -4.3532520226000000e-008f,-3.8325938958999998e-008f,-3.5517200380000001e-008f,-3.0222408884000001e-008f,
    -2.7328060049999998e-008f,-2.1946858307000000e-008f,-1.8971765836000000e-008f,-1.3508209360999999e-008f,
    -1.0453567685500000e-008f,-4.9145941869000004e-009f,-1.7870487960000000e-009f,3.8209962341000000e-009f,
    7.0173976030999994e-009f,1.2692473074000000e-008f,1.5951118264999998e-008f,2.1686116470000001e-008f,
    2.5003805514999997e-008f,3.0792436517000001e-008f,3.4159958396999997e-008f,4.0000433325000000e-008f,
    4.3413754746999999e-008f,4.9298429233000000e-008f,5.2753928011000001e-008f,5.8674257695999997e-008f,
    6.2164500570999998e-008f,6.8116085499000003e-008f,7.1634794756000000e-008f,7.7609668339999996e-008f,
    8.1152055137999996e-008f,8.7146161863000001e-008f,9.0703726286999990e-008f,9.6705866264999998e-008f,
    1.0027288615000000e-007f,1.0628307049199999e-007f,1.0985242368700000e-007f,1.1585973028000000e-007f,
    1.1942625017000000e-007f,1.2542241243000002e-007f,1.2897904353000001e-007f,1.3495942817000002e-007f,
    1.3849761501000000e-007f,1.4445366655999999e-007f,1.4796563143999997e-007f,1.5389268328000000e-007f,
    1.5737142627000001e-007f,1.6325758963000001e-007f,1.6669666635000000e-007f,1.7254071901999998e-007f,
    1.7593246288000000e-007f,1.8172107166000001e-007f,1.8505992715999999e-007f,1.9078686988999999e-007f,
    1.9406428156000000e-007f,1.9972433606999999e-007f,2.0293030400999999e-007f,2.0851402594999999e-007f,
    2.1164232799999998e-007f,2.1714227299999998e-007f,2.2018546478999999e-007f,2.2559452181000002e-007f,
    2.2854571451999999e-007f,2.3385732806999999e-007f,2.3670741067999999e-007f,2.4191291417999996e-007f,
    2.4465677562999999e-007f,2.4974828026999999e-007f,2.5237669843000001e-007f,2.5734875982000001e-007f,
    2.5985195701000001e-007f,2.6469601968000000e-007f,2.6706844040000001e-007f,2.7177672665000001e-007f,
    2.7401070430999999e-007f,2.7857721419999999e-007f,2.8066797107000000e-007f,2.8508381579999999e-007f,
    2.8702112975999995e-007f,2.9128119826999996e-007f,2.9306162491000002e-007f,2.9715680617999996e-007f,
    2.9876901228000001e-007f,3.0269519523999997e-007f,3.0413284753000002e-007f,3.0788169892999998e-007f,
    3.0914013079000002e-007f,3.1270376181999997e-007f,3.1377630664999994e-007f,3.1715060623999999e-007f,
    3.1803126410000000e-007f,3.2120989898000002e-007f,3.2189066995000004e-007f,3.2486875128000002e-007f,
    3.2534596873000002e-007f,3.2811482992999997e-007f,3.2837971617000000e-007f,3.3093613505000002e-007f,
    3.3098469011999999e-007f,3.3332255563000000e-007f,3.3315044623999997e-007f,3.3526264734000000e-007f,
    3.3486498465000000e-007f,3.3674907692000000e-007f,3.3612119431000004e-007f,3.3777228891000003e-007f,
    3.3691018642000002e-007f,3.3832417228000000e-007f,3.3722173885999997e-007f,3.3839239382000000e-007f,
    3.3704607394999998e-007f,3.3797250912999997e-007f,3.3637874728999995e-007f,3.3705574051999997e-007f,
    3.3521287005999998e-007f,3.3563608804999999e-007f,3.3354022012000002e-007f,3.3370999620000002e-007f,
    3.3135801972000001e-007f,3.3127179836000000e-007f,3.2866215779000002e-007f,3.2831660569000001e-007f,
    3.2544552329000000e-007f,3.2483641827000003e-007f,3.2170500513999996e-007f,3.2083379163000001e-007f,
    3.1743904780000001e-007f,3.1630305916000000e-007f,3.1264620684000002e-007f,3.1124477641000004e-007f,
    3.0732414894999995e-007f,3.0565861005000002e-007f,3.0147409633999997e-007f,2.9954467119000002e-007f,
    2.9509727122000002e-007f,2.9290240428000000e-007f,2.8819111805999997e-007f,2.8573214265000000e-007f,
    2.8075963681999998e-007f,2.7803844181000001e-007f,2.7280527191999998e-007f,2.6982341285000000e-007f,
    2.6433391218999996e-007f,2.6109327792999998e-007f,2.5534766872000001e-007f,2.5185237033999997e-007f,
    2.4585309700000001e-007f,2.4210557892000001e-007f,2.3585775250999999e-007f,2.3185912583000000e-007f,
    2.2536541299000000e-007f,2.2112034433000000e-007f,2.1438530057000002e-007f,2.0989734544999999e-007f,
    2.0292485962000000e-007f,1.9820157351999999e-007f,1.9099797888999999e-007f,1.8604269510999999e-007f,
    1.7861154720000000e-007f,1.7343037678999999e-007f,1.6577756442999998e-007f,1.6037639621999999e-007f,
    1.5250980822000000e-007f,1.4689386438000000e-007f,1.3881872290999999e-007f,1.3299555891999999e-007f,
    1.2471786391999999e-007f,1.1869470192999999e-007f,1.1022308664700000e-007f,1.0400971544800000e-007f,
    9.5352968682999998e-008f,8.8954665999999998e-008f,8.0119387686999987e-008f,7.3546064532000003e-008f,
    6.4540321256999994e-008f,5.7800321990999995e-008f,4.8635846969999999e-008f,4.1737282623000001e-008f,
    3.2421531337000002e-008f,2.5374701805999999e-008f,1.5915996394000000e-008f,8.7314649067000007e-009f,
    -8.5771831161999997e-010f,-8.1685672023999996e-009f,-1.7879043430000003e-008f,-2.5307180258999998e-008f,
    -3.5128126492999998e-008f,-4.2661928931999999e-008f,-5.2583018609000001e-008f,-6.0211897874999997e-008f,
    -7.0219942237999997e-008f,-7.7931598453999995e-008f,-8.8016742045999994e-008f,-9.5799541995000008e-008f,
    -1.0595056270600000e-007f,-1.1379163985000000e-007f,-1.2399376005000001e-007f,-1.3188101451000001e-007f,
    -1.4212302319999998e-007f,-1.5004449953999999e-007f,-1.6031217463999997e-007f,-1.6825487299000002e-007f,
    -1.7853754794000001e-007f,-1.8648835732000001e-007f,-1.9677092115999998e-007f,-2.0471639725999999e-007f,
    -2.1498585012000001e-007f,-2.2291199307999999e-007f,-2.3315689063000000e-007f,-2.4104992281000002e-007f,
    -2.5125382076999998e-007f,-2.5910074229999999e-007f,-2.6925030747000001e-007f,-2.7703622960999997e-007f,
    -2.8711735101999995e-007f,-2.9482916279000003e-007f,-3.0482917389999996e-007f,-3.1245265321999998e-007f,
    -3.2235555418999997e-007f,-3.2987636786999997e-007f,-3.3966849216999999e-007f,-3.4707130702999997e-007f,
    -3.5673932146000001e-007f,-3.6401202651000000e-007f,-3.7353959790000000e-007f,-3.8066708217999999e-007f,
    -3.9003954401000002e-007f,-3.9700669655999996e-007f,-4.0621082673999997e-007f,-4.1300498102000000e-007f,
    -4.2202722412999999e-007f,-4.2863226918999999e-007f,-4.3745784760000000e-007f,-4.4386078357000001e-007f,
    -4.5247514186999997e-007f,-4.5866119111999999e-007f,-4.6705099610999999e-007f,-4.7300749210000000e-007f,
    -4.8115852170000003e-007f,-4.8687090902000002e-007f,-4.9476749671999997e-007f,-5.0022144217999996e-007f,
    -5.0785314363999999e-007f,-5.1303653624999995e-007f,-5.2038868495000003e-007f,-5.2528741374000001e-007f,
    -5.3234667647999990e-007f,-5.3694929712000000e-007f,-5.4370256291999992e-007f,-5.4799485333000007e-007f,
    -5.5443056674999999e-007f,-5.5840097149000004e-007f,-5.6450535488999996e-007f,-5.6814220740999996e-007f,
    -5.7390326090999999e-007f,-5.7719245023999989e-007f,-5.8260050726999999e-007f,-5.8553270016999991e-007f,
    -5.9057520529999997e-007f,-5.9313840189000002e-007f,-5.9780535522000004e-007f,-5.9998955560000001e-007f,
    -6.0426951279999999e-007f,-6.0606416152000001e-007f,-6.0994745602000000e-007f,-6.1134244206999995e-007f,
    -6.1481885174999993e-007f,-6.1580506411000009e-007f,-6.1886658905000009e-007f,-6.1943413892999994e-007f,
    -6.2207133477999996e-007f,-6.2221255559000002e-007f,-6.2441808908999998e-007f,-6.2412653644999991e-007f,
    -6.2589207435000000e-007f,-6.2515941501000009e-007f,-6.2647762405000003e-007f,-6.2529674697000002e-007f,
    -6.2616240497999989e-007f,-6.2452631022999999e-007f,-6.2493230616999996e-007f,-6.2283666046000008e-007f,
    -6.2277843882000002e-007f,-6.2021724220999999e-007f,-6.1969035858999999e-007f,-6.1665872223999994e-007f,
    -6.1565928779000000e-007f,-6.1215654503999992e-007f,-6.1068111534999998e-007f,-6.0670082181999996e-007f,
    -6.0474606358999998e-007f,-6.0028744150999999e-007f,-5.9785179919999992e-007f,-5.9291207082000002e-007f,
    -5.8999376666999989e-007f,-5.8457248754999990e-007f,-5.8117118822999997e-007f,-5.7526769170999999e-007f,
    -5.7138384166000001e-007f,-5.6499934995000003e-007f,-5.6063272695000007e-007f,-5.5376924003000001e-007f,
    -5.4892239960999998e-007f,-5.4157958414999999e-007f,-5.3625397073999991e-007f,-5.2843482670999997e-007f,
    -5.2263466249000002e-007f,-5.1434196763999996e-007f,-5.0806980813999995e-007f,-4.9930878464000001e-007f,
    -4.9256896315000003e-007f,-4.8334427762000005e-007f,-4.7614357184999996e-007f,-4.6646100200999996e-007f,
    -4.5880441191000002e-007f,-4.4867029103000000e-007f,-4.4056414987000002e-007f,-4.2998570009999999e-007f,
    -4.2143823001999996e-007f,-4.1042222907000000e-007f,-4.0144054110999996e-007f,-3.8999709998999997e-007f,
    -3.8059074961000000e-007f,-3.6872864601000002e-007f,-3.5890718866999998e-007f,-3.4663708914999997e-007f,
    -3.3641230250999999e-007f,-3.2374542918000002e-007f,-3.1312709092000000e-007f,-3.0007455477999999e-007f,
    -2.8907488699999997e-007f,-2.7564857682000003e-007f,-2.6428180160000003e-007f,-2.5049438392000000e-007f,
    -2.3877116782000001e-007f,-2.2463764249000001e-007f,-2.1257409645999999e-007f,-1.9810912999999999e-007f,
    -1.8571858723999999e-007f,-1.7093751282999998e-007f,-1.5823741760999998e-007f,-1.4315579065000000e-007f,
    -1.3016092059999999e-007f,-1.1479518536999999e-007f,-1.0152244032099999e-007f,-8.5889518873999997e-008f,
    -7.2356420873000004e-008f,-5.6474435250000004e-008f,-4.2698350789999997e-008f,-2.6585945248999999e-008f,
    -1.2586351912999999e-008f,3.7371848500000000e-009f,1.7940909477999998e-008f,3.4456844317000001e-008f,
    4.8844478216999998e-008f,6.5532111339000002e-008f,8.0083788043000001e-008f,9.6922597431000004e-008f,
    1.1161788381000000e-007f,1.2858793632999998e-007f,1.4340501037999999e-007f,1.6048395070000002e-007f,
    1.7540113486000000e-007f,1.9256574098999997e-007f,2.0756136881000000e-007f,2.2479052985000000e-007f,
    2.3984060156999999e-007f,2.5711076220000001e-007f,2.7219316692999998e-007f,2.8948177181999998e-007f,
    3.0457217646999999e-007f,3.2185511474999999e-007f,3.3693163064999998e-007f,3.5418612476999995e-007f,
    3.6922386328000003e-007f,3.8642491349000001e-007f,4.0139920818999999e-007f,4.1852192584999996e-007f,
    4.3340866587000002e-007f,4.5043038453999998e-007f,4.6520401458000000e-007f,4.8209873451999995e-007f,
    4.9673492148999997e-007f,5.1347864294000007e-007f,5.2795249819999996e-007f,5.4451922142000000e-007f,
    5.5880674521000007e-007f,5.7517313710000005e-007f,5.8924844079000007e-007f,6.0538816828000000e-007f,
    6.1922602989999994e-007f,6.3511387101999992e-007f,6.4868973525999990e-007f,6.6430157913999998e-007f,
    6.7759011291999997e-007f,6.9290095980999998e-007f,7.0587749671000005e-007f,7.2086212464000008e-007f,
    7.3350233157000006e-007f,7.4813674077999998e-007f,7.6041617353999998e-007f,7.7467614204999996e-007f,
    7.8657024532999998e-007f,8.0043177338000000e-007f,8.1191621409000007e-007f,8.2535485748000002e-007f,
    8.3640596918999997e-007f,8.4939883926000004e-007f,8.5999306664999992e-007f,8.7251738584999997e-007f,
    8.8263295136000003e-007f,8.9466438659999999e-007f,9.0427806824000004e-007f,9.1579561973000007e-007f,
    9.2488586215999996e-007f,9.3586719679000002e-007f,9.4441211133999998e-007f,9.5483678487000001e-007f,
    9.6281548285999992e-007f,9.7266105106999994e-007f,9.8005253270999987e-007f,9.8929999578999998e-007f,
    9.9608503905000006e-007f,1.0047151749700000e-006f,1.0108751133699998e-006f,1.0188679223300000e-006f,
    1.0243832005099999e-006f,1.0317216826800001e-006f,1.0365750785899999e-006f,1.0432417897000000e-006f,
    1.0474164146199999e-006f,1.0533949103899999e-006f,1.0568745422600001e-006f,1.0621477117499999e-006f,
    1.0649164618400001e-006f,1.0694701940800001e-006f,1.0715145069700000e-006f,1.0753350243200000e-006f,
    1.0766413445900000e-006f,1.0797143138599999e-006f,1.0802697527500001e-006f,1.0825837296100001e-006f,
    1.0823761761300001e-006f,1.0839204940200001e-006f,1.0829402816000000e-006f,1.0837042739599999e-006f,
    1.0819407360399998e-006f,1.0819142918600000e-006f,1.0793590951900000e-006f,1.0785346589899999e-006f,
    1.0751802480900000e-006f,1.0735511532700001e-006f,1.0693914170900000e-006f,1.0669511081600001e-006f,
    1.0619802689799999e-006f,1.0587247459800000e-006f,1.0529379149600000e-006f,1.0488634001500000e-006f,
    1.0422592439699999e-006f,1.0373626262700000e-006f,1.0299381449600000e-006f,1.0242178688299998e-006f,
    1.0159726179499999e-006f,1.0094286833900000e-006f,1.0003627740500000e-006f,9.9299706992999995e-007f,
    9.8311294655000000e-007f,9.7492736173999998e-007f,9.6422791317999995e-007f,9.5522600319999990e-007f,
    9.4371500720000002e-007f,9.3390210532999999e-007f,9.2158556182999999e-007f,9.1096744579000000e-007f,
    8.9785179916999991e-007f,8.8643569110999991e-007f,8.7252849684999993e-007f,8.6032295223999999e-007f,
    8.4563332135999997e-007f,8.3264922898000001e-007f,8.1718882803000001e-007f,8.0343718776999997e-007f,
    7.8721712775000007e-007f,7.7271027282000002e-007f,7.5574322027000001e-007f,7.4049515052999998e-007f,
    7.2279677195999996e-007f,7.0682137615999996e-007f,6.8840700475000007e-007f,6.7172150493999993e-007f,
    6.5260669608999995e-007f,6.3522820321000001e-007f,6.1543162339999999e-007f,5.9737980391999996e-007f,
    5.7692189738999997e-007f,5.5821652889000000e-007f,5.3711707322000008e-007f,5.1777893326999997e-007f,
    4.9605959490999997e-007f,4.7611146106000000e-007f,4.5379546200000000e-007f,4.3326077846000000e-007f,
    4.1037167401999996e-007f,3.8927532943000003e-007f,3.6583834157999995e-007f,3.4420555791000001e-007f,
    3.2024757526999997e-007f,2.9810635224000002e-007f,2.7365504120000003e-007f,2.5103293409000000e-007f,
    2.2611718325000002e-007f,2.0304296954999998e-007f,1.7769144528999999e-007f,1.5419534692000001e-007f,
    1.2843916003999999e-007f,1.0455169891700000e-007f,7.8422360212999995e-008f,5.4175991568000001e-008f,
    2.7704978502999999e-008f,3.1331364460999996e-009f,-2.3645096879999997e-008f,-4.8509181569999998e-008f,
    -7.5560299944999993e-008f,-1.0068185983800001e-007f,-1.2797060917000000e-007f,-1.5331402240000000e-007f,
    -1.8080574747999999e-007f,-2.0633560328999999e-007f,-2.3399343781999999e-007f,-2.5967229213999999e-007f,
    -2.8745890316000002e-007f,-3.1324964525000004e-007f,-3.4112725535999999e-007f,-3.6699166337999997e-007f,
    -3.9492082852999998e-007f,-4.2082056952999998e-007f,-4.4876317898999998e-007f,-4.7465836448000000e-007f,
    -5.0257441864999997e-007f,-5.2842604901999997e-007f,-5.5627654828999997e-007f,-5.8204495727000003e-007f,
    -6.0978979092999992e-007f,-6.3543420114999996e-007f,-6.6303192517000007e-007f,-6.8851189258999995e-007f,
    -7.1592272959000003e-007f,-7.4119681018000008e-007f,-7.6837898279999998e-007f,-7.9340673251999994e-007f,
    -8.2031901895000003e-007f,-8.4505899377000004e-007f,-8.7166050552999999e-007f,-8.9607170585999990e-007f,
    -9.2232199891000001e-007f,-9.4636331404999989e-007f,-9.7222083324999993e-007f,-9.9585148582999991e-007f,
    -1.0212744538199999e-006f,-1.0444529998100000e-006f,-1.0694010836599999e-006f,-1.0920870790199998e-006f,
    -1.1165188346999998e-006f,-1.1386719464999998e-006f,-1.1625472632999999e-006f,-1.1841259364000000e-006f,
    -1.2074068146999999e-006f,-1.2283732717000000e-006f,-1.2510174896999999e-006f,-1.2713306199000000e-006f,
    -1.2933015112999998e-006f,-1.3129235372999999e-006f,-1.3341811024999999e-006f,-1.3530731358000000e-006f,
    -1.3735795973999999e-006f,-1.3917049717000002e-006f,-1.4114225522999998e-006f,-1.4287434901999999e-006f,
    -1.4476355235000001e-006f,-1.4641164698000000e-006f,-1.4821485117000000e-006f,-1.4977550223000000e-006f,
    -1.5148915175999999e-006f,-1.5295880373000001e-006f,-1.5457956530000001e-006f,-1.5595488488000000e-006f,
    -1.5747942519000000e-006f,-1.5875707907999999e-006f,-1.6018228705000000e-006f,-1.6135927528000000e-006f,
    -1.6268192871999999e-006f,-1.6375514021000000e-006f,-1.6497246137000000e-006f,-1.6593900726000002e-006f,
    -1.6704810727999998e-006f,-1.6790532092999999e-006f,-1.6890342206000001e-006f,-1.6964852572000001e-006f,
    -1.7053307243000001e-006f,-1.7116373279000001e-006f,-1.7193228066000000e-006f,-1.7244594219000001e-006f,
    -1.7309626902000001e-006f,-1.7349070952000001e-006f,-1.7402070421999999e-006f,-1.7429392371000001e-006f,
    -1.7470147518999998e-006f,-1.7485169590999999e-006f,-1.7513502640999999e-006f,-1.7516024837999999e-006f,
    -1.7531769124999998e-006f,-1.7521658115000001e-006f,-1.7524669195999999e-006f,-1.7501758314000002e-006f,
    -1.7491902857000000e-006f,-1.7456080992999999e-006f,-1.7433236776999998e-006f,-1.7384403932000000e-006f,
    -1.7348470957999999e-006f,-1.7286527133000000e-006f,-1.7237438735000001e-006f,-1.7162328374999999e-006f,
    -1.7100006776000000e-006f,-1.7011663215000000e-006f,-1.6936097304000000e-006f,-1.6834498320000000e-006f,
    -1.6745632541999999e-006f,-1.6630767023999999e-006f,-1.6528612490000000e-006f,-1.6400480438000000e-006f,
    -1.6285059370000000e-006f,-1.6143694116999999e-006f,-1.6015028737000001e-006f,-1.5860474726999999e-006f,
    -1.5718631700999998e-006f,-1.5550955599999999e-006f,-1.5396012704999999e-006f,-1.5215303401000000e-006f,
    -1.5047349525000001e-006f,-1.4853718127999998e-006f,-1.4672875491999999e-006f,-1.4466444223000001e-006f,
    -1.4272846158999999e-006f,-1.4053759461000000e-006f,-1.3847572634000000e-006f,-1.3616008282999999e-006f,
    -1.3397399357999999e-006f,-1.3153535130000000e-006f,-1.2922715216000001e-006f,-1.2666762220000000e-006f,
    -1.2423953537000000e-006f,-1.2156145104000001e-006f,-1.1901569871999999e-006f,-1.1622161554999999e-006f,
    -1.1356086438000001e-006f,-1.1065342678799999e-006f,-1.0788043229600000e-006f,-1.0486248469799999e-006f,
    -1.0198024685400000e-006f,-9.8854978107000007e-007f,-9.5866674656999991e-007f,-9.2637284728999995e-007f,
    -8.9546260083999993e-007f,-8.6216226717999990e-007f,-8.3026114175000001e-007f,-7.9599137334000000e-007f,
    -7.6313692410999988e-007f,-7.2793549835000002e-007f,-6.9416628049000002e-007f,-6.5807341919999997e-007f,
    -6.2343132117999995e-007f,-5.8648857950000004e-007f,-5.5101526756999992e-007f,-5.1326742282999997e-007f,
    -4.7700845209000001e-007f,-4.3849994829000003e-007f,-4.0150076272999999e-007f,-3.6227859939999997e-007f,
    -3.2458764297999996e-007f,-2.8470059741000000e-007f,-2.4636709186000000e-007f,-2.0586549688000000e-007f,
    -1.6693944170000001e-007f,-1.2587396347000000e-007f,-8.6407635914999997e-008f,-4.4831462792000000e-008f,
    -4.8786123245000002e-009f,3.7153995122999995e-008f,7.7538102389000002e-008f,1.1997180026999998e-007f,
    1.6073139267000000e-007f,2.0351007598999999e-007f,2.4458777632000002e-007f,2.8765290121999997e-007f,
    3.2898993228999999e-007f,3.7228294379999999e-007f,4.1382075063999999e-007f,4.5728264935000000e-007f,
    4.9896134366999995e-007f,5.4253101908000000e-007f,5.8428860149999996e-007f,6.2790394311999997e-007f,
    6.6967941424999996e-007f,7.1327875602999993e-007f,7.5500844983999995e-007f,7.9852912574000000e-007f,
    8.4015093174000007e-007f,8.8352905350999994e-007f,9.2497852790000000e-007f,9.6815020728999995e-007f,
    1.0093642395900000e-006f,1.0522659216800000e-006f,1.0931798458700001e-006f,1.1357475313000002e-006f,
    1.1762960146999999e-006f,1.2184633707999999e-006f,1.2585818585000001e-006f,1.3002847748000001e-006f,
    1.3399088230000000e-006f,1.3810828557000001e-006f,1.4201469095000001e-006f,1.4607276148000000e-006f,
    1.4991672304000000e-006f,1.5390890533999999e-006f,1.5768408980999999e-006f,1.6160405060999999e-006f,
    1.6530401361000001e-006f,1.6914530853000000e-006f,1.7276371679000001e-006f,1.7652001256000000e-006f,
    1.8005042169999999e-006f,1.8371538505000000e-006f,1.8715168402000000e-006f,1.9071920390000000e-006f,
    1.9405517054000000e-006f,1.9751913589999998e-006f,2.0074865916000000e-006f,2.0410295894999998e-006f,
    2.0722014999999998e-006f,2.1045878428000000e-006f,2.1345775429000000e-006f,2.1657505645000001e-006f,
    2.1944991659000002e-006f,2.2244010891000001e-006f,2.2518519256999999e-006f,2.2804260844000003e-006f,
    2.3065247122999997e-006f,2.3337166626000003e-006f,2.3584108601000000e-006f,2.3841672691999999e-006f,
    2.4074025924000000e-006f,2.4316734607999996e-006f,2.4533999102000001e-006f,2.4761352383999999e-006f,
    2.4963039255999999e-006f,2.5174548251999997e-006f,2.5360201950999999e-006f,2.5555388887999997e-006f,
    2.5724531641000002e-006f,2.5902985411999998e-006f,2.6055195000999997e-006f,2.6216471166000003e-006f,
    2.6351336483999999e-006f,2.6495046157999999e-006f,2.6612178319999999e-006f,2.6737943729000001e-006f,
    2.6836964960999997e-006f,2.6944419441999998e-006f,2.7024996414000001e-006f,2.7113806636999997e-006f,
    2.7175617130000000e-006f,2.7245471987000001e-006f,2.7288216003999999e-006f,2.7338826609000000e-006f,
    2.7362226374999997e-006f,2.7393337175000002e-006f,2.7397159358999997e-006f,2.7408548134000001e-006f,
    2.7392559404999998e-006f,2.7384015045999999e-006f,2.7348015406000002e-006f,2.7319360136999996e-006f,
    2.7263205143000002e-006f,2.7214272298999999e-006f,2.7137817508000000e-006f,2.7068484868000002e-006f,
    2.6971619170000000e-006f,2.6881808956999997e-006f,2.6764443463999999e-006f,2.6654100122999998e-006f,
    2.6516190391000002e-006f,2.6385258366999998e-006f,2.6226793284999996e-006f,2.6075272577999999e-006f,
    2.5896252146000000e-006f,2.5724176089000001e-006f,2.5524644751000000e-006f,2.5332046676999997e-006f,
    2.5112082209999998e-006f,2.4899073228999998e-006f,2.4658753409999998e-006f,2.4425444632000001e-006f,
    2.4164925014999996e-006f,2.3911460882999998e-006f,2.3630908132999999e-006f,2.3357477533999997e-006f,
    2.3057069426999997e-006f,2.2763872358999999e-006f,2.2443853337000000e-006f,2.2131145352999999e-006f,
    2.1791759858000000e-006f,2.1459807621999999e-006f,2.1101344539999998e-006f,2.0750459160000002e-006f,
    2.0373251820999999e-006f,2.0003755515999999e-006f,1.9608148360999998e-006f,1.9220430016000000e-006f,
    1.8806800818999999e-006f,1.8401249319000001e-006f,1.7970020297999999e-006f,1.7547046749999998e-006f,
    1.7098662345000000e-006f,1.6658744522000000e-006f,1.6193671395000000e-006f,1.5737298180999999e-006f,
    1.5256036326999998e-006f,1.4783707717000000e-006f,1.4286801575000000e-006f,1.3799073119000001e-006f,
    1.3287067127999998e-006f,1.2784516598000000e-006f,1.2258010751999999e-006f,1.1741227030999999e-006f,
    1.1200843545999999e-006f,1.0670461072100000e-006f,1.0116818830800000e-006f,9.5735020417999993e-007f,
    9.0072799262999993e-007f,8.4516988155000007e-007f,7.8735879299999989e-007f,7.3064502680999993e-007f,
    6.7171694942999991e-007f,6.1392063850999999e-007f,5.5395001600000007e-007f,4.9514604848999998e-007f,
    4.3420910231000002e-007f,3.7447503298999997e-007f,3.1265054012999995e-007f,2.5206592375999998e-007f,
    1.8943443896999998e-007f,1.2808094140000000e-007f,6.4725119408999997e-008f,2.6865075790999998e-009f,
    -6.1309109124999995e-008f,-1.2394787162000001e-007f,-1.8849700390000002e-007f,-2.5164803904999997e-007f,
    -3.1666227778999997e-007f,-3.8023708648000001e-007f,-4.4562721034999999e-007f,-5.0953557125999996e-007f,
    -5.7521024784000006e-007f,-6.3936005078000003e-007f,-7.0522772542999990e-007f,-7.6952641576999996e-007f,
    -8.3549286721000006e-007f,-8.9984633478000002e-007f,-9.6581689728999986e-007f,-1.0301303652600000e-006f,
    -1.0960101509000000e-006f,-1.1601872869000000e-006f,-1.2258788521999999e-006f,-1.2898226572000000e-006f,
    -1.3552297809000000e-006f,-1.4188435892000001e-006f,-1.4838684945000001e-006f,-1.5470545293000001e-006f,
    -1.6115994393999998e-006f,-1.6742599239000000e-006f,-1.7382259508999999e-006f,-1.8002619971999998e-006f,
    -1.8635513642999998e-006f,-1.9248640844999999e-006f,-1.9873801259999999e-006f,-2.0478717433000000e-006f,
    -2.1095144602000000e-006f,-2.1690871977999999e-006f,-2.2297588132999998e-006f,-2.2883160054999998e-006f,
    -2.3479198538999999e-006f,-2.4053637238999997e-006f,-2.4638031394999998e-006f,-2.5200370216000000e-006f,
    -2.5772164498000001e-006f,-2.6321447894000002e-006f,-2.6879686755999999e-006f,-2.7414981403000000e-006f,
    -2.7958731521000001e-006f,-2.8479104094999996e-006f,-2.9007432145000000e-006f,-2.9511949321999998e-006f,
    -3.0023944202000001e-006f,-3.0511705990999997e-006f,-3.1006489931999999e-006f,-3.1476607452999998e-006f,
    -3.1953280463999999e-006f,-3.2404887059000002e-006f,-3.2862593592999999e-006f,-3.3294833714999997e-006f,
    -3.3732729335999999e-006f,-3.4144769659999998e-006f,-3.4562032153999998e-006f,-3.4953061576999999e-006f,
    -3.5348890952000003e-006f,-3.5718120592999997e-006f,-3.6091739078999996e-006f,-3.6438402279000001e-006f,
    -3.6789076549999995e-006f,-3.7112451093999996e-006f,-3.7439436713000000e-006f,-3.7738811497000000e-006f,
    -3.8041419581999998e-006f,-3.8316105724000000e-006f,-3.8593669614999999e-006f,-3.8843022677000000e-006f,
    -3.9094909047000004e-006f,-3.9318295702000003e-006f,-3.9543915667999996e-006f,-3.9740758143999998e-006f,
    -3.9939522823000001e-006f,-4.0109265569999997e-006f,-4.0280641633999996e-006f,-4.0422762434999999e-006f,
    -4.0566260999999996e-006f,-4.0680282081999994e-006f,-4.0795425375000003e-006f,-4.0880902298000005e-006f,
    -4.0967256990000003e-006f,-4.1023789757999993e-006f,-4.1080978075000000e-006f,-4.1108177802999998e-006f,
    -4.1135844192999998e-006f,-4.1133388662000000e-006f,-4.1131222016999999e-006f,-4.1098833452000000e-006f,
    -4.1066567108000005e-006f,-4.1003989956000005e-006f,-4.0941401692999994e-006f,-4.0848435956000001e-006f,
    -4.0755336887000003e-006f,-4.0631815899999998e-006f,-4.0508061581999997e-006f,-4.0353863124000001e-006f,
    -4.0199364668999998e-006f,-4.0014410962999999e-006f,-3.9829112815999994e-006f,-3.9613381639999996e-006f,
    -3.9397272690000003e-006f,-3.9150775155000000e-006f,-3.8903899846000002e-006f,-3.8626702617999996e-006f,
    -3.8349138726999997e-006f,-3.8041341804999998e-006f,-3.7733222663999999e-006f,-3.7394981601999998e-006f,
    -3.7056484987000000e-006f,-3.6687988671999999e-006f,-3.6319325691999999e-006f,-3.5920840787999997e-006f,
    -3.5522289217999996e-006f,-3.5094093499999996e-006f,-3.4665964448000000e-006f,-3.4208402356999998e-006f,
    -3.3751062485999999e-006f,-3.3264511796000003e-006f,-3.2778361101999998e-006f,-3.2263277364000000e-006f,
    -3.1748771397999998e-006f,-3.1205599051999997e-006f,-3.0663248920000003e-006f,-3.0092521294000003e-006f,
    -2.9522871435000003e-006f,-2.8925166301000001e-006f,-2.8328794486999999e-006f,-2.7704722949999995e-006f,
    -2.7082284730000000e-006f,-2.6432502339000000e-006f,-2.5784675483999999e-006f,-2.5109882232000001e-006f,
    -2.4437377845999999e-006f,-2.3738340391999997e-006f,-2.3041936244999998e-006f,-2.2319421248000003e-006f,
    -2.1599917331999998e-006f,-2.0854758117000001e-006f,-2.0113021090000000e-006f,-1.9346095426000002e-006f,
    -1.8583014167999999e-006f,-1.7795233156999999e-006f,-1.7011740991999998e-006f,-1.6204049068999998e-006f,
    -1.5401112653999998e-006f,-1.4574509808999999e-006f,-1.3753140244999998e-006f,-1.2908648689999999e-006f,
    -1.2069890410999999e-006f,-1.1208576801999999e-006f,-1.0353507575000000e-006f,-9.4764585677999997e-007f,
    -8.6061928261000002e-007f,-7.7145495203999997e-007f,-6.8302405857999997e-007f,-5.9251618588999996e-007f,
    -5.0279830529999998e-007f,-4.1106611152000000e-007f,-3.2018190926000003e-007f,-2.2734761538999997e-007f,
    -1.3542097911000000e-007f,-4.1609883897000002e-008f,5.1233243218000004e-008f,1.4589409660000000e-007f,
    2.3952471584000000e-007f,3.3490531758000002e-007f,4.2919237470000002e-007f,5.2516008167999996e-007f,
    6.1997013356999999e-007f,7.1639072490999995e-007f,8.1158832848000002e-007f,9.0832602776000002e-007f,
    1.0037742954899999e-006f,1.1006909929800000e-006f,1.1962513707000000e-006f,1.2932070677999998e-006f,
    1.3887394457999999e-006f,1.4855951438999999e-006f,1.5809575236000000e-006f,1.6775698908000000e-006f,
    1.7726200513999998e-006f,1.8688457558000000e-006f,1.9634414765000000e-006f,2.0591371862000001e-006f,
    2.1531340239999999e-006f,2.2481564070999997e-006f,2.3414110301000000e-006f,2.4356145325000000e-006f,
    2.5279802755000001e-006f,2.6212215652999998e-006f,2.7125562074999999e-006f,2.8046897305999998e-006f,
    2.8948477179000000e-006f,2.9857301423999998e-006f,3.0745681429000001e-006f,3.1640561368999996e-006f,
    3.2514308187000000e-006f,3.3393799391999996e-006f,3.4251490814999998e-006f,3.5114193299000001e-006f,
    3.5954407118999999e-006f,3.6798909785000000e-006f,3.7620268238000003e-006f,3.8445171099999998e-006f,
    3.9246263089000003e-006f,4.0050210604999997e-006f,4.0829680588000003e-006f,4.1611294993999997e-006f,
    4.2367809651000000e-006f,4.3125757626999999e-006f,4.3857983638000003e-006f,4.4590942975000003e-006f,
    4.5297569242000000e-006f,4.6004273285999992e-006f,4.6684033154999996e-006f,4.7363204140999995e-006f,
    4.8014842068999998e-006f,4.8665246675999997e-006f,4.9287562675000002e-006f,4.9908012026000005e-006f,
    5.0499794997000001e-006f,5.1089122436999998e-006f,5.1649239057999998e-006f,5.2206300154000001e-006f,
    5.2733628213999994e-006f,5.3257322977000001e-006f,5.3750806930999996e-006f,5.4240090927000003e-006f,
    5.4698675230000000e-006f,5.5152537357999997e-006f,5.5575233130999998e-006f,5.5992684512000005e-006f,
    5.6378558430999997e-006f,5.6758687962999996e-006f,5.7106817815000003e-006f,5.7448736618000005e-006f,
    5.7758277967000002e-006f,5.8061163827000004e-006f,5.8331294458999997e-006f,5.8594369606000004e-006f,
    5.8824345083999995e-006f,5.9046876192000002e-006f,5.9235985411999998e-006f,5.9417294710000001e-006f,
    5.9564893234000003e-006f,5.9704358505999999e-006f,5.9809857451000001e-006f,5.9906923146999998e-006f,
    5.9969789184999996e-006f,6.0023933087999999e-006f,6.0043677334999995e-006f,6.0054455004999998e-006f,
    6.0030655242999996e-006f,5.9997688906000002e-006f,5.9930000693999996e-006f,5.9852945908999998e-006f,
    5.9741058139000004e-006f,5.9619659353000001e-006f,5.9463338694000004e-006f,5.9297395908999996e-006f,
    5.9096475695999994e-006f,5.8885844468999991e-006f,5.8640224702999992e-006f,5.8384816145999997e-006f,
    5.8094441271999992e-006f,5.7794266496000005e-006f,5.7459158736000007e-006f,5.7114273295999996e-006f,
    5.6734532648999995e-006f,5.6345047654999996e-006f,5.5920818563999999e-006f,5.5486934014000003e-006f,
    5.5018449810000000e-006f,5.4540410145999997e-006f,5.4027959714999994e-006f,5.3506098266999998e-006f,
    5.2950037160999995e-006f,5.2384742813999996e-006f,5.1785493250999996e-006f,5.1177210445000000e-006f,
    5.0535272419999995e-006f,4.9884545594000001e-006f,4.9200463545999997e-006f,4.8507881583000003e-006f,
    4.7782299949999999e-006f,4.7048507287999994e-006f,4.6282114951999996e-006f,4.5507844916999993e-006f,
    4.4701397426000002e-006f,4.3887450010000001e-006f,4.3041769577999993e-006f,4.2189000327999994e-006f,
    4.1304964723999999e-006f,4.0414295852999996e-006f,3.9492871733999999e-006f,3.8565281009999996e-006f,
    3.7607490588000003e-006f,3.6644022444999998e-006f,3.5650943486999997e-006f,3.4652720135999997e-006f,
    3.3625485964000000e-006f,3.2593674060000002e-006f,3.1533495772999997e-006f,3.0469317526000000e-006f,
    2.9377439555999998e-006f,2.8282194952999996e-006f,2.7159950620000000e-006f,2.6034972981000002e-006f,
    2.4883728937999997e-006f,2.3730429359999999e-006f,2.2551607814999997e-006f,2.1371441838999997e-006f,
    2.0166531665999999e-006f,1.8960999277000001e-006f,1.7731533794000001e-006f,1.6502201642999998e-006f,
    1.5249747501000000e-006f,1.3998215571999998e-006f,1.2724417199000002e-006f,1.1452318808999999e-006f,
    1.0158851743800000e-006f,8.8679057645000006e-007f,7.5564755455999999e-007f,6.2484164040999994e-007f,
    4.9207907916000001e-007f,3.5973929145999997e-007f,2.2553707794000001e-007f,9.1845370425999992e-008f,
    -4.3613663858999999e-008f,-1.7847243747999997e-007f,-3.1500162772999997e-007f,-4.5083893601000000e-007f,
    -5.8824789523999993e-007f,-7.2487197343000000e-007f,-8.6296759245999999e-007f,-1.0001846647200001e-006f,
    -1.1387719454999999e-006f,-1.2763839026999999e-006f,-1.4152647360999999e-006f,-1.5530733580000001e-006f,
    -1.6920475237999999e-006f,-1.8298517013000001e-006f,-1.9687169792999998e-006f,-2.1063144921999998e-006f,
    -2.2448675510999999e-006f,-2.3820539569999998e-006f,-2.5200903544000001e-006f,-2.6566589886999997e-006f,
    -2.7939731710999999e-006f,-2.9297195914000000e-006f,-3.0661037830999999e-006f,-3.2008213247999999e-006f,
    -3.3360699723000001e-006f,-3.4695508596999998e-006f,-3.6034561872999999e-006f,-3.7354937557999997e-006f,
    -3.8678502100000003e-006f,-3.9982377950000001e-006f,-4.1288387111999994e-006f,-4.2573718703000003e-006f,
    -4.3860116949999998e-006f,-4.5124837635999992e-006f,-4.6389591655000001e-006f,-4.7631679233999996e-006f,
    -4.8872744600999997e-006f,-5.0090176871000000e-006f,-5.1305575827999999e-006f,-5.2496341698000000e-006f,
    -5.3684063153999997e-006f,-5.4846207087999999e-006f,-5.6004284396000002e-006f,-5.7135850857999996e-006f,
    -5.8262350704000000e-006f,-5.9361406379999992e-006f,-6.0454439894000003e-006f,-6.1519095913999995e-006f,
    -6.2576763114999997e-006f,-6.3605175053000002e-006f,-6.4625653736999993e-006f,-6.5615999389000000e-006f,
    -6.6597478463000005e-006f,-6.7547980068999995e-006f,-6.8488715106000000e-006f,-6.9397639349999993e-006f,
    -7.0295908145000005e-006f,-7.1161566154999997e-006f,-7.2015724280000002e-006f,-7.2836482738999997e-006f,
    -7.3644907988000000e-006f,-7.4419166912000001e-006f,-7.5180314855999996e-006f,-7.5906552038000000e-006f,
    -7.6618900469999994e-006f,-7.7295660368999993e-006f,-7.7957775969999999e-006f,-7.8583636377999999e-006f,
    -7.9194141384000005e-006f,-7.9767757870000000e-006f,-8.0325330072000003e-006f,-8.0845413759999996e-006f,
    -8.1348819836999993e-006f,-8.1814159628000000e-006f,-8.2262210702999993e-006f,-8.2671662163999991e-006f,
    -8.3063247136999996e-006f,-8.3415754722999994e-006f,-8.3749829160000006e-006f,-8.4044381770000003e-006f,
    -8.4320012346999998e-006f,-8.4555698878999993e-006f,-8.4771996715999993e-006f,-8.4947961623000011e-006f,
    -8.5104126727999998e-006f,-8.5219614461999997e-006f,-8.5314935731000006e-006f,-8.5369290743000010e-006f,
    -8.5403123737999998e-006f,-8.5395734923000008e-006f,-8.5367535205000003e-006f,-8.5297902568000000e-006f,
    -8.5207203474999991e-006f,-8.5074915908999992e-006f,-8.4921339667000000e-006f,-8.4726063842000000e-006f,
    -8.4509332675999995e-006f,-8.4250824150000003e-006f,-8.3970749173000004e-006f,-8.3648852391999994e-006f,
    -8.3305333605000002e-006f,-8.2920004124999999e-006f,-8.2513019305999993e-006f,-8.2064301570999989e-006f,
    -8.1593928496999999e-006f,-8.1081933616999996e-006f,-8.0548361175000001e-006f,-7.9973322481000004e-006f,
    -7.9376817335000001e-006f,-7.8739057045999997e-006f,-7.8079985858999995e-006f,-7.7379903970999999e-006f,
    -7.6658733404999993e-006f,-7.5896852134999993e-006f,-7.5114137739999991e-006f,-7.4291045970999992e-006f,
    -7.3447443296000004e-006f,-7.2563852131999999e-006f,-7.1660083392000001e-006f,-7.0716781713999996e-006f,
    -6.9753713566999999e-006f,-6.8751590254999999e-006f,-6.7730144913999998e-006f,-6.6670177735999999e-006f,
    -6.5591388523999998e-006f,-6.4474655247000003e-006f,-6.3339633263999994e-006f,-6.2167300542999997e-006f,
    -6.0977267999000000e-006f,-5.9750602488000002e-006f,-5.8506859369999999e-006f,-5.7227183277999993e-006f,
    -5.5931129571999999e-006f,-5.4599898440000002e-006f,-5.3253011909000004e-006f,-5.1871736833000000e-006f,
    -5.0475584128000007e-006f,-4.9045898425000000e-006f,-4.7602123974000000e-006f,-4.6125705405000001e-006f,
    -4.4636053635000002e-006f,-4.3114679959999997e-006f,-4.1580973074999999e-006f,-4.0016499831000004e-006f,
    -3.8440626701000004e-006f,-3.6834998313000003e-006f,-3.5218936695999999e-006f,-3.3574164255000002e-006f,
    -3.1919947464000002e-006f,-3.0238119837999999e-006f,-2.8547881184999998e-006f,-2.6831153908000001e-006f,
    -2.5107093371000001e-006f,-2.3357677531999997e-006f,-2.1602061754999999e-006f,-1.9822257330999998e-006f,
    -1.8037397401999999e-006f,-1.6229559924999999e-006f,-1.4417833598000000e-006f,-1.2584385265999999e-006f,
    -1.0748246960900001e-006f,-8.8916544159000005e-007f,-7.0335952188999989e-007f,-5.1563884356000002e-007f,
    -3.2789638767000003e-007f,-1.3837172737999998e-007f,5.1047122857000003e-008f,2.4211313440000001e-007f,
    4.3294389274000001e-007f,6.2528474709000002e-007f,8.1725860510999990e-007f,1.0106036716399999e-006f,
    1.2034479653999999e-006f,1.3975226913000000e-006f,1.5909618680000001e-006f,1.7854888116000001e-006f,
    1.9792435406999999e-006f,2.1739415937000004e-006f,2.3677296557999996e-006f,2.5623165988000000e-006f,
    2.7558535522999998e-006f,2.9500438325999999e-006f,3.1430441248000000e-006f,3.3365510785999998e-006f,
    3.5287269345999999e-006f,3.7212616758999999e-006f,3.9123264319000001e-006f,4.1036011858000001e-006f,
    4.2932626224999995e-006f,4.4829885029999996e-006f,4.6709588454999997e-006f,4.8588447443999991e-006f,
    5.0448351066999995e-006f,5.2305921379999996e-006f,5.4143125229999998e-006f,5.5976540228999997e-006f,
    5.7788177668000005e-006f,5.9594559603999992e-006f,6.1377775104999992e-006f,6.3154268451000003e-006f,
    6.4906217597999998e-006f,6.6649989048999996e-006f,6.8367849647999993e-006f,7.0076110343000001e-006f,
    7.1757093532999997e-006f,7.3427054610999993e-006f,7.5068393752999997e-006f,7.6697321908000003e-006f,
    7.8296305917999998e-006f,7.9881501176999993e-006f,8.1435452303999995e-006f,8.2974248027000002e-006f,
    8.4480521853000006e-006f,8.5970318065999996e-006f,8.7426325728000005e-006f,8.8864555789999986e-006f,
    9.0267775091000000e-006f,9.1651939027000008e-006f,9.2999892214000000e-006f,9.4327534492999993e-006f,
    9.5617810478999997e-006f,9.6886553346999999e-006f,9.8116796599999991e-006f,9.9324351191000007e-006f,
    1.0049228395599999e-005f,1.0163638362600000e-005f,1.0273981703600000e-005f,1.0381829514000000e-005f,
    1.0485509588299999e-005f,1.0586588577499999e-005f,1.0683399831600001e-005f,1.0777508890500000e-005f,
    1.0867256881899999e-005f,1.0954203790200000e-005f,1.1036700743000000e-005f,1.1116299947000001e-005f,
    1.1191365863000000e-005f,1.1263454031000000e-005f,1.1330931134000001e-005f,1.1395330489999999e-005f,
    1.1455052115000000e-005f,1.1511618215999999e-005f,1.1563428809000001e-005f,1.1612028323000000e-005f,
    1.1655794551999999e-005f,1.1696271925000000e-005f,1.1731871569000001e-005f,1.1764126801999999e-005f,
    1.1791437640000000e-005f,1.1815348512000000e-005f,1.1834270545000000e-005f,1.1849748168000000e-005f,
    1.1860181397000001e-005f,1.1867125771999999e-005f,1.1869003530999999e-005f,1.1867336880999999e-005f,
    1.1860581393000000e-005f,1.1850248163000000e-005f,1.1834792762000001e-005f,1.1815748508000000e-005f,
    1.1791548750000001e-005f,1.1763749028000000e-005f,1.1730782690999999e-005f,1.1694194168000001e-005f,
    1.1652439030000000e-005f,1.1607050595000001e-005f,1.1556506655999999e-005f,1.1502318309000000e-005f,
    1.1442974458000001e-005f,1.1379997309999999e-005f,1.1311886879999999e-005f,1.1240154263999999e-005f,
    1.1163299477000000e-005f,1.1082836948299999e-005f,1.0997288914900000e-005f,1.0908153139600000e-005f,
    1.0813966303700001e-005f,1.0716222836699998e-005f,1.0613467197600000e-005f,1.0507193815900000e-005f,
    1.0395954928300001e-005f,1.0281240519899999e-005f,1.0161615049500001e-005f,1.0038565168899999e-005f,
    9.9106631146000005e-006f,9.7793944272999989e-006f,9.6433391211999993e-006f,9.5039805147999991e-006f,
    9.3599086221999998e-006f,9.2126023174999997e-006f,9.0606627258000003e-006f,8.9055642767999992e-006f,
    8.7459192066000000e-006f,8.5831975004999994e-006f,8.4160202834000007e-006f,8.2458553184000003e-006f,
    8.0713337302999999e-006f,7.8939177266999999e-006f,7.7122495433999989e-006f,7.5277880547000001e-006f,
    7.3391843852000001e-006f,7.1478940759000000e-006f,6.9525782512999997e-006f,6.7546880079999996e-006f,
    6.5528922481999991e-006f,6.3486420685000004e-006f,6.1406141488000000e-006f,5.9302540301999998e-006f,
    5.7162495036000001e-006f,5.5000427767999998e-006f,5.2803294183999993e-006f,5.0585471918000003e-006f,
    4.8334027766000001e-006f,4.6063283807000002e-006f,4.3760406835999996e-006f,4.1439674487999999e-006f,
    3.9088331334999997e-006f,3.6720621678999997e-006f,3.4323878979999999e-006f,3.1912325318000002e-006f,
    2.9473349708000003e-006f,2.7021129785999998e-006f,2.4543176788000001e-006f,2.2053590573000001e-006f,
    1.9539971265000000e-006f,1.7016385389999999e-006f,1.4470499737999999e-006f,1.1916358613000001e-006f,
    9.3416832488999993e-007f,6.7604912832999999e-007f,4.1605828382000000e-007f,1.5559188850999999e-007f,
    -1.0656186770400000e-007f,-3.6901119874000001e-007f,-6.3296111477000005e-007f,-8.9702414077999998e-007f,
    -1.1623972648000001e-006f,-1.4276990562000000e-006f,-1.6941197252999999e-006f,-1.9602803970000000e-006f,
    -2.2273666149999998e-006f,-2.4940039485999997e-006f,-2.7613701638000000e-006f,-3.0280963854000001e-006f,
    -3.2953537128000002e-006f,-3.5617799373999998e-006f,-3.8285372698000000e-006f,-4.0942690568999999e-006f,
    -4.3601330649000001e-006f,-4.6247759740000005e-006f,-4.8893522170999998e-006f,-5.1525118076999994e-006f,
    -5.4154025121000004e-006f,-5.6766810104000000e-006f,-5.9374906245000004e-006f,-6.1964924788999995e-006f,
    -6.4548243399999994e-006f,-6.7111528877999999e-006f,-6.9666092221000000e-006f,-7.2198700227999997e-006f,
    -7.4720575009000000e-006f,-7.7218550029000002e-006f,-7.9703802953999988e-006f,-8.2163233914999996e-006f,
    -8.4607976134000004e-006f,-8.7024963074999997e-006f,-8.9425305737999999e-006f,-9.1796015363999993e-006f,
    -9.4148125175999988e-006f,-9.6468724191999996e-006f,-9.8768812302000007e-006f,-1.0103554519000001e-005f,
    -1.0327985608000000e-005f,-1.0548897843299999e-005f,-1.0767382325100000e-005f,-1.0982169066100000e-005f,
    -1.1194343611000000e-005f,-1.1402641528000001e-005f,-1.1608150584000000e-005f,-1.1809615235999998e-005f,
    -1.2008102139999999e-005f,-1.2202389086000001e-005f,-1.2393520507999999e-005f,-1.2580274196000001e-005f,
    -1.2763716806000000e-005f,-1.2942615017000000e-005f,-1.3118046596000000e-005f,-1.3288778222000001e-005f,
    -1.3455865439999999e-005f,-1.3618119373000001e-005f,-1.3776573343999999e-005f,-1.3930038476000000e-005f,
    -1.4079570314000000e-005f,-1.4223957759000000e-005f,-1.4364267467000000e-005f,-1.4499310561000000e-005f,
    -1.4630131474999999e-005f,-1.4755563553999999e-005f,-1.4876640120999998e-005f,-1.4992183410000000e-005f,
    -1.5103260077000000e-005f,-1.5208703467000000e-005f,-1.5309546902999998e-005f,-1.5404645951999999e-005f,
    -1.5495022826000001e-005f,-1.5579566425000000e-005f,-1.5659287850000001e-005f,-1.5733064890000000e-005f,
    -1.5801930868000002e-005f,-1.5864763573000001e-005f,-1.5922585217000000e-005f,-1.5974306921999998e-005f,
    -1.6020928678000002e-005f,-1.6061361607000000e-005f,-1.6096639032000001e-005f,-1.6125649853000001e-005f,
    -1.6149438504000002e-005f,-1.6166916107000000e-005f,-1.6179093762999998e-005f,-1.6184904816000000e-005f,
    -1.6185382588999999e-005f,-1.6179449315000000e-005f,-1.6168127206000001e-005f,-1.6150371827999999e-005f,
    -1.6127194282000000e-005f,-1.6097550133999999e-005f,-1.6062450484999997e-005f,-1.6020884233999998e-005f,
    -1.5973840260000001e-005f,-1.5920307461999999e-005f,-1.5861296941000000e-005f,-1.5795797595999999e-005f,
    -1.5724820528000001e-005f,-1.5647365746999999e-005f,-1.5564444353999998e-005f,-1.5475056359000000e-005f,
    -1.5380223974000000e-005f,-1.5278947209000002e-005f,-1.5172248276000000e-005f,-1.5059149406999999e-005f,
    -1.4940661703000000e-005f,-1.4815818506999999e-005f,-1.4685619809000000e-005f,-1.4549121174000000e-005f,
    -1.4407333702999999e-005f,-1.4259312961000001e-005f,-1.4106047827000000e-005f,-1.3946616088000000e-005f,
    -1.3782017734000000e-005f,-1.3611341663000000e-005f,-1.3435576754000000e-005f,-1.3253811905000000e-005f,
    -1.3067047105999999e-005f,-1.2874393476999998e-005f,-1.2676828786000000e-005f,-1.2473475264000000e-005f,
    -1.2265321790000000e-005f,-1.2051501706000001e-005f,-1.1832981669000000e-005f,-1.1608917243000000e-005f,
    -1.1380297306999999e-005f,-1.1146244092000001e-005f,-1.0907762032400001e-005f,-1.0664002247800001e-005f,
    -1.0415944728400000e-005f,-1.0162757260299999e-005f,-9.9054187226000000e-006f,-9.6431069012999992e-006f,
    -9.3767984532999995e-006f,-9.1056789422999996e-006f,-8.8307250251999993e-006f,-8.5511322655999990e-006f,
    -8.2678728759999995e-006f,-7.9801546420999997e-006f,-7.6889464431000001e-006f,-7.3934638423999998e-006f,
    -7.0946746081000001e-006f,-6.7918043034999993e-006f,-6.4858184744999999e-006f,-6.1759515732000000e-006f,
    -5.8631647010999997e-006f,-5.5467023101999996e-006f,-5.2275232798000004e-006f,-4.9048820618000000e-006f,
    -4.5797330911000001e-006f,-4.2513385973000000e-006f,-3.9206530152999995e-006f,-3.5869463523999998e-006f,
    -3.2511674880000001e-006f,-2.9125975403999997e-006f,-2.5721809445999996e-006f,-2.2292077077000002e-006f,
    -1.8846200424999999e-006f,-1.5377135116000001e-006f,-1.1894269945000000e-006f,-8.3906638702999998e-007f,
    -4.8756545762999997e-007f,-1.3423821315999999e-007f,2.1998602234000000e-007f,5.7578479764999992e-007f,
    9.3223312201999996e-007f,1.2900004332000001e-006f,1.6481668514999998e-006f,2.0073943703000002e-006f,
    2.3667674431999998e-006f,2.7269405081000004e-006f,3.0870035740999997e-006f,3.4476021902999999e-006f,
    3.8078319212999999e-006f,4.1683316496000003e-006f,4.5282036063999993e-006f,4.8880777854000003e-006f,
    5.2470619732999997e-006f,5.6057806083000002e-006f,5.9633448103999993e-006f,6.3203745733999999e-006f,
    6.6759876839000000e-006f,7.0307952469000000e-006f,7.3839217155999999e-006f,7.7359726395000007e-006f,
    8.0860791383999993e-006f,8.4348400952000001e-006f,8.7813921852000000e-006f,9.1263298469000007e-006f,
    9.4687964221999987e-006f,9.8093796829999997e-006f,1.0147230748900000e-005f,1.0482931836300000e-005f,
    1.0815640731400000e-005f,1.1145932984000000e-005f,1.1472974158000001e-005f,1.1797348692000000e-005f,
    1.2118201039000000e-005f,1.2436120082000000e-005f,1.2750283606999999e-005f,1.3061258275000000e-005f,
    1.3368221872000000e-005f,1.3671729947999999e-005f,1.3970993622000000e-005f,1.4266546222000001e-005f,
    1.4557609978000000e-005f,1.4844729328999999e-005f,1.5127115393999998e-005f,1.5405323723000001e-005f,
    1.5678554323999999e-005f,1.5947373858000000e-005f,1.6210993443999999e-005f,1.6469968631999999e-005f,
    1.6723510540999998e-005f,1.6972196943000000e-005f,1.7215238956999997e-005f,1.7453181021999999e-005f,
    1.7685289812000001e-005f,1.7912087544000001e-005f,1.8132840892000002e-005f,1.8348083184000000e-005f,
    1.8557081093999997e-005f,1.8760367950000001e-005f,1.8957221536999999e-005f,1.9148175182999997e-005f,
    1.9332506673000001e-005f,1.9510760446000001e-005f,1.9682225398000000e-005f,1.9847434857000000e-005f,
    2.0005677719000002e-005f,2.0157509533999998e-005f,2.0302219197999998e-005f,2.0440351149999998e-005f,
    2.0571227619000000e-005f,2.0695370821999999e-005f,2.0812114099000000e-005f,2.0921979666999997e-005f,
    2.1024334198999997e-005f,2.1119677690000002e-005f,2.1207365701999999e-005f,2.1287942674000001e-005f,
    2.1360764168000002e-005f,2.1426352401000001e-005f,2.1484085156999998e-005f,2.1534484652999998e-005f,
    2.1576939783999998e-005f,2.1611983878000000e-005f,2.1638994718999998e-005f,2.1658505635000000e-005f,
    2.1669927742999999e-005f,2.1673783260000001e-005f,2.1669494414000001e-005f,2.1657572310999999e-005f,
    2.1637472512000003e-005f,2.1609683900999999e-005f,2.1573684260999999e-005f,2.1529973586999997e-005f,
    2.1478018551000000e-005f,2.1418330259000002e-005f,2.1350386493999999e-005f,2.1274698362000000e-005f,
    2.1190754757000001e-005f,2.1099077896000000e-005f,2.0999145561999998e-005f,2.0891491083000000e-005f,
    2.0775614464000000e-005f,2.0652026810999999e-005f,2.0520261462000000e-005f,2.0380829522999998e-005f,
    2.0233253221000000e-005f,2.0078054773000002e-005f,1.9914789739000001e-005f,1.9743947002999999e-005f,
    1.9565115457999999e-005f,1.9378783988000001e-005f,1.9184530375000000e-005f,1.8982865724999998e-005f,
    1.8773378931000000e-005f,1.8556569987999999e-005f,1.8332050011000000e-005f,1.8100330105999999e-005f,
    1.7860999165999997e-005f,1.7614579408000001e-005f,1.7360693057999997e-005f,1.7099851222000002e-005f,
    1.6831676126000001e-005f,1.6556678876000000e-005f,1.6274515030999999e-005f,1.5985684586000000e-005f,
    1.5689831989000001e-005f,1.5387490568000000e-005f,1.5078315881999999e-005f,1.4762807925999999e-005f,
    1.4440644480999999e-005f,1.4112347764000000e-005f,1.3777595556000000e-005f,1.3436910073999999e-005f,
    1.3089969099000000e-005f,1.2737294848000001e-005f,1.2378587323999999e-005f,1.2014357633000000e-005f,
    1.1644339111000000e-005f,1.1269020642000001e-005f,1.0888131117599999e-005f,1.0502191643699999e-005f,
    1.0110931111900000e-005f,9.7148628503999999e-006f,9.3137301950999997e-006f,8.9080442520000001e-006f,
    8.4975572458000002e-006f,8.0827813935999997e-006f,7.6634778089000008e-006f,7.2401564865999997e-006f,
    6.8125885401000000e-006f,6.3812828531999995e-006f,5.9460205392000001e-006f,5.5073071486000007e-006f,
    5.0649337945999991e-006f,4.6194038054999996e-006f,4.1705182944000001e-006f,3.7187783674000001e-006f,
    3.2639906930999999e-006f,2.8066597108999999e-006f,2.3465965337999999e-006f,1.8843033790000000e-006f,
    1.4196024705000002e-006f,9.5299002556000000e-007f,4.8429771252999998e-007f,1.4019515358999999e-008f,
    -4.5800597544999998e-007f,-9.3128735370000005e-007f,-1.4059781623000000e-006f,-1.8815911839000000e-006f,
    -2.3582719725999999e-006f,-2.8355371998999998e-006f,-3.3135246422000001e-006f,-3.7917543042999997e-006f,
    -4.2703595181999994e-006f,-4.7488613998000004e-006f,-5.2273877255999996e-006f,-5.7054651670000002e-006f,
    -6.1832137228000005e-006f,-6.6601656198999997e-006f,-7.1364319682999995e-006f,-7.6115527726000003e-006f,
    -8.0856324762000004e-006f,-8.5582144170000006e-006f,-9.0293997050999994e-006f,-9.4987361228000003e-006f,
    -9.9663192247000008e-006f,-1.0431702348600000e-005f,-1.0894975493600000e-005f,-1.1355697552999999e-005f,
    -1.1813959637000000e-005f,-1.2269310639000001e-005f,-1.2721850558000001e-005f,-1.3171146065000000e-005f,
    -1.3617263826000001e-005f,-1.4059792734000001e-005f,-1.4498810566000000e-005f,-1.4933883993000000e-005f,
    -1.5365090791999999e-005f,-1.5792019856000000e-005f,-1.6214748961999998e-005f,-1.6632867002999999e-005f,
    -1.7046429533999998e-005f,-1.7455058781000000e-005f,-1.7858799187999999e-005f,-1.8257284091999997e-005f,
    -1.8650546826000001e-005f,-1.9038220727000001e-005f,-1.9420372461000000e-005f,-1.9796613143000000e-005f,
    -2.0167009439000002e-005f,-2.0531183574999999e-005f,-2.0889202216999997e-005f,-2.1240709812999996e-005f,
    -2.1585750807000001e-005f,-2.1923980758000000e-005f,-2.2255455221000001e-005f,-2.2579829754999998e-005f,
    -2.2897159914999999e-005f,-2.3207123481999999e-005f,-2.3509753789000001e-005f,-2.3804739727999999e-005f,
    -2.4092136853999998e-005f,-2.4371622947999999e-005f,-2.4643253564999998e-005f,-2.4906739818999999e-005f,
    -2.5162115042999999e-005f,-2.5409090351000001e-005f,-2.5647721298000000e-005f,-2.5877741220000000e-005f,
    -2.6099172338999996e-005f,-2.6311759102000001e-005f,-2.6515557064000000e-005f,-2.6710310672000000e-005f,
    -2.6896053258999998e-005f,-2.7072562605000000e-005f,-2.7239860931999998e-005f,-2.7397748241999998e-005f,
    -2.7546235645999997e-005f,-2.7685145368000000e-005f,-2.7814499629999999e-005f,-2.7934098433999999e-005f,
    -2.8043986224000000e-005f,-2.8143985223999997e-005f,-2.8234128766999997e-005f,-2.8314239077000002e-005f,
    -2.8384371708999997e-005f,-2.8444348887000000e-005f,-2.8494237277000001e-005f,-2.8533881324999999e-005f,
    -2.8563314363999998e-005f,-2.8582414172999999e-005f,-2.8591214085000000e-005f,-2.8589614100999998e-005f,
    -2.8577647553999999e-005f,-2.8555214445000000e-005f,-2.8522348106999998e-005f,-2.8478970762999999e-005f,
    -2.8425137968000000e-005f,-2.8360749722999997e-005f,-2.8285861583000001e-005f,-2.8200417992999999e-005f,
    -2.8104474508000001e-005f,-2.7997964461999999e-005f,-2.7880954520999998e-005f,-2.7753389130000002e-005f,
    -2.7615346066000000e-005f,-2.7466791996000000e-005f,-2.7307782474999997e-005f,-2.7138295280999999e-005f,
    -2.6958419301999997e-005f,-2.6768121205000001e-005f,-2.6567500989000002e-005f,-2.6356547543000001e-005f,
    -2.6135338643999998e-005f,-2.5903885402999997e-005f,-2.5662276707999998e-005f,-2.5410545891999998e-005f,
    -2.5148759621000000e-005f,-2.4876973449999998e-005f,-2.4595276267000000e-005f,-2.4303701405000000e-005f,
    -2.4002348863000000e-005f,-2.3691296417999999e-005f,-2.3370621846999998e-005f,-2.3040402926999999e-005f,
    -2.2700739656999999e-005f,-2.2351720924999999e-005f,-2.1993446730000002e-005f,-2.1626017070999998e-005f,
    -2.1249531947000001e-005f,-2.0864113579000001e-005f,-2.0469850854999999e-005f,-2.0066877106999997e-005f,
    -1.9655292334000002e-005f,-1.9235252089999999e-005f,-1.8806845263000000e-005f,-1.8370238517999997e-005f,
    -1.7925520742999999e-005f,-1.7472869714000001e-005f,-1.7012385430000002e-005f,-1.6544256777999999e-005f,
    -1.6068583757000000e-005f,-1.5585555253999999e-005f,-1.5095282379000000e-005f,-1.4597976241000000e-005f,
    -1.4093725728000000e-005f,-1.3582764171000000e-005f,-1.3065180458000000e-005f,-1.2541219031000000e-005f,
    -1.2010990999999999e-005f,-1.1474718585000000e-005f,-1.0932519562600000e-005f,-1.0384642819200001e-005f,
    -9.8311939093000003e-006f,-9.2724350524999985e-006f,-8.7084718032999996e-006f,-8.1395786034000007e-006f,
    -7.5658587850999996e-006f,-6.9875956789000000e-006f,-6.4048937281999993e-006f,-5.8180473744999995e-006f,
    -5.2271566167999996e-006f,-4.6325281186999997e-006f,-4.0342607681000003e-006f,-3.4326678952000000e-006f,
    -2.8278494989999999e-006f,-2.2201289095999999e-006f,-1.6096016816000001e-006f,-9.9659970056999990e-007f,
    -3.8121863221999996e-007f,2.3620174907000000e-007f,8.5556866645000008e-007f,1.4765341233999998e-006f,
    2.0990078985999998e-006f,2.7226338844999998e-006f,3.3473254153000001e-006f,3.9727180501999999e-006f,
    4.5987273456000001e-006f,5.2249844162999998e-006f,5.8514070409000002e-006f,6.4776196675999999e-006f,
    7.1035422972000000e-006f,7.7287938223999997e-006f,8.3532997995000001e-006f,8.9766724545999994e-006f,
    9.5988406773000008e-006f,1.0219410027099999e-005f,1.0838317171300000e-005f,1.1455163225000000e-005f,
    1.2069879299999998e-005f,1.2682073177999999e-005f,1.3291678192999999e-005f,1.3898294348999999e-005f,
    1.4501877202000000e-005f,1.5101993423000000e-005f,1.5698620790000000e-005f,1.6291325974000001e-005f,
    1.6880075641999999e-005f,1.7464447575999999e-005f,1.8044419554000000e-005f,1.8619569357999999e-005f,
    1.9189863655000000e-005f,1.9754869115999998e-005f,2.0314585740999997e-005f,2.0868580201000001e-005f,
    2.1416830274000000e-005f,2.1958924852999999e-005f,2.2494841715999999e-005f,2.3024169756000000e-005f,
    2.3546897861999997e-005f,2.4062592704999997e-005f,2.4571276507000001e-005f,2.5072515938999999e-005f,
    2.5566333223000000e-005f,2.6052283919000002e-005f,2.6530412471000001e-005f,2.7000274439000001e-005f,
    2.7461914266999998e-005f,2.7914898625999998e-005f,2.8359271959999999e-005f,2.8794612050999999e-005f,
    2.9220974453999999e-005f,2.9637914728999998e-005f,3.0045510652999999e-005f,3.0443340007999999e-005f,
    3.0831469459999998e-005f,3.1209465679999999e-005f,3.1577439778000000e-005f,3.1934947313999999e-005f,
    3.2282099397999997e-005f,3.2618451589999999e-005f,3.2944137222000000e-005f,3.3258722964999999e-005f,
    3.3562342150999998e-005f,3.3854561451000002e-005f,3.4135514196999999e-005f,3.4404800392999997e-005f,
    3.4662553370999998e-005f,3.4908362023999996e-005f,3.5142393017000004e-005f,3.5364224132000003e-005f,
    3.5574033144999998e-005f,3.5771408948999996e-005f,3.5956540430999999e-005f,3.6129027595000001e-005f,
    3.6289059328000003e-005f,3.6436246744999996e-005f,3.6570789844000002e-005f,3.6692288629000000e-005f,
    3.6800987541999998e-005f,3.6896475475999997e-005f,3.6979007983999996e-005f,3.7048185069999996e-005f,
    3.7104262286999997e-005f,3.7146850750000002e-005f,3.7176239345000001e-005f,3.7192016965000001e-005f,
    3.7194494718000002e-005f,3.7183283719000001e-005f,3.7158672854000001e-005f,3.7120306570999994e-005f,
    3.7068495978000001e-005f,3.7002863301000005e-005f,3.6923752981000006e-005f,3.6830776132999996e-005f,
    3.6724299420000000e-005f,3.6603956179000000e-005f,3.6470113072999994e-005f,3.6322403439000003e-005f,
    3.6161205051000005e-005f,3.5986173467999998e-005f,3.5797697574999998e-005f,3.5595432930999996e-005f,
    3.5379779532000000e-005f,3.5150392936999996e-005f,3.4907717585999996e-005f,3.4651397927000003e-005f,
    3.4381867288999998e-005f,3.4098814564000003e-005f,3.3802673080999999e-005f,3.3493131731999996e-005f,
    3.3170646067999998e-005f,3.2834893870000002e-005f,3.2486364022000003e-005f,3.2124745415999995e-005f,
    3.1750538046999999e-005f,3.1363408584999999e-005f,3.0963890357999996e-005f,3.0551672257999999e-005f,
    3.0127276502000002e-005f,2.9690403093000000e-005f,2.9241596469999999e-005f,2.8780556635999997e-005f,
    2.8307839141000002e-005f,2.7823166209999998e-005f,2.7327093392999996e-005f,2.6819331803999998e-005f,
    2.6300481436999999e-005f,2.5770242295000001e-005f,2.5229225482999997e-005f,2.4677142114999999e-005f,
    2.4114614407000001e-005f,2.3541353472999999e-005f,2.2958003751000002e-005f,2.2364287465999997e-005f,
    2.1760837945000000e-005f,2.1147388524000000e-005f,2.0524594752000001e-005f,1.9892201075999999e-005f,
    1.9250863044999999e-005f,1.8600325106000001e-005f,1.7941253918999999e-005f,1.7273405041999997e-005f,
    1.6597467356999997e-005f,1.5913185310999999e-005f,1.5221258897000000e-005f,1.4521432562000000e-005f,
    1.3814428521000001e-005f,1.3099991221000000e-005f,1.2378853988000000e-005f,1.1650761269000000e-005f,
    1.0916447501100000e-005f,1.0175673797799998e-005f,9.4291823738999994e-006f,8.6767343428999985e-006f,
    7.9190808084000003e-006f,7.1559839950000002e-006f,6.3882050062000004e-006f,5.6155082887999992e-006f,
    4.8386649462000002e-006f,4.0574372029999999e-006f,3.2726083847000000e-006f,2.4839384936999997e-006f,
    1.6922208553999999e-006f,8.9721491665000002e-007f,9.9722602763999999e-008f,-7.0049688385000003e-007f,
    -1.5026349734999999e-006f,-2.3069313748999996e-006f,-3.1125710962000000e-006f,-3.9197963572000001e-006f,
    -4.7277816105999999e-006f,-5.5367746316999999e-006f,-6.3459432065999999e-006f,-7.1555328883999997e-006f,
    -7.9647070187999989e-006f,-8.7737167064000001e-006f,-9.5817164040999989e-006f,-1.0388960553800001e-005f,
    -1.1194599164000000e-005f,-1.1998891121000000e-005f,-1.2800971989000000e-005f,-1.3601119543000001e-005f,
    -1.4398456013999998e-005f,-1.5193259176999999e-005f,-1.5984651262999999e-005f,-1.6772921158000001e-005f,
    -1.7557191093000000e-005f,-1.8337738842999999e-005f,-1.9113697749999998e-005f,-1.9885334477999998e-005f,
    -2.0651782368999998e-005f,-2.1413330309000000e-005f,-2.2169100529000001e-005f,-2.2919381914999997e-005f,
    -2.3663296697999997e-005f,-2.4401167097000000e-005f,-2.5132082010000000e-005f,-2.5856363655999998e-005f,
    -2.6573123155000000e-005f,-2.7282682725999999e-005f,-2.7984164600000000e-005f,-2.8677890995999999e-005f,
    -2.9362961923000002e-005f,-3.0039732932999999e-005f,-3.0707315145999997e-005f,-3.1366041891999998e-005f,
    -3.2015046512999999e-005f,-3.2654662339000001e-005f,-3.3284022712000000e-005f,-3.3903483184000003e-005f,
    -3.4512154874999995e-005f,-3.5110437781000003e-005f,-3.5697420800000002e-005f,-3.6273515038999998e-005f,
    -3.6837820506999996e-005f,-3.7390748311000004e-005f,-3.7931409570999999e-005f,-3.8460237616000004e-005f,
    -3.8976332455000000e-005f,-3.9480127416999994e-005f,-3.9970744732999999e-005f,-4.0448628843000001e-005f,
    -4.0912913088999996e-005f,-4.1364030800000001e-005f,-4.1801137540000001e-005f,-4.2224677748999996e-005f,
    -4.2633795880000003e-005f,-4.3028969705999996e-005f,-4.3409343679999997e-005f,-4.3775406686000001e-005f,
    -4.4126303176999995e-005f,-4.4462544258999999e-005f,-4.4783274384999999e-005f,-4.5089026882999998e-005f,
    -4.5378946206000005e-005f,-4.5653576792999998e-005f,-4.5912085318999997e-005f,-4.6155005111999997e-005f,
    -4.6381513957999995e-005f,-4.6592189629000000e-005f,-4.6786198799999997e-005f,-4.6964119242999995e-005f,
    -4.7125139854999997e-005f,-4.7269849519000004e-005f,-4.7397448242999996e-005f,-4.7508547131999998e-005f,
    -4.7602346193999997e-005f,-4.7679456533999998e-005f,-4.7739111493000004e-005f,-4.7781933286999998e-005f,
    -4.7807155256999997e-005f,-4.7815410730000001e-005f,-4.7805955269000005e-005f,-4.7779433312000001e-005f,
    -4.7735100422000003e-005f,-4.7673645480999999e-005f,-4.7594290718999999e-005f,-4.7497769461999999e-005f,
    -4.7383315050999995e-005f,-4.7251649701000002e-005f,-4.7102040086000001e-005f,-4.6935230643000003e-005f,
    -4.6750488046000001e-005f,-4.6548556731999994e-005f,-4.6328736707999998e-005f,-4.6091783521999996e-005f,
    -4.5836986069999999e-005f,-4.5565133232999999e-005f,-4.5275536128999996e-005f,-4.4968994750000003e-005f,
    -4.4644797992000002e-005f,-4.4303790290999999e-005f,-4.3945282765000000e-005f,-4.3570108739000000e-005f,
    -4.3177601552999996e-005f,-4.2768605642999999e-005f,-4.2342465460000000e-005f,-4.1900047662000000e-005f,
    -4.1440696699999995e-005f,-4.0965312564999997e-005f,-4.0473217485999997e-005f,-3.9965355897999996e-005f,
    -3.9441061140999995e-005f,-3.8901255427999999e-005f,-3.8345327653999994e-005f,-3.7774200031999998e-005f,
    -3.7187261457000000e-005f,-3.6585456363999999e-005f,-3.5968173647999997e-005f,-3.5336379965999997e-005f,
    -3.4689486435000000e-005f,-3.4028459712000001e-005f,-3.3352710914000000e-005f,-3.2663240031000002e-005f,
    -3.1959458180000000e-005f,-3.1242376461999998e-005f,-3.0511428215999999e-005f,-2.9767635654000002e-005f,
    -2.9010409892999999e-005f,-2.8240817588999998e-005f,-2.7458280970000000e-005f,-2.6663877803000002e-005f,
    -2.5857019205000000e-005f,-2.5038794053999999e-005f,-2.4208657910999998e-005f,-2.3367677432000000e-005f,
    -2.2515319289000001e-005f,-2.1652683470999999e-005f,-2.0779225538999998e-005f,-1.9896067703999996e-005f,
    -1.9002654415999999e-005f,-1.8100130107999999e-005f,-1.7187961451999998e-005f,-1.6267281770000001e-005f,
    -1.5337568845000000e-005f,-1.4399967109999999e-005f,-1.3453965459000001e-005f,-1.2500719435999999e-005f,
    -1.1539706824000001e-005f,-1.0572109833399999e-005f,-9.5974073583000000e-006f,-8.6167927201000000e-006f,
    -7.6297414796000002e-006f,-6.6374614025000001e-006f,-5.6394291607000004e-006f,-4.6368636308999996e-006f,
    -3.6292425960999997e-006f,-2.6177938218000003e-006f,-1.6019995354000001e-006f,-5.8309250235000003e-007f,
    4.3944260553000000e-007f,1.4643631340000000e-006f,2.4921861890000002e-006f,3.5216603386000000e-006f,
    4.5533022442999998e-006f,5.5858530298000005e-006f,6.6198304677000001e-006f,7.6539690151000006e-006f,
    8.6887875557000003e-006f,9.7230138799999986e-006f,1.0757166871700000e-005f,1.1789970987999999e-005f,
    1.2821949557000000e-005f,1.3851817036000000e-005f,1.4880095641999999e-005f,1.5905507610000001e-005f,
    1.6928575157000000e-005f,1.7947998296000000e-005f,1.8964321465999999e-005f,1.9976255790999997e-005f,
    2.0984312377000000e-005f,2.1987213458999999e-005f,2.2985492364999999e-005f,2.3977849107999998e-005f,
    2.4964839237999997e-005f,2.5945151657000001e-005f,2.6919330804000001e-005f,2.7886087802999999e-005f,
    2.8845978203999999e-005f,2.9797690908999998e-005f,3.0741803689999997e-005f,3.1677005449000004e-005f,
    3.2603862846999998e-005f,3.3521075897000002e-005f,3.4429233482000002e-005f,3.5327035614999999e-005f,
    3.6215060067999997e-005f,3.7092006853999996e-005f,3.7958487078000002e-005f,3.8813189641999996e-005f,
    3.9656725651000004e-005f,4.0487806228999998e-005f,4.1307053592000002e-005f,4.2113156641999998e-005f,
    4.2906759817000000e-005f,4.3686574241000001e-005f,4.4453244352000002e-005f,4.5205470162999995e-005f,
    4.5943918333999994e-005f,4.6667299988999996e-005f,4.7376292899000005e-005f,4.8069619298999998e-005f,
    4.8747945848999999e-005f,4.9410017006000005e-005f,5.0056521652000001e-005f,5.0686193132999999e-005f,
    5.1299742553000003e-005f,5.1895914368999994e-005f,5.2475419684999998e-005f,5.3037025179999999e-005f,
    5.3581453069000002e-005f,5.4107458919999999e-005f,5.4615809392000002e-005f,5.5105260052999996e-005f,
    5.5576588672999999e-005f,5.6028550820000003e-005f,5.6461946486000002e-005f,5.6875553460999999e-005f,
    5.7270171736999993e-005f,5.7644590215000001e-005f,5.7999631108999999e-005f,5.8334083319999996e-005f,
    5.8648802394999997e-005f,5.8942588345999997e-005f,5.9216285608999996e-005f,5.9468727528999996e-005f,
    5.9700780764000003e-005f,5.9911278658999998e-005f,6.0101110093999997e-005f,6.0269108413999995e-005f,
    6.0416195832000002e-005f,6.0541205692999995e-005f,6.0645082432000000e-005f,6.0726692726999997e-005f,
    6.0786958791000001e-005f,6.0824780634999993e-005f,6.0841113804999999e-005f,6.0834847201000001e-005f,
    6.0806958591000001e-005f,6.0756359096999998e-005f,6.0684037598000001e-005f,6.0588927437999997e-005f,
    6.0472028607000002e-005f,6.0332285559999994e-005f,6.0170731619999997e-005f,5.9986300131000000e-005f,
    5.9780057749000000e-005f,5.9550960040000003e-005f,5.9300084770999998e-005f,5.9026387508000000e-005f,
    5.8730990461999996e-005f,5.8412849198999994e-005f,5.8073097040999996e-005f,5.7710722886999997e-005f,
    5.7326860058999997e-005f,5.6920530788999996e-005f,5.6492868399000001e-005f,5.6042917343000000e-005f,
    5.5571833164999998e-005f,5.5078660318999996e-005f,5.4564598793000001e-005f,5.4028693041000000e-005f,
    5.3472143051000000e-005f,5.2894026610000003e-005f,5.2295577038999997e-005f,5.1675861014000002e-005f,
    5.1036134078000002e-005f,5.0375485128999999e-005f,4.9695191932000001e-005f,4.8994332274000000e-005f,
    4.8274217252999999e-005f,4.7533957989000004e-005f,4.6774854469000001e-005f,4.5996040034999999e-005f,
    4.5198825784999995e-005f,4.4382367282999996e-005f,4.3548008959999996e-005f,4.2694884157999996e-005f,
    4.1824381751999998e-005f,4.0935635083999997e-005f,4.0030033029000001e-005f,3.9106753372999999e-005f,
    3.8167196101999997e-005f,3.7210539002000000e-005f,3.6238193169999996e-005f,3.5249358614000001e-005f,
    3.4245457541999996e-005f,3.3225712184000000e-005f,3.2191544748000002e-005f,3.1142188574999997e-005f,
    3.0079099206000000e-005f,2.9001498871000000e-005f,2.7910876443999999e-005f,2.6806443043999996e-005f,
    2.5689709766999999e-005f,2.4559909954000001e-005f,2.3418543590000000e-005f,2.2264877349000002e-005f,
    2.1100422326999999e-005f,1.9924434086999999e-005f,1.8738445946999999e-005f,1.7541724580999998e-005f,
    1.6335825528999999e-005f,1.5120004354000000e-005f,1.3895827707000001e-005f,1.2662562261999999e-005f,
    1.1421796892000001e-005f,1.0172800493200001e-005f,8.9171608274999987e-006f,7.6541579021000002e-006f,
    6.3853928121000004e-006f,5.1101477868999995e-006f,3.8300361437000000e-006f,2.5443390007999997e-006f,
    1.2546830086000000e-006f,-3.9648070181999999e-008f,-1.3370199630000000e-006f,-2.6381469516000000e-006f,
    -3.9413861413000001e-006f,-5.2474497471999998e-006f,-6.5546866746999997e-006f,-7.8638091389000004e-006f,
    -9.1731593785999987e-006f,-1.0483449608899999e-005f,-1.1793015402000000e-005f,-1.3102568972999999e-005f,
    -1.4410433671999999e-005f,-1.5717342824999998e-005f,-1.7021596449000001e-005f,-1.8323927869999998e-005f,
    -1.9622648215999997e-005f,-2.0918479701999997e-005f,-2.2209744566999998e-005f,-2.3497142803999998e-005f,
    -2.4779018873999997e-005f,-2.6056083880999998e-005f,-2.7326637842000001e-005f,-2.8591425194000002e-005f,
    -2.9848768175999999e-005f,-3.1099366781000003e-005f,-3.2341565470000002e-005f,-3.3576086457999998e-005f,
    -3.4801251983999999e-005f,-3.6017795373999997e-005f,-3.7224038866999993e-005f,-3.8420726899999999e-005f,
    -3.9606192822999999e-005f,-4.0781181073000000e-005f,-4.1944002778000002e-005f,-4.3095446818999999e-005f,
    -4.4233824323999998e-005f,-4.5359913062999995e-005f,-4.6472035274999994e-005f,-4.7570990952000003e-005f,
    -4.8655091222000000e-005f,-4.9725147188000004e-005f,-5.0779492199999999e-005f,-5.1818937361000002e-005f,
    -5.2841816021000003e-005f,-5.3848961504999999e-005f,-5.4838707162999998e-005f,-5.5811897431000001e-005f,
    -5.6766876769999998e-005f,-5.7704511837999998e-005f,-5.8623147096000003e-005f,-5.9523649201999998e-005f,
    -6.0404395949999994e-005f,-6.1266253998000007e-005f,-6.2107601139999995e-005f,-6.2929337366999998e-005f,
    -6.3729851583999998e-005f,-6.4510054892999994e-005f,-6.5268336198999994e-005f,-6.6005628825999995e-005f,
    -6.6720332789999996e-005f,-6.7413392525999998e-005f,-6.8083241382999992e-005f,-6.8730823796000004e-005f,
    -6.9354573113999997e-005f,-6.9955478216000006e-005f,-7.0531983561999999e-005f,-7.1085066920000006e-005f,
    -7.1613206082999997e-005f,-7.2117412152000003e-005f,-7.2596151809000003e-005f,-7.3050458376999999e-005f,
    -7.3478820759999993e-005f,-7.3882294502999998e-005f,-7.4259379620999995e-005f,-7.4611142770000000e-005f,
    -7.4936117297999996e-005f,-7.5235380971999994e-005f,-7.5507467140000002e-005f,-7.5753498012999998e-005f,
    -7.5972018049999995e-005f,-7.6164160572999990e-005f,-7.6328492263000007e-005f,-7.6466168663999999e-005f,
    -7.6575767567999995e-005f,-7.6658477852000004e-005f,-7.6712888418999995e-005f,-7.6740199256999993e-005f,
    -7.6739021491000004e-005f,-7.6710599553000009e-005f,-7.6653544568000000e-005f,-7.6569100967999998e-005f,
    -7.6455935433000007e-005f,-7.6315303505999999e-005f,-7.6145871866999993e-005f,-7.5948940502999996e-005f,
    -7.5723187205000003e-005f,-7.5469923070999999e-005f,-7.5187859224999998e-005f,-7.4878340097999998e-005f,
    -7.4540065702999994e-005f,-7.4174413804000002e-005f,-7.3780106635999999e-005f,-7.3358555296000003e-005f,
    -7.2908493129999997e-005f,-7.2431331234999998e-005f,-7.1925847400999997e-005f,-7.1393486058000000e-005f,
    -7.0833024995999998e-005f,-7.0245919755999989e-005f,-6.9630981460999992e-005f,-6.8989687873999988e-005f,
    -6.8320872339999996e-005f,-6.7626045954999998e-005f,-6.6904030952999992e-005f,-6.6156360651999999e-005f,
    -6.5381901729999998e-005f,-6.4582209726999994e-005f,-6.3756151320999992e-005f,-6.2905304274000007e-005f,
    -6.2028557486000000e-005f,-6.1127522052000004e-005f,-6.0201097982999998e-005f,-5.9250896373999999e-005f,
    -5.8275861679999997e-005f,-5.7277638328999996e-005f,-5.6255148553999996e-005f,-5.5210070116000003e-005f,
    -5.4141347469999993e-005f,-5.3050691709999997e-005f,-5.1937058402000000e-005f,-5.0802147529000002e-005f,
    -4.9644970212000002e-005f,-4.8467237544999996e-005f,-4.7267949537999999e-005f,-4.6048872840000001e-005f,
    -4.4809007460999996e-005f,-4.3550131161000004e-005f,-4.2271266171999998e-005f,-4.0974212475999995e-005f,
    -3.9658003415999998e-005f,-3.8324438973999994e-005f,-3.6972596937000004e-005f,-3.5604288398000000e-005f,
    -3.4218580033000000e-005f,-3.2817327378999995e-005f,-3.1399597112000004e-005f,-2.9967255879999999e-005f,
    -2.8519392580999998e-005f,-2.7057873862999999e-005f,-2.5581821957000000e-005f,-2.4093114622000000e-005f,
    -2.2590862977999999e-005f,-2.1076989228000000e-005f,-1.9550593381000000e-005f,-1.8013608751000002e-005f,
    -1.6465157569000002e-005f,-1.4907184259999999e-005f,-1.3338822165999999e-005f,-1.1762015712000000e-005f,
    -1.0175911573200000e-005f,-8.5824663967000000e-006f,-6.9808401908999992e-006f,-5.3729929361999996e-006f,
    -3.7580924186999998e-006f,-2.1381086187000004e-006f,-5.1221398892000004e-007f,1.1176110459999999e-006f,
    2.7521891444999998e-006f,4.3895316597999996e-006f,6.0304574725999992e-006f,7.6729699362000000e-006f,
    9.3178868202000000e-006f,1.0963203700200000e-005f,1.2609729456999999e-005f,1.4255468554999999e-005f,
    1.5901229874999999e-005f,1.7544980104000000e-005f,1.9187552567000000e-005f,2.0826925062000000e-005f,
    2.2463908691999997e-005f,2.4096481255000001e-005f,2.5725453853999998e-005f,2.7348804287000000e-005f,
    2.8967354768000000e-005f,3.0579060873000000e-005f,3.2184767037999999e-005f,3.3782428838999999e-005f,
    3.5372879601000001e-005f,3.6954086011000004e-005f,3.8526881393999998e-005f,4.0089232437000001e-005f,
    4.1641972464999996e-005f,4.3183090386999998e-005f,4.4713419527999997e-005f,4.6230937686000003e-005f,
    4.7736500408000002e-005f,4.9228085491999998e-005f,5.0706537373999999e-005f,5.2169867184999998e-005f,
    5.3618919360999995e-005f,5.5051705032999998e-005f,5.6469079748000004e-005f,5.7869065747999999e-005f,
    5.9252529691000000e-005f,6.0617482707999995e-005f,6.1964835900999994e-005f,6.3292600400999998e-005f,
    6.4601676198999992e-005f,6.5890096647999995e-005f,6.7158772849999990e-005f,6.8405760379999992e-005f,
    6.9631992561999996e-005f,7.0835491638000000e-005f,7.2017235375999993e-005f,7.3175279350999991e-005f,
    7.4310579108999997e-005f,7.5421212447000010e-005f,7.6508168243999997e-005f,7.7569524296999996e-005f,
    7.8606280595999993e-005f,7.9616526049000006e-005f,8.0601305089999999e-005f,8.1558706627000004e-005f,
    8.2489797315999996e-005f,8.3392666064999993e-005f,8.4268401752000008e-005f,8.5115126617999994e-005f,
    8.5933940651999996e-005f,8.6722977205999985e-005f,8.7483358491000004e-005f,8.8213262303000003e-005f,
    8.8913788631000002e-005f,8.9583159715000000e-005f,9.0222497765999999e-005f,9.0830013913000007e-005f,
    9.1406897033000003e-005f,9.1951358254999994e-005f,9.2464608677999998e-005f,9.2944870542000001e-005f,
    9.3393388278999995e-005f,9.3808406351000002e-005f,9.4191191411999999e-005f,9.4540010145999993e-005f,
    9.4856140318000005e-005f,9.5137893056000008e-005f,9.5386546124999998e-005f,9.5600455097000008e-005f,
    9.5780919958999991e-005f,9.5926296282999995e-005f,9.6037939610999997e-005f,9.6114205514999992e-005f,
    9.6156482869999999e-005f,9.6163160581000002e-005f,9.6135638633999986e-005f,9.6072328156000011e-005f,
    9.5974673576999989e-005f,9.5841097135000001e-005f,9.5673065481999994e-005f,9.5469045300000002e-005f,
    9.5230503240999987e-005f,9.4955939319999998e-005f,9.4646864633000005e-005f,9.4301779195000003e-005f,
    9.3922238545999997e-005f,9.3506753811999999e-005f,9.3056913865999989e-005f,9.2571263166999997e-005f,
    9.2051401698999995e-005f,9.1495907253999999e-005f,9.0906402038000005e-005f,9.0281497176000007e-005f,
    8.9622837095999997e-005f,8.8929055145000005e-005f,8.8201829083999999e-005f,8.7439803370999988e-005f,
    8.6644700211000001e-005f,8.5815186284000003e-005f,8.4953006016999993e-005f,8.4056837200999996e-005f,
    8.3128457595999986e-005f,8.2166589436999995e-005f,8.1173021595000002e-005f,8.0146498527000010e-005f,
    7.9088831325999995e-005f,7.7998808892999993e-005f,7.6878242321000008e-005f,7.5725942732999993e-005f,
    7.4543776777000003e-005f,7.3330566686999996e-005f,7.2088190222000008e-005f,7.0815491837999993e-005f,
    6.9514393738000007e-005f,6.8183751488999996e-005f,6.6825520627000005e-005f,6.5438556718999994e-005f,
    6.4024848633999996e-005f,6.2583285271999999e-005f,6.1115866613000003e-005f,5.9621514889999998e-005f,
    5.8102230083000002e-005f,5.6556978869000002e-005f,5.4987783449999998e-005f,5.3393599391999998e-005f,
    5.1776504452000002e-005f,5.0135465306999996e-005f,4.8472559714000001e-005f,4.6786798794000003e-005f,
    4.5080271415000001e-005f,4.3351999809000001e-005f,4.1604106177000003e-005f,3.9835612751000006e-005f,
    3.8048675065000006e-005f,3.6242326462000001e-005f,3.4418733586999999e-005f,3.2576963115999999e-005f,
    3.0719181693999996e-005f,2.8844478218999997e-005f,2.6955030446999999e-005f,2.5049938386999998e-005f,
    2.3131424238999998e-005f,2.1198565790000001e-005f,1.9253607462000000e-005f,1.7295649263999998e-005f,
    1.5326946729000000e-005f,1.3346610977000000e-005f,1.1356897541000001e-005f,9.3569497628999996e-006f,
    7.3490253978999996e-006f,5.3322666768000002e-006f,3.3089569100999996e-006f,1.2782405508000000e-006f,
    -7.5758975735999998e-007f,-2.7993797836999998e-006f,-4.8448293289999997e-006f,-6.8947777182000000e-006f,
    -8.9469160854999998e-006f,-1.1002079978100000e-005f,-1.3057947197000000e-005f,-1.5115359955999999e-005f,
    -1.7171994945000000e-005f,-1.9228663267000001e-005f,-2.1283064944999996e-005f,-2.3335999970999999e-005f,
    -2.5385146146000001e-005f,-2.7431336794999999e-005f,-2.9472227497000000e-005f,-3.1508651577000000e-005f,
    -3.3538264613999999e-005f,-3.5561899933000001e-005f,-3.7577224224000000e-005f,-3.9585048589999999e-005f,
    -4.1583061942999996e-005f,-4.3572086497000001e-005f,-4.5549777830999995e-005f,-4.7516991491999997e-005f,
    -4.9471383058999994e-005f,-5.1413796968000001e-005f,-5.3341899908999996e-005f,-5.5256558540000005e-005f,
    -5.7155439550999992e-005f,-5.9039398488999998e-005f,-6.0906135377000004e-005f,-6.2756494650999990e-005f,
    -6.4588165223000008e-005f,-6.6402047083999994e-005f,-6.8195829145999994e-005f,-6.9970389177999989e-005f,
    -7.1723449425000000e-005f,-7.3455898766999999e-005f,-7.5165459449000007e-005f,-7.6853053683999999e-005f,
    -7.8516392605999989e-005f,-8.0156420649999990e-005f,-8.1770882282999993e-005f,-8.3360710828999992e-005f,
    -8.4923661865999995e-005f,-8.6460702050999999e-005f,-8.7969598073000003e-005f,-8.9451327699999997e-005f,
    -9.0903679842999991e-005f,-9.2327654491999997e-005f,-9.3721040557999998e-005f,-9.5084871363999997e-005f,
    -9.6416946932000009e-005f,-9.7718322807000005e-005f,-9.8986821232999997e-005f,-1.0022351997700001e-004f,
    -1.0142625239400000e-004f,-1.0259611847300000e-004f,-1.0373098490200000e-004f,-1.0483196278100000e-004f,
    -1.0589695213100000e-004f,-1.0692706405199999e-004f,-1.0792023189800000e-004f,-1.0887761121300001e-004f,
    -1.0979714646200000e-004f,-1.1068000429999999e-004f,-1.1152410696999999e-004f,-1.1233076556999999e-004f,
    -1.1309798011999999e-004f,-1.1382686171999999e-004f,-1.1451541038999999e-004f,-1.1516507055999999e-004f,
    -1.1577373114000000e-004f,-1.1634272544999999e-004f,-1.1687005350999999e-004f,-1.1735715974999999e-004f,
    -1.1780204419000000e-004f,-1.1820615125999999e-004f,-1.1856748098000000e-004f,-1.1888747778000000e-004f,
    -1.1916425278999999e-004f,-1.1939925044000001e-004f,-1.1959069297000000e-004f,-1.1974002480999999e-004f,
    -1.1984524598000000e-004f,-1.1990802313000000e-004f,-1.1992657850000000e-004f,-1.1990246762999999e-004f,
    -1.1983380165000001e-004f,-1.1972213610000001e-004f,-1.1956591543999999e-004f,-1.1936658410000000e-004f,
    -1.1912247542999999e-004f,-1.1883525608000000e-004f,-1.1850325940000000e-004f,-1.1812804092999999e-004f,
    -1.1770804512999999e-004f,-1.1724504975999999e-004f,-1.1673727706000000e-004f,-1.1618650479000000e-004f,
    -1.1559128851999999e-004f,-1.1495318379000001e-004f,-1.1427085727999999e-004f,-1.1354597563999999e-004f,
    -1.1277698332999999e-004f,-1.1196576922000000e-004f,-1.1111088888000000e-004f,-1.1021422006900000e-004f,
    -1.0927420724700000e-004f,-1.0829279483900000e-004f,-1.0726857174800001e-004f,-1.0620343795500000e-004f,
    -1.0509603791800000e-004f,-1.0394830495099999e-004f,-1.0275890573400000e-004f,-1.0152979580299999e-004f,
    -1.0025968628200001e-004f,-9.8950566039999994e-005f,-9.7601168422999996e-005f,-9.6213515632999997e-005f,
    -9.4786374348999997e-005f,-9.3321788995000000e-005f,-9.1818570693999999e-005f,-9.0278786091999998e-005f,
    -8.8701268533999999e-005f,-8.7088140221000003e-005f,-8.5438223386999996e-005f,-8.3753695788000006e-005f,
    -8.2033412991000006e-005f,-8.0279563862999988e-005f,-7.8491037303999995e-005f,-7.6670044403000004e-005f,
    -7.4815518503999997e-005f,-7.2929692917999989e-005f,-7.1011523210999999e-005f,-6.9063264916000011e-005f,
    -6.7083895821000002e-005f,-6.5075704791999999e-005f,-6.3037702949999994e-005f,-6.0972190271999997e-005f,
    -5.8878200101000000e-005f,-5.6758076857999993e-005f,-5.4610864996999999e-005f,-5.2438931160999999e-005f,
    -5.0241330915000001e-005f,-4.8020464234999994e-005f,-4.5775408907999998e-005f,-4.3508598243000004e-005f,
    -4.1219110027000002e-005f,-3.8909399790999998e-005f,-3.6578578655000003e-005f,-3.4229113260999999e-005f,
    -3.1860136950999996e-005f,-2.9474127478000001e-005f,-2.7070240405999998e-005f,-2.4650964598999999e-005f,
    -2.2215477843000001e-005f,-1.9766280112999998e-005f,-1.7302582527999997e-005f,-1.4826885063000001e-005f,
    -1.2338398836999999e-005f,-9.8396682689999991e-006f,-7.3298989224999993e-006f,-4.8116418831000001e-006f,
    -2.2841271585000001e-006f,2.5008649910999998e-007f,2.7917598598999999e-006f,5.3383232829000002e-006f,
    7.8905299828000004e-006f,1.0445798874300000e-005f,1.3004881061000000e-005f,1.5565177680000000e-005f,
    1.8127429834999999e-005f,2.0689059774000001e-005f,2.3250778601000001e-005f,2.5810008563999999e-005f,
    2.8367471877999997e-005f,3.0920557457999997e-005f,3.3470009741000002e-005f,3.6013206531000000e-005f,
    3.8550881153999994e-005f,4.1080433635999999e-005f,4.3602586191999997e-005f,4.6114727736999994e-005f,
    4.8617602707999996e-005f,5.1108588909000002e-005f,5.3588430777000004e-005f,5.6054517226999995e-005f,
    5.8507603806999999e-005f,6.0945079431999999e-005f,6.3367677427999999e-005f,6.5772831153999988e-005f,
    6.8161262825000004e-005f,7.0530416911000003e-005f,7.2881037848999999e-005f,7.5210536775999998e-005f,
    7.7519713684000001e-005f,7.9805968599000010e-005f,8.2070112624000002e-005f,8.4309568006999991e-005f,
    8.6525145851000008e-005f,8.8714290626000009e-005f,9.0877813434999999e-005f,9.3013192080999989e-005f,
    9.5121237666999999e-005f,9.7199450217999995e-005f,9.9248663058999995e-005f,1.0126636510400000e-004f,
    1.0325344523300000e-004f,1.0520740347100000e-004f,1.0712911758699999e-004f,1.0901613204999999e-004f,
    1.1086934685100000e-004f,1.1268631757000000e-004f,1.1446796642000000e-004f,1.1621183787000000e-004f,
    1.1791904301999999e-004f,1.1958691523000000e-004f,1.2121656559999999e-004f,1.2280566082000001e-004f,
    1.2435520088000001e-004f,1.2586274136000000e-004f,1.2732939336000001e-004f,1.2875271246000000e-004f,
    1.3013380975999999e-004f,1.3147046306000000e-004f,1.3276367234999999e-004f,1.3401121543000000e-004f,
    1.3521420340000001e-004f,1.3637030294999999e-004f,1.3748084739999999e-004f,1.3854339232999998e-004f,
    1.3955915995000001e-004f,1.4052615028000001e-004f,1.4144536330999998e-004f,1.4231479905999999e-004f,
    1.4313567973999998e-004f,1.4390567204000001e-004f,1.4462633150000000e-004f,1.4529554703000000e-004f,
    1.4591442973000001e-004f,1.4648109072999999e-004f,1.4699686334999998e-004f,1.4745963649999999e-004f,
    1.4787085460999999e-004f,1.4822862881000001e-004f,1.4853429242000000e-004f,1.4878584546000002e-004f,
    1.4898484346999999e-004f,1.4912928647000000e-004f,1.4922084110999999e-004f,1.4925750741000000e-004f,
    1.4924084091000000e-004f,1.4916895273999999e-004f,1.4904350955000000e-004f,1.4886273357999998e-004f,
    1.4862818037000001e-004f,1.4833807216000001e-004f,1.4799407560000001e-004f,1.4759463515000000e-004f,
    1.4714119524000000e-004f,1.4663220032999999e-004f,1.4606942818000000e-004f,1.4545121214000001e-004f,
    1.4477932996999999e-004f,1.4405211501999999e-004f,1.4327145616000001e-004f,1.4243579784999999e-004f,
    1.4154691785000001e-004f,1.4060348283999999e-004f,1.3960715946999998e-004f,1.3855661441999998e-004f,
    1.3745373655999998e-004f,1.3629719257000000e-004f,1.3508876020999999e-004f,1.3382710616000000e-004f,
    1.3251445261999999e-004f,1.3114913293999999e-004f,1.2973336932000000e-004f,1.2826593955000000e-004f,
    1.2674873249999999e-004f,1.2518052595999999e-004f,1.2356354213000000e-004f,1.2189644768999999e-004f,
    1.2018157594999999e-004f,1.1841748248000001e-004f,1.1660650059000000e-004f,1.1474751917999999e-004f,
    1.1284264934000000e-004f,1.1089086885800001e-004f,1.0889443326699999e-004f,1.0685225368900000e-004f,
    1.0476665232300000e-004f,1.0263655140199999e-004f,1.0046432868000000e-004f,9.8248961944999999e-005f,
    9.5992817839999999e-005f,9.3694940818999991e-005f,9.1357730858000001e-005f,8.8980232410999996e-005f,
    8.6564923230999998e-005f,8.4110869993999997e-005f,8.1620550453000002e-005f,7.9093086838999990e-005f,
    7.6531001349000003e-005f,7.3933416213999991e-005f,7.1302898075000003e-005f,6.8638613606999998e-005f,
    6.5943140562000003e-005f,6.3215667836999999e-005f,6.0458795405999999e-005f,5.7671767720999997e-005f,
    5.4857206977999999e-005f,5.2014368740000001e-005f,4.9145908536000005e-005f,4.6251093039999995e-005f,
    4.3332600003000000e-005f,4.0389751654000004e-005f,3.7425225743999999e-005f,3.4438366724000001e-005f,
    3.1431874567000001e-005f,2.8405115946000000e-005f,2.5360813055999999e-005f,2.2298343680999999e-005f,
    1.9220463348999999e-005f,1.6126549844000000e-005f,1.3019392027000001e-005f,9.8983743485999997e-006f,
    6.7662990029999998e-006f,3.6225771072000001e-006f,4.7001307759999997e-007f,-2.6919619689999998e-006f,
    -5.8605336163000005e-006f,-9.0362585253999990e-006f,-1.2216311168999999e-005f,-1.5401234875000000e-005f,
    -1.8588203004999999e-005f,-2.1777737776000000e-005f,-2.4967016994000001e-005f,-2.8156562876000000e-005f,
    -3.1343519895000004e-005f,-3.4528410267999998e-005f,-3.7708400689999998e-005f,-4.0883991156000002e-005f,
    -4.4052337250000005e-005f,-4.7213961188999999e-005f,-5.0366007445999999e-005f,-5.3508976015999998e-005f,
    -5.6640033593999998e-005f,-5.9759680175000004e-005f,-6.2865082453999996e-005f,-6.5956751537000008e-005f,
    -6.9031831897000000e-005f,-7.2090867972999988e-005f,-7.5131004238000002e-005f,-7.8152785131000002e-005f,
    -8.1153355124999991e-005f,-8.4133280880999993e-005f,-8.7089717983000005e-005f,-9.0023221981000003e-005f,
    -9.2930970680999995e-005f,-9.5813552966000001e-005f,-9.8668135530999995e-005f,-1.0149530725900000e-004f,
    -1.0429227928899999e-004f,-1.0705965161500000e-004f,-1.0979463537600000e-004f,-1.1249787500999999e-004f,
    -1.1516651498999999e-004f,-1.1780126642000000e-004f,-1.2039946266000000e-004f,-1.2296165925999999e-004f,
    -1.2548507847000000e-004f,-1.2797049805999999e-004f,-1.3041514028000001e-004f,-1.3281978289999999e-004f,
    -1.3518164816999999e-004f,-1.3750162496999998e-004f,-1.3977693555000000e-004f,-1.4200824656999999e-004f,
    -1.4419311361000000e-004f,-1.4633231443999999e-004f,-1.4842307130999999e-004f,-1.5046638421000000e-004f,
    -1.5245958649999999e-004f,-1.5440345595000001e-004f,-1.5629565925000000e-004f,-1.5813686306000000e-004f,
    -1.5992462296000000e-004f,-1.6165993893999997e-004f,-1.6334025546999999e-004f,-1.6496646143000001e-004f,
    -1.6653622351000001e-004f,-1.6805054170000001e-004f,-1.6950686046999998e-004f,-1.7090640203000000e-004f,
    -1.7224661084999998e-004f,-1.7352870914000000e-004f,-1.7475025248000001e-004f,-1.7591235196999999e-004f,
    -1.7701278541000000e-004f,-1.7805255279000000e-004f,-1.7902965412999999e-004f,-1.7994508941999998e-004f,
    -1.8079663645999999e-004f,-1.8158562856999998e-004f,-1.8230984355000000e-004f,-1.8297050361000002e-004f,
    -1.8356560876999999e-004f,-1.8409649234999998e-004f,-1.8456093214999999e-004f,-1.8496037259999997e-004f,
    -1.8529270260999998e-004f,-1.8555947772000000e-004f,-1.8575858683999999e-004f,-1.8589158550999998e-004f,
    -1.8595647375000001e-004f,-1.8595469599000001e-004f,-1.8588458558000000e-004f,-1.8574747583999999e-004f,
    -1.8554158900999999e-004f,-1.8526848063000001e-004f,-1.8492648405000000e-004f,-1.8451715481000001e-004f,
    -1.8403882625999998e-004f,-1.8349305394000000e-004f,-1.8287828231000001e-004f,-1.8219617802000000e-004f,
    -1.8144518553000000e-004f,-1.8062697148999999e-004f,-1.7974009146999999e-004f,-1.7878621212000001e-004f,
    -1.7776400011999997e-004f,-1.7667523322999998e-004f,-1.7551835591000001e-004f,-1.7429547924999999e-004f,
    -1.7300504771000001e-004f,-1.7164895016000002e-004f,-1.7022607550000002e-004f,-1.6873831260000001e-004f,
    -1.6718421702999997e-004f,-1.6556601099000000e-004f,-1.6388247227000000e-004f,-1.6213560085000001e-004f,
    -1.6032417452000001e-004f,-1.5845041548000002e-004f,-1.5651310152000000e-004f,-1.5451445483999999e-004f,
    -1.5245347544999999e-004f,-1.5033227444000001e-004f,-1.4814985181999999e-004f,-1.4590854089999999e-004f,
    -1.4360723057999999e-004f,-1.4124825417000000e-004f,-1.3883072279000000e-004f,-1.3635708086000002e-004f,
    -1.3382621728000001e-004f,-1.3124068757999999e-004f,-1.2859971398999998e-004f,-1.2590551871000000e-004f,
    -1.2315754619000001e-004f,-1.2035812974000000e-004f,-1.1750649159000000e-004f,-1.1460518726999999e-004f,
    -1.1165355011999999e-004f,-1.0865420233599999e-004f,-1.0560634392600000e-004f,-1.0251265264100000e-004f,
    -9.9372450709999999e-005f,-9.6188438106000000e-005f,-9.2959970391000006e-005f,-8.9689769760000005e-005f,
    -8.6377247330000003e-005f,-8.3025158628999990e-005f,-7.9632936995999994e-005f,-7.6203382403000001e-005f,
    -7.2735972632999993e-005f,-6.9233518768999999e-005f,-6.5695543037999998e-005f,-6.2124900966999998e-005f,
    -5.8521114783000004e-005f,-5.4887095567999998e-005f,-5.1222398881999999e-005f,-4.7529924695999999e-005f,
    -4.3809306347000000e-005f,-4.0063454917000004e-005f,-3.6292014853999999e-005f,-3.2497941684000001e-005f,
    -2.8680879854999998e-005f,-2.4843829337000000e-005f,-2.0986467911000001e-005f,-1.7111784436000002e-005f,
    -1.3219501136999999e-005f,-9.3126257616999984e-006f,-5.3908838684000001e-006f,-1.4573154266999999e-006f,
    2.4883395607999996e-006f,6.4430255690999997e-006f,1.0406987040199999e-005f,1.4377156227000000e-005f,
    1.8353760905000000e-005f,2.2333721104999997e-005f,2.6317259046999999e-005f,3.0301285872999999e-005f,
    3.4285990469999998e-005f,3.8268306202000001e-005f,4.2248410844999995e-005f,4.6223204429999995e-005f,
    5.0192886955000002e-005f,5.4154358450999999e-005f,5.8107785583000003e-005f,6.2050090604000001e-005f,
    6.5981440178999997e-005f,6.9898734338999996e-005f,7.3802161970999990e-005f,7.7688623106000003e-005f,
    8.1558295519999999e-005f,8.5408101465999996e-005f,8.9238218719999999e-005f,9.3045569535000000e-005f,
    9.6830342797999994e-005f,1.0058946076200000e-004f,1.0432314564699999e-004f,1.0802830859499999e-004f,
    1.1170521626999998e-004f,1.1535073537000000e-004f,1.1896514366999999e-004f,1.2254533009000001e-004f,
    1.2609173906999999e-004f,1.2960114842000000e-004f,1.3307389147000000e-004f,1.3650707936000000e-004f,
    1.3990071208999999e-004f,1.4325212302000002e-004f,1.4656142326000001e-004f,1.4982572394999999e-004f,
    1.5304535842000001e-004f,1.5621743780999998e-004f,1.5934218434000000e-004f,1.6241682025999998e-004f,
    1.6544167890000000e-004f,1.6841387140000000e-004f,1.7133384220000000e-004f,1.7419870243999999e-004f,
    1.7700900767000000e-004f,1.7976186903000000e-004f,1.8245773096000001e-004f,1.8509392681999998e-004f,
    1.8767078994000002e-004f,1.9018587589999999e-004f,1.9263951802999998e-004f,1.9502904969000002e-004f,
    1.9735502643000000e-004f,1.9961489271999998e-004f,2.0180920410999998e-004f,2.0393551617999998e-004f,
    2.0599427336999998e-004f,2.0798292015000001e-004f,2.0990234539999998e-004f,2.1174999359000000e-004f,
    2.1352653137999999e-004f,2.1522951434999998e-004f,2.1685972026999999e-004f,2.1841481582999999e-004f,
    2.1989557879999999e-004f,2.2129978697999999e-004f,2.2262810703000001e-004f,2.2387842785999998e-004f,
    2.2505152723999999e-004f,2.2614529407999999e-004f,2.2716061725999999e-004f,2.2809538569000000e-004f,
    2.2895059936000001e-004f,2.2972414718000001e-004f,2.3041714024999999e-004f,2.3102735636999999e-004f,
    2.3155612885999999e-004f,2.3200134662999998e-004f,2.3236434300000000e-004f,2.3264289577000000e-004f,
    2.3283856048000000e-004f,2.3294911493000001e-004f,2.3297622577000000e-004f,2.3291778191000001e-004f,
    2.3277533888999997e-004f,2.3254700783999999e-004f,2.3223434430000000e-004f,2.3183545940000001e-004f,
    2.3135201979000001e-004f,2.3078224770999999e-004f,2.3012780980999998e-004f,2.2938703943999999e-004f,
    2.2856149213999999e-004f,2.2764983458999999e-004f,2.2665362233000001e-004f,2.2557129982000000e-004f,
    2.2440475593000001e-004f,2.2315254622999999e-004f,2.2181644848000000e-004f,2.2039524047000000e-004f,
    2.1889058885000000e-004f,2.1730138252000001e-004f,2.1562939923999998e-004f,2.1387363902000000e-004f,
    2.1203587962000001e-004f,2.1011500993999997e-004f,2.0811314106999998e-004f,2.0602927301999999e-004f,
    2.0386529466000000e-004f,2.0162031711000000e-004f,1.9929656257000001e-004f,1.9689291993999999e-004f,
    1.9441172253000002e-004f,1.9185208145999999e-004f,1.8921621893000000e-004f,1.8650335716999998e-004f,
    1.8371571838000000e-004f,1.8085263589999998e-004f,1.7791655415000000e-004f,1.7490669535999998e-004f,
    1.7182550395000002e-004f,1.6867231326000000e-004f,1.6544956771000002e-004f,1.6215693397000000e-004f,
    1.5879663423999999e-004f,1.5536844629999999e-004f,1.5187470346000000e-004f,1.4831518349999999e-004f,
    1.4469233083999998e-004f,1.4100581214999998e-004f,1.3725840518000000e-004f,1.3344966549000000e-004f,
    1.2958237083000000e-004f,1.2565618787000000e-004f,1.2167389436000000e-004f,1.1763537919000000e-004f,
    1.1354330899999999e-004f,1.0939753934700000e-004f,1.0520100353500000e-004f,1.0095349045500000e-004f,
    9.6657955632999999e-005f,9.2314276847999994e-005f,8.7925431847999996e-005f,8.3491342856000010e-005f,
    7.9015032064000003e-005f,7.4496443917000001e-005f,6.9938667273000004e-005f,6.5341668798999996e-005f,
    6.0708581796999997e-005f,5.6039406266999998e-005f,5.1337297733000004e-005f,4.6602300639000001e-005f,
    4.1837614953000000e-005f,3.7043307340999998e-005f,3.2222599992999997e-005f,2.7375604019000000e-005f,
    2.2505552720000000e-005f,1.7612601650000000e-005f,1.2699995221000000e-005f,7.7679289865999997e-006f,
    2.8196684697000000e-006f,-2.1445829984000000e-006f,-7.1215232284999996e-006f,-1.2110934445000000e-005f,
    -1.7109484459000001e-005f,-2.2116956606000003e-005f,-2.7129995364000001e-005f,-3.2148345179999998e-005f,
    -3.7168672753999997e-005f,-4.2190700311000001e-005f,-4.7211072329000000e-005f,-5.2229499922000001e-005f,
    -5.7242616456999995e-005f,-6.2250133047999994e-005f,-6.7248671951000000e-005f,-7.2237944279999997e-005f,
    -7.7214583401999991e-005f,-8.2178267098000006e-005f,-8.7125639845999999e-005f,-9.2056379426999992e-005f,
    -9.6967141430000003e-005f,-1.0185759252500000e-004f,-1.0672438830100000e-004f,-1.1156721765000000e-004f,
    -1.1638272504999999e-004f,-1.2117067717000000e-004f,-1.2592762960000000e-004f,-1.3065324900999998e-004f,
    -1.3534442432000000e-004f,-1.4000071108999999e-004f,-1.4461877602000000e-004f,-1.4919850799999999e-004f,
    -1.5373657373000000e-004f,-1.5823252876999999e-004f,-1.6268337315000000e-004f,-1.6708866242999998e-004f,
    -1.7144539663999997e-004f,-1.7575313133999997e-004f,-1.8000875545000000e-004f,-1.8421204675000001e-004f,
    -1.8835978304999998e-004f,-1.9245196435000001e-004f,-1.9648536845999999e-004f,-2.0045977316000000e-004f,
    -2.0437217847999999e-004f,-2.0822247331000001e-004f,-2.1200754656999998e-004f,-2.1572728714999999e-004f,
    -2.1937869508000001e-004f,-2.2296177036000000e-004f,-2.2647351301999997e-004f,-2.2991403417000001e-004f,
    -2.3328011161999999e-004f,-2.3657207869999999e-004f,-2.3978693544000001e-004f,-2.4292468183999998e-004f,
    -2.4598265125999998e-004f,-2.4896084370000000e-004f,-2.5185648140999998e-004f,-2.5466989772000002e-004f,
    -2.5739809266000000e-004f,-2.6004151067000002e-004f,-2.6259737400000002e-004f,-2.6506612708999998e-004f,
    -2.6744488108000001e-004f,-2.6973419151999999e-004f,-2.7193139176999995e-004f,-2.7403692627000001e-004f,
    -2.7604835059999997e-004f,-2.7796599809000000e-004f,-2.7978753543000002e-004f,-2.8151340705999996e-004f,
    -2.8314127966999999e-004f,-2.8467170880999996e-004f,-2.8610236116999999e-004f,-2.8743401451999999e-004f,
    -2.8866444666000000e-004f,-2.8979410202999997e-004f,-2.9082109176000002e-004f,-2.9174608250999998e-004f,
    -2.9256696319000000e-004f,-2.9328462268000000e-004f,-2.9389694988999997e-004f,-2.9440505592000005e-004f,
    -2.9480682967999999e-004f,-2.9510327116000001e-004f,-2.9529260260000001e-004f,-2.9537582399000005e-004f,
    -2.9535115756999997e-004f,-2.9521971443999999e-004f,-2.9497971683999997e-004f,-2.9463249808999998e-004f,
    -2.9417639153999996e-004f,-2.9361261939999999e-004f,-2.9293962612999999e-004f,-2.9215885615999998e-004f,
    -2.9126875395000000e-004f,-2.9027076393000001e-004f,-2.8916344166999999e-004f,-2.8794845381999997e-004f,
    -2.8662424483999997e-004f,-2.8519259248999996e-004f,-2.8365227456000002e-004f,-2.8200473547999996e-004f,
    -2.8024897526000001e-004f,-2.7838677165999999e-004f,-2.7641701357999996e-004f,-2.7434147878000002e-004f,
    -2.7215916727000000e-004f,-2.6987196791999999e-004f,-2.6747899185000000e-004f,-2.6498235015000001e-004f,
    -2.6238093172000003e-004f,-2.5967695875999997e-004f,-2.5686965350000000e-004f,-2.5396112702999999e-004f,
    -2.5095071269000001e-004f,-2.4784052157000001e-004f,-2.4463010923000001e-004f,-2.4132180897999998e-004f,
    -2.3791484304999999e-004f,-2.3441165585999998e-004f,-2.3081191407999999e-004f,-2.2711806212999999e-004f,
    -2.2332954445999998e-004f,-2.1944891659999999e-004f,-2.1547606744000002e-004f,-2.1141333029000000e-004f,
    -2.0726070515000001e-004f,-2.0302063644000000e-004f,-1.9869312416000002e-004f,-1.9428072384000000e-004f,
    -1.8978354659000000e-004f,-1.8520425905000000e-004f,-1.8054286122000000e-004f,-1.7580213084999999e-004f,
    -1.7098229016000000e-004f,-1.6608622801000001e-004f,-1.6111394440000002e-004f,-1.5606855040999998e-004f,
    -1.5095015714999997e-004f,-1.4576176458999999e-004f,-1.4050381716999998e-004f,-1.3517909264000000e-004f,
    -1.2978825766000001e-004f,-1.2433420108999999e-004f,-1.1881736737000001e-004f,-1.1324108979999999e-004f,
    -1.0760557948900000e-004f,-1.0191425862500000e-004f,-9.6167560536999998e-005f,-9.0368796302999993e-005f,
    -8.4518499251000004e-005f,-7.8620024902999994e-005f,-7.2673962141999997e-005f,-6.6683710933999996e-005f,
    -6.0649904605999999e-005f,-5.4575998679000003e-005f,-4.8462637591000000e-005f,-4.2313343528999998e-005f,
    -3.6128805375000004e-005f,-2.9912556427000000e-005f,-2.3665352232999998e-005f,-1.7390748313000000e-005f,
    -1.1089536881299998e-005f,-4.7653023464999999e-006f,1.5811286330000000e-006f,7.9461416489000000e-006f,
    1.4328878931999999e-005f,2.0725703852000001e-005f,2.7135728639999997e-005f,3.3555297776999998e-005f,
    3.9983500160999998e-005f,4.6416646940000002e-005f,5.2853827011999996e-005f,5.9291340414000000e-005f,
    6.5728220489000001e-005f,7.2160789495999989e-005f,7.8588058556000001e-005f,8.5006327705999997e-005f,
    9.1414608067000007e-005f,9.7809199676000003e-005f,1.0418910254300000e-004f,1.1055059448299999e-004f,
    1.1689271995000000e-004f,1.2321165675999998e-004f,1.2950648270000000e-004f,1.3577353113999999e-004f,
    1.4201180209000002e-004f,1.4821751781000000e-004f,1.5438967830999999e-004f,1.6052461696000001e-004f,
    1.6662133376999999e-004f,1.7267627321999998e-004f,1.7868832420999997e-004f,1.8465393121999999e-004f,
    1.9057209426000000e-004f,1.9643903558999999e-004f,2.0225408855000001e-004f,2.0801336429000000e-004f,
    2.1371619615000002e-004f,2.1935880639000000e-004f,2.2494052834999998e-004f,2.3045747317999998e-004f,
    2.3590908532999998e-004f,2.4129169816999998e-004f,2.4660453393000002e-004f,2.5184403709000000e-004f,
    2.5700954098999997e-004f,2.6209749010999998e-004f,2.6710710668000000e-004f,2.7203516851000001e-004f,
    2.7688078671999998e-004f,2.8164073912000001e-004f,2.8631424793999999e-004f,2.9089809098999998e-004f,
    2.9539171272000003e-004f,2.9979166871999999e-004f,3.0409762565999996e-004f,3.0830613913000000e-004f,
    3.1241698691000000e-004f,3.1642683570000000e-004f,3.2033524106000002e-004f,3.2413920301999999e-004f,
    3.2783838824999997e-004f,3.3142968567000000e-004f,3.3491276194999998e-004f,3.3828483934000001e-004f,
    3.4154547339999998e-004f,3.4469188637999999e-004f,3.4772385605999999e-004f,3.5063860469000002e-004f,
    3.5343613226999996e-004f,3.5611343882999998e-004f,3.5867085770000001e-004f,3.6110538890999998e-004f,
    3.6341736579000001e-004f,3.6560401058999996e-004f,3.6766554553000001e-004f,3.6959941508000002e-004f,
    3.7140595256999998e-004f,3.7308271358000000e-004f,3.7462992033000000e-004f,3.7604535061999997e-004f,
    3.7732933777999997e-004f,3.7847965960999995e-004f,3.7949676054999999e-004f,3.8037852950999998e-004f,
    3.8112552203999999e-004f,3.8173573815999999e-004f,3.8220973342000002e-004f,3.8254561894999995e-004f,
    3.8274417251999999e-004f,3.8280350525999999e-004f,3.8272439494000001e-004f,3.8250517491000000e-004f,
    3.8214662293999997e-004f,3.8164740570999998e-004f,3.8100818987999997e-004f,3.8022764212999996e-004f,
    3.7930676244999999e-004f,3.7824421751999997e-004f,3.7704111843999999e-004f,3.7569613188999997e-004f,
    3.7421059118999999e-004f,3.7258338524000001e-004f,3.7081573624999996e-004f,3.6890653311999998e-004f,
    3.6685733139000002e-004f,3.6466724218000001e-004f,3.6233759880999997e-004f,3.5986762351000002e-004f,
    3.5725898293000003e-004f,3.5451089930000002e-004f,3.5162526149000000e-004f,3.4860118062000000e-004f,
    3.4544054555999998e-004f,3.4214291187000001e-004f,3.3871027952999999e-004f,3.3514198188000000e-004f,
    3.3144024111999995e-004f,3.2760472392000001e-004f,3.2363743026000004e-004f,3.1953824902999998e-004f,
    3.1530940242999997e-004f,3.1095066824000001e-004f,3.0646449087999995e-004f,3.0185087034999996e-004f,
    2.9711202885000001e-004f,2.9224829970999998e-004f,2.8726201624000000e-004f,2.8215351176999996e-004f,
    2.7692523071999999e-004f,2.7157761752999996e-004f,2.6611322773000001e-004f,2.6053250575999997e-004f,
    2.5483834048000000e-004f,2.4903106522000001e-004f,2.4311367994999999e-004f,2.3708651799999998e-004f,
    2.3095291267000002e-004f,2.2471319728999999e-004f,2.1837070516000001e-004f,2.1192599183000001e-004f,
    2.0538227949000001e-004f,1.9874034591000001e-004f,1.9200341328000001e-004f,1.8517248159000000e-004f,
    1.7825088413999998e-004f,1.7123950980999999e-004f,1.6414180300999999e-004f,1.5695876372999999e-004f,
    1.4969394748999998e-004f,1.4234857649999999e-004f,1.3492598406000000e-004f,1.2742761460000001e-004f,
    1.1985691252999999e-004f,1.1221521116999999e-004f,1.0450628826000000e-004f,9.6731388232000007e-005f,
    8.8894299936999994e-005f,8.0996434471999998e-005f,7.3041625131999992e-005f,6.5031327458000001e-005f,
    5.6969419189000002e-005f,4.8857444754000003e-005f,4.0699326335999996e-005f,3.2496652808000001e-005f,
    2.4253413018999999e-005f,1.5971229175000002e-005f,7.6541267913000000e-006f,-6.9619059357999996e-007f,
    -9.0756647979999989e-006f,-1.7482558505999999e-005f,-2.5912774203000000e-005f,-3.4364523017999995e-005f,
    -4.2833671659000005e-005f,-5.1318409032999995e-005f,-5.9814568515000004e-005f,-6.8320294567999993e-005f,
    -7.6831387233999989e-005f,-8.5345990975999993e-005f,-9.3859861392000003e-005f,-1.0237112072300001e-004f,
    -1.1087551345599999e-004f,-1.1937113961000000e-004f,-1.2785372144999998e-004f,-1.3632130344000000e-004f,
    -1.4476966340000000e-004f,-1.5319691246000000e-004f,-1.6159860622000000e-004f,-1.6997296692000002e-004f,
    -1.7831555015999998e-004f,-1.8662457818000001e-004f,-1.9489560658000001e-004f,-2.0312685760000000e-004f,
    -2.1131388684000001e-004f,-2.1945491653999999e-004f,-2.2754550229999999e-004f,-2.3558386636000000e-004f,
    -2.4356567542999999e-004f,-2.5148904064000002e-004f,-2.5934973981000002e-004f,-2.6714588406999998e-004f,
    -2.7487325124000002e-004f,-2.8252995245000000e-004f,-2.9011176552000000e-004f,-2.9761702379999997e-004f,
    -3.0504139399999998e-004f,-3.1238309836000000e-004f,-3.1963813691999999e-004f,-3.2680462081000002e-004f,
    -3.3387855006999998e-004f,-3.4085814693999997e-004f,-3.4773941145999998e-004f,-3.5452067697999999e-004f,
    -3.6119794353999999e-004f,-3.6776954448999996e-004f,-3.7423159098000001e-004f,-3.8058252746999999e-004f,
    -3.8681857621999997e-004f,-3.9293807058000003e-004f,-3.9893723280999999e-004f,-4.0481461847999999e-004f,
    -4.1056656095999998e-004f,-4.1619150470999998e-004f,-4.2168611642999997e-004f,-4.2704872947000000e-004f,
    -4.3227589941999999e-004f,-4.3736640407000002e-004f,-4.4231679900999998e-004f,-4.4712575091999999e-004f,
    -4.5178992649999995e-004f,-4.5630832576000003e-004f,-4.6067739318000000e-004f,-4.6489635098999999e-004f,
    -4.6896197699999994e-004f,-4.7287316010999998e-004f,-4.7662690035000003e-004f,-4.8022230884000000e-004f,
    -4.8365638560999999e-004f,-4.8692846400000001e-004f,-4.9003543293000000e-004f,-4.9297684795999996e-004f,
    -4.9574982023000000e-004f,-4.9835368308000000e-004f,-5.0078599209000001e-004f,-5.0304608060000003e-004f,
    -5.0513139308000000e-004f,-5.0704170731000003e-004f,-5.0877457887000003e-004f,-5.1032956332000003e-004f,
    -5.1170443846000006e-004f,-5.1289920428999999e-004f,-5.1391141638999999e-004f,-5.1474118586999993e-004f,
    -5.1538651274999996e-004f,-5.1584728591999997e-004f,-5.1612172761999998e-004f,-5.1620994895999999e-004f,
    -5.1611017218000004e-004f,-5.1582261950000000e-004f,-5.1534584649000001e-004f,-5.1468007536999995e-004f,
    -5.1382386170999996e-004f,-5.1277787217000003e-004f,-5.1154044009999995e-004f,-5.1011245438000005e-004f,
    -5.0849258169000002e-004f,-5.0668159979999996e-004f,-5.0467850871999999e-004f,-5.0248419732999998e-004f,
    -5.0009755453000006e-004f,-4.9751980253000001e-004f,-4.9475005244999993e-004f,-4.9178952650000003e-004f,
    -4.8863744690999999e-004f,-4.8529525810999996e-004f,-4.8176229344000000e-004f,-4.7803999733000003e-004f,
    -4.7412814755999996e-004f,-4.7002818855999996e-004f,-4.6573978700000001e-004f,-4.6126483175000000e-004f,
    -4.5660310059000001e-004f,-4.5175648239000000e-004f,-4.4672497714999998e-004f,-4.4151069596000002e-004f,
    -4.3611352771000001e-004f,-4.3053580571000003e-004f,-4.2477775218000002e-004f,-4.1884170042999995e-004f,
    -4.1272798378999998e-004f,-4.0643915779000001e-004f,-3.9997555575999998e-004f,-3.9333995545000002e-004f,
    -3.8653280130000002e-004f,-3.7955698216999998e-004f,-3.7241327582999999e-004f,-3.6510446003000003e-004f,
    -3.5763153475999997e-004f,-3.4999738887999998e-004f,-3.4220313349000000e-004f,-3.3425187966999996e-004f,
    -3.2614473852000004e-004f,-3.1788504333999995e-004f,-3.0947401634000000e-004f,-3.0091510192999999e-004f,
    -2.9220963343000000e-004f,-2.8336116635999998e-004f,-2.7437125626000002e-004f,-2.6524345865000000e-004f,
    -2.5597944017999996e-004f,-2.4658297859000001e-004f,-2.3705596274999999e-004f,-2.2740194818000000e-004f,
    -2.1762315707999998e-004f,-2.0772325608000000e-004f,-1.9770446737999998e-004f,-1.8757079094000001e-004f,
    -1.7732433785000001e-004f,-1.6696933029000001e-004f,-1.5650787935000000e-004f,-1.4594431831999998e-004f,
    -1.3528098050999998e-004f,-1.2452219920999999e-004f,-1.1367052994999999e-004f,-1.0273021713199999e-004f,
    -9.1703971839999994e-005f,-8.0596238474000000e-005f,-6.9409694784999999e-005f,-5.8148918505000004e-005f,
    -4.6816665161999997e-005f,-3.5417590265000001e-005f,-2.3954538229999999e-005f,-1.2432231232000001e-005f,
    -8.5361224157000003e-007f,1.0776536678000000e-005f,2.2455208779000000e-005f,3.4177547109999999e-005f,
    4.5940473923999996e-005f,5.7739067048000002e-005f,6.9570193179999991e-005f,8.1428874591999998e-005f,
    9.3311911316000000e-005f,1.0521428117999999e-004f,1.1713271755000000e-004f,1.2906215380999999e-004f,
    1.4099925666000000e-004f,1.5293902615000002e-004f,1.6487801787000000e-004f,1.7681100965000001e-004f,
    1.8873477929999999e-004f,2.0064399354000000e-004f,2.1253543017999999e-004f,2.2440375594000000e-004f,
    2.3624541529999998e-004f,2.4805540830999997e-004f,2.5983006834000001e-004f,2.7156439543999999e-004f,
    2.8325472298000001e-004f,2.9489582879000000e-004f,3.0648415734999999e-004f,3.1801470870999996e-004f,
    3.2948370513000001e-004f,3.4088603555000000e-004f,3.5221825555999998e-004f,3.6347503188000004e-004f,
    3.7465292009999999e-004f,3.8574680915999998e-004f,3.9675303243000000e-004f,4.0766647884999996e-004f,
    4.1848370400999997e-004f,4.2919959685000004e-004f,4.3981060185000002e-004f,4.5031171905999997e-004f,
    4.6069939296000000e-004f,4.7096873470999997e-004f,4.8111629989999998e-004f,4.9113697747000000e-004f,
    5.0102754523000006e-004f,5.1078289212000004e-004f,5.2039990705999998e-004f,5.2987359010000005e-004f,
    5.3920071904999998e-004f,5.4837651617999994e-004f,5.5739764819000000e-004f,5.6625944845999998e-004f,
    5.7495880591000006e-004f,5.8349105391999998e-004f,5.9185308140999998e-004f,6.0004033287000005e-004f,
    6.0804980832999999e-004f,6.1587706338999998e-004f,6.2351920918999996e-004f,6.3097169021999989e-004f,
    6.3823195095000001e-004f,6.4529554697999997e-004f,6.5215970056000001e-004f,6.5882030061999999e-004f,
    6.6527479163000004e-004f,6.7151895141000001e-004f,6.7755044665000004e-004f,6.8336516627999998e-004f,
    6.8896077698999997e-004f,6.9433350103999996e-004f,6.9948089400999997e-004f,7.0439940037999996e-004f,
    7.0908679795000007e-004f,7.1353953120000002e-004f,7.1775560015000005e-004f,7.2173144928000001e-004f,
    7.2546530083000002e-004f,7.2895382149999993e-004f,7.3219523352999996e-004f,7.3518642584000007e-004f,
    7.3792573177999994e-004f,7.4041015138000005e-004f,7.4263824021000000e-004f,7.4460710940999993e-004f,
    7.4631553676999998e-004f,7.4776085565000005e-004f,7.4894173272999998e-004f,7.4985572358999999e-004f,
    7.5050182824000001e-004f,7.5087782448000006e-004f,7.5098260120999994e-004f,7.5081426955999990e-004f,
    7.5037194065000006e-004f,7.4965361450000001e-004f,7.4865895778000009e-004f,7.4738597050999999e-004f,
    7.4583443046999994e-004f,7.4400267100999996e-004f,7.4189046990999995e-004f,7.3949638273999993e-004f,
    7.3682052061000000e-004f,7.3386155019999997e-004f,7.3061958261999994e-004f,7.2709372899000004e-004f,
    7.2328421153000004e-004f,7.1919014135999996e-004f,7.1481218514000001e-004f,7.1014967620999998e-004f,
    7.0520328122999996e-004f,6.9997244464999997e-004f,6.9445827756999998e-004f,6.8866033554999991e-004f,
    6.8257984080000004e-004f,6.7621668220999996e-004f,6.6957230421000008e-004f,6.6264648458000007e-004f,
    6.5544111219000001e-004f,6.4795629815000001e-004f,6.4019370910999994e-004f,6.3215401173000001e-004f,
    6.2383909487999996e-004f,6.1524951411000002e-004f,6.0638749162000003e-004f,5.9725391628999999e-004f,
    5.8785123253999997e-004f,5.7818021813999996e-004f,5.6824376194999991e-004f,5.5804286395999992e-004f,
    5.4758052413999994e-004f,5.3685796469999996e-004f,5.2587818561000005e-004f,5.1464296462999995e-004f,
    5.0315541283999995e-004f,4.9141730799999992e-004f,4.7943198340999997e-004f,4.6720155016000001e-004f,
    4.5472956376999999e-004f,4.4201824643999999e-004f,4.2907137590999996e-004f,4.1589128549000001e-004f,
    4.0248186403000000e-004f,3.8884588927999997e-004f,3.7498747231000000e-004f,3.6090927975999997e-004f,
    3.4661564491999999e-004f,3.3210956776000001e-004f,3.1739571490000003e-004f,3.0247697520000000e-004f,
    2.8735823750000001e-004f,2.7204272399000001e-004f,2.5653532350999999e-004f,2.4083959157999998e-004f,
    2.2496052814999999e-004f,2.0890191095999998e-004f,1.9266873995999999e-004f,1.7626501511000000e-004f,
    1.5969618080000000e-004f,1.4296612587999999e-004f,1.2608029474000000e-004f,1.0904315400200000e-004f,
    9.1860181389000003e-005f,7.4535810190000000e-005f,5.7075807013999997e-005f,3.9484760703999998e-005f,
    2.1768582312000000e-005f,3.9319829019999998e-006f,-1.4018970919999999e-005f,-3.2079434757999996e-005f,
    -5.0243186451999998e-005f,-6.8505237162999995e-005f,-8.6859264731999996e-005f,-1.0530012476599999e-004f,
    -1.2382142844000001e-004f,-1.4241779803000001e-004f,-1.6108272248999998e-004f,-1.7981075742999999e-004f,
    -1.9859534736000001e-004f,-2.1743082566999999e-004f,-2.3631063686999998e-004f,-2.5522889213000000e-004f,
    -2.7417892485000000e-004f,-2.9315484620000000e-004f,-3.1214976736000004e-004f,-3.3115791061000000e-004f,
    -3.5017205379999999e-004f,-3.6918641921000002e-004f,-3.8819389579999999e-004f,-4.0718826140999999e-004f,
    -4.2616262721999995e-004f,-4.4511054884999998e-004f,-4.6402502637000000e-004f,-4.8289983762000001e-004f,
    -5.0172764933999994e-004f,-5.2050223937000000e-004f,-5.3921616333999997e-004f,-5.5786319909000004e-004f,
    -5.7643590225000001e-004f,-5.9492793955000006e-004f,-6.1333186661999999e-004f,-6.3164135019000000e-004f,
    -6.4984883477999997e-004f,-6.6794809823000000e-004f,-6.8593136283999988e-004f,-7.0379240645000003e-004f,
    -7.2152356247000000e-004f,-7.3911860874000001e-004f,-7.5656976755999995e-004f,-7.7387070566000001e-004f,
    -7.9101397866999999e-004f,-8.0799291998999998e-004f,-8.2480030746999997e-004f,-8.4142947450999996e-004f,
    -8.5787297673999994e-004f,-8.7412448089000002e-004f,-8.9017643147999996e-004f,-9.0602238412999998e-004f,
    -9.2165511668999996e-004f,-9.3706796256000000e-004f,-9.5225381069999988e-004f,-9.6720610562000002e-004f,
    -9.8191773627999998e-004f,-9.9638225829999996e-004f,-1.0105924495300001e-003f,-1.0245420878100000e-003f,
    -1.0382239509899999e-003f,-1.0516318169099999e-003f,-1.0647586856400001e-003f,-1.0775984461300001e-003f,
    -1.0901439873399999e-003f,-1.1023894204400001e-003f,-1.1143277454999999e-003f,-1.1259531848000000e-003f,
    -1.1372586273000001e-003f,-1.1482374063999999e-003f,-1.1588850777000000e-003f,-1.1691938635000000e-003f,
    -1.1791582083000001e-003f,-1.1887714454999999e-003f,-1.1980280195999999e-003f,-1.2069223750999999e-003f,
    -1.2154478454000001e-003f,-1.2235999861000000e-003f,-1.2313710195000001e-003f,-1.2387565011999998e-003f,
    -1.2457508757000000e-003f,-1.2523485875000002e-003f,-1.2585429699999999e-003f,-1.2643306899000001e-003f,
    -1.2697039694999999e-003f,-1.2746605866000001e-003f,-1.2791927634999999e-003f,-1.2832960558000000e-003f,
    -1.2869660190999999e-003f,-1.2901982090000000e-003f,-1.2929870699999999e-003f,-1.2953292687999998e-003f,
    -1.2972170276999999e-003f,-1.2986492355999998e-003f,-1.2996203370000000e-003f,-1.3001247764000000e-003f,
    -1.3001603316000001e-003f,-1.2997214471000000e-003f,-1.2988047895999999e-003f,-1.2974070257999999e-003f,
    -1.2955226002000001e-003f,-1.2931492906000000e-003f,-1.2902826525999999e-003f,-1.2869204640000001e-003f,
    -1.2830582804000000e-003f,-1.2786927685000001e-003f,-1.2738217060999999e-003f,-1.2684417599000001e-003f,
    -1.2625495965999998e-003f,-1.2561429940000000e-003f,-1.2492197299000000e-003f,-1.2417753599000001e-003f,
    -1.2338087728999999e-003f,-1.2253188578000001e-003f,-1.2163011702000001e-003f,-1.2067545990000000e-003f,
    -1.1966780331000000e-003f,-1.1860692503000000e-003f,-1.1749260284000000e-003f,-1.1632461452000000e-003f,
    -1.1510307118000000e-003f,-1.1382763949000000e-003f,-1.1249831944999998e-003f,-1.1111488884000000e-003f,
    -1.0967732543799998e-003f,-1.0818559591100000e-003f,-1.0663958914900000e-003f,-1.0503928293000000e-003f,
    -1.0338463281000000e-003f,-1.0167562767799999e-003f,-9.9912245311999993e-004f,-9.8094519044999995e-004f,
    -9.6222437766000008e-004f,-9.4296079252000000e-004f,-9.2315454614000001e-004f,-9.0280652739999990e-004f,
    -8.8191718074000008e-004f,-8.6048783948000000e-004f,-8.3851917028000009e-004f,-8.1601272867999999e-004f,
    -7.9296951466999990e-004f,-7.6939130601000002e-004f,-7.4527932490999990e-004f,-7.2063568246000004e-004f,
    -6.9546204530999999e-004f,-6.6976063565999994e-004f,-6.4353334238000006e-004f,-6.1678272100000001e-004f,
    -5.8951110482999996e-004f,-5.6172116050999998e-004f,-5.3341544357000004e-004f,-5.0459717619999998e-004f,
    -4.7526891392999997e-004f,-4.4543410117000004e-004f,-4.1509584899999995e-004f,-3.8425782404999999e-004f,
    -3.5292313740000001e-004f,-3.2109601122999999e-004f,-2.8877977884000000e-004f,-2.5597888462999997e-004f,
    -2.2269688411999999e-004f,-1.8893855504000000e-004f,-1.5470778623999999e-004f,-1.2000946656000001e-004f,
    -8.4847884846000002e-005f,-4.9228096602999997e-005f,-1.3154679563000000e-005f,2.3367021882999998e-005f,
    6.0332185560999994e-005f,9.7735222637999994e-005f,1.3557108872000001e-004f,1.7383381720000000e-004f,
    2.1251820813000000e-004f,2.5161815045999998e-004f,2.9112808868999999e-004f,3.3104157843999996e-004f,
    3.7135284199000000e-004f,4.1205543496000002e-004f,4.5314324630000002e-004f,4.9460938719000003e-004f,
    5.3644763546999998e-004f,5.7865099120999993e-004f,6.2121289891999996e-004f,6.6412624755999997e-004f,
    7.0738414830999994e-004f,7.5097915679999999e-004f,7.9490438421000000e-004f,8.3915216394999997e-004f,
    8.8371527387000001e-004f,9.2858593627000001e-004f,9.7375681788999997e-004f,1.0192198077000000e-003f,
    1.0649672391100000e-003f,1.1109911121999999e-003f,1.1572839826000001e-003f,1.2038357393000000e-003f,
    1.2506408268000001e-003f,1.2976892451999999e-003f,1.3449732168000000e-003f,1.3924838528000000e-003f,
    1.4402133754999999e-003f,1.4881528960999999e-003f,1.5362924146999999e-003f,1.5846241535999999e-003f,
    1.6331403351000000e-003f,1.6818309592999999e-003f,1.7306860263000001e-003f,1.7796988694999999e-003f,
    1.8288583779000000e-003f,1.8781556627000000e-003f,1.9275829461999998e-003f,1.9771280062999999e-003f,
    2.0267852875000001e-003f,2.0765425677000001e-003f,2.1263909581000001e-003f,2.1763215698999997e-003f,
    2.2263244031999999e-003f,2.2763894581000000e-003f,2.3265089568999999e-003f,2.3766706775000001e-003f,
    2.4268668422000000e-003f,2.4770863399999998e-003f,2.5273202821000000e-003f,2.5775575575000000e-003f,
    2.6277903885000000e-003f,2.6780076640999999e-003f,2.7282004955000000e-003f,2.7783566606000001e-003f,
    2.8284683816999999e-003f,2.8785256588999999e-003f,2.9285173811999998e-003f,2.9784335487000003e-003f,
    3.0282663837000001e-003f,3.0780025529999998e-003f,3.1276353899999999e-003f,3.1771526725999999e-003f,
    3.2265444008999999e-003f,3.2758027972000000e-003f,3.3249156393999999e-003f,3.3738729275999998e-003f,
    3.4226668840999998e-003f,3.4712852867999997e-003f,3.5197192468999997e-003f,3.5679587644999997e-003f,
    3.6159949507999999e-003f,3.6638155837000002e-003f,3.7114128855000000e-003f,3.7587768562999998e-003f,
    3.8058963851000001e-003f,3.8527636941999995e-003f,3.8993676725999999e-003f,3.9456983204000000e-003f,
    3.9917467488000003e-003f,4.0375040690000001e-003f,4.0829602811000001e-003f,4.1281053852000003e-003f,
    4.1729304925000000e-003f,4.2174256031000000e-003f,4.2615818282000003e-003f,4.3053902790000003e-003f,
    4.3488409556000007e-003f,4.3919249691999999e-003f,4.4346345420999992e-003f,4.4769585632999992e-003f,
    4.5188903661999994e-003f,4.5604188398000005e-003f,4.6015362064000002e-003f,4.6422346882999998e-003f,
    4.6825042855999999e-003f,4.7223372205999993e-003f,4.7617246044999997e-003f,4.8006575484999996e-003f,
    4.8391293859999995e-003f,4.8771312282000004e-003f,4.9146541863000007e-003f,4.9516904826000007e-003f,
    4.9882334505000001e-003f,5.0242742011999998e-003f,5.0598049569999994e-003f,5.0948179402000001e-003f,
    5.1293064842000006e-003f,5.1632628113000003e-003f,5.1966802548999999e-003f,5.2295499261999995e-003f,
    5.2618662697000006e-003f,5.2936215076999993e-003f,5.3248100846999998e-003f,5.3554242229999997e-003f,
    5.3854561448999994e-003f,5.4149025171000001e-003f,5.4437533396999999e-003f,5.4720052793999999e-003f,
    5.4996516695999999e-003f,5.5266847326000002e-003f,5.5531000240000000e-003f,5.5788930993999992e-003f,
    5.6040550699999999e-003f,5.6285837135999998e-003f,5.6524723635999995e-003f,5.6757143533999995e-003f,
    5.6983074608000003e-003f,5.7202450191999998e-003f,5.7415236953000000e-003f,5.7621368224999997e-003f,
    5.7820810675000001e-003f,5.8013519858999994e-003f,5.8199451332999995e-003f,5.8378560653000004e-003f,
    5.8550825597000001e-003f,5.8716190610000000e-003f,5.8874633470000007e-003f,5.9026109733000005e-003f,
    5.9170597176999998e-003f,5.9308051357999996e-003f,5.9438438943000002e-003f,5.9561748821000005e-003f,
    5.9677947658999999e-003f,5.9787002123999995e-003f,5.9888901105000000e-003f,5.9983611268999999e-003f,
    6.0071110393999996e-003f,6.0151398479999993e-003f,6.0224431082999998e-003f,6.0290208203000002e-003f,
    6.0348718728999995e-003f,6.0399940438999999e-003f,6.0443862222000003e-003f,6.0480484077999998e-003f,
    6.0509783784999998e-003f,6.0531772453999997e-003f,6.0546427863000006e-003f,6.0553761122999995e-003f
};

#define GetCoeff(p,index) (p[(index < nMiddle ? index : (nCoefficients - 1 - index))])

VOID
PrepareFilter(
    PMIXER_SRC_INSTANCE pSrc
)
{
    PFLOAT  pCoeff = pSrc->pCoeff;
    LONG    lTemp;
    ULONG   Quality = pSrc->Quality;
    ULONG   UpSampleRate = pSrc->UpSampleRate;
    ULONG   DownSampleRate = pSrc->DownSampleRate;
    ULONG   nChannels = pSrc->nChannels;
    FLOAT   Normalizer;
    PFLOAT   pTableCopy;
	ULONG	i, j, nCoefficients, nMiddle, NumberToSkip, NextIndex;
    KFLOATING_SAVE     FloatSave;
    SHORT  wTemp;

    pSrc->nCoeffUsed = 0;
    if (UpSampleRate == DownSampleRate || Quality <= KSAUDIO_QUALITY_PC ) {
        return;
    }

    SaveFloatState(&FloatSave);
    
	// Pick a filter based on the quality...
	pTableCopy = FilterTableFromQuality[Quality];
    nCoefficients = FilterSizeFromQuality[Quality];
    nMiddle = nCoefficients/2;

    Normalizer = (FLOAT)UpSampleRate;
    pSrc->Normalizer = Normalizer;

    // Copy the coefficients in the order we'll use them
    j = 0;
    if (!pSrc->fRequiresFloat) {
        // Generate 16-bit integer coefficients
        // (Ordered to work with MMX)
        do {
            for (i=j; i<nCoefficients; i += UpSampleRate) {
                lTemp = ConvertFloatToLong((GetCoeff(pTableCopy, i) * Normalizer * 32768.0f));
                ((PSHORT)pCoeff)[pSrc->nCoeffUsed] = (SHORT) (lTemp);
                pSrc->nCoeffUsed++;
            }

            // align on qword boundary
            while ((pSrc->nCoeffUsed & 3)) {
                ((PSHORT)pCoeff)[pSrc->nCoeffUsed] = 0;
                pSrc->nCoeffUsed++;
            }
            
           	j = (j + DownSampleRate) % UpSampleRate;
        } while (j != 0);

        for (i=0; i<pSrc->nCoeffUsed; i += 4) {
            // Swap the order for the words
            wTemp = ((PSHORT)pCoeff)[i];
            ((PSHORT)pCoeff)[i] = ((PSHORT)pCoeff)[i+3];
            ((PSHORT)pCoeff)[i+3] = wTemp;

            wTemp = ((PSHORT)pCoeff)[i+1];
            ((PSHORT)pCoeff)[i+1] = ((PSHORT)pCoeff)[i+2];
            ((PSHORT)pCoeff)[i+2] = wTemp;
        }
    } else {
        // Float table generation
        // For non-x86 processors, we generate the "raw" float table for SrcMix_X
        // Otherwise, we skip 2*UpSampleRate for stereo up-sampling
        // and 3*UpSampleRate all others.
#ifdef _X86_
        NumberToSkip = ((UpSampleRate < DownSampleRate || nChannels != 2) ? 3*UpSampleRate : 2*UpSampleRate);
#else
        NumberToSkip = nCoefficients;
#endif

        do {
            for (i=j; i<(nCoefficients - NumberToSkip); i += UpSampleRate) {
                NextIndex = i+NumberToSkip;
                pCoeff[pSrc->nCoeffUsed] = GetCoeff(pTableCopy,i) / GetCoeff(pTableCopy,NextIndex);
                pSrc->nCoeffUsed++;
            }
                
            for (; i<nCoefficients; i += UpSampleRate) {
                pCoeff[pSrc->nCoeffUsed] = GetCoeff(pTableCopy,i) * Normalizer;
                pSrc->nCoeffUsed++;
            }
            
           	j = (j + DownSampleRate) % UpSampleRate;
        } while (j != 0);
    }
    
    RestoreFloatState(&FloatSave);
    return;
}


NTSTATUS
InitializeSRC(
    PMIXER_SRC_INSTANCE pSrc,
    ULONG InputRate, 
    ULONG OutputRate,
    ULONG nChannels,
    ULONG csMixBufferSize
)
{
	ULONG nCoefficients;
#ifdef PERF_COUNT
    LARGE_INTEGER   StartTick, EndTick, Freq;
#endif

    START_PERF;
    pSrc->nChannels = nChannels;
	
    // Our desired stopband is the minimum of InputRate/2 and OutputRate/2.
    // The interpolated rate is (desired stopband) / STOPBAND_FACTOR
    if (InputRate > OutputRate) {
        // Down-sampling
        pSrc->UpSampleRate = ((STOPBAND_FACTOR/2)*OutputRate + InputRate/2)/InputRate;
        pSrc->UpSampleRate = (pSrc->UpSampleRate ? pSrc->UpSampleRate : 1);
        pSrc->DownSampleRate = STOPBAND_FACTOR/2;
    } else {
        // Up-sampling
        pSrc->UpSampleRate = STOPBAND_FACTOR/2;
        pSrc->DownSampleRate = ((STOPBAND_FACTOR/2)*InputRate + OutputRate/2)/OutputRate;
        pSrc->DownSampleRate = (pSrc->DownSampleRate ? pSrc->DownSampleRate : 1);
    }

    pSrc->dwFrac = (4096L*InputRate+OutputRate/2)/OutputRate;

    // Calculate the size of our filter
    nCoefficients = FilterSizeFromQuality[pSrc->Quality];

    // Calculate size to use for our sample history.
    // We allocate enough space for the largest filter.
    if (pSrc->Quality <= KSAUDIO_QUALITY_PC) {
        pSrc->csHistory = 2;
    } else {
        pSrc->csHistory = nCoefficients / pSrc->UpSampleRate;
        if (pSrc->csHistory * pSrc->UpSampleRate < nCoefficients)
            pSrc->csHistory++;
    }

    // Make sure the number of samples in our history is 4 sample aligned (for MMX)
    if (pSrc->csHistory & 3) {
        pSrc->csHistory += (4 - (pSrc->csHistory & 3));
    }
    pSrc->nSizeOfHistory = pSrc->csHistory * nChannels;

    // Clear the counters
    pSrc->nOutCycle = 0;
    pSrc->CoeffIndex = 0;
    pSrc->SampleFrac = 0;
                
    // Calculate the number of input samples needed (and round up)
    pSrc->csInputBufferSize = SrcInputBufferSize(pSrc, csMixBufferSize)+1;

    pSrc->fStarted = FALSE;
    pSrc->pHistory = NULL;
    pSrc->pCoeff = NULL;
    pSrc->fRequiresFloat = (pSrc->UpSampleRate != pSrc->DownSampleRate &&
                            pSrc->Quality > KSAUDIO_QUALITY_PC);
#ifdef _X86_    
    if (MmxPresent() && pSrc->Quality == KSAUDIO_QUALITY_ADVANCED) {
        // Turn off the float SRC
        pSrc->fRequiresFloat = FALSE;
    }
#endif

#ifdef PERF_COUNT
    // Store the average counter
    EndTick = KeQueryPerformanceCounter(&Freq);
    if (EndTick.QuadPart > StartTick.QuadPart) {
        AverageTicksPerInitSrc = (DWORD)(EndTick.QuadPart-StartTick.QuadPart);
    }
#endif            
    return STATUS_SUCCESS;
}

NTSTATUS
EnableSRC
(
    PFILTER_INSTANCE pFilterInstance,
    PMIXER_SRC_INSTANCE pSrc,
    PMIXER_SOURCE_INSTANCE pMixerSource
)
{
    ULONG            siz;
    ULONG            i, Index;
    
    
    //
    // pFilterInstance is required for accessing MAX_INPUT_SAMPLES (includes MIXBUFFERDURATION)
    //

    // Make sure our source instance pointer is valid.
    ASSERT( !IsListEmpty(&pFilterInstance->SourceConnectionList) );
    if (pMixerSource) {
        ASSERT( pMixerSource->WriteContext );
        ASSERT( pMixerSource->WriteContext->pFilterInstance == pFilterInstance );
    }

    // Assumes that InitializeSrc was called successfully.
    // And pMixerSource == NULL indicates that this is an independent SRC, not global
    if (pSrc->fStarted) {
        return STATUS_SUCCESS;
    }

    // Allocate space for our sample history and input buffer
   	// The input buffer follows the sample history immediately.
   	// MAX(nOutCycle) = UpSampleRate-1
    siz = pSrc->csInputBufferSize;
    siz *= (pSrc->nChannels * sizeof(FLOAT));
    siz += pSrc->nSizeOfHistory * sizeof(FLOAT);

    // Add 3 DWORD's so we can always round up to the next 4 sample boundary in our code
    siz += 3 * sizeof(FLOAT);

    Index = SrcIndex(pSrc);

    // Make sure our indeces into pSrcBuffer are valid.  Otherwise if pMixerSource is not
    // NULL we will corrupt memory and lose track of the buffers and fail to free them.
    // Note the following quantities are both unsigned so these asserts are also effectively
    // checking that both Quality and Index are >= 0.

    ASSERT( pSrc->Quality <= KSAUDIO_QUALITY_ADVANCED );
    ASSERT( Index < STOPBAND_FACTOR );

    if (pMixerSource == NULL || pMixerSource->pSrcBuffer[pSrc->Quality][Index] == INVALID_POINTER) {
        siz = MAX_INPUT_SAMPLES;
        siz *= (pSrc->nChannels * sizeof(FLOAT));
        siz += pSrc->nSizeOfHistory * sizeof(FLOAT);
        pSrc->pHistory = (PFLOAT) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
        if (pMixerSource && pSrc->pHistory) {
            pMixerSource->pSrcBuffer[pSrc->Quality][Index] = pSrc->pHistory;
        }
    } else {
        pSrc->pHistory = pMixerSource->pSrcBuffer[pSrc->Quality][Index];
    }
    if (!pSrc->pHistory) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#ifdef USE_CAREFUL_ALLOCATIONS
    ValidateAccess((PBYTE)pSrc->pHistory + siz - 1);
#endif

   	pSrc->pInputBuffer = pSrc->pHistory + pSrc->nSizeOfHistory;

    if (pSrc->Quality > KSAUDIO_QUALITY_PC) {
        siz = FilterSizeFromQuality[pSrc->Quality] * sizeof(FLOAT);
   	    pSrc->pCoeff = (PFLOAT) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
        if (pSrc->pCoeff == NULL) {
            if (pMixerSource == NULL) {
                ExFreePool( pSrc->pHistory );
            }
            pSrc->pHistory = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
   	
   	// Generate a copy of the coefficient table
  	PrepareFilter(pSrc);

    ASSERT( pSrc->pHistory );
   	ASSERT( pSrc->pInputBuffer );
   	ASSERT( pSrc->pCoeff || pSrc->Quality <= KSAUDIO_QUALITY_PC );

    pSrc->fStarted = TRUE;
    if (pMixerSource) {
        (pMixerSource->SrcCount[pSrc->Quality][Index])++;
    }

    if (pMixerSource == NULL || pMixerSource->SrcCount[pSrc->Quality][Index] == 1) {
        // Zero out the history.
        for (i=0; i<pSrc->nSizeOfHistory; i++) {
            pSrc->pHistory[i] = 0;
        }
    }
    
   	return STATUS_SUCCESS;
}

NTSTATUS
DisableSRC(
    PMIXER_SRC_INSTANCE pSrc,
    PMIXER_SOURCE_INSTANCE pMixerSource
)
{
    ULONG   Index;
    
    // Assumes that InitializeSrc was called successfully.
    // And pMixerSource == NULL indicates that this is an independent SRC, not global
    if (!pSrc->fStarted) {
        return STATUS_SUCCESS;
    }

    // Free the space allocated
    if (pSrc->pHistory) {
        if (pMixerSource == NULL) {
            ExFreePool(pSrc->pHistory);
        }
        pSrc->pHistory = NULL;
    }
    
    if (pSrc->Quality > KSAUDIO_QUALITY_PC && pSrc->pCoeff) {
        ExFreePool(pSrc->pCoeff);
        pSrc->pCoeff = NULL;
    }

    pSrc->fStarted = FALSE;
    Index = SrcIndex(pSrc);
    if (pMixerSource) {
        (pMixerSource->SrcCount[pSrc->Quality][Index])--;
    }

    return STATUS_SUCCESS;
}

FLOAT
DB_TO_LINEAR
(
    LONG dbValue
)
{
    static FLOAT LinearTable[192] = {
        1.6788e-05f,1.77828e-05f,1.88365e-05f,1.99526e-05f,2.11349e-05f,2.23872e-05f,2.37137e-05f,2.51189e-05f,
        2.66073e-05f,2.81838e-05f,2.98538e-05f,3.16228e-05f,3.34965e-05f,3.54813e-05f,3.75837e-05f,3.98107e-05f,
        4.21697e-05f,4.46684e-05f,4.73151e-05f,5.01187e-05f,5.30884e-05f,5.62341e-05f,5.95662e-05f,6.30957e-05f,
        6.68344e-05f,7.07946e-05f,7.49894e-05f,7.94328e-05f,8.41395e-05f,8.91251e-05f,9.44061e-05f,0.0001f,
        0.000105925f,0.000112202f,0.00011885f,0.000125893f,0.000133352f,0.000141254f,0.000149624f,0.000158489f,
        0.00016788f,0.000177828f,0.000188365f,0.000199526f,0.000211349f,0.000223872f,0.000237137f,0.000251189f,
        0.000266073f,0.000281838f,0.000298538f,0.000316228f,0.000334965f,0.000354813f,0.000375837f,0.000398107f,
        0.000421697f,0.000446684f,0.000473151f,0.000501187f,0.000530884f,0.000562341f,0.000595662f,0.000630957f,
        0.000668344f,0.000707946f,0.000749894f,0.000794328f,0.000841395f,0.000891251f,0.000944061f,0.001f,
        0.001059254f,0.001122018f,0.001188502f,0.001258925f,0.001333521f,0.001412538f,0.001496236f,0.001584893f,
        0.001678804f,0.001778279f,0.001883649f,0.001995262f,0.002113489f,0.002238721f,0.002371374f,0.002511886f,
        0.002660725f,0.002818383f,0.002985383f,0.003162278f,0.003349654f,0.003548134f,0.003758374f,0.003981072f,
        0.004216965f,0.004466836f,0.004731513f,0.005011872f,0.005308844f,0.005623413f,0.005956621f,0.006309573f,
        0.006683439f,0.007079458f,0.007498942f,0.007943282f,0.008413951f,0.008912509f,0.009440609f,0.01f,
        0.010592537f,0.011220185f,0.011885022f,0.012589254f,0.013335214f,0.014125375f,0.014962357f,0.015848932f,
        0.01678804f,0.017782794f,0.018836491f,0.019952623f,0.02113489f,0.022387211f,0.023713737f,0.025118864f,
        0.026607251f,0.028183829f,0.029853826f,0.031622777f,0.033496544f,0.035481339f,0.03758374f,0.039810717f,
        0.04216965f,0.044668359f,0.047315126f,0.050118723f,0.053088444f,0.056234133f,0.059566214f,0.063095734f,
        0.066834392f,0.070794578f,0.074989421f,0.079432823f,0.084139514f,0.089125094f,0.094406088f,0.1f,
        0.105925373f,0.112201845f,0.118850223f,0.125892541f,0.133352143f,0.141253754f,0.149623566f,0.158489319f,
        0.167880402f,0.177827941f,0.188364909f,0.199526231f,0.211348904f,0.223872114f,0.237137371f,0.251188643f,
        0.266072506f,0.281838293f,0.298538262f,0.316227766f,0.334965439f,0.354813389f,0.375837404f,0.398107171f,
        0.421696503f,0.446683592f,0.473151259f,0.501187234f,0.530884444f,0.562341325f,0.595662144f,0.630957344f,
        0.668343918f,0.707945784f,0.749894209f,0.794328235f,0.841395142f,0.891250938f,0.944060876f,1
        };

    dbValue = ((dbValue+16384) / 32768L) + 191;
    return (dbValue < 0 ? 0.0f : dbValue > 191 ? 1.0f : LinearTable[dbValue]);
}

LONG
LINEAR_TO_DB
(
    FLOAT Level
)
{
    static LONG dbTable[201] = {
        THE_SOUND_OF_SILENCE,-3016006,-2621440,-2390634,-2226874,-2099852,-1996068,-1908319,
        -1832308,-1765261,-1705286,-1651032,-1601502,-1555938,-1513753,-1474480,
        -1437742,-1403232,-1370695,-1339918,-1310720,-1282947,-1256466,-1231162,
        -1206936,-1183698,-1161372,-1139889,-1119187,-1099212,-1079914,-1061248,
        -1043176,-1025659,-1008666,-992165,-976129,-960533,-945352,-930566,
        -916154,-902098,-888381,-874986,-861900,-849107,-836596,-824354,
        -812370,-800632,-789132,-777860,-766806,-755963,-745323,-734878,
        -724621,-714546,-704646,-694915,-685348,-675939,-666682,-657574,
        -648610,-639784,-631093,-622533,-614100,-605790,-597599,-589525,
        -581563,-573711,-565967,-558326,-550786,-543345,-536000,-528748,
        -521588,-514517,-507532,-500632,-493815,-487078,-480420,-473839,
        -467334,-460902,-454541,-448251,-442030,-435876,-429788,-423764,
        -417803,-411905,-406066,-400287,-394566,-388902,-383294,-377740,
        -372240,-366793,-361397,-356052,-350757,-345510,-340312,-335160,
        -330055,-324995,-319980,-315008,-310080,-305193,-300349,-295545,
        -290782,-286058,-281372,-276726,-272116,-267544,-263008,-258508,
        -254044,-249614,-245218,-240856,-236527,-232231,-227967,-223735,
        -219534,-215364,-211224,-207114,-203033,-198982,-194959,-190964,
        -186997,-183058,-179145,-175260,-171401,-167567,-163760,-159977,
        -156220,-152487,-148779,-145094,-141434,-137796,-134182,-130591,
        -127022,-123475,-119951,-116447,-112966,-109505,-106066,-102647,
        -99249,-95870,-92512,-89173,-85854,-82554,-79273,-76011,
        -72768,-69543,-66336,-63147,-59975,-56822,-53685,-50566,
        -47464,-44379,-41310,-38258,-35222,-32202,-29198,-26210,
        -23237,-20280,-17339,-14412,-11500,-8603,-5721,-2853,
        0
    };

    return (Level < 0.0f ? THE_SOUND_OF_SILENCE : Level > 0.995f ? 0L : dbTable[ConvertFloatToLong(Level/0.005f)]);
}

VOID
GenerateSpeakerMapping( VOID )
{
    ULONG i, j;
    FLOAT Delta, Distance, Level;
    KFLOATING_SAVE     FloatSave;


    SaveFloatState(&FloatSave);
    
    // Generates the speaker mapping for each possible speaker combo
    // Note that SpeakerMap[x][y] is the mapping of input x to output y
    for (i=0; i<nPossibleSpeakers; i++) {
        for (j=0; j<nPossibleSpeakers; j++) {
            // Calculate the distance between speaker i and speaker j
            Delta = (SpeakerLocation[i][0] - SpeakerLocation[j][0]) ;
            Distance = (Delta*Delta);

            Delta = (SpeakerLocation[i][1] - SpeakerLocation[j][1]) ;
            Distance += (Delta*Delta);
            
            Delta = (SpeakerLocation[i][2] - SpeakerLocation[j][2]) ;
            Distance += (Delta*Delta);

            // Map the distance to a level
            if (Distance < 1.0) {
                Level = 1.0f;
            } else {
                Level = 1.0f/Distance;
            }

            SpeakerMap[i][j] = Level;
        }
    }

    RestoreFloatState(&FloatSave);

    
}

VOID
MapSpeakerLocations(
	PMIXER_SINK_INSTANCE pMixerSink,
	ULONG	InChannels,
	ULONG	OutChannels,
	ULONG   InMask,
	ULONG   OutMask,
    PMIXER_SOURCE_INSTANCE pMixerSource
)
{
    ULONG i, j, InputChannel, OutputChannel;
    FLOAT Max, sum, ScaleFactor;
    PFLOAT pMixLevelModel;
    KFLOATING_SAVE     FloatSave;


    SaveFloatState(&FloatSave);

    // Initialize the mix levels to their defaults
    // Remember: pMixLevelModel[x*OutChannels + y]
    //                       is the gain for input channel x before it is mixed to y
    // Start with no outputs
    pMixLevelModel = (PFLOAT) pMixerSink->pMixLevelModel;
    for (i=0; i<InChannels*OutChannels; i++)
        pMixLevelModel[i] = 0.0f;

	// We special case the channel mask of zero when it is only present on one side.
	if (InMask || OutMask) {
		// We have a mask on at least one side.
		if (OutMask == 0) {
			// The output is unspecified.
			if (OutChannels == 1) {
				// Mono special case
				OutMask = KSAUDIO_SPEAKER_MONO;
			} else {
				// Map one-to-one
				// Copy as many speaker locations as possible
				j = 0;
				for (i=0; i<nPossibleSpeakers; i++) {
					if ((InMask & ChannelMask[i]) && (j<OutChannels)) {
						OutMask |= ChannelMask[i];
						j++;
					}
				}
			}
		} else if (InMask == 0) {
			// The input is unspecified.
			if (InChannels == 1) {
				// Mono special case
				InMask = KSAUDIO_SPEAKER_MONO;
			} else {
				// Map one-to-one
				// Copy as many speaker locations as possible
				j = 0;
				for (i=0; i<nPossibleSpeakers; i++) {
					if ((OutMask & ChannelMask[i]) && (j<InChannels)) {
						InMask |= ChannelMask[i];
						j++;
					}
				}
			}
		}
	}
	
    // For each speaker location present in the input stream,
    // Find the maximum mapping from all the speaker locations in the output stream
    // And fill in the corresponding super-mix cell for all input & output channel
    // combinations that would have that maximum mapping.
    InputChannel = 0;
    for (i=0; i<nPossibleSpeakers; i++) {
        if (InMask & ChannelMask[i]) {
            // Find the maximum mapping (closest output) for this speaker
            // Note that SpeakerMap[x][y] is the mapping of input x to output y
            Max = 0.0;
            for (j=0; j<nPossibleSpeakers; j++) {
                if ((OutMask & ChannelMask[j]) && SpeakerMap[i][j] > Max) {
                    Max = SpeakerMap[i][j];
                }
            }

            // Now use ALL the available output speakers that have the MAX mapping
            OutputChannel = 0;
            for (j=0; j<nPossibleSpeakers; j++) {
                if (OutMask & ChannelMask[j]) {
                    if (SpeakerMap[i][j] == Max &&
                        Max > pMixLevelModel[InputChannel*OutChannels + OutputChannel]) {
                        pMixLevelModel[InputChannel*OutChannels + OutputChannel] = Max;
                    }
                    
                    // We're done with this output channel.
                    // Note: All extra speaker locations are mapped to the last output channel
                    if (OutputChannel < (OutChannels-1)) {
                        OutputChannel++;
                    }
                }
            }

            // We're done with this input channel.
            // Note: All extra speaker locations are mapped to the last input channel
            if (InputChannel < (InChannels-1)) {
                InputChannel++;
            }
        }
    }

    // Now, handle any extra input and output channels (not mapped to speaker locations)
    // We need to find the next available (unmapped) input channel
    InputChannel = 0;
    for (i=0; i<nPossibleSpeakers; i++) {
        if (InMask & ChannelMask[i]) {
            // This channel is mapped.
            InputChannel++;
        }
    }
    
    // We need to find the next available (unmapped) output channel
    OutputChannel = 0;
    for (j=0; j<nPossibleSpeakers; j++) {
        if (OutMask & ChannelMask[j]) {
            // This channel is mapped.
            OutputChannel++;
        }
    }
    
    // InputChannel and OutputChannel now point to the first unmapped input and output channels, respectively.
    for (; (InputChannel<InChannels && OutputChannel<OutChannels); InputChannel++, OutputChannel++) {
        pMixLevelModel[InputChannel*OutChannels + OutputChannel] = 1.0;
    }

    // We've run out of extra channels, either on input or output.
    // If output, it's okay - all the input channels were sent somewhere.
    // If input, we can't do anything about it - all the output channels are used up.'

    // Make sure we don't cause clipping on any output channels
    Max = 0.0;
    for (j=0; j<OutChannels; j++) {
        sum = 0.0;
        for (i=0; i<InChannels; i++) {
            sum += pMixLevelModel[i*OutChannels + j];
        }

        if (sum > Max) {
            Max = sum;
        }
    }

    if (Max > 0.0) {
        ScaleFactor = 1.0f/Max;
    } else {
        ScaleFactor = 1.0f;
    }

    // Convert everybody to LONG mix levels
    for (i=0; i<(InChannels * OutChannels); i++) {
        pMixerSink->pMixLevelModel[i] = LINEAR_TO_DB(ScaleFactor*pMixLevelModel[i]);
    }
    RestoreFloatState(&FloatSave);
}

VOID
GenerateMixArray(
	PMIXER_SINK_INSTANCE pMixerSink,
	ULONG	InChannels,
	ULONG	OutChannels,
    PMIXER_SOURCE_INSTANCE pMixerSource
)
{
	ULONG	i, j, m, n, MaxChannels;
	LONG    lTemp ;
	FLOAT   ChannelVolumeLevel, MasterVolumeLevel, Divisor = 0x10000L, flTemp;
	PFLOAT	pDest;
	PLONG   pSrc;
    KFLOATING_SAVE     FloatSave;
    PBYTE   pMap;
    BOOL    fAnyVolume, fRequiresFloat, fEnableSrc, fFloatInput, fScalingConvert, fEnableHiRes;
    ULONG   wBitsPerSample, SequenceSize;
    PSUPERMIX_BLOCK pBlock;
    BOOL	fBlank;

	pMixerSink->fMuted = (pMixerSource->MasterVolumeLevel == THE_SOUND_OF_SILENCE || 
	                      pMixerSink->MasterVolumeLevel == THE_SOUND_OF_SILENCE);
	if (pMixerSink->fMuted) {
	    return;
	}
	
    pMixerSink->fMuted = TRUE;
    for (i=0; i<InChannels; i++) {
        if (pMixerSink->pChannelVolumeLevel[i] != THE_SOUND_OF_SILENCE) {
            pMixerSink->fMuted = FALSE;
        }
    }
    if (pMixerSink->fMuted) {
        return;
    }

    pMixerSink->fMuted = TRUE;
    for (j=0; j<OutChannels; j++) {
        if (pMixerSink->pPanVolumeLevel[j] != THE_SOUND_OF_SILENCE) {
            pMixerSink->fMuted = FALSE;
        }
    }
    if (pMixerSink->fMuted) {
        return;
    }
    
    SaveFloatState(&FloatSave);
    
	// Remember: pMixLevelArray[x*OutChannels + y]
	// 			 is the gain for input channel x before it is mixed to y
	pDest = pMixerSink->pMixLevelArray;
	pSrc = pMixerSink->pMixLevelModel;
	pBlock = pMixerSink->pSuperMixBlock;
	MasterVolumeLevel = (FLOAT) DB_TO_LINEAR(pMixerSource->MasterVolumeLevel);
	MasterVolumeLevel *= (FLOAT)DB_TO_LINEAR(pMixerSink->MasterVolumeLevel);

    // Adjust master volume for dither, if necessary.
    fRequiresFloat = pMixerSink->pInfo->Src.fRequiresFloat;
    fEnableSrc = (pMixerSink->pInfo->Src.UpSampleRate != pMixerSink->pInfo->Src.DownSampleRate);
    fFloatInput = (pMixerSink->WaveFormatEx.wFormatTag == WAVE_FORMAT_IEEE_FLOAT);
    fFloatInput |= (pMixerSink->WaveFormatEx.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
                    IsEqualGUID( &(pMixerSink->WaveFormatExt.SubFormat), &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT ) );
    fRequiresFloat |= (fFloatInput && !fEnableSrc);

    if (fRequiresFloat) {
        // Adjust for dither over interval (-1, +1)
        MasterVolumeLevel *= (32767.0/32768.0);
    }

	// Fill-in the Mix Level Array for SuperMix
    wBitsPerSample = pMixerSink->WaveFormatEx.wBitsPerSample;
    if ( pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK ) {
        wBitsPerSample = pMixerSource->WaveFormatEx.wBitsPerSample;
    }
    fEnableHiRes = (wBitsPerSample==24 || wBitsPerSample==32);
	fScalingConvert = (InChannels != OutChannels &&
	                   InChannels <= 2 &&
	                   OutChannels <= 2 &&
	                   !pMixerSink->fEnable3D &&
	                   !fEnableHiRes);
	                   
    // If the first SRC is being used, we must not convert channels first.                          
    if (pMixerSink->fCreate3D && 
        pMixerSink->pInfo->Doppler.UpSampleRate != pMixerSink->pInfo->Doppler.DownSampleRate) {
        fScalingConvert = FALSE;
    }

	for (i=0; i<InChannels; i++) {
		for (j=0; j<OutChannels; j++) {
			ChannelVolumeLevel = (FLOAT) DB_TO_LINEAR((*pSrc));
   			ChannelVolumeLevel *= (FLOAT)DB_TO_LINEAR(pMixerSink->pPanVolumeLevel[j]);
			    ChannelVolumeLevel *= (FLOAT)DB_TO_LINEAR(pMixerSink->pChannelVolumeLevel[i]);
			
            *pDest = (ChannelVolumeLevel * MasterVolumeLevel);
            pDest++;
			pSrc++;
		}		
	}

#ifdef NEW_SURROUND    
        if (pMixerSource->fSurround) {
            // Scale all values (to reduce clipping)
            pDest = pMixerSink->pMixLevelArray;
            for (i=0; i<InChannels; i++) {
                for (j=0; j<OutChannels; j++) {
                    *pDest *= 0.4f;
                    pDest++;
                }
            }

            // Scale center and surround by SURSCALE to prepare for surround encoding
            // Assumes L, R, C, S
            pDest = pMixerSink->pMixLevelArray;
            for (i=0; i<InChannels; i++) {
                pDest[2] *= SURSCALE;
                pDest[3] *= SURSCALE;
                pDest += OutChannels;
            }
        }
#endif

    // Fill-in the supermix block list
    pDest = pMixerSink->pMixLevelArray;
    pMixerSink->fMuted = TRUE;
#if _X86_
	if (MmxPresent()) {	    
		// MMX supermix (4x2 16-bit integers)
		for (j=0; j<OutChannels; j += 4) {
		    SequenceSize = 0;
		    for (i=0; i<InChannels; i += 2) {
		        // Fill-in the data for this potential block.
		        pBlock[SequenceSize].InputChannel = i;
		        pBlock[SequenceSize].OutputChannel = j;
		        pBlock[SequenceSize].wMixLevel[0][0] = 0;
		        pBlock[SequenceSize].wMixLevel[1][0] = 0;
		        pBlock[SequenceSize].wMixLevel[2][0] = 0;
		        pBlock[SequenceSize].wMixLevel[3][0] = 0;
		        pBlock[SequenceSize].wMixLevel[0][1] = 0;
		        pBlock[SequenceSize].wMixLevel[1][1] = 0;
		        pBlock[SequenceSize].wMixLevel[2][1] = 0;
		        pBlock[SequenceSize].wMixLevel[3][1] = 0;
		        pBlock[SequenceSize].wMixLevel[0][0] = (WORD) (16384 * pDest[i*OutChannels + j]);
	  	        if ( (i+1) < InChannels )
	    	        pBlock[SequenceSize].wMixLevel[0][1] = (WORD) (16384 * pDest[(i+1)*OutChannels + j]);
		        if ( (j+1) < OutChannels ) {
	    	        pBlock[SequenceSize].wMixLevel[1][0] = (WORD) (16384 * pDest[i*OutChannels + j + 1]);
	    	        if ( (i+1) < InChannels )
	        	        pBlock[SequenceSize].wMixLevel[1][1] = (WORD) (16384 * pDest[(i+1)*OutChannels + j+1]);
	    	    }
	    	    if ( (j+2) < OutChannels ) {
	    	        pBlock[SequenceSize].wMixLevel[2][0] = (WORD) (16384 * pDest[i*OutChannels + j + 2]);
	    	        if ( (i+1) < InChannels )
	        	        pBlock[SequenceSize].wMixLevel[2][1] = (WORD) (16384 * pDest[(i+1)*OutChannels + j+2]);
	    	    }
	    	    if ( (j+3) < OutChannels ) {
	    	        pBlock[SequenceSize].wMixLevel[3][0] = (WORD) (16384 * pDest[i*OutChannels + j + 3]);
	    	        if ( (i+1) < InChannels )
	        	        pBlock[SequenceSize].wMixLevel[3][1] = (WORD) (16384 * pDest[(i+1)*OutChannels + j+3]);
	    	    }

	            if (pBlock[SequenceSize].wMixLevel[0][0] ||
	    	        pBlock[SequenceSize].wMixLevel[1][0] ||
	    	        pBlock[SequenceSize].wMixLevel[2][0] ||
	    	        pBlock[SequenceSize].wMixLevel[3][0] ||
	    	        pBlock[SequenceSize].wMixLevel[0][1] ||
	    	        pBlock[SequenceSize].wMixLevel[1][1] ||
	    	        pBlock[SequenceSize].wMixLevel[2][1] ||
	    	        pBlock[SequenceSize].wMixLevel[3][1] ) {
	    	        SequenceSize++;
	    	    }
		    }

		    if (SequenceSize == 0) {
		        SequenceSize++;
		    } else {
		        pMixerSink->fMuted = FALSE;
		    }

		    pBlock[0].SequenceSize = SequenceSize * sizeof(SUPERMIX_BLOCK);
		    for (i=SequenceSize; i>0; i--) {
		        pBlock[i].InputChannel = pBlock[i-1].InputChannel;
		    }
		    pBlock += (SequenceSize+1);
		}
	} else {
#endif
		// non-MMX supermix (MxN 32-bit floats)
		for (j=0; j<OutChannels; j += BLOCK_SIZE_OUT) {
		    SequenceSize = 0;
		    for (i=0; i<InChannels; i += BLOCK_SIZE_IN) {
		        // Fill-in the data for this potential block.
		        pBlock[SequenceSize].InputChannel = i;
		        pBlock[SequenceSize].OutputChannel = j;

		        // Fill all entries
		        fBlank = TRUE;
		        for (m=0; m<BLOCK_SIZE_OUT; m++) {
		        	for (n=0; n<BLOCK_SIZE_IN; n++) {
		        		pBlock[SequenceSize].MixLevel[m][n] = 0;
		        		if ( (j+m) < OutChannels && (i+n) < InChannels ) {
#ifdef FLOAT_SUPERMIX_BLOCKS
		        			pBlock[SequenceSize].MixLevel[m][n] = pDest[(i+n)*OutChannels + (j+m)];
#else
							pBlock[SequenceSize].MixLevel[m][n] = (LONG) (16384 * pDest[(i+n)*OutChannels + (j+m)]);
#endif
		        		}
		        		if (pBlock[SequenceSize].MixLevel[m][n] != 0) {
		        			fBlank = FALSE;
		        		}
		        	}
		        }
		        
	            if (!fBlank) {
	    	        SequenceSize++;
	    	    }
		    }

		    if (SequenceSize == 0) {
		        SequenceSize++;
		    } else {
		        pMixerSink->fMuted = FALSE;
		    }

		    pBlock[0].SequenceSize = SequenceSize * sizeof(SUPERMIX_BLOCK);
		    for (i=SequenceSize; i>0; i--) {
		        pBlock[i].InputChannel = pBlock[i-1].InputChannel;
		    }
		    pBlock += (SequenceSize+1);
		}
#ifdef _X86_
	}
#endif

    // Fill-in the mapping tables for the Convert stage
    MaxChannels = (InChannels > OutChannels ? InChannels : OutChannels);
    pMap = (PBYTE)pMixerSink->pMappingTable;
    fAnyVolume = FALSE;
	for (j=0; j<MaxChannels; j++) {
	    if (fScalingConvert) {
	        // There are really only 2 cases where scaling is used: mono-to-stereo, and stereo-to-mono
	        if (InChannels == 1 && OutChannels == 2) {
	            // mono-to-stereo
	            ChannelVolumeLevel = (FLOAT) (MasterVolumeLevel * 
	                                          DB_TO_LINEAR(pMixerSink->pPanVolumeLevel[j]) *
	                                          DB_TO_LINEAR(pMixerSink->pChannelVolumeLevel[0]) *
	                                          DB_TO_LINEAR(pMixerSink->pMixLevelModel[j]));
	        } else {
	            // stereo-to-mono
	            ChannelVolumeLevel = (FLOAT) (MasterVolumeLevel *
	                                          DB_TO_LINEAR(pMixerSink->pPanVolumeLevel[0]) *
	                                          DB_TO_LINEAR(pMixerSink->pChannelVolumeLevel[j]) *
	                                          DB_TO_LINEAR(pMixerSink->pMixLevelModel[j]));
	        }
   	    }

        // Store vol/32768 as a DWORD for the MMX and crude versions of convert
        pMixerSink->pVolumeTable[j] = ConvertFloatToLong((FLOAT)(32768L * ChannelVolumeLevel));
        fAnyVolume |= (pMixerSink->pVolumeTable[j] < 32768L);
        
        if (pMap) {
            if (wBitsPerSample == 8) {
#ifndef _X86_
        	    for (i=0; i<256; i++) {
       	            lTemp = ((LONG)i - 0x80)*256;

                    if (fRequiresFloat) {
        	            // Store as a float
       	                ((PFLOAT)pMap)[64+i] = (lTemp * ChannelVolumeLevel);
       	            } else {
                        // Store as a long
       	                ((PLONG)pMap)[64+i] = ConvertFloatToLong((FLOAT)(lTemp * ChannelVolumeLevel));
       	            }
    	        }
#else
                if (fRequiresFloat) {
                    _asm {
                        mov ecx, 1
                        mov edi, pMap

                        mov eax, 256

                        lea esi, [edi+256+512]
                        mov lTemp, eax

                        fild lTemp                  // t
                        fld ChannelVolumeLevel      // v, t
                        fmulp st(1), st             // t
                        fst flTemp                  // 256*ChannelVolumeLevel

        FloatLoop8:
                        fst DWORD PTR [edi+ecx*4+256+512]
                        fadd flTemp                 // t+256*ChannelVolumeLevel

                        sub esi, 4
                        mov ebx, DWORD PTR [edi+ecx*4+256+512]
                        
                        xor ebx, 0x80000000

                        mov DWORD PTR [esi], ebx
                        inc ecx
                        
                        cmp ecx, 128
                        jne FloatLoop8

                        fst flTemp
                        fistp DWORD PTR [edi]       // 128*256*ChannelVolumeLevel

                        mov ebx, flTemp

                        xor ebx, 0x80000000

                        mov DWORD PTR [edi+256], ebx
                    }
                } else {
                    _asm {
                        mov ecx, 1
                        mov edi, pMap

                        mov eax, 256

                        lea esi, [edi+256+512]
                        mov lTemp, eax

                        fild lTemp                  // t
                        fld ChannelVolumeLevel      // v, t
                        fmulp st(1), st             // t
                        fst flTemp                  // 256*ChannelVolumeLevel

        LongLoop8:
                        fist DWORD PTR [edi+ecx*4+256+512]
                        fadd flTemp                 // t+256*ChannelVolumeLevel

                        sub esi, 4
                        mov eax, DWORD PTR [edi+ecx*4+256+512]
                        
                        neg eax
                        
                        mov DWORD PTR [esi], eax
                        inc ecx
                        
                        cmp ecx, 128
                        jne LongLoop8

                        fistp DWORD PTR [edi]       // 128*256*ChannelVolumeLevel

                        mov eax, DWORD PTR [edi]

                        neg eax

                        mov DWORD PTR [edi+256], eax
                    }
                }
                ((PLONG)pMap)[64+128] = 0;
#endif
       	        
                // Each channel has 1280 bytes of mapping table available
        	    pMap += (256*sizeof(LONG)+256*sizeof(BYTE));
    	    } else {
#ifndef _X86_
        	    for (i=0; i<128; i++) {
                    // Store as a byte
                    pMap[i] = (unsigned char) ConvertFloatToLong((FLOAT)(i * ChannelVolumeLevel));
    	        
                    // Store as a long
       	            lTemp = ((LONG)i)*256;
       	            ((PLONG)pMap)[64+i] = ConvertFloatToLong((FLOAT)(lTemp * ChannelVolumeLevel));
    	        }

        	    for (; i<256; i++) {
                    // Store as a byte
                    pMap[i] = (unsigned char) ConvertFloatToLong((FLOAT)(i * ChannelVolumeLevel));
    	        
                    // Store as a long
           	        lTemp = ((LONG)i-0x100)*256;
           	        ((PLONG)pMap)[64+i] = ConvertFloatToLong((FLOAT)(lTemp * ChannelVolumeLevel));
    	        }
    	        
                // Store as a float
       	        ((PFLOAT)pMap)[320] = ChannelVolumeLevel;
#else
                _asm {
                    mov ecx, 1
                    mov edi, pMap

                    fld ChannelVolumeLevel      // t
                    
    ByteLoop:
                    fist DWORD PTR [edi]
                    fadd ChannelVolumeLevel     // t+ChannelVolumeLevel
                    
                    mov al, BYTE PTR [edi]

                    mov BYTE PTR [edi+ecx], al
                    inc ecx

                    cmp ecx, 256
                    jne ByteLoop

                    fst flTemp                  // 256*ChannelVolumeLevel
                    
                    lea esi, [edi+256+1024]
                    mov ecx, 1

    LongLoop:
                    fist DWORD PTR [edi+ecx*4+256]
                    fadd flTemp                 // t+256*ChannelVolumeLevel

                    sub esi, 4
                    mov eax, DWORD PTR [edi+ecx*4+256]
                    
                    neg eax
                    
                    inc ecx
                    mov DWORD PTR [esi], eax
                    
                    cmp ecx, 128
                    jne LongLoop

                    fistp DWORD PTR [edi+321*4] // 128*256*ChannelVolumeLevel

                    mov eax, DWORD PTR [edi+321*4]
                    mov ebx, ChannelVolumeLevel

                    neg eax
                    mov DWORD PTR [edi+320*4], ebx

                    mov DWORD PTR [esi-4], eax
                }
                pMap[0] = 0;
                ((PLONG)pMap)[64] = 0L;
#endif
                // Each channel has 1288 bytes of mapping table available
        	    pMap += (256*sizeof(LONG)+2*sizeof(FLOAT)+256*sizeof(BYTE));
    	    }
    	}
	}

    // Adjust MMX volume levels, if scaling is required.
#ifdef SURROUND_VOLUME_HACK
    pMixerSink->CenterVolume = 0;
#endif
	if (fAnyVolume) {
    	for (j=0; j<MaxChannels; j++) {
    	    if (pMixerSink->pVolumeTable[j] > 32767L) {
    	        pMixerSink->pVolumeTable[j] = 32767L;
    	    }
            
#ifdef SURROUND_VOLUME_HACK
            pMixerSink->CenterVolume += (FLOAT) (pMixerSink->pVolumeTable[j]/32768.0f);
#endif
    	}
	}

#ifdef SURROUND_VOLUME_HACK
    // Fill-in the surround encoder volume levels
    pMixerSink->CenterVolume = pMixerSink->CenterVolume / 2;
    pMixerSink->SurroundVolume = 1.0f - pMixerSink->CenterVolume;
#endif

    RestoreFloatState(&FloatSave);
}


#define N_MAC(a) _asm { fadd DWORD PTR [esi-a*12] }; \
                    _asm { fxch st(1) }; \
                    _asm { fmul DWORD PTR [edi+a*12-8] }; \
                    _asm { fxch st(2) }; \
                    _asm { fadd DWORD PTR [esi-a*12-8] }; \
                    _asm { fxch st(1) }; \
                    _asm { fmul DWORD PTR [edi+a*12] }; \
                    _asm { fxch st(2) }; \
                    _asm { fadd DWORD PTR [esi-a*12-4] }; \
                    _asm { fxch st(1) }; \
                    _asm { fmul DWORD PTR [edi+a*12+8] }; \
                    _asm { fxch st(2) };

///////////////////////////////////////////////////////////////////////////////////////
//  Optimized SRC functions...
///////////////////////////////////////////////////////////////////////////////////////
DWORD __forceinline
SrcMix_X
(
    PMIXER_OPERATION    CurStage,
    ULONG               nSamples,
    ULONG               nOutputSamples,
    ULONG               Quality,
    BOOL                fMixOutput
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, j, k;
	DWORD   nCoefficients;
	PFLOAT	pHistory, pTemp, pHistoryStart;
	PFLOAT	pCoeff, pCoeffEnd;
	PFLOAT  pCoeffStart;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
#ifndef _X86_
    DWORD   coeffnum;
    FLOAT   sum;
#endif	
	FLOAT   Normalizer;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    FLOAT   flShifter =  25165824.0;
    ULONG   nSizeOfChannel;
    LONG    Multiplier, FirstSample, SecondSample;
    DWORD   dwFrac, SampleFrac;
    ULONG   nChannels = fp->nChannels;

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */
	j = fp->nOutCycle;
	nCoefficients = FilterSizeFromQuality[Quality];
    pHistory = (PFLOAT)CurStage->pInputBuffer - nChannels;
	pCoeff = fp->pCoeff + fp->CoeffIndex;
	pCoeffEnd = fp->pCoeff + fp->nCoeffUsed;
	Normalizer = fp->Normalizer;
	nSizeOfChannel = fp->csHistory;
	pHistoryStart = (PFLOAT)CurStage->pInputBuffer - fp->nSizeOfHistory;

    if (!fMixOutput) {
        // We just clear the output buffer first.
        ZeroBuffer32(CurStage, nSamples, nOutputSamples);
    }

    if (Quality == KSAUDIO_QUALITY_PC) {
        dwFrac = fp->dwFrac;
	    SampleFrac = fp->SampleFrac;
	    pHistory = (PFLOAT)CurStage->pInputBuffer - 2*nChannels;

        for (i=0; i<nOutputSamples; i++) {
			if ((SampleFrac >> 12)*nChannels >= (nSamples + 2)*nChannels)
				break;

            Multiplier = (SampleFrac & 4095);
            for (k=0; k<nChannels; k++) {
                FirstSample = ((PLONG)pHistory)[k+(SampleFrac >> 12)*nChannels];
                SecondSample = ((PLONG)pHistory)[k+nChannels+(SampleFrac >> 12)*nChannels];
                pOut[k] += FirstSample;
                pOut[k] += (((SecondSample - FirstSample)*Multiplier)/4096);
            }

            SampleFrac += dwFrac;
            pOut += nChannels;
        }
    } else {
#if INTEGER_INPUT_FOR_FLOAT_SRC
        // Change the input buffer to float
        pTemp = CurStage->pInputBuffer;
        i=nSamples*nChannels;
#ifndef _X86_       
        for (i=(nSamples*nChannels); i>0; i--) {
            ((PFLOAT)pTemp)[i-1] = (FLOAT) ((PLONG)pTemp)[i-1];
        }
#else
        _asm {
            mov esi, pTemp
            mov ecx, i

            cmp ecx, 0
            jz AllDone

            fild [esi]

            dec ecx
            jz Last1
LoopC:
            fstp [esi]

            fild [esi+4]

            add esi, 4
            dec ecx
            
            jnz LoopC
Last1:
            fstp [esi]
AllDone:
        }
#endif        
#endif        
    
    	/* Produce nOutputSamples samples generated from the input block */
    	// (loop executes once for each output sample)

    	for (i=0; i < nOutputSamples; i++) {
            while (j >= L) {
                // Take the next nChannels of input
                pHistory += nChannels;
                pTemp = pHistoryStart + nSizeOfChannel;
                pHistoryStart++;
                for (k=0; k<nChannels; k++) {
                    *((PLONG)pTemp) = ((PLONG)pHistory)[k];
                    pTemp += nSizeOfChannel;
                }
        		j -= L;
        	}
        	
    		if (Quality == KSAUDIO_QUALITY_WORST) {
       		    // This assumes the input buffer is a long integer.
        	    for (k=0; k<nChannels; k++) {
        	            pOut[k] += ((PLONG)pHistory)[k];
    		    }
    	    } else {
#ifndef _X86_
    	        pCoeffStart = pCoeff;
                for (k=nChannels; k>0; k--) {
            		// We multiply T / L of the taps (skipping the zero samples)
    	            pTemp = pHistoryStart+k*nSizeOfChannel-1;
    	            pCoeff = pCoeffStart;
                    sum = ((PFLOAT)pOut)[k-1];
    	            for (coeffnum = j; coeffnum < nCoefficients; coeffnum += L) {
    	                sum += ((*pTemp) * (*pCoeff));
    	                pTemp--;
    	                pCoeff++;
    	            }
                    ((PFLOAT)pOut)[k-1] = sum;
                }
#else	            
                pTemp = pHistoryStart + fp->nSizeOfHistory - 1 - 3;
                pCoeffStart = pCoeff + 3;
                _asm {
                    mov eax, j
                    mov edx, nCoefficients

                    sub eax, edx
                    mov ebx, L
                    
                    mov esi, pTemp

                    lea eax, [eax+2*ebx]
                    lea ebx, [ebx+2*ebx]        // 3*L

                    mov edi, nSizeOfChannel
                    
                    shl edi, 2
                    lea ecx, [ebx+4*ebx]        // 15*L

                    push edi                    // 4*nSizeOfChannel
                    
                    shl ecx, 2                  // 60*L

                    sub ecx, ebx                // 57*L

                    push ebx                    // 3*L

                    mov ebx, ecx                // 57*L
                    mov ecx, nChannels
                    
                    mov edi, pCoeffStart

                    push eax

ChannelLoop:                    
                    fld DWORD PTR [esi+4]       // c

                    fmul DWORD PTR [edi-4]      // c

                    fld DWORD PTR [esi+8]       // b, c

                    fld DWORD PTR [esi+12]      // a, b, c

                    fmul DWORD PTR [edi-12]     // a, b, c

                    add eax, ebx
                    jns SmallLoop
BigLoop:
                }

                N_MAC(0);
                N_MAC(1);
                N_MAC(2);
                N_MAC(3);
                N_MAC(4);
                N_MAC(5);
                N_MAC(6);
                N_MAC(7);
                N_MAC(8);
                N_MAC(9);
                N_MAC(10);
                N_MAC(11);
                N_MAC(12);
                N_MAC(13);
                N_MAC(14);
                N_MAC(15);
                N_MAC(16);
                N_MAC(17);
                N_MAC(18);

                _asm {
                    sub esi, 12*19
                    add edi, 12*19

                    add eax, ebx
                    js BigLoop

SmallLoop:
                    sub eax, ebx
                    mov edx, [esp+4]            // 3*L

                    add eax, edx
                    jns OneLoop

Loop1:
                }

                N_MAC(0);

                _asm {
                    sub esi, 12
                    add edi, 12

                    add eax, edx
                    js Loop1
                    
OneLoop:
                    sub eax, edx
                    mov edx, L

                    fxch st(1)                  // b, a, c

                    fmul DWORD PTR [edi-8]      // b, a, c
                    fxch st(1)                  // a, b, c

                    add eax, edx
                    jns LoopDone

Loop2:
                    fadd DWORD PTR [esi]        // a, b, c

                    sub esi, 4
                    add edi, 4

                    add eax, edx

                    fmul DWORD PTR [edi-4]        // a, b, c
                    fxch st(2)                  // c, b, a

                    fxch st(1)                  // b, c, a

                    js Loop2

LoopDone:                    
                    faddp st(1), st             // b+c, a

                    mov pCoeff, edi
                    mov edi, pOut
                    
                    mov esi, pTemp
                    mov eax, [esp+8]            // 4*nSizeOfChannel
                    
                    faddp st(1), st             // a+b+c

                    sub esi, eax
                    dec ecx

                    mov pTemp, esi           // pTemp

                    fadd DWORD PTR [edi+4*ecx]
                    
                    mov eax, [esp]
                    
                    fstp DWORD PTR [edi+4*ecx]
                    
                    mov edi, pCoeffStart
                    jnz ChannelLoop

                    add esp, 12
	            }
#endif	            
    	    }
            
    		if (pCoeff >= pCoeffEnd) {
    		    pCoeff = fp->pCoeff;
    		}
    		
    		pOut += nChannels;
            j += M;
    	}
    }

    nSamples -= (ULONG)(pHistoryStart + fp->nSizeOfHistory - (PFLOAT)CurStage->pInputBuffer);
    while (j >= L && nSamples) {
        // Take the next nChannels of input
        pHistory += nChannels;
        pTemp = pHistoryStart + nSizeOfChannel;
        pHistoryStart++;
        for (k=0; k<nChannels; k++) {
            *((PLONG)pTemp) = ((PLONG)pHistory)[k];
            pTemp += nSizeOfChannel;
        }
		j -= L;
    	nSamples--;
    }
    	
    // Copy last samples to history
    pTemp = (PFLOAT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory = pHistoryStart;
    if (Quality == KSAUDIO_QUALITY_PC) {
        pHistory = pTemp + nSamples * nChannels;
        
        if ((SampleFrac >> 12) >= nSamples) {
            // We will use the extra samples next time.
            SampleFrac -= nSamples*4096;
        }
        fp->SampleFrac = SampleFrac;
        nSamples = 0;
    }
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = (ULONG)(pCoeff - fp->pCoeff);

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

	return (nOutputSamples);
}

// WORST quality: no filter
DWORD SrcMix_Worst(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_WORST, TRUE);
}

DWORD Src_Worst(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_WORST, FALSE);
}

// PC quality
DWORD SrcMix_Linear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_PC, TRUE);
}

DWORD Src_Linear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_PC, FALSE);
}

// BASIC quality
DWORD SrcMix_Basic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_BASIC, TRUE);
}

DWORD Src_Basic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_BASIC, FALSE);
}

// ADVANCED quality
DWORD SrcMix_Advanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_ADVANCED, TRUE);
}

DWORD Src_Advanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_ADVANCED, FALSE);
}

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

DWORD
SrcMix_StereoLinear
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
#ifndef _X86_
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_PC, TRUE);
#else
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	DWORD 	nOut = 0, dwFrac, SampleFrac;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer, pDstEnd, pSrcEnd;
	
    dwFrac = fp->dwFrac;
    pHistory = (PLONG)CurStage->pInputBuffer - 2*nChannels;
	SampleFrac = fp->SampleFrac;
	pDstEnd = pOut + nOutputSamples * nChannels;
	pSrcEnd = pHistory + (nSamples + 2)*nChannels;
	
   _asm {
    	mov	esi, pHistory
    	mov	edi, pOut

    	push	dwFrac
    	push	pDstEnd
    	mov	eax, pSrcEnd
    	sub	eax, 8
    	push	eax
    	mov eax, SampleFrac		// Fractional counter.
    	push	ebp
    	mov	edx, esi
    	mov	ebp, eax		// Current fraction.

    	mov	ecx, eax
    	shr	ecx, 12
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	
    	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
    	jae	Exit

Top:
    	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
    	jae	Exit

    	mov	ecx, DWORD PTR [esi+8]
    	mov	ebx, DWORD PTR [esi]
    	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
    	sub	ecx, ebx		// x   = NewSample - OldSample
    	imul	ecx, ebp		// x  *= Frac
    	sar	ecx, 12			// x >>= 12
    	add	ecx, ebx		// NewSample += x
    	mov	ebx, DWORD PTR [edi]
    	add	ebx, ecx

    	mov	ecx, DWORD PTR [esi+12]
    	mov	DWORD PTR [edi], ebx

    	mov	ebx, DWORD PTR [esi+4]
    	sub	ecx, ebx		// x   = NewSample - OldSample
    	add	edi, 8			// plBuild += 2
    	imul	ecx, ebp		// x  *= Frac
    	sar	ecx, 12			// x >>= 12
    	mov	ebp, DWORD PTR [esp+12]	// dwStep
    	add	ecx, ebx		// NewSample += x
    	mov	ebx, DWORD PTR [edi-4]
    	add	eax, ebp		// dwFraction += dwStep
    	add	ebx, ecx
    	mov	ecx, eax
    	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

    	shr	ecx, 12
    	mov	ebp, eax
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd
    	jb	Top
Exit:
    	pop	ebp
    	add	esp, 12
    	mov pOut, edi
    	mov pHistory, esi
    	mov SampleFrac, eax
	}

    pTemp = (PLONG)CurStage->pInputBuffer - 2*nChannels;
    pHistory = pTemp + nSamples * nChannels;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];
    pTemp[2] = pHistory[2];
    pTemp[3] = pHistory[3];

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT((SampleFrac >> 12) >= nSamples);
#endif
    
    if ((SampleFrac >> 12) >= nSamples) {
        // We will take an extra sample next time.
        SampleFrac -= nSamples*4096;
    }
    fp->SampleFrac = SampleFrac;

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT(pOut == pDstEnd);
#endif

	return (nOutputSamples);
#endif
}

DWORD
Src_StereoLinear
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
#ifndef _X86_
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_PC, FALSE);
#else
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	DWORD 	nOut = 0, dwFrac, SampleFrac;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer, pDstEnd, pSrcEnd;
	
    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

    dwFrac = fp->dwFrac;
    pHistory = (PLONG)CurStage->pInputBuffer - 2*nChannels;
	SampleFrac = fp->SampleFrac;
	pDstEnd = pOut + nOutputSamples * nChannels;
	pSrcEnd = pHistory + (nSamples + 2)*nChannels;
	
   _asm {
    	mov	esi, pHistory
    	mov	edi, pOut

    	push	dwFrac
    	push	pDstEnd
    	mov	eax, pSrcEnd
    	sub	eax, 8
    	push	eax
    	mov eax, SampleFrac		// Fractional counter.
    	push	ebp
    	mov	edx, esi
    	mov	ebp, eax		// Current fraction.

    	mov	ecx, eax
    	shr	ecx, 12
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	
    	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
    	jae	Exit

Top:
    	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
    	jae	Exit

    	mov	ecx, DWORD PTR [esi+8]
    	mov	ebx, DWORD PTR [esi]
    	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
    	sub	ecx, ebx		// x   = NewSample - OldSample
    	imul	ecx, ebp		// x  *= Frac
    	sar	ecx, 12			// x >>= 12
    	add	ecx, ebx		// NewSample += x
    	mov	ebx, DWORD PTR [edi]
    	add	ebx, ecx

    	mov	ecx, DWORD PTR [esi+12]
    	mov	DWORD PTR [edi], ebx

    	mov	ebx, DWORD PTR [esi+4]
    	sub	ecx, ebx		// x   = NewSample - OldSample
    	add	edi, 8			// plBuild += 2
    	imul	ecx, ebp		// x  *= Frac
    	sar	ecx, 12			// x >>= 12
    	mov	ebp, DWORD PTR [esp+12]	// dwStep
    	add	ecx, ebx		// NewSample += x
    	mov	ebx, DWORD PTR [edi-4]
    	add	eax, ebp		// dwFraction += dwStep
    	add	ebx, ecx
    	mov	ecx, eax
    	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

    	shr	ecx, 12
    	mov	ebp, eax
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd
    	jb	Top
Exit:
    	pop	ebp
    	add	esp, 12
    	mov pOut, edi
    	mov pHistory, esi
    	mov SampleFrac, eax
	}

    pTemp = (PLONG)CurStage->pInputBuffer - 2*nChannels;
    pHistory = pTemp + nSamples * nChannels;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];
    pTemp[2] = pHistory[2];
    pTemp[3] = pHistory[3];

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT((SampleFrac >> 12) >= nSamples);
#endif
    if ((SampleFrac >> 12) >= nSamples) {
        // We will take an extra sample next time.
        SampleFrac -= nSamples*4096;
    }
    fp->SampleFrac = SampleFrac;

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT(pOut == pDstEnd);
#endif

	return (nOutputSamples);
#endif
}

DWORD
SrcMix_StereoUpNoFilter
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
#ifdef _X86_
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	LONG   j;
	DWORD 	nOut = 0;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer;

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */
	pHistory = (PLONG)CurStage->pInputBuffer - 2;
	j = fp->nOutCycle;

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)
    _asm {
        mov ecx, nOutputSamples
        mov esi, pHistory
        mov edi, pOut
        mov ebx, j
        mov edx, M
        push ebp
        cmp ecx, 0
        je  AllDone
Loop1:
        cmp ebx, 160
        jb DoNext

        sub ebx, 160
        add esi, 8
DoNext:
        mov eax, [esi]
        mov ebp, [edi]

        add eax, ebp
        mov ebp, [edi+4]

        mov [edi], eax
        mov eax, [esi+4]

        add eax, ebp
        add ebx, edx

        mov [edi+4], eax
        add edi, 8

        dec ecx
        jnz Loop1
AllDone:
        pop ebp
        
        mov pHistory, esi
        mov j, ebx
        }

    nSamples -= (pHistory - (PLONG)CurStage->pInputBuffer + 2)/2;
    if (j >= (STOPBAND_FACTOR/2) && nSamples) {
        pHistory += 2;
   		j -= (STOPBAND_FACTOR/2);
   		nSamples--;
   	}
    	
    // Copy last samples to history
    pTemp = (PLONG)CurStage->pInputBuffer - 2;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];

	fp->nOutCycle = j;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

	return (nOutputSamples);
#else
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_WORST, TRUE);
#endif
}

DWORD
Src_StereoUpNoFilter
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
#ifdef _X86_
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	LONG   j;
	DWORD 	nOut = 0;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer;

    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */
	pHistory = (PLONG)CurStage->pInputBuffer - 2;
	j = fp->nOutCycle;

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)
    _asm {
        mov ecx, nOutputSamples
        mov esi, pHistory
        mov edi, pOut
        mov ebx, j
        mov edx, M
        push ebp
        cmp ecx, 0
        je  AllDone
Loop1:
        cmp ebx, 160
        jb DoNext

        sub ebx, 160
        add esi, 8
DoNext:
        mov eax, [esi]
        mov ebp, [edi]

        add eax, ebp
        mov ebp, [edi+4]

        mov [edi], eax
        mov eax, [esi+4]

        add eax, ebp
        add ebx, edx

        mov [edi+4], eax
        add edi, 8

        dec ecx
        jnz Loop1
AllDone:
        pop ebp
        
        mov pHistory, esi
        mov j, ebx
        }

    nSamples -= (pHistory - (PLONG)CurStage->pInputBuffer + 2)/2;
    if (j >= (STOPBAND_FACTOR/2) && nSamples) {
        pHistory += 2;
   		j -= (STOPBAND_FACTOR/2);
   		nSamples--;
   	}
    	
    // Copy last samples to history
    pTemp = (PLONG)CurStage->pInputBuffer - 2;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];

	fp->nOutCycle = j;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

	return (nOutputSamples);
#else
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	return SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_WORST, FALSE);
#endif
}

#define STEREO_MAC(a) _asm {  fadd DWORD PTR [esi-a*8-8 ] };  \
            _asm { fxch st(2)  }; \
            _asm { fmul DWORD PTR [edi+a*4] }; \
            _asm { fxch st(1)  }; \
            _asm { fadd DWORD PTR [esi-a*8-12	]   }; \
            _asm { fxch st(3)  }; \
            _asm { fmul DWORD PTR [edi+a*4] }; \
            _asm { fxch st(1) };

#define START_STEREO_MAC_SEQUENCE() _asm { mov esi, pHistory }; \
            _asm { mov edi, pCoeff }; \
            _asm { fld DWORD PTR [esi] }; \
            _asm { fmul DWORD PTR [edi] }; \
            _asm { fld DWORD PTR [esi-12] }; \
            _asm { fxch st(1) }; \
            _asm { fld DWORD PTR [esi-8] }; \
            _asm { fxch st(1) }; \
            _asm { fld DWORD PTR [esi-4] }; \
            _asm { fmul DWORD PTR [edi] }; \
            _asm { fxch st(1) };

#define END_STEREO_MAC_SEQUENCE(a) _asm { mov eax, pOut }; \
            _asm { fadd DWORD PTR [eax+4] }; \
            _asm { fxch st(2) }; \
            _asm { fmul DWORD PTR [edi+a*4] }; \
            _asm { fxch st(1) }; \
            _asm { fadd DWORD PTR [eax] }; \
            _asm { fxch st(3) }; \
            _asm { fmul DWORD PTR [edi+a*4] }; \
            _asm { fxch st(1) }; \
            _asm { faddp st(2), st }; \
            _asm { faddp st(2), st }; \
            _asm { fstp DWORD PTR [eax+4] }; \
            _asm { fstp DWORD PTR [eax] };

DWORD SrcMix_StereoUpBasic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
#ifdef _X86_
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, j;
	PFLOAT	pHistory, pTemp;
	PFLOAT	pCoeff, pCoeffEnd;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    static FLOAT flShifter =  25165824.0;
    
	// Since we are up-sampling, we know that L is STOPBAND_FACTOR / 2.
			
	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */
	j = fp->nOutCycle;
   	pHistory = (PFLOAT)CurStage->pInputBuffer - 1;
	pCoeff = fp->pCoeff+fp->CoeffIndex;
	pCoeffEnd = fp->pCoeff + fp->nCoeffUsed;

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)
	for (i=0; i < nOutputSamples; i++) {
        if (j >= (STOPBAND_FACTOR/2)) {
		    pHistory += 2;
    		j -= (STOPBAND_FACTOR/2);
    	}
    	
   		// We multiply T / L of the taps (skipping the zero samples)
   		START_STEREO_MAC_SEQUENCE();
        STEREO_MAC(1);      // sum2*c1, sum1*c1, sum4, sum3
        STEREO_MAC(2);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(3);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(4);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(5);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(6);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(7);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(8);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(9);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(10);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(11);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(12);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(13);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(14);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(15);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(16);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(17);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(18);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(19);     // sum2*coeff, sum1*coeff, sum4, sum3
        END_STEREO_MAC_SEQUENCE(20);
        
		pOut += 2;
		pCoeff += FILTER_SIZE_BASIC/(STOPBAND_FACTOR/2);
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = fp->pCoeff;
		}
		
        j += M;
	}

    nSamples -= (pHistory - (PFLOAT)CurStage->pInputBuffer + 1)/2;
    if (j >= (STOPBAND_FACTOR/2) && nSamples) {
        pHistory += 2;
   		j -= (STOPBAND_FACTOR/2);
   		nSamples--;
   	}
    	
    // Copy last samples to history
    pTemp = (PFLOAT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory -= (fp->nSizeOfHistory - 1);
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

#else
	nOutputSamples = SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_BASIC, TRUE);
#endif

	return (nOutputSamples);
}

DWORD Src_StereoUpBasic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
#ifdef _X86_
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, j;
	PFLOAT	pHistory, pTemp;
	PFLOAT	pCoeff, pCoeffEnd;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    static FLOAT flShifter =  25165824.0;
    
    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

	// Since we are up-sampling, we know that L is STOPBAND_FACTOR / 2.
			
	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */
	j = fp->nOutCycle;
   	pHistory = (PFLOAT)CurStage->pInputBuffer - 1;
	pCoeff = fp->pCoeff+fp->CoeffIndex;
	pCoeffEnd = fp->pCoeff + fp->nCoeffUsed;

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)
	for (i=0; i < nOutputSamples; i++) {
        if (j >= (STOPBAND_FACTOR/2)) {
		    pHistory += 2;
    		j -= (STOPBAND_FACTOR/2);
    	}
    	
   		// We multiply T / L of the taps (skipping the zero samples)
   		START_STEREO_MAC_SEQUENCE();
        STEREO_MAC(1);      // sum2*c1, sum1*c1, sum4, sum3
        STEREO_MAC(2);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(3);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(4);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(5);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(6);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(7);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(8);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(9);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(10);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(11);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(12);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(13);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(14);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(15);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(16);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(17);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(18);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(19);     // sum2*coeff, sum1*coeff, sum4, sum3
        END_STEREO_MAC_SEQUENCE(20);
        
		pOut += 2;
		pCoeff += FILTER_SIZE_BASIC/(STOPBAND_FACTOR/2);
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = fp->pCoeff;
		}
		
        j += M;
	}

    nSamples -= (pHistory - (PFLOAT)CurStage->pInputBuffer + 1)/2;
    if (j >= (STOPBAND_FACTOR/2) && nSamples) {
        pHistory += 2;
   		j -= (STOPBAND_FACTOR/2);
   		nSamples--;
   	}
    	
    // Copy last samples to history
    pTemp = (PFLOAT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory -= (fp->nSizeOfHistory - 1);
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

#else
	nOutputSamples = SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_BASIC, FALSE);
#endif

	return (nOutputSamples);
}

// Advanced quality: large filter
DWORD SrcMix_StereoUpAdvanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
#ifdef _X86_
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, j;
	PFLOAT	pHistory, pTemp;
	PFLOAT	pCoeff, pCoeffEnd;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    static FLOAT flShifter =  25165824.0;
    
	// Since we are up-sampling, we know that L is STOPBAND_FACTOR / 2.
	// and nSizeOfHistory = nChannels*FILTER_SIZE_LOW/L = 4*FILTER_SIZE_LOW/STOPBAND_FACTOR

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */
	j = fp->nOutCycle;
   	pHistory = (PFLOAT)CurStage->pInputBuffer - 1;
	pCoeff = fp->pCoeff+fp->CoeffIndex;
	pCoeffEnd = fp->pCoeff + fp->nCoeffUsed;

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)
	for (i=0; i < nOutputSamples; i++) {
        if (j >= (STOPBAND_FACTOR/2)) {
		    pHistory += 2;
    		j -= (STOPBAND_FACTOR/2);
    	}
    	
   		// We multiply T / L of the taps (skipping the zero samples)
   		START_STEREO_MAC_SEQUENCE();
        STEREO_MAC(1);      // sum2*c1, sum1*c1, sum4, sum3
        STEREO_MAC(2);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(3);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(4);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(5);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(6);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(7);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(8);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(9);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(10);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(11);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(12);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(13);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(14);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(15);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(16);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(17);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(18);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(19);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(20);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(21);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(22);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(23);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(24);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(25);    // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(26);    // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(27);    // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(28);    // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(29);    // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(30);    // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(31);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(32);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(33);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(34);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(35);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(36);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(37);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(38);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(39);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(40);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(41);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(42);       // sum4*c42, sum3*c42, sum2, sum1
        STEREO_MAC(43);        // sum2*c43, sum1*c43, sum4*c42+y0, sum3*c42+x0
        STEREO_MAC(44);
        STEREO_MAC(45);
        STEREO_MAC(46);
        STEREO_MAC(47);
        STEREO_MAC(48);
        STEREO_MAC(49);
        STEREO_MAC(50);
        STEREO_MAC(51);
        STEREO_MAC(52);
        STEREO_MAC(53);
        STEREO_MAC(54);
        STEREO_MAC(55);
        STEREO_MAC(56);
        STEREO_MAC(57);
        STEREO_MAC(58);
        END_STEREO_MAC_SEQUENCE(59);
		pOut += 2;
		pCoeff += FILTER_SIZE_ADVANCED/(STOPBAND_FACTOR/2);
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = fp->pCoeff;
		}
		
        j += M;
	}

    nSamples -= (pHistory - (PFLOAT)CurStage->pInputBuffer + 1)/2;
    if (j >= (STOPBAND_FACTOR/2) && nSamples) {
        pHistory += 2;
   		j -= (STOPBAND_FACTOR/2);
   		nSamples--;
   	}
    	
    // Copy last samples to history
    pTemp = (PFLOAT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory -= (fp->nSizeOfHistory - 1);
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

#else
    nOutputSamples = SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_ADVANCED, TRUE);
#endif

	return (nOutputSamples);
}
            
// Advanced quality: large filter
DWORD Src_StereoUpAdvanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples)
{
#ifdef _X86_
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, j;
	PFLOAT	pHistory, pTemp;
	PFLOAT	pCoeff, pCoeffEnd;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    static FLOAT flShifter =  25165824.0;
    
    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

	// Since we are up-sampling, we know that L is STOPBAND_FACTOR / 2.
	// and nSizeOfHistory = nChannels*FILTER_SIZE_LOW/L = 4*FILTER_SIZE_LOW/STOPBAND_FACTOR

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */
	j = fp->nOutCycle;
   	pHistory = (PFLOAT)CurStage->pInputBuffer - 1;
	pCoeff = fp->pCoeff+fp->CoeffIndex;
	pCoeffEnd = fp->pCoeff + fp->nCoeffUsed;

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)
	for (i=0; i < nOutputSamples; i++) {
        if (j >= (STOPBAND_FACTOR/2)) {
		    pHistory += 2;
    		j -= (STOPBAND_FACTOR/2);
    	}
    	
   		// We multiply T / L of the taps (skipping the zero samples)
   		START_STEREO_MAC_SEQUENCE();
        STEREO_MAC(1);      // sum2*c1, sum1*c1, sum4, sum3
        STEREO_MAC(2);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(3);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(4);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(5);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(6);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(7);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(8);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(9);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(10);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(11);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(12);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(13);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(14);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(15);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(16);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(17);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(18);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(19);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(20);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(21);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(22);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(23);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(24);     // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(25);    // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(26);    // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(27);    // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(28);    // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(29);    // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(30);    // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(31);     // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(32);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(33);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(34);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(35);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(36);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(37);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(38);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(39);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(40);      // sum4*coeff, sum3*coeff, sum2, sum1
        STEREO_MAC(41);      // sum2*coeff, sum1*coeff, sum4, sum3
        STEREO_MAC(42);       // sum4*c42, sum3*c42, sum2, sum1
        STEREO_MAC(43);        // sum2*c43, sum1*c43, sum4*c42+y0, sum3*c42+x0
        STEREO_MAC(44);
        STEREO_MAC(45);
        STEREO_MAC(46);
        STEREO_MAC(47);
        STEREO_MAC(48);
        STEREO_MAC(49);
        STEREO_MAC(50);
        STEREO_MAC(51);
        STEREO_MAC(52);
        STEREO_MAC(53);
        STEREO_MAC(54);
        STEREO_MAC(55);
        STEREO_MAC(56);
        STEREO_MAC(57);
        STEREO_MAC(58);
        END_STEREO_MAC_SEQUENCE(59);
		pOut += 2;
		pCoeff += FILTER_SIZE_ADVANCED/(STOPBAND_FACTOR/2);
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = fp->pCoeff;
		}
		
        j += M;
	}

    nSamples -= (pHistory - (PFLOAT)CurStage->pInputBuffer + 1)/2;
    if (j >= (STOPBAND_FACTOR/2) && nSamples) {
        pHistory += 2;
   		j -= (STOPBAND_FACTOR/2);
   		nSamples--;
   	}
    	
    // Copy last samples to history
    pTemp = (PFLOAT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory -= (fp->nSizeOfHistory - 1);
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

#else
    nOutputSamples = SrcMix_X(CurStage, nSamples, nOutputSamples, KSAUDIO_QUALITY_ADVANCED, FALSE);
#endif

	return (nOutputSamples);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\driver\debug.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

#ifndef _DEBUG_H_
#define _DEBUG_H_

//
// Modified version of ksdebug.h to support runtime debug level changes.
//
const int DBG_NONE     = 0x00000000;
const int DBG_PRINT    = 0x00000001; // Blabla. Function entries for example
const int DBG_WARNING  = 0x00000002; // warning level
const int DBG_ERROR    = 0x00000004; // this doesn't generate a breakpoint
const int DBG_STREAM   = 0x00000010; // For stream messages
const int DBG_SYSTEM   = 0x10000000; // For system information messages
const int DBG_ALL      = 0xFFFFFFFF;

//
// The default statements that will print are warnings (DBG_WARNING) and
// errors (DBG_ERROR).
//
const int DBG_DEFAULT = DBG_WARNING | DBG_ERROR;

//
// Define global debug variable.
//
#ifdef DEFINE_DEBUG_VARS
#if (DBG)
unsigned long ulDebugOut = DBG_DEFAULT;
#endif

#else // !DEFINED_DEBUG_VARS
#if (DBG)
extern unsigned long ulDebugOut;
#endif
#endif

//
// Define the print statement.
//
#if defined(__cplusplus)
extern "C" {
#endif // #if defined(__cplusplus)

//
// DBG is 1 in checked builds
//
#if (DBG)
#define DOUT(lvl, strings)          \
    if ((lvl) & ulDebugOut)         \
    {                               \
        DbgPrint(STR_MODULENAME);   \
        DbgPrint##strings;          \
        DbgPrint("\n");             \
    }

#define BREAK()                     \
    DbgBreakPoint()

#else // if (!DBG)
#define DOUT(lvl, strings)
#define BREAK()
#endif // !DBG    

#if defined(__cplusplus)
}
#endif // #if defined(__cplusplus)

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\driver\device.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// We want the global debug variables here.
//
#define DEFINE_DEBUG_VARS

//
// Every debug output has "STR_MODULENAME text"
//
static char STR_MODULENAME[] = "GFX device: ";

#include "common.h"

//
// The table points to the filter descriptors of the device.
// We have only one filter descriptor which is defined in filter.cpp
//
DEFINE_KSFILTER_DESCRIPTOR_TABLE (FilterDescriptorTable)
{   
    &FilterDescriptor
};

//
// This defines the device descriptor. It has a dispatch table +
// the filter descriptors.
// We do not need to intercept PnP messages, so we keep the dispatch table
// empty and KS will deal with that.
//
const KSDEVICE_DESCRIPTOR DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptorTable),
    FilterDescriptorTable
};

/**************************************************************************
 * DriverEntry
 **************************************************************************
 * This function is called by the operating system when the filter is loaded.
 */
extern "C"
NTSTATUS DriverEntry (IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPathName)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("DriverEntry"));

    return KsInitializeDriver (pDriverObject, pRegistryPathName, &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\driver\common.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

#define _WDMDDK_        // secret hacks ...
extern "C" {
    #include <ntddk.h>
} // extern "C"

#include <unknown.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <kcom.h>
#include <drmk.h>

#include "debug.h"
#include "filter.h"
#include "pin.h"

//
// Put your own pool tag here. 'pawS' is backwards for 'Swap'.
//
#define GFXSWAP_POOL_TAG    'pawS'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\vmaxhead.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    vmaxhead.h

Abstract:

    This module implements floating point, IIR 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/


#if !defined(VMAXINTHEADER_HEADER)
#define VMAXINTHEADER_HEADER
#pragma once

// ---------------------------------------------------------------------------
// Typedefs

typedef LONG STATUS;

// ---------------------------------------------------------------------------
// Defines

#define STATUS_OK 0
#define STATUS_ERROR 1

// ---------------------------------------------------------------------------
// Enumerations

// Output channel tags
typedef enum {
	tagLeft,
	tagRight,
	echannelCount
} EChannel;

// Filter tags, used as alias for EChannel tags
typedef enum {
	tagDelta,
	tagSigma,
	efilterCount
} EFilter;

// Sample rates
typedef enum {
	tag8000Hz,
	tag11025Hz,
	tag16000Hz,
	tag22050Hz,
	tag32000Hz,
	tag44100Hz,
	tag48000Hz,
	esamplerateCount
} ESampleRate;

// Maximum number of biquads in fixed-point filter
#define MAX_BIQUADS 6

#define MaxSaturation SHRT_MAX
#define MinSaturation SHRT_MIN

// Filter methods
/*
typedef enum {
	DFI_TRANS_WITH_UNITY_B0,
	DFI_TRANS,
	DFII_WITH_UNITY_B0,
	DFII,
	BIQ_DFI,
	BIQ_DFI_TRANS,
	BIQ_DFII,
	BIQ_DFII_TRANS,
	FILTER_METHOD_COUNT
} IIR_FILTER_METHOD;
*/
/*
typedef enum {
	DIRECT_FORM,
	CASCADE_FORM,
	FILTER_METHOD_COUNT
} IIR_FILTER_METHOD;
*/


/*
// Coefficient formats
enum ECoeffFormat {
	tagFloat,
	tagShort,
	ecoeffformatCount
};

// Filter methods
typedef enum {
	tagCanonical,
	tagJackson,
	efiltermethodCount
} EFilterMethod; 

// DirectSound cooperative levels
enum ECoopLevel {
	tagNormal,
	tagPriority,
	tagExclusive,
	ecooplevelCount
};

// DirectSound speaker configurations
enum EDSSpeakerConfig {
	tagDSHeadphones,
	tagDSSpeakers10Degrees,
	tagDSSpeakers20Degrees,
	edsspeakerconfigCount
};
*/

#endif

// End of VMAXINTHEADER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\driver\filter.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

typedef class CGFXFilter
{
public:
    BOOL        enableChannelSwap;
    ULONGLONG   bytesProcessed;

public:
    CGFXFilter() {enableChannelSwap = TRUE, bytesProcessed = 0;}
    ~CGFXFilter() {}

    //
    // Create and Close are used to construct and destruct, respectively the
    // client CGFXFilter object.  Process gets called by the ks when there 
    // is work to be done. 
    //
    static NTSTATUS Create
    (
        IN OUT PKSFILTER filter,
        IN PIRP          irp
    );
    static NTSTATUS Close
    (
        IN OUT PKSFILTER filter,
        IN PIRP          irp
    );
    static NTSTATUS Process
    (
        IN PKSFILTER                filter,
        IN PKSPROCESSPIN_INDEXENTRY processPinsIndex
    );
} GFXFILTER, *PGFXFILTER;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern const KSFILTER_DESCRIPTOR FilterDescriptor;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------
// These are all properties function prototypes. Feel free to move them
// into a "FilterProperty" object if you want.

NTSTATUS PropertySaveState
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN OUT PVOID    data
);
NTSTATUS PropertyGetFilterState
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    OUT PVOID       data
);

NTSTATUS PropertySetRenderTargetDeviceId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        data
);

NTSTATUS PropertySetCaptureTargetDeviceId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        data
);

NTSTATUS PropertyDrmSetContentId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        drmData
);

NTSTATUS PropertyChannelSwap
(
    IN     PIRP        irp,
    IN     PKSPROPERTY property,
    IN OUT PVOID       data
);

NTSTATUS PropertyAudioPosition
(
    IN PIRP                  irp,
    IN PKSPROPERTY           property,
    IN OUT PKSAUDIO_POSITION position
);

NTSTATUS DataRangeIntersection
(
    IN PVOID            Filter,
    IN PIRP             Irp,
    IN PKSP_PIN         PinInstance,
    IN PKSDATARANGE     CallerDataRange,
    IN PKSDATARANGE     DescriptorDataRange,
    IN ULONG            BufferSize,
    OUT PVOID           Data OPTIONAL,
    OUT PULONG          DataSize
);

NTSTATUS PropertyDataFormat
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN PVOID        pVoid
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\driver\filter.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// Every debug output has "Modulname text"
//
static char STR_MODULENAME[] = "GFX filter: ";

#include "common.h"
#include <msgfx.h>

//
// These defines are used to describe the framing requirements.
// MAX_NUMBER_OF_FRAMES are the max number of frames that float between the
// output pin of this filter and the input pin of the lower filter (which
// would be the audio driver) and FRAME_SIZE is the buffer (frame) size.
// 3306 is the max. size of a 10ms buffer (55010Hz * 24bit * stereo). The
// buffers don't get filled completely if not neccessary.
//
#define MAX_NUMBER_OF_FRAMES    8
#define FRAME_SIZE              3306

//
// Define the pin data range here. Since we are an autoload GFX that loads on
// the Microsoft USB speakers (DSS 80), we have to support the same data range
// than the USB speakers.
// If you do not support the same data range then you restrict the audio stack
// from the mixer down with your limitations. For example, in case you would
// only support 48KHz 16 bit stereo PCM data then only this can be played by
// the audio driver even though it might have the ability to play 44.1KHz
// also.
// List the data ranges in the preferred connection order, that means, first
// list the data range you always would like to connect with the audio driver,
// if the DataRangeIntersection with the audio driver fails, then the second
// data range gets used etc.
// Please don't use wildcards in the data range, because ValidateDataFormat
// and the DataRangeIntersection functions wouldn't work anymore. Both
// functions also only work with KSDATAFORMAT_SPECIFIER_WAVEFORMATEX. If your
// device can handle float or other formats then you need to modify those
// functions. Also take a look at GFXPinSetDataFormat.
//
const KSDATARANGE_AUDIO PinDataRanges[] = 
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            6,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),              // major format
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),             // sub format
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)   // wave format
        },
        2,          // channels
        24,         // min. bits per sample
        24,         // max. bits per sample
        4990,       // min. sample rate
        55010       // max. sample rate
    },
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            4,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),              // major format
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),             // sub format
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)   // wave format
        },
        2,          // channels
        16,         // min. bits per sample
        16,         // max. bits per sample
        4990,       // min. sample rate
        55010       // max. sample rate
    }

};

//
// This structure points to the different pin data ranges that we defined.
//
const PKSDATARANGE DataRanges[] =
{
    PKSDATARANGE(&PinDataRanges[0]),        // the 24bit data range
    PKSDATARANGE(&PinDataRanges[1])         // the 16bit data range
};

//
// This will define the framing requirements that are used in the pin descrip-
// tor. Note that we can also deal with other framing requirements as the flag
// KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY indicates. Note also that KS will
// allocate the non-paged buffers (MAX_NUMBER_OF_FRAMES * FRAME_SIZE) for you,
// so don't be too greedy here.
//
DECLARE_SIMPLE_FRAMING_EX
(
    AllocatorFraming,                               // Name of the framing structure
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED,              // memory type that's used for allocation
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |        // flags
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    MAX_NUMBER_OF_FRAMES,                           // max. number of frames
    31,                                             // 32-byte alignment
    FRAME_SIZE,                                     // min. frame size
    FRAME_SIZE                                      // max. frame size
);

//
// DEFINE_KSPROPERTY_TABLE defines a KSPROPERTY_ITEM. We use these macros to
// define properties in a property set. A property set is represented as a GUID.
// It contains property items that have a functionality. You could imagine that
// a property set is a function group and a property a function. An example for
// a property set is KSPROPSETID_Audio, a property item in this set is for
// example KSPROPERTY_AUDIO_POSITION
// We add here the pre-defined (in ksmedia.h) property for the audio position
// to the pin.
//

//
// Define the KSPROPERTY_AUDIO_POSITION property item.
//
DEFINE_KSPROPERTY_TABLE (AudioPinPropertyTable)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIO_POSITION,      // property item defined in ksmedia.h
        PropertyAudioPosition,          // our "get" property handler
        sizeof(KSPROPERTY),             // minimum buffer length for property
        sizeof(KSAUDIO_POSITION),       // minimum buffer length for returned data
        PropertyAudioPosition,          // our "set" property handler
        NULL,                           // default values
        0,                              // related properties
        NULL,
        NULL,                           // no raw serialization handler
        0                               // don't serialize
    )
};

//
// Define the KSPROPERTY_DRMAUDIOSTREAM_CONTENTID property item.
//
DEFINE_KSPROPERTY_TABLE (PinPropertyTable_DRM)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,    // property item defined in ksmedia.h
        NULL,                                   // does not support "get"
        sizeof(KSPROPERTY),                     // minimum buffer length for property
        sizeof(ULONG)+sizeof(DRMRIGHTS),        // minimum buffer length for returned data
        PropertyDrmSetContentId,                // our "set" property handler
        NULL,                                   // default values
        0,                                      // related properties
        NULL,
        NULL,                                   // no raw serialization handler
        0                                       // don't serialize
    )
};

//
// Define the property sets KSPROPSETID_Audio and KSPROPSETID_Connection.
// They both will be added to the pin descriptor through the automation table.
//
DEFINE_KSPROPERTY_SET_TABLE (PinPropertySetTable)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Audio,                     // property set defined in ksmedia.h
        SIZEOF_ARRAY(AudioPinPropertyTable),    // the properties supported
        AudioPinPropertyTable,
        0,                                      // reserved
        NULL                                    // reserved
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_DrmAudioStream,            // property set defined in ksmedia.h
        SIZEOF_ARRAY(PinPropertyTable_DRM),     // the properties supported
        PinPropertyTable_DRM,
        0,                                      // reserved
        NULL                                    // reserved
    )
};

//
// This defines the automation table. The automation table will be added to
// the pin descriptor and has pointers to the porperty (set) table, method
// table and event table.
//
DEFINE_KSAUTOMATION_TABLE (PinAutomationTable)
{
    DEFINE_KSAUTOMATION_PROPERTIES (PinPropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
// This defines the pin dispatch table. We need to provide our own dispatch
// functions because we have special requirements (for example, input and
// output pin need to have the same sample format).
//
const KSPIN_DISPATCH GFXSinkPinDispatch =
{
    CGFXPin::Create,            // Create
    CGFXPin::Close,             // Close
    NULL,                       // Process
    NULL,                       // Reset
    CGFXPin::SetDataFormat,     // SetDataFormat
    CGFXPin::SetDeviceState,    // SetDeviceState
    NULL,                       // Connect
    NULL,                       // Disconnect
    NULL,                       // Clock
    NULL                        // Allocator
};

const KSPIN_DISPATCH GFXSourcePinDispatch =
{
    NULL,                       // Create
    NULL,                       // Close
    NULL,                       // Process
    NULL,                       // Reset
    CGFXPin::SetDataFormat,     // SetDataFormat
    NULL,                       // SetDeviceState
    NULL,                       // Connect
    NULL,                       // Disconnect
    NULL,                       // Clock
    NULL                        // Allocator
};

//
// This defines the pin descriptor for a filter.
// The pin descriptor has pointers to the dispatch functions, automation
// tables, basic pin descriptor etc. - just everything you need ;)
//
const KSPIN_DESCRIPTOR_EX PinDescriptors[]=
{
    {   // This is the first pin. It's the top pin of the filter for incoming
        // data flow

        &GFXSinkPinDispatch,                    // dispatch table
        &PinAutomationTable,                    // automation table
        {                                       // basic pin descriptor
            DEFINE_KSPIN_DEFAULT_INTERFACES,    // default interfaces
            DEFINE_KSPIN_DEFAULT_MEDIUMS,       // default mediums
            SIZEOF_ARRAY(DataRanges),           // pin data ranges
            DataRanges,
            KSPIN_DATAFLOW_IN,                  // data flow in (into the GFX)
            KSPIN_COMMUNICATION_BOTH,           // KS2 will handle that
            NULL,                               // Category GUID
            NULL,                               // Name GUID
            0                                   // ConstrainedDataRangesCount
        },
        NULL,                                   // Flags. Since we are filter centric, these flags
                                                // won't effect anything
        1,                                      // max. InstancesPossible
        1,                                      // InstancesNecessary for processing
        &AllocatorFraming,                      // Allocator framing requirements.
        CGFXPin::DataRangeIntersection          // Out data intersection handler (we need one!)
    },
    
    {   // This is the second pin. It's the bottom pin of the filter for outgoing
        // data flow. Everything is the same as above, except for the data flow
        // and the pin dispatch table.
        &GFXSourcePinDispatch,
        &PinAutomationTable,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(DataRanges),
            DataRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,
            NULL,
            0
        },
        NULL,
        1,
        1,
        &AllocatorFraming,
        CGFXPin::DataRangeIntersection
    }
};

//
// DEFINE_KSPROPERTY_TABLE defines a KSPROPERTY_ITEM. We use these macros to
// define properties in a property set. A property set is represented as a
// GUID. It contains property items that have a functionality. You could
// imagine that a property set is a function group and a property a function.
// An example for a property set is KSPROPSETID_Audio, a property item in this
// set is for example KSPROPERTY_AUDIO_POSITION.
// We add here our private property for controlling the GFX (channel swap
// on/off) which will be added to the node descriptor.
//

//
// Define our private KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property item.
//
DEFINE_KSPROPERTY_TABLE (AudioNodePropertyTable)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP, // property item defined in msgfx.h
        PropertyChannelSwap,                // our "get" property handler
        sizeof(KSP_NODE),                   // minimum buffer length for property
        sizeof(ULONG),                      // minimum buffer length for returned data
        PropertyChannelSwap,                // our "set" property handler
        NULL,                               // default values
        0,                                  // related properties
        NULL,
        NULL,                               // no raw serialization handler
        sizeof(ULONG)                       // Serialized size
    )
};

//
// Define the private property set KSPROPSETID_MsGfxSample.
// The property set will be added to the node descriptor through the automation
// table.
//
DEFINE_KSPROPERTY_SET_TABLE (NodePropertySetTable)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_MsGfxSample,               // property set defined in msgfx.h
        SIZEOF_ARRAY(AudioNodePropertyTable),   // the properties supported
        AudioNodePropertyTable,
        0,                                      // reserved
        NULL                                    // reserved
    )
};

//
// This defines the automation table. The automation table will be added to
// the node descriptor and has pointers to the porperty (set) table, method
// table and event table.
//
DEFINE_KSAUTOMATION_TABLE (NodeAutomationTable)
{
    DEFINE_KSAUTOMATION_PROPERTIES (NodePropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
// This defines the node descriptor for a (filter) node.
// The node descriptor has pointers to the automation table and the type & name
// of the node.
// We have only one node that is for the private property.
//
const KSNODE_DESCRIPTOR NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR
    (
        &NodeAutomationTable,               // Automation table (for the properties)
        &GFXSAMPLE_NODETYPE_CHANNEL_SWAP,   // Type of node
        &GFXSAMPLE_NODENAME_CHANNEL_SWAP    // Name of node
    )
};

//
// Define our private KSPROPERTY_MSGFXSAMPLE_SAVESTATE property item.
//
DEFINE_KSPROPERTY_TABLE (FilterPropertyTable_SaveState)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_MSGFXSAMPLE_SAVESTATE,   // property item defined in msgfx.h
        PropertySaveState,                  // our "get" property handler
        sizeof(KSPROPERTY),                 // minimum buffer length for property
        sizeof(ULONG),                      // minimum buffer length for returned data
        PropertySaveState,                  // our "set" property handler
        NULL,                               // default values
        0,                                  // related properties
        NULL,
        NULL,                               // no raw serialization handler
        sizeof(ULONG)                       // Serialized size
    )
};

//
// Define the items for the property set KSPROPSETID_AudioGfx, which are
// KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID and
// KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID.
//
DEFINE_KSPROPERTY_TABLE (FilterPropertyTable_AudioGfx)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,   // property item defined in msgfx.h
        NULL,                                       // no "get" property handler
        sizeof(KSPROPERTY),                         // minimum buffer length for property
        sizeof(WCHAR),                              // minimum buffer length for returned data
        PropertySetRenderTargetDeviceId,            // our "set" property handler
        NULL,                                       // default values
        0,                                          // related properties
        NULL,
        NULL,                                       // no raw serialization handler
        0                                           // don't serialize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID,  // property item defined in msgfx.h
        NULL,                                       // no "get" property handler
        sizeof(KSPROPERTY),                         // minimum buffer length for property
        sizeof(WCHAR),                              // minimum buffer length for returned data
        PropertySetCaptureTargetDeviceId,           // our "set" property handler
        NULL,                                       // default values
        0,                                          // related properties
        NULL,
        NULL,                                       // no raw serialization handler
        0                                           // don't serialize
    )
};

//
// Define the items for the property set KSPROPSETID_Audio, which are
// KSPROPERTY_AUDIO_FILTER_STATE.
//
DEFINE_KSPROPERTY_TABLE (FilterPropertyTable_Audio)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIO_FILTER_STATE,      // property item defined in msgfx.h
        PropertyGetFilterState,             // our "get" property handler
        sizeof(KSPROPERTY),                 // minimum buffer length for property
        0,                                  // minimum buffer length for returned data
        NULL,                               // no "set" property handler
        NULL,                               // default values
        0,                                  // related properties
        NULL,
        NULL,                               // no raw serialization handler
        0                                   // don't serialize
    )
};

//
// Define the property sets KSPROPSETID_SaveState, KSPROPSETID_AudioGfx,
// KSPROPSETID_Audio and KSPROPSETID_DrmAudioStream. They will be added to
// the filter descriptor through the automation table.
//
DEFINE_KSPROPERTY_SET_TABLE (FilterPropertySetTable)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_SaveState,                         // property set defined in msgfx.h
        SIZEOF_ARRAY(FilterPropertyTable_SaveState),    // the properties supported
        FilterPropertyTable_SaveState,
        0,                                              // reserved
        NULL                                            // reserved
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_AudioGfx,                          // property set defined in msgfx.h
        SIZEOF_ARRAY(FilterPropertyTable_AudioGfx),     // the properties supported
        FilterPropertyTable_AudioGfx,
        0,                                              // reserved
        NULL                                            // reserved
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Audio,                             // property set defined in msgfx.h
        SIZEOF_ARRAY(FilterPropertyTable_Audio),        // the properties supported
        FilterPropertyTable_Audio,
        0,                                              // reserved
        NULL                                            // reserved
    )
};

//
// This defines the automation table. The automation table will be added to the
// filter descriptor and has pointers to the porperty (set) table, method table
// and event table.
//
DEFINE_KSAUTOMATION_TABLE (FilterAutomationTable)
{
    DEFINE_KSAUTOMATION_PROPERTIES (FilterPropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
// The categories of the filter.
//
const GUID Categories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_DATATRANSFORM)
};

//
// The dispath handlers of the filter.
//
const KSFILTER_DISPATCH FilterDispatch =
{
    CGFXFilter::Create,
    CGFXFilter::Close,
    CGFXFilter::Process,
    NULL                    // Reset
};

//
// The connection table
//
const KSTOPOLOGY_CONNECTION FilterConnections[] =
{
    // From Pin0 (input pin) to Node0 - pin1 (input of our "channel swap" node)
    {KSFILTER_NODE, 0, 0, 1},
    // From Node0 - pin0 (output of our "channel swap" node) to pin1 (output pin)
    {0, 0, KSFILTER_NODE, 1}
};

//
// This defines the filter descriptor.
//
DEFINE_KSFILTER_DESCRIPTOR (FilterDescriptor)
{
    &FilterDispatch,                                    // Dispath table
    &FilterAutomationTable,                             // Automation table
    KSFILTER_DESCRIPTOR_VERSION,
    KSFILTER_FLAG_CRITICAL_PROCESSING,                  // Flags
    &KSNAME_MsGfxSample,                                // The name of the filter
    DEFINE_KSFILTER_PIN_DESCRIPTORS (PinDescriptors),
    DEFINE_KSFILTER_CATEGORIES (Categories),
    DEFINE_KSFILTER_NODE_DESCRIPTORS (NodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS (FilterConnections),
    NULL                                                // Component ID
};

/*****************************************************************************
 * CGFXFilter::Create
 *****************************************************************************
 * This routine is called when a  filter is created.  It instantiates the
 * client filter object and attaches it to the  filter structure.
 * 
 * Arguments:
 *    filter - Contains a pointer to the  filter structure.
 *    irp    - Contains a pointer to the create request.
 *
 * Return Value:
 *    STATUS_SUCCESS or, if the filter could not be instantiated, 
 *    STATUS_INSUFFICIENT_RESOURCES.
 */
NTSTATUS CGFXFilter::Create
(
    IN OUT PKSFILTER filter,
    IN     PIRP      irp
)
{
    PAGED_CODE ();
    
    PGFXFILTER gfxFilter;

    DOUT (DBG_PRINT, ("[Create]"));
    
    //
    // Check the filter context
    //
    if (filter->Context)
    {
        DOUT (DBG_ERROR, ("[Create] filter context already exists!"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create an instance of the client filter object.
    //
    gfxFilter = new (PagedPool, GFXSWAP_POOL_TAG) GFXFILTER;
    if(gfxFilter == NULL)
    {
        DOUT (DBG_ERROR, ("[Create] couldn't allocate gfx filter object!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Attach it to the filter structure.
    //
    filter->Context = (PVOID)gfxFilter;
    DOUT (DBG_PRINT, ("[Create] gfxFilter %08x", gfxFilter));
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXFilter::Close
 *****************************************************************************
 * This routine is called when a  filter is closed.  It deletes the
 * client filter object attached it to the  filter structure.
 * 
 * Arguments:
 *    filter - Contains a pointer to the  filter structure.
 *    irp    - Contains a pointer to the create request.
 *
 * Return Value:
 *    STATUS_SUCCESS.
 */
NTSTATUS CGFXFilter::Close
(
    IN PKSFILTER filter,
    IN PIRP      irp
)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("[Close] gfxFilter %08x", filter->Context));
    
    // delete is safe with NULL pointers.
    delete (PGFXFILTER)filter->Context;
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXFilter::Process
 *****************************************************************************
 * This routine is called when there is data to be processed.
 * 
 * Arguments:
 *    filter - Contains a pointer to the  filter structure.
 *    processPinsIndex -
 *       Contains a pointer to an array of process pin index entries.  This
 *       array is indexed by pin ID.  An index entry indicates the number 
 *       of pin instances for the corresponding pin type and points to the
 *       first corresponding process pin structure in the ProcessPins array.
 *       This allows process pin structures to be quickly accessed by pin ID
 *       when the number of instances per type is not known in advance.
 *
 * Return Value:
 *    STATUS_SUCCESS or STATUS_PENDING.
 */
NTSTATUS CGFXFilter::Process
(
    IN PKSFILTER                filter,
    IN PKSPROCESSPIN_INDEXENTRY processPinsIndex
)
{
    PAGED_CODE ();
    
    PGFXFILTER      gfxFilter = (PGFXFILTER)filter->Context;
    PKSPROCESSPIN   inPin, outPin;
    ULONG           ulByteCount, ulBytesProcessed;

    //
    // The first pin is the input pin, then we have an output pin.
    //
    inPin  = processPinsIndex[0].Pins[0];
    outPin = processPinsIndex[1].Pins[0];

    // Makes it easier to read.
    PKSDATAFORMAT_WAVEFORMATEX pWaveFmt =
        (PKSDATAFORMAT_WAVEFORMATEX)inPin->Pin->ConnectionFormat;
    
    //
    // Find out how much data we have to process.
    // Calculate the number of bytes we can processed for the buffer. Ideally
    // this would always be equal ulByteCount since we have our framing
    // requirements calculated to fit a 10ms buffer, but we might also get
    // more. Note that the 3306 bytes won't hold complete stereo 16bit samples.
    //
    ulByteCount = min (inPin->BytesAvailable, outPin->BytesAvailable);
    ulByteCount = ulByteCount -
        ulByteCount % ((pWaveFmt->WaveFormatEx.nChannels *
                        pWaveFmt->WaveFormatEx.wBitsPerSample) >> 3);

    //
    // Start process here.
    // We only do a channel swap if we are connected with a stereo format and we
    // are supposed to channel swap.
    //
    if (((PGFXFILTER)filter->Context)->enableChannelSwap &&
        (pWaveFmt->WaveFormatEx.nChannels == 2))
    {
        //
        // Check the data format of the pin. We have 2 different process
        // routines, one for 16bit and one for 24bit data.
        //
        if (pWaveFmt->WaveFormatEx.wBitsPerSample == 16)
        {
            //
            // Do the 16bit channel swap
            //
            PSHORT  in = (PSHORT)inPin->Data;
            PSHORT out = (PSHORT)outPin->Data;
            SHORT wSwap;
            
            //
            // loop through & swap
            //
            for (int nLoop = ulByteCount; nLoop; nLoop -= 4)
            {
                // In case the input and output buffers are the same
                // (in-place processing) we need to use a wSwap
                // to store one sample.
                wSwap = *in;
                *out = *(in + 1);
                out++;
                *out = wSwap;
                out++;
                in += 2;
            }
        }
        else
        {
            //
            // This must be 24bit channel swap since we only accept 16 or 24bit.
            //
            struct tag3Bytes
            {
                BYTE    a, b, c;
            };
            typedef tag3Bytes   THREEBYTES;

            THREEBYTES  *in = (THREEBYTES *)inPin->Data;
            THREEBYTES *out = (THREEBYTES *)outPin->Data;
            THREEBYTES wSwap;
            
            //
            // loop through & swap
            //
            for (int nLoop = ulByteCount; nLoop; nLoop -= 6)
            {
                // In case the input and output buffers are the same
                // (in-place processing) we need to use a wSwap
                // to store one sample.
                wSwap = *in;
                *out = *(in + 1);
                out++;
                *out = wSwap;
                out++;
                in += 2;
            }
        }
    }
    else
    {
        //
        // No swap required.
        // In case we do in-place processing we don't need to do a data copy.
        // Note that the InPlaceCounterpart pointer must point to the outPin
        // since we only have one in and out pin.
        //
        if (!inPin->InPlaceCounterpart)
            RtlCopyMemory (outPin->Data, inPin->Data, ulByteCount);
    }

    //
    // Report back how much data we processed
    //
    inPin->BytesUsed = outPin->BytesUsed = ulByteCount;

    // Update the bytesProcessed variable in the filter.
    // We start assuming that bytesProcessed is 0. The loop makes sure that if this is not
    // the case (which most likely will not) that bytesProcessed gets read in an interlocked
    // fashion, then modified and written back on the 2nd loop.
    ULONGLONG oldBytesProcessed = 0;
    ULONGLONG newBytesProcessed = ulByteCount;
    ULONGLONG returnValue;

    // ExInterlockedCompareExchange64 doesn't use the 4th parameter.
    while ((returnValue = ExInterlockedCompareExchange64 ((LONGLONG *)&gfxFilter->bytesProcessed,
            (LONGLONG *)&newBytesProcessed, (LONGLONG *)&oldBytesProcessed, NULL)) != oldBytesProcessed)
    {
        oldBytesProcessed = returnValue;
        newBytesProcessed = returnValue + ulByteCount;
    }

    //
    // Do not pack frames. Submit what we have so that we don't
    // hold off the audio stack.
    //
    outPin->Terminate = TRUE;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PropertyGetFilterState
 *****************************************************************************
 * Returns the property sets that comprise the persistable filter settings.
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get.
 *    property  - not used in this function.
 *    data      - return buffer which will contain the property sets.
 */
NTSTATUS PropertyGetFilterState
(
    IN  PIRP        irp,
    IN  PKSPROPERTY property,
    OUT PVOID       data
)
{
    PAGED_CODE ();
    
    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[PropertyGetFilterState]"));
    
    //
    // These are the property set IDs that we return.
    //
    GUID SaveStatePropertySets[] =
    {
        STATIC_KSPROPSETID_SaveState
    };

    //
    // Get the output buffer length.
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation (irp);
    ULONG              cbData = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Check buffer length.
    //
    if (!cbData)
    {
        //
        // 0 buffer length requests the buffer size needed.
        //
        irp->IoStatus.Information = sizeof(SaveStatePropertySets);
        ntStatus = STATUS_BUFFER_OVERFLOW;
    }
    else
        if (cbData < sizeof(SaveStatePropertySets))
        {
            //
            // This buffer is simply too small
            //
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            //
            // Right size. Copy the property set IDs.
            //
            RtlCopyMemory (data, SaveStatePropertySets, sizeof(SaveStatePropertySets));
            irp->IoStatus.Information = sizeof(SaveStatePropertySets);
            ntStatus = STATUS_SUCCESS;
        }

    return ntStatus;
}

/*****************************************************************************
 * PropertySetRenderTargetDeviceId
 *****************************************************************************
 * Advises the GFX of the hardware PnP ID of the target render device.
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the set.
 *    property  - not used in this function.
 *    data      - Pointer to Unicode string containing the hardware PnP ID of
 *                 the target render device
 */
NTSTATUS PropertySetRenderTargetDeviceId
(
    IN PIRP        irp,
    IN PKSPROPERTY property,
    IN PVOID       data
)
{
    PAGED_CODE ();
    
    PWSTR    deviceId;
    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[PropertySetRenderTargetDeviceId]"));
    
    //
    // Get the output buffer length.
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
    ULONG              cbData = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // check for reasonable values
    if (!cbData || cbData > 1024)
        return STATUS_UNSUCCESSFUL;

    //
    // Handle this property if you are interested in the PnP device ID
    // of the target render device on which this GFX is applied
    //
    // For now we just copy the PnP device ID and print it on the debugger,
    // then we discard it. You could for example compare the PnP ID string
    // with the ones in the INF file to make sure nobody altered the INF
    // file to apply your GFX to a different device.
    //
    deviceId = (PWSTR)ExAllocatePoolWithTag (PagedPool, cbData, GFXSWAP_POOL_TAG);
    if (deviceId)
    {
        //
        // Copy the PnP device ID.
        //
        RtlCopyMemory ((PVOID)deviceId, data, cbData);
        
        //
        // Ensure last character is NULL
        //
        deviceId[(cbData/sizeof(deviceId[0]))-1] = L'\0';
        
        //
        // Print out the string.
        //
        DOUT (DBG_PRINT, ("[PropertySetRenderTargetDeviceId] ID is [%ls]", deviceId));

        //
        // If you are interested in the DeviceId and need to store it then
        // you probably wouldn't free the memory here.
        //
        ExFreePool (deviceId);
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        DOUT (DBG_WARNING, ("[PropertySetRenderTargetDeviceId] couldn't allocate buffer for device ID."));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertySetCaptureTargetDeviceId
 *****************************************************************************
 * Advises the GFX of the hardware PnP ID of the target capture device
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the set.
 *    property  - not used in this function.
 *    data      - Pointer to Unicode string containing the hardware PnP ID of
 *                 the target capture device
 */
NTSTATUS PropertySetCaptureTargetDeviceId
(
    IN PIRP        irp,
    IN PKSPROPERTY property,
    IN PVOID       data
)
{
    PAGED_CODE ();
    
    PWSTR    deviceId;
    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[PropertySetCaptureTargetDeviceId]"));
    
    //
    // Get the output buffer length.
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
    ULONG              cbData = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // check for reasonable values
    if (!cbData || cbData > 1024)
        return STATUS_UNSUCCESSFUL;

    //
    // Handle this property if you are interested in the PnP device ID
    // of the target capture device on which this GFX is applied
    //
    //
    // For now we just copy the PnP device ID and print it on the debugger,
    // then we discard it. You could for example compare the PnP ID string
    // with the ones in the INF file to make sure nobody altered the INF
    // file to apply your GFX to a different device.
    //
    deviceId = (PWSTR)ExAllocatePoolWithTag (PagedPool, cbData, GFXSWAP_POOL_TAG);
    if (deviceId)
    {
        //
        // Copy the PnP device ID.
        //
        RtlCopyMemory ((PVOID)deviceId, data, cbData);
        
        //
        // Ensure last character is NULL
        //
        deviceId[(cbData/sizeof(deviceId[0]))-1] = L'\0';
        
        //
        // Print out the string.
        //
        DOUT (DBG_PRINT, ("[PropertySetCaptureTargetDeviceId] ID is [%ls]", deviceId));

        //
        // If you are interested in the DeviceId and need to store it then
        // you probably wouldn't free the memory here.
        //
        ExFreePool (deviceId);
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        DOUT (DBG_WARNING, ("[PropertySetCaptureTargetDeviceId] couldn't allocate buffer for device ID."));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertySaveState
 *****************************************************************************
 * Saves or restores the filter state. The filter has only one "channel swap"
 * node, so this will be easy!
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get/set.
 *    property  - not used in this function.
 *    data      - buffer to receive the filter state OR new filter state that
 *                 is to be used.
 */
NTSTATUS PropertySaveState
(
    IN     PIRP        irp,
    IN     PKSPROPERTY property,
    IN OUT PVOID       data
)
{
    PAGED_CODE ();
    
    PGFXFILTER  gfxFilter;
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[PropertySaveState]"));
    
    //
    // This handler is a filter property handler, but is not different
    // from the PropertyChannelSwap node property handler.
    // This property handler therefore only shows that you can have a
    // different property for saving your filter state which is usefull
    // once you have a lot of things to save (and you want to do that
    // at once and not by calling several properties).
    //

    //
    // Get hold of our FilterContext via pIrp
    //
    gfxFilter = (PGFXFILTER)(KsGetFilterFromIrp(irp)->Context);

    //
    // Assert that we have a valid filter context
    //
    ASSERT (gfxFilter);

    if (property->Flags & KSPROPERTY_TYPE_GET)
    {
        //
        // Get channel swap state
        //
        *(PBOOL)data = gfxFilter->enableChannelSwap;
    }
    else if (property->Flags & KSPROPERTY_TYPE_SET)
        {
            //
            // Set Channel swap state
            //
            gfxFilter->enableChannelSwap = *(PBOOL)data;
        }
        else
        {
            //
            // We support only Get & Set
            //
            DOUT (DBG_ERROR, ("[PropertySaveState] invalid property type."));
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    
    return ntStatus;
}


/*****************************************************************************
 * PropertyChannelSwap
 *****************************************************************************
 * This is our private property for our private node. The node just gets/sets
 * a flag to disable/enable the filter, that means, to disable/enable the
 * channel swapping.
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get/set.
 *    property  - our private property.
 *    data      - buffer to receive the filter state.
 */
NTSTATUS PropertyChannelSwap
(
    IN     PIRP        irp,
    IN     PKSPROPERTY property,
    IN OUT PVOID       data
)
{
    PAGED_CODE ();
    
    PGFXFILTER  gfxFilter;
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[PropertyChannelSwap]"));
    
    //
    // Get hold of our FilterContext via pIrp
    //
    gfxFilter = (PGFXFILTER)(KsGetFilterFromIrp(irp)->Context);

    //
    // Assert that we have a valid filter context
    //
    ASSERT (gfxFilter);

    if (property->Flags & KSPROPERTY_TYPE_GET)
    {
        //
        // Get channel swap state
        //
        *(PBOOL)data = gfxFilter->enableChannelSwap;
    }
    else if (property->Flags & KSPROPERTY_TYPE_SET)
        {
            //
            // Set Channel swap state
            //
            gfxFilter->enableChannelSwap = *(PBOOL)data;
        }
        else
        {
            //
            // We support only Get & Set
            //
            DOUT (DBG_ERROR, ("[PropertyChannelSwap] invalid property type."));
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    
    return ntStatus;
}

/*****************************************************************************
 * PropertyDrmSetContentId
 *****************************************************************************
 * A KS audio filter handles this property request synchronously.
 * If the request returns STATUS_SUCCESS, all the downstream KS audio nodes
 * of the target KS audio pin were also successfully configured with the
 * specified DRM content ID and DRM content rights. 
 * (Note that a downstream node is a direct or indirect sink for the audio
 * content flowing through an audio pin.)
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the set.
 *    property  - not used in this function.
 *    drmData   - The content ID and the DRM rights.
 */
NTSTATUS PropertyDrmSetContentId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        drmData
)
{
    PAGED_CODE ();

    NTSTATUS    ntStatus = STATUS_SUCCESS;
    ULONG       contentId = *(PULONG)drmData;
    DRMRIGHTS*  drmRights = (PDRMRIGHTS)(((PULONG)drmData) + 1);
    PKSPIN      pin, otherPin;
    PKSFILTER   filter;
     
    DOUT (DBG_PRINT, ("[PropertyDrmSetContentId]"));

    //
    // Get the pin from the IRP. If the pin is NULL, that means that
    // the IRP is for a filter node (not a filter pin).
    //
    pin = KsGetPinFromIrp (irp);
    if (!pin)
    {
        DOUT (DBG_ERROR, ("[PropertyDrmSetContentId] this property is for a filter node?"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // This property should only go to the sink pin. Check this out.
    //
    if (pin->Id != GFX_SINK_PIN)
    {
        DOUT (DBG_ERROR, ("[PropertyDrmSetContentId] this property was invoked on the source pin!"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Now get the filter where the pin is implemented.
    //
    filter = KsPinGetParentFilter (pin);
    
    //
    // We need to go through the pin list to get the source pin.
    // For that we need the control mutex.
    //
    KsFilterAcquireControl (filter);

    //
    // Look now for the source pin.
    //
    otherPin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
    if (!otherPin)
    {
        // We couldn't find the source pin.
        KsFilterReleaseControl (filter);
        DOUT (DBG_ERROR, ("[PropertyDrmSetContentId] couldn't find source pin."));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // You need to honor the DRM rights bits.
    // The sample GFX just processes the buffers and sends it down the stack,
    // so all we do is let the system verify the filter below us. If this
    // filter (normally the usbaudio driver) is certified then we can
    // play DRM content.
    //

    //
    // Forward the Content ID to the lower device object.
    //
    PFILE_OBJECT   fileObject   = KsPinGetConnectedPinFileObject (otherPin);
    PDEVICE_OBJECT deviceObject = KsPinGetConnectedPinDeviceObject (otherPin);

    //
    // The above 2 functions would only fail if pOtherPin is not a source pin.
    //
    if (fileObject && deviceObject)
    {
        DRMFORWARD DrmForward;

        DrmForward.Flags        = 0;
        DrmForward.DeviceObject = deviceObject;
        DrmForward.FileObject   = fileObject;
        DrmForward.Context      = (PVOID)fileObject;

        ntStatus = DrmForwardContentToDeviceObject (contentId, NULL, &DrmForward);
    }
    else
    {
        ASSERT (!"[PropertyDrmSetContentId] otherPin not source pin?!?");
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

    KsFilterReleaseControl (filter);

    return ntStatus;
}

/*****************************************************************************
 * PropertyAudioPosition
 *****************************************************************************
 * Gets/Sets the audio position of the audio stream (Relies on the next
 * filter's audio position)
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get/set.
 *    property  - Ks Property structure.
 *    data      - Pointer to buffer where position value needs to be filled OR
 *                 Pointer to buffer which has the new positions
 */
NTSTATUS PropertyAudioPosition
(
    IN     PIRP              irp,
    IN     PKSPROPERTY       property,
    IN OUT PKSAUDIO_POSITION position
)
{
    PAGED_CODE ();
    
    PKSFILTER       filter;
    PGFXFILTER      gfxFilter;
    PKSPIN          otherPin;
    PKSPIN          pin;
    ULONG           bytesReturned;
    PIKSCONTROL     pIKsControl;
    NTSTATUS        ntStatus;

    DOUT (DBG_PRINT, ("[PropertyAudioPosition]"));

    //
    // Get the pin from the IRP. If the pin is NULL, that means that
    // the IRP is for a filter node (not a filter pin).
    //
    pin = KsGetPinFromIrp (irp);
    if (!pin)
    {
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] this property is for a filter node?"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // This property should only go to the sink pin. Check this out.
    //
    if (pin->Id != GFX_SINK_PIN)
    {
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] this property was invoked on the source pin!"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Now get the filter where the pin is implemented.
    //
    filter = KsPinGetParentFilter (pin);
    gfxFilter = (PGFXFILTER)filter->Context;
    
    //
    // We need to go through the pin list to get the source pin.
    // For that we need the control mutex.
    //
    KsFilterAcquireControl (filter);

    //
    // Look now for the source pin.
    //
    otherPin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
    if (!otherPin)
    {
        // We couldn't find the source pin.
        KsFilterReleaseControl (filter);
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] couldn't find the source pin."));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // This gets the interface that is connected with our output pin.
    //
    ntStatus = KsPinGetConnectedPinInterface (otherPin, &IID_IKsControl, (PVOID*)&pIKsControl);
    if (!NT_SUCCESS (ntStatus))
    {
        // We couldn't get the interface.
        KsFilterReleaseControl (filter);
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] couldn't get IID_IKsControl interface."));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Pass the property down through the interface.
    // Always release the mutex before calling down.
    //
    KsFilterReleaseControl (filter);
    ntStatus = pIKsControl->KsProperty (property, sizeof (KSPROPERTY),
                                        position, sizeof (KSAUDIO_POSITION),
                                        &bytesReturned);

    //
    // This GFX is always in the playback graph (it's never used for
    // capture). We need to modify therefore only the WritePosition of
    // the KSAUDIO_POSITION structure.
    // If you do a GFX that is in the capture graph, you need to check if
    // you are inplace. If true, you change the write position like we do
    // now, and if you are not inplace, then you need to set the write
    // position to the BytesProcessed and the play position you need to
    // clip to the number of bytes processed + bytes outstanding on the
    // sink pin.
    //
    if (property->Id & KSPROPERTY_TYPE_GET)
    {
        // ExInterlockedCompareExchange64 doesn't use the 4th parameter.
        position->WriteOffset = ExInterlockedCompareExchange64 ((LONGLONG *)&gfxFilter->bytesProcessed,
                    (LONGLONG *)&position->WriteOffset, (LONGLONG *)&position->WriteOffset, NULL);
        ASSERT (position->PlayOffset <= position->WriteOffset);
    }

    //
    // We don't need this interface anymore.
    //
    pIKsControl->Release();

    // Set the IRP information field.
    irp->IoStatus.Information = bytesReturned;

    return(ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\gfxproperty.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXProperty.cpp : Implementation of CGFXProperty
#include "stdafx.h"
#include <devioctl.h>
#include <ks.h>
#include "GFXProp.h"
#include "GFXProperty.h"
#include "..\inc\msgfx.h"

/////////////////////////////////////////////////////////////////////////////
// CGFXProperty

/////////////////////////////////////////////////////////////////////////////
// SetObjects
//
// This function gets passed in a IUnknown interface pointer from mmsys.cpl
// through OleCreatePropertyFrame. This IUnknown interface belongs to a
// IDataObject that stores the handle of the GFX. We need this handle in order
// to "talk" with the GFX.
// The implied action is that we close this handle when the dialog closes.

STDMETHODIMP CGFXProperty::SetObjects (ULONG nObjects, IUnknown **ppUnk)
{
    IDataObject *pDataObject;
    FORMATETC   DataFormat;
    STGMEDIUM   GFXObject;

    // Check paramters. We expect one IUnknown.
    if (ppUnk == NULL)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] IUnknown is NULL\n"));
        return E_POINTER;
    }

    if (nObjects != 1)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] Not one object passed but %d\n"), nObjects);
        return E_INVALIDARG;
    }

    // Query for IDataObject interface.
    if (ppUnk[0]->QueryInterface (IID_IDataObject, (PVOID *)&pDataObject) != S_OK)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] QueryInterface failed!\n"));
        return E_FAIL;
    }

    // Get the handle
    memset ((PVOID)&DataFormat, 0, sizeof (DataFormat));
    DataFormat.tymed = TYMED_HGLOBAL;
    if (pDataObject->GetData (&DataFormat, &GFXObject) != S_OK)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] GetData failed!\n"));
        return E_FAIL;
    }

    // Store the handle of the GFX filter.
    m_hGFXFilter = GFXObject.hGlobal;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// SetChannelSwap
//
// This function send down a property to the sample GFX to change the GFX
// functionality, that is the channel swap variable.
// Setting it (pass TRUE to this function) means that the left and right
// channel are swapped.

void CGFXProperty::SetChannelSwap (BOOL bSwap)
{
    KSP_NODE        GFXSampleProperty;
    ULONG           ulBytesReturned;
    BOOL            fSuccess;

    // Prepare the property structure sent down.
    GFXSampleProperty.Property.Set = KSPROPSETID_MsGfxSample;
    GFXSampleProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    GFXSampleProperty.Property.Id = KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP;
    // The first node in the filter is the GFX node. If you have
    // a more complicated filter, you could search for the node by
    // optaining the filter node list first with KSPROPERTY_TOPOLOGY_NODES.
    GFXSampleProperty.NodeId = 0;

    // Make the final call.
    fSuccess = DeviceIoControl (m_hGFXFilter, IOCTL_KS_PROPERTY,
                                &GFXSampleProperty, sizeof (GFXSampleProperty),
                                &bSwap, sizeof (bSwap),
                                &ulBytesReturned, NULL);
    
    // Check for error.
    if (!fSuccess)
    {
        ATLTRACE (_T("[CGFXProperty::SetChannelSwap] DeviceIoControl failed!\n"));
    }

    return;     // We don't care about the return value.
}

/////////////////////////////////////////////////////////////////////////////
// GetChannelSwap
//
// This function sends down the property to the sample GFX to get the current GFX
// channel swap variable. We need this information to set the dialog controls
// before they get displayed.

void CGFXProperty::GetChannelSwap (BOOL *pbSwap)
{
    KSP_NODE        GFXSampleProperty;
    ULONG           ulBytesReturned;
    BOOL            fSuccess;

    // Initialize
    *pbSwap = TRUE;
    
    // Prepare the property structure sent down.
    GFXSampleProperty.Property.Set = KSPROPSETID_MsGfxSample;
    GFXSampleProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    GFXSampleProperty.Property.Id = KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP;
    // The first node in the filter is the GFX node. If you have
    // a more complicated filter, you could search for the node by
    // optaining the filter node list first with KSPROPERTY_TOPOLOGY_NODES.
    GFXSampleProperty.NodeId = 0;

    // Make the final call.
    fSuccess = DeviceIoControl (m_hGFXFilter, IOCTL_KS_PROPERTY,
                                &GFXSampleProperty, sizeof (GFXSampleProperty),
                                pbSwap, sizeof (BOOL),
                                &ulBytesReturned, NULL);
    
    // Check for error.
    if (!fSuccess)
    {
        ATLTRACE (_T("[CGFXProperty::GetChannelSwap] DeviceIoControl failed!\n"));
    }

    return;     // We don't care about the return value.
}

/////////////////////////////////////////////////////////////////////////////
// OnInitDialog
//
// This function is called when the dialog gets initialized.
// We read the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property and set the checkbox
// appropriately.

LRESULT CGFXProperty::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Get the current KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property value.
    GetChannelSwap (&m_bChannelSwap);
    // Set the checkbox to reflect the current state.
    SendMessage (GetDlgItem (IDC_CHANNEL_SWAP), BM_SETCHECK,
        (m_bChannelSwap) ? BST_CHECKED : BST_UNCHECKED, 0);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\gfxproperty.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXProperty.h : Declaration of the CGFXProperty

#ifndef __GFXPROPERTY_H_
#define __GFXPROPERTY_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_GFXProperty;

/////////////////////////////////////////////////////////////////////////////
// CGFXProperty
//
// This class implements the functionality we need to control the GFX property
// page. It also has the necessary functions to "talk" with the GFX.
// The IUnknown that we get passed in with "SetObjects" is the IUnknown
// interface of a IDataObject that stores the GFX handle. We will ask this
// object for the handle and when the dialog gets destroyed, we will close
// the handle.
class ATL_NO_VTABLE CGFXProperty :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CGFXProperty, &CLSID_GFXProperty>,
    public IPropertyPageImpl<CGFXProperty>,
    public CDialogImpl<CGFXProperty>
{
public:
    // Stores string resources for the dialog and initializes private member
    // variables.
    CGFXProperty() 
    {
        m_dwTitleID = IDS_TITLEGFXProperty;
        // To enable help in the dialog box uncomment this line and change the
        // string resource
        //m_dwHelpFileID = IDS_HELPFILEGFXProperty;
        m_dwDocStringID = IDS_DOCSTRINGGFXProperty;
        m_hGFXFilter = NULL;
    }

    // Closes the handle got from the IID_IDataObject.
    ~CGFXProperty()
    {
        if (m_hGFXFilter)
            CloseHandle (m_hGFXFilter);
    }

    enum {IDD = IDD_GFXPROPERTY};

    // ATL "secrets"
    DECLARE_REGISTRY_RESOURCEID(IDR_GFXPROPERTY)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    // This is the only interface we have (or want to expose).
    BEGIN_COM_MAP(CGFXProperty) 
        COM_INTERFACE_ENTRY(IPropertyPage)
    END_COM_MAP()

    // This is the message map that redirects messages to our message handlers.
    BEGIN_MSG_MAP(CGFXProperty)
        CHAIN_MSG_MAP(IPropertyPageImpl<CGFXProperty>)
        COMMAND_HANDLER(IDC_CHANNEL_SWAP, BN_CLICKED, OnClickedChannelSwap)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    // Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // "Apply" button pressed on the dialog.
    STDMETHOD(Apply)(void)
    {
        // Set the property on the GFX to the desired value.
        SetChannelSwap (m_bChannelSwap);
        // Mark the "Apply" button to be grayed out.
        m_bDirty = FALSE;
        return S_OK;
    }

    // The checkbox changed it's value.
    LRESULT OnClickedChannelSwap (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        // Get the state of the checkbox and safe if in out variable.
        if (SendMessage (hWndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED)
            m_bChannelSwap = TRUE;
        else
            m_bChannelSwap = FALSE;
        
        // Mark the "Apply" button as valid.
        SetDirty (TRUE);
        return 0;
    }
    
    // This function is called indirect by mmsys.cpl to pass in the IUnknown
    // of the IDataObject which has the handle of our GFX.
    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);

private:
    // This is the value of the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property
    BOOL   m_bChannelSwap;
    // The handle to our GFX.
    HANDLE m_hGFXFilter;

    // Set the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property on the GFX.
    void GetChannelSwap (BOOL *);
    // Get the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property on the GFX.
    void SetChannelSwap (BOOL);
    // Gets called when the dialog gets initialized.
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

#endif //__GFXPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\driver\pin.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// The pin descriptors (static structures) are in filter.cpp
//

//
// Every debug output has "Modulname text"
//
static char STR_MODULENAME[] = "GFX pin: ";

#include "common.h"
#include <msgfx.h>


/*****************************************************************************
 * CGFXPin::ValidateDataFormat
 *****************************************************************************
 * Checks if the passed data format is in the data range passed in. The data
 * range is one of our own data ranges that we defined for the pin and the
 * data format is the requested data format for creating a stream or changing
 * the data format (SetDataFormat).
 */
NTSTATUS CGFXPin::ValidateDataFormat
(
    IN PKSDATAFORMAT dataFormat,
    IN PKSDATARANGE  dataRange
)
{
    PAGED_CODE ();

    ASSERT (dataFormat);

    DOUT (DBG_PRINT, ("[ValidateDataFormat]"));

    //
    // KSDATAFORMAT contains three GUIDs to support extensible format.  The
    // first two GUIDs identify the type of data.  The third indicates the
    // type of specifier used to indicate format specifics.
    // KS makes sure that it doesn't call the driver with any data format
    // that doesn't match the GUIDs in the data range of the pin. That
    // means we don't have to check this here again.
    //

    PWAVEFORMATPCMEX    waveFormat = (PWAVEFORMATPCMEX)(dataFormat + 1);
    PKSDATARANGE_AUDIO  audioDataRange = (PKSDATARANGE_AUDIO)dataRange;

    //
    // We are only supporting PCM audio formats that use WAVEFORMATEX.
    //
    // If the size doesn't match, then something is messed up.
    //
    if (dataFormat->FormatSize < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATEX)))
    {
        DOUT (DBG_WARNING, ("[ValidateDataFormat] Invalid FormatSize!"));
        return STATUS_INVALID_PARAMETER;
    }
            
    //
    // Print the information.
    //
    if (waveFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
    {
        DOUT (DBG_STREAM, ("[ValidateDataFormat] PCMEX - Frequency: %d, Channels: %d, bps: %d, ChannelMask: %X",
              waveFormat->Format.nSamplesPerSec, waveFormat->Format.nChannels,
              waveFormat->Format.wBitsPerSample, waveFormat->dwChannelMask));
    }
    else
    {
        DOUT (DBG_STREAM, ("[ValidateDataFormat] PCM - Frequency: %d, Channels: %d, bps: %d",
              waveFormat->Format.nSamplesPerSec, waveFormat->Format.nChannels,
              waveFormat->Format.wBitsPerSample));
    }
    
    //
    // Compare the data format with the data range.
    // Check the bits per sample.
    //
    if ((waveFormat->Format.wBitsPerSample < audioDataRange->MinimumBitsPerSample) ||
        (waveFormat->Format.wBitsPerSample > audioDataRange->MaximumBitsPerSample))
    {
        DOUT (DBG_PRINT, ("[ValidateDataFormat] No match for Bits Per Sample!"));
        return STATUS_NO_MATCH;
    }
    
    //
    // Check the number of channels.
    //
    if ((waveFormat->Format.nChannels < 1) ||
        (waveFormat->Format.nChannels > audioDataRange->MaximumChannels))
    {
        DOUT (DBG_PRINT, ("[ValidateDataFormat] No match for Number of Channels!"));
        return STATUS_NO_MATCH;
    }
    
    //
    // Check the sample frequency.
    //
    if ((waveFormat->Format.nSamplesPerSec < audioDataRange->MinimumSampleFrequency) ||
        (waveFormat->Format.nSamplesPerSec > audioDataRange->MaximumSampleFrequency))
    {
        DOUT (DBG_PRINT, ("[ValidateDataFormat] No match for Sample Frequency!"));
        return STATUS_NO_MATCH;
    }
    
    //
    // We support WaveFormatPCMEX (=WAVEFORMATEXTENSIBLE) or WaveFormatPCM.
    // In case of WaveFormatPCMEX we need to check the speaker config too.
    //
    if ((waveFormat->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE) &&
        (waveFormat->Format.wFormatTag != WAVE_FORMAT_PCM))
    {
        DOUT (DBG_WARNING, ("[ValidateDataFormat] Invalid Format Tag!"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make additional checks for the WAVEFORMATEXTENSIBLE
    //
    if (waveFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
    {
        //
        // If the size doesn't match, then something is messed up.
        //
        if (dataFormat->FormatSize < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX)))
        {
            DOUT (DBG_WARNING, ("[ValidateDataFormat] Invalid FormatSize!"));
            return STATUS_INVALID_PARAMETER;
        }
        
        //
        // Check also the subtype (PCM) and the size of the extended data.
        //
        if (!IsEqualGUIDAligned (waveFormat->SubFormat, KSDATAFORMAT_SUBTYPE_PCM) ||
            (waveFormat->Format.cbSize < 22))
        {
            DOUT (DBG_WARNING, ("[ValidateDataFormat] Unsupported WAVEFORMATEXTENSIBLE!"));
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Check the channel mask. We support 1 or 2 channels.
        //
        if (((waveFormat->Format.nChannels == 1) &&
             (waveFormat->dwChannelMask != KSAUDIO_SPEAKER_MONO)) ||
            ((waveFormat->Format.nChannels == 2) &&
             (waveFormat->dwChannelMask != KSAUDIO_SPEAKER_STEREO)))
        {
            DOUT (DBG_WARNING, ("[ValidateDataFormat] Unsupported Channel Mask!"));
            return STATUS_INVALID_PARAMETER;
        }
    }
        
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::Create
 *****************************************************************************
 * This function is called once a pin gets opened.
 */
NTSTATUS CGFXPin::Create
(
    IN PKSPIN   pin,
    IN PIRP     irp
)
{
    PAGED_CODE ();
    
    PGFXPIN     gfxPin;

    DOUT (DBG_PRINT, ("[Create]"));
    
    //
    // The pin context is the filter's context. We overwrite it with
    // the pin object.
    //
    gfxPin = new (NonPagedPool, GFXSWAP_POOL_TAG) GFXPIN;
    if (gfxPin == NULL)
    {
        DOUT (DBG_ERROR, ("[Create] couldn't allocate gfx pin object."));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Attach it to the pin structure.
    //
    pin->Context = (PVOID)gfxPin;
    DOUT (DBG_PRINT, ("[Create] gfxPin %08x", gfxPin));
    
    //
    // Initialize the CGFXPin object variables.
    //
    ExInitializeFastMutex (&gfxPin->pinQueueSync);

    //
    // Get the OS version info
    //
    RTL_OSVERSIONINFOEXW version;
    version.dwOSVersionInfoSize = sizeof (RTL_OSVERSIONINFOEXW);
    RtlGetVersion ((PRTL_OSVERSIONINFOW)&version);

    //
    // If we are running under the first release of Windows XP,
    // KsPinGetAvailableByteCount has a bug so that we can't use it.
    // We only use this function in SetDataFormat, so we just reject
    // all data format changes. Otherwise, if a service pack is installed
    // or Windows Server 2003 or a later version of Windows XP we can use the
    // function.
    //
    if (version.dwBuildNumber > 2600)
        gfxPin->rejectDataFormatChange = FALSE;
    else
    {
        if (version.wServicePackMajor > 0)
            gfxPin->rejectDataFormatChange = FALSE;
        else
            gfxPin->rejectDataFormatChange = TRUE;
    }
    DOUT (DBG_SYSTEM,
        ("[Create] OS build number: %d, version: %d.%d, service pack: %d.%d",
        version.dwBuildNumber, version.dwMajorVersion, version.dwMinorVersion,
        version.wServicePackMajor, version.wServicePackMinor));

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::Close
 *****************************************************************************
 * This routine is called when a pin is closed.  It deletes the
 * client pin object attached to the pin structure.
 * 
 * Arguments:
 *    pin     - Contains a pointer to the pin structure.
 *    pIrp    - Contains a pointer to the close request.
 *
 * Return Value:
 *    STATUS_SUCCESS.
 */
NTSTATUS CGFXPin::Close
(
    IN PKSPIN    pin,
    IN PIRP      irp
)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("[Close] gfxPin %08x", pin->Context));
    
    // delete is safe with NULL pointers.
    delete (PGFXPIN)pin->Context;
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::SetDataFormat
 *****************************************************************************
 * This function is called on the pin everytime the data format should change.
 * It is also called just before the pin gets created with the new data format.
 * Therefore, we don't need to have a pin Create dispatch function just to
 * check the data format.
 * Since we need to have both pins running at the same data format, we need
 * to pass down the request to change the pin's data format to the lower
 * driver, which would be the audio driver. If the audio driver fails to change
 * the data format, we will do so too.
 */
NTSTATUS CGFXPin::SetDataFormat
(
    IN PKSPIN                   pin,
    IN PKSDATAFORMAT            oldFormat,
    IN PKSMULTIPLE_ITEM         oldAttributeList,
    IN const KSDATARANGE        *dataRange,
    IN const KSATTRIBUTE_LIST   *attributeRange
)
{
    PAGED_CODE ();

    ASSERT (pin);
    
    NTSTATUS    ntStatus;
    PKSFILTER   filter;
    PKSPIN      otherPin;
    PGFXPIN     gfxPin = NULL;
    
    DOUT (DBG_PRINT, ("[GFXPinSetDataFormat]"));
    
    //
    // First validate if the requested data format is valid.
    //
    ntStatus = ValidateDataFormat (pin->ConnectionFormat, (PKSDATARANGE)dataRange);
    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    //
    // We need to have the same data format on both pins.
    // That means we need to get to the other pin and if this pin is created
    // make sure that the lower level driver (audio driver) gets a SetDataFormat
    // too.
    //

    //
    // We hold the filter control mutex already.
    //
    filter = KsPinGetParentFilter (pin);

    //
    // Now get to the other pin. If this property was called on the sink
    // pin, then we get the source pin and continue. If it was called on
    // the source pin we go to the sink pin and continue.
    // To check if the pin really exists you look at the OldFormat which
    // is passed in. If it's a creation of the pin the OldFormat will be
    // NULL.
    // If the other pin doesn't exist we accept the format since it passed
    // the format check.
    //
    if (pin->Id == GFX_SINK_PIN)
    {
        otherPin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
        if (oldFormat)
            gfxPin = (PGFXPIN)pin->Context;
    }
    else    // It's a source pin
    {
        otherPin = KsFilterGetFirstChildPin (filter, GFX_SINK_PIN);
        if (otherPin)
            gfxPin = (PGFXPIN)otherPin->Context;
    }
        
    //
    // If there is no other pin open, accept the data format.
    //
    if (!otherPin)
    {
        DOUT (DBG_PRINT, ("[GFXPinSetDataFormat] data format accepted."));
        return STATUS_SUCCESS;
    }

    //
    // Check if the data format if equal for both pins.
    // We cannot just compare the memory of the data format structure
    // since one could be WAVEFORMATEX and the other one WAVEFORMATPCMEX,
    // but we also know that these are the only formats that we accept,
    // so compare their values now.
    //
    PWAVEFORMATEX   thisWaveFmt = (PWAVEFORMATEX)(pin->ConnectionFormat + 1);
    PWAVEFORMATEX  otherWaveFmt = (PWAVEFORMATEX)(otherPin->ConnectionFormat + 1);

    if ((thisWaveFmt->nChannels == otherWaveFmt->nChannels) &&
        (thisWaveFmt->nSamplesPerSec == otherWaveFmt->nSamplesPerSec) &&
        (thisWaveFmt->wBitsPerSample == otherWaveFmt->wBitsPerSample))
    {
        //
        // We have a match right here.
        //
        DOUT (DBG_PRINT, ("[GFXPinSetDataFormat] data format accepted."));
        return STATUS_SUCCESS;
    }
     
    //
    // We don't have a match. We need to change the data format of the otherPin
    // now and if that succeeds we can continue, otherwise we need to fail.
    //
    // Before we pass down the property however, we need to make sure that all
    // buffers on the sink pin are processed (since they were sampled with
    // the old data format).
    //
    LONG  bytesQueuedUp = 0;
    do
    {
        //
        // We need to synchronize the call to KsPinGetAvailableByteCount
        // with changes in the pin state (using the fast mutex) only on
        // the sink pin.
        //
        if (gfxPin)
        {
            ExAcquireFastMutex (&gfxPin->pinQueueSync);
            //
            // In case we are not in STOP state, the pin queue should be there,
            // otherwise it is destroyed (or in the process of destroying) and
            // therefore we assume no buffers are waiting on the pin.
            //
            if (gfxPin->pinQueueValid)
            {
                //
                // If we are running on a system without the KS fix, we
                // need to reject the SetDataFormat because we want to
                // prevent an unprocessed buffer from playing at the
                // wrong sample frequency.
                //
                if (gfxPin->rejectDataFormatChange)
                {
                    ExReleaseFastMutex (&gfxPin->pinQueueSync);
                    return STATUS_UNSUCCESSFUL;
                }
                
                KsPinGetAvailableByteCount (pin, &bytesQueuedUp, NULL);
            }
            else
                bytesQueuedUp = 0;
            ExReleaseFastMutex (&gfxPin->pinQueueSync);
        }

        //
        // If we got some bytes queued on the sink pin yield for 1ms.
        //
        if (bytesQueuedUp)
        {
            LARGE_INTEGER   timeToWait;

            DOUT (DBG_STREAM, ("[GFXPinSetDataFormat] %d Bytes left to process.\n", bytesQueuedUp));
            timeToWait.QuadPart = -10000;   // one ms
            KeDelayExecutionThread (KernelMode, FALSE, &timeToWait);
        }
    } while (bytesQueuedUp);
    
    //
    // Now that every data frame on the sink pin is processed and passed
    // down the stack we can call down with the property too.
    //
    KSPROPERTY      property;
    PIKSCONTROL     pIKsControl;
    ULONG           cbReturned;

    property.Set = KSPROPSETID_Connection;
    property.Id = KSPROPERTY_CONNECTION_DATAFORMAT;
    property.Flags = KSPROPERTY_TYPE_SET;

    //
    // Get a control interface to the pin that is connected with otherPin.
    //
    ntStatus = KsPinGetConnectedPinInterface (otherPin, &IID_IKsControl, (PVOID*)&pIKsControl);
    if (!NT_SUCCESS(ntStatus))
    {
        DOUT (DBG_ERROR, ("[GFXPinSetDataFormat] Could not get pin interface."));
        return ntStatus;
    }

    // Always release the mutex before calling down.
    KsFilterReleaseControl (filter);

    //
    // Call the interface with KSPROPERTY_CONNECTION_DATAFORMAT.
    // Pass in our pin data format as the data format.
    //
    ntStatus = pIKsControl->KsProperty (&property, sizeof(property),
                                        pin->ConnectionFormat, pin->ConnectionFormat->FormatSize,
                                        &cbReturned);

    // Get the control of the filter back!
    KsFilterAcquireControl (filter);

    //
    // We don't need this interface anymore.
    //
    pIKsControl->Release();
    
    //
    // Return the error code from the KsProperty call. If the connected pin
    // changed seccessfully the data format then we can accept this data
    // format too.
    //
    return ntStatus;
}

/*****************************************************************************
 * CGFXPin::SetDeviceState
 *****************************************************************************
 * This function is called on the pin everytime the device state changes.
 */
NTSTATUS CGFXPin::SetDeviceState
(
    IN PKSPIN  pin,
    IN KSSTATE toState,
    IN KSSTATE fromState
)
{
    PAGED_CODE ();

    ASSERT (pin);
    ASSERT (pin->Context);
    
    PKSFILTER   filter;
    PGFXFILTER  gfxFilter;
    PGFXPIN     gfxPin = (PGFXPIN)pin->Context;
    
    DOUT (DBG_PRINT, ("[GFXPinSetDeviceState]"));
    
    //
    // We hold the filter control mutex already. Get the filter and that
    // way to the bytesProcessed variable.
    //
    filter = KsPinGetParentFilter (pin);
    gfxFilter = (PGFXFILTER)filter->Context;

    //
    // We only need to reset the byte counter on STOP.
    // In addition, for synchronization with the set data format handler,
    // we need to set pinQueueValid variable.
    //
    ExAcquireFastMutex (&gfxPin->pinQueueSync);
    if (toState == KSSTATE_STOP)
    {
        gfxFilter->bytesProcessed = 0;
        gfxPin->pinQueueValid = FALSE;
    }
    else
    {
        gfxPin->pinQueueValid = TRUE;
    }
    ExReleaseFastMutex (&gfxPin->pinQueueSync);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::IntersectDataRanges
 *****************************************************************************
 * This routine performs a data range intersection between 2 specific formats.
 * It assumes that it can always return a WAVEFORMATPCMEX structure, that
 * means that the data ranges of this filter cannot be anything else than
 * KSDATAFORMAT_SPECIFIER_WAVEFORMATEX.
 * This function will return STATUS_NO_MATCH if there is no intersection
 * between the 2 data ranges and it will return the "highest" data format if
 * the client's data range contains wildcards.
 * 
 * Arguments:
 *     clientDataRange - pointer to one of the data ranges supplied by the
 *                       client in the data intersection request. The format
 *                       type, subtype and specifier are compatible with the
 *                       DescriptorDataRange.
 *     myDataRange     - pointer to one of the data ranges from the pin
 *                       descriptor for the pin in question.  The format type,
 *                       subtype and specifier are compatible with the
 *                       clientDataRange.
 *     ResultantFormat - pointer to the buffer to contain the data format
 *                       structure representing the best format in the
 *                       intersection of the two data ranges. The buffer is
 *                       big enough to hold a WAVEFORMATPCMEX structure.
 *     ReturnedBytes   - pointer to ULONG containing the number of bytes
 *                       that this routine will write into ResultantFormat.
 *
 * Return Value:
 *    STATUS_SUCCESS if there is an intersection or STATUS_NO_MATCH.
 */
NTSTATUS CGFXPin::IntersectDataRanges
(
    IN PKSDATARANGE clientDataRange,
    IN PKSDATARANGE myDataRange,
    OUT PVOID       ResultantFormat,
    OUT PULONG      ReturnedBytes
)
{
    DOUT (DBG_PRINT, ("[GFXPinIntersectDataRanges]"));

    //
    // Handle the wildcards. KS checked that the GUIDS will match either with
    // a wildcard or exactly.
    //
    if (IsEqualGUIDAligned (clientDataRange->Specifier,  KSDATAFORMAT_SPECIFIER_WILDCARD))
    {
        //
        // If there is a wildcard passed in and all the other fields fit, then we can
        // return the best format in the current data range.
        //
        
        // First copy the GUIDs
        *(PKSDATAFORMAT)ResultantFormat = *myDataRange;
        
        //
        // Append the WAVEFORMATPCMEX structure.
        //
        PWAVEFORMATPCMEX WaveFormat = (PWAVEFORMATPCMEX)((PKSDATAFORMAT)ResultantFormat + 1);

        // We want a WAFEFORMATEXTENSIBLE which is equal to WAVEFORMATPCMEX.
        WaveFormat->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
        // Set the number of channels
        WaveFormat->Format.nChannels = (WORD)((PKSDATARANGE_AUDIO)myDataRange)->MaximumChannels;
        // Set the sample frequency
        WaveFormat->Format.nSamplesPerSec = ((PKSDATARANGE_AUDIO)myDataRange)->MaximumSampleFrequency;
        // Set the bits per sample
        WaveFormat->Format.wBitsPerSample = (WORD)((PKSDATARANGE_AUDIO)myDataRange)->MaximumBitsPerSample;
        // Calculate one sample block (a frame).
        WaveFormat->Format.nBlockAlign = (WaveFormat->Format.wBitsPerSample * WaveFormat->Format.nChannels) / 8;
        // That is played in a sec.
        WaveFormat->Format.nAvgBytesPerSec = WaveFormat->Format.nSamplesPerSec * WaveFormat->Format.nBlockAlign;
        // WAVEFORMATPCMEX
        WaveFormat->Format.cbSize = 22;
        // We have as many valid bits as the bit depth is.
        WaveFormat->Samples.wValidBitsPerSample = WaveFormat->Format.wBitsPerSample;
        // Set the channel mask
        ASSERT (WaveFormat->dwChannelMask == 2);
        WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
        // Here we specify the subtype of the WAVEFORMATEXTENSIBLE.
        WaveFormat->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        
        //
        // Modify the size of the data format structure to fit the WAVEFORMATPCMEX
        // structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->FormatSize =
            sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
        
        //
        // Now overwrite also the sample size in the KSDATAFORMAT structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->SampleSize = WaveFormat->Format.nBlockAlign;

        //
        // That we will return.
        //
        *ReturnedBytes = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    }
    else
    {
        //
        // Check the passed data range format.
        //
        if (clientDataRange->FormatSize < sizeof(KSDATARANGE_AUDIO))
            return STATUS_INVALID_PARAMETER;
        
        //
        // Verify that we have an intersection with the specified data range and
        // our audio data range.
        //
        if ((((PKSDATARANGE_AUDIO)clientDataRange)->MinimumSampleFrequency >
             ((PKSDATARANGE_AUDIO)myDataRange)->MaximumSampleFrequency) ||
            (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumSampleFrequency <
             ((PKSDATARANGE_AUDIO)myDataRange)->MinimumSampleFrequency) ||
            (((PKSDATARANGE_AUDIO)clientDataRange)->MinimumBitsPerSample >
             ((PKSDATARANGE_AUDIO)myDataRange)->MaximumBitsPerSample) ||
            (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumBitsPerSample <
             ((PKSDATARANGE_AUDIO)myDataRange)->MinimumBitsPerSample))
        {
            return STATUS_NO_MATCH;
        }

        //
        // Since we have a match now, build the data format for our buddy.
        //

        // First copy the GUIDs
        *(PKSDATAFORMAT)ResultantFormat = *myDataRange;
        
        //
        // Append the WAVEFORMATPCMEX structure.
        //
        PWAVEFORMATPCMEX WaveFormat = (PWAVEFORMATPCMEX)((PKSDATAFORMAT)ResultantFormat + 1);

        // We want a WAFEFORMATEXTENSIBLE which is equal to WAVEFORMATPCMEX.
        WaveFormat->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
        // Set the number of channels
        WaveFormat->Format.nChannels = (WORD)
            min (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumChannels,
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumChannels);
        // Set the sample frequency
        WaveFormat->Format.nSamplesPerSec =
            min (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumSampleFrequency,
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumSampleFrequency);
        // Set the bits per sample
        WaveFormat->Format.wBitsPerSample = (WORD)
            min (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumBitsPerSample,
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumBitsPerSample);
        // Calculate one sample block (a frame).
        WaveFormat->Format.nBlockAlign = (WaveFormat->Format.wBitsPerSample * WaveFormat->Format.nChannels) / 8;
        // That is played in a sec.
        WaveFormat->Format.nAvgBytesPerSec = WaveFormat->Format.nSamplesPerSec * WaveFormat->Format.nBlockAlign;
        // WAVEFORMATPCMEX
        WaveFormat->Format.cbSize = 22;
        // We have as many valid bits as the bit depth is.
        WaveFormat->Samples.wValidBitsPerSample = WaveFormat->Format.wBitsPerSample;
        // Set the channel mask
        if (WaveFormat->Format.nChannels == 1)
        {
            WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_MONO;
        }
        else
        {
            // We can have only 1 or 2 channels in this sample.
            ASSERT (WaveFormat->Format.nChannels == 2);
            WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
        }
        // Here we specify the subtype of the WAVEFORMATEXTENSIBLE.
        WaveFormat->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;

        //
        // Modify the size of the data format structure to fit the WAVEFORMATPCMEX
        // structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->FormatSize =
            sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    
        //
        // Now overwrite also the sample size in the KSDATAFORMAT structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->SampleSize = WaveFormat->Format.nBlockAlign;
    
        //
        // That we will return.
        //
        *ReturnedBytes = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::DataRangeIntersection
 *****************************************************************************
 * This routine handles pin data intersection queries by determining the
 * intersection between two data ranges.
 * 
 * Arguments:
 *    Filter          - void pointer to the filter structure.
 *    Irp             - pointer to the data intersection property request.
 *    PinInstance     - pointer to a structure indicating the pin in question.
 *    CallerDataRange - pointer to one of the data ranges supplied by the client
 *                      in the data intersection request.  The format type, subtype
 *                      and specifier are compatible with the DescriptorDataRange.
 *    OurDataRange    - pointer to one of the data ranges from the pin descriptor
 *                      for the pin in question.  The format type, subtype and
 *                      specifier are compatible with the CallerDataRange.
 *    BufferSize      - size in bytes of the buffer pointed to by the Data
 *                      argument.  For size queries, this value will be zero.
 *    Data            - optionall. Pointer to the buffer to contain the data format
 *                      structure representing the best format in the intersection
 *                      of the two data ranges.  For size queries, this pointer will
 *                      be NULL.
 *    DataSize        - pointer to the location at which to deposit the size of the
 *                      data format.  This information is supplied by the function
 *                      when the format is actually delivered and in response to size
 *                      queries.
 *
 * Return Value:
 *    STATUS_SUCCESS if there is an intersection and it fits in the supplied
 *    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
 *    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
 *    buffer is too small.
 */
NTSTATUS CGFXPin::DataRangeIntersection
(
    IN PVOID        Filter,
    IN PIRP         Irp,
    IN PKSP_PIN     PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE OurDataRange,
    IN ULONG        BufferSize,
    OUT PVOID       Data OPTIONAL,
    OUT PULONG      DataSize
)
{
    PAGED_CODE();

    PKSFILTER filter = (PKSFILTER) Filter;
    PKSPIN    pin;
    NTSTATUS  ntStatus;

    DOUT (DBG_PRINT, ("[DataRangeIntersection]"));

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(OurDataRange);
    ASSERT(DataSize);

    //
    // We need to have the same data format on both pins. So, first look if
    // the other pin is already open, then return the data format of that
    // pin instance.
    // If the other pin is not open, do a real data range intersection.
    //
    if (PinInstance->PinId == GFX_SINK_PIN)
    {
        pin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
    }
    else
    {
        pin = KsFilterGetFirstChildPin (filter, GFX_SINK_PIN);
    }

    if (!pin)
    {
        //
        // Do the data range instersection here. The returned data format
        // will always be a KSDATAFORMAT_WAVEFORMATPCMEX for now.
        //

        //
        // Validate return buffer size, if the request is only for the
        // size of the resultant structure, return it now.
        //
        if (!BufferSize)
        {
            *DataSize = sizeof (KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            if (BufferSize < (sizeof (KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX)))
            {
                ntStatus =  STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                //
                // Check if there is a match.
                //
                ntStatus = IntersectDataRanges (CallerDataRange, OurDataRange, Data, DataSize);

                if (NT_SUCCESS (ntStatus))
                {
                    PWAVEFORMATEX   pWvFmt = (PWAVEFORMATEX)((PKSDATAFORMAT)Data + 1);
                    DOUT (DBG_PRINT, ("[DataRangeIntersection] Intersection returns %d Hz, %d ch, %d bits.",
                                      pWvFmt->nSamplesPerSec, (DWORD)pWvFmt->nChannels, (DWORD)pWvFmt->wBitsPerSample));
                }
            }
        }
    }
    else
    {
        //
        // Validate that the current wave format is part of the data range.
        //
        PWAVEFORMATEX pWvFmt = (PWAVEFORMATEX)(pin->ConnectionFormat + 1);
        if (IsEqualGUIDAligned (CallerDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
        {
            //
            // Check the passed data range format.
            //
            if (CallerDataRange->FormatSize < sizeof(KSDATARANGE_AUDIO))
                return STATUS_INVALID_PARAMETER;

            //
            // Check the range of channels, frequency & bit depth.
            //
            if ((((PKSDATARANGE_AUDIO)CallerDataRange)->MinimumSampleFrequency >
                 pWvFmt->nSamplesPerSec) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MaximumSampleFrequency <
                 pWvFmt->nSamplesPerSec) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MinimumBitsPerSample >
                 pWvFmt->wBitsPerSample) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MaximumBitsPerSample <
                 pWvFmt->wBitsPerSample) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MaximumChannels <
                 pWvFmt->nChannels))
            {
                 return STATUS_NO_MATCH;
            }
        }
        else
        {
            if (!IsEqualGUIDAligned (CallerDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WILDCARD))
                return STATUS_NO_MATCH;
        }
            
            
        //
        // Validate return buffer size, if the request is only for the
        // size of the resultant structure, return it now.
        //    
        if (!BufferSize)
        {
            *DataSize = pin->ConnectionFormat->FormatSize;
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            if (BufferSize < pin->ConnectionFormat->FormatSize)
            {
                ntStatus =  STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                DOUT (DBG_PRINT, ("[DataRangeIntersection] Returning pin's data format."));
                DOUT (DBG_PRINT, ("[DataRangeIntersection] pin->ConnectionFormat: %P.",
                                  pin->ConnectionFormat));
                
                if (pin->ConnectionFormat->FormatSize >= sizeof (KSDATAFORMAT_WAVEFORMATEX))
                {
                    DOUT (DBG_PRINT, ("[DataRangeIntersection] Which is %d Hz, %d ch, %d bits.",
                                      pWvFmt->nSamplesPerSec, (DWORD)pWvFmt->nChannels, (DWORD)pWvFmt->wBitsPerSample));
                }
                
                *DataSize = pin->ConnectionFormat->FormatSize;
                RtlCopyMemory (Data, pin->ConnectionFormat, *DataSize);
                ntStatus = STATUS_SUCCESS;
            }
        }
    } 

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\gfxproppages.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXPropPages.cpp : Implementation of CGFXPropPages
#include "stdafx.h"
#include "GFXProp.h"
#include "GFXPropPages.h"

/////////////////////////////////////////////////////////////////////////////
// CGFXPropPages
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\gfxprop.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXProp.cpp : Implementation of DLL Exports.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f GFXPropps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "GFXProp.h"

#include "GFXProp_i.c"
#include "GFXPropPages.h"
#include "GFXProperty.h"


// We need this for ATL to work.
CComModule _Module;

// This specifies the different CLSIDs that can be created with the IClassFactory
// interface that ATL implements for us. The second parameter specifies the class
// that would be created with that CLSID.
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_GFXPropPages, CGFXPropPages)
    OBJECT_ENTRY(CLSID_GFXProperty, CGFXProperty)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_GFXPROPLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object but not the typelib.
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\resource.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GFXProp.rc
//
#define IDS_PROJNAME                    100
#define IDR_GFXPROPPAGES                101
#define IDS_TITLEGFXProperty            102
#define IDS_HELPFILEGFXProperty         103
#define IDS_DOCSTRINGGFXProperty        104
#define IDR_GFXPROPERTY                 105
#define IDD_GFXPROPERTY                 106
#define IDC_CHANNEL_SWAP                201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\gfxproppages.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXPropPages.h : Declaration of the CGFXPropPages

#ifndef __GFXPROPPAGES_H_
#define __GFXPROPPAGES_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CGFXPropPages
//
// This class only provides the ISpecifyPropertyPages interface that is used
// by mmsys.cpl to query for the GUIDs which represent property pages.
// mmsys.cpl uses these GUIDs to create the property page with
// OleCreatePropertyFrame. OleCreatePropertyFrame will then instanciate these
// objects and attach them to the dialog (means calls them for dialog messages).
//
// NOTE: The CLSID of this object is registered by the INF file to make the
//       Connection between the GFX and the property page.
class ATL_NO_VTABLE CGFXPropPages : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CGFXPropPages, &CLSID_GFXPropPages>,
    public ISpecifyPropertyPagesImpl<CGFXPropPages>
{
public:
    // ATL "secrets"
    DECLARE_REGISTRY_RESOURCEID(IDR_GFXPROPPAGES)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    // This is the only interface we have.
    BEGIN_COM_MAP(CGFXPropPages)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    END_COM_MAP()

    // These are the GUIDs that are returned on a GetPages call.
    BEGIN_PROP_MAP(CGFXPropPages)
        PROP_PAGE(CLSID_GFXProperty)
    END_PROP_MAP()
};

#endif //__GFXPROPPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\driver\pin.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

enum GFXPinIds
{
    GFX_SINK_PIN = 0,
    GFX_SOURCE_PIN
};

typedef class CGFXPin
{
public:
    BOOL        rejectDataFormatChange;
    BOOL        pinQueueValid;
    FAST_MUTEX  pinQueueSync;

public:
    CGFXPin() {pinQueueValid = FALSE;};
    ~CGFXPin() {};

    //
    // The functions here are static so that we can add them to the
    // dispatch function table. Some also might be called when the
    // object itself is not yet created.
    //
    static NTSTATUS Create
    (
        IN PKSPIN   pin,
        IN PIRP     Irp
    );

    static NTSTATUS Close
    (
        IN PKSPIN   pin,
        IN PIRP     Irp
    );

    static NTSTATUS SetDataFormat
    (
        IN PKSPIN                   pin,
        IN PKSDATAFORMAT            oldFormat,
        IN PKSMULTIPLE_ITEM         oldAttributeList,
        IN const KSDATARANGE        *DataRange,
        IN const KSATTRIBUTE_LIST   *AttributeRange
    );

    static NTSTATUS SetDeviceState
    (
        IN PKSPIN  pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
    );
    
    static NTSTATUS DataRangeIntersection
    (
        IN PVOID        Filter,
        IN PIRP         Irp,
        IN PKSP_PIN     PinInstance,
        IN PKSDATARANGE CallerDataRange,
        IN PKSDATARANGE OurDataRange,
        IN ULONG        BufferSize,
        OUT PVOID       Data OPTIONAL,
        OUT PULONG      DataSize
    );

private:
    //
    // These functions are static because they need to be called
    // even if the object doesn't exist.
    //
    static NTSTATUS ValidateDataFormat
    (
        IN PKSDATAFORMAT DataFormat,
        IN PKSDATARANGE  DataRange
    );

    static NTSTATUS IntersectDataRanges
    (
        IN PKSDATARANGE clientDataRange,
        IN PKSDATARANGE myDataRange,
        OUT PVOID       ResultantFormat,
        OUT PULONG      ReturnedBytes
    );
} GFXPIN, *PGFXPIN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\stdafx.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\inc\msgfx.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// This is the sample GFX property set ID.
// Please use your own GUIDs in your GFX.
//
#define STATIC_KSPROPSETID_MsGfxSample \
    0xec1699d5, 0x2845, 0x4ca2, 0xbe, 0x7d, 0x8c, 0xe4, 0x62, 0xfd, 0xac, 0x2b
DEFINE_GUIDSTRUCT("EC1699D5-2845-4ca2-BE7D-8CE462FDAC2B", KSPROPSETID_MsGfxSample);
#define KSPROPSETID_MsGfxSample DEFINE_GUIDNAMED(KSPROPSETID_MsGfxSample)

//
// These are the defined methods that the property supports.
// KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP will be used to set/get the "channel swap"
// flag.
//
typedef enum {
    KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP = 1
} KSPROPERTY_MSGFXSAMPLE_NODE;


//
// This property set is used to save the state of the GFX.
// Please use your own GUIDs in your GFX.
//
#define STATIC_KSPROPSETID_SaveState \
    0xe04db855, 0x1846, 0x4c9d, 0xb5, 0x57, 0x8a, 0xf7, 0x55, 0x5a, 0xbe, 0x57
DEFINE_GUIDSTRUCT("E04DB855-1846-4c9d-B557-8AF7555ABE57", KSPROPSETID_SaveState);
#define KSPROPSETID_SaveState DEFINE_GUIDNAMED(KSPROPSETID_SaveState)

//
// These are the defined methods that the property supports.
// KSPROPERTY_MSGFXSAMPLE_SAVESTATE will be used to save the "channel swap"
// flag.
//
typedef enum {
    KSPROPERTY_MSGFXSAMPLE_SAVESTATE = 1
} KSPROPERTY_MSGFXSAMPLE_FILTER;


//
// This GUID defines the type for the "channel swap" node.
// Please use your own GUIDs in your GFX.
//
#define STATIC_GFXSAMPLE_NODETYPE_CHANNEL_SWAP \
    0x4398814d, 0xeb1c, 0x4b99, 0x97, 0x61, 0x3c, 0x24, 0xc9, 0x2e, 0xb7, 0xcb
DEFINE_GUIDSTRUCT("4398814D-EB1C-4b99-9761-3C24C92EB7CB", GFXSAMPLE_NODETYPE_CHANNEL_SWAP);
#define GFXSAMPLE_NODETYPE_CHANNEL_SWAP DEFINE_GUIDNAMED(GFXSAMPLE_NODETYPE_CHANNEL_SWAP)

//
// This GUID defines the name for the "channel swap" node.
// Note that the name & GUID are linked together in the INF file.
// Please use your own GUIDs in your GFX.
//
#define STATIC_GFXSAMPLE_NODENAME_CHANNEL_SWAP \
    0x2b143fe6, 0x4f67, 0x4b12, 0x80, 0x39, 0xce, 0x03, 0xeb, 0xef, 0x12, 0x90
DEFINE_GUIDSTRUCT("2B143FE6-4F67-4b12-8039-CE03EBEF1290", GFXSAMPLE_NODENAME_CHANNEL_SWAP);
#define GFXSAMPLE_NODENAME_CHANNEL_SWAP DEFINE_GUIDNAMED(GFXSAMPLE_NODENAME_CHANNEL_SWAP)

//
// This GUID defines the name for the GFXSwap filter.
// Note that the name & GUID are linked together in the INF file.
// Please use your own GUIDs in your GFX.
//
#define STATIC_KSNAME_MsGfxSample \
    0x9b365890, 0x165f, 0x11d0, 0xa1, 0x9f, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", KSNAME_MsGfxSample);
#define KSNAME_MsGfxSample DEFINE_GUIDNAMED(KSNAME_MsGfxSample)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\samples\gfxswap\gfxprop\stdafx.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__722DC775_FE6F_42FB_BED5_E1E299976D17__INCLUDED_)
#define AFX_STDAFX_H__722DC775_FE6F_42FB_BED5_E1E299976D17__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__722DC775_FE6F_42FB_BED5_E1E299976D17__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\splitter\device.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    device.c

Abstract:
    
    This module implements the device object interface.

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/

#define KSDEBUG_INIT

#include "private.h"


ULONG gBufferDuration;


#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


//---------------------------------------------------------------------------


NTSTATUS
QueryRegistryValueEx(
    ULONG Hive,
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG uValueType,
    PVOID *ppValue,
    PVOID pDefaultData,
    ULONG DefaultDataLength
)
{
    PRTL_QUERY_REGISTRY_TABLE pRegistryValueTable = NULL;
    UNICODE_STRING usString;
    DWORD dwValue;
    NTSTATUS Status = STATUS_SUCCESS;
    usString.Buffer = NULL;

    pRegistryValueTable = (PRTL_QUERY_REGISTRY_TABLE) ExAllocatePoolWithTag(
                            PagedPool,
                            (sizeof(RTL_QUERY_REGISTRY_TABLE)*2),
                            POOLTAG_SPLITTER);

    if(!pRegistryValueTable) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(pRegistryValueTable, (sizeof(RTL_QUERY_REGISTRY_TABLE)*2));

    pRegistryValueTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    pRegistryValueTable[0].Name = pwstrRegistryValue;
    pRegistryValueTable[0].DefaultType = uValueType;
    pRegistryValueTable[0].DefaultLength = DefaultDataLength;
    pRegistryValueTable[0].DefaultData = pDefaultData;

    switch (uValueType) {
        case REG_SZ:
            pRegistryValueTable[0].EntryContext = &usString;
            break;
        case REG_DWORD:
            pRegistryValueTable[0].EntryContext = &dwValue;
            break;
        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }

    Status = RtlQueryRegistryValues(
      Hive,
      pwstrRegistryPath,
      pRegistryValueTable,
      NULL,
      NULL);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    switch (uValueType) {
        case REG_SZ:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        usString.Length + sizeof(UNICODE_NULL),
                        POOLTAG_SPLITTER);
            if(!(*ppValue)) {
                RtlFreeUnicodeString(&usString);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            memcpy(*ppValue, usString.Buffer, usString.Length);
            ((PWCHAR)*ppValue)[usString.Length/sizeof(WCHAR)] = UNICODE_NULL;

            RtlFreeUnicodeString(&usString);
            break;

        case REG_DWORD:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(DWORD),
                        POOLTAG_SPLITTER);
            if(!(*ppValue)) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            *((DWORD *)(*ppValue)) = dwValue;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }
exit:
    if (pRegistryValueTable) {
        ExFreePool(pRegistryValueTable);
    }
    return(Status);
}


ULONG
GetUlongFromRegistry(
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG DefaultValue
)
{
    PVOID      pulValue ;
    ULONG       ulValue ;
    NTSTATUS    Status ;

    Status = QueryRegistryValueEx(RTL_REGISTRY_ABSOLUTE,
                         pwstrRegistryPath,
                         pwstrRegistryValue,
                         REG_DWORD,
                         &pulValue,
                         &DefaultValue,
                         sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        ulValue = *((PULONG)pulValue);
        ExFreePool(pulValue);
    }
    else {
        ulValue = DefaultValue;
    }
    return ( ulValue ) ;
}


//---------------------------------------------------------------------------




NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
{

    // Query the registry for the default audio buffer duration.

    gBufferDuration = GetUlongFromRegistry( CORE_AUDIO_BUFFER_DURATION_PATH,
                                            CORE_AUDIO_BUFFER_DURATION_VALUE,
                                            DEFAULT_CORE_AUDIO_BUFFER_DURATION );

    // Limit duration maximum.

    if ( gBufferDuration > MAX_CORE_AUDIO_BUFFER_DURATION ) {

        gBufferDuration = MAX_CORE_AUDIO_BUFFER_DURATION;

    }

    // Limit duration minimum.

    if ( gBufferDuration < MIN_CORE_AUDIO_BUFFER_DURATION ) {

        gBufferDuration = MIN_CORE_AUDIO_BUFFER_DURATION;

    }

    return 
        KsInitializeDriver(
            DriverObject,
            RegistryPathName,
            &DeviceDescriptor);
}

#if (DBG)

PSZ
DbgGuid2Sz(
    GUID *pGuid
)
{
    static char sz[256];
    if(pGuid == NULL) {
        return("NO GUID");
    }
    if(IsEqualGUID(
      &GUID_NULL,
      pGuid)) {
        return("GUID_NULL");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_TYPE_AUDIO,
      pGuid)) {
        return("KSDATAFORMAT_TYPE_AUDIO");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_ANALOG,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_ANALOG");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_PCM,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_PCM");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_IEEE_FLOAT");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_TYPE_MUSIC,
      pGuid)) {
        return("KSDATAFORMAT_TYPE_MUSIC");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_MIDI,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_MIDI");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_MIDI_BUS,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_MIDI_BUS");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_DSOUND");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_WAVEFORMATEX");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_NONE,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_NONE");
    }
    if(IsEqualGUID(
      &KSCATEGORY_AUDIO,
      pGuid)) {
        return("KSCATEGORY_AUDIO");
    }
    if(IsEqualGUID(
      &KSNODETYPE_SPEAKER,
      pGuid)) {
        return("KSNODETYPE_SPEAKER");
    }
    if(IsEqualGUID(
      &KSNODETYPE_MICROPHONE,
      pGuid)) {
        return("KSNODETYPE_MICROPHONE");
    }
    if(IsEqualGUID(
      &KSNODETYPE_CD_PLAYER,
      pGuid)) {
        return("KSNODETYPE_CD_PLAYER");
    }
    if(IsEqualGUID(
      &KSNODETYPE_LEGACY_AUDIO_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_LEGACY_AUDIO_CONNECTOR");
    }
    if(IsEqualGUID(
      &KSNODETYPE_ANALOG_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_ANALOG_CONNECTOR");
    }
    if(IsEqualGUID(
      &KSCATEGORY_WDMAUD_USE_PIN_NAME,
      pGuid)) {
        return("KSCATEGORY_WDMAUD_USE_PIN_NAME");
    }
    if(IsEqualGUID(
      &KSNODETYPE_LINE_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_LINE_CONNECTOR");
    }
    if(IsEqualGUID(
      &PINNAME_CAPTURE,
      pGuid)) {
        return("PINNAME_CAPTURE");
    }
    if(IsEqualGUID(&KSNODETYPE_DAC, pGuid)) {
	return("KSNODETYPE_DAC");
    }
    if(IsEqualGUID(&KSNODETYPE_ADC, pGuid)) {
	return("KSNODETYPE_ADC");
    }
    if(IsEqualGUID(&KSNODETYPE_SRC, pGuid)) {
	return("KSNODETYPE_SRC");
    }
    if(IsEqualGUID(&KSNODETYPE_SUPERMIX, pGuid)) {
	return("KSNODETYPE_SUPERMIX");
    }
    if(IsEqualGUID( &KSNODETYPE_MUX, pGuid)) {
	return("KSNODETYPE_MUX");
    }
    if(IsEqualGUID( &KSNODETYPE_DEMUX, pGuid)) {
	return("KSNODETYPE_DEMUX");
    }
    if(IsEqualGUID(&KSNODETYPE_SUM, pGuid)) {
	return("KSNODETYPE_SUM");
    }
    if(IsEqualGUID(&KSNODETYPE_MUTE, pGuid)) {
	return("KSNODETYPE_MUTE");
    }
    if(IsEqualGUID(&KSNODETYPE_VOLUME, pGuid)) {
	return("KSNODETYPE_VOLUME");
    }
    if(IsEqualGUID(&KSNODETYPE_TONE, pGuid)) {
	return("KSNODETYPE_TONE");
    }
    if(IsEqualGUID(&KSNODETYPE_AGC, pGuid)) {
	return("KSNODETYPE_AGC");
    }
    if(IsEqualGUID(&KSNODETYPE_SYNTHESIZER, pGuid)) {
	return("KSNODETYPE_SYNTHESIZER");
    }
    if(IsEqualGUID(&KSNODETYPE_3D_EFFECTS, pGuid)) {
	return("KSNODETYPE_3D_EFFECTS");
    }
    sprintf(sz, "%08x %04x %04x %02x%02x%02x%02x%02x%02x%02x%02x",
      pGuid->Data1,
      pGuid->Data2,
      pGuid->Data3,
      pGuid->Data4[0],
      pGuid->Data4[1],
      pGuid->Data4[2],
      pGuid->Data4[3],
      pGuid->Data4[4],
      pGuid->Data4[5],
      pGuid->Data4[6],
      pGuid->Data4[7]);

    return(sz);
}

VOID
DumpDataRange(
    ULONG Level,
    PKSDATARANGE_AUDIO pDataRangeAudio
)
{
    _DbgPrintF(Level,
      (" FormatSize: %02x Flags: %08x SampleSize: %02x Reserved: %08x",
      pDataRangeAudio->DataRange.FormatSize,
      pDataRangeAudio->DataRange.Flags,
      pDataRangeAudio->DataRange.SampleSize,
      pDataRangeAudio->DataRange.Reserved));
    _DbgPrintF(Level, ("MajorFormat: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.MajorFormat)));
    _DbgPrintF(Level, ("  SubFormat: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.SubFormat)));
    _DbgPrintF(Level, ("  Specifier: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.Specifier)));

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      &pDataRangeAudio->DataRange.Specifier)) {

	_DbgPrintF(Level,
	 ("WaveFmtEx: MaxCH %d MaxSR %u MinSR %u MaxBPS %u MinBPS %u",
          pDataRangeAudio->MaximumChannels,
          pDataRangeAudio->MinimumSampleFrequency,
          pDataRangeAudio->MaximumSampleFrequency,
          pDataRangeAudio->MinimumBitsPerSample,
          pDataRangeAudio->MaximumBitsPerSample));
    }

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      &pDataRangeAudio->DataRange.Specifier)) {

	_DbgPrintF(Level,
	  ("DSOUND:    MaxCH %d MaxSR %u MinSR %u MaxBPS %u MinBPS %u",
          pDataRangeAudio->MaximumChannels,
          pDataRangeAudio->MinimumSampleFrequency,
          pDataRangeAudio->MaximumSampleFrequency,
          pDataRangeAudio->MinimumBitsPerSample,
          pDataRangeAudio->MaximumBitsPerSample));

    }
}

VOID
DumpDataFormat(
    ULONG Level,
    PKSDATAFORMAT pDataFormat
)
{
    _DbgPrintF(Level,
      (" FormatSize: %02x Flags: %08x SampleSize: %02x Reserved: %08x",
      pDataFormat->FormatSize,
      pDataFormat->Flags,
      pDataFormat->SampleSize,
      pDataFormat->Reserved));
    _DbgPrintF(Level,
      ("MajorFormat: %s", DbgGuid2Sz(&pDataFormat->MajorFormat)));
    _DbgPrintF(Level,
      ("  SubFormat: %s", DbgGuid2Sz(&pDataFormat->SubFormat)));
    _DbgPrintF(Level,
      ("  Specifier: %s", DbgGuid2Sz(&pDataFormat->Specifier)));

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      &pDataFormat->Specifier)) {

        _DbgPrintF(Level,
	  ("WaveFmtEx: %u SR: %u CH: %u BPS %u ABPS %u BA %u cb %u",
          ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->
            WaveFormatEx.wFormatTag,
          ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->
            WaveFormatEx.nSamplesPerSec,
          ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->
            WaveFormatEx.nChannels,
          ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->
            WaveFormatEx.wBitsPerSample,
          ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->
            WaveFormatEx.nAvgBytesPerSec,
          ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->
            WaveFormatEx.nBlockAlign,
          ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->
            WaveFormatEx.cbSize));
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      &pDataFormat->Specifier)) {

        _DbgPrintF(Level,
	  ("DSOUND:    %u SR: %u CH: %u BPS %u ABPS %u BA %u cb %u",
          ((PKSDATAFORMAT_DSOUND)pDataFormat)->
            BufferDesc.WaveFormatEx.wFormatTag,
          ((PKSDATAFORMAT_DSOUND)pDataFormat)->
            BufferDesc.WaveFormatEx.nSamplesPerSec,
          ((PKSDATAFORMAT_DSOUND)pDataFormat)->
            BufferDesc.WaveFormatEx.nChannels,
          ((PKSDATAFORMAT_DSOUND)pDataFormat)->
            BufferDesc.WaveFormatEx.wBitsPerSample,
          ((PKSDATAFORMAT_DSOUND)pDataFormat)->
            BufferDesc.WaveFormatEx.nAvgBytesPerSec,
          ((PKSDATAFORMAT_DSOUND)pDataFormat)->
            BufferDesc.WaveFormatEx.nBlockAlign,
          ((PKSDATAFORMAT_DSOUND)pDataFormat)->
            BufferDesc.WaveFormatEx.cbSize));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\splitter\private.h ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Private.h

Abstract:


Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/


#if !defined( _PRIVATE_ )
#define _PRIVATE_

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksmediap.h>
#if (DBG)
//
// debugging specific constants
//
#define STR_MODULENAME "splitter: "
#define DEBUG_VARIABLE SPLITTERDebug
#endif
#include <ksdebug.h>

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// constant definitions
//

#define ID_DATA_OUTPUT_PIN		0
#define ID_DATA_INPUT_PIN		1

#define POOLTAG_SPLITTER		'TLPS'		// SPLT
#define POOLTAG_ALLOCATORFRAMING	'TLPS'		// SPLT
#define POOLTAG_AUDIOPOSITION 	    	'TLPS'		// SPLT

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// global data
//
                    
// filter.c:

extern const KSDEVICE_DESCRIPTOR DeviceDescriptor;
extern const KSALLOCATOR_FRAMING_EX AllocatorFraming;

extern ULONG gBufferDuration;


//
// local prototypes
//

//---------------------------------------------------------------------------
// filter.c:

NTSTATUS
FilterProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    );
NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );

//---------------------------------------------------------------------------
// pins.c:

NTSTATUS
PinCreate(
    IN PKSPIN Pin,
    IN PIRP Irp
    );

NTSTATUS
PinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    );

NTSTATUS
PinState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    );

void
PinReset(
    IN PKSPIN Pin
    );

NTSTATUS
PropertyAudioPosition(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
);

#if (DBG)

VOID
DumpDataFormat(
    ULONG Level,
    PKSDATAFORMAT pDataFormat
);

VOID
DumpDataRange(
    ULONG Level,
    PKSDATARANGE_AUDIO pDataRangeAudio
);

#endif

#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\splitter\filter.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    filter.c

Abstract:

    This module implements the filter object interface.

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IntersectHandler)
#endif // ALLOC_PRAGMA

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

//
// Define the wildcard data format.
//

const KSDATARANGE WildcardDataFormat =
{
    sizeof( WildcardDataFormat ),
    0, // ULONG Flags
    0, // ULONG SampleSize
    0, // ULONG Reserved
    STATICGUIDOF( KSDATAFORMAT_TYPE_AUDIO ),
    STATICGUIDOF( KSDATAFORMAT_SUBTYPE_WILDCARD ),
    STATICGUIDOF( KSDATAFORMAT_SPECIFIER_WILDCARD )
};


const PKSDATARANGE PinFormatRanges[] =
{
    (PKSDATARANGE)&WildcardDataFormat
};


//
// Define pin allocator framing.
//

// Note that these are defaults.  They should never be used in practice
// because we change the allocator buffer size at pin creation time to reflect
// the actual sample rate of the data we will be processing.  This is done
// at pin creation time by going down to the pin we are connected to (normally
// portcls) and using ITS allocator framing information.  Currently portcls
// reports a framing that varies depending on the data format so that all
// frames have a duration equal to that specified in the registry or
// DEFAULT_CORE_AUDIO_BUFFER_DURATION if no registry value is specified.

#if !DEFAULT_CORE_AUDIO_BUFFER_DURATION
#error DEFAULT_CORE_AUDIO_BUFFER_DURATION must be non zero!
#endif

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming, 
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED, 
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    8,                      // 8 buffers max
    63,                     // 64 byte aligned
    // WARNING!!! DO NOT CHANGE THE BELOW ROUNDING.
    // THE ROUNDING IS DONE SO THAT IT GUARANTEES THAT BOTH OF THE FOLLOWING
    // VALUES ARE NON ZERO!  IT ALSO GUARANTEES THAT IN CASES WHEN THE DURATION
    // DOES NOT EQUAL AN EXACT NUMBER OF SAMPLES, THEN IT LEAVES SPACE FOR THE
    // OCCASIONAL EXTRA SAMPLE!  IN CASES OF EXACT MATCHES, IT DOES NOT ADD
    // SPACE FOR AN EXTRA SAMPLE.
    (((192000/1000)*DEFAULT_CORE_AUDIO_BUFFER_DURATION*2*2)+999)/1000,   // (192kHz/1000ms/sec)*?usec*2channels*2bytespersample rounded up
    (((192000/1000)*DEFAULT_CORE_AUDIO_BUFFER_DURATION*2*2)+999)/1000     
    // WARNING!!! DO NOT CHANGE THE ABOVE ROUNDING.  SEE ABOVE COMMENT.
);

DEFINE_KSPROPERTY_TABLE(AudioPinPropertyTable) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_POSITION,
        PropertyAudioPosition,
        sizeof(KSPROPERTY),
        sizeof(KSAUDIO_POSITION),
        PropertyAudioPosition,
        NULL,
        0,
        NULL,
        NULL,
        0)
};

DEFINE_KSPROPERTY_SET_TABLE(PinPropertySetTable) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Audio,
        SIZEOF_ARRAY(AudioPinPropertyTable),
        AudioPinPropertyTable,
        0,
        NULL)
};

DEFINE_KSAUTOMATION_TABLE(PinAutomationTable) {
    DEFINE_KSAUTOMATION_PROPERTIES(PinPropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
// Define splitter pins.
//

const
KSPIN_DISPATCH
PinDispatch =
{
    PinCreate,
    PinClose,
    NULL,// Process
    PinReset,// Reset
    NULL,// SetDataFormat
    PinState,// SetDeviceState
    NULL,// Connect
    NULL// Disconnect
};

const
KSPIN_DESCRIPTOR_EX
PinDescriptors[] =
{
    {   
        &PinDispatch,
        &PinAutomationTable,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            &PINNAME_CAPTURE, //Category
            0
        },
        KSPIN_FLAG_DENY_USERMODE_ACCESS |
        KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING |
        KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING |
        KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE |
        KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL, //Flags
        KSINSTANCE_INDETERMINATE,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    },
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            NULL,//Category
            0
        },
        KSPIN_FLAG_DENY_USERMODE_ACCESS |
        KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING |
        KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE |
        KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL, //Flags
        1,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    }
};

//
// Define splitter topology
//

const KSNODE_DESCRIPTOR NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR(
        NULL,
        &KSCATEGORY_AUDIO_SPLITTER,		// GUID *Type
        NULL)					// GUID *Name
};

//
// Define filter dispatch table
//

const
KSFILTER_DISPATCH
FilterDispatch =
{
    NULL,		// Create
    NULL,		// Close
    FilterProcess,	// Process
    NULL		// Reset
};

//
// Define filter categories
//

const GUID Categories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_AUDIO_SPLITTER)
};

//
// Define filter
//

DEFINE_KSFILTER_DESCRIPTOR(FilterDescriptor)
{   
    &FilterDispatch,
    NULL, //AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,
    KSFILTER_FLAG_DENY_USERMODE_ACCESS |
    KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING, //Flags
    &KSNAME_Filter,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptors),
    DEFINE_KSFILTER_CATEGORIES(Categories),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{
    &FilterDescriptor,
};

//
// Define device
//

const
KSDEVICE_DESCRIPTOR 
DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptors),
    FilterDescriptors
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

{
    PKSFILTER filter = (PKSFILTER) Filter;
    PKSPIN pin;
    NTSTATUS status;

    _DbgPrintF(DEBUGLVL_BLAB,("[IntersectHandler]"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Find a pin instance if there is one.  Try the supplied pin type first.
    // If there is no pin, we fail to force the graph builder to try the
    // other filter.

    // KS has already grabbed the control mutex for the filter when we are called
    // so it is safe for us to look at other pins.

    pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId);
    if (! pin) {
        pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId ^ 1);
    }

    if (! pin) {
        status = STATUS_NO_MATCH;
    } else {
        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if ((!IsEqualGUIDAligned( 
                &CallerDataRange->SubFormat,
                &pin->ConnectionFormat->SubFormat ) &&
             !IsEqualGUIDAligned( 
                &CallerDataRange->SubFormat,
                &KSDATAFORMAT_SUBTYPE_WILDCARD )) || 
            (!IsEqualGUIDAligned(  
                &CallerDataRange->Specifier, 
                &pin->ConnectionFormat->Specifier ) &&
             !IsEqualGUIDAligned( 
                &CallerDataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_WILDCARD ))) {
	#if (DBG)
            _DbgPrintF( 
              DEBUGLVL_VERBOSE, ("range does not match current format") );
	    DumpDataFormat(
	      DEBUGLVL_VERBOSE, pin->ConnectionFormat);
	    DumpDataRange(
	      DEBUGLVL_VERBOSE, (PKSDATARANGE_AUDIO)CallerDataRange);
	#endif
            status = STATUS_NO_MATCH;
        } else {
            //
            // Validate return buffer size, if the request is only for the
            // size of the resultant structure, return it now.
            //    
            if (!BufferSize) {
                *DataSize = pin->ConnectionFormat->FormatSize;
                status = STATUS_BUFFER_OVERFLOW;
            } else if (BufferSize < pin->ConnectionFormat->FormatSize) {
                status =  STATUS_BUFFER_TOO_SMALL;
            } 
            else {
                #if (DBG)
                _DbgPrintF(DEBUGLVL_VERBOSE, ("IntersectHandler returns:") );
                DumpDataFormat(DEBUGLVL_VERBOSE, pin->ConnectionFormat);
                #endif
                *DataSize = pin->ConnectionFormat->FormatSize;
                RtlCopyMemory( Data, pin->ConnectionFormat, *DataSize );
                status = STATUS_SUCCESS;
            }
        }
    } 

    return status;
}


NTSTATUS
FilterProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    )

/*++

Routine Description:

    This routine is called when there is data to be processed.

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        array of pointers to process pins.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    Indication of whether more processing should be done if frames are 
    available.  A value of STATUS_PENDING indicates that processing should not
    continue even if frames are available on all required queues.  
    STATUS_SUCCESS indicates processing should continue if frames are
    available on all required queues.

Structures:

    struct _KSPROCESSPIN {
	PKSPIN Pin;
	PKSSTREAM_POINTER StreamPointer;
	PKSPROCESSPIN InPlaceCounterpart;
	PKSPROCESSPIN DelegateBranch;
	PKSPROCESSPIN CopySource;
	PVOID Data;
	ULONG BytesAvailable;
	ULONG BytesUsed;
	ULONG Flags;
	BOOLEAN Terminate;
    };
--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PKSAUDIO_POSITION pAudioPosition;
    PKSPROCESSPIN processPinInput;
    PKSPROCESSPIN processPinOutput;
    ULONG byteCount;
    ULONG i;


    //
    // Determine how much data we can process this time.
    //
    ASSERT(ProcessPinsIndex[ID_DATA_INPUT_PIN].Count == 1);

    processPinInput = ProcessPinsIndex[ID_DATA_INPUT_PIN].Pins[0];
    ASSERT(processPinInput != NULL);
    ASSERT(processPinInput->Data != NULL);

    byteCount = processPinInput->BytesAvailable;
    ASSERT(byteCount != 0);

#ifdef DEBUG_CHECK
    if(processPinInput->Pin->ConnectionFormat->SampleSize != 0) {
        ASSERT((byteCount % processPinInput->Pin->ConnectionFormat->SampleSize) == 0);
    }
#endif

    for(i = 0; i < ProcessPinsIndex[ID_DATA_OUTPUT_PIN].Count; i++) {

        processPinOutput = ProcessPinsIndex[ID_DATA_OUTPUT_PIN].Pins[i];
        ASSERT(processPinOutput != NULL);

        if(processPinOutput->BytesAvailable == 0) {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("%08x->BytesAvailable == 0 State %d",
                    processPinOutput, processPinOutput->Pin->ClientState) );
        }
        else {
            if(processPinOutput->Pin->ClientState == KSSTATE_RUN) {
                Status = STATUS_SUCCESS;
                if(byteCount > processPinOutput->BytesAvailable) {
                    byteCount = processPinOutput->BytesAvailable;
                }
            }
        }

    }

    ASSERT( byteCount );

    // We always use all of the input data available even when no pins are ready
    // to receive any data.  We do this so that splitter does not increase the
    // latency of capture.  This means we will drop data on the floor if the
    // input pin is receiving data and no output pins are ready for it.
    processPinInput->BytesUsed = byteCount;
    _DbgPrintF(DEBUGLVL_BLAB, ("processPinInput->BytesUsed %08x", byteCount) );



    // Now we update the information we track to enable proper position
    // reporting.

    for (i = 0; i < ProcessPinsIndex[ID_DATA_OUTPUT_PIN].Count; i++) {

        processPinOutput = ProcessPinsIndex[ID_DATA_OUTPUT_PIN].Pins[i];
        ASSERT(processPinOutput != NULL);
        ASSERT(processPinInput != NULL);

        // We track 2 additional pieces of information about position for
        // each output pin.  1 is the amount of data we have processed through
        // the input pin when we first come through this code for each output
        // pin.  That gives us a starting position for when this output pin's
        // stream of data started.  The other is a running sum of the amount
        // of data since startup time, that we have dropped on the floor for
        // this pin.  We use this information to get proper position information
        // reported on every output pin.

        // We store the initial starting position in the WriteOffset of the second
        // KSPOSITION in our context, and we store the running sum of how much data
        // we have dropped on the floor in the PlayOffset of the second KSPOSITION.

        ASSERT (processPinOutput->Pin->Context);
        pAudioPosition = (PKSAUDIO_POSITION)processPinOutput->Pin->Context;

        // KS currently has the unfortunate characteristic, that pins can show up
        // in our list BEFORE their creation has completed.  This will be fixed at
        // some point in the future, but for now that is the way it is.  Furthermore,
        // objects in KS currently inherit their parent objects context, so we
        // end up seeing a pin in our list that has a context which is NOT the
        // context that we allocate for the pin when it is created, but is actually
        // our Filter->Context.   However, the Filter->Context is paged, and we
        // can run at DISPATCH_LEVEL - so this can cause a page fault while at
        // DISPATCH_LEVEL - which is very bad.

        // We work around this problem, by checking if the context that our pin
        // has matches our Filter context.  If so, we simply skip this pin and
        // move on to the next one.

        if (pAudioPosition == Filter->Context) {
            continue;
        }

        if (pAudioPosition[1].WriteOffset==-1I64) {
            pAudioPosition[1].WriteOffset=((PKSAUDIO_POSITION)processPinInput->Pin->Context)->WriteOffset;
        }

        if (processPinOutput->Pin->ClientState != KSSTATE_RUN ||
            processPinOutput->BytesAvailable == 0) {

            // This pin cannot accept any data either because it is not in the run
            // state, or because it has no buffers available to hold the data.
            // In this case we keep a running sum of all of the data that we have
            // dropped on the floor for this pin.  This is required so that we
            // can properly report the position.  If we don't do this, and he ever
            // does not have space for us to copy data, then we will eventually end
            // up always pegging his position at the end of all of the buffers he
            // has sent us.
            pAudioPosition[1].PlayOffset+=byteCount;
        }

    }




    if(Status == STATUS_PENDING) {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("STATUS_PENDING") );
        goto exit;
    }

#ifdef DEBUG_CHECK
    if(processPinInput->Pin->ConnectionFormat->SampleSize != 0) {
        ASSERT((byteCount % processPinInput->Pin->ConnectionFormat->SampleSize) == 0);
    }
#endif


    for (i = 0; i < ProcessPinsIndex[ID_DATA_OUTPUT_PIN].Count; i++) {
        processPinOutput = ProcessPinsIndex[ID_DATA_OUTPUT_PIN].Pins[i];
        ASSERT(processPinOutput != NULL);
        ASSERT(processPinInput != NULL);

        if (processPinOutput->Pin->ClientState == KSSTATE_RUN &&
            processPinOutput->BytesAvailable != 0) {

            ASSERT(processPinOutput->BytesAvailable != 0);
            ASSERT(processPinInput->BytesAvailable != 0);
            ASSERT(processPinOutput->Data != NULL);
            ASSERT(processPinInput->Data != NULL);
            ASSERT(processPinOutput->BytesAvailable >= byteCount);
            ASSERT(processPinInput->BytesAvailable >= byteCount);
            ASSERT(Status == STATUS_SUCCESS);

            RtlCopyMemory (
                processPinOutput->Data,
                processPinInput->Data,
                byteCount
                );

            processPinOutput->BytesUsed = byteCount;

            // 
            // PinContext is a pointer to PKSAUDIO_POSITION which keeps a
            // running total of the number of bytes copied for a particular
            // pin.  This is used by GetPosition().
            // 

            ASSERT (processPinOutput->Pin->Context);
            pAudioPosition = (PKSAUDIO_POSITION)processPinOutput->Pin->Context;
            pAudioPosition->WriteOffset += byteCount;

#ifdef PRINT_POS
            if(pAudioPosition->WriteOffset != 0) {
                DbgPrint("'splitter: FilterProcess wo %08x%08x\n", pAudioPosition->WriteOffset);
            }
#endif

        }

    }


exit:
    // Update the count of the bytes we have processed through our input pin.
    ((PKSAUDIO_POSITION)processPinInput->Pin->Context)->WriteOffset+=byteCount;

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\splitter\pins.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    pins.c

Abstract:

    This module handles the communication transform filters
    (e.g. source to source connections).

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PinCreate)
#pragma alloc_text(PAGE, PinClose)
#pragma alloc_text(PAGE, PinReset)
#pragma alloc_text(PAGE, PinState)
#pragma alloc_text(PAGE, PropertyAudioPosition)
#endif // ALLOC_PRAGMA

//===========================================================================
//===========================================================================


NTSTATUS
PinCreate(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Validates pin format on creation.

Arguments:

    Pin -
        Contains a pointer to the  pin structure.

    Irp -
        Contains a pointer to the create IRP.

Return:

    STATUS_SUCCESS or an appropriate error code

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN distribute = FALSE;
    PIKSCONTROL control = NULL;
    PKSFILTER filter;
    PKSPIN otherPin;
    ULONG BufferSize;

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);

    //
    // Find another pin instance if there is one.
    //
    filter = KsPinGetParentFilter(Pin);
    otherPin = KsFilterGetFirstChildPin(filter,Pin->Id ^ 1);
    if (! otherPin) {
        otherPin = KsFilterGetFirstChildPin(filter,Pin->Id);
        if (otherPin == Pin) {
            otherPin = KsPinGetNextSiblingPin(otherPin);
        }
    }

    //
    // Verify the formats are the same if there is another pin.
    //
    if (otherPin) {
        if ((Pin->ConnectionFormat->FormatSize != 
             otherPin->ConnectionFormat->FormatSize) ||
            (Pin->ConnectionFormat->FormatSize != 
             RtlCompareMemory(
                Pin->ConnectionFormat,
                otherPin->ConnectionFormat,
                Pin->ConnectionFormat->FormatSize))) {
        #if (DBG)
            _DbgPrintF(DEBUGLVL_VERBOSE,
                  ("format does not match existing pin's format") );
                DumpDataFormat(DEBUGLVL_VERBOSE, Pin->ConnectionFormat);
                DumpDataFormat(DEBUGLVL_VERBOSE, otherPin->ConnectionFormat);
        #endif
            return STATUS_INVALID_PARAMETER;
        }
    }

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Pin %d connected at:", Pin->Id) );
    DumpDataFormat(DEBUGLVL_VERBOSE, Pin->ConnectionFormat);
#endif

    // Do not query if context already exists.
    //
    if (!filter->Context) {
        // This will succeed if pin is a source pin or the connected pin is an
        // AVStream filter.
        // 
        status =
            KsPinGetConnectedPinInterface(
                Pin,
                &IID_IKsControl,
                (PVOID *) &control);

        if (NT_SUCCESS(status)) {

            //
            // Source pin.  Try the extended allocator framing property first.
            //
            KSALLOCATOR_FRAMING_EX framingex;
            KSPROPERTY property;
            ULONG bufferSize=0;

            property.Set = KSPROPSETID_Connection;
            property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX;
            property.Flags = KSPROPERTY_TYPE_GET;
        
            status = 
                control->lpVtbl->KsProperty(
                    control,
                    &property,
                    sizeof(property),
                    &framingex,
                    sizeof(framingex),
                    &bufferSize);

            if (NT_SUCCESS(status) || status == STATUS_BUFFER_OVERFLOW) {
                //
                // It worked!  Now we need to get the actual value into a buffer.
                //
                filter->Context = 
                    ExAllocatePoolWithTag(
                    PagedPool,
                    bufferSize,
                    POOLTAG_ALLOCATORFRAMING);

                if (filter->Context) {
                    PKSALLOCATOR_FRAMING_EX framingEx = 
                        (PKSALLOCATOR_FRAMING_EX) filter->Context;

                    status = 
                        control->lpVtbl->KsProperty(
                            control,
                            &property,
                            sizeof(property),
                            filter->Context,
                            bufferSize,
                            &bufferSize);

                    //
                    // Sanity check.
                    //
                    if (NT_SUCCESS(status) && 
                        (bufferSize != 
                            ((framingEx->CountItems) * sizeof(KS_FRAMING_ITEM)) + 
                            sizeof(KSALLOCATOR_FRAMING_EX) - 
                            sizeof(KS_FRAMING_ITEM))) {
                        _DbgPrintF( 
                            DEBUGLVL_TERSE, 
                            ("connected pin's allocator framing property size disagrees with item count"));
                        status = STATUS_UNSUCCESSFUL;
                    }

                    if (NT_SUCCESS(status)) {
                        //
                        // Mark all the items 'in-place'.
                        //
                        ULONG item;
                        for (item = 0; item < framingEx->CountItems; item++) {
                            framingEx->FramingItem[item].Flags |= 
                                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                                KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
                                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
                            _DbgPrintF( 
                              DEBUGLVL_VERBOSE, 
                              ("%d Frms: %d min %08x max %08x SR %d CH %d BPS %d",
                                item,
                                framingEx->FramingItem[item].Frames,
                                framingEx->FramingItem[item].FramingRange.
                                  Range.MinFrameSize,
                                framingEx->FramingItem[item].FramingRange.
                                  Range.MaxFrameSize,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)
                                  ->WaveFormatEx.nSamplesPerSec,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)
                                  ->WaveFormatEx.nChannels,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)
                                  ->WaveFormatEx.wBitsPerSample));
                        }
                    } 
                    else {
                        ExFreePool(filter->Context);
                        filter->Context = NULL;
                    }
                } 
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } 
            else {
                //
                // No extended framing.  Try regular framing next.
                //
                KSALLOCATOR_FRAMING framing;
                property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;

                status = 
                    control->lpVtbl->KsProperty(
                        control,
                        &property,
                        sizeof(property),
                        &framing,
                        sizeof(framing),
                        &bufferSize);

                if (NT_SUCCESS(status)) {
                    //
                    // It worked!  Now we make a copy of the default framing and
                    // modify it.
                    //
                    filter->Context = 
                        ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(AllocatorFraming),
                            POOLTAG_ALLOCATORFRAMING);
    
                    if (filter->Context) {
                        PKSALLOCATOR_FRAMING_EX framingEx = 
                            (PKSALLOCATOR_FRAMING_EX) filter->Context;

                        //
                        // Use the old-style framing acquired from the connected
                        // pin to modify the framing from the descriptor.
                        //
                        RtlCopyMemory(
                            framingEx,
                            &AllocatorFraming,
                            sizeof(AllocatorFraming));

                        framingEx->FramingItem[0].MemoryType = 
                            (framing.PoolType == NonPagedPool) ? 
                                KSMEMORY_TYPE_KERNEL_NONPAGED : 
                                KSMEMORY_TYPE_KERNEL_PAGED;
                        framingEx->FramingItem[0].Flags = 
                            framing.RequirementsFlags | 
                            KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                            KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
                            KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
                        framingEx->FramingItem[0].Frames = framing.Frames;
                        framingEx->FramingItem[0].FileAlignment = 
                            framing.FileAlignment;
                        framingEx->FramingItem[0].FramingRange.Range.MaxFrameSize =
                        framingEx->FramingItem[0].FramingRange.Range.MinFrameSize =
                            framing.FrameSize;
                        if (framing.RequirementsFlags & 
                            KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) {
                            framingEx->FramingItem[0].FramingRange.
                              InPlaceWeight = 0;
                            framingEx->FramingItem[0].FramingRange.
                              NotInPlaceWeight = 0;
                        } 
                        else {
                            framingEx->FramingItem[0].FramingRange.
                              InPlaceWeight = (ULONG) -1;
                            framingEx->FramingItem[0].FramingRange.
                              NotInPlaceWeight = (ULONG) -1;
                        }

                        _DbgPrintF(
                              DEBUGLVL_VERBOSE, 
                              ("Frms: %d min %08x max %08x SR %d CH %d BPS %d\n", 
                                framingEx->FramingItem[0].Frames,
                                framingEx->FramingItem[0].FramingRange.
                                  Range.MinFrameSize,
                                framingEx->FramingItem[0].FramingRange.
                                  Range.MaxFrameSize,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                  WaveFormatEx.nSamplesPerSec,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                  WaveFormatEx.nChannels,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                  WaveFormatEx.wBitsPerSample));
                    } 
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } 
                else {
                    //
                    // No framing at all.  Use registry specified or default buffer
                    // duration, to calculate framing.
                    //
                    filter->Context = 
                        ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(AllocatorFraming),
                            POOLTAG_ALLOCATORFRAMING);
    
                    if (filter->Context) {
                        PKSALLOCATOR_FRAMING_EX framingEx = 
                            (PKSALLOCATOR_FRAMING_EX) filter->Context;

                        //
                        // Use the old-style framing acquired from the connected
                        // pin to modify the framing from the descriptor.
                        //
                        RtlCopyMemory(
                            framingEx,
                            &AllocatorFraming,
                            sizeof(AllocatorFraming));

                        // For now we truncate BufferSize down.  This matches how kmixer, usbaudio
                        // and portcls currently calculate their capture buffer sizes.

                        BufferSize = ((ULONG)(((((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                WaveFormatEx.nSamplesPerSec * (ULONGLONG)gBufferDuration ) + 0 ) / 1000000)) *
                            ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                WaveFormatEx.nChannels *
                            (((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                WaveFormatEx.wBitsPerSample / 8);

                        // Make sure we have space for at least 1 sample.

                        if (!BufferSize) {
                            BufferSize = ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->WaveFormatEx.nChannels *
                            (((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->WaveFormatEx.wBitsPerSample / 8);
                        }

                        framingEx->FramingItem[0].FramingRange.Range.MaxFrameSize =
                        framingEx->FramingItem[0].FramingRange.Range.MinFrameSize = BufferSize;

                        _DbgPrintF(
                              DEBUGLVL_VERBOSE, 
                              ("Frms: %d min %08x max %08x SR %d CH %d BPS %d\n", 
                                framingEx->FramingItem[0].Frames,
                                framingEx->FramingItem[0].FramingRange.
                                  Range.MinFrameSize,
                                framingEx->FramingItem[0].FramingRange.
                                  Range.MaxFrameSize,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                  WaveFormatEx.nSamplesPerSec,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                  WaveFormatEx.nChannels,
                                ((PKSDATAFORMAT_WAVEFORMATEX)Pin->ConnectionFormat)->
                                  WaveFormatEx.wBitsPerSample));

                        status = STATUS_SUCCESS;
                    } 
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }

            //
            // If we got a good framing structure, tell all the existing pins.
            //
            if (filter->Context) {
                distribute = TRUE;
            }
        } 
        else {
            //
            // This is a sink.
            //
            status = STATUS_SUCCESS;
        }
    }
    // We already have filter->Context.
    //
    else {
        status = STATUS_SUCCESS;        
    }

    //
    // Distribute allocator and header size information to all the pins.
    //
    if (NT_SUCCESS(status) && distribute) {
        ULONG pinId;
        for(pinId = 0; 
            NT_SUCCESS(status) && 
                (pinId < filter->Descriptor->PinDescriptorsCount); 
            pinId++) {
            otherPin = KsFilterGetFirstChildPin(filter,pinId);
            while (otherPin && NT_SUCCESS(status)) {
                status = KsEdit(otherPin,&otherPin->Descriptor,'ETSM');
                if (NT_SUCCESS(status)) {
                    ((PKSPIN_DESCRIPTOR_EX)(otherPin->Descriptor))->
                        AllocatorFraming = 
                            filter->Context;
                }
                otherPin = KsPinGetNextSiblingPin(otherPin);
            }
        }
    }

    //
    // Release the control interface if there is one.
    //
    if (control) {
        control->lpVtbl->Release(control);
    }

    // 
    // Pin->Context now holds KSAUDIO_POSITION
    //
    if (NT_SUCCESS(status)) {
        Pin->Context = ExAllocatePoolWithTag(
          NonPagedPool,
          2*sizeof (KSAUDIO_POSITION),
          POOLTAG_AUDIOPOSITION);

        if (Pin->Context == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {
            RtlZeroMemory (Pin->Context, 2*sizeof (KSAUDIO_POSITION));
            // Mark the initial stream offset as not initialized.
            ((PKSAUDIO_POSITION)Pin->Context)[1].WriteOffset=-1I64;
        }
    }

    return status;
}


NTSTATUS
PinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:
    Called when a pin closes.

Arguments:
    Pin -
        Contains a pointer to the  pin structure.

    Irp -
        Contains a pointer to the create IRP.

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    PKSFILTER filter;

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);

    //
    // PinContext points to a KSAUDIO_POSITION, which is is used to store
    // the number of bytes read from the Pin for GetPosition.
    //
    if (Pin->Context) {
        ExFreePool(Pin->Context);
        Pin->Context = NULL;
    }

    //
    // If the filter has the allocator framing and this is the last pin, free
    // the structure.
    //
    filter = KsPinGetParentFilter(Pin);
    if (filter->Context) {
        ULONG pinId;
        ULONG pinCount = 0;
        for(pinId = 0; 
            pinId < filter->Descriptor->PinDescriptorsCount; 
            pinId++) {
            pinCount += KsFilterGetChildPinCount(filter,pinId);
        }

        //
        // Free the allocator framing attached to the filter if this is the last
        // pin.
        //
        if (pinCount == 1) {
            ExFreePool(filter->Context);
            filter->Context = NULL;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PinState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )

/*++

Routine Description:
    Called when a pin changes state. Zero the count of bytes transferred on KSSTATE_STOP.

Arguments:
    Pin -
        Contains a pointer to the  pin structure.

    ToState -
        Contains the next state

    FromState -
        Contains the current state

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Pin->Context);


    //
    // PinContext points to a KSAUDIO_POSITION, which is is used to store
    // the number of bytes read from the Pin for GetPosition.
    //
    if (KSSTATE_STOP == ToState) {
        RtlZeroMemory (Pin->Context, 2*sizeof (KSAUDIO_POSITION));
        // Mark the initial stream offset as not initialized.
        ((PKSAUDIO_POSITION)Pin->Context)[1].WriteOffset=-1I64;
    }
    _DbgPrintF(DEBUGLVL_VERBOSE, ("PinState: KsFilterAttemptProcessing") );
    KsFilterAttemptProcessing(KsPinGetParentFilter(Pin), TRUE);

    return STATUS_SUCCESS;
}


void
PinReset(
    IN PKSPIN Pin
    )

/*++

Routine Description:
    Called when a pin is reset.  Zero the count of bytes transferred.

Arguments:
    Pin -
        Contains a pointer to the  pin structure.

Return:
    VOID

--*/

{
    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Pin->Context);

    //
    // PinContext points to a KSAUDIO_POSITION, which is is used to store
    // the number of bytes read from the Pin for GetPosition.
    //
    RtlZeroMemory (Pin->Context, 2*sizeof (KSAUDIO_POSITION));
    // Mark the initial stream offset as not initialized.
    ((PKSAUDIO_POSITION)Pin->Context)[1].WriteOffset=-1I64;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("PinReset: KsFilterAttemptProcessing") );
    KsFilterAttemptProcessing(KsPinGetParentFilter(Pin), TRUE);

    return;
}

NTSTATUS
PropertyAudioPosition(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
)
/*++

Routine Description:

    Gets/Sets the audio position of the audio stream
    (Relies on the next filter's audio position)

    pIrp -
        Irp which asked us to do the get/set

    pProperty -
        Ks Property structure

    pData -
        Pointer to buffer where position value needs to be filled OR
        Pointer to buffer which has the new positions

--*/

{

    PKSAUDIO_POSITION pAudioPosition;
    PFILE_OBJECT pFileObject;
    LONG OutputBufferBytes;
    ULONG BytesReturned;
    PKSFILTER pFilter;
    NTSTATUS Status;
    PKSPIN pOtherPin;
    PKSPIN pPin;

    PAGED_CODE();


    pPin = KsGetPinFromIrp(pIrp);
    if (NULL == pPin)
    {
        ASSERT(pPin && "Irp has no pin");
        return STATUS_INVALID_PARAMETER;
    }


    if(pPin->Id != ID_DATA_OUTPUT_PIN) {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }


    pFilter = KsPinGetParentFilter(pPin);

    KsFilterAcquireControl(pFilter);
    pOtherPin = KsFilterGetFirstChildPin(pFilter, (pPin->Id ^ 1));
    if(pOtherPin == NULL) {
        KsFilterReleaseControl(pFilter);
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    pFileObject = KsPinGetConnectedPinFileObject(pOtherPin);

    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pProperty,
      sizeof (KSPROPERTY),
      pPosition,
      sizeof (KSAUDIO_POSITION),
      &BytesReturned);


    pIrp->IoStatus.Information = sizeof(KSAUDIO_POSITION);


    //
    // Limit the WriteOffset to the number of bytes actually copied into
    // the client's buffer.  Which is kept in pPin->Context which points
    // to a KSAUDIO_POSITION.
    //

    ASSERT (pPin->Context);

    pAudioPosition = (PKSAUDIO_POSITION)pPin->Context;

    //
    // For capture streams, the Write and Play offsets are the same.
    //

    KsFilterAcquireProcessingMutex(pFilter);


#ifdef PRINT_POS
    if(pAudioPosition->WriteOffset != 0) {
        DbgPrint("'splitter: hwo %08x%08x hpo %08x%08x\n", 
          pPosition->WriteOffset,
          pPosition->PlayOffset);
    }
#endif


    pPosition->WriteOffset = pAudioPosition->WriteOffset;


    // Subtract out of the play position, both the input pin byte count when
    // this pins stream was first processed, and the total number of bytes that splitter
    // has dropped on the floor for this pin because there was no output buffering
    // available.  Ideally the second number will always be zero.
    // Ideally for the first output pin, the initial count will be zero, however
    // output pins created after the first output pin later will likely have a non zero count.

    if (pAudioPosition[1].WriteOffset!=-1I64) {
        pPosition->PlayOffset-=pAudioPosition[1].WriteOffset; // WriteOffset has starting position.
    }
    pPosition->PlayOffset-=pAudioPosition[1].PlayOffset; // PlayOffset has the total starvation count.

    // BUGBUG At least the AWE64 is broken.  Its position is off by 1 sample.
    //ASSERT(pPosition->PlayOffset >= pPosition->WriteOffset);
#if (DBG)
    if (pPosition->PlayOffset < pPosition->WriteOffset) {
        DbgPrint("0x%I64x < 0x%I64x\n", pPosition->PlayOffset, pPosition->WriteOffset);
    }
#endif

    KsPinGetAvailableByteCount(pPin, NULL, &OutputBufferBytes);

    // BUGBUG At least usbaudio is broken.
    //ASSERT(pPosition->PlayOffset <= pAudioPosition->WriteOffset + OutputBufferBytes);
#if (DBG)
    if (pPosition->PlayOffset > pPosition->WriteOffset + OutputBufferBytes) {
        DbgPrint("0x%I64x > 0x%I64x\n", pPosition->PlayOffset, pPosition->WriteOffset + OutputBufferBytes);
    }
#endif

    if(pPosition->PlayOffset > pAudioPosition->WriteOffset + OutputBufferBytes) {


#ifdef PRINT_POS
        DbgPrint("'splitter: OBB %08x wo %08x%08x po %08x%08x\n", 
          OutputBufferBytes,
          pAudioPosition->WriteOffset,
          pPosition->PlayOffset);
#endif


        pPosition->PlayOffset = pAudioPosition->WriteOffset + OutputBufferBytes; 
    }


#ifdef PRINT_POS
    if(pPosition->PlayOffset != 0) {
        DbgPrint("'splitter: wo %08x%08x po %08x%08x\n", 
          pPosition->WriteOffset,
          pPosition->PlayOffset);
    }
#endif


    KsFilterReleaseProcessingMutex(pFilter);
    KsFilterReleaseControl(pFilter);

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <wdm.h>
#include <windef.h>
#include <winerror.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>
#include <string.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <swenum.h>
#include <midi.h>

#include <ksdebug.h>

#ifdef __cplusplus
}
#endif

#include "synth.h"
#include "swmidi.h"
#include "muldiv32.h"

#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\control.cpp ===
//      ControlLogic.cpp
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"

#include "fltsafe.h"

void ControlLogic::SetSampleRate(DWORD dwSampleRate)
{
    if (dwSampleRate > 40000)
    {
        dwSampleRate = 44100;
        m_dwConvert = 10;
    }
    else if (dwSampleRate > 20000)
    {
        dwSampleRate = 22050;
        m_dwConvert = 20;
    }
    else
    {
        dwSampleRate = 11025;
        m_dwConvert = 40;
    }

    AllNotesOff();
    m_stLastMixTime = (m_stLastMixTime * dwSampleRate) / m_dwSampleRate;
#if BUILDSTATS
    m_stLastStats = 0;
#endif  //  BUILDSTATS
    m_dwSampleRate = dwSampleRate;
    m_stMinSpan = dwSampleRate / 100;   // 10 ms.
    m_stMaxSpan = (dwSampleRate + 19) / 20;    // 50 ms.
    m_Instruments.SetSampleRate(dwSampleRate);
    m_stOptimalOffset = (kOptimalMSecOffset * m_dwSampleRate) / 1000;
    m_lCalibrate = (kPLLForce * kStartMSecOffset * m_dwSampleRate) / 1000;
    m_stBrickWall = (kMsBrickWall * m_dwSampleRate) / 1000;
}

STIME ControlLogic::MilsToSamples(MTIME mtTime)
{
    STIME stTime;

    stTime = mtTime - m_mtStartTime;
    stTime *= 441;
    stTime /= m_dwConvert;
    stTime += m_stTimeOffset;

    return stTime;
}

MTIME ControlLogic::SamplesToMils(STIME stTime)
{
    stTime -= m_stTimeOffset;
    stTime = (stTime * m_dwConvert) / 441;
    stTime += m_mtStartTime;
    return MTIME(stTime);
}

STIME ControlLogic::SamplesPerMs(void)
{
    return (MulDiv(1,441,m_dwConvert));
}

STIME ControlLogic::Unit100NsToSamples(LONGLONG unit100Ns)
{
    unit100Ns *= 441;
    unit100Ns /= m_dwConvert;           //  we now have #100ns * (samp/ms)
    return STIME(unit100Ns / 10000);    //  div by (100ns/ms), get samples
}

ControlLogic::ControlLogic()
{
    DWORD nIndex;
    Voice *pVoice;

    _DbgPrintF(DEBUGLVL_MUTEX, ("\t ControlLogic::ControlLogic waiting for Mutex"));
    KeWaitForSingleObject(&gMutex,Executive,KernelMode,FALSE,NULL);

    GMReset();

    for (nIndex = 0;nIndex < 16;nIndex++)
    {
        m_fSustain[nIndex] = FALSE;
    }
    for (nIndex = 0;nIndex < MAX_NUM_VOICES;nIndex++)
    {
        pVoice = new Voice;
        if (pVoice != NULL)
        {
            m_VoicesFree.AddHead(pVoice);
        }
    }
    for (nIndex = 0;nIndex < NUM_EXTRA_VOICES;nIndex++)
    {
        pVoice = new Voice;
        if (pVoice != NULL)
        {
            m_VoicesExtra.AddHead(pVoice);
        }
    }
#if BUILDSTATS
    m_stLastStats = 0;
    ResetPerformanceStats();
#endif  //  BUILDSTATS
    m_nMaxVoices = MAX_NUM_VOICES;
    m_nExtraVoices = NUM_EXTRA_VOICES;
    m_stLastMixTime = 0;
    m_stLastCalTime = 0;
    m_stTimeOffset = 0;
    m_mtStartTime = 0;
    m_fAllowPanWhilePlayingNote = TRUE;
    m_fAllowVolumeChangeWhilePlayingNote = TRUE;
    m_dwSampleRate = SAMPLE_RATE_22;

    SetSampleRate(SAMPLE_RATE_22);
    m_dwStereo = 1;
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("Calling SetGMLoad(TRUE) from ControlLogic()."));
    m_Instruments.SetGMLoad(TRUE);

    KeReleaseMutex(&gMutex, FALSE);
    _DbgPrintF(DEBUGLVL_MUTEX, ("\t ControlLogic::ControlLogic released Mutex"));
}

ControlLogic::~ControlLogic()
{
    Voice *pVoice;

    _DbgPrintF(DEBUGLVL_MUTEX, ("ControlLogic::~ControlLogic waiting for Mutex"));
    KeWaitForSingleObject(&gMutex,Executive,KernelMode,FALSE,NULL);

    while (pVoice = m_VoicesInUse.RemoveHead())
    {
        delete pVoice;
    }
    while (pVoice = m_VoicesFree.RemoveHead())
    {
        delete pVoice;
    }
    while (pVoice = m_VoicesExtra.RemoveHead())
    {
        delete pVoice;
    }

    KeReleaseMutex(&gMutex, FALSE);
    _DbgPrintF(DEBUGLVL_MUTEX, ("\t ControlLogic::~ControlLogic released Mutex"));
}

void ControlLogic::GMReset()
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Resetting GM"));
    
    static BYTE nPartToChannel[16] = {
        9,0,1,2,3,4,5,6,7,8,10,11,12,13,14,15
    };
    int nX;
    for (nX = 0; nX < 16; nX++)
    {
        int nY;
        m_nData[nX] = 0;
        m_prFineTune[nX] = 0;
        m_bDrums[nX] = 0;
        for (nY = 0; nY < 12; nY++)
        {
            m_prScaleTune[nX][nY] = 0;
        }
        m_prCoarseTune[nX] = 0;
        m_bPartToChannel[nX] = nPartToChannel[nX];
        m_fMono[nX] = FALSE;
    }
    m_bDrums[0] = 1;
    m_vrMasterVolume = 0;
    m_fGSActive = FALSE;
}

void ControlLogic::AdjustTiming(MTIME mtDeltaTime, STIME stDeltaSamples)
{
    m_mtStartTime += mtDeltaTime;
    m_stTimeOffset += stDeltaSamples;
}

#if BUILDSTATS

void ControlLogic::ResetPerformanceStats()
{
    m_BuildStats.dwNotesLost = 0;
    m_BuildStats.dwTotalTime = 0;
    m_BuildStats.dwVoices10 = 0;
    m_BuildStats.dwTotalSamples = 0;
    m_BuildStats.dwCPU100k = 0;
    m_BuildStats.dwMaxAmplitude = 0;
    m_CopyStats = m_BuildStats;
}

#endif  //  BUILDSTATS

void ControlLogic::SetStartTime(MTIME mtTime, STIME stOffset)
{
    int nIndex;
    Voice *pVoice;

    m_mtStartTime = mtTime;
    m_stLastMixTime = 0;
#if BUILDSTATS
    m_stLastStats = 0;
#endif  //  BUILDSTATS
    m_stTimeOffset = stOffset;

    // Make sure all the voices are marked as usable
    while (pVoice = m_VoicesInUse.GetHead())
    {
        m_VoicesInUse.Remove(pVoice);
        pVoice->ResetVoice();
        m_VoicesFree.AddHead(pVoice);
    }

    m_Notes.ClearMIDI(MAX_STIME);

    for (nIndex = 0; nIndex < 16; nIndex++) {
    // reset all controllers
        m_ModWheel[nIndex].ClearMIDI(MAX_STIME);
        m_Volume[nIndex].ClearMIDI(MAX_STIME);
        m_Pan[nIndex].ClearMIDI(MAX_STIME);
        m_Expression[nIndex].ClearMIDI(MAX_STIME);
        m_PitchBend[nIndex].ClearMIDI(MAX_STIME);
        m_Program[nIndex].ClearMIDI(MAX_STIME);
    }

    // could probably be done more directly
    for (nIndex = 0; nIndex < 16; nIndex++) {
    // reset all controllers
        m_ModWheel[nIndex].RecordMIDI(0, 0);
        m_Volume[nIndex].RecordMIDI(0, 100);
        m_Pan[nIndex].RecordMIDI(0, 64);
        m_Expression[nIndex].RecordMIDI(0, 127);
        m_PitchBend[nIndex].RecordMIDI(0, 0x2000);

        Note note;
        note.m_bPart = (BYTE) nIndex;
        note.m_bKey = NOTE_SUSTAIN;
        note.m_bVelocity = 0; // sustain off
        m_Notes.RecordNote(0,&note);
    }
}

/*  StealNotes checks if the VoicesExtra queue was used. If so,
    it needs to replenish it by moving voices over from the
    free queue and setting older notes to finish now.
    When it steals notes, it takes from the top of the inuse
    list. The list is sorted by part (channel) priority, with high
    priority parts at the bottom.
*/

void ControlLogic::StealNotes(STIME stTime)
{
    Voice *pVoice;
    long lToMove = m_nExtraVoices - (long) m_VoicesExtra.GetCount();
    if (lToMove > 0)
    {
        for (;lToMove > 0;)
        {
            pVoice = m_VoicesFree.RemoveHead();
            if (pVoice != NULL)
            {
                m_VoicesExtra.AddHead(pVoice);
                lToMove--;
            }
            else break;
        }
        for (;lToMove > 0;lToMove--)
        {
            pVoice = OldestVoice();
            if (pVoice != NULL)
            {
                pVoice->QuickStopVoice(stTime);
#if BUILDSTATS
                m_BuildStats.dwNotesLost++;
#endif  //  BUILDSTATS
            }
            else break;
        }
    }
}

HRESULT ControlLogic::AllNotesOff()

{
    Voice *pVoice;

    while (pVoice = m_VoicesInUse.RemoveHead())
    {
        pVoice->ClearVoice();
        pVoice->ResetVoice();
        m_VoicesFree.AddHead(pVoice);
#if BUILDSTATS
        if (pVoice->m_stStartTime < m_stLastStats)
        {
            m_BuildStats.dwTotalSamples += (ULONG) (pVoice->m_stStopTime - m_stLastStats);
        }
        else
        {
            m_BuildStats.dwTotalSamples += (ULONG) (pVoice->m_stStopTime - pVoice->m_stStartTime);
        }
#endif  //  BUILDSTATS
    }
    return (S_OK);
}

Voice *ControlLogic::OldestVoice()

{
    Voice *pVoice;
    Voice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    pBest = pVoice;
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (!pVoice->m_fTag)
        {
            if (pBest->m_fTag)
            {
                pBest = pVoice;
            }
            else
            {
                if (pVoice->m_fNoteOn)
                {
                    if (pBest->m_fNoteOn)
                    {
                        if (pBest->m_stStartTime > pVoice->m_stStartTime)
                        {
                            pBest = pVoice;
                        }
                    }
                }
                else
                {
                    if (pBest->m_fNoteOn ||
                        (pBest->m_vrVolume > pVoice->m_vrVolume))
                    {
                        pBest = pVoice;
                    }
                }
            }
        }
    }
    if (pBest != NULL)
    {
        if (pBest->m_fTag)
        {
            pBest = NULL;
        }
    }
    return pBest;
}

Voice *ControlLogic::StealVoice()

{
    Voice *pVoice;
    Voice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    pBest = pVoice;
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_fNoteOn == FALSE)
        {
            if ((pBest->m_fNoteOn == TRUE) ||
                (pBest->m_vrVolume > pVoice->m_vrVolume))
            {
                pBest = pVoice;
            }
        }
        else
        {
            if (pBest->m_stStartTime > pVoice->m_stStartTime)
            {
                pBest = pVoice;
            }
        }
    }
    if (pBest != NULL)
    {
        pBest->ClearVoice();
        pBest->ResetVoice();
        m_VoicesInUse.Remove(pBest);
        pBest->Reset();
    }
    return pBest;
}

void ControlLogic::QueueNotes(STIME stEndTime)
{
    Note note;

    StealNotes(stEndTime);
    while (m_Notes.GetNote(stEndTime,&note))
    {
        if (note.m_bKey == NOTE_SUSTAIN) // special sustain marker
        {
            m_fSustain[note.m_bPart] = (BOOL) note.m_bVelocity;
            if (note.m_bVelocity == FALSE)
            {
                Voice * pVoice = m_VoicesInUse.GetHead();
                for (;pVoice != NULL;pVoice = pVoice->GetNext())
                {
                    if (pVoice->m_fSustainOn &&
                        pVoice->m_nPart == note.m_bPart)
                    {
                        DPF3(3,"Note Off:%7d ch = %01x  k = %02x  (sustain now off)",
                             note.m_stTime, note.m_bPart, pVoice->m_nKey);
                        pVoice->StopVoice(note.m_stTime);
                    }
                }
            }
            else
            {
                DPF2(3, "Sustain on %7d: (%d)", note.m_stTime, note.m_bPart);
            }
        }
        else if (note.m_bKey == NOTE_ALLOFF) // special all notes off marker
        {
            Voice *pVoice = m_VoicesInUse.GetHead();
            for (;pVoice != NULL; pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                    (pVoice->m_nPart == note.m_bPart))
                {
                    if (m_fSustain[pVoice->m_nPart])
                    {
                        pVoice->m_fSustainOn = TRUE;
                    }
                    else
                    {
                        pVoice->StopVoice(note.m_stTime);
                    }
                }
            }
        }
        else if (note.m_bKey == NOTE_SOUNDSOFF) // special all sounds off marker
        {
            Voice *pVoice = m_VoicesInUse.GetHead();
            for (;pVoice != NULL; pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fNoteOn &&
                    (pVoice->m_nPart == note.m_bPart))
                {
                    pVoice->StopVoice(note.m_stTime);
                }
            }
        }
        else if (note.m_bKey == NOTE_ASSIGNRECEIVE)
        {
            m_bPartToChannel[note.m_bPart] = note.m_bVelocity;
        }
        else if (note.m_bKey == NOTE_MASTERVOLUME)
        {
            m_vrMasterVolume = MIDIRecorder::VelocityToVolume(note.m_bVelocity);
        }
        else if (note.m_bVelocity == 0)  // Note Off.
        {
            Voice * pVoice = m_VoicesInUse.GetHead();
            WORD nPart = note.m_bPart;
            for (;pVoice != NULL;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                    (pVoice->m_nKey == (WORD) note.m_bKey) &&
                    (pVoice->m_nPart == nPart))
                {
                    if (m_fSustain[nPart])
                    {
                        pVoice->m_fSustainOn = TRUE;
                    }
                    else
                    {
                        pVoice->StopVoice(note.m_stTime);
                    }
                    break;
                }
            }
            if (pVoice == NULL) {
                DPF3(3,"Note Off:%7d ch = %01x          k = %02x  (couldn't find note!)",
                     note.m_stTime, nPart, note.m_bKey);
            }
        }
        else   // Note On.
        {
            DWORD dwProgram = m_Program[note.m_bPart].GetProgram(note.m_stTime);

            if (m_bDrums[note.m_bPart])
            {
                dwProgram |= AA_FINST_DRUM;
            }
            if (m_fMono[note.m_bPart])
            {
                Voice * pVoice = m_VoicesInUse.GetHead();
                WORD nPart = note.m_bPart;
                for (;pVoice != NULL;pVoice = pVoice->GetNext())
                {
                    if (pVoice->m_fNoteOn && (pVoice->m_nPart == nPart))
                    {
                        pVoice->StopVoice(note.m_stTime);
                    }
                }
            }
            Instrument * pInstrument =
                m_Instruments.GetInstrument(dwProgram,note.m_bKey);
            if (pInstrument == NULL)
            {
                if (dwProgram & AA_FINST_DRUM) 
                {
                    dwProgram = AA_FINST_DRUM;
                }

                pInstrument =
                    m_Instruments.GetInstrument(dwProgram,note.m_bKey);

                // Fallback to GM if not Drum.
                //
                if (NULL == pInstrument && AA_FINST_DRUM != dwProgram)
                {
                    dwProgram &= 0x7F;

                    pInstrument = 
                        m_Instruments.GetInstrument(dwProgram,note.m_bKey);
                }
            }
            
            if (NULL == pInstrument)
            {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("No Instruments found %X %X %X", note.m_bPart, note.m_bKey, dwProgram));
            }

            if (pInstrument != NULL)
            {
                SourceRegion * pRegion =
                    pInstrument->ScanForRegion(note.m_bKey);
                if (pRegion != NULL)
                {
                    WORD nPart = note.m_bPart;
                    Voice * pVoice = m_VoicesInUse.GetHead();
                    if (!pRegion->m_bAllowOverlap)
                    {
                        for (;pVoice != NULL; pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_nPart == nPart) &&
                                (pVoice->m_nKey == note.m_bKey))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }
                    }
                    pVoice = m_VoicesFree.RemoveHead();
                    if (pVoice == NULL)
                    {
                        pVoice = m_VoicesExtra.RemoveHead();
                    }

                    if (pVoice == NULL)
                    {
                        pVoice = StealVoice();
                    }

                    if (pRegion->m_bGroup != 0)
                    {
                        Voice * pXVoice = m_VoicesInUse.GetHead();
                        for (;pXVoice != NULL;pXVoice = pXVoice->GetNext())
                        {
                            if ((pXVoice->m_dwGroup == pRegion->m_bGroup) &&
                                (pXVoice->m_nPart == nPart) &&
                                (pXVoice->m_dwProgram == dwProgram))
                            {
                                pXVoice->QuickStopVoice(note.m_stTime);
                            }
                        }
                    }

                    if (pVoice != NULL)
                    {
                        PREL prPitch = m_prFineTune[nPart] + m_prScaleTune[nPart][note.m_bKey % 12];
                        if (!m_bDrums[nPart])
                        {
                            prPitch += m_prCoarseTune[nPart];
                        }
                        pVoice->m_nKey = note.m_bKey;
                        pVoice->m_nPart = nPart;
                        pVoice->m_dwProgram = dwProgram;
                        if (pVoice->StartVoice(this,
                            pRegion, note.m_stTime,
                            &m_ModWheel[nPart],
                            &m_PitchBend[nPart],
                            &m_Expression[nPart],
                            &m_Volume[nPart],
                            &m_Pan[nPart],
                            (WORD)note.m_bKey,
                            (WORD)note.m_bVelocity,
                            m_vrMasterVolume,
                            prPitch))
                        {
                            pVoice->m_fInUse = TRUE;
                            m_VoicesInUse.AddHead(pVoice);
                        }
                        else
                        {
                            pVoice->ResetVoice();
                            m_VoicesFree.AddHead(pVoice);
                        }
                    }
#if BUILDSTATS
                    else
                    {
                        m_BuildStats.dwNotesLost++;
                    }
                }
                else
                {
                    m_BuildStats.dwNotesLost++;
                }
            }
            else
            {
                m_BuildStats.dwNotesLost++;
            }
#else   //  BUILDSTATS
        }
    }
#endif  //  BUILDSTATS
        }
    }
}

#if BUILDSTATS
void ControlLogic::FinishMix(short *pBuffer,DWORD dwLength)
{
    DWORD dwIndex;
//    short nData;
    short nMax = (short) m_BuildStats.dwMaxAmplitude << 3;
    for (dwIndex = 0; dwIndex < (dwLength << m_dwStereo); dwIndex++)
    {
        if (pBuffer[dwIndex] > nMax)
        {
            nMax = pBuffer[dwIndex];
        }
    }
    m_BuildStats.dwMaxAmplitude = nMax >> 3;
}
#endif  //  BUILDSTATS

void ControlLogic::Flush(STIME stTime)
{
    DWORD dwIndex;

    for (dwIndex = 0;dwIndex < 16; dwIndex++)
    {
        m_ModWheel[dwIndex].FlushMIDI(stTime);
        m_PitchBend[dwIndex].FlushMIDI(stTime);
        m_Volume[dwIndex].FlushMIDI(stTime);
        m_Expression[dwIndex].FlushMIDI(stTime);
        m_Pan[dwIndex].FlushMIDI(stTime);
        m_Program[dwIndex].FlushMIDI(stTime);
    }
    m_Notes.FlushMIDI(stTime);
}


void ControlLogic::FlushChannel(BYTE bChannel, STIME stTime)

{
    BYTE bIndex;

    for (bIndex = 0; bIndex < 16; bIndex++) // To deal with GS part concept.
    {
        if (bChannel == m_bPartToChannel[bIndex])
        {
            m_Notes.FlushPart(stTime, bIndex);
        }
    }
}

#if BUILDSTATS
HRESULT ControlLogic::GetPerformanceStats(PerfStats *pStats)
{
    if (pStats == NULL)
    {
        return E_POINTER;
    }
    *pStats = m_CopyStats;
    return (S_OK);
}
#endif  //  BUILDSTATS

void ControlLogic::Mix(short *pBuffer,DWORD dwLength)
{
    FLOATSAFE fs;

    LONGLONG llPosition;
    DWORD dwIndex;
    LONGLONG llEndTime;
    Voice *pVoice;
    Voice *pNextVoice;
    long lNumVoices = 0;

#if BUILDSTATS
    LONGLONG    llTime = - (LONGLONG)::GetTime100Ns();
#endif  //  BUILDSTATS

    llPosition = m_stLastMixTime;
    memset(pBuffer,0,dwLength << (m_dwStereo + 1));

    llEndTime = llPosition + dwLength;
    QueueNotes(llEndTime);

    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pNextVoice)
    {
        pNextVoice = pVoice->GetNext();
        pVoice->Mix(pBuffer,dwLength,llPosition,llEndTime);
        lNumVoices++;

        if (pVoice->m_fInUse == FALSE)
        {
            m_VoicesInUse.Remove(pVoice);
            pVoice->ResetVoice();
            m_VoicesFree.AddHead(pVoice);
#if BUILDSTATS
            if (pVoice->m_stStartTime < m_stLastStats)
            {
                m_BuildStats.dwTotalSamples += (ULONG) (pVoice->m_stStopTime - m_stLastStats);
            }
            else
            {
                m_BuildStats.dwTotalSamples += (ULONG) (pVoice->m_stStopTime - pVoice->m_stStartTime);
            }
#endif  //  BUILDSTATS
        }
    }

    for (dwIndex = 0;dwIndex < 16; dwIndex++)
    {
        m_ModWheel[dwIndex].ClearMIDI(llEndTime);
        m_PitchBend[dwIndex].ClearMIDI(llEndTime);
        m_Volume[dwIndex].ClearMIDI(llEndTime);
        m_Expression[dwIndex].ClearMIDI(llEndTime);
        m_Pan[dwIndex].ClearMIDI(llEndTime);
        m_Program[dwIndex].ClearMIDI(llEndTime);
    }
#if BUILDSTATS
    FinishMix(pBuffer,dwLength);
    llTime += ::GetTime100Ns();
#endif  //  BUILDSTATS
    if (llEndTime > m_stLastMixTime)
    {
        m_stLastMixTime = llEndTime;
    }

#if BUILDSTATS
    m_BuildStats.dwTotalTime += (LONG) llTime;

    if ((m_stLastStats + m_dwSampleRate) <= m_stLastMixTime)
    {
        DWORD dwElapsed = (ULONG) (m_stLastMixTime - m_stLastStats);
        pVoice = m_VoicesInUse.GetHead();
        for (;pVoice != NULL;pVoice = pVoice->GetNext())
        {
            if (pVoice->m_stStartTime < m_stLastStats)
            {
                m_BuildStats.dwTotalSamples += dwElapsed;
            }
            else
            {
                m_BuildStats.dwTotalSamples += (ULONG) (m_stLastMixTime - pVoice->m_stStartTime);
            }
        }
        if (dwElapsed == 0) dwElapsed = 1;
        if (m_BuildStats.dwTotalSamples == 0) m_BuildStats.dwTotalSamples = 1;

        m_BuildStats.dwVoices10 = ((m_BuildStats.dwTotalSamples + (dwElapsed >> 1)) * 10) / dwElapsed;
        
        m_BuildStats.dwCPU100k = MulDiv(m_BuildStats.dwTotalTime,m_dwSampleRate, dwElapsed);
#if PRINTSTATS        
        if (m_BuildStats.dwCPU100k/100000 < 100)
        {
            _DbgPrintF( DEBUGLVL_TERSE, ("CPU usage: %2d.%02d%% on %2d.%01d voices (%d.%02d%%/voice)",
                m_BuildStats.dwCPU100k/100000,(m_BuildStats.dwCPU100k%100000)/1000,
                m_BuildStats.dwVoices10/10,m_BuildStats.dwVoices10%10,
                (m_BuildStats.dwCPU100k/m_BuildStats.dwVoices10)/10000,((m_BuildStats.dwCPU100k/m_BuildStats.dwVoices10)%10000)/100));
        }
        else
        {
            _DbgPrintF( DEBUGLVL_TERSE, ("CPU usage maxed out @ %2d.%01d voices (%d.%02d%%/voice)",
                m_BuildStats.dwVoices10/10,m_BuildStats.dwVoices10%10,
                (m_BuildStats.dwCPU100k/m_BuildStats.dwVoices10)/10000,((m_BuildStats.dwCPU100k/m_BuildStats.dwVoices10)%10000)/100));
        }
#endif  //  PRINTSTATS
        m_CopyStats = m_BuildStats;
        memset(&m_BuildStats, 0, sizeof(m_BuildStats));
        m_stLastStats = m_stLastMixTime;
    }
#endif  //  BUILDSTATS
}

STIME ControlLogic::CalibrateSampleTime(STIME stTime)
{
    STIME   stOffset,stDelta;


    stOffset = (stTime - m_stLastMixTime)
             + (m_lCalibrate/kPLLForce);        //  How far ahead from mix position is sys time?
    stDelta = m_stOptimalOffset - stOffset;     //  How close are we to the offset we want?

    if ((stDelta < m_stBrickWall) && (stDelta > (-m_stBrickWall)))
    {                                           //  If within the realm of reality,
        m_lCalibrate += stDelta;                //  just nudge toward the OptimalOffset.
    }
    else                                        //  Otherwise,
    {
        m_lCalibrate += (stDelta * kPLLForce);  //  radically adjust the calibration.
        _DbgPrintF( DEBUGLVL_VERBOSE, ("SWMidi:Brickwall @ %d, gross adjustment by %ld samples",stTime,stDelta));
    }
    stTime += (m_lCalibrate/kPLLForce);         //  Calibrate our time.

    if (m_stLastCalTime <= stTime)              //  Don't ever go backwards in time.
    {
        m_stLastCalTime = stTime;               //  Only update the time if we went forward.
    }
    return m_stLastCalTime;
}

BOOL ControlLogic::RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2)
{
    WORD nPreChannel;
    Note note;
    long lTemp;
    DWORD dwProgram;
    BOOL bReturn;
    WORD nPart;

    nPreChannel = bStatus & 0xF;
    bStatus = bStatus & 0xF0;
    bReturn = TRUE;

    if ((bStatus == 0xF0) && (nPreChannel == 0x0F))
    {
       m_fGSActive = FALSE;
       GMReset();
       SWMidiResetPatches(stTime);
       SWMidiClearAll(stTime);

       _DbgPrintF( DEBUGLVL_VERBOSE, ("Calling SetGMLoad(TRUE) from RecordMidi(), received SYS_RESET."));
       m_Instruments.SetGMLoad(TRUE);
       return bReturn;
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("Midi: %X %X %X", bStatus | nPreChannel, bData1, bData2 ));
    for (nPart = 0;nPart < 16; nPart++)
    {
        if (nPreChannel == m_bPartToChannel[nPart])
        {
            switch (bStatus)
            {
                case MIDI_NOTEOFF :
                    bData2 = 0;
                case MIDI_NOTEON :
                    note.m_bPart = (BYTE) nPart;
                    note.m_bKey = bData1;
                    note.m_bVelocity = bData2;
                    bReturn = m_Notes.RecordNote(stTime,&note);
                    break;
                case MIDI_CCHANGE :
                    switch (bData1)
                    {
                        case CC_BANKSELECTH :
                            if (GetGSActive())
                                bReturn = m_Program[nPart].RecordBankH(bData2);
                            break;
                        case CC_MODWHEEL :
                            bReturn = m_ModWheel[nPart].RecordMIDI(stTime,(long) bData2);
                            break;
                        case CC_VOLUME :
                            bReturn = m_Volume[nPart].RecordMIDI(stTime,(long) bData2);
                            break;
                        case CC_PAN :
                            bReturn = m_Pan[nPart].RecordMIDI(stTime,(long) bData2);
                            break;
                        case CC_EXPRESSION :
                            bReturn = m_Expression[nPart].RecordMIDI(stTime,(long)bData2);
                            break;
                        case CC_BANKSELECTL :
                            if (GetGSActive())
                                bReturn = m_Program[nPart].RecordBankL(bData2);
                            break;

                        case CC_RESETALL:
                            if (bData2)
                            {
                                bReturn = bReturn && m_Volume[nPart].RecordMIDI(stTime, 100);
                                bReturn = bReturn && m_Pan[nPart].RecordMIDI(stTime, 64);
                            }
                            bReturn = bReturn && m_Expression[nPart].RecordMIDI(stTime, 127);
                            bReturn = bReturn && m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
                            bReturn = bReturn && m_ModWheel[nPart].RecordMIDI(stTime, 0);

                            bData2 = 0;
                            // fall through into Sustain Off case....

                        case CC_SUSTAIN :
                            note.m_bPart = (BYTE) nPart;
                            note.m_bKey = NOTE_SUSTAIN;
                            note.m_bVelocity = bData2;
                            bReturn = bReturn && m_Notes.RecordNote(stTime,&note);
                            break;

                        case CC_ALLSOUNDSOFF:
                            note.m_bPart = (BYTE) nPart;
                            note.m_bKey = NOTE_SOUNDSOFF;
                            note.m_bVelocity = 0;
                            bReturn = m_Notes.RecordNote(stTime,&note);
                            break;

                        case CC_ALLNOTESOFF:
                            note.m_bPart = (BYTE) nPart;
                            note.m_bKey = NOTE_ALLOFF;
                            note.m_bVelocity = 0;
                            bReturn = m_Notes.RecordNote(stTime,&note);
                            break;

                        case CC_DATAENTRYMSB:
                            m_nData[nPart] &= ~(0x7F << 7);
                            m_nData[nPart] |= bData2 << 7;
                            switch (m_CurrentRPN[nPart])
                            {
                                case RPN_PITCHBEND:
                                    m_PitchBend[nPart].m_prRange = bData2 * 100;
                                    break;
                                case RPN_FINETUNE:
                                    lTemp = m_nData[nPart];
                                    lTemp -= 8192;
                                    lTemp *= 100;
                                    lTemp /= 8192;
                                    m_prFineTune[nPart] = lTemp;
                                    break;
                                case RPN_COARSETUNE:
                                    m_prCoarseTune[nPart] = 100 * (bData2 - 64);
                                    break;
                                default:
                                    DPF2(3, "Unhandled data-entry MSB nPart %d: %d  (semitones set)", nPart, bData2);
                                }
                            break;

                        case CC_DATAENTRYLSB:
                            m_nData[nPart] &= ~0x7F;
                            m_nData[nPart] |= bData2;
                            switch (m_CurrentRPN[nPart])
                            {
                                case RPN_PITCHBEND: // Don't do anything, Roland ignores lsb
                                    break;
                                case RPN_FINETUNE:
                                    lTemp = m_nData[nPart];
                                    lTemp -= 8192;
                                    lTemp *= 100;
                                    lTemp /= 8192;
                                    m_prFineTune[nPart] = lTemp;
                                    break;
                                case RPN_COARSETUNE: // Ignore lsb
                                    break;
                                default:
                                    DPF2(3, "Unhandled data-entry LSB channel %d: %d", nPart, bData2);
                            }
                            break;
                        case CC_NRPN_LSB :
                        case CC_NRPN_MSB :
                            m_CurrentRPN[nPart] = 0x3FFF;   // Safely disable it!
                            break;
                        case CC_RPN_LSB:
                            m_CurrentRPN[nPart] = (m_CurrentRPN[nPart] & 0x3f80) + bData2;
                            DPF2(1, "New RPN #%d on nPart %d  (LSB set)",
                                     m_CurrentRPN[nPart], nPart);
                            break;

                        case CC_RPN_MSB:
                            m_CurrentRPN[nPart] = (m_CurrentRPN[nPart] & 0x7f) + (bData2 << 7);
                            DPF2(1, "New RPN #%d on nPart %d  (MSB set)",
                                     m_CurrentRPN[nPart], nPart);
                            break;
                        case CC_MONOMODE :
                            m_fMono[nPart] = TRUE;
                            note.m_bPart = (BYTE) nPart;
                            note.m_bKey = NOTE_SOUNDSOFF;
                            note.m_bVelocity = 0;
                            bReturn = m_Notes.RecordNote(stTime,&note);
                            break;
                        case CC_POLYMODE :
                            m_fMono[nPart] = FALSE;
                            note.m_bPart = (BYTE) nPart;
                            note.m_bKey = NOTE_SOUNDSOFF;
                            note.m_bVelocity = 0;
                            bReturn = m_Notes.RecordNote(stTime,&note);
                            break;
                        default:
                            DPF4(3, "Unhandled controller: %7d: (%d): %d = %d",
                                     stTime, nPart, bData1, bData2);
                            break;
                    }
                    break;

                case MIDI_PCHANGE :
                    DPF2(3, "Program change: nPart %2d to instrument %d", nPart, bData1);
                    bReturn = m_Program[nPart].RecordProgram(stTime,bData1);
                    dwProgram = m_Program[nPart].GetProgram(stTime);
                    if (m_bDrums[nPart])
                    {
                        int nDrumPart;
                        dwProgram |= AA_FINST_DRUM;
                        for (nDrumPart = 0;nDrumPart < 16; nDrumPart++)
                        {
                            if (m_bDrums[nDrumPart] == m_bDrums[nPart])
                            {
                                m_Instruments.RequestGMInstrument((DWORD) nDrumPart,dwProgram);
                            }
                        }
                    }
                    else
                    {
                        if (!m_Instruments.RequestGMInstrument((DWORD) nPart,dwProgram))
                        {
                            // Fallback to GM.
                            //
                            m_Instruments.RequestGMInstrument((DWORD) nPart,dwProgram & 0x7F);
                        }
                    }
                    break;

                case MIDI_PBEND :
                    WORD nBend;
                    nBend = bData2 << 7;
                    nBend |= bData1;
                    bReturn = m_PitchBend[nPart].RecordMIDI(stTime,(long)nBend);
                    break;
            }   //  switch bStatus
        }   //  if nPreChannel
    }   //  for nPart
    return bReturn;
}

BOOL ControlLogic::RecordSysEx(STIME stTime,DWORD dwSysExLength,BYTE *pSysExData)
{
    Note note;
    int nPart,nTune;
    DWORD dwAddress;
    BOOL fClearAll,fResetPatches;

    fClearAll = FALSE;
    fResetPatches = FALSE;

    
    if (dwSysExLength < 6) return FALSE;

    switch (pSysExData[1])  // ID number
    {
        case 0x7E : // General purpose ID
            if (pSysExData[3] == 0x09)
            {
                GMReset();
                fClearAll = TRUE;
                fResetPatches = TRUE;

                BOOL fGMSysOn = (pSysExData[4] == 0x01);
                if (fGMSysOn)
                    m_fGSActive = FALSE;
                _DbgPrintF( DEBUGLVL_VERBOSE, ("Calling SetGMLoad(%x) from RecordSysEx(), received GM_State SysEx.",
                                             fGMSysOn));
                m_Instruments.SetGMLoad(fGMSysOn);
            }
            break;
        case 0x7F : // Real time ID
            if (pSysExData[3] == 0x04)
            {
                if (pSysExData[4] == 1) // Master Volume
                {
                    note.m_bPart = 0;
                    note.m_bKey = NOTE_MASTERVOLUME;
                    note.m_bVelocity = pSysExData[6];
                    m_Notes.RecordNote(stTime,&note);
                }
            }
            break;
        case 0x41 : // Roland
        {
            if (dwSysExLength < 11)     return FALSE;
            if (pSysExData[3] != 0x42)  break;
            if (pSysExData[4] != 0x12)  break;
            nPart = pSysExData[6] & 0xF;
            dwAddress = (pSysExData[5] << 16) |
                ((pSysExData[6] & 0xF0) << 8) | pSysExData[7];

            switch (dwAddress)
            {
                case 0x40007F :     // GS Reset.
                    GMReset();
			        fClearAll = TRUE;
			        m_fGSActive = TRUE;
			        fResetPatches = TRUE;
                    break;
                case 0x401002 :     // Set Receive Channel.
                    if (m_fGSActive)
                    {
                        if (pSysExData[8])
                        {
                            note.m_bPart = (BYTE) nPart;
                            note.m_bKey = NOTE_ASSIGNRECEIVE;
                            note.m_bVelocity = pSysExData[8] - 1;
                            m_Notes.RecordNote(stTime,&note);
                        }
//                      fClearAll = TRUE;
                    }
                    break;
                case 0x401015 :     // Use for Rhythm.
                    if (m_fGSActive)
                    {
                        m_bDrums[nPart] = pSysExData[8];
                        fClearAll = TRUE;
                    }
                    break;
                case 0x401040 :     // Scale Tuning.
                    if (m_fGSActive)
                    {
                        for (nTune = 0;nTune < 12; nTune++)
                        {
                            if (pSysExData[9 + nTune] & 0x80) break;
                            m_prScaleTune[nPart][nTune] =
                                (PREL) pSysExData[8 + nTune] - (PREL) 64;
                        }
                    }
                    break;
            }   //  switch dwAddress
            break;
        }   //  case Roland
    }   //  switch ID number
    if (fClearAll)
    {
        SWMidiClearAll(stTime);
    }
    if (fResetPatches)
    {
        SWMidiResetPatches(stTime);
    }

    return TRUE;
}

void
ControlLogic::SWMidiClearAll(STIME stTime)
{
    Note    note;
    int     nPart;

    AllNotesOff();
    Flush(0);
    for (nPart = 0;nPart < 16;nPart++)
    {
        note.m_bPart = (BYTE) nPart;
        note.m_bKey = NOTE_SUSTAIN;
        note.m_bVelocity = 0; // sustain off
        m_Notes.RecordNote(stTime,&note);
        m_Volume[nPart].RecordMIDI(stTime, 100);
        m_Pan[nPart].RecordMIDI(stTime, 64);
        m_Expression[nPart].RecordMIDI(stTime, 127);
        m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
        m_ModWheel[nPart].RecordMIDI(stTime, 0);
    }
}

void
ControlLogic::SWMidiResetPatches(STIME stTime)
{
    DWORD   dwProgram;
    int     nPart;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("Resetting Patches"));
    for (nPart = 0;nPart < 16;nPart++)
    {
        m_Program[nPart].RecordBankL(0);
        m_Program[nPart].RecordBankH(0);
        m_Program[nPart].RecordProgram(stTime,0);
        dwProgram = m_Program[nPart].GetProgram(stTime);
        if (m_bDrums[nPart])
        {
            int nDrumPart;
            dwProgram |= AA_FINST_DRUM;
            for (nDrumPart = 0;nDrumPart < 16; nDrumPart++)
            {
                if (m_bDrums[nDrumPart] == m_bDrums[nPart])
                {
                    m_Instruments.RequestGMInstrument((DWORD) nDrumPart,dwProgram);
                }
            }
        }
        else
        {
            m_Instruments.RequestGMInstrument((DWORD) nPart,dwProgram);
        }
    }
}

//
//  New/delete for WDM driver
//

void * __cdecl operator new( size_t size )
{
    return(ExAllocatePoolWithTag(PagedPool,size,'iMwS'));   //  SwMi
}

/*****************************************************************************
 * operator new()
 *****************************************************************************
 * Overload new to allocate with a specified allocation tag.
 * Allocates from PagedPool or NonPagedPool, as specified.
 */
inline PVOID operator new(size_t iSize, ULONG tag)
{
    PVOID result = ExAllocatePoolWithTag(PagedPool, iSize, tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }
#if DBG
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("Couldn't allocate tagged PagedPool: %d bytes", iSize));
    }
#endif // DBG

    return result;
}

void __cdecl operator delete( void *p )
{
    ExFreePool(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\clist.h ===
//
//      clist.h
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#ifndef __CLIST_H__
#define __CLIST_H__

// Forward Declaration.
class CList;

// WARNING
// Always use CList functions to remove and add items to list.
// Never never use SetNext to remove or add items. This will
// definitely break list item counting.

class CListItem
{
public:
    CListItem() { m_pNext=NULL; };
    CListItem *GetNext() const { return m_pNext;};
    ULONG GetCount() const;
    void Reset() {m_pNext = NULL;};
    BOOL IsMember(CListItem *pItem);
    CListItem* GetPrev(CListItem *pItem) const;
    CListItem* GetItem(LONG index);

private:
    CListItem *m_pNext;

    // These are affecting the size of the list.
    // Only CList should call them.
    CListItem* Remove(CListItem* pItem);
    CListItem* Cat(CListItem* pItem);
    CListItem* AddTail(CListItem* pItem) { return Cat(pItem);};
    void SetNext(CListItem *pNext) {m_pNext=pNext;}; 

    friend class CList;
};

class CList
{
public:
    CList() { m_pHead=NULL; m_ulCount=0; m_ulMaxItems=(ULONG) -1;};
    CList(ULONG ulMaxItems) { m_pHead=NULL; m_ulCount=0; m_ulMaxItems=ulMaxItems;};
    CListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL; m_ulCount=0;};
    ULONG GetCount() const { return m_ulCount;}; 
    CListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertAfter(CListItem *pItem, CListItem *pInsert);
    void InsertBefore(CListItem *pItem,CListItem *pInsert);
    void Cat(CListItem *pItem) 
        {
            ASSERT(pItem);
            m_ulCount += pItem->GetCount();
            m_pHead=m_pHead->Cat(pItem); 
        };
    void Cat(CList *pList)
        {
            ASSERT(pList);
            m_ulCount += pList->GetCount();
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void Truncate(CListItem *pItem);
    void AddHead(CListItem *pItem)
        {
            ASSERT(pItem);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
            m_ulCount++;
        }
    void AddTail(CListItem *pItem) 
        {
            m_pHead=m_pHead->AddTail(pItem);
            m_ulCount++;
        };
    void Remove(CListItem *pItem) 
        {
            ASSERT(0 != m_ulCount);
            m_pHead=m_pHead->Remove(pItem);
            m_ulCount--;
        };
    CListItem *GetPrev(CListItem *pItem) const { return m_pHead->GetPrev(pItem);};
    CListItem *GetTail() const { return GetPrev(NULL);};
    BOOL IsEmpty(void) const { return (m_pHead==NULL);};
    BOOL IsFull(void) const { return (m_ulCount >= m_ulMaxItems);};
    BOOL IsMember(CListItem *pItem) { return (m_pHead->IsMember(pItem));};
    CListItem *RemoveHead(void)
        {
            CListItem *li;
            li=m_pHead;
            if (m_pHead)
            {
                m_pHead=m_pHead->GetNext();
                ASSERT(0 != m_ulCount);
                m_ulCount--;
            }
            if (li)
                li->SetNext(NULL);
            return li;
        }

protected:
    CListItem *m_pHead;
    ULONG      m_ulCount;
    ULONG      m_ulMaxItems;
};

#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\device.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define IRPMJFUNCDESC

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

const WCHAR FilterTypeName[] = KSSTRING_Filter;


DEFINE_KSCREATE_DISPATCH_TABLE(DeviceCreateItems)
{
    DEFINE_KSCREATE_ITEM(FilterDispatchCreate, FilterTypeName, NULL)
};


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------


NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING      usRegistryPathName
)
{


    KeInitializeMutex(&gMutex, 0);
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = PnpDriverUnload;   // KsNullDriverUnload;


    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_WRITE);


    MIDIRecorder::InitTables();        
    Voice::Init();
    Wave::Init();

    return STATUS_SUCCESS;
}


NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch (pIrpStack->MinorFunction) 
    {
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            //
            // Mark the device as not disableable.
            //
            pIrp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            break;
    }
    return (KsDefaultDispatchPnp(pDeviceObject, pIrp));
}


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
)
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    _DbgPrintF(DEBUGLVL_TERSE,("Entering PnpAddDevice"));
    NTSTATUS            Status;
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    pDeviceInstance;
    GUID                NameFilter = KSNAME_Filter ;

    //
    // The Software Bus Enumerator expects to establish links 
    // using this device name.
    //
    Status = IoCreateDevice( 
                DriverObject,  
	            sizeof( DEVICE_INSTANCE ),
                NULL,                           // FDOs are unnamed
                FILE_DEVICE_KS,
                0,
                FALSE,
                &FunctionalDeviceObject );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    pDeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;

    Status = KsAllocateDeviceHeader(
                &pDeviceInstance->pDeviceHeader,
                SIZEOF_ARRAY( DeviceCreateItems ),
                (PKSOBJECT_CREATE_ITEM)DeviceCreateItems );

    if (NT_SUCCESS(Status)) 
    {
        KsSetDevicePnpAndBaseObject(
            pDeviceInstance->pDeviceHeader,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject ),
            FunctionalDeviceObject );

        FunctionalDeviceObject->Flags |= (DO_DIRECT_IO | DO_POWER_PAGABLE);
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }
    else
    {
        IoDeleteDevice( FunctionalDeviceObject );
    }
    
    return Status;
}


VOID
PnpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
    _DbgPrintF(DEBUGLVL_TERSE,("Entering PnpDriverUnload"));
    KsNullDriverUnload(DriverObject);
}

//---------------------------------------------------------------------------
//  End of File: device.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\clist.cpp ===
//
//      clist.cpp
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"

ULONG CListItem::GetCount(void) const
{
    ULONG l;
    const CListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

BOOL CListItem::IsMember(CListItem *pItem)

{
    CListItem *li = this;
    for (;li != NULL; li=li->m_pNext)
    {
        if (li == pItem) return (TRUE);
    }
    return (FALSE);
}

CListItem* CListItem::Cat(CListItem *pItem)
{
    CListItem *li;

    if (this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

CListItem* CListItem::Remove(CListItem *pItem)
{
    CListItem *li,*prev;

    if (pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if (li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

CListItem* CListItem::GetPrev(CListItem *pItem) const
{
    const CListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (CListItem*)prev;
}

CListItem * CListItem::GetItem(LONG index)
{
    CListItem *scan;
    for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
    return (scan);
}

// pItem is the new last element of the truncated list.
void CList::Truncate(CListItem *pItem)
{
    ASSERT(pItem);
    
    CListItem *pCutListHead = pItem->GetNext();

    if (pCutListHead)
    {
        m_ulCount -= pCutListHead->GetCount();
        pItem->SetNext(NULL);
    }
}

void CList::InsertAfter(CListItem *pItem, CListItem *pInsert)
{
    ASSERT(pItem); 
    ASSERT(pInsert);

    CListItem *next = pItem->GetNext();
    pItem->SetNext(pInsert);
    pInsert->SetNext(next);
    m_ulCount++;
}

void CList::InsertBefore(CListItem *pItem,CListItem *pInsert)
{
    ASSERT(pItem);
    ASSERT(pInsert);

    CListItem *prev = GetPrev(pItem);
    pInsert->SetNext(pItem);
    if (prev) prev->SetNext(pInsert);
    else m_pHead = pInsert;
    m_ulCount++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\dls.h ===
//==========================================================================;
//
//  dls.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//==========================================================================;

#ifndef _INC_DLS
#define _INC_DLS

///////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn' 
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL 
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//
// INFOLIST
// LIST [] 'INFO' 
//               'icmt' 'One of those crazy comments.'
//               'icop' 'Copyright (C) 1996 Sonic Foundry'
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
///////////////////////////////////////////////////////////////////////////

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('W','A','V','E')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

///////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions 
///////////////////////////////////////////////////////////////////////////

// Generic Sources
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

// Midi Controllers 0-127
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

// Generic Destinations
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_RESERVED          0x0002
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

// LFO Destinations
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

// EG1 Destinations
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RESERVED      0x0208
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

// EG2 Destinations
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RESERVED      0x030c
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;
				   

typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


// Level 1 Articulation Data

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            // size of the connection list structure
  ULONG    cConnections;      // count of connections in the list
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



///////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
///////////////////////////////////////////////////////////////////////////

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

///////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
///////////////////////////////////////////////////////////////////////////

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            // Key range 
  RGNRANGE RangeVelocity;       // Velocity Range 
  USHORT   fusOptions;          // Synthesis options for this range
  USHORT   usKeyGroup;          // Key grouping for non simultaneous play
                                // 0 = no group, 1 up is group
                                // for Level 1 only groups 1-15 are allowed
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          // Count of regions in this instrument
  MIDILOCALE Locale;            // Intended MIDI locale of this instrument
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      // Count of instruments in the collection
}DLSHEADER, FAR *LPDLSHEADER;

//////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
//////////////////////////////////////////////////////////////////////////////

// ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  ****
// ulChannel allows for up to 32 channels of audio with each bit position
// specifiying a channel of playback

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { // any paths or links are stored right after struct
  USHORT   fusOptions;     // options flags for this wave
  USHORT   usPhaseGroup;   // Phase grouping for locking channels
  ULONG    ulChannel;      // channel placement
  ULONG    ulTableIndex;   // index into the wave pool table, 0 based
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE { 
//  ULONG    ulEntryIndex;   // Index entry in the list
  ULONG    ulOffset;       // Offset to the entry in the list
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            // size of the pool table structure
  ULONG    cCues;             // count of cues in the list
  } POOLTABLE, FAR *LPPOOLTABLE;

//////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
//////////////////////////////////////////////////////////////////////////////

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         // MIDI Unity Playback Note
  SHORT   sFineTune;           // Fine Tune in log tuning
  LONG    lAttenuation;        // Overall Attenuation to be applied to data
  ULONG   fulOptions;          // Flag options 
  ULONG   cSampleLoops;        // Count of Sample loops, 0 loops is one shot
  } WSMPL, FAR *LPWSMPL;


// This loop type is a normal forward playing loop which is continually
// played until the envelope reaches an off threshold in the release
// portion of the volume envelope

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              // Loop Type
  ULONG ulStart;             // Start of loop in samples
  ULONG ulLength;            // Length of loop in samples
} WLOOP, FAR *LPWLOOP;

#endif //_INC_DLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\maketab.cpp ===
//      maketab.cpp
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"
#include <math.h>

short * DigitalAudio::m_pnDecompMult = NULL; //[NLEVELS * 256];
short VoiceLFO::m_snSineTable[256] = { 0 };
short VoiceEG::m_snAttackTable[201] = { 0 };
PFRACT DigitalAudio::m_spfCents[201] = { 0 };
PFRACT DigitalAudio::m_spfSemiTones[97] = { 0 };
VFRACT DigitalAudio::m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1] = { 0 };
MIDIData *MIDIRecorder::m_pEventPool = NULL;
CList    *MIDIRecorder::m_pFreeEventList = NULL;
LONG      MIDIRecorder::m_lRefCount = 0;


// short DigitalAudio::m_InterpMult[NINTERP * 512] = { 0 };
VREL        Voice::m_svrPanToVREL[128] = { 0 };
char        Wave::m_Compress[2048] = { 0 };
VREL        MIDIRecorder::m_vrMIDIToVREL[128] = { 0 };

BOOL DigitalAudio::m_sfMMXEnabled = FALSE;

void DigitalAudio::InitCompression()
{
	long lVal;
	if (m_pnDecompMult != 0)
	{
		return;
	}
	m_pnDecompMult = new short [NLEVELS * 256];
	if (m_pnDecompMult == 0)
	{
		return;
	}
    for (int multiplier = 0; multiplier < NLEVELS; multiplier++)
    {
        for (lVal = -128; lVal < 128; lVal++)
        {
            float flTemp;
            long lTemp = lVal;
            if (lTemp < 0) lTemp = -lVal;
            flTemp = (float)(lTemp);
            flTemp /= (float)128.0;
            flTemp = powf((float)8.0,flTemp);
            flTemp -= (float)1.0;
            flTemp *= (float)(16384.0 / 7.0);
            if (lVal < 0) 
            {
                flTemp = -flTemp;
            }
            flTemp *= (float)(multiplier);
            flTemp /= (float)NLEVELS-1;
            m_pnDecompMult[(multiplier * 256) + lVal + 128] = 
                (short) (flTemp);  
        }
    }
}

void DigitalAudio::ClearCompression()

{
	if (m_pnDecompMult == 0)
	{
		return;
	}
	delete m_pnDecompMult;
	m_pnDecompMult = NULL;
}

#pragma optimize("", off) // Optimize causes crash! Argh!

void DigitalAudio::Init()
{
    float   flVolume;
    VREL    vrdB;

#ifdef MMX_ENABLED
	m_sfMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
    for (vrdB = MINDB * 10;vrdB <= MAXDB * 10;vrdB++)
    {
        flVolume = (float)(vrdB);
        flVolume /= (float)100.0;
        flVolume = powf((float)10.0,flVolume);
        flVolume = powf(flVolume,(float)0.5);   // square root.
        flVolume *= (float)4095.0; // 2^12th, but avoid overflow...
        m_svfDbToVolume[vrdB - (MINDB * 10)] = (long)(flVolume);
    }

    PREL prRatio;
    float flPitch;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flPitch = (float)(prRatio);
        flPitch /= (float)1200.0;
        flPitch = powf((float)2.0,flPitch);
        flPitch *= (float)4096.0;
        m_spfCents[prRatio + 100] = (long)(flPitch);
    }
    
    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flPitch = (float)(prRatio);
        flPitch /= (float)12.0;
        flPitch = powf((float)2.0,flPitch);
        flPitch *= (float)4096.0;
        m_spfSemiTones[prRatio + 48] = (long)(flPitch);
    }
}

#pragma optimize("", on)

void MIDIRecorder::DestroyEventList()
{
    KeWaitForSingleObject(&gMutex,Executive,KernelMode,FALSE,NULL);
    if (0 == (--m_lRefCount))
    {
        ASSERT(m_pFreeEventList);
        ASSERT(m_pEventPool);

        delete m_pFreeEventList;
        delete [] m_pEventPool;
        
        m_pFreeEventList = NULL;
        m_pEventPool = NULL;
    }
    KeReleaseMutex(&gMutex, FALSE);
}

BOOL MIDIRecorder::InitEventList()
{
    BOOL fResult = TRUE;

    KeWaitForSingleObject(&gMutex,Executive,KernelMode,FALSE,NULL);

    // Allocate an array of MidiData and add them to free list.
    if (0 == m_lRefCount)
    {
        m_pEventPool = new MIDIData[MAX_MIDI_EVENTS];
        if (m_pEventPool)
        {
            m_pFreeEventList = new CList();
            if (m_pFreeEventList)
            {
                for (int i = 0; i < MAX_MIDI_EVENTS; i++)
                {
                    m_pFreeEventList->AddHead(&m_pEventPool[i]);
                }
            }
            else
            {
                delete [] m_pEventPool;
                m_pEventPool = NULL;
                fResult = FALSE;
                _DbgPrintF(DEBUGLVL_TERSE, ("Free MIDIData list allocation failed (m_pFreeEventList)"));
            }
        }
        else
        {
            fResult = FALSE;
            _DbgPrintF(DEBUGLVL_TERSE, ("MIDIData pool allocation failed (m_pEventPool)"));
        }
    }
    
    if (fResult)
    {
        m_lRefCount++;       
    }

    KeReleaseMutex(&gMutex, FALSE);

    return fResult;
}

void MIDIRecorder::InitTables()
{
    int nIndex;
    for (nIndex = 1; nIndex < 128; nIndex++)
    {
        float   flDB;
        flDB = (float)(nIndex);
        flDB /= (float)127.0;
        flDB = powf(flDB,(float)4.0);
        flDB = log10f(flDB);
        flDB *= (float)1000.0;
        m_vrMIDIToVREL[nIndex] = (long)(flDB);
    }
    m_vrMIDIToVREL[0] = -9600;
}

void VoiceEG::Init()
{
    float flVolume;
    long lV;

	m_snAttackTable[0] = 0;
    for (lV = 1;lV <= 200; lV++)
    {
        flVolume = (float)(lV);
        flVolume /= (float)200.0;
        flVolume *= flVolume;
        flVolume = log10f(flVolume);
        flVolume *= (float)10000.0;
        flVolume /= (float)96;
        flVolume = flVolume + (float)1000.0;
        m_snAttackTable[lV] = (short) (flVolume);
    }   
}

void Voice::Init()
{
    
    VoiceLFO::Init();
    VoiceEG::Init();
    DigitalAudio::Init();

    WORD nI;
    for (nI = 1; nI < 128; nI++)
    {
        float flDB;
        flDB = (float)(nI);
        flDB /= (float)127.0;
        flDB = log10f(flDB);
        flDB *= (float)1000.0;
        m_svrPanToVREL[nI] = (long)(flDB);
    }  
    m_svrPanToVREL[0] = -2500;
}

void Wave::Init()
{
    long lOrig; 
    float flLog8 = log10f((float)8.0);
    for (lOrig = 0; lOrig < 2048; lOrig++)
    {
        float flTemp = (float)(lOrig);
        flTemp *= (float)7.0;
        flTemp /= (float)2048.0;
        flTemp = flTemp + (float)1.0;
        flTemp = log10f(flTemp);
        flTemp *= (float)128.0;
        flTemp /= flLog8;
        m_Compress[lOrig] = (char) (flTemp);
    }
}

void VoiceLFO::Init()
{
    float flSine;
    long lIndex;
    for (lIndex = 0;lIndex < 256;lIndex++)
    {
        flSine = (float)(lIndex);
        flSine *= (float)6.283185307;
        flSine /= (float)256.0;
        flSine = sinf(flSine);
        flSine *= (float)100.0;
        m_snSineTable[lIndex] = (short) (long)(flSine);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\instr.cpp ===
//      Instrument.cpp
//      Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"

HRESULT GetRegDlsFileName(PCWSTR lpSubKey, PCWSTR lpValueName, PWSTR lpszString, DWORD cbSize)
{
    ASSERT(lpSubKey);
    ASSERT(lpValueName);
    ASSERT(lpszString);
    ASSERT(cbSize);
    
    NTSTATUS                        ntStatus;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION  pKeyValuePartialInformation = NULL;
    UNICODE_STRING                  UnicodeSubKey;
    UNICODE_STRING                  UnicodeValueName;
    HANDLE                          hKey;
    DWORD                           dwCbData;

    RtlInitUnicodeString(&UnicodeSubKey, lpSubKey);
    RtlInitUnicodeString(&UnicodeValueName, lpValueName);
    lpszString[0] = 0;
    InitializeObjectAttributes(
        &ObjectAttributes, 
        &UnicodeSubKey, 
        OBJ_CASE_INSENSITIVE, 
        NULL, 
        NULL);

    pKeyValuePartialInformation = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool(
        PagedPool, 
        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(WCHAR) * MAX_PATH);
    if (pKeyValuePartialInformation)
    {
        pKeyValuePartialInformation->DataLength = sizeof(WCHAR) * MAX_PATH;
        ntStatus = ZwOpenKey(
            &hKey, 
            KEY_QUERY_VALUE, 
            &ObjectAttributes);
        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = ZwQueryValueKey(
                hKey, 
                &UnicodeValueName, 
                KeyValuePartialInformation,
                pKeyValuePartialInformation, 
                sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(WCHAR) * MAX_PATH, 
                &dwCbData);

            // The registry only exists for Windows XP and higher. (wdmaudio.inf)
            // For all other systems default path is used.
            //
            if (NT_SUCCESS(ntStatus))
            {
                if (dwCbData <= cbSize)
                {
                    if (pKeyValuePartialInformation->Type == REG_SZ)
                    {
                        wcscpy(lpszString, (PWSTR) pKeyValuePartialInformation->Data);
                    }
                    else 
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                }
                else
                {
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                }
            }

            ZwClose(hKey);
        }
        
        ExFreePool(pKeyValuePartialInformation);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return (NT_SUCCESS(ntStatus) ? S_OK : E_FAIL);
} // GetRegDlsFileName

SourceLFO::SourceLFO()
{
    m_pfFrequency = 237; // f = (256*4096*hz)/(samplerate)
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
}

void SourceLFO::Init(DWORD dwSampleRate)
{
    m_pfFrequency = (256 * 4096 * 5) / dwSampleRate;
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
}

void SourceLFO::SetSampleRate(long lChange)
{
    if (lChange > 0)
    {
        m_stDelay <<= lChange;
        m_pfFrequency <<= lChange;
    }
    else
    {
        m_stDelay >>= -lChange;
        m_pfFrequency >>= -lChange;
    }
}

void SourceLFO::Verify()
{
    FORCEBOUNDS(m_pfFrequency,4,475);
    FORCEBOUNDS(m_stDelay,0,441000);
    FORCEBOUNDS(m_vrVolumeScale,-1200,1200);
    FORCEBOUNDS(m_vrMWVolumeScale,-1200,1200);
    FORCEBOUNDS(m_prPitchScale,-1200,1200);
    FORCEBOUNDS(m_prMWPitchScale,-1200,1200);
}

SourceEG::SourceEG()
{
    m_stAttack = 0;
    m_stDecay = 0;
    m_pcSustain = 1000;
    m_stRelease = 0;
    m_trVelAttackScale = 0;
    m_trKeyDecayScale = 0;
    m_sScale = 0;
}

void SourceEG::Init(DWORD dwSampleRate)
{
    m_stAttack = 0;
    m_stDecay = 0;
    m_pcSustain = 1000;
    m_stRelease = 0;
    m_trVelAttackScale = 0;
    m_trKeyDecayScale = 0;
    m_sScale = 0;
}

void SourceEG::SetSampleRate(long lChange)
{
    if (lChange > 0)
    {
        m_stAttack <<= lChange;
        m_stDecay <<= lChange;
        m_stRelease <<= lChange;
    }
    else
    {
        m_stAttack >>= -lChange;
        m_stDecay >>= -lChange;
        m_stRelease >>= -lChange;
    }
}

void SourceEG::Verify()
{
    FORCEBOUNDS(m_stAttack,0,1764000);
    FORCEBOUNDS(m_stDecay,0,1764000);
    FORCEBOUNDS(m_pcSustain,0,1000);
    FORCEBOUNDS(m_stRelease,0,1764000);
    FORCEBOUNDS(m_sScale,-1200,1200);
    FORCEBOUNDS(m_trKeyDecayScale,-12000,12000);
    FORCEBOUNDS(m_trVelAttackScale,-12000,12000);
}

SourceArticulation::SourceArticulation()
{
    m_sVelToVolScale = -9600;
    m_lUsageCount = 0;
    m_sDefaultPan = 0;
    m_dwSampleRate = 22050;
    m_PitchEG.m_sScale = 0; // pitch envelope defaults to off
    m_wEditTag = 0;
}

void SourceArticulation::SetSampleRate(DWORD dwSampleRate)
{
    if (dwSampleRate != m_dwSampleRate)
    {
        long lChange;
        if (dwSampleRate > (m_dwSampleRate * 2))
        {
            lChange = 2;        // going from 11 to 44.
        }
        else if (dwSampleRate > m_dwSampleRate)
        {
            lChange = 1;        // must be doubling
        }
        else if ((dwSampleRate * 2) < m_dwSampleRate)
        {
            lChange = -2;       // going from 44 to 11
        }
        else
        {
            lChange = -1;       // that leaves halving.
        }
        m_dwSampleRate = dwSampleRate;
        m_LFO.SetSampleRate(lChange);
        m_PitchEG.SetSampleRate(lChange);
        m_VolumeEG.SetSampleRate(lChange);
    }
}

void SourceArticulation::Verify()
{
    FORCEBOUNDS(m_sVelToVolScale,-20000,20000);
    m_LFO.Verify();
    m_PitchEG.Verify();
    m_VolumeEG.Verify();
}

void SourceArticulation::AddRef()
{
    LONG   usageCount = InterlockedIncrement(&m_lUsageCount);
    ASSERT(usageCount > 0);
}

void SourceArticulation::Release()
{
    LONG   usageCount = InterlockedDecrement(&m_lUsageCount);
    ASSERT(usageCount >= 0);
    if (usageCount == 0)
    {
        delete this;
    }
}

SourceSample::SourceSample()
{
    m_pWave = NULL;
    m_dwLoopStart = 0;
    m_dwLoopEnd = 1;
    m_dwSampleLength = 0;
    m_prFineTune = 0;
    m_dwSampleRate = 22050;
    m_bMIDIRootKey = 60;
    m_bOneShot = TRUE;
    m_bSampleType = 0;
    m_bWSMPLoaded = FALSE;
}

SourceSample::~SourceSample()
{ 
    if (m_pWave != NULL)
    {
        if (m_pWave->IsLocked())
        {
            m_pWave->UnLock();
        }
        m_pWave->Release();
    }
}

void SourceSample::Verify()
{
    if (m_pWave != NULL)
    {
        if (m_pWave->IsLocked())
        {
            FORCEUPPERBOUNDS(m_dwSampleLength,m_pWave->m_dwSampleLength);
            FORCEBOUNDS(m_dwLoopEnd,1,m_dwSampleLength);
            FORCEUPPERBOUNDS(m_dwLoopStart,m_dwLoopEnd);
            if ((m_dwLoopEnd - m_dwLoopStart) < 6) 
            {
                m_bOneShot = TRUE;
            }
        }
    }
    FORCEBOUNDS(m_dwSampleRate,3000,80000);
    FORCEBOUNDS(m_bMIDIRootKey,0,127);
    FORCEBOUNDS(m_prFineTune,-1200,1200);
}

BOOL SourceSample::CopyFromWave()
{
    if (m_pWave == NULL)
    {
        return FALSE;
    }
    m_dwSampleLength = m_pWave->m_dwSampleLength;
    m_dwSampleRate = m_pWave->m_dwSampleRate;
    m_bSampleType = m_pWave->m_bSampleType; 
    if (m_pWave->m_bWSMPLoaded && !m_bWSMPLoaded)
    {
        m_dwLoopEnd = m_pWave->m_dwLoopEnd;
        m_dwLoopStart = m_pWave->m_dwLoopStart;
        m_bOneShot = m_pWave->m_bOneShot;
        m_prFineTune = m_pWave->m_prFineTune;
        m_bMIDIRootKey = m_pWave->m_bMIDIRootKey;
    }
    if (m_bOneShot)
    {
        m_dwSampleLength--;
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength] = 0;
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength] = 0;
        }
    }
    else 
    {
        if (m_dwLoopStart >= m_dwSampleLength)
        {
            m_dwLoopStart = 0;
        }
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength-1] =
                m_pWave->m_pnWave[m_dwLoopStart];
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength-1] = pBuffer[m_dwLoopStart];
        }
    }
    Verify();
    return (TRUE);
}

BOOL SourceSample::Lock()
{
    if (m_pWave == NULL)
    {   // error, no wave structure!
        return (FALSE);
    }
    if (m_pWave->Lock())
    {
        if (m_pWave->m_pnWave)
        {
            return CopyFromWave();
        }
        // no wave, must be problem
        m_pWave->UnLock();
        return (FALSE);
    }
    // no lock, must be problem
    return (FALSE);
}

BOOL SourceSample::UnLock()
{
    if (m_pWave != NULL)
    {
        if (m_pWave->IsLocked())
        {
            m_pWave->UnLock();
            return (TRUE);
        }
        //  we have already been unlocked, must be something strange
        return (FALSE);
    }
    // no wave object, must be problem
    return (FALSE);
}

Wave::Wave()
{
    m_pnWave = NULL;
    m_dwSampleRate = 22050;
    m_bSampleType = SFORMAT_16;
    m_dwSampleLength = 0;
    m_lUsageCount = 0;
    m_lLockCount = 0;
    m_uipOffset = 0;
    m_wID = 0;
    m_bCompress = COMPRESS_OFF;
    m_bOneShot = FALSE;
    m_wEditTag = 0;
}

Wave::~Wave()
{
    if (m_pnWave)
    {
        ASSERT(m_pnWave == NULL);
        ExFreePool(m_pnWave);
        m_pnWave = NULL;
    }
}

void Wave::Verify()
{
    if (IsLocked())
    {
        if (m_pnWave == NULL)
        {
            m_dwSampleLength = 0;
        }
    }
    FORCEBOUNDS(m_dwLoopEnd,1,m_dwSampleLength);
    FORCEUPPERBOUNDS(m_dwLoopStart,m_dwLoopEnd);
    if ((m_dwLoopEnd - m_dwLoopStart) < 5) 
    {
        m_bOneShot = TRUE;
    }
    FORCEBOUNDS(m_dwSampleRate,3000,80000);
    FORCEBOUNDS(m_bMIDIRootKey,0,127);
    FORCEBOUNDS(m_prFineTune,-1200,1200);
    FORCEBOUNDS(m_vrAttenuation,-10000,0);
}

BOOL Wave::Lock()
{
    LONG   lockCount = InterlockedIncrement(&m_lLockCount);
    ASSERT(IsLocked());
    if (lockCount == 1)
    {
        if (m_uipOffset != 0)
        {
            UNALIGNED RIFFLIST *pck = (RIFFLIST *) m_uipOffset;
            if ((pck->ckid == LIST_TAG) && 
                (pck->fccType == mmioFOURCC('w','a','v','e')))
            {
                HRESULT hr;
                BYTE *p = (BYTE *) m_uipOffset;
                hr = Load(p + sizeof(RIFFLIST),
                    p + sizeof(RIFF) + pck->cksize, m_bCompress);
                if (!FAILED(hr))
                {
                    return (TRUE);
                }
            }
        }
        if (InterlockedDecrement(&m_lLockCount) < 0)
        {
            InterlockedIncrement(&m_lLockCount);
        }
        return (FALSE);
    }
    return (TRUE);
}

BOOL Wave::UnLock()
{
    LONG   lockCount = InterlockedDecrement(&m_lLockCount);
    if (lockCount < 0)
    {
        lockCount = InterlockedIncrement(&m_lLockCount);
    }
    if (lockCount == 0)
    {
        ASSERT(m_pnWave);
        if (m_pnWave != NULL)
        {
            ExFreePool(m_pnWave);
            m_pnWave = NULL;
        }
    }
    return (TRUE);
}

BOOL Wave::IsLocked()
{
    return (m_lLockCount > 0);
}

void Wave::AddRef()
{
    ASSERT(m_lLockCount  >= 0);

    long   usageCount = InterlockedIncrement(&m_lUsageCount);
}

void Wave::Release()
{
    ASSERT(m_lLockCount  >= 0);

    long usageCount = InterlockedDecrement(&m_lUsageCount);
    if (usageCount == 0)
    {
        while (IsLocked())
        {
            UnLock();
        }
        delete this;
    }
}

static DWORD SwapWord(UINT wData)
{
    char t;
    union {
        char c[2];
        UINT w;
    } sw;
    sw.w = wData;
    t = sw.c[0];
    sw.c[0] = sw.c[1];
    sw.c[1] = t;
    return (sw.w);
}

static DWORD SwapDWord(DWORD dwData)
{
    char t;
    union {
        char c[4];
        DWORD dw;
    } sw;
    sw.dw = dwData;
    t = sw.c[0];
    sw.c[0] = sw.c[3];
    sw.c[3] = t;
    t = sw.c[1];
    sw.c[1] = sw.c[2];
    sw.c[2] = t;
    return (sw.dw);
}

SourceRegion::SourceRegion()
{
    m_pArticulation = NULL;
    m_vrAttenuation = 0;
    m_prTuning = 0;
    m_bKeyHigh = 127;
    m_bKeyLow = 0;
    m_bGroup = 0;
    m_lLockCount = 0;
    m_bAllowOverlap = FALSE;
    m_wEditTag = 0;
}

SourceRegion::~SourceRegion()
{
    if (m_pArticulation)
    {
        m_pArticulation->Release();
    }
}

void SourceRegion::SetSampleRate(DWORD dwSampleRate)
{
    if (m_pArticulation != NULL)
    {
        m_pArticulation->SetSampleRate(dwSampleRate);
    }
}

BOOL SourceRegion::Lock(DWORD dwLowNote,DWORD dwHighNote)
{
    ASSERT(this->m_lLockCount >= 0);

    if (dwHighNote < m_bKeyLow) return (FALSE);
    if (dwLowNote > m_bKeyHigh) return (FALSE);
    if (m_Sample.Lock())
    {
        (void) InterlockedIncrement(&m_lLockCount);
        return (TRUE);
    }
    return (FALSE);
}

BOOL SourceRegion::UnLock(DWORD dwLowNote,DWORD dwHighNote)
{
    if (dwHighNote < m_bKeyLow) return (FALSE);
    if (dwLowNote > m_bKeyHigh) return (FALSE);
    if (m_Sample.UnLock())
    {
        if (InterlockedDecrement(&m_lLockCount) < 0)
        {
            (void) InterlockedIncrement(&m_lLockCount);
        }
        return (TRUE);
    }
    return (FALSE);
}

Instrument::Instrument()
{
    m_dwProgram = 0;
    m_lLockCount = 0;
    m_wEditTag = 0;
}

Instrument::~Instrument()
{
    while (!m_RegionList.IsEmpty())
    {
        SourceRegion *pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }
}

void Instrument::SetSampleRate(DWORD dwSampleRate)
{
    SourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        pRegion->SetSampleRate(dwSampleRate);
    }
}

SourceRegion * Instrument::ScanForRegion(DWORD dwNoteValue)
{
    SourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        if ((dwNoteValue >= pRegion->m_bKeyLow) 
         && (dwNoteValue <= pRegion->m_bKeyHigh))
        {
            if (pRegion->m_lLockCount > 0)
            {
                break;
            }
        }
    }
    return pRegion;
}

BOOL Instrument::Lock(DWORD dwLowNote,DWORD dwHighNote)
{
    ASSERT(this->m_lLockCount >= 0);
    BOOL fLocked = FALSE;
    SourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        fLocked =  pRegion->Lock(dwLowNote,dwHighNote) || fLocked;
    }
    if (fLocked)
    {
        (void) InterlockedIncrement(&m_lLockCount);
    }
    return (fLocked);
}

BOOL Instrument::UnLock(DWORD dwLowNote,DWORD dwHighNote)
{
    BOOL fLocked = FALSE;
    SourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        fLocked = pRegion->UnLock(dwLowNote,dwHighNote) || fLocked;
    }
    if (fLocked)
    {
        ASSERT(m_lLockCount > 0);
        (void) InterlockedDecrement(&m_lLockCount);
    }
    return (fLocked);
}

Collection::Collection()
{
    m_fIsGM = FALSE;
    m_pszName = NULL;
    m_pszFileName = NULL;
    m_lLockCount = 0;
    m_lOpenCount = 0;
    m_lpMapAddress = NULL;
    m_uipWavePool = 0;
    m_wEditTag = 0;
    m_wWavePoolSize = 0;
}

Collection::~Collection()
{
    if (m_pszName != NULL)
    {
        delete m_pszName;
        m_pszName = NULL;
    }
    if (m_pszFileName != NULL)
    {
        delete m_pszFileName;
        m_pszFileName = NULL;
    }
    while (!m_InstrumentList.IsEmpty())
    {
        Instrument *pInstrument = m_InstrumentList.RemoveHead();
        delete pInstrument;
    }
    while (!m_WavePool.IsEmpty()) 
    {
        Wave *pWave = m_WavePool.RemoveHead();

        if (pWave->IsLocked())
        {
            pWave->UnLock();
        }

        pWave->Release();
    }
    Close();
}

void Collection::SetSampleRate(DWORD dwSampleRate)
{
    Instrument *pInstrument = m_InstrumentList.GetHead();
    for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
    {
        pInstrument->SetSampleRate(dwSampleRate);
    }
}

BOOL Collection::Lock(DWORD dwProgram,DWORD dwLowNote,DWORD dwHighNote)
{
    ASSERT(this->m_lLockCount >= 0);

    Instrument *pInstrument = m_InstrumentList.GetHead();
    for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram)
        {
            if (pInstrument->Lock(dwLowNote,dwHighNote))
            {
                (void) InterlockedIncrement(&m_lLockCount);
                return (TRUE);
            }
            return (FALSE);
        }
    }
    if (dwProgram < 128)
    {
        dwProgram &= 0xF8;
    // Second pass to find an instrument within GM range (GM only).
        for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
        {
            if ((pInstrument->m_dwProgram & 0xF8) == dwProgram)
            {
                if (pInstrument->Lock(dwLowNote,dwHighNote))
                {
                    (void) InterlockedIncrement(&m_lLockCount);
                    return (TRUE);
                }
                return (FALSE);
            }
        }
    }
    return (FALSE);
}


BOOL Collection::UnLock(DWORD dwProgram,DWORD dwLowNote,DWORD dwHighNote)
{
    Instrument *pInstrument = m_InstrumentList.GetHead();
    for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram)
        {
            if (pInstrument->UnLock(dwLowNote,dwHighNote))
            {
                ASSERT(m_lLockCount > 0);
                (void) InterlockedDecrement(&m_lLockCount);
                return (TRUE);
            }
            return (FALSE);
        }
    }
    return (FALSE);
}

LockRange::LockRange()
{
    m_dwHighNote = 127;
    m_dwLowNote = 0;
    m_dwProgram = 0;
    m_pCollection = NULL;
}

Instrument * Collection::GetInstrument(DWORD dwProgram, DWORD dwKey)
{
    Instrument *pInstrument = m_InstrumentList.GetHead();
    for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram) 
        {
            if (pInstrument->m_lLockCount > 0)
            {
                if (dwKey == RANGE_ALL)
                {
                    break;
                }
                if (pInstrument->ScanForRegion(dwKey) != NULL)
                {
                    break;
                }
            }
        }
    }
    return (pInstrument);
}


void Collection::RemoveDuplicateInstrument(DWORD dwProgram)
{
    Instrument *pInstrument = m_InstrumentList.GetHead();
    for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram) 
        {
            m_InstrumentList.Remove(pInstrument);
            delete pInstrument;
            break;
        }
    }
}

void InstManager::SetSampleRate(DWORD dwSampleRate)
{
    m_dwSampleRate = dwSampleRate;

    Collection *pCollection = m_CollectionList.GetHead();
    for (;pCollection != NULL; pCollection = pCollection->GetNext())
    {
        pCollection->SetSampleRate(dwSampleRate);
    }
}

HRESULT InstManager::SetGMLoad(BOOL fLoadGM)
{
    HRESULT hr = S_OK;

    if (m_fLoadGM != fLoadGM)
    {
        DWORD dwIndex;
        if (fLoadGM)    //  Load it
        {
            hr = LoadCollection(&m_hGMCollection,STR_DLS_DEFAULT,TRUE);
            if (hr == S_OK)
            {
                m_GMNew[0].m_dwProgram = AA_FINST_DRUM;
                m_GMNew[0].m_hLock = Lock(m_hGMCollection,AA_FINST_DRUM,0,127);
                DWORD defaultProgram = 0;
                for (dwIndex = 1;dwIndex < 16;dwIndex++)
                {
                    m_GMNew[dwIndex].m_dwProgram = defaultProgram;
                    m_GMNew[dwIndex].m_hLock = Lock(m_hGMCollection,defaultProgram,0,127);
                }
                m_fLoadGM = TRUE;
            }
        }
        else            //  Unload it
        {
            for (dwIndex = 0;dwIndex < 16;dwIndex++)
            {
                if (m_GMNew[dwIndex].m_hLock != NULL)
                {
                    UnLock(m_GMNew[dwIndex].m_hLock);
                    m_GMNew[dwIndex].m_hLock = NULL;
                }
                m_GMNew[dwIndex].m_dwProgram = AA_FINST_EMPTY;
                if (m_GMOld[dwIndex].m_hLock != NULL)
                {
                    UnLock(m_GMOld[dwIndex].m_hLock);
                    m_GMOld[dwIndex].m_hLock = NULL;
                }
                m_GMOld[dwIndex].m_dwProgram = AA_FINST_EMPTY;
            }
            if (m_hGMCollection != NULL)
            {
                ReleaseCollection(m_hGMCollection);
                m_hGMCollection = NULL;
            }
            m_fLoadGM = FALSE;
        }
    }
    return (hr);
}   

InstManager::InstManager()
{
    int nI; 
    for (nI = 0;nI < 16; nI++)
    {
        m_GMNew[nI].m_hLock = NULL;
        m_GMNew[nI].m_dwProgram = AA_FINST_EMPTY;
        m_GMOld[nI].m_hLock = NULL;
        m_GMOld[nI].m_dwProgram = AA_FINST_EMPTY;
    }
    m_hGMCollection = NULL;
    m_fLoadGM = FALSE;
    m_dwCompress = COMPRESS_OFF;
    m_dwSampleRate = 22050;
    m_pszFileName = NULL;

    // None of these will cause a "real" failure.
    // if an error occurs, the m_pszFileName will remain NULL and the 
    // default file name will be used.
    WCHAR achBuffer[MAX_PATH];

    HRESULT hr = GetRegDlsFileName(
              STR_DLS_REGISTRY_KEY,
              STR_DLS_REGISTRY_NAME,
              achBuffer,
              MAX_PATH * sizeof(WCHAR));
    if (hr == S_OK)
    {
        // we need to convert the filename to device name.
        m_pszFileName = new WCHAR[wcslen(achBuffer) + wcslen(L"\\DosDevices\\") + 1];
        if (m_pszFileName)
        {
            wcscpy(m_pszFileName, L"\\DosDevices\\");
            wcscat(m_pszFileName,achBuffer);
        }
    }
}

InstManager::~InstManager()
{
    if (m_pszFileName)
    {
        delete m_pszFileName;
    }
    SetGMLoad(FALSE);

    while (!m_CollectionList.IsEmpty())
    {
        Collection *pCollection = m_CollectionList.RemoveHead();
        delete pCollection;
    }
}

HANDLE InstManager::Lock(HANDLE hCollection, DWORD dwProgram, DWORD dwLowNote,DWORD dwHighNote)
{
    Collection *pCollection = m_CollectionList.GetHead();
    for (;pCollection != NULL;pCollection = pCollection->GetNext())
    {
        if (hCollection == (HANDLE) pCollection)
        {
            break;
        }
    }
    if (pCollection != NULL)
    {
        if (pCollection->Lock(dwProgram,dwLowNote,dwHighNote))
        {
            LockRange *pLock = new LockRange;
            if (pLock != NULL)
            {
                pLock->m_dwProgram = dwProgram;
                pLock->m_pCollection = pCollection;
                pLock->m_dwLowNote = dwLowNote;
                pLock->m_dwHighNote = dwHighNote;
                pLock->m_fLoaded = TRUE;
                m_LockList.AddHead(pLock);
            }
            return ((HANDLE) pLock);
        }
    }
    return (NULL);
}

HRESULT InstManager::UnLock(HANDLE hLock)
{
    LockRange *pLock = (LockRange *) hLock;
    HRESULT hr = E_HANDLE;

    if (m_LockList.IsMember(pLock))
    {
        if (m_CollectionList.IsMember(pLock->m_pCollection))
        {
            if (pLock->m_pCollection->UnLock(pLock->m_dwProgram,pLock->m_dwLowNote,pLock->m_dwHighNote))
            {
                hr = S_OK;
            }
        }
        m_LockList.Remove(pLock);
        delete pLock;
    }
    return (hr);
}

Instrument * InstManager::GetInstrument(DWORD dwProgram, 
                                        DWORD dwKey)
{
    Collection *pCollection;
    Instrument *pInstrument = NULL;

    pCollection = m_CollectionList.GetHead();
    for (;pCollection != NULL; pCollection = pCollection->GetNext())
    {
        pInstrument = pCollection->GetInstrument(dwProgram,dwKey);
        if (pInstrument != NULL)
        {
            break;
        }
    }
    return (pInstrument);
}

BOOLEAN InstManager::RequestGMInstrument(DWORD dwChannel, DWORD dwPatch)
{
    BOOLEAN fResult = FALSE;
    
    _DbgPrintF(DEBUGLVL_BLAB, ("InstManager::RequestGMInstrument - %d %d", dwChannel, dwPatch));
    
    if (m_GMNew[dwChannel].m_dwProgram == dwPatch)
    {
        //  we are already loaded
        return TRUE;
    }
    if (m_fLoadGM)
    {
        fResult = LoadGMInstrument(dwChannel, dwPatch);
    }

    return fResult;
}

BOOLEAN InstManager::LoadGMInstrument(DWORD dwChannel, DWORD dwPatch)
{
    BOOLEAN fResult = FALSE;
    
    if (m_hGMCollection != NULL)
    {
        HANDLE hLock = Lock(m_hGMCollection,dwPatch,0,127);
        if (hLock != NULL)
        {
            if (m_GMOld[dwChannel].m_hLock != NULL)
            {
                UnLock(m_GMOld[dwChannel].m_hLock);
            }
            m_GMOld[dwChannel] = m_GMNew[dwChannel];
            m_GMNew[dwChannel].m_hLock = hLock;
            m_GMNew[dwChannel].m_dwProgram = dwPatch;

            fResult = TRUE;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("InstManager::LoadGMInstrument - Unable to load %d %d", dwChannel, dwPatch));
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\filter.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   filter.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
extern NTSTATUS
FilterTopologyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
);

static const WCHAR PinTypeName[] = KSSTRING_Pin ;

DEFINE_KSCREATE_DISPATCH_TABLE(FilterCreateHandlers)
{
    DEFINE_KSCREATE_ITEM(PinDispatchCreate, PinTypeName, 0)
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

KSDISPATCH_TABLE FilterDispatchTable =
{
    FilterDispatchIoControl,
    NULL,
    FilterDispatchWrite,
    NULL,
    FilterDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

DEFINE_KSPROPERTY_PINSET(
    FilterPropertyHandlers,
    FilterPinPropertyHandler,
    FilterPinInstances,
    FilterPinIntersection
) ;

// DJS 5/5/97 {
DEFINE_KSPROPERTY_TOPOLOGYSET(
        TopologyPropertyHandlers,
        FilterTopologyHandler
);
// DJS 5/5/97 }

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySet)
{
    DEFINE_KSPROPERTY_SET(
       // &__uuidof(struct KSPROPSETID_Pin),           // Set
       &KSPROPSETID_Pin,           // Set
       SIZEOF_ARRAY( FilterPropertyHandlers ),      // PropertiesCount
       FilterPropertyHandlers,              // PropertyItem
       0,                       // FastIoCount
       NULL                     // FastIoTable
    ),
    // DJS 5/6/97 {
   DEFINE_KSPROPERTY_SET(
       // &__uuidof(struct KSPROPSETID_Topology),          // Set
       &KSPROPSETID_Topology,          // Set
       SIZEOF_ARRAY(TopologyPropertyHandlers),          // PropertiesCount
       TopologyPropertyHandlers,                        // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    )
    // DJS 5/6/97 }
} ;

KSPIN_INTERFACE PinInterfaces[] =
{
    {
    STATICGUIDOF(KSINTERFACESETID_Media),
    KSINTERFACE_MEDIA_MUSIC
    },
    {
    STATICGUIDOF(KSINTERFACESETID_Standard),
    KSINTERFACE_STANDARD_STREAMING
    }
} ;

KSPIN_MEDIUM PinMediums[] =
{
    {
    STATICGUIDOF(KSMEDIUMSETID_Standard),
    KSMEDIUM_STANDARD_DEVIO
    }
} ;

KSDATARANGE_MUSIC PinMIDIFormats[] =
{
   {
      {
         sizeof( KSDATARANGE_MUSIC ),
         0,
         0,
         0,
         STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
         STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
         STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE),
      },
      STATICGUIDOF(KSMUSIC_TECHNOLOGY_SWSYNTH),
      MAX_NUM_VOICES,
      MAX_NUM_VOICES,
      0xffffffff
   }
} ;

KSDATARANGE_AUDIO PinDigitalAudioFormats[] =
{
   {
      {
     sizeof( KSDATARANGE_AUDIO ),
     0,
         0,
         0,
     STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
     STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
     STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
      },
      2,
      16,
      16,
      22050,
      22050
   }
} ;

PKSDATARANGE PinDataFormats[] =
{
    (PKSDATARANGE)&PinMIDIFormats[ 0 ],
    (PKSDATARANGE)&PinDigitalAudioFormats[ 0 ]
} ;

KSPIN_DESCRIPTOR PinDescs[MAX_NUM_PIN_TYPES] =
{
    // PIN_ID_MIDI_SINK
    DEFINE_KSPIN_DESCRIPTOR_ITEMEX (
    2,              // number of interfaces
    &PinInterfaces[ 0 ],
    1,              // number of mediums
    PinMediums,
    1,              // number of data formats
    &PinDataFormats[ 0 ],
    KSPIN_DATAFLOW_IN,
    KSPIN_COMMUNICATION_SINK,
    &KSCATEGORY_WDMAUD_USE_PIN_NAME,
    &KSNODETYPE_SWMIDI
    ),
    // PIN_ID_PCM_SOURCE
    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    1,              // number of interfaces
    &PinInterfaces[ 1 ],
    1,              // number of mediums
    PinMediums,
    1,              // number of data formats
    &PinDataFormats[ 1 ],
    KSPIN_DATAFLOW_OUT,
    KSPIN_COMMUNICATION_SOURCE
    )
} ;

const KSPIN_CINSTANCES gcPinInstances[MAX_NUM_PIN_TYPES] =
{
    {       // PIN_ID_MIDI_SINK
    1,      // cPossible
    0       // cCurrent
    },
    {       // PIN_ID_PCM_SOURCE
    1,      // cPossible
    0       // cCurrent
    }
} ;

KMUTEX  gMutex;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
FilterDispatchCreate(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;
    _DbgPrintF( DEBUGLVL_TERSE, ("FilterDispatchCreate"));
    NTSTATUS            Status ;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    Status =
        KsReferenceSoftwareBusObject(
         ((PDEVICE_INSTANCE)pdo->DeviceExtension)->pDeviceHeader );

    if (!NT_SUCCESS( Status )) 
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return Status;
    }

    pFilterInstance = (PFILTER_INSTANCE)
        ExAllocatePoolWithTag(NonPagedPool,sizeof(FILTER_INSTANCE),'iMwS'); //  SwMi

    if (pFilterInstance == NULL) 
    {
        KsDereferenceSoftwareBusObject(
             ((PDEVICE_INSTANCE)pdo->DeviceExtension)->pDeviceHeader );
        pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = KsAllocateObjectHeader(&pFilterInstance->ObjectHeader,
                                    SIZEOF_ARRAY(FilterCreateHandlers),
                                    FilterCreateHandlers,
                                    pIrp,
                                    (PKSDISPATCH_TABLE)&FilterDispatchTable);
    if (!NT_SUCCESS(Status))
    {
        ExFreePool(pFilterInstance);
        KsDereferenceSoftwareBusObject(
             ((PDEVICE_INSTANCE)pdo->DeviceExtension)->pDeviceHeader );
        pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize midi event pool.
    // This could be moved to DriverEntry for perf improvement.
    if (!MIDIRecorder::InitEventList())
    {
        _DbgPrintF( DEBUGLVL_TERSE, ("[MidiData pool allocation failed!!]"));        
        KsFreeObjectHeader ( pFilterInstance->ObjectHeader );
        ExFreePool(pFilterInstance);
        KsDereferenceSoftwareBusObject(
             ((PDEVICE_INSTANCE)pdo->DeviceExtension)->pDeviceHeader );
        pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pIrpStack->FileObject->FsContext = pFilterInstance; // pointer to instance

    RtlCopyMemory(pFilterInstance->cPinInstances,
                  gcPinInstances,
                  sizeof(gcPinInstances));
    RtlZeroMemory(pFilterInstance->aWriteContext, 
                  sizeof(pFilterInstance->aWriteContext));

    pFilterInstance->DeviceState = KSSTATE_STOP;
    pFilterInstance->bRunningStatus = 0;
    pFilterInstance->pSynthesizer = NULL;
    pFilterInstance->cConsecutiveErrors= 0;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
FilterDispatchClose(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    _DbgPrintF( DEBUGLVL_TERSE, ("FilterDispatchClose"));

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;

    if (pFilterInstance->DeviceState != KSSTATE_STOP)
    {
        SetDeviceState(pFilterInstance, KSSTATE_STOP);
    }
    if (pFilterInstance->pSynthesizer != NULL) 
    {
        delete pFilterInstance->pSynthesizer;
        pFilterInstance->pSynthesizer = NULL;
    }

    MIDIRecorder::DestroyEventList();

    KsDereferenceSoftwareBusObject(
         ((PDEVICE_INSTANCE)pdo->DeviceExtension)->pDeviceHeader );

    KsFreeObjectHeader ( pFilterInstance->ObjectHeader );

    //  We MUST ensure that all IRPs have completed by this time -- the 
    //  filterinstance contains the IOSBs used by the completion routines
    ExFreePool( pFilterInstance );
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
FilterDispatchWrite(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
)
{
    return KsDispatchInvalidDeviceRequest(pdo,pIrp);
}

NTSTATUS
FilterDispatchIoControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
)
{
    NTSTATUS                     Status;
    PIO_STACK_LOCATION           pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler( pIrp,
             SIZEOF_ARRAY(FilterPropertySet),
            (PKSPROPERTY_SET) FilterPropertySet );
        break;
    
    default:
        return KsDefaultDeviceIoCompletion(pDeviceObject, pIrp);
    }
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return Status;
}

NTSTATUS
FilterPinPropertyHandler(
    IN PIRP     pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PVOID    pvData
)
{
    return KsPinPropertyHandler(
      pIrp,
      pProperty,
      pvData,
      SIZEOF_ARRAY( PinDescs ),
      PinDescs);
}

NTSTATUS
FilterPinInstances(
    IN PIRP                 pIrp,
    IN PKSP_PIN             pPin,
    OUT PKSPIN_CINSTANCES   pCInstances
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = (PFILTER_INSTANCE) pIrpStack->FileObject->FsContext;
    *pCInstances = pFilterInstance->cPinInstances[ pPin->PinId ];
    pIrp->IoStatus.Information = sizeof( KSPIN_CINSTANCES );
    return STATUS_SUCCESS;

}

VOID
WaveFormatFromAudioRange (
    PKSDATARANGE_AUDIO  pDataRangeAudio,
    WAVEFORMATEX *      pWavFormatEx)
{
    if(IS_VALID_WAVEFORMATEX_GUID(&pDataRangeAudio->DataRange.SubFormat)) {
        pWavFormatEx->wFormatTag =
          EXTRACT_WAVEFORMATEX_ID(&pDataRangeAudio->DataRange.SubFormat);
    }
    else {
        pWavFormatEx->wFormatTag = WAVE_FORMAT_UNKNOWN;
    }
    pWavFormatEx->nChannels = (WORD)pDataRangeAudio->MaximumChannels;
    pWavFormatEx->nSamplesPerSec = pDataRangeAudio->MaximumSampleFrequency;
    pWavFormatEx->wBitsPerSample = (WORD)pDataRangeAudio->MaximumBitsPerSample;
    pWavFormatEx->nBlockAlign =
      (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
    pWavFormatEx->nAvgBytesPerSec =
      pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
    pWavFormatEx->cbSize = 0;
}

BOOL
DataIntersectionAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio1,
    PKSDATARANGE_AUDIO pDataRangeAudio2,
    PKSDATARANGE_AUDIO pDataRangeAudioIntersection
)
{
    if(pDataRangeAudio1->MaximumChannels <
       pDataRangeAudio2->MaximumChannels) {
        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio1->MaximumChannels;
    }
    else {
        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio2->MaximumChannels;
    }

    if(pDataRangeAudio1->MaximumSampleFrequency <
       pDataRangeAudio2->MaximumSampleFrequency) {
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio1->MaximumSampleFrequency;
    }
    else {
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio2->MaximumSampleFrequency;
    }
    if(pDataRangeAudio1->MinimumSampleFrequency >
       pDataRangeAudio2->MinimumSampleFrequency) {
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio1->MinimumSampleFrequency;
    }
    else {
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio2->MinimumSampleFrequency;
    }
    if(pDataRangeAudioIntersection->MaximumSampleFrequency <
       pDataRangeAudioIntersection->MinimumSampleFrequency ) {
        return(FALSE);
    }

    if(pDataRangeAudio1->MaximumBitsPerSample <
       pDataRangeAudio2->MaximumBitsPerSample) {
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio1->MaximumBitsPerSample;
    }
    else {
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio2->MaximumBitsPerSample;
    }
    if(pDataRangeAudio1->MinimumBitsPerSample >
       pDataRangeAudio2->MinimumBitsPerSample) {
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio1->MinimumBitsPerSample;
    }
    else {
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio2->MinimumBitsPerSample;
    }
    if(pDataRangeAudioIntersection->MaximumBitsPerSample <
       pDataRangeAudioIntersection->MinimumBitsPerSample ) {
        return(FALSE);
    }
    return(TRUE);
}

BOOL DataIntersectionRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2,
    PKSDATARANGE pDataRangeIntersection
)
{
    // Pick up pDataRange1 values by default.
    *pDataRangeIntersection = *pDataRange1;

    if(IsEqualGUID(pDataRange1->MajorFormat, pDataRange2->MajorFormat) ||
       IsEqualGUID(pDataRange1->MajorFormat, KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->MajorFormat = pDataRange2->MajorFormat;
    }
    else if(!IsEqualGUID(
      pDataRange2->MajorFormat,
      KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(pDataRange1->SubFormat, pDataRange2->SubFormat) ||
       IsEqualGUID(pDataRange1->SubFormat, KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->SubFormat = pDataRange2->SubFormat;
    }
    else if(!IsEqualGUID(
      pDataRange2->SubFormat,
      KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(pDataRange1->Specifier, pDataRange2->Specifier) ||
       IsEqualGUID(pDataRange1->Specifier, KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->Specifier = pDataRange2->Specifier;
    }
    else if(!IsEqualGUID(
      pDataRange2->Specifier,
      KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    pDataRangeIntersection->Reserved = 0; // Must be zero
    return(TRUE);
}

NTSTATUS
DefaultIntersectHandler(
    IN PKSDATARANGE     DataRange,
    IN PKSDATARANGE     pDataRangePin,
    IN ULONG            OutputBufferLength,
    OUT PVOID           Data,
    OUT PULONG          pDataLength
    )
{
    KSDATARANGE_AUDIO   DataRangeAudioIntersection;
    ULONG               ExpectedBufferLength;
    PWAVEFORMATEX       pWaveFormatEx;
    BOOL                bDSoundFormat = FALSE;

    // Check for generic match on the specific ranges, allowing wildcards.

    if (!DataIntersectionRange(pDataRangePin,
                               DataRange,
                               &DataRangeAudioIntersection.DataRange)) {
        return STATUS_NO_MATCH;
    }

    // Check for format matches that the default handler can deal with.
    if (IsEqualGUID(
       pDataRangePin->Specifier,
       KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)Data)->WaveFormatEx);
        ExpectedBufferLength = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    }
    else {
        return STATUS_NO_MATCH;
    }

    // GUIDs match, so check for valid intersection of audio ranges.
    if (!DataIntersectionAudio((PKSDATARANGE_AUDIO)pDataRangePin,
                               (PKSDATARANGE_AUDIO)DataRange,
                               &DataRangeAudioIntersection)) {
        return STATUS_NO_MATCH;
    }

    // Have a match!
    // Determine whether the data format itself is to be returned, or just
    // the size of the data format so that the client can allocate memory
    // for the full range.

    if (!OutputBufferLength) {
        *pDataLength = ExpectedBufferLength;
        return STATUS_BUFFER_OVERFLOW;
    } else if (OutputBufferLength < ExpectedBufferLength) {
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        // Get WAV format from intersected and limited maximums.
        WaveFormatFromAudioRange(&DataRangeAudioIntersection, pWaveFormatEx);

        // Copy across DATARANGE/DATAFORMAT_x part of match, and adjust fields.
        *(PKSDATARANGE)Data = DataRangeAudioIntersection.DataRange;
        ((PKSDATAFORMAT)Data)->FormatSize = ExpectedBufferLength;

        *pDataLength = ExpectedBufferLength;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
IntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
    )
/*++

Routine Description:

    This is the data range callback for KsPinDataIntersection, which is called by
    FilterPinIntersection to enumerate the given list of data ranges, looking for
    an acceptable match. If a data range is acceptable, a data format is copied
    into the return buffer. A STATUS_NO_MATCH continues the enumeration.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
        This enumeration callback does not need to look at any of this though. It need
        only look at the specific pin identifier.

    DataRange -
        Contains a specific data range to validate.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    NTSTATUS            Status = STATUS_NO_MATCH;
    ULONG               OutputBufferLength;
    PKSDATARANGE        pDataRangePin;
    UINT                i;
    ULONG               DataLength = 0;

    // The underlying pin does not support data intersection.
    // Do the data intersection on its behalf for the pin formats that SYSAUDIO understands.
    //
    // All the major/sub/specifier checking has been done by the handler, but may include wildcards.
    //
    pIrpStack = IoGetCurrentIrpStackLocation( Irp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    OutputBufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;
    for (i = 0; i < PinDescs[Pin->PinId].DataRangesCount; i++) {
        pDataRangePin = PinDescs[Pin->PinId].DataRanges[i];
        Status = DefaultIntersectHandler (DataRange,
                                          pDataRangePin,
                                          OutputBufferLength,
                                          Data,
                                          &DataLength);
        if(Status == STATUS_NO_MATCH) {
            continue;
        }
        Irp->IoStatus.Information = DataLength;
        break;
    }
    return Status;
}

NTSTATUS
FilterPinIntersection(
    IN PIRP     pIrp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
    Returns the first acceptable data format given a list of data ranges for a specified
    Pin factory. Actually just calls the Intersection Enumeration helper, which then
    calls the IntersectHandler callback with each data range.

Arguments:

    pIrp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    if (Pin->PinId != PIN_ID_PCM_SOURCE) {
        return (STATUS_INVALID_DEVICE_REQUEST);
    }
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    return KsPinDataIntersection(
        pIrp,
        Pin,
        Data,
        MAX_NUM_PIN_TYPES, //cPins,
        PinDescs,
        IntersectHandler);
}

//---------------------------------------------------------------------------
//  End of File: filter.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\mmx.cpp ===
//      MMX.cpp
//      Copyright (c) Intel Corporation 1996
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//      MMX Mix engines for SWMIDI

/*      Most of the mix engines have been converted into assembler
        via .asm output from the 4.2 release compiler. I did
        this because the 5.0 backend turns off optimization when
        it encounters _asm statements, so it generates worse code.
        However, the original code is still intact within the 
        ! _X86_ versions, and can be used to generate new assembler,
        should that be needed at a later date.
*/

/*
Variable useage.

        Variable                                    register 
        pfSamplePos                                 eax
        pfPitch                                     ebx
        dwI                                         ecx
        dwIncDelta                                  edx (edx is sometimes a temporary register)
        dwPosition1                                 esi
        dwPostiion2                                 edi

        vfRvolume and vfLvolume                     mm0     
        vfRVolume, vfLVolume                        mm2     

        mm4 - mm7 are temporary mmx registers.
*/

// Notes about calculation.

        // Loop is unrolled once.
        // *1  shifting volumne to 15 bit values to get rid of shifts and simplify code.
        // This make the packed mulitply work better later since I keep the sound interpolated
        // wave value at 16 bit signed value.  For a PMULHW, this results in 15 bit results
        // which is the same as the original code.


        // *2 linear interpolation can be done very quickly with MMX by re-arranging the
        // way that the interpolation is done. Here is code in C that shows the difference.
        // Original C code      
        //lM1 = ((pcWave[dwPosition1 + 1] - pcWave[dwPosition1]) * dwFract1) >> 12;
        //lM2 = ((pcWave[dwPosition2 + 1] - pcWave[dwPosition2]) * dwFract2) >> 12;
        //lM1 += pcWave[dwPosition1];
        //lM2 += pcWave[dwPosition2];

        // Equivalent C Code that can be done with a pmadd
        //lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;
        //lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;


#include "common.h"

typedef unsigned __int64 QWORD;

DWORD DigitalAudio::MixMono8X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;    
    
    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    char * pcWave = (char *)m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


    QWORD   dwFractMASK =   0x000000000FFF0FFF;
    QWORD   dwFractOne  =   0x0000000010001000; 
    QWORD   wordmask    =   0x0000FFFF0000FFFF;
    QWORD   vfDeltaLandRVolume;

_asm{
                
    // vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;   
    
    movd    mm0, vfVolume
    movd    mm7, vfVolume

    // vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
    movd    mm1, vfDeltaVolume
    movd    mm6, vfDeltaVolume

  punpckldq mm1, mm6
    
    // dwI = 0
    mov     ecx, 0
    movq    vfDeltaLandRVolume, mm1


    movq    mm1, dwFractOne
    movq    mm4, dwFractMASK
    
    mov     eax, pfSamplePos


  punpckldq mm0, mm7
    mov     ebx, pfPitch

    pslld   mm0, 8
    mov     edx, dwIncDelta

    movq    mm2, mm0        // vfLVolume and vfRVolume in mm2
                            // need to be set before first pass.
    
    // *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
    psrld   mm2, 5  
    
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
    cmp     ecx, dwLength
    jae     done

        
        
        cmp     eax, pfSampleLength //if (pfSamplePos >= pfSampleLength)
        jb      NotPastEndOfSample1 //{ 
                        
        cmp     pfLoopLength, 0     //if (!pfLoopLength)
            
        je      done                // break;
            
        sub     eax, pfLoopLength   // else pfSamplePos -= pfLoopLength;
    
NotPastEndOfSample1:                //}
                    
        mov     esi, eax            // dwPosition1 = pfSamplePos;
        add     eax, ebx            // pfSamplePos += pfPitch;      
                
        sub     edx, 2              // dwIncDelta-=2;                                       
        jnz     DontIncreaseValues1 //if (!dwIncDelta) {

            // Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
            // for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
            // if it goes below zero.
                        
            paddd   mm0, vfDeltaLandRVolume // vfVFract += vfDeltaVolume;
                                            // vfVFract += vfDeltaVolume;
            pxor    mm5, mm5                // TestLVol = 0; TestRVol = 0;

            
            mov     edx, pfPFract           // Temp = pfPFract;
            pcmpgtd mm5, mm0            // if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
                                        // if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

            add     edx, pfDeltaPitch   // Temp += pfDeltaPitch;
            pandn   mm5, mm0            // TestLVol = vfLVFract & (~TestLVol);
                                        // TestRVol = vfRVFract & (~TestRVol);

            mov     pfPFract, edx       // pfPFract = Temp;
            movq    mm2, mm5            // vfLVolume = TestLVol;
                                        // vfRVolume = TestRVol;
            

            shr     edx, 8              // Temp = Temp >> 8;
            psrld   mm2, 5              // vfLVolume = vfLVolume >> 5;
                                        // vfRVolume = vfRVolume >> 5;                      
            
            mov     ebx, edx            // pfPitch = Temp;
            mov     edx, dwDeltaPeriod  //dwIncDelta = dwDeltaPeriod;           
            
        //}
DontIncreaseValues1:

        movd    mm6, esi            // dwFract1 = dwPosition1;
        movq    mm5, mm1            // words in mm5 = 0, 0, 0x1000, 0x1000      
        
        shr     esi, 12             // dwPosition1 = dwPosition1 >> 12;     
        inc     ecx                 //dwI++;
                        
        // if (dwI < dwLength) break;                      
        cmp     ecx, dwLength
        jae     StoreOne
        
        //if (pfSamplePos >= pfSampleLength)
        //{ 
        cmp     eax, pfSampleLength
        jb      NotPastEndOfSample2

            // Original if in C was not negated
            //if (!pfLoopLength)            
            cmp     pfLoopLength, 0
            //break;            
            je      StoreOne
            //else
            //pfSamplePos -= pfLoopLength;
            sub     eax, pfLoopLength
        //}
NotPastEndOfSample2:

        //shl       esi, 1          // do not shift left since pcWave is array of chars
        mov     edi, eax        // dwPosition2 = pfSamplePos;

        add     esi, pcWave     // Put address of pcWave[dwPosition1] in esi            
        movd    mm7, eax        // dwFract2 = pfSamplePos;

        shr     edi, 12         // dwPosition2 = dwPosition2 >> 12;
    punpcklwd   mm6, mm7        // combine dwFract Values. Words in mm6 after unpack are
                                // 0, 0, dwFract2, dwFract1
                                
        pand    mm6, mm4        // dwFract2 &= 0xfff; dwFract1 &= 0xfff;
        
        movzx   esi, word ptr[esi]  //lLM1 = pcWave[dwPosition1];
        movd    mm3, esi

        psubw   mm5, mm6        // 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

        //shl       edi, 1          //do not shift left since pcWave is array of chars
    punpcklwd   mm5, mm6        // dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
                                
        add     edi, pcWave     // Put address of pcWave[dwPosition2] in edi
        mov     esi, ecx        // Temp = dWI;
                                                                                                                
        shl     esi, 1          // Temp = Temp << 1;
        
        movzx   edi, word ptr[edi]  //lLM2 = pcWave[dwPoisition2];
        movd    mm6, edi

        pxor    mm7, mm7        // zero out mm7 to make 8 bit into 16 bit
                    
                                // low 4 bytes in mm3
        punpcklwd   mm3, mm6    // pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1]                                           
        
        add     esi, pBuffer    //
    punpcklbw   mm7, mm3        // low four bytes bytes in 
                                // pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
                                                
        pmaddwd mm7, mm5        // high dword = lM2 =
                                //(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
                                // low dword = lM1 =
                                //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))      

        movq    mm3, mm2        // put left and right volume levels in mm3
        add     eax, ebx        //pfSamplePos += pfPitch;

        packssdw    mm3, mm2        // words in mm7
                                // vfVolume, vfVolume, vfVolume, vfVolume
                                    
        movd    mm5, dword ptr[esi-2]   // Load values from buffer
        inc     ecx             // dwI++;
                        
        psrad   mm7, 12         // shift back down to 16 bits.

    packssdw    mm7, mm4        // only need one word in mono case.
                                // low word are lm2 and lm1
                                                
        // above multiplies and shifts are all done with this one pmul. Low two word are only
        // interest in mono case
        pmulhw      mm3, mm7    // lLM1 *= vfVolume;                                
                                // lLM2 *= vfVolume;
                                
                                
        paddsw  mm5, mm3                // Add values to buffer with saturation
        movd    dword ptr[esi-2], mm5   // Store values back into buffer.
                                
    // }
    jmp     mainloop

    // Need to write only one.
    //if (dwI < dwLength)
    //{
StoreOne:       
#if 1
        // Linearly interpolate between points and store only one value.
        // combine dwFract Values.
    
        // Make mm7 zero for unpacking

        //shl       esi, 1              // do not shift left since pcWave is array of chars
        add     esi, pcWave         // Put address of pcWave[dwPosition1] in esi
        pxor    mm7, mm7
                
        //lLM1 = pcWave[dwPosition1];
        movzx   esi, word ptr[esi]
        
        // Doing AND that was not done for dwFract1 and dwFract2
        pand    mm6, mm4

                                // words in MMX register after operation is complete.       
        psubw   mm5, mm6        // 0, 0, 0x1000 - 0, 0x1000 - dwFract1
    punpcklwd   mm5, mm6        // 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
                
        // put values of pcWave into MMX registers.  They are read into a regular register so
        // that the routine does not read past the end of the buffer otherwise, it could read
        // directly into the MMX registers.

                                // words in MMX registers
        pxor    mm7, mm7
                                // low four bytes
        movd    mm4, esi        // 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

                                // 8 bytes after unpakc
        punpcklbw   mm7, mm4    // 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
                
        // *2 pmadd efficent code.
        //lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
        //lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

        pmaddwd     mm7, mm5// low dword = lM1 =
                            //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
        
        psrad       mm7, 12         // shift back down to 16 bits
                
        movq        mm5, mm2    // move volume into mm5
/*      
        // Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

        // Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
        // above multiplies and shifts are all done with this one pmul
        pmulhw      mm5, mm7
        
        // calculate buffer location.
        mov     edi, ecx
        shl     edi, 1
        add     edi, pBuffer

        movd    edx, mm5

        //pBuffer[dwI+1] += (short) lM1;
        add     word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
        mov     word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
        mov     word ptr[edi-2], 0x8000
no_oflowr1:     
    //}
#endif 
done:

    mov     edx, this                       // get address of class object

    //m_vfLastLVolume = vfVolume;
    //m_vfLastRVolume = vfVolume;
    // need to shift volume back down to 12 bits before storing
    psrld   mm2, 3
    movd    [edx]this.m_vfLastLVolume, mm2  
    movd    [edx]this.m_vfLastRVolume, mm2
    
    //m_pfLastPitch = pfPitch;
    mov     [edx]this.m_pfLastPitch, ebx
        
    //m_pfLastSample = pfSamplePos;
    mov     [edx]this.m_pfLastSample, eax
        
    // put value back into dwI to be returned. This could just be passed back in eax I think.   
    mov     dwI, ecx
    emms    
} // ASM block
    return (dwI);
}


DWORD DigitalAudio::Mix8X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
    //long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;

    VFRACT vfLVolume2 = m_vfLastLVolume;
    VFRACT vfRVolume2 = m_vfLastRVolume;

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    dwLength <<= 1;

    QWORD   dwFractMASK =   0x000000000FFF0FFF;
    QWORD   dwFractOne  =   0x0000000010001000; 
    QWORD   wordmask    =   0x0000FFFF0000FFFF;
    QWORD   vfDeltaLandRVolume;

_asm{
                
    // vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;   
    
    movd    mm0, vfLVolume
    movd    mm7, vfRVolume

    // vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
    movd    mm1, vfDeltaLVolume
    movd    mm6, vfDeltaRVolume

  punpckldq mm1, mm6
    
    // dwI = 0
    mov     ecx, 0
    movq    vfDeltaLandRVolume, mm1


    movq    mm1, dwFractOne
    movq    mm4, dwFractMASK
    
    mov     eax, pfSamplePos


  punpckldq mm0, mm7
    mov     ebx, pfPitch

    pslld   mm0, 8
    mov     edx, dwIncDelta

    movq    mm2, mm0        // vfLVolume and vfRVolume in mm2
                            // need to be set before first pass.
    
    // *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
    psrld   mm2, 5  
    
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
    cmp     ecx, dwLength
    jae     done

        
        
        cmp     eax, pfSampleLength //if (pfSamplePos >= pfSampleLength)
        jb      NotPastEndOfSample1 //{ 
                        
        cmp     pfLoopLength, 0     //if (!pfLoopLength)
            
        je      done                // break;
            
        sub     eax, pfLoopLength   // else pfSamplePos -= pfLoopLength;
    
NotPastEndOfSample1:                //}
                    
        mov     esi, eax            // dwPosition1 = pfSamplePos;
        add     eax, ebx            // pfSamplePos += pfPitch;      
                
        sub     edx, 2              // dwIncDelta-=2;                                       
        jnz     DontIncreaseValues1 //if (!dwIncDelta) {

            // Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
            // for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
            // if it goes below zero.
                        
            paddd   mm0, vfDeltaLandRVolume // vfLVFract += vfDeltaLVolume;
                                            // vfRVFract += vfDeltaRVolume;
            pxor    mm5, mm5                // TestLVol = 0; TestRVol = 0;

            
            mov     edx, pfPFract           // Temp = pfPFract;
            pcmpgtd mm5, mm0            // if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
                                        // if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

            add     edx, pfDeltaPitch   // Temp += pfDeltaPitch;
            pandn   mm5, mm0            // TestLVol = vfLVFract & (~TestLVol);
                                        // TestRVol = vfRVFract & (~TestRVol);

            mov     pfPFract, edx       // pfPFract = Temp;
            movq    mm2, mm5            // vfLVolume = TestLVol;
                                        // vfRVolume = TestRVol;
            

            shr     edx, 8              // Temp = Temp >> 8;
            psrld   mm2, 5              // vfLVolume = vfLVolume >> 5;
                                        // vfRVolume = vfRVolume >> 5;                      
            
            mov     ebx, edx            // pfPitch = Temp;
            mov     edx, dwDeltaPeriod  //dwIncDelta = dwDeltaPeriod;           
            
        //}
DontIncreaseValues1:

        movd    mm6, esi            // dwFract1 = dwPosition1;
        movq    mm5, mm1            // words in mm5 = 0, 0, 0x1000, 0x1000      
        
        shr     esi, 12             // dwPosition1 = dwPosition1 >> 12;     
        add     ecx, 2              //dwI += 2;
                        
        // if (dwI < dwLength) break;                      
        cmp     ecx, dwLength
        jae     StoreOne
        
        //if (pfSamplePos >= pfSampleLength)
        //{ 
        cmp     eax, pfSampleLength
        jb      NotPastEndOfSample2

            // Original if in C was not negated
            //if (!pfLoopLength)            
            cmp     pfLoopLength, 0
            //break;            
            je      StoreOne
            //else
            //pfSamplePos -= pfLoopLength;
            sub     eax, pfLoopLength
        //}
NotPastEndOfSample2:

        //shl       esi, 1          // do not shift left since pcWave is array of chars
        mov     edi, eax        // dwPosition2 = pfSamplePos;

        add     esi, pcWave     // Put address of pcWave[dwPosition1] in esi            
        movd    mm7, eax        // dwFract2 = pfSamplePos;

        shr     edi, 12         // dwPosition2 = dwPosition2 >> 12;
    punpcklwd   mm6, mm7        // combine dwFract Values. Words in mm6 after unpack are
                                // 0, 0, dwFract2, dwFract1
                                
        pand    mm6, mm4        // dwFract2 &= 0xfff; dwFract1 &= 0xfff;
        
        movzx   esi, word ptr[esi]  //lLM1 = pcWave[dwPosition1];

        movd    mm3, esi

        psubw   mm5, mm6        // 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

        //shl       edi, 1          // do not shift left since pcWave is array of chars
    punpcklwd   mm5, mm6        // dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
                                
        add     edi, pcWave     // Put address of pcWave[dwPosition2] in edi
        mov     esi, ecx        // Temp = dWI;
                                                                                                                
        shl     esi, 1          // Temp = Temp << 1;                                
        
                    
        movzx   edi, word ptr[edi]  //lLM2 = pcWave[dwPosition2];
        movd    mm6, edi
    
        pxor    mm7, mm7        // zero out mm7 to make 8 bit into 16 bit

                                // low 4 bytes bytes in mm3
    punpcklwd   mm3, mm6        // pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
        
        add     esi, pBuffer    //
    punpcklbw   mm7, mm3        // bytes in mm7
                                // pcWave[dwPos2+1], 0, pcWave[dwPos2], 0, pcWave[dwPos1+1], pcWave[dwPos1], 0 
                                                
        pmaddwd mm7, mm5        // high dword = lM2 =
                                //(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
                                // low dword = lM1 =
                                //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))      

        movq    mm3, mm2        // put left and right volume levels in mm3

        add     eax, ebx        //pfSamplePos += pfPitch;
    packssdw    mm3, mm2        // words in mm3
                                // vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
        
        movq    mm5, qword ptr[esi-4]   // Load values from buffer
        add     ecx, 2          // dwI += 2;
                        
        psrad   mm7, 12         // shift back down to 16 bits.

        pand    mm7, wordmask   // combine results to get ready to multiply by left and right
        movq    mm6, mm7        // volume levels.
        pslld   mm6, 16         //
        por     mm7, mm6        // words in mm7
                                // lM2, lM2, lM1, lM1
                                                
        // above multiplies and shifts are all done with this one pmul
        pmulhw      mm3, mm7    // lLM1 *= vfLVolume;
                                // lM1 *= vfRVolume;
                                // lLM2 *= vfLVolume;
                                // lM2 *= vfRVolume;
                                
        paddsw  mm5, mm3                // Add values to buffer with saturation
        movq    qword ptr[esi-4], mm5   // Store values back into buffer.
                                
    // }
    jmp     mainloop

    // Need to write only one.
    //if (dwI < dwLength)
    //{
StoreOne:       
#if 1
        // Linearly interpolate between points and store only one value.
        // combine dwFract Values.
    
        // Make mm7 zero for unpacking

        //shl       esi, 1              // do not shift left since pcWave is array of chars
        add     esi, pcWave         // Put address of pcWave[dwPosition1] in esi
        pxor    mm7, mm7
                
        //lLM1 = pcWave[dwPosition1];
        movzx   esi, word ptr[esi]
        
        // Doing AND that was not done for dwFract1 and dwFract2
        pand    mm6, mm4

                                // words in MMX register after operation is complete.       
        psubw   mm5, mm6        // 0, 0, 0x1000 - 0, 0x1000 - dwFract1
    punpcklwd   mm5, mm6        // 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
                
        // put values of pcWave into MMX registers.  They are read into a regular register so
        // that the routine does not read past the end of the buffer otherwise, it could read
        // directly into the MMX registers.

        pxor    mm7, mm7
                                // byte in MMX registers
        movd    mm4, esi        // 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

        punpcklbw   mm7, mm4    // 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
                
        // *2 pmadd efficent code.
        //lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
        //lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

        pmaddwd     mm7, mm5// low dword = lM1 =
                            //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
        
        psrad       mm7, 12         // shift back down to 16 bits

        pand        mm7, wordmask   // combine results to get ready to multiply by left and right 
        movq        mm6, mm7        // volume levels.
        pslld       mm6, 16         //
        por         mm7, mm6        // words in mm7
                                    // lM2, lM2, lM1, lM1

        pxor        mm6, mm6

        movq        mm5, mm2    // move volume1 into mm5
                                
                                // use pack to get 4 volume values together for multiplication.
        packssdw    mm5, mm6    // words in mm7
                                // 0, 0, vfRVolume1, vfLVolume1
/*      
        // Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

        // Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
        // above multiplies and shifts are all done with this one pmul
        pmulhw      mm5, mm7
        
        // calculate buffer location.
        mov     edi, ecx
        shl     edi, 1
        add     edi, pBuffer        

/*
        add     word ptr[edi-4], si
        jno     no_oflowl1
        // pBuffer[dwI] = 0x7fff;
        mov     word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
        mov     word ptr[edi-4], 0x8000
no_oflowl1:
        //pBuffer[dwI+1] += (short) lM1;
        add     word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
        mov     word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
        mov     word ptr[edi-2], 0x8000
no_oflowr1:
*/
        movd    mm7, dword ptr[edi-4]       
        paddsw  mm7, mm5
        movd    dword ptr[edi-4], mm7
    //}
#endif 
done:

    mov     edx, this                       // get address of class object

    //m_vfLastLVolume = vfLVolume;
    //m_vfLastRVolume = vfRVolume;
    // need to shift volume back down to 12 bits before storing
    psrld   mm2, 3
    movd    [edx]this.m_vfLastLVolume, mm2
    psrlq   mm2, 32
    movd    [edx]this.m_vfLastRVolume, mm2
    
    //m_pfLastPitch = pfPitch;
    mov     [edx]this.m_pfLastPitch, ebx
        
    //m_pfLastSample = pfSamplePos;
    mov     [edx]this.m_pfLastSample, eax
        
    // put value back into dwI to be returned. This could just be passed back in eax I think.   
    mov     dwI, ecx
    emms    
} // ASM block
    return (dwI >> 1);
}


DWORD DigitalAudio::MixMono16X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)
{
    DWORD dwI;    
    
    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    short * pcWave = (short*)m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


    QWORD   dwFractMASK =   0x000000000FFF0FFF;
    QWORD   dwFractOne  =   0x0000000010001000; 
    QWORD   wordmask    =   0x0000FFFF0000FFFF;
    QWORD   vfDeltaLandRVolume;

_asm{
                
    // vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;   
    
    movd    mm0, vfVolume
    movd    mm7, vfVolume

    // vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
    movd    mm1, vfDeltaVolume
    movd    mm6, vfDeltaVolume

  punpckldq mm1, mm6
    
    // dwI = 0
    mov     ecx, 0
    movq    vfDeltaLandRVolume, mm1


    movq    mm1, dwFractOne
    movq    mm4, dwFractMASK
    
    mov     eax, pfSamplePos


  punpckldq mm0, mm7
    mov     ebx, pfPitch

    pslld   mm0, 8
    mov     edx, dwIncDelta

    movq    mm2, mm0        // vfLVolume and vfRVolume in mm2
                            // need to be set before first pass.
    
    // *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
    psrld   mm2, 5  
    
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
    cmp     ecx, dwLength
    jae     done

        
        
        cmp     eax, pfSampleLength //if (pfSamplePos >= pfSampleLength)
        jb      NotPastEndOfSample1 //{ 
                        
        cmp     pfLoopLength, 0     //if (!pfLoopLength)
            
        je      done                // break;
            
        sub     eax, pfLoopLength   // else pfSamplePos -= pfLoopLength;
    
NotPastEndOfSample1:                //}
                    
        mov     esi, eax            // dwPosition1 = pfSamplePos;
        add     eax, ebx            // pfSamplePos += pfPitch;      
                
        sub     edx, 2              // dwIncDelta-=2;                                       
        jnz     DontIncreaseValues1 //if (!dwIncDelta) {

            // Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
            // for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
            // if it goes below zero.
                        
            paddd   mm0, vfDeltaLandRVolume // vfVFract += vfDeltaVolume;
                                            // vfVFract += vfDeltaVolume;
            pxor    mm5, mm5                // TestLVol = 0; TestRVol = 0;

            
            mov     edx, pfPFract           // Temp = pfPFract;
            pcmpgtd mm5, mm0            // if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
                                        // if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

            add     edx, pfDeltaPitch   // Temp += pfDeltaPitch;
            pandn   mm5, mm0            // TestLVol = vfLVFract & (~TestLVol);
                                        // TestRVol = vfRVFract & (~TestRVol);

            mov     pfPFract, edx       // pfPFract = Temp;
            movq    mm2, mm5            // vfLVolume = TestLVol;
                                        // vfRVolume = TestRVol;
            

            shr     edx, 8              // Temp = Temp >> 8;
            psrld   mm2, 5              // vfLVolume = vfLVolume >> 5;
                                        // vfRVolume = vfRVolume >> 5;                      
            
            mov     ebx, edx            // pfPitch = Temp;
            mov     edx, dwDeltaPeriod  //dwIncDelta = dwDeltaPeriod;           
            
        //}
DontIncreaseValues1:

        movd    mm6, esi            // dwFract1 = dwPosition1;
        movq    mm5, mm1            // words in mm5 = 0, 0, 0x1000, 0x1000      
        
        shr     esi, 12             // dwPosition1 = dwPosition1 >> 12;     
        inc     ecx                 //dwI++;
                        
        // if (dwI < dwLength) break;                      
        cmp     ecx, dwLength
        jae     StoreOne
        
        //if (pfSamplePos >= pfSampleLength)
        //{ 
        cmp     eax, pfSampleLength
        jb      NotPastEndOfSample2

            // Original if in C was not negated
            //if (!pfLoopLength)            
            cmp     pfLoopLength, 0
            //break;            
            je      StoreOne
            //else
            //pfSamplePos -= pfLoopLength;
            sub     eax, pfLoopLength
        //}
NotPastEndOfSample2:

        shl     esi, 1          // shift left since pcWave is array of shorts
        mov     edi, eax        // dwPosition2 = pfSamplePos;

        add     esi, pcWave     // Put address of pcWave[dwPosition1] in esi            
        movd    mm7, eax        // dwFract2 = pfSamplePos;

        shr     edi, 12         // dwPosition2 = dwPosition2 >> 12;
    punpcklwd   mm6, mm7        // combine dwFract Values. Words in mm6 after unpack are
                                // 0, 0, dwFract2, dwFract1
                                
        pand    mm6, mm4        // dwFract2 &= 0xfff; dwFract1 &= 0xfff;
        
        movd    mm7, dword ptr[esi] //lLM1 = pcWave[dwPosition1];
        psubw   mm5, mm6        // 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

        shl     edi, 1          // shift left since pcWave is array of shorts
    punpcklwd   mm5, mm6        // dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
                                
        add     edi, pcWave     // Put address of pcWave[dwPosition2] in edi
        mov     esi, ecx        // Temp = dWI;
                                                                                                                
        shl     esi, 1          // Temp = Temp << 1;                                
        movq    mm3, mm2        // put left and right volume levels in mm3
        
                    
        movd    mm6, dword ptr[edi] //lLM2 = pcWave[dwPosition2];
    packssdw    mm3, mm2        // words in mm7
                                // vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
        
        add     esi, pBuffer    //
    punpckldq   mm7, mm6        // low four bytes bytes in 
                                // pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
                                                
        pmaddwd mm7, mm5        // high dword = lM2 =
                                //(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
                                // low dword = lM1 =
                                //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))      
        add     eax, ebx        //pfSamplePos += pfPitch;
        
        movd    mm5, dword ptr[esi-2]   // Load values from buffer
        inc     ecx             // dwI++;
                        
        psrad   mm7, 12         // shift back down to 16 bits.

    packssdw    mm7, mm4        // only need one word in mono case.
                                // low word are lm2 and lm1
                                                
        // above multiplies and shifts are all done with this one pmul. Low two word are only
        // interest in mono case
        pmulhw      mm3, mm7    // lLM1 *= vfVolume;                                
                                // lLM2 *= vfVolume;
                                
                                
        paddsw  mm5, mm3                // Add values to buffer with saturation
        movd    dword ptr[esi-2], mm5   // Store values back into buffer.
                                
    // }
    jmp     mainloop

    // Need to write only one.
    //if (dwI < dwLength)
    //{
StoreOne:       
#if 1
        // Linearly interpolate between points and store only one value.
        // combine dwFract Values.
    
        // Make mm7 zero for unpacking

        shl     esi, 1              // shift left since pcWave is array of shorts
        add     esi, pcWave         // Put address of pcWave[dwPosition1] in esi
        pxor    mm7, mm7
                
        //lLM1 = pcWave[dwPosition1];
        mov     esi, dword ptr[esi]
        
        // Doing AND that was not done for dwFract1 and dwFract2
        pand    mm6, mm4

                                // words in MMX register after operation is complete.       
        psubw   mm5, mm6        // 0, 0, 0x1000 - 0, 0x1000 - dwFract1
    punpcklwd   mm5, mm6        // 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
                
        // put values of pcWave into MMX registers.  They are read into a regular register so
        // that the routine does not read past the end of the buffer otherwise, it could read
        // directly into the MMX registers.

                                // words in MMX registers
        movd    mm7, esi        // 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
                
        // *2 pmadd efficent code.
        //lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
        //lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

        pmaddwd     mm7, mm5// low dword = lM1 =
                            //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
        
        psrad       mm7, 12         // shift back down to 16 bits
                
        movq        mm5, mm2    // move volume into mm5
/*      
        // Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

        // Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
        // above multiplies and shifts are all done with this one pmul
        pmulhw      mm5, mm7
        
        // calculate buffer location.
        mov     edi, ecx
        shl     edi, 1
        add     edi, pBuffer

        movd    edx, mm5

        //pBuffer[dwI+1] += (short) lM1;
        add     word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
        mov     word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
        mov     word ptr[edi-2], 0x8000
no_oflowr1:     
    //}
#endif 
done:

    mov     edx, this                       // get address of class object

    //m_vfLastLVolume = vfVolume;
    //m_vfLastRVolume = vfVolume;
    // need to shift volume back down to 12 bits before storing
    psrld   mm2, 3
    movd    [edx]this.m_vfLastLVolume, mm2  
    movd    [edx]this.m_vfLastRVolume, mm2
    
    //m_pfLastPitch = pfPitch;
    mov     [edx]this.m_pfLastPitch, ebx
        
    //m_pfLastSample = pfSamplePos;
    mov     [edx]this.m_pfLastSample, eax
        
    // put value back into dwI to be returned. This could just be passed back in eax I think.   
    mov     dwI, ecx
    emms    
} // ASM block
    return (dwI);
}

DWORD DigitalAudio::Mix16X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
        DWORD dwI;

    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
    //long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    short * pcWave = (short *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;

    VFRACT vfLVolume2 = m_vfLastLVolume;
    VFRACT vfRVolume2 = m_vfLastRVolume;

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    dwLength <<= 1;

    QWORD   dwFractMASK =   0x000000000FFF0FFF;
    QWORD   dwFractOne  =   0x0000000010001000; 
    QWORD   wordmask    =   0x0000FFFF0000FFFF;
    QWORD   vfDeltaLandRVolume;

_asm{
                
    // vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;   
    
    movd    mm0, vfLVolume
    movd    mm7, vfRVolume

    // vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
    movd    mm1, vfDeltaLVolume
    movd    mm6, vfDeltaRVolume

  punpckldq mm1, mm6
    
    // dwI = 0
    mov     ecx, 0
    movq    vfDeltaLandRVolume, mm1


    movq    mm1, dwFractOne
    movq    mm4, dwFractMASK
    
    mov     eax, pfSamplePos


  punpckldq mm0, mm7
    mov     ebx, pfPitch

    pslld   mm0, 8
    mov     edx, dwIncDelta

    movq    mm2, mm0        // vfLVolume and vfRVolume in mm2
                            // need to be set before first pass.
    
    // *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
    psrld   mm2, 5  
    
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
    cmp     ecx, dwLength
    jae     done

        
        
        cmp     eax, pfSampleLength //if (pfSamplePos >= pfSampleLength)
        jb      NotPastEndOfSample1 //{ 
                        
        cmp     pfLoopLength, 0     //if (!pfLoopLength)
            
        je      done                // break;
            
        sub     eax, pfLoopLength   // else pfSamplePos -= pfLoopLength;
    
NotPastEndOfSample1:                //}
                    
        mov     esi, eax            // dwPosition1 = pfSamplePos;
        add     eax, ebx            // pfSamplePos += pfPitch;      
                
        sub     edx, 2              // dwIncDelta-=2;                                       
        jnz     DontIncreaseValues1 //if (!dwIncDelta) {

            // Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
            // for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
            // if it goes below zero.
                        
            paddd   mm0, vfDeltaLandRVolume // vfLVFract += vfDeltaLVolume;
                                            // vfRVFract += vfDeltaRVolume;
            pxor    mm5, mm5                // TestLVol = 0; TestRVol = 0;

            
            mov     edx, pfPFract           // Temp = pfPFract;
            pcmpgtd mm5, mm0            // if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
                                        // if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

            add     edx, pfDeltaPitch   // Temp += pfDeltaPitch;
            pandn   mm5, mm0            // TestLVol = vfLVFract & (~TestLVol);
                                        // TestRVol = vfRVFract & (~TestRVol);

            mov     pfPFract, edx       // pfPFract = Temp;
            movq    mm2, mm5            // vfLVolume = TestLVol;
                                        // vfRVolume = TestRVol;
            

            shr     edx, 8              // Temp = Temp >> 8;
            psrld   mm2, 5              // vfLVolume = vfLVolume >> 5;
                                        // vfRVolume = vfRVolume >> 5;                      
            
            mov     ebx, edx            // pfPitch = Temp;
            mov     edx, dwDeltaPeriod  //dwIncDelta = dwDeltaPeriod;           
            
        //}
DontIncreaseValues1:

        movd    mm6, esi            // dwFract1 = dwPosition1;
        movq    mm5, mm1            // words in mm5 = 0, 0, 0x1000, 0x1000      
        
        shr     esi, 12             // dwPosition1 = dwPosition1 >> 12;     
        add     ecx, 2              //dwI += 2;
                        
        // if (dwI < dwLength) break;                      
        cmp     ecx, dwLength
        jae     StoreOne
        
        //if (pfSamplePos >= pfSampleLength)
        //{ 
        cmp     eax, pfSampleLength
        jb      NotPastEndOfSample2

            // Original if in C was not negated
            //if (!pfLoopLength)            
            cmp     pfLoopLength, 0
            //break;            
            je      StoreOne
            //else
            //pfSamplePos -= pfLoopLength;
            sub     eax, pfLoopLength
        //}
NotPastEndOfSample2:

        shl     esi, 1          // shift left since pcWave is array of shorts
        mov     edi, eax        // dwPosition2 = pfSamplePos;

        add     esi, pcWave     // Put address of pcWave[dwPosition1] in esi            
        movd    mm7, eax        // dwFract2 = pfSamplePos;

        shr     edi, 12         // dwPosition2 = dwPosition2 >> 12;
    punpcklwd   mm6, mm7        // combine dwFract Values. Words in mm6 after unpack are
                                // 0, 0, dwFract2, dwFract1
                                
        pand    mm6, mm4        // dwFract2 &= 0xfff; dwFract1 &= 0xfff;
        
        movd    mm7, dword ptr[esi] //lLM1 = pcWave[dwPosition1];
        psubw   mm5, mm6        // 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

        shl     edi, 1          // shift left since pcWave is array of shorts
    punpcklwd   mm5, mm6        // dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
                                
        add     edi, pcWave     // Put address of pcWave[dwPosition2] in edi
        mov     esi, ecx        // Temp = dWI;
                                                                                                                
        shl     esi, 1          // Temp = Temp << 1;                                
        movq    mm3, mm2        // put left and right volume levels in mm3
        
                    
        movd    mm6, dword ptr[edi] //lLM2 = pcWave[dwPosition2];
    packssdw    mm3, mm2        // words in mm7
                                // vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
        
        add     esi, pBuffer    //
    punpckldq   mm7, mm6        // low four bytes bytes in 
                                // pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
                                                
        pmaddwd mm7, mm5        // high dword = lM2 =
                                //(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
                                // low dword = lM1 =
                                //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))      
        add     eax, ebx        //pfSamplePos += pfPitch;
        
        movq    mm5, qword ptr[esi-4]   // Load values from buffer
        add     ecx, 2          // dwI += 2;
                        
        psrad   mm7, 12         // shift back down to 16 bits.

        pand    mm7, wordmask   // combine results to get ready to multiply by left and right
        movq    mm6, mm7        // volume levels.
        pslld   mm6, 16         //
        por     mm7, mm6        // words in mm7
                                // lM2, lM2, lM1, lM1
                                                
        // above multiplies and shifts are all done with this one pmul
        pmulhw      mm3, mm7    // lLM1 *= vfLVolume;
                                // lM1 *= vfRVolume;
                                // lLM2 *= vfLVolume;
                                // lM2 *= vfRVolume;
                                
        paddsw  mm5, mm3                // Add values to buffer with saturation
        movq    qword ptr[esi-4], mm5   // Store values back into buffer.
                                
    // }
    jmp     mainloop

    // Need to write only one.
    //if (dwI < dwLength)
    //{
StoreOne:       
#if 1
        // Linearly interpolate between points and store only one value.
        // combine dwFract Values.
    
        // Make mm7 zero for unpacking

        shl     esi, 1              // shift left since pcWave is array of shorts
        add     esi, pcWave         // Put address of pcWave[dwPosition1] in esi
        pxor    mm7, mm7
                
        //lLM1 = pcWave[dwPosition1];
        mov     esi, dword ptr[esi]
        
        // Doing AND that was not done for dwFract1 and dwFract2
        pand    mm6, mm4

                                // words in MMX register after operation is complete.       
        psubw   mm5, mm6        // 0, 0, 0x1000 - 0, 0x1000 - dwFract1
    punpcklwd   mm5, mm6        // 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
                
        // put values of pcWave into MMX registers.  They are read into a regular register so
        // that the routine does not read past the end of the buffer otherwise, it could read
        // directly into the MMX registers.

                                // words in MMX registers
        movd    mm7, esi        // 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
                
        // *2 pmadd efficent code.
        //lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
        //lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

        pmaddwd     mm7, mm5// low dword = lM1 =
                            //(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
        
        psrad       mm7, 12         // shift back down to 16 bits

        pand        mm7, wordmask   // combine results to get ready to multiply by left and right 
        movq        mm6, mm7        // volume levels.
        pslld       mm6, 16         //
        por         mm7, mm6        // words in mm7
                                    // lM2, lM2, lM1, lM1

        pxor        mm6, mm6

        movq        mm5, mm2    // move volume1 into mm5
                                
                                // use pack to get 4 volume values together for multiplication.
        packssdw    mm5, mm6    // words in mm7
                                // 0, 0, vfRVolume1, vfLVolume1
/*      
        // Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

        // Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
        // above multiplies and shifts are all done with this one pmul
        pmulhw      mm5, mm7
        
        // calculate buffer location.
        mov     edi, ecx
        shl     edi, 1
        add     edi, pBuffer        

/*
        add     word ptr[edi-4], si
        jno     no_oflowl1
        // pBuffer[dwI] = 0x7fff;
        mov     word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
        mov     word ptr[edi-4], 0x8000
no_oflowl1:
        //pBuffer[dwI+1] += (short) lM1;
        add     word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
        mov     word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
        mov     word ptr[edi-2], 0x8000
no_oflowr1:
*/
        movd    mm7, dword ptr[edi-4]       
        paddsw  mm7, mm5
        movd    dword ptr[edi-4], mm7
    //}
#endif 
done:

    mov     edx, this                       // get address of class object

    //m_vfLastLVolume = vfLVolume;
    //m_vfLastRVolume = vfRVolume;
    // need to shift volume back down to 12 bits before storing
    psrld   mm2, 3
    movd    [edx]this.m_vfLastLVolume, mm2
    psrlq   mm2, 32
    movd    [edx]this.m_vfLastRVolume, mm2
    
    //m_pfLastPitch = pfPitch;
    mov     [edx]this.m_pfLastPitch, ebx
        
    //m_pfLastSample = pfSamplePos;
    mov     [edx]this.m_pfLastSample, eax
        
    // put value back into dwI to be returned. This could just be passed back in eax I think.   
    mov     dwI, ecx
    emms    
} // ASM block
    return (dwI >> 1);
}

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  

BOOL MultiMediaInstructionsSupported()
{
    static  BOOL bMultiMediaInstructionsSupported = FALSE;
    static  BOOL bFlagNotSetYet = TRUE;
    
    // No need to keep interogating the CPU after it has been checked the first time
    if (bFlagNotSetYet)
    {
        bFlagNotSetYet = FALSE;         // Don't repeat the check for each call
        _asm 
        {
            pushfd                      // Store original EFLAGS on stack
            pop     eax                 // Get original EFLAGS in EAX
            mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
            xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
            push    eax                 // Save new EFLAGS value on stack
            popfd                       // Replace current EFLAGS value
            pushfd                      // Store new EFLAGS on stack
            pop     eax                 // Get new EFLAGS in EAX
            xor     eax, ecx            // Can we toggle ID bit?
            jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
            mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
            push    ebx                 // CPU_ID trashes eax-edx
            CPU_ID                      // Get family/model/stepping/features
            pop     ebx                 // CPU_ID trashes eax-edx
            test    edx, 0x00800000L    // Check if mmx technology available
            jz      Done                // Jump if no

//Don't need to do this now - P55C's are adequate, so any MMX chip is good enough.
    //  also check for GenuineIntel     // GenuineIntel and clones work differently.
    //  if not, jump to Success:        // The clones' implementations work.
    //  check family                    // Initial implementation of MMX is inefficient for EMMS,
    //  if 5 or earlier, jump to Done:  // so use only family 6 or higher.
        }
//Success:                              // Tests have passed, this machine supports MMX Instruction Set!
        bMultiMediaInstructionsSupported = TRUE;
Done:
        NULL;
    }
    return (bMultiMediaInstructionsSupported);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\loadicol.cpp ===
//      loadicol.cpp
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"
#include <math.h>
#include "dls.h"
#include "fltsafe.h"


extern "C" HRESULT SWMIDILoadFile(char *, PVOID, PULONG);

DWORD TimeCents2Samples(long tcTime, DWORD dwSampleRate)
{
    if (tcTime ==  0x80000000) return (0);
    float flTime = (float)(tcTime);
    flTime /= (float)(65536 * 1200);
    flTime = powf((float)2,flTime);
    flTime *= (float)(dwSampleRate);
    return (DWORD) (long)(flTime);
}

DWORD PitchCents2PitchFract(long pcRate,DWORD dwSampleRate)
{
    float fRate = (float)(pcRate);
    fRate /= (float)65536;
    fRate -= (float)6900;
    fRate /= (float)1200;
    fRate = powf((float)2,fRate);
    fRate *= (float)440;
    fRate *= (float)256*4096;
    fRate /= (float)(dwSampleRate);
    return (DWORD) (long)(fRate);
}

HRESULT Wave::Load(BYTE *p, BYTE *pEnd, DWORD dwCompress)
{
    BOOL            fFormatRead = FALSE;
    WAVEFORMATEX    WaveFormatEx;
    long            fulOptions = 0;
    BOOL            fClipRange;
    
    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;
        switch (pck->ckid) 
        {
            case LIST_TAG :
                switch (pck->fccType)
                {
                    case mmioFOURCC('I','N','F','O') :
                        // !!! ignore info
                        break;
                }
                break;
            case FOURCC_EDIT :
                {
                    DWORD dwTag;
                    memcpy((void *)&dwTag,(p + sizeof(RIFF)),4);
                    m_wEditTag = (WORD) dwTag;
                }
                break;
            case mmioFOURCC('f','m','t',' ') :
                if (fFormatRead)
                {
                    if (m_pnWave && !IsLocked())
                    {
                        ExFreePool(m_pnWave);
                        m_pnWave = NULL;
                    }
                    return E_BADWAVE;
                }
            
                if (pck->cksize < sizeof(PCMWAVEFORMAT) )
                {
                    if (m_pnWave && !IsLocked())
                    {
                        ExFreePool(m_pnWave);
                        m_pnWave = NULL;
                    }
                    return E_BADWAVE;
                }
            
                memcpy((void *)&WaveFormatEx,(p + sizeof(RIFF)),sizeof(WaveFormatEx));
    //            m_pwfx = (WAVEFORMATEX *) (p + sizeof(RIFF));
                if (WaveFormatEx.wFormatTag != WAVE_FORMAT_PCM)
                {
                    if (m_pnWave && !IsLocked())
                    {
                        ExFreePool(m_pnWave);
                        m_pnWave = NULL;
                    }
                    return E_NOTPCM;
                }
            
                if (WaveFormatEx.nChannels != 1)
                {
                    if (m_pnWave && !IsLocked())
                    {
                        ExFreePool(m_pnWave);
                        m_pnWave = NULL;
                    }
                    return E_NOTMONO;
                }
            
                if (WaveFormatEx.wBitsPerSample == 8)
                {
                    m_bSampleType = SFORMAT_8;
                }
                else if (WaveFormatEx.wBitsPerSample == 16)
                {
                    m_bSampleType = SFORMAT_16;
                }
                else
                {
                    if (m_pnWave && !IsLocked())
                    {
                        ExFreePool(m_pnWave);
                        m_pnWave = NULL;
                    }
                    return E_BADWAVE;
                }
                m_dwSampleRate = WaveFormatEx.nSamplesPerSec;
                fFormatRead = TRUE;
                break;

            case mmioFOURCC('s','m','p','l') :
                // obsolete now
                break;
            case FOURCC_WSMP :
            {
                if (pck->cksize < (sizeof(WSMPL)))
                {
                    if (m_pnWave && !IsLocked())
                    {
                        ExFreePool(m_pnWave);
                        m_pnWave = NULL;
                    }
                    return E_BADWAVE;
                }
                UNALIGNED WSMPL *pws = (WSMPL *) (p + sizeof(RIFF));
                UNALIGNED WLOOP *pwl = (WLOOP *) (p + sizeof(RIFF) + sizeof(WSMPL));

                m_vrAttenuation = (SHORT)(((pws->lAttenuation) * 10) >> 16);
                m_prFineTune = pws->sFineTune;
                m_bMIDIRootKey = (BYTE) pws->usUnityNote;
                m_bWSMPLoaded = TRUE;
                fulOptions = pws->fulOptions;

                // !!! verify pws->wUnityNote <= 127?
                
                if (pws->cSampleLoops == 0)
                {
                    m_bOneShot = TRUE;
                }
                else
                {
                    if (pck->cksize < sizeof(WSMPL) +
                            pws->cSampleLoops * sizeof(WLOOP)) 
                    {
                        if (m_pnWave && !IsLocked())
                        {
                            ExFreePool(m_pnWave);
                            m_pnWave = NULL;
                        }
                        return E_BADWAVE;
                    }

                    if (pwl->cbSize < sizeof(WLOOP))
                    {
                        if (m_pnWave && !IsLocked())
                        {
                            ExFreePool(m_pnWave);
                            m_pnWave = NULL;
                        }
                        return E_BADWAVE;
                    }

                    if (pwl->ulType != WLOOP_TYPE_FORWARD)
                    {
                        if (m_pnWave && !IsLocked())
                        {
                            ExFreePool(m_pnWave);
                            m_pnWave = NULL;
                        }
                        return E_BADWAVE;
                    }

                    m_dwLoopStart = pwl->ulStart;
                    m_dwLoopEnd = pwl->ulStart + pwl->ulLength;
                    m_bOneShot = FALSE;
                }
                break;
            }
            case mmioFOURCC('d','a','t','a') :
            {
                fClipRange = TRUE;
                if (m_pnWave)
                {
                    if (IsLocked())
                    {
                        return E_FAIL;
                    }
                    
                    ExFreePool(m_pnWave);
                    m_pnWave = NULL;
                }
                if (!fFormatRead)
                {
                    return E_BADWAVE;
                }

                if (WaveFormatEx.wBitsPerSample == 8)
                {
                    ASSERT(NULL == m_pnWave);
                    m_pnWave = (short *)
                        ExAllocatePoolWithTag(PagedPool,pck->cksize+1,'iMwS');  //  SwMi
                    if (m_pnWave == NULL)
                    {
                        return E_OUTOFMEMORY;
                    }
            
                    memcpy(m_pnWave,(void *) (p + sizeof(RIFF)),pck->cksize);
                    DWORD dwIndex;
                    char *pWave = (char *) m_pnWave;
                    for (dwIndex = 0;dwIndex < pck->cksize;dwIndex++)
                    {
                        pWave[dwIndex] -= (char) 128;
                    }

                    m_dwSampleLength = pck->cksize + 1;
                }
                else
                {
                    m_dwSampleLength = pck->cksize / 2;
                    if (dwCompress & COMPRESS_ON)
                    {
                        if (fulOptions & F_WSMP_NO_COMPRESSION) dwCompress &= ~COMPRESS_ON;
                    }
                    if (dwCompress & COMPRESS_TRUNCATE)
                    {
                        if (fulOptions & F_WSMP_NO_TRUNCATION) dwCompress &= ~COMPRESS_TRUNCATE;
                    }
                    if (dwCompress & COMPRESS_ON)
                    {
                        m_bSampleType = SFORMAT_COMPRESSED;
                        ASSERT(NULL == m_pnWave);
                        m_pnWave = (short *) 
                            ExAllocatePoolWithTag(PagedPool,m_dwSampleLength+1,'iMwS'); //  SwMi
                        if (m_pnWave == NULL)
                        {
                            return E_OUTOFMEMORY;
                        }
            
                        DWORD dwIndex;
                        char *pWave = (char *) m_pnWave;
                        short *pSource = (short *) (p + sizeof(RIFF));
                        for (dwIndex = 0;dwIndex < m_dwSampleLength;dwIndex++)
                        {
                            short nSample = pSource[dwIndex];
                            if (nSample >= 0)
                            {
                                pWave[dwIndex] = m_Compress[nSample >> 4];
                            }
                            else
                            {
                                pWave[dwIndex] = -m_Compress[-nSample >> 4];
                            }
                        }
                    }
                    else if (dwCompress & COMPRESS_TRUNCATE)
                    {
                        m_bSampleType = SFORMAT_8;
                        ASSERT(NULL == m_pnWave);
                        m_pnWave = (short *) 
                            ExAllocatePoolWithTag(PagedPool,m_dwSampleLength+1,'iMwS'); //  SwMi
                        if (m_pnWave == NULL)
                        {
                            return E_OUTOFMEMORY;
                        }
            
                        DWORD dwIndex;
                        char *pWave = (char *) m_pnWave;
                        short *pSource = (short *) (p + sizeof(RIFF));
                        for (dwIndex = 0;dwIndex < m_dwSampleLength;dwIndex++)
                        {
                            pWave[dwIndex] = pSource[dwIndex] >> 8;
                        }
                    }
                    else 
                    {
                        m_bSampleType = SFORMAT_16;
                        ASSERT(NULL == m_pnWave);
                        m_pnWave = (short *)
                            ExAllocatePoolWithTag(PagedPool,pck->cksize+2,'iMwS');  //  SwMi
                        if (m_pnWave == NULL)
                        {
                            return E_OUTOFMEMORY;
                        }
            
                        memcpy(m_pnWave,(void *) (p + sizeof(RIFF)),pck->cksize);
                        fClipRange = FALSE;
                    }
                    m_dwSampleLength++;
                }
                break;
            }   //  case fourcc 'data'
        }   //  switch (pck->ckid)
        p += pck->cksize + sizeof(RIFF);
    }   //  while p < pEnd

    Verify();
    return S_OK;
}


HRESULT SourceArticulation::Load(BYTE *p, BYTE *pEnd, DWORD dwSampleRate)
{
    UNALIGNED   CONNECTIONLIST *pConChunk;
    UNALIGNED   CONNECTION *pConnection;
    DWORD       dwIndex;

    m_LFO.Init(dwSampleRate);       // Set to default values.
    m_PitchEG.Init(dwSampleRate);
    m_VolumeEG.Init(dwSampleRate);
    
    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;
                
        switch (pck->ckid) 
        {
        case FOURCC_EDIT :
            {
                DWORD dwTag;
                memcpy((void *)&dwTag,(p + sizeof(RIFF)),4);
                m_wEditTag = (WORD) dwTag;
            }
            break;
        case FOURCC_ART1 :
            pConChunk = (CONNECTIONLIST *) (p + sizeof(RIFF));

            if (pConChunk->cbSize < sizeof(CONNECTIONLIST))
            {
                return E_BADARTICULATION;
            }
        
            if (pck->cksize != pConChunk->cbSize +
                                   pConChunk->cConnections * sizeof(CONNECTION))
            {
                return E_BADARTICULATION;
            }
            for (dwIndex = 0;dwIndex < pConChunk->cConnections;dwIndex++)
            {
                pConnection = (CONNECTION *) (p + sizeof(RIFF) + sizeof(CONNECTIONLIST) +
                                            dwIndex * sizeof(CONNECTION));

                switch (pConnection->usSource)
                {
                case CONN_SRC_NONE :
                    switch (pConnection->usDestination)
                    {
                    case CONN_DST_LFO_FREQUENCY :
                        m_LFO.m_pfFrequency = 
                            PitchCents2PitchFract(pConnection->lScale,dwSampleRate);
                        break;
                    case CONN_DST_LFO_STARTDELAY :
                        m_LFO.m_stDelay = 
                            TimeCents2Samples((TCENT) pConnection->lScale,dwSampleRate);
                        break;
                    case CONN_DST_EG1_ATTACKTIME :
                        m_VolumeEG.m_stAttack =
                            TimeCents2Samples((TCENT) pConnection->lScale,dwSampleRate);
                        break;
                    case CONN_DST_EG1_DECAYTIME :
                        m_VolumeEG.m_stDecay =
                            TimeCents2Samples((TCENT) pConnection->lScale,dwSampleRate);
                        break;
                    case CONN_DST_EG1_RESERVED :
                        m_VolumeEG.m_pcSustain =
                            (PERCENT) pConnection->lScale;
                        break;
                    case CONN_DST_EG1_SUSTAINLEVEL :
                        m_VolumeEG.m_pcSustain =
                            (PERCENT) ((long) (pConnection->lScale >> 16));
                        break;
                    case CONN_DST_EG1_RELEASETIME :
                        m_VolumeEG.m_stRelease =
                            TimeCents2Samples((TCENT) pConnection->lScale,dwSampleRate); 
                        break;
                    case CONN_DST_EG2_ATTACKTIME :
                        m_PitchEG.m_stAttack =
                            TimeCents2Samples((TCENT) pConnection->lScale,dwSampleRate);
                        break;
                    case CONN_DST_EG2_DECAYTIME :
                        m_PitchEG.m_stDecay =
                            TimeCents2Samples((TCENT) pConnection->lScale,dwSampleRate);
                        break;
                    case CONN_DST_EG2_RESERVED :
                        m_PitchEG.m_pcSustain =
                            (PERCENT) pConnection->lScale;
                        break;
                    case CONN_DST_EG2_SUSTAINLEVEL :
                        m_PitchEG.m_pcSustain =
                            (PERCENT) ((long) (pConnection->lScale >> 16));
                        break;
                    case CONN_DST_EG2_RELEASETIME :
                        m_PitchEG.m_stRelease =
                            TimeCents2Samples((TCENT) pConnection->lScale,dwSampleRate); 
                        break;
                    case CONN_DST_RESERVED :
                        m_sDefaultPan = (SHORT)
                            (((long) pConnection->lScale) * 16 / 125);
                        break;
                    case CONN_DST_PAN :
                        m_sDefaultPan = (SHORT)
                            (((long) pConnection->lScale >> 12) / 125);
                        break;
                    default:
                        DPF2(1, "Unknown Articulation: SRC None DEST %d Value %d",
                                     pConnection->usDestination, pConnection->lScale);
                        break;
                    }
                    break;
                case CONN_SRC_LFO :
                    switch (pConnection->usControl)
                    {
                    case CONN_SRC_NONE :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_ATTENUATION :
                            m_LFO.m_vrVolumeScale = (VRELS)
                                ((long) ((pConnection->lScale * 10) >> 16));
                            if (m_LFO.m_vrVolumeScale > 1200)
                            {
                                m_LFO.m_vrVolumeScale = 1200;
                            }
                            if (m_LFO.m_vrVolumeScale < -1200)
                            {
                                m_LFO.m_vrVolumeScale = -1200;
                            }
                            break;
                        case CONN_DST_PITCH :
                            m_LFO.m_prPitchScale = (PRELS)
                                ((long) (pConnection->lScale >> 16)); 
                            if (m_LFO.m_prPitchScale > 1200)
                            {
                                m_LFO.m_prPitchScale = 1200;
                            }
                            if (m_LFO.m_prPitchScale < -1200)
                            {
                                m_LFO.m_prPitchScale = -1200;
                            }
                            break;
                        }
                        break;
                    case CONN_SRC_CC1 :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_ATTENUATION :
                            m_LFO.m_vrMWVolumeScale = (VRELS)
                                ((long) ((pConnection->lScale * 10) >> 16)); 
                            if (m_LFO.m_vrMWVolumeScale > 1200)
                            {
                                m_LFO.m_vrMWVolumeScale = 1200;
                            }
                            if (m_LFO.m_vrMWVolumeScale < -1200)
                            {
                                m_LFO.m_vrMWVolumeScale = -1200;
                            }
                            break;
                        case CONN_DST_PITCH :
                            m_LFO.m_prMWPitchScale = (PRELS)
                                ((long) (pConnection->lScale >> 16)); 
                            if (m_LFO.m_prMWPitchScale > 1200)
                            {
                                m_LFO.m_prMWPitchScale = 1200;
                            }
                            if (m_LFO.m_prMWPitchScale < -1200)
                            {
                                m_LFO.m_prMWPitchScale = -1200;
                            }
                            break;
                        }
                        break;
                    }
                    break;

                case CONN_SRC_KEYONVELOCITY :
                    switch (pConnection->usDestination)
                    {
                    case CONN_DST_EG1_ATTACKTIME :
                        m_VolumeEG.m_trVelAttackScale = (TRELS)
                            ((long) (pConnection->lScale >> 16));
                        break;
                    case CONN_DST_EG2_ATTACKTIME :
                        m_PitchEG.m_trVelAttackScale = (TRELS)
                            ((long) (pConnection->lScale >> 16));
                        break;
                    case CONN_DST_ATTENUATION :
                        if (pConnection->lScale == 0x80000000)
                        {
                            m_sVelToVolScale = -9600;
                        }
                        else
                        {
                            m_sVelToVolScale = (short)
                                ((long) ((pConnection->lScale * 10) >> 16));

                            if (m_sVelToVolScale > 0)
                            {
                                m_sVelToVolScale = 0;
                            }
                            if (m_sVelToVolScale < -9600)
                            {
                                m_sVelToVolScale = -9600;
                            }   
                        }
                        break;
                    }
                    break;
                case CONN_SRC_KEYNUMBER :
                    switch (pConnection->usDestination)
                    {
                    case CONN_DST_EG1_DECAYTIME :
                        m_VolumeEG.m_trKeyDecayScale = (TRELS)
                            ((long) (pConnection->lScale >> 16));
                        break;
                    case CONN_DST_EG2_DECAYTIME :
                        m_PitchEG.m_trKeyDecayScale = (TRELS)
                            ((long) (pConnection->lScale >> 16));
                        break;
                    }
                    break;
                 case CONN_SRC_EG2 :
                    switch (pConnection->usDestination)
                    {
                    case CONN_DST_PITCH :
                        m_PitchEG.m_sScale = (short)
                            ((long) (pConnection->lScale >> 16));
                        break;
                    }
                    break;
                }
            }
        }
        p += pck->cksize + sizeof(RIFF);
    }
    Verify();
    return S_OK;
}

HRESULT SourceRegion::Load(BYTE *p, BYTE *pEnd, DWORD dwSampleRate)
{
    HRESULT hr;  
    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;
        switch (pck->ckid) {
        case FOURCC_RGNH :
            if (pck->cksize < sizeof(RGNHEADER) )
            {
                return E_BADREGION;
            }
            {
                UNALIGNED RGNHEADER *prh = (RGNHEADER *) (p + sizeof(RIFF));
                m_bKeyHigh = (BYTE) prh->RangeKey.usHigh;
                m_bKeyLow = (BYTE) prh->RangeKey.usLow;
                if (prh->fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE)
                {
                    m_bAllowOverlap = TRUE;
                }
                else
                {
                    m_bAllowOverlap = FALSE;
                }
                m_bGroup = (BYTE) prh->usKeyGroup;
            }
            break;
        case FOURCC_EDIT :
            {
                DWORD dwTag;
                memcpy((void *)&dwTag,(p + sizeof(RIFF)),4);
                m_wEditTag = (WORD) dwTag;
            }
            break;
        case FOURCC_WSMP :
            if (pck->cksize < (sizeof(WSMPL)))
            {
                return E_BADREGION;
            }
            {
                UNALIGNED WSMPL *pws = (WSMPL *) (p + sizeof(RIFF));
                UNALIGNED WLOOP *pwl = (WLOOP *) (p + sizeof(RIFF) + sizeof(WSMPL));

                m_vrAttenuation = (SHORT)(((pws->lAttenuation) * 10) >> 16);
                m_Sample.m_prFineTune = pws->sFineTune;
                m_Sample.m_bMIDIRootKey = (BYTE) pws->usUnityNote;
                m_Sample.m_bWSMPLoaded = TRUE;
                    
                if (pws->cSampleLoops == 0)
                {
                    m_Sample.m_bOneShot = TRUE;
                }
                else
                {
                    if (pck->cksize < sizeof(WSMPL) +
                            pws->cSampleLoops * sizeof(WLOOP)) {
                        return E_BADREGION;
                    }

                    if (pws->cSampleLoops > 1)
                    {
                        return E_BADREGION;
                    }

                    // !!! these shouldn't be asserts, obviously.
                    if (pwl->cbSize < sizeof(WLOOP))
                    {
                        return E_BADREGION;
                    }

                    m_Sample.m_dwLoopStart = pwl->ulStart;
                    m_Sample.m_dwLoopEnd = pwl->ulStart + pwl->ulLength;
                    m_Sample.m_bOneShot = FALSE;
                }
            }
            break;

        case FOURCC_WLNK :
            if (pck->cksize < sizeof(WAVELINK) )
            {
                return E_BADWAVELINK;
            }
            {
                UNALIGNED WAVELINK * pwvl = (WAVELINK *) (p + sizeof(RIFF));

                if (pwvl->ulChannel != WAVELINK_CHANNEL_LEFT)
                {
                    return E_NOTMONO;
                }

                m_Sample.m_wID = (WORD) pwvl->ulTableIndex;
            }
            break;
        case LIST_TAG :
            switch (((UNALIGNED RIFFLIST *)pck)->fccType)
            {
                case FOURCC_LART :
                    if (m_pArticulation)
                    {
                        m_pArticulation->Release();
                    }
                    
                    m_pArticulation = new SourceArticulation;

                    if (!m_pArticulation)
                    {
                        return E_OUTOFMEMORY;
                    }

                    hr = m_pArticulation->Load(p + sizeof(RIFFLIST),
                                            p + sizeof(RIFF) + pck->cksize,
                                            dwSampleRate);

                    if (FAILED(hr))
                    {
                        return hr;
                    }

                    m_pArticulation->AddRef();
                    break;
            }
            break;
        }
        p += pck->cksize + sizeof(RIFF);
    }
    return S_OK;
}

HRESULT Instrument::LoadRegions(BYTE *p, BYTE *pEnd, DWORD dwSampleRate)
{
    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;
        switch (pck->ckid) {
        case LIST_TAG :
            switch (pck->fccType)
            {
            case FOURCC_RGN :
                SourceRegion *pRegion = NULL;

                pRegion = new SourceRegion;

                // !!! delay creating these?  do this more efficiently?

                if (!pRegion)
                {
                    return E_OUTOFMEMORY;
                }

                HRESULT hr = pRegion->Load(p + sizeof(RIFFLIST),
                                           p + sizeof(RIFF) + pck->cksize,
                                           dwSampleRate);
                if (FAILED(hr))
                {
                    delete pRegion;
                    return hr;
                }
                m_RegionList.AddHead(pRegion);
                break;
            }
        }
        p += pck->cksize + sizeof(RIFF);
    }

    return S_OK;
}

HRESULT Instrument::Load( BYTE *p, BYTE *pEnd, DWORD dwSampleRate)
{
    HRESULT hr;
    SourceArticulation *pArticulation = NULL;
    BOOL fIsDrum = FALSE;

    while (p < pEnd)
    {
        UNALIGNED RIFF *pck = (RIFF *) p;
        switch (pck->ckid) {
        case FOURCC_EDIT :
            {
                DWORD dwTag;
                memcpy((void *)&dwTag,(p + sizeof(RIFF)),4);
                m_wEditTag = (WORD) dwTag;
            }
            break;
        case FOURCC_INSH :
            if (pck->cksize < sizeof(INSTHEADER) )
            {
                // !!!
                return E_BADINSTRUMENT;
            }
            {
                UNALIGNED INSTHEADER * pInstHeader = (INSTHEADER *) (p + sizeof(RIFF));
                // !!! do something
                // !!! verify cRegions?
                // !!! is this right?

                if (pInstHeader->Locale.ulBank & F_INSTRUMENT_DRUMS)    // Drum Bank?
                {
                    fIsDrum = TRUE;
                }

                if (pInstHeader->Locale.ulInstrument > 0x7f)
                {
                    DPF1(1, "Instrument #%0x isn't in 0x00-0x7f range!",
                         pInstHeader->Locale.ulInstrument);
                }
                
                m_dwProgram = pInstHeader->Locale.ulInstrument;
                m_dwProgram |= ((pInstHeader->Locale.ulBank & 0x7F) << 7);
                m_dwProgram |= ((pInstHeader->Locale.ulBank & 0x7F00) << 6);
                                         
                if (fIsDrum)
                {
                    m_dwProgram |= AA_FINST_DRUM;
                }
                DPF3(2, "Loading instrument bank %d, patch %d with %d regions",
                     pInstHeader->Locale.ulBank,
                     pInstHeader->Locale.ulInstrument,
                     pInstHeader->cRegions);
            }
            break;
        case LIST_TAG :
            switch (((
                    UNALIGNED RIFFLIST *)pck)->fccType)
            {
                case FOURCC_LRGN :
                    // First, get rid of previous list of regions.
                    while (!m_RegionList.IsEmpty())
                    {
                        SourceRegion *pRegion = m_RegionList.RemoveHead();
                        delete pRegion;
                    }
                    hr = LoadRegions(p + sizeof(RIFFLIST),
                                     p + sizeof(RIFF) + pck->cksize,
                                     dwSampleRate);

                    if (FAILED(hr))
                    {
                        return hr; 
                    }
                    break;
                case mmioFOURCC('I','N','F','O') :
                    // load info, not.
                    break;
                case FOURCC_LART :
                    // !!! copy these to each region!

                    if (pArticulation)
                    {
                        // !!! already had one?
                        pArticulation->Release();
                    }
                    
                    pArticulation = new SourceArticulation;

                    if (!pArticulation)
                    {
                        return E_OUTOFMEMORY;
                    }
                    pArticulation->AddRef(); // Will Release when done.

                    hr = pArticulation->Load(p + sizeof(RIFFLIST),
                                            p + sizeof(RIFF) + pck->cksize,
                                            dwSampleRate);
                    if (FAILED(hr))
                    {
                        pArticulation->Release();
                        return hr;
                    }
                    break;
            }
            break;
        }
        p += pck->cksize + sizeof(RIFF);
    }

    if (pArticulation)
    {
    
        for (SourceRegion *pr = m_RegionList.GetHead();
             pr != NULL;
             pr = pr->GetNext())
        {
            if (pr->m_pArticulation == NULL)
            {
                pr->m_pArticulation = pArticulation;
                pArticulation->AddRef();    
            }
        }
        pArticulation->Release();   // Release initial AddRef();
    }
    else
    {

        for (SourceRegion *pr = m_RegionList.GetHead();
             pr != NULL;
             pr = pr->GetNext())
        {
            if (pr->m_pArticulation == NULL)
            {
                return E_NOARTICULATION;
            }
        }
    }
    
    return S_OK;
}

HRESULT Collection::LoadInstruments(BYTE *p, BYTE *pEnd, DWORD dwSampleRate)
{
    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;
        switch (pck->ckid) {
        case LIST_TAG :
            switch (pck->fccType)
            {
            case FOURCC_INS :
                Instrument *pInstrument = NULL;

                pInstrument = new Instrument;
                if (!pInstrument)
                {
                    return E_OUTOFMEMORY;
                }

                HRESULT hr = pInstrument->Load(p + sizeof(RIFFLIST),
                                               p + pck->cksize + sizeof(RIFF),
                                               dwSampleRate);

                if (FAILED(hr))
                {
                    delete pInstrument;
                    // !!! OK, so this instrument failed; should we try to go on?
                    return hr;
                }
                RemoveDuplicateInstrument(pInstrument->m_dwProgram);
                m_InstrumentList.AddTail(pInstrument);
                break;
            }
        }
        p += pck->cksize + sizeof(RIFF);
    }

    // !!! check whether we found the right # of instruments
    return S_OK;
}

HRESULT Collection::LoadWavePool(BYTE *p, BYTE *pEnd,DWORD dwCompress)
{
    DWORD entry = 0;
    Wave *pWave;
    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;
        switch (pck->ckid) {
        case LIST_TAG :
            switch (pck->fccType)
            {
            case mmioFOURCC('W','A','V','E') :
            case mmioFOURCC('w','a','v','e') :
                pWave = new Wave;
                if (pWave == NULL)
                {
                    return E_OUTOFMEMORY;
                }
                m_WavePool.AddTail(pWave);
                pWave->AddRef();
                entry++;    // Need to change this to scan around the wave, just grab the offset.
                HRESULT hr = pWave->Load(p + sizeof(RIFFLIST),
                                              p + sizeof(RIFF) + pck->cksize, dwCompress);

                if (FAILED(hr))
                {
                    return hr;
                }
                break;
            }
        }
        p += pck->cksize + sizeof(RIFF);
    }

    return S_OK;
}

HRESULT Collection::LoadPoolCues(BYTE *p, BYTE *pEnd, DWORD dwCompress)
{
    DWORD dwIndex;
    UNALIGNED POOLTABLE *pHeader = (POOLTABLE *) p;
    p += pHeader->cbSize;

    while (!m_WavePool.IsEmpty()) 
    {
        Wave *pWave = m_WavePool.RemoveHead();

        if (pWave->IsLocked())
        {
            pWave->UnLock();
        }
        pWave->Release();
    }
    for (dwIndex = 0; dwIndex < pHeader->cCues; dwIndex++)
    {
        UNALIGNED POOLCUE *pCue = (POOLCUE *) p;
        if (p >= pEnd) break;
        Wave *pWave = new Wave;
        if (pWave != NULL)
        {
            pWave->m_wID = (WORD) dwIndex;
            pWave->m_uipOffset = pCue->ulOffset;
            pWave->m_bCompress = (BYTE) dwCompress;
            m_WavePool.AddTail(pWave);
            pWave->AddRef();
        }
        p += sizeof(POOLCUE);
    }
    if (dwIndex > 65535)
    {
        return E_FAIL;
    }
    m_wWavePoolSize = (WORD) dwIndex;
    return (S_OK);
}

HRESULT Collection::ResolveConnections()
{
    HRESULT hr = S_OK;
    Wave** pArray = new Wave*[m_wWavePoolSize];

    if (pArray != NULL)
    {
        for (short i = 0;i < m_wWavePoolSize;i++)
        {
            pArray[i] = NULL;
        }

        Wave *pWave;
        DWORD dwIndex = 0;
        pWave = m_WavePool.GetHead();
        for (;pWave != NULL;pWave = pWave->GetNext())
        {
            if (dwIndex >= m_wWavePoolSize)
            {
                hr = E_BADCOLLECTION;
                break;  // Should never happen.
            }
            pArray[dwIndex] = pWave;
            if (pWave->m_wID != dwIndex)
            {
                hr = E_BADCOLLECTION;
                break;  // Should never happen.
            }
            dwIndex++;
        }
        for (Instrument *pInstrument = m_InstrumentList.GetHead();
             pInstrument != NULL;
             pInstrument = pInstrument->GetNext())
        {
            SourceRegion *pRegion = pInstrument->m_RegionList.GetHead();
            for (;pRegion != NULL;pRegion = pRegion->GetNext())
            {
                if (pRegion->m_Sample.m_wID < m_wWavePoolSize)
                {
                    pWave = pArray[pRegion->m_Sample.m_wID];
                    if (pRegion->m_Sample.m_pWave != NULL)
                    {
                        if (pRegion->m_Sample.m_pWave->IsLocked())
                        {
                            pRegion->m_Sample.m_pWave->UnLock();
                        }
                        pRegion->m_Sample.m_pWave->Release();
                        
                        //                        pRegion->m_Sample.m_pWave = NULL; //  not needed, see below
                    }
                    pRegion->m_Sample.m_pWave = pWave;
                    if (pWave)
                    {
                        pWave->AddRef(); 
                    }
                    else
                    {
                        hr = E_NOWAVE;
                        break;
                    }
                }
                else
                {
                    hr = E_NOWAVE;
                    break;
                }
            }
        }
        delete[] pArray;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

void Collection::Close()
{
    if (m_lpMapAddress != NULL) 
    {
        ExFreePool(m_lpMapAddress);
        m_lpMapAddress = NULL;
    }
}

HRESULT Collection::Open(PCWSTR szCollection)
{
    FILE_STANDARD_INFORMATION FileStandardInformationBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE hFile = NULL;
    HRESULT hr = S_OK;

    NTSTATUS status = STATUS_SUCCESS;

    RtlInitUnicodeString(&UnicodeString,szCollection);
    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status =    ZwCreateFile(&hFile,
                                GENERIC_READ,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                0,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,
                                0);

    if (!NT_SUCCESS(status)) {
        Trap();
        hr = E_FAIL;
        goto exit;
    }
    if (!NT_SUCCESS(ZwQueryInformationFile(hFile,
                      &IoStatusBlock,
                      &FileStandardInformationBlock,
                      sizeof(FileStandardInformationBlock),
                      FileStandardInformation))) {
        Trap();
        hr = E_FAIL;
        goto exit;
    }
    m_cbFile = FileStandardInformationBlock.EndOfFile.LowPart;
    ASSERT(FileStandardInformationBlock.EndOfFile.HighPart == 0);

    // The below allocation will cause bugcheck c4 if the file is empty.
    if (0 == m_cbFile)
    {
        hr = E_FAIL;
        goto exit;
    }

    m_lpMapAddress = ExAllocatePoolWithTag(PagedPool,m_cbFile,'iMwS');  //  SwMi
    if (m_lpMapAddress == NULL) 
    {
        Trap();
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    if (!NT_SUCCESS(ZwReadFile( hFile,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                m_lpMapAddress,
                                m_cbFile,
                                NULL,
                                NULL)  )  )
    {
        Trap();
        Close();        //  m_lpMapAddress is freed here
        hr = E_FAIL;
        goto exit;
    }
exit:
    if (hFile) {
        ZwClose(hFile);
    }
    return hr;
}

HRESULT Collection::LoadName(BYTE *p, BYTE *pEnd)
{
    HRESULT hr = S_OK;
    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;
        switch (pck->ckid) 
        {
        case mmioFOURCC('I','N','A','M') :
            if (m_pszName != NULL)
            {
                delete m_pszName;
            }
            m_pszName = new char[pck->cksize+1];
            if (m_pszName != NULL)
            {
                strcpy(m_pszName,(char *) (p + sizeof(RIFF)));
            }
            break;
        default:
            break;
        }
        p += ((pck->cksize + 1) & 0xFFFFFFFE) + sizeof(RIFF);
    }
    return hr;
}

HRESULT Collection::Load(BYTE *p, BYTE *pEnd, DWORD dwCompress, DWORD dwSampleRate)
{
    UNALIGNED DLSHEADER *ph = NULL;
    HRESULT hr;
    BOOL fCuesLoaded = FALSE;

    while (p < pEnd)
    {
        UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;

        switch (pck->ckid) {
        case FOURCC_EDIT :
            {
                DWORD dwTag;
                memcpy((void *)&dwTag,(p + sizeof(RIFF)),4);
                m_wEditTag = (WORD) dwTag;
            }
            break;
        case FOURCC_COLH :
            if (pck->cksize < sizeof(DLSHEADER) )
            {
                return E_BADCOLLECTION;
            }

            ph = (DLSHEADER *) (p + sizeof(RIFF));

            DPF1(1, "Loading collection with %d instruments",
                 ph->cInstruments);
            // !!! do something with cInstruments
            // !!! do something with cPoolEntries

            break;
        case FOURCC_PTBL :
            hr = LoadPoolCues(p + sizeof(RIFF),
                              p + sizeof(RIFF) + pck->cksize,dwCompress); 
            if (FAILED(hr))
            {
                return hr;
            }
            fCuesLoaded = TRUE;
            break;
        case LIST_TAG :
            switch (pck->fccType)
            {
                case FOURCC_LINS :
                    hr = LoadInstruments(p + sizeof(RIFFLIST),
                                         p + sizeof(RIFF) + pck->cksize,
                                         dwSampleRate);
                    if (FAILED(hr))
                    {
                        return hr;
                    }
                    break;
                case mmioFOURCC('I','N','F','O') :
                    hr = LoadName(p + sizeof(RIFFLIST),
                                  p + sizeof(RIFF) + pck->cksize);
                    if (FAILED(hr))
                    {
                        return hr;
                    }
                    break;
                case FOURCC_WVPL :
                    if (fCuesLoaded)
                    {
                        m_uipWavePool = (UINT_PTR)p + sizeof(RIFFLIST);
                        Wave * pWave = m_WavePool.GetHead();
                        for (;pWave != NULL;pWave = pWave->GetNext())
                        {
                            pWave->m_uipOffset += m_uipWavePool;
                        }
                    }
                    else
                    {
                        hr = LoadWavePool(p + sizeof(RIFFLIST),
                                          p + sizeof(RIFF) + pck->cksize,dwCompress);
                        if (FAILED(hr))
                        {
                            return hr;
                        }
                    }
                    break;
            }
            break;
        }
        p += pck->cksize + sizeof(RIFF);
    }
    ResolveConnections();
    return S_OK;
}

HRESULT Collection::Load(DWORD dwCompress, DWORD dwSampleRate)
{
    BYTE *p = (BYTE *) m_lpMapAddress;
    UNALIGNED RIFFLIST *pck = (RIFFLIST *) p;

    if (p == NULL) return E_FAIL;  // This should NEVER happen.
    if (pck->fccType != FOURCC_DLS)
    {
        return E_BADCOLLECTION;
    }
    return Load(p + sizeof(RIFFLIST), p + m_cbFile, dwCompress, dwSampleRate);
}

HRESULT InstManager::LoadCollection(HANDLE *pHandle,
                          PCWSTR szFileName,
                          BOOL fIsGM)
{
    FLOATSAFE fs;

    HRESULT hr = S_OK;
    if (szFileName == NULL)
    {
        return E_FAIL;
    }
    Collection *pCollection = m_CollectionList.GetHead();
    for (;pCollection != NULL;pCollection = pCollection->GetNext())
    {
        if (wcscmp(pCollection->m_pszFileName,szFileName) == 0)
        {
            ASSERT(pCollection->m_lOpenCount >= 0);
            (void) InterlockedIncrement(&(pCollection->m_lOpenCount));
            *pHandle = (HANDLE) pCollection;
            return (S_OK);
        }
    }
    pCollection = new Collection;
    if (pCollection == NULL)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("SWMidi can't create DLS collection, no memory!"));
        return E_OUTOFMEMORY;
    }

    // m_pszFileName is read from registry.
    if (m_pszFileName)
    {
        hr = pCollection->Open(m_pszFileName);
        if (FAILED(hr))
        {
            // if the registry DLS file is not found, try the default.
            hr = pCollection->Open(szFileName);
        }
    }
    // if the registry key does not exist, try the default.
    else
    {
        hr = pCollection->Open(szFileName);
    }

    if (FAILED(hr))
    {
        delete pCollection;
        _DbgPrintF(DEBUGLVL_TERSE, ("SWMidi can't open DLS collection!"));
        return (hr);
    }

    hr = pCollection->Load(m_dwCompress,m_dwSampleRate);
    if (SUCCEEDED(hr))
    {
        pCollection->m_pszFileName = new WCHAR[wcslen(szFileName)+1];
        if (pCollection->m_pszFileName)
        {
            wcscpy(pCollection->m_pszFileName,szFileName);
            *pHandle = (HANDLE) pCollection;

            (void) InterlockedIncrement(&(pCollection->m_lOpenCount));
            if (fIsGM)  // Make is so search always finds GM last.
            {
                m_CollectionList.AddTail(pCollection);
            }
            else
            {
                m_CollectionList.AddHead(pCollection);
            }
            pCollection->m_fIsGM = fIsGM;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("SWMidi can't add DLS collection to list, no memory!"));
            delete pCollection;
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("SWMidi can't load DLS collection, parse error!"));
        delete pCollection;
    }
    
    return (hr);
}

HRESULT InstManager::ReleaseCollection(HANDLE hCollection)

{
    HRESULT hr = E_HANDLE;
    Collection *pCollection = (Collection *) hCollection;
    ASSERT(pCollection->m_lOpenCount > 0);

    if (m_CollectionList.IsMember(pCollection))
    {
        if (InterlockedDecrement(&(pCollection->m_lOpenCount)) == 0)
        {
            m_CollectionList.Remove(pCollection);
            delete pCollection;
        }
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\mix.cpp ===
//      Mix.cpp
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//      Mix engines for Microsoft GS Synthesizer

#include "common.h"

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_

#ifndef _X86_

DWORD DigitalAudio::Mix8(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
	dwLength <<= 1;
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        lLM = pcWave[dwPosition];
        lM = ((pcWave[dwPosition + 1] - lLM) * dwFract) >> 12;
        lM += lLM;
        lLM = lM;

        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else

// Generic non ALPHA, non X86 case.  This is used for IA64 at least.
// Note that this would probably work for Alpha as well.  I don't know why
// they wrote such convoluted code as they did above.  Maybe it was fast.

		// First add what is in the buffer to our sample values.
		lLM+=pBuffer[dwI];
		lM+=pBuffer[dwI+1];

		// Now saturate them to 16 bit sample sizes.
		if (lLM>32767)
			lLM=32767;
		if (lM>32767)
			lM=32767;
		if (lLM<-32768)
			lLM=-32768;
		if (lM<-32768)
			lM=-32768;

		// Now write out the 16 bit pegged values to the buffer.
		pBuffer[dwI]=(short)lLM;
		pBuffer[dwI+1]=(short)lM;

// NOTE!  TODO!  The whole algorithm here is sub-optimal!
// We are saturating EACH TIME we mix a new voice.  That is definitely lower quality.  We should
// be mixing into an internal buffer that is big enough to hold non pegged values,
// and we should saturate only AFTER all of the data is mixed.

#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;
        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	
		pBuffer[dwI+1] += (short) lM;
        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:	
#endif // _X86_
		dwI += 2;
    }
    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

#else // _X86_

__declspec( naked ) DWORD DigitalAudio::Mix8(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
#define Mix8_pBuffer$ 8
#define Mix8_dwLength$ 12
#define Mix8_dwDeltaPeriod$ 16
#define Mix8_vfDeltaLVolume$ 20
#define Mix8_vfDeltaRVolume$ 24
#define Mix8_pfDeltaPitch$ 28
#define Mix8_pfSampleLength$ 32
#define Mix8_pfLoopLength$ 36
#define Mix8_lLM$ (-16)
#define Mix8_dwIncDelta$ (-20)
#define Mix8_dwFract$ (-4)
#define Mix8_pcWave$ (-12)
#define Mix8_vfRVolume$ (-32)
#define Mix8_pfPitch$ (-36)
#define Mix8_pfPFract$ (-24)
#define Mix8_vfLVFract$ (-28)
#define Mix8_vfRVFract$ (-8)
_asm {
; Line 24
	mov	edx, DWORD PTR Mix8_dwDeltaPeriod$[esp-4]
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR Mix8_dwIncDelta$[esp+36], edx
	push	ebx
	push	esi
	mov	edx, DWORD PTR [ecx+44]
	push	edi
	mov	esi, DWORD PTR [ecx+68]
	push	ebp
; Line 32
	mov	ebp, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR Mix8_pcWave$[esp+52], ebp
	mov	DWORD PTR Mix8_vfRVolume$[esp+52], edi
; Line 36
	mov	DWORD PTR Mix8_pfPitch$[esp+52], eax
; Line 37
	shl	eax, 8
	mov	DWORD PTR Mix8_pfPFract$[esp+52], eax
; Line 38
	mov	eax, edx
	shl	eax, 8
	mov	DWORD PTR Mix8_vfLVFract$[esp+52], eax
; Line 39
	mov	eax, edi
	shl	eax, 8
	mov	DWORD PTR Mix8_vfRVFract$[esp+52], eax
; Line 40
	mov	eax, DWORD PTR Mix8_dwLength$[esp+48]
	add	eax, eax
	mov	DWORD PTR Mix8_dwLength$[esp+48], eax
; Line 41
	xor	eax, eax
	cmp	DWORD PTR Mix8_dwLength$[esp+48], eax
	je	$L30782
	mov	ebx, DWORD PTR Mix8_pBuffer$[esp+48]
$L30781:
; Line 43
	mov	ebp, DWORD PTR Mix8_pfSampleLength$[esp+48]
	cmp	ebp, esi
	jg	SHORT $L30783
; Line 45
	mov	ebp, DWORD PTR Mix8_pfLoopLength$[esp+48]
	test	ebp, ebp
	je	$L30782
; Line 46
	sub	esi, ebp
; Line 50
$L30783:
	mov	edi, esi
	mov	ebp, esi
	sar	edi, 12					; 0000000cH
	and	ebp, 4095				; 00000fffH
; Line 51
	mov	DWORD PTR Mix8_dwFract$[esp+52], ebp
; Line 52
	mov	ebp, DWORD PTR Mix8_pfPitch$[esp+52]
	add	esi, ebp
; Line 54
	mov	ebp, DWORD PTR Mix8_dwIncDelta$[esp+52]
	dec	ebp
	mov	DWORD PTR Mix8_dwIncDelta$[esp+52], ebp
; Line 55
	jne	SHORT $L30786
; Line 57
	mov	edx, DWORD PTR Mix8_dwDeltaPeriod$[esp+48]
	mov	ebp, DWORD PTR Mix8_pfDeltaPitch$[esp+48]
	mov	DWORD PTR Mix8_dwIncDelta$[esp+52], edx
; Line 58
	mov	edx, DWORD PTR Mix8_pfPFract$[esp+52]
	add	edx, ebp
	mov	ebp, DWORD PTR Mix8_vfDeltaLVolume$[esp+48]
	mov	DWORD PTR Mix8_pfPFract$[esp+52], edx
; Line 59
	sar	edx, 8
	mov	DWORD PTR Mix8_pfPitch$[esp+52], edx
; Line 60
	mov	edx, DWORD PTR Mix8_vfLVFract$[esp+52]
	add	edx, ebp
	mov	ebp, DWORD PTR Mix8_vfDeltaRVolume$[esp+48]
	mov	DWORD PTR Mix8_vfLVFract$[esp+52], edx
	add	DWORD PTR Mix8_vfRVFract$[esp+52], ebp
; Line 61
	sar	edx, 8
	mov	ebp, DWORD PTR Mix8_vfRVFract$[esp+52]
; Line 63
	sar	ebp, 8
	mov	DWORD PTR Mix8_vfRVolume$[esp+52], ebp
; Line 65
$L30786:
	mov	ebp, DWORD PTR Mix8_pcWave$[esp+52]
	movsx	ebp, BYTE PTR [ebp+edi]
	mov	DWORD PTR Mix8_lLM$[esp+52], ebp
; Line 67
	mov	ebp, DWORD PTR Mix8_pcWave$[esp+52]
	movsx	edi, BYTE PTR [ebp+edi+1]
	mov	ebp, DWORD PTR Mix8_lLM$[esp+52]
	sub	edi, ebp
	imul	edi, DWORD PTR Mix8_dwFract$[esp+52]
	sar	edi, 12					; 0000000cH
	add	edi, ebp
; Line 71
	mov	ebp, edi
	imul	ebp, edx
	imul	edi, DWORD PTR Mix8_vfRVolume$[esp+52]
	sar	ebp, 5
; Line 73
	sar	edi, 5
; Line 90
	add	WORD PTR [ebx], bp
; Line 91
	jno	SHORT $no_oflowl$30788
; Line 92
	mov	WORD PTR [ebx], 32767			; 00007fffH
; Line 93
	js	SHORT $no_oflowl$30788
; Line 94
	mov	WORD PTR [ebx], -32768			; ffff8000H
; Line 95
$no_oflowl$30788:
; Line 96
	add	WORD PTR [ebx+2], di
; Line 97
	jno	SHORT $no_oflowr$30791
; Line 98
	mov	WORD PTR [ebx+2], 32767			; 00007fffH
; Line 99
	js	SHORT $no_oflowr$30791
; Line 100
	mov	WORD PTR [ebx+2], -32768		; ffff8000H
; Line 101
$no_oflowr$30791:
	add	ebx, 4
	add	eax, 2
; Line 104
	cmp	eax, DWORD PTR Mix8_dwLength$[esp+48]
	jb	$L30781
$L30782:
; Line 105
	shr	eax, 1
	mov	edi, DWORD PTR Mix8_vfRVolume$[esp+52]
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+48], edi
; Line 107
	mov	edx, DWORD PTR Mix8_pfPitch$[esp+52]
	mov	DWORD PTR [ecx+68], esi
	pop	ebp
	mov	DWORD PTR [ecx+52], edx
; Line 110
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	32					; 00000020H
 }	//	asm
}	//	Mix8

#endif // _X86_

#ifndef _X86_ 

DWORD DigitalAudio::MixMono8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }
        lM = pcWave[dwPosition];
        lM += ((pcWave[dwPosition + 1] - lM) * dwFract) >> 12;
        lM *= vfVolume;
		lM >>= 5;
#ifndef _X86_

#ifdef _ALPHA_
        int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif // _X86_
		dwI++;
    }
    m_vfLastLVolume = vfVolume;
    m_vfLastRVolume = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}

#else // _X86_

__declspec (naked) DWORD DigitalAudio::MixMono8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)
{
#define MixMono8_pBuffer$ 8
#define MixMono8_dwLength$ 12
#define MixMono8_dwDeltaPeriod$ 16
#define MixMono8_vfDeltaVolume$ 20
#define MixMono8_pfDeltaPitch$ 24
#define MixMono8_pfSampleLength$ 28
#define MixMono8_pfLoopLength$ 32
#define MixMono8_dwIncDelta$ (-16)
#define MixMono8_dwFract$ (-4)
#define MixMono8_pcWave$ (-8)
#define MixMono8_vfVolume$ (-36)
#define MixMono8_pfPitch$ (-32)
#define MixMono8_pfPFract$ (-20)
#define MixMono8_vfVFract$ (-24)
_asm {
; Line 129
	mov	edx, DWORD PTR MixMono8_dwDeltaPeriod$[esp-4]
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR MixMono8_dwIncDelta$[esp+36], edx
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [eax+12]
	push	edi
	mov	esi, DWORD PTR [ecx+68]
	push	ebp
	mov	edx, DWORD PTR [ecx+44]
; Line 135
	mov	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR MixMono8_pcWave$[esp+52], ebx
; Line 137
	mov	DWORD PTR MixMono8_vfVolume$[esp+52], edx
	mov	DWORD PTR MixMono8_pfPitch$[esp+52], eax
; Line 139
	shl	eax, 8
	mov	ebp, DWORD PTR MixMono8_dwLength$[esp+48]
	mov	DWORD PTR MixMono8_pfPFract$[esp+52], eax
; Line 140
	mov	eax, edx
	shl	eax, 8
	mov	DWORD PTR MixMono8_vfVFract$[esp+52], eax
; Line 142
	xor	eax, eax
	cmp	ebp, eax
	je	$L30816
	mov	edi, DWORD PTR MixMono8_pBuffer$[esp+48]
$L30815:
; Line 144
	mov	edx, DWORD PTR MixMono8_pfSampleLength$[esp+48]
	cmp	edx, esi
	jg	SHORT $L30817
; Line 146
	mov	edx, DWORD PTR MixMono8_pfLoopLength$[esp+48]
	test	edx, edx
	je	$L30816
; Line 147
	sub	esi, edx
; Line 151
$L30817:
	mov	ebx, esi
	mov	edx, esi
	sar	ebx, 12					; 0000000cH
	and	edx, 4095				; 00000fffH
; Line 152
	mov	ebp, DWORD PTR MixMono8_pfPitch$[esp+52]
	mov	DWORD PTR MixMono8_dwFract$[esp+52], edx
; Line 153
	add	esi, ebp
	mov	edx, DWORD PTR MixMono8_dwIncDelta$[esp+52]
; Line 154
	dec	edx
	mov	DWORD PTR MixMono8_dwIncDelta$[esp+52], edx
; Line 155
	jne	SHORT $L30820
; Line 157
	mov	edx, DWORD PTR MixMono8_dwDeltaPeriod$[esp+48]
	mov	ebp, DWORD PTR MixMono8_pfDeltaPitch$[esp+48]
	mov	DWORD PTR MixMono8_dwIncDelta$[esp+52], edx
; Line 158
	mov	edx, DWORD PTR MixMono8_pfPFract$[esp+52]
	add	edx, ebp
	mov	ebp, DWORD PTR MixMono8_vfDeltaVolume$[esp+48]
	mov	DWORD PTR MixMono8_pfPFract$[esp+52], edx
; Line 159
	sar	edx, 8
	mov	DWORD PTR MixMono8_pfPitch$[esp+52], edx
; Line 160
	mov	edx, DWORD PTR MixMono8_vfVFract$[esp+52]
	add	edx, ebp
	mov	DWORD PTR MixMono8_vfVFract$[esp+52], edx
; Line 161
	sar	edx, 8
	mov	DWORD PTR MixMono8_vfVolume$[esp+52], edx
; Line 163
$L30820:
	mov	edx, DWORD PTR MixMono8_pcWave$[esp+52]
	movsx	ebp, BYTE PTR [ebx+edx]
; Line 164
	movsx	ebx, BYTE PTR [ebx+edx+1]
	sub	ebx, ebp
	mov	edx, DWORD PTR MixMono8_vfVolume$[esp+52]
	imul	ebx, DWORD PTR MixMono8_dwFract$[esp+52]
	sar	ebx, 12					; 0000000cH
; Line 165
	add	ebp, ebx
	imul	edx, ebp
; Line 166
	sar	edx, 5
; Line 176
	add	WORD PTR [edi], dx
; Line 177
	jno	SHORT $no_oflow$30822
; Line 178
	mov	WORD PTR [edi], 32767			; 00007fffH
; Line 179
	js	SHORT $no_oflow$30822
; Line 180
	mov	WORD PTR [edi], -32768			; ffff8000H
; Line 181
$no_oflow$30822:
	add	edi, 2
	inc	eax
; Line 186
	cmp	eax, DWORD PTR MixMono8_dwLength$[esp+48]
	jb	$L30815
$L30816:
; Line 187
	mov	edx, DWORD PTR MixMono8_vfVolume$[esp+52]
	mov	ebx, DWORD PTR MixMono8_pfPitch$[esp+52]
	pop	ebp
	mov	DWORD PTR [ecx+44], edx
; Line 188
	pop	edi
	mov	DWORD PTR [ecx+48], edx
; Line 189
	mov	DWORD PTR [ecx+52], ebx
	mov	DWORD PTR [ecx+68], esi
; Line 192
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	28					; 0000001cH
 }	//	asm
}	//	MixMono8

#endif // _X86_

#ifndef _X86_ 

DWORD DigitalAudio::Mix8NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{

    DWORD dwI;
    PFRACT pfSamplePos;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
    pfSamplePos = m_pfLastSample >> 12;
    pfSampleLength >>= 12;
    pfLoopLength >>= 12;

	dwLength <<= 1;
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        pfSamplePos++;
        dwIncDelta--;
        if (!dwIncDelta)
        {
            dwIncDelta = dwDeltaPeriod;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        lM = (long) pcWave[pfSamplePos];
        lLM = lM;
        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;
        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	
		pBuffer[dwI+1] += (short) lM;
        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_
		dwI += 2;
    }
    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastSample = pfSamplePos << 12;
    return (dwI >> 1);
}

#else // _X86_

__declspec (naked) DWORD DigitalAudio::Mix8NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)
{

#define Mix8NoI_pBuffer$ 8
#define Mix8NoI_dwLength$ 12
#define Mix8NoI_dwDeltaPeriod$ 16
#define Mix8NoI_vfDeltaLVolume$ 20
#define Mix8NoI_vfDeltaRVolume$ 24
#define Mix8NoI_pfSampleLength$ 28
#define Mix8NoI_pfLoopLength$ 32
#define Mix8NoI_lM$ (-8)
#define Mix8NoI_dwIncDelta$ (-12)
#define Mix8NoI_pcWave$ (-4)
#define Mix8NoI_vfRVolume$ (-24)
#define Mix8NoI_vfLVFract$ (-16)
#define Mix8NoI_vfRVFract$ (-20)

_asm {
	mov	edx, DWORD PTR Mix8NoI_dwDeltaPeriod$[esp-4]
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR Mix8NoI_dwIncDelta$[esp+24], edx
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [eax+12]
	push	edi
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR Mix8NoI_pcWave$[esp+36], ebx
	push	ebp
; Line 534
	mov	edi, DWORD PTR [ecx+48]
	mov	eax, edx
	shl	eax, 8
	mov	esi, DWORD PTR [ecx+68]
	sar	esi, 12					; 0000000cH
	mov	ebp, DWORD PTR Mix8NoI_pfSampleLength$[esp+36]
	sar	ebp, 12					; 0000000cH
	mov	DWORD PTR Mix8NoI_vfRVolume$[esp+40], edi
; Line 535
	mov	DWORD PTR Mix8NoI_vfLVFract$[esp+40], eax
	mov	DWORD PTR Mix8NoI_pfSampleLength$[esp+36], ebp
; Line 536
	mov	eax, edi
	shl	eax, 8
	mov	DWORD PTR Mix8NoI_vfRVFract$[esp+40], eax
; Line 539
	mov	eax, DWORD PTR Mix8NoI_pfLoopLength$[esp+36]
	sar	eax, 12					; 0000000cH
	mov	DWORD PTR Mix8NoI_pfLoopLength$[esp+36], eax
; Line 541
	mov	eax, DWORD PTR Mix8NoI_dwLength$[esp+36]
	add	eax, eax
	mov	DWORD PTR Mix8NoI_dwLength$[esp+36], eax
; Line 542
	xor	eax, eax
	cmp	DWORD PTR Mix8NoI_dwLength$[esp+36], eax
	je	$L30806
	mov	edi, DWORD PTR Mix8NoI_pBuffer$[esp+36]
$L30805:
; Line 544
	mov	ebx, DWORD PTR Mix8NoI_pfSampleLength$[esp+36]
	cmp	esi, ebx
	jl	SHORT $L30807
; Line 546
	mov	ebx, DWORD PTR Mix8NoI_pfLoopLength$[esp+36]
	test	ebx, ebx
	je	$L30806
; Line 547
	sub	esi, ebx
; Line 551
$L30807:
	inc	esi
	mov	ebx, DWORD PTR Mix8NoI_dwIncDelta$[esp+40]
; Line 552
	dec	ebx
	mov	DWORD PTR Mix8NoI_dwIncDelta$[esp+40], ebx
; Line 553
	jne	SHORT $L30810
; Line 555
	mov	edx, DWORD PTR Mix8NoI_dwDeltaPeriod$[esp+36]
	mov	ebx, DWORD PTR Mix8NoI_vfDeltaLVolume$[esp+36]
	mov	ebp, DWORD PTR Mix8NoI_vfLVFract$[esp+40]
	mov	DWORD PTR Mix8NoI_dwIncDelta$[esp+40], edx
; Line 556
	add	ebp, ebx
	mov	ebx, DWORD PTR Mix8NoI_vfDeltaRVolume$[esp+36]
	mov	edx, ebp
	mov	DWORD PTR Mix8NoI_vfLVFract$[esp+40], ebp
; Line 557
	sar	edx, 8
	mov	ebp, DWORD PTR Mix8NoI_vfRVFract$[esp+40]
; Line 558
	add	ebp, ebx
	mov	ebx, ebp
	mov	DWORD PTR Mix8NoI_vfRVFract$[esp+40], ebp
; Line 559
	sar	ebx, 8
	mov	DWORD PTR Mix8NoI_vfRVolume$[esp+40], ebx
; Line 561
$L30810:
	mov	ebx, DWORD PTR Mix8NoI_pcWave$[esp+40]
	movsx	ebp, BYTE PTR [esi+ebx]
	mov	ebx, DWORD PTR Mix8NoI_vfRVolume$[esp+40]
	mov	DWORD PTR Mix8NoI_lM$[esp+40], ebp
; Line 564
	imul	ebx, DWORD PTR Mix8NoI_lM$[esp+40]
	sar	ebx, 5
	mov	ebp, edx
	imul	ebp, DWORD PTR Mix8NoI_lM$[esp+40]
	sar	ebp, 5
; Line 582
	add	WORD PTR [edi], bp
; Line 583
	jno	SHORT $no_oflowl$30813
; Line 584
	mov	WORD PTR [edi], 32767			; 00007fffH
; Line 585
	js	SHORT $no_oflowl$30813
; Line 586
	mov	WORD PTR [edi], -32768			; ffff8000H
; Line 587
$no_oflowl$30813:
; Line 588
	add	WORD PTR [edi+2], bx
; Line 589
	jno	SHORT $no_oflowr$30816
; Line 590
	mov	WORD PTR [edi+2], 32767			; 00007fffH
; Line 591
	js	SHORT $no_oflowr$30816
; Line 592
	mov	WORD PTR [edi+2], -32768		; ffff8000H
; Line 593
$no_oflowr$30816:
	add	edi, 4
	add	eax, 2
; Line 596
	cmp	DWORD PTR Mix8NoI_dwLength$[esp+36], eax
	ja	$L30805
$L30806:
; Line 597
	shl	esi, 12					; 0000000cH
	mov	edi, DWORD PTR Mix8NoI_vfRVolume$[esp+40]
	shr	eax, 1
	pop	ebp
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+48], edi
; Line 599
	pop	edi
	mov	DWORD PTR [ecx+68], esi
; Line 601
	pop	esi
	pop	ebx
	add	esp, 24					; 00000018H
	ret	28					; 0000001cH
 }	//	asm
}	//	Mix8NoI

#endif // _X86_

#ifndef _X86_ 

DWORD DigitalAudio::MixMono8NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    PFRACT pfSamplePos;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    VFRACT vfVolume = m_vfLastLVolume;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.
    pfSamplePos = m_pfLastSample >> 12;
    pfSampleLength >>= 12;
    pfLoopLength >>= 12;

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        pfSamplePos++;
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }
        lM = (long) pcWave[pfSamplePos];
        lM *= vfVolume; 
		lM >>= 5;
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif // _X86_
		dwI++;
    }
    m_vfLastLVolume = vfVolume;
    m_pfLastSample = pfSamplePos << 12;
    return (dwI);
}

#else // _X86_

__declspec (naked) DWORD DigitalAudio::MixMono8NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{
#define MixMono8NoI_pBuffer$ 8
#define MixMono8NoI_dwLength$ 12
#define MixMono8NoI_dwDeltaPeriod$ 16
#define MixMono8NoI_vfDeltaVolume$ 20
#define MixMono8NoI_pfSampleLength$ 24
#define MixMono8NoI_pfLoopLength$ 28
#define MixMono8NoI_dwIncDelta$ (-8)
#define MixMono8NoI_pcWave$ (-4)
#define MixMono8NoI_vfVFract$ (-12)
_asm {
	mov	edx, DWORD PTR MixMono8NoI_dwDeltaPeriod$[esp-4]
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR MixMono8NoI_dwIncDelta$[esp+12], edx
	push	ebx
	push	esi
	mov	edx, DWORD PTR [ecx+44]
	push	edi
	push	ebp
; Line 612
	mov	ebp, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [ecx+68]
	sar	ebx, 12					; 0000000cH
	mov	eax, edx
	shl	eax, 8
	mov	esi, DWORD PTR MixMono8NoI_pfSampleLength$[esp+24]
	sar	esi, 12					; 0000000cH
	mov	edi, DWORD PTR MixMono8NoI_pfLoopLength$[esp+24]
	sar	edi, 12					; 0000000cH
	mov	DWORD PTR MixMono8NoI_pcWave$[esp+28], ebp
; Line 614
	mov	ebp, DWORD PTR MixMono8NoI_dwLength$[esp+24]
	mov	DWORD PTR MixMono8NoI_vfVFract$[esp+28], eax
; Line 616
	xor	eax, eax
	mov	DWORD PTR MixMono8NoI_pfSampleLength$[esp+24], esi
; Line 619
	cmp	ebp, eax
	je	SHORT $L30836
	mov	esi, DWORD PTR MixMono8NoI_pBuffer$[esp+24]
$L30835:
; Line 621
	mov	ebp, DWORD PTR MixMono8NoI_pfSampleLength$[esp+24]
	cmp	ebx, ebp
	jl	SHORT $L30837
; Line 623
	test	edi, edi
	je	SHORT $L30836
; Line 624
	sub	ebx, edi
; Line 628
$L30837:
	inc	ebx
	mov	ebp, DWORD PTR MixMono8NoI_dwIncDelta$[esp+28]
; Line 629
	dec	ebp
	mov	DWORD PTR MixMono8NoI_dwIncDelta$[esp+28], ebp
; Line 630
	jne	SHORT $L30840
; Line 632
	mov	edx, DWORD PTR MixMono8NoI_dwDeltaPeriod$[esp+24]
	mov	ebp, DWORD PTR MixMono8NoI_vfDeltaVolume$[esp+24]
	mov	DWORD PTR MixMono8NoI_dwIncDelta$[esp+28], edx
; Line 633
	mov	edx, DWORD PTR MixMono8NoI_vfVFract$[esp+28]
	add	edx, ebp
	mov	DWORD PTR MixMono8NoI_vfVFract$[esp+28], edx
; Line 634
	sar	edx, 8
; Line 636
$L30840:
; Line 648
	mov	ebp, DWORD PTR MixMono8NoI_pcWave$[esp+28]
	movsx	ebp, BYTE PTR [ebx+ebp]
	imul	ebp, edx
	sar	ebp, 5
	add	WORD PTR [esi], bp
; Line 649
	jno	SHORT $no_oflow$30843
; Line 650
	mov	WORD PTR [esi], 32767			; 00007fffH
; Line 651
	js	SHORT $no_oflow$30843
; Line 652
	mov	WORD PTR [esi], -32768			; ffff8000H
; Line 653
$no_oflow$30843:
	add	esi, 2
	inc	eax
; Line 656
	cmp	DWORD PTR MixMono8NoI_dwLength$[esp+24], eax
	ja	SHORT $L30835
$L30836:
; Line 657
	shl	ebx, 12					; 0000000cH
	pop	ebp
	pop	edi
	mov	DWORD PTR [ecx+44], edx
; Line 658
	pop	esi
	mov	DWORD PTR [ecx+68], ebx
; Line 660
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	24					; 00000018H
}	//	asm
}	//	MixMono8NoI

#endif // _X86_

#ifndef _X86_ 

DWORD DigitalAudio::Mix16(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        lA = pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 13;
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lA, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else

// Generic non ALPHA, non X86 case.  This is used for IA64 at least.
// Note that this would probably work for Alpha as well.  I don't know why
// they wrote such convoluted code as they did above.  Maybe it was fast.

		// First add what is in the buffer to our sample values.
		lA+=pBuffer[dwI];
		lM+=pBuffer[dwI+1];

		// Now saturate them to 16 bit sample sizes.
		if (lA>32767)
			lA=32767;
		if (lM>32767)
			lM=32767;
		if (lA<-32768)
			lA=-32768;
		if (lM<-32768)
			lM=-32768;

		// Now write out the 16 bit pegged values to the buffer.
		pBuffer[dwI]=(short)lA;
		pBuffer[dwI+1]=(short)lM;

// NOTE!  TODO!  The whole algorithm here is sub-optimal!
// We are saturating EACH TIME we mix a new voice.  That is definitely lower quality.  We should
// be mixing into an internal buffer that is big enough to hold non pegged values,
// and we should saturate only AFTER all of the data is mixed.

#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;
        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	
        lM *= vfRVolume;
		lM >>= 13;
		pBuffer[dwI+1] += (short) lM;
        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_
		dwI += 2;
    }
    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

#else // _X86_

__declspec( naked ) DWORD DigitalAudio::Mix16(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)
{

#define Mix16_pBuffer$ (8)
#define Mix16_dwLength$ (12)
#define Mix16_dwDeltaPeriod$ 16
#define Mix16_vfDeltaLVolume$ 20
#define Mix16_vfDeltaRVolume$ 24
#define Mix16_pfDeltaPitch$ 28
#define Mix16_pfSampleLength$ 32
#define Mix16_pfLoopLength$ 36
#define Mix16_lA$ (-20)
#define Mix16_dwIncDelta$ (-24)
#define Mix16_dwFract$ (-4)
#define Mix16_pcWave$ (-16)
#define Mix16_vfLVolume$ (-32)
#define Mix16_vfRVolume$ (-36)
#define Mix16_pfPFract$ (-28)
#define Mix16_vfLVFract$ (-8)
#define Mix16_vfRVFract$ (-12)
_asm {
; Line 952
	mov	edx, DWORD PTR Mix16_dwDeltaPeriod$[esp-4]
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR Mix16_dwIncDelta$[esp+36], edx
	push	ebx
	push	esi
	push	edi
	push	ebp
	mov	esi, DWORD PTR [ecx+68]
; Line 959
	mov	ebp, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR Mix16_pcWave$[esp+52], ebp
	mov	DWORD PTR Mix16_vfLVolume$[esp+52], edi
; Line 962
	mov	DWORD PTR Mix16_vfRVolume$[esp+52], eax
; Line 964
	mov	eax, edx
	shl	eax, 8
	mov	DWORD PTR Mix16_pfPFract$[esp+52], eax
; Line 965
	mov	eax, edi
	shl	eax, 8
	mov	DWORD PTR Mix16_vfLVFract$[esp+52], eax
; Line 966
	mov	eax, DWORD PTR Mix16_vfRVolume$[esp+52]
	shl	eax, 8
	mov	DWORD PTR Mix16_vfRVFract$[esp+52], eax
; Line 967
	mov	eax, DWORD PTR Mix16_dwLength$[esp+48]
	add	eax, eax
	mov	DWORD PTR Mix16_dwLength$[esp+48], eax
; Line 969
	xor	eax, eax
	cmp	DWORD PTR Mix16_dwLength$[esp+48], eax
	je	$L30838
	mov	ebx, DWORD PTR Mix16_pBuffer$[esp+48]
$L30837:
; Line 971
	mov	ebp, DWORD PTR Mix16_pfSampleLength$[esp+48]
	cmp	ebp, esi
	jg	SHORT $L30839
; Line 973
	mov	ebp, DWORD PTR Mix16_pfLoopLength$[esp+48]
	test	ebp, ebp
	je	$L30838
; Line 975
	sub	esi, ebp
; Line 980
$L30839:
	mov	edi, esi
	mov	ebp, esi
	sar	edi, 12					; 0000000cH
	and	ebp, 4095				; 00000fffH
; Line 981
	add	esi, edx
	mov	DWORD PTR Mix16_dwFract$[esp+52], ebp
; Line 983
	dec	DWORD PTR Mix16_dwIncDelta$[esp+52]
; Line 984
	jne	SHORT $L30842
; Line 986
	mov	edx, DWORD PTR Mix16_dwDeltaPeriod$[esp+48]
	mov	ebp, DWORD PTR Mix16_pfDeltaPitch$[esp+48]
	mov	DWORD PTR Mix16_dwIncDelta$[esp+52], edx
; Line 987
	mov	edx, DWORD PTR Mix16_pfPFract$[esp+52]
	add	edx, ebp
	mov	ebp, DWORD PTR Mix16_vfDeltaLVolume$[esp+48]
	mov	DWORD PTR Mix16_pfPFract$[esp+52], edx
	add	DWORD PTR Mix16_vfLVFract$[esp+52], ebp
; Line 988
	sar	edx, 8
	mov	ebp, DWORD PTR Mix16_vfLVFract$[esp+52]
; Line 990
	sar	ebp, 8
	mov	DWORD PTR Mix16_vfLVolume$[esp+52], ebp
; Line 991
	mov	ebp, DWORD PTR Mix16_vfDeltaRVolume$[esp+48]
	add	DWORD PTR Mix16_vfRVFract$[esp+52], ebp
; Line 992
	mov	ebp, DWORD PTR Mix16_vfRVFract$[esp+52]
	sar	ebp, 8
	mov	DWORD PTR Mix16_vfRVolume$[esp+52], ebp
; Line 994
$L30842:
	mov	ebp, DWORD PTR Mix16_pcWave$[esp+52]
	movsx	ebp, WORD PTR [ebp+edi*2]
	mov	DWORD PTR Mix16_lA$[esp+52], ebp
; Line 997
	mov	ebp, DWORD PTR Mix16_pcWave$[esp+52]
	movsx	edi, WORD PTR [ebp+edi*2+2]
	mov	ebp, DWORD PTR Mix16_lA$[esp+52]
	sub	edi, ebp
	imul	edi, DWORD PTR Mix16_dwFract$[esp+52]
	sar	edi, 12					; 0000000cH
	add	ebp, edi
; Line 1018
	mov	edi, DWORD PTR Mix16_vfLVolume$[esp+52]
	imul	edi, ebp
	sar	edi, 13					; 0000000dH
	add	WORD PTR [ebx], di
; Line 1019
	jno	SHORT $no_oflowl$30845
; Line 1020
	mov	WORD PTR [ebx], 32767			; 00007fffH
; Line 1021
	js	SHORT $no_oflowl$30845
; Line 1022
	mov	WORD PTR [ebx], -32768			; ffff8000H
; Line 1023
$no_oflowl$30845:
; Line 1024
	mov	edi, DWORD PTR Mix16_vfRVolume$[esp+52]
	imul	edi, ebp
; Line 1025
	sar	edi, 13					; 0000000dH
; Line 1026
	add	WORD PTR [ebx+2], di
; Line 1027
	jno	SHORT $no_oflowr$30848
; Line 1028
	mov	WORD PTR [ebx+2], 32767			; 00007fffH
; Line 1029
	js	SHORT $no_oflowr$30848
; Line 1030
	mov	WORD PTR [ebx+2], -32768		; ffff8000H
; Line 1031
$no_oflowr$30848:
	add	ebx, 4
	add	eax, 2
; Line 1039
	cmp	DWORD PTR Mix16_dwLength$[esp+48], eax
	ja	$L30837
$L30838:
; Line 1040
	shr	eax, 1
	mov	edi, DWORD PTR Mix16_vfLVolume$[esp+52]
	mov	ebx, DWORD PTR Mix16_vfRVolume$[esp+52]
	mov	DWORD PTR [ecx+44], edi
; Line 1041
	pop	ebp
	mov	DWORD PTR [ecx+48], ebx
; Line 1042
	pop	edi
	mov	DWORD PTR [ecx+52], edx
; Line 1043
	mov	DWORD PTR [ecx+68], esi
; Line 1045
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	32					; 00000020H
 }	//	asm
}	//	Mix16

#endif // _X86_

#ifndef _X86_ 

DWORD DigitalAudio::Mix16NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{

    DWORD dwI;
    long lM, lRM;
    DWORD dwIncDelta = dwDeltaPeriod;
    short * pcWave = m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample >> 12;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
    pfSampleLength >>= 12;
    pfLoopLength >>= 12;
	dwLength <<= 1;
	
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        pfSamplePos++;
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        lM = (long) pcWave[pfSamplePos];
        lRM = lM;
        lRM *= vfLVolume;
        lRM >>= 13;         // Signal bumps up to 15 bits.
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lRM, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		lM *= vfRVolume;
		lM >>= 13;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lRM;
        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short)0x8000;
no_oflowl:	
        lM *= vfRVolume;
		lM >>= 13;
		pBuffer[dwI+1] += (short) lM;
        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_
		dwI += 2;
    }
    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastSample = pfSamplePos << 12;
    return (dwI >> 1);
}

#else // _X86_

__declspec( naked ) DWORD DigitalAudio::Mix16NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{
#define Mix16NoI_pBuffer$ 8
#define Mix16NoI_dwLength$ 12
#define Mix16NoI_dwDeltaPeriod$ 16
#define Mix16NoI_vfDeltaLVolume$ 20
#define Mix16NoI_vfDeltaRVolume$ 24
#define Mix16NoI_pfSampleLength$ 28
#define Mix16NoI_pfLoopLength$ 32
#define Mix16NoI_lM$ (-8)
#define Mix16NoI_dwIncDelta$ (-12)
#define Mix16NoI_pcWave$ (-4)
#define Mix16NoI_vfLVFract$ (-16)
#define Mix16NoI_vfRVFract$ (-20)
_asm {
; Line 1238
	mov	edx, DWORD PTR Mix16NoI_dwDeltaPeriod$[esp-4]
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR Mix16NoI_dwIncDelta$[esp+20], edx
	push	ebx
	push	esi
	push	edi
	push	ebp
	mov	esi, DWORD PTR [ecx+68]
; Line 1243
	sar	esi, 12					; 0000000cH
	mov	ebp, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+44]
	mov	ebx, DWORD PTR [ecx+48]
	mov	eax, edx
	mov	DWORD PTR Mix16NoI_pcWave$[esp+36], ebp
; Line 1247
	shl	eax, 8
	mov	edi, DWORD PTR Mix16NoI_pfSampleLength$[esp+32]
	sar	edi, 12					; 0000000cH
	mov	DWORD PTR Mix16NoI_vfLVFract$[esp+36], eax
; Line 1248
	mov	eax, ebx
	mov	DWORD PTR Mix16NoI_pfSampleLength$[esp+32], edi
	shl	eax, 8
	mov	DWORD PTR Mix16NoI_vfRVFract$[esp+36], eax
; Line 1250
	mov	eax, DWORD PTR Mix16NoI_pfLoopLength$[esp+32]
	sar	eax, 12					; 0000000cH
	mov	DWORD PTR Mix16NoI_pfLoopLength$[esp+32], eax
; Line 1251
	mov	eax, DWORD PTR Mix16NoI_dwLength$[esp+32]
	add	eax, eax
	mov	DWORD PTR Mix16NoI_dwLength$[esp+32], eax
; Line 1253
	xor	eax, eax
	cmp	DWORD PTR Mix16NoI_dwLength$[esp+32], eax
	je	$L30871
	mov	edi, DWORD PTR Mix16NoI_pBuffer$[esp+32]
$L30870:
; Line 1255
	mov	ebp, DWORD PTR Mix16NoI_pfSampleLength$[esp+32]
	cmp	esi, ebp
	jl	SHORT $L30872
; Line 1257
	mov	ebp, DWORD PTR Mix16NoI_pfLoopLength$[esp+32]
	test	ebp, ebp
	je	$L30871
; Line 1258
	sub	esi, ebp
; Line 1262
$L30872:
	inc	esi
	mov	ebp, DWORD PTR Mix16NoI_dwIncDelta$[esp+36]
; Line 1263
	dec	ebp
	mov	DWORD PTR Mix16NoI_dwIncDelta$[esp+36], ebp
; Line 1264
	jne	SHORT $L30875
; Line 1266
	mov	edx, DWORD PTR Mix16NoI_dwDeltaPeriod$[esp+32]
	mov	ebx, DWORD PTR Mix16NoI_vfDeltaLVolume$[esp+32]
	mov	ebp, DWORD PTR Mix16NoI_vfLVFract$[esp+36]
	mov	DWORD PTR Mix16NoI_dwIncDelta$[esp+36], edx
; Line 1267
	add	ebp, ebx
	mov	ebx, DWORD PTR Mix16NoI_vfDeltaRVolume$[esp+32]
	mov	edx, ebp
	mov	DWORD PTR Mix16NoI_vfLVFract$[esp+36], ebp
; Line 1268
	sar	edx, 8
	mov	ebp, DWORD PTR Mix16NoI_vfRVFract$[esp+36]
; Line 1269
	add	ebp, ebx
	mov	ebx, ebp
	mov	DWORD PTR Mix16NoI_vfRVFract$[esp+36], ebp
; Line 1270
	sar	ebx, 8
; Line 1272
$L30875:
	mov	ebp, DWORD PTR Mix16NoI_pcWave$[esp+36]
	movsx	ebp, WORD PTR [ebp+esi*2]
	mov	DWORD PTR Mix16NoI_lM$[esp+36], ebp
; Line 1293
	mov	ebp, edx
	imul	ebp, DWORD PTR Mix16NoI_lM$[esp+36]
	sar	ebp, 13					; 0000000dH
	add	WORD PTR [edi], bp
; Line 1294
	jno	SHORT $no_oflowl$30878
; Line 1295
	mov	WORD PTR [edi], 32767			; 00007fffH
; Line 1296
	js	SHORT $no_oflowl$30878
; Line 1297
	mov	WORD PTR [edi], -32768			; ffff8000H
; Line 1298
$no_oflowl$30878:
; Line 1299
	mov	ebp, ebx
	imul	ebp, DWORD PTR Mix16NoI_lM$[esp+36]
; Line 1300
	sar	ebp, 13					; 0000000dH
; Line 1301
	add	WORD PTR [edi+2], bp
; Line 1302
	jno	SHORT $no_oflowr$30881
; Line 1303
	mov	WORD PTR [edi+2], 32767			; 00007fffH
; Line 1304
	js	SHORT $no_oflowr$30881
; Line 1305
	mov	WORD PTR [edi+2], -32768		; ffff8000H
; Line 1306
$no_oflowr$30881:
	add	edi, 4
	add	eax, 2
; Line 1314
	cmp	DWORD PTR Mix16NoI_dwLength$[esp+32], eax
	ja	$L30870
$L30871:
; Line 1315
	shl	esi, 12					; 0000000cH
	pop	ebp
	shr	eax, 1
	pop	edi
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+48], ebx
; Line 1317
	mov	DWORD PTR [ecx+68], esi
; Line 1319
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	28					; 0000001cH
 }	//	asm
}	//	Mix16NoI

#endif // _X86_

#ifndef _X86_

DWORD DigitalAudio::MixMono16(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }
        lA = (long) pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        lM *= vfVolume; 
        lM >>= 13;         // Signal bumps up to 12 bits.

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86_
		dwI++;
    }
    m_vfLastLVolume = vfVolume;
    m_vfLastRVolume = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}

#else // _X86_

__declspec( naked ) DWORD DigitalAudio::MixMono16(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
#define MixMono16_pBuffer$ 8
#define MixMono16_dwLength$ 12
#define MixMono16_dwDeltaPeriod$ 16
#define MixMono16_vfDeltaVolume$ 20
#define MixMono16_pfDeltaPitch$ 24
#define MixMono16_pfSampleLength$ 28
#define MixMono16_pfLoopLength$ 32
#define MixMono16_lA$ (-12)
#define MixMono16_dwIncDelta$ (-16)
#define MixMono16_dwFract$ (-4)
#define MixMono16_pcWave$ (-8)
#define MixMono16_pfPitch$ (-28)
#define MixMono16_pfPFract$ (-20)
#define MixMono16_vfVFract$ (-24)
_asm {
; Line 1325
	mov	edx, DWORD PTR MixMono16_dwDeltaPeriod$[esp-4]
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR MixMono16_dwIncDelta$[esp+28], edx
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [eax+12]
	push	edi
	mov	esi, DWORD PTR [ecx+68]
	push	ebp
	mov	edx, DWORD PTR [ecx+52]
; Line 1332
	mov	edi, DWORD PTR [ecx+44]
	mov	eax, edx
	shl	eax, 8
	mov	DWORD PTR MixMono16_pcWave$[esp+44], ebx
; Line 1335
	mov	ebp, DWORD PTR MixMono16_dwLength$[esp+40]
	mov	DWORD PTR MixMono16_pfPitch$[esp+44], edx
; Line 1336
	mov	DWORD PTR MixMono16_pfPFract$[esp+44], eax
; Line 1337
	mov	eax, edi
	shl	eax, 8
	mov	DWORD PTR MixMono16_vfVFract$[esp+44], eax
; Line 1339
	xor	eax, eax
	cmp	ebp, eax
	je	$L30906
	mov	ebx, DWORD PTR MixMono16_pBuffer$[esp+40]
$L30905:
; Line 1341
	mov	edx, DWORD PTR MixMono16_pfSampleLength$[esp+40]
	cmp	esi, edx
	jl	SHORT $L30907
; Line 1343
	mov	edx, DWORD PTR MixMono16_pfLoopLength$[esp+40]
	test	edx, edx
	je	$L30906
; Line 1344
	sub	esi, edx
; Line 1348
$L30907:
	mov	ebp, esi
	mov	edx, esi
	sar	ebp, 12					; 0000000cH
	and	edx, 4095				; 00000fffH
; Line 1349
	mov	DWORD PTR MixMono16_dwFract$[esp+44], edx
; Line 1350
	mov	edx, DWORD PTR MixMono16_pfPitch$[esp+44]
	add	esi, edx
; Line 1351
	mov	edx, DWORD PTR MixMono16_dwIncDelta$[esp+44]
	dec	edx
	mov	DWORD PTR MixMono16_dwIncDelta$[esp+44], edx
; Line 1352
	jne	SHORT $L30910
; Line 1354
	mov	edx, DWORD PTR MixMono16_dwDeltaPeriod$[esp+40]
	mov	edi, DWORD PTR MixMono16_pfDeltaPitch$[esp+40]
	mov	DWORD PTR MixMono16_dwIncDelta$[esp+44], edx
; Line 1355
	mov	edx, DWORD PTR MixMono16_pfPFract$[esp+44]
	add	edx, edi
	mov	edi, DWORD PTR MixMono16_vfDeltaVolume$[esp+40]
	mov	DWORD PTR MixMono16_pfPFract$[esp+44], edx
; Line 1356
	sar	edx, 8
	mov	DWORD PTR MixMono16_pfPitch$[esp+44], edx
; Line 1357
	mov	edx, DWORD PTR MixMono16_vfVFract$[esp+44]
	add	edx, edi
	mov	edi, edx
	mov	DWORD PTR MixMono16_vfVFract$[esp+44], edx
; Line 1358
	sar	edi, 8
; Line 1360
$L30910:
	mov	edx, DWORD PTR MixMono16_pcWave$[esp+44]
	movsx	edx, WORD PTR [edx+ebp*2]
	mov	DWORD PTR MixMono16_lA$[esp+44], edx
; Line 1375
	mov	edx, DWORD PTR MixMono16_pcWave$[esp+44]
	movsx	edx, WORD PTR [edx+ebp*2+2]
	mov	ebp, DWORD PTR MixMono16_lA$[esp+44]
	sub	edx, ebp
	imul	edx, DWORD PTR MixMono16_dwFract$[esp+44]
	sar	edx, 12					; 0000000cH
	add	edx, ebp
	imul	edx, edi
	sar	edx, 13					; 0000000dH
	add	WORD PTR [ebx], dx
; Line 1376
	jno	SHORT $no_oflow$30913
; Line 1377
	mov	WORD PTR [ebx], 32767			; 00007fffH
; Line 1378
	js	SHORT $no_oflow$30913
; Line 1379
	mov	WORD PTR [ebx], -32768			; ffff8000H
; Line 1380
$no_oflow$30913:
	add	ebx, 2
	inc	eax
; Line 1383
	cmp	DWORD PTR MixMono16_dwLength$[esp+40], eax
	ja	$L30905
$L30906:
; Line 1384
	mov	edx, DWORD PTR MixMono16_pfPitch$[esp+44]
	mov	DWORD PTR [ecx+44], edi
; Line 1385
	pop	ebp
	mov	DWORD PTR [ecx+48], edi
; Line 1386
	pop	edi
	mov	DWORD PTR [ecx+52], edx
; Line 1387
	mov	DWORD PTR [ecx+68], esi
; Line 1389
	pop	esi
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	28					; 0000001cH
 }	//	asm
}	//	MixMono16

#endif // _X86_

#ifndef _X86_

DWORD DigitalAudio::MixMono16NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    short * pcWave = m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample >> 12;
    VFRACT vfVolume = m_vfLastLVolume;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.
    pfSampleLength >>= 12;
    pfLoopLength >>= 12;

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        pfSamplePos++;
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            vfVolume += vfDeltaVolume;

            dwIncDelta = dwDeltaPeriod;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }
        lM = (long) pcWave[pfSamplePos];
        lM *= vfVolume;
        lM >>= 13;
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86_
		dwI++;
    }
    m_vfLastLVolume = vfVolume;
    m_pfLastSample = pfSamplePos << 12;
    return (dwI);
}

#else // _X86_

__declspec( naked ) DWORD DigitalAudio::MixMono16NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{
#define MixMono16NoI_pBuffer$ 8
#define MixMono16NoI_dwLength$ 12
#define MixMono16NoI_dwDeltaPeriod$ 16
#define MixMono16NoI_vfDeltaVolume$ 20
#define MixMono16NoI_pfSampleLength$ 24
#define MixMono16NoI_pfLoopLength$ 28
#define MixMono16NoI_dwIncDelta$ (-8)
#define MixMono16NoI_pcWave$ (-4)
#define MixMono16NoI_vfVFract$ (-12)
_asm {
; Line 1395
	mov	edx, DWORD PTR MixMono16NoI_dwDeltaPeriod$[esp-4]
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
;	npad	1
	mov	DWORD PTR MixMono16NoI_dwIncDelta$[esp+12], edx
	push	ebx
	push	esi
	push	edi
	push	ebp
	mov	edi, DWORD PTR [ecx+68]
; Line 1399
	sar	edi, 12					; 0000000cH
	mov	ebp, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+44]
	mov	ebx, DWORD PTR MixMono16NoI_pfSampleLength$[esp+24]
	sar	ebx, 12					; 0000000cH
	mov	eax, edx
	shl	eax, 8
	mov	DWORD PTR MixMono16NoI_pcWave$[esp+28], ebp
; Line 1402
	mov	esi, DWORD PTR MixMono16NoI_dwLength$[esp+24]
	mov	DWORD PTR MixMono16NoI_vfVFract$[esp+28], eax
; Line 1403
	xor	eax, eax
	mov	DWORD PTR MixMono16NoI_pfSampleLength$[esp+24], ebx
; Line 1404
	mov	ebx, DWORD PTR MixMono16NoI_pfLoopLength$[esp+24]
	sar	ebx, 12					; 0000000cH
; Line 1406
	cmp	esi, eax
	je	SHORT $L30932
	mov	esi, DWORD PTR MixMono16NoI_pBuffer$[esp+24]
$L30931:
; Line 1408
	mov	ebp, DWORD PTR MixMono16NoI_pfSampleLength$[esp+24]
	cmp	ebp, edi
	jg	SHORT $L30933
; Line 1410
	test	ebx, ebx
	je	SHORT $L30932
; Line 1411
	sub	edi, ebx
; Line 1415
$L30933:
	inc	edi
	mov	ebp, DWORD PTR MixMono16NoI_dwIncDelta$[esp+28]
; Line 1416
	dec	ebp
	mov	DWORD PTR MixMono16NoI_dwIncDelta$[esp+28], ebp
; Line 1417
	jne	SHORT $L30936
; Line 1422
	mov	edx, DWORD PTR MixMono16NoI_dwDeltaPeriod$[esp+24]
	mov	ebp, DWORD PTR MixMono16NoI_vfDeltaVolume$[esp+24]
	mov	DWORD PTR MixMono16NoI_dwIncDelta$[esp+28], edx
; Line 1423
	mov	edx, DWORD PTR MixMono16NoI_vfVFract$[esp+28]
	add	edx, ebp
	mov	DWORD PTR MixMono16NoI_vfVFract$[esp+28], edx
; Line 1424
	sar	edx, 8
; Line 1426
$L30936:
; Line 1438
	mov	ebp, DWORD PTR MixMono16NoI_pcWave$[esp+28]
	movsx	ebp, WORD PTR [ebp+edi*2]
	imul	ebp, edx
	sar	ebp, 13					; 0000000dH
	add	WORD PTR [esi], bp
; Line 1439
	jno	SHORT $no_oflow$30939
; Line 1440
	mov	WORD PTR [esi], 32767			; 00007fffH
; Line 1441
	js	SHORT $no_oflow$30939
; Line 1442
	mov	WORD PTR [esi], -32768			; ffff8000H
; Line 1443
$no_oflow$30939:
	add	esi, 2
	inc	eax
; Line 1446
	cmp	DWORD PTR MixMono16NoI_dwLength$[esp+24], eax
	ja	SHORT $L30931
$L30932:
; Line 1447
	shl	edi, 12					; 0000000cH
	pop	ebp
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+68], edi
; Line 1450
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	24					; 00000018H 
}	//	asm
}	//	MixMono16NoI

#endif	//	_X86_

DWORD DigitalAudio::MixC(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    DWORD dwPosition;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  

    if (vfLVolume > 4095) vfLVolume = 4095;
    if (vfRVolume > 4095) vfRVolume = 4095;

    const short * pVolL = m_pnDecompMult + ((vfLVolume >> 6) * 256 + 128);
    const short * pVolR = m_pnDecompMult + ((vfRVolume >> 6) * 256 + 128);


	dwLength <<= 1;
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwPosition = pfSamplePos >> 12;

        // interpolation fraction in bits 8-11
        dwFract = (pfSamplePos & 0xFFF);
        
        pfSamplePos += pfPitch;
        dwIncDelta--;
        if (!dwIncDelta)
        {

            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;

            if (vfLVolume > 4095) vfLVolume = 4095;
            else if (vfLVolume < 0) vfLVolume = 0;
            if (vfRVolume > 4095) vfRVolume = 4095;
            else if (vfRVolume < 0) vfRVolume = 0;

            // precompute pointers to lines in table.

            pVolL = m_pnDecompMult + ((vfLVolume >> 6) * 256 + 128);
            pVolR = m_pnDecompMult + ((vfRVolume >> 6) * 256 + 128);
        }

        int s1 = pcWave[dwPosition];
        s1 += ((pcWave[dwPosition + 1] - s1) * dwFract) >> 12;
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) pVolL[s1], &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) pVolR[s1], &pBuffer[dwI+1] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // _X86_
		pBuffer[dwI] += (short) pVolL[s1];
        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	
		pBuffer[dwI+1] += (short) pVolR[s1];
        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_
		dwI += 2;		    
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

DWORD DigitalAudio::MixMonoC(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume, 
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    DWORD dwPosition;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.
 

    if (vfVolume > 4095) vfVolume = 4095;

    const short * pVol = m_pnDecompMult + ((vfVolume >> 6) * 256 + 128);

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwPosition = pfSamplePos >> 12;

        // interpolation fraction in bits 8-11
        dwFract = (pfSamplePos & 0xFFF);
        
        pfSamplePos += pfPitch;
        dwIncDelta--;
        if (!dwIncDelta)
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
            if (vfVolume > 4095) vfVolume = 4095;
            else if (vfVolume < 0) vfVolume = 0;

            // precompute pointers to lines in table.
            pVol = m_pnDecompMult + ((vfVolume >> 6) * 256 + 128);
        }
 
        int s1 = pcWave[dwPosition];
        s1 += ((pcWave[dwPosition + 1] - s1) * dwFract) >> 12;

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) pVol[s1], &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // _X86_
        pBuffer[dwI] += (short) pVol[s1];
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86_
		dwI++;
    }

    m_vfLastLVolume = vfVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}


DWORD DigitalAudio::MixCNoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    DWORD dwIncDelta = dwDeltaPeriod;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample >> 12;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
    pfSampleLength >>= 12;
    pfLoopLength >>= 12;

    if (vfLVolume > 4095) vfLVolume = 4095;
    if (vfRVolume > 4095) vfRVolume = 4095;

    const short * pVolL = m_pnDecompMult + ((vfLVolume >> 6) * 256 + 128);
    const short * pVolR = m_pnDecompMult + ((vfRVolume >> 6) * 256 + 128);
	
	dwLength <<= 1;
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        
        pfSamplePos++;
        dwIncDelta--;
        if (!dwIncDelta)
        {
            dwIncDelta = dwDeltaPeriod;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;

            if (vfLVolume > 4095) vfLVolume = 4095;
            else if (vfLVolume < 0) vfLVolume = 0;
            if (vfRVolume > 4095) vfRVolume = 4095;
            else if (vfRVolume < 0) vfRVolume = 0;
            // precompute pointers to lines in table.

            pVolL = m_pnDecompMult + ((vfLVolume >> 6) * 256 + 128);
            pVolR = m_pnDecompMult + ((vfRVolume >> 6) * 256 + 128);
        }

        short s1 = pcWave[pfSamplePos];

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) pVolL[s1], &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if (ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) pVolR[s1], &pBuffer[dwI+1] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // _X86_
		pBuffer[dwI] += (short) pVolL[s1];
        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	
		pBuffer[dwI+1] += (short) pVolR[s1];
        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_
		dwI += 2;    
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastSample = pfSamplePos << 12;
    return (dwI >> 1);
}

DWORD DigitalAudio::MixMonoCNoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
        VFRACT vfDeltaVolume, 
        PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    DWORD dwIncDelta = dwDeltaPeriod;
    char * pcWave = (char *) m_Source.m_pWave->m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample >> 12;
    VFRACT vfVolume = m_vfLastLVolume;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.
    pfSampleLength >>= 12;
    pfLoopLength >>= 12;

    if (vfVolume > 4095) vfVolume = 4095;

    const short * pVol = m_pnDecompMult + ((vfVolume >> 6) * 256 + 128);
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        
        pfSamplePos++;
        dwIncDelta--;
        if (!dwIncDelta)
        {
            dwIncDelta = dwDeltaPeriod;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;

            if (vfVolume > 4095) vfVolume = 4095;
            else if (vfVolume < 0) vfVolume = 0;
            // precompute pointers to lines in table.
            pVol = m_pnDecompMult + ((vfVolume >> 6) * 256 + 128);
        }
#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if (ALPHA_OVERFLOW &
			(nBitmask = __ADAWI( (short) pVol[pcWave[pfSamplePos]], &pBuffer[dwI] )) )  {
			if (ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#endif // _ALPHA_

#else // _X86_
        pBuffer[dwI] += pVol[pcWave[pfSamplePos]];
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86_
		dwI++;
    }

    m_vfLastLVolume = vfVolume;
    m_pfLastSample = pfSamplePos << 12;
    return (dwI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\midi.cpp ===
//      MIDI.cpp
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"

MIDIData::MIDIData() 
{
    m_stTime = 0;
    m_lData = 0;            
}

void * MIDIData::operator new(size_t size)
{
    return (void *) MIDIRecorder::m_pFreeEventList->RemoveHead();
}

void MIDIData::operator delete(void *pFreeItem)
{
    MIDIRecorder::m_pFreeEventList->AddHead( (CListItem *) pFreeItem);
}

MIDIRecorder::MIDIRecorder()
{
    m_lCurrentData = 0;
    m_stCurrentTime = 0;
}

MIDIRecorder::~MIDIRecorder()
{
    ClearMIDI(MAX_STIME);
}

void MIDIRecorder::FlushMIDI(STIME stTime)
{
    MIDIData *pMD;
    MIDIData *pLast = NULL;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                m_EventList.Truncate(pLast);
            }
            for(; pMD != NULL; pMD = pLast)
            {
                pLast = pMD->GetNext();
                delete pMD; // return it to free items.
            }
            break;
        }
        pLast = pMD;
    }
}

void MIDIRecorder::ClearMIDI(STIME stTime)
{
    MIDIData *pMD;
    for (;pMD = m_EventList.GetHead();)
    {
        if (pMD->m_stTime < stTime)
        {
            DPF2(7, "Freeing event at time %ld, data %ld",
                 pMD->m_stTime, pMD->m_lData);
            m_EventList.RemoveHead();
            m_stCurrentTime = pMD->m_stTime;
            m_lCurrentData = pMD->m_lData;
            delete pMD; // return it to free items.
        }
        else break;
    }
}

VREL MIDIRecorder::VelocityToVolume(WORD nVelocity)
{
    return (m_vrMIDIToVREL[nVelocity]);
}

BOOL MIDIRecorder::RecordMIDI(STIME stTime, long lData)
{
    MIDIData *pNext;
    MIDIData *pScan = m_EventList.GetHead();
    MIDIData *pMD;

    if (m_EventList.IsFull())
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("MidiEvent list full. Dropping events"));
        return (FALSE);
    }

    pMD = new MIDIData;
    if (pMD == NULL)
    {
        Trap();
        DPF2(10, "ERROR: MIDIRecorder stTime %08x, data %08x", stTime, lData);
        return (FALSE);
    }

    pMD->m_stTime = stTime;
    pMD->m_lData = lData;
    if (pScan == NULL)
    {
        m_EventList.AddHead(pMD);
    }
    else
    {
        if (pScan->m_stTime > stTime)
        {
            m_EventList.AddHead(pMD);
        }
        else
        {
            for (;pScan != NULL; pScan = pNext)
            {
                pNext = pScan->GetNext();
                if (pNext == NULL || pNext->m_stTime > stTime)
                {
                    m_EventList.InsertAfter(pScan, pMD);
                    break;
                }
            }
        }
    }
    return (TRUE);
}

long MIDIRecorder::GetData(STIME stTime)
{
    long lData = m_lCurrentData;
    for (MIDIData *pMD = m_EventList.GetHead();pMD;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime > stTime)
        {
            break;
        }
        lData = pMD->m_lData;
    }

    DPF2(9, "Getting data at time %ld, data %ld", stTime, lData);
    return (lData);
}

BOOL NoteIn::RecordNote(STIME stTime, Note * pNote)
{
    long lData = pNote->m_bPart << 16;
    lData |= pNote->m_bKey << 8;
    lData |= pNote->m_bVelocity;
    return (RecordMIDI(stTime,lData));
}

BOOL NoteIn::GetNote(STIME stTime, Note * pNote)
{
    MIDIData *pMD = m_EventList.GetHead();
    if (pMD != NULL)
    {
        if (pMD->m_stTime <= stTime)
        {
            pNote->m_stTime = pMD->m_stTime;
            pNote->m_bPart = (BYTE) (pMD->m_lData >> 16);
            pNote->m_bKey = (BYTE) (pMD->m_lData >> 8) & 0xFF;
            pNote->m_bVelocity = (BYTE) pMD->m_lData & 0xFF;
            m_EventList.RemoveHead();
            delete pMD; // return it to free items.
            return (TRUE);
        }
    }
    return (FALSE);
}

void NoteIn::FlushMIDI(STIME stTime)
{
    MIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            pMD->m_stTime = stTime;     // Play now.
            switch ((pMD->m_lData & 0x0000FF00) >> 8)
            {
                case NOTE_ASSIGNRECEIVE:
                case NOTE_MASTERVOLUME:
                case NOTE_SOUNDSOFF:
                case NOTE_SUSTAIN:
                case NOTE_ALLOFF:
                    break;                      //  this is a special command
                                                //  so don't mess with the velocity
                default:
                    pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
            }
        }
    }
}

void NoteIn::FlushPart(STIME stTime, BYTE bChannel)
{
    MIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (bChannel == (BYTE) (pMD->m_lData >> 16))
            {
            pMD->m_stTime = stTime;     // Play now.
            switch ((pMD->m_lData & 0x0000FF00) >> 8)
            {
                case NOTE_ASSIGNRECEIVE:
                case NOTE_MASTERVOLUME:
                case NOTE_SOUNDSOFF:
                case NOTE_SUSTAIN:
                case NOTE_ALLOFF:
                    break;                      //  this is a special command
                                                //  so don't mess with the velocity
                default:
                    pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
            }
            }
        }
    }
}

DWORD ModWheelIn::GetModulation(STIME stTime)
{
    DWORD nResult = MIDIRecorder::GetData(stTime);
    return (nResult);
}

PitchBendIn::PitchBendIn()
{
    m_lCurrentData = 0x2000;	// initially at midpoint, no bend
    m_prRange = 200;           // whole tone range by default.
}

// note: we don't keep a time-stamped range.
// if people are changing the pitch bend range often, this won't work right,
// but that didn't seem likely enough to warrant a new list.
PREL PitchBendIn::GetPitch(STIME stTime)
{
    PREL prResult = (PREL) MIDIRecorder::GetData(stTime);
    prResult -= 0x2000;         // Subtract MIDI Midpoint.
    prResult *= m_prRange;	// adjust by current range
    prResult >>= 13;
    return (prResult);
}

VolumeIn::VolumeIn()
{
    m_lCurrentData = 100;
}

VREL VolumeIn::GetVolume(STIME stTime)
{
    long lResult = MIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

ExpressionIn::ExpressionIn()
{
    m_lCurrentData = 127;
}

VREL ExpressionIn::GetVolume(STIME stTime)
{
    long lResult = MIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

PanIn::PanIn()
{
    m_lCurrentData = 64;
}

long PanIn::GetPan(STIME stTime)
{
    long lResult = (long) MIDIRecorder::GetData(stTime);
    return (lResult);
}

ProgramIn::ProgramIn()
{
    m_lCurrentData = 0;
    m_bBankH = 0;
    m_bBankL = 0;
}

DWORD ProgramIn::GetProgram(STIME stTime)
{
    DWORD dwProgram = (DWORD) MIDIRecorder::GetData(stTime);
    return (dwProgram);
}

BOOL ProgramIn::RecordBankH(BYTE bBankH)
{
    m_bBankH = bBankH;
    return (TRUE);
}

BOOL ProgramIn::RecordBankL(BYTE bBankL)
{
    m_bBankL = bBankL;
    return (TRUE);
}

BOOL ProgramIn::RecordProgram(STIME stTime, BYTE bProgram)
{
    DWORD dwProgram = (m_bBankH << 14) | (m_bBankL << 7) | bProgram;
    return (RecordMIDI(stTime,(long) dwProgram));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\pch.c ===
/*
  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
*/

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-2000 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define MulDiv      MulDiv32
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\synth.h ===
//      Synth.h
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//      All rights reserved.
//

/*  For internal representation, volume is stored in Volume Cents,
    where each increment represents 1/100 of a dB.
    Pitch is stored in Pitch Cents, where each increment
    represents 1/100 of a semitone.
*/

/*  SAMPLE_RATE should be 22kHz.
    BUFFER_SIZE is the size of the buffer we write into.
    Since AudioMan determines the absolute size of the buffer,
    this is just a close estimate.
*/

/*  SourceLFO is the file format definition of the LFO in an
    instrument. This is used to represent an LFO as part of
    a specific articulation set within an instrument that
    has been loaded from disk. Once the instrument is chosen
    to play a note, this is also copied into the Voice
    object.
*/

#include "clist.h"

/*  Sample format and Sample playback flags are organized
    together because together they determine which
    mix loop to use.
*/

#define MMX_ENABLED

#ifdef _X86_
BOOL MultiMediaInstructionsSupported(); // Check for MMX
#else  // !_X86_
#undef MMX_ENABLED                      // Don't waste your time checking.
#endif // !_X86_

#define SFORMAT_16              1       // Sixteen bit sample.
#define SFORMAT_8               2       // Eight bit sample.
#define SFORMAT_COMPRESSED      4       // Sixteen compressed to 8.
#define SPLAY_MMX               0x10    // Use MMX processor (16 bit only).
#define SPLAY_INTERPOLATE       0x20    // Interpolation required.
#define SPLAY_STEREO            0x40    // Stereo output.

#define RA_E_FIRST              (OLE_E_FIRST + 5000)

#define E_BADWAVE               (RA_E_FIRST + 1)    // Bad wave chunk
#define E_NOTPCM                (RA_E_FIRST + 2)    // Not PCM data in wave
#define E_NOTMONO               (RA_E_FIRST + 3)    // Wave not MONO
#define E_BADARTICULATION       (RA_E_FIRST + 4)    // Bad articulation chunk
#define E_BADREGION             (RA_E_FIRST + 5)    // Bad region chunk
#define E_BADWAVELINK           (RA_E_FIRST + 6)    // Bad lnk from reg to wave
#define E_BADINSTRUMENT         (RA_E_FIRST + 7)    // Bad instrument chunk
#define E_NOARTICULATION        (RA_E_FIRST + 8)    // No art found in region
#define E_NOWAVE                (RA_E_FIRST + 9)    // No wave found for region
#define E_BADCOLLECTION         (RA_E_FIRST + 10)   // Bad collection chunk
#define E_NOLOADER              (RA_E_FIRST + 11)   // No IRALoader interface
#define E_NOLOCK                (RA_E_FIRST + 12)   // Unable to lock a region
#define E_TOOBUSY               (RA_E_FIRST + 13)   // to busy to fully follow

typedef long HRESULT;

typedef long    PREL;   // Pitch cents, for relative pitch.
typedef short   PRELS;  // Pitch cents, in storage form.
typedef long    VREL;   // Volume cents, for relative volume.
typedef short   VRELS;  // Volume cents, in storage form.
typedef long    TREL;   // Time cents, for relative time
typedef short   TRELS;  // Time Cents, in storage form.
typedef LONGLONG STIME;  // Time value, in samples.
typedef long    MTIME;  // Time value, in milliseconds.
typedef long    PFRACT; // Pitch increment, where upper 20 bits are
                        // the index and the lower 12 are the fractional
                        // component.
typedef long    VFRACT; // Volume, where lower 12 bits are the fraction.

#define MAX_STIME   0x7FFFFFFFFFFFFFFF
//typedef short    PCENT;
//typedef short    GCENT;
typedef long    TCENT;
typedef short   PERCENT;

#define RIFF_TAG    mmioFOURCC('R','I','F','F')
#define LIST_TAG    mmioFOURCC('L','I','S','T')
#define WAVE_TAG    mmioFOURCC('W','A','V','E')
#define FMT__TAG    mmioFOURCC('f','m','t',' ')
#define DATA_TAG    mmioFOURCC('d','a','t','a')
#define FACT_TAG    mmioFOURCC('f','a','c','t')

#define FOURCC_EDIT mmioFOURCC('e','d','i','t')

typedef struct _EDITTAG {
  DWORD    dwID;
}EDITTAG, FAR *LPEDITTAG;

#define MIN_VOLUME      -9600   // Below 96 db down is considered off.
#define PERCEIVED_MIN_VOLUME   -8000   // But, we cheat.
#define SAMPLE_RATE_22  22050   // 22 kHz is the standard rate.
#define SAMPLE_RATE_44  44100   // 44 kHz is the high quality rate.
#define SAMPLE_RATE_11  11025   // 11 kHz should not be allowed!
#define STEREO_ON       1
#define STEREO_OFF      0

#define DL_WAVE         1       // Indicates a wave was downloaded.
#define DL_COLLECTION   2       // Collection header downloaded.
#define DL_INSTRUMENT   3
#define DL_ARTICULATION 4
#define DL_REGION       5
#define DL_NONE         0

#define CONSTTAB
//#define CONSTTAB const

#define FORCEBOUNDS(data,min,max) {if (data < min) data = min; else if (data > max) data = max;}
#define FORCEUPPERBOUNDS(data,max) {if (data > max) data = max;}

// For memory mapped riff file io:

typedef struct RIFF {
    DWORD ckid;
    DWORD cksize;
} RIFF;

typedef struct RIFFLIST {
    DWORD ckid;
    DWORD cksize;
    DWORD fccType;
} RIFFLIST;

class SourceLFO
{
public:
                SourceLFO();
    void        Init(DWORD dwSampleRate);
    void        SetSampleRate(long lDirection);
    void        Verify();           // Verifies that the data is valid.
    PFRACT      m_pfFrequency;      // Frequency, in increments through the sine table.
    STIME       m_stDelay;          // How long to delay in sample units.
    VRELS       m_vrMWVolumeScale;   // Scaling of volume LFO by Mod Wheel.
    PRELS       m_prMWPitchScale;    // Scaling of pitch LFO by Mod Wheel.
    VRELS       m_vrVolumeScale;     // Scaling of straight volume signal from LFO.
    PRELS       m_prPitchScale;      // Scaling of straight pitch signal from LFO.

};

/*  SourceEG is the file format definition of an Envelope
    generator in an instrument.
*/

class SourceEG
{
public:
                SourceEG();
    void        SetSampleRate(long lDirection);
    void        Init(DWORD dwSampleRate);
    void        Verify();           // Verifies valid data.
    STIME       m_stAttack;         // Attack rate.
    STIME       m_stDecay;          // Decay rate.
    STIME       m_stRelease;        // Release rate.
    TRELS       m_trVelAttackScale; // Scaling of attack by note velocity.
    TRELS       m_trKeyDecayScale;  // Scaling of decay by note value.
    PERCENT     m_pcSustain;        // Sustain level.
    short       m_sScale;           // Scaling of entire signal.
};

/*  SourceArticulation is the file format definition of
    a complete articulation set: the LFO and two
    envelope generators.
    Since several regions within one Instrument can
    share one articulation, a counter is used to keep
    track of the usage.
*/

class SourceArticulation
{
public:
                SourceArticulation();
    void        Verify();           // Verifies valid data.
    void        AddRef();
    void        Release();
    void        SetSampleRate(DWORD dwSampleRate);
    SourceEG    m_PitchEG;          // Pitch envelope.
    SourceEG    m_VolumeEG;         // Volume envelope.
    SourceLFO   m_LFO;              // Low frequency oscillator.
    DWORD       m_dwSampleRate;
    HRESULT     Load(BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    LONG        m_lUsageCount;      // Keeps track of how many times in use.
    WORD        m_wEditTag;         // Used for editor updates.
    short       m_sDefaultPan;      // default pan (for drums)
    short       m_sVelToVolScale;   // Velocity to volume scaling.
};

/*  Since multiple regions may reference
    the same Wave, a reference count is maintained to
    keep track of how many regions are using the sample.
*/

class Wave : public CListItem
{
public:
                    Wave();
                    ~Wave();
    BOOL            Lock();             // Locks down sample.
    BOOL            UnLock();           // Releases sample.
    BOOL            IsLocked();         // Is currently locked?
    void            Verify();           // Verifies that the data is valid.

    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.

    Wave *          GetNext() {return(Wave *)CListItem::GetNext();};
    HRESULT         Load(BYTE *p, BYTE *pEnd, DWORD dwCompress);
static  void        Init();             // Set up sine table.
static  CONSTTAB    char m_Compress[2048]; // Array for compressing 12->8 bit
    DWORD           m_dwSampleLength;   // Length of sample.
    DWORD           m_dwSampleRate;
    short *         m_pnWave;
    UINT_PTR        m_uipOffset;        // Pointer to wave data in memory mapped wave pool.
    DWORD           m_dwLoopStart;
    DWORD           m_dwLoopEnd;
    WORD            m_wID;              // ID for matching wave with regions.
    VRELS           m_vrAttenuation;    // Attenuation.
    PRELS           m_prFineTune;       // Fine tune.
    WORD            m_wEditTag;         // Used for editor updates.
    LONG            m_lUsageCount;      // Keeps track of how many times in use.
    LONG            m_lLockCount;       // How many locks on this wave.
    BYTE            m_bOneShot;         // One shot flag.
    BYTE            m_bMIDIRootKey;     // Root note.
    BYTE            m_bSampleType;
    BYTE            m_bCompress;
    BYTE            m_bWSMPLoaded;      // WSMP chunk has been loaded into Wave.
};


class WavePool : public CList
{
public:
    Wave *      GetHead() {return (Wave *)CList::GetHead();};
    Wave *      GetItem(DWORD dwID) {return (Wave *)CList::GetItem((LONG)dwID);};
    Wave *      RemoveHead() {return (Wave *)CList::RemoveHead();};
};


/*  The SourceSample class describes one sample in an
    instrument. The sample is referenced by a SourceRegion
    structure.
*/
class Collection;

class SourceSample
{
public:
                SourceSample();
                ~SourceSample();
    BOOL        Lock();
    BOOL        CopyFromWave();
    BOOL        UnLock();
    void        Verify();           // Verifies that the data is valid.
    Wave *      m_pWave;            // Wave in pool.
    DWORD       m_dwLoopStart;      // Index of start of loop.
    DWORD       m_dwLoopEnd;        // Index of end of loop.
    DWORD       m_dwSampleLength;   // Length of sample.
    DWORD       m_dwSampleRate;     // Sample rate of recording.
    PRELS       m_prFineTune;       // Fine tune to correct pitch.
    WORD        m_wID;              // Wave pool id.
    BYTE        m_bSampleType;      // 16 or 8, compressed or not.
    BYTE        m_bOneShot;         // Is this a one shot sample?
    BYTE        m_bMIDIRootKey;     // MIDI note number for sample.
    BYTE        m_bWSMPLoaded;      // Flag to indicate WSMP loaded in region.
};

/*  The SourceRegion class defines a region within an instrument.
    The sample is managed with a pointer instead of an embedded
    sample. This allows multiple regions to use the same
    sample.
    Each region also has an associated articulation. For drums, there
    is a one to one matching. For melodic instruments, all regions
    share the same articulation. So, to manage this, each region
    points to the articulation.
*/

class SourceRegion : public CListItem
{
public:
                SourceRegion();
                ~SourceRegion();
    SourceRegion *GetNext() {return(SourceRegion *)CListItem::GetNext();};
    void        SetSampleRate(DWORD dwSampleRate);
    BOOL        Lock(DWORD dwLowNote,DWORD dwHighNote);
    BOOL        UnLock(DWORD dwLowNote,DWORD dwHighNote);
    SourceSample m_Sample;       // Sample structure.
    SourceArticulation * m_pArticulation; // Pointer to associated articulation.
    VRELS       m_vrAttenuation;    // Volume change to apply to sample.
    PRELS       m_prTuning;         // Pitch shift to apply to sample.
    LONG        m_lLockCount;      // How many locks on this.
    HRESULT     Load(BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    WORD        m_wEditTag;         // Used for editor updates.
    BYTE        m_bAllowOverlap;    // Allow overlapping of note.
    BYTE        m_bKeyHigh;         // Upper note value for region.
    BYTE        m_bKeyLow;          // Lower note value.
    BYTE        m_bGroup;           // Logical group (for drums.)
};


class SourceRegionList : public CList
{
public:
    SourceRegion *GetHead() {return (SourceRegion *)CList::GetHead();};
    SourceRegion *RemoveHead() {return (SourceRegion *)CList::RemoveHead();};
};


/*  The Instrument class is really the file format definition
    of an instrument.
    The Instrument can be either a Drum or a Melodic instrument.
    If a drum, it has up to 128 pairings of articulations and
    regions. If melodic, all regions share the same articulation.
    ScanForRegion is called by ControlLogic to get the region
    that corresponds to a note.
*/

#define AA_FINST_DRUM   0x80000000
#define AA_FINST_EMPTY  0x40000000
#define AA_FINST_USEGM  0x00400000
#define AA_FINST_USEGS  0x00200000

class InstManager;

class Instrument : public CListItem
{
public:
                    Instrument();
                    ~Instrument();
    Instrument *    GetNext() {return(Instrument *)CListItem::GetNext();};
    void            SetSampleRate(DWORD dwSampleRate);
    BOOL            Lock(DWORD dwLowNote,DWORD dwHighNote);
    BOOL            UnLock(DWORD dwLowNote,DWORD dwHighNote);
    SourceRegion * ScanForRegion(DWORD dwNoteValue);
    SourceRegionList m_RegionList;   // Linked list of regions.
    DWORD           m_dwProgram;        // Which program change it represents.
    Collection *    m_pCollection;      // Collection this belongs to.

    HRESULT LoadRegions( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    HRESULT Load( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    WORD            m_wEditTag;         // Used for editor updates.
    LONG            m_lLockCount;       // How many locks are on this.
};

class InstrumentList : public CList
{
public:
    Instrument *    GetHead() {return (Instrument *)CList::GetHead();};
    Instrument *    RemoveHead() {return (Instrument *)CList::RemoveHead();};
};


class Collection : public CListItem
{
public:
                    Collection();
                    ~Collection();
    HRESULT         Open(PCWSTR szCollection);
    void            Close();
    Collection *    GetNext() {return(Collection *)CListItem::GetNext();};
    BOOL            Lock(DWORD dwProgram,DWORD dwLowNote,DWORD dwHighNote);
    BOOL            UnLock(DWORD dwProgram,DWORD dwLowNote,DWORD dwHighNote);
    HRESULT         ResolveConnections();
    HRESULT         Load(DWORD dwCompress, DWORD dwSampleRate);
    void            SetSampleRate(DWORD dwSampleRate);
private:
    void            RemoveDuplicateInstrument(DWORD dwProgram);
    HRESULT         LoadName(BYTE *p, BYTE *pEnd);
    HRESULT         Load(BYTE *p, BYTE *pEnd, DWORD dwCompress, DWORD dwSampleRate);
    HRESULT         LoadInstruments(BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    HRESULT         LoadWavePool(BYTE *p, BYTE *pEnd, DWORD dwCompress);
    HRESULT         LoadPoolCues(BYTE *p, BYTE *pEnd, DWORD dwCompress);
public:
    Instrument *    GetInstrument(DWORD dwProgram,DWORD dwKey);
    InstrumentList  m_InstrumentList;
    PWCHAR          m_pszFileName;      // File path of collection.
    char *          m_pszName;          // Name of Collection.
    WavePool        m_WavePool;
    BOOL            m_fIsGM;            // Is this the GM kit?
    LONG            m_lLockCount;       // How many locks on this?
    LONG            m_lOpenCount;       // How many opens on this?
private:
    ULONG           m_cbFile;           // Size of file
    LPVOID          m_lpMapAddress;     // Memory map of file.
    UINT_PTR        m_uipWavePool;      // Base address of wave pool.
    WORD            m_wEditTag;         // Used for editor updates.
    WORD            m_wWavePoolSize;    // Number of waves in wave pool.
};


class CollectionList : public CList
{
public:
    Collection *GetHead() {return (Collection *)CList::GetHead();};
    void        AddHead(Collection * pC) {CList::AddHead((CListItem *) pC);};
    Collection *RemoveHead() {return (Collection *)CList::RemoveHead();};
};

#define RANGE_ALL   128

class LockRange : public CListItem
{
public :
                LockRange();
    LockRange * GetNext() {return(LockRange *)CListItem::GetNext();};
    void        Verify();           // Verifies that the data is valid.
    DWORD       m_dwProgram;        // Instrument.
    Collection *m_pCollection;      // Collection.
    DWORD       m_dwHighNote;       // Top of range.
    DWORD       m_dwLowNote;        // Bottom of range.
    BOOL        m_fLoaded;          // Has been successfully loaded.
};


class LockList : public CList
{
public:
    LockRange  *GetHead() {return (LockRange *)CList::GetHead();};
    void        AddHead(LockRange * pC) {CList::AddHead((CListItem *) pC);};
    LockRange  *RemoveHead() {return (LockRange *)CList::RemoveHead();};
};

/*  InstManager keeps track of the instruments.
    It uses sixteen lists for the melodic instruments and
    one for the drums. The sixteen lists represent the
    16 General MIDI groups. In other words, bits 0x78 in the
    address are used to select the group.
    If an instrument is not found, another in the same
    group can be used. This is marginally acceptable, but
    better than nothing.
    This doubles as a hash table scheme to make sure
    that accessing instruments never gets too expensive.
    InstManager keeps a seperate thread running to download
    samples. This allows samples to be loaded either through
    GM patch change commands or the standard download
    command without stopping the engine's performance.
    Obviously, if an instrument is not ready in time for a note,
    it is not used.
    To pass the download commands to the engine, a
    message structure, InstMessage, is used.
*/

#define COMPRESS_OFF        0   // No compression
#define COMPRESS_ON         1   // Compress 16 to 8 bits
#define COMPRESS_TRUNCATE   2   // Truncate 18 to 8 bits

typedef struct GMInstrument {
    HANDLE      m_hLock;
    DWORD       m_dwProgram;
} GMInstrument;

class InstManager {
public:
                    InstManager();
                    ~InstManager();
    BOOLEAN         RequestGMInstrument(DWORD dwChannel,DWORD dwPatch);
    Instrument *    GetInstrument(DWORD dwPatch,DWORD dwKey);
    HANDLE          Lock(HANDLE hCollection,DWORD dwProgram,DWORD dwLowNote,DWORD dwHighNote);
    HRESULT         UnLock(HANDLE hLock);
    HRESULT         LoadCollection(HANDLE *pHandle, PCWSTR szFileName, BOOL fIsGM);
    HRESULT         ReleaseCollection(HANDLE hCollection);

    HRESULT         SetGMLoad(BOOL fLoadGM);
    BOOLEAN         LoadGMInstrument(DWORD dwChannel,DWORD dwPatch);

    void            SetSampleRate(DWORD dwSampleRate);

private:
    CollectionList  m_CollectionList;   // List of collections.
    LockList        m_LockList;         // List of lock handles.
    BOOL            m_fLoadGM;          // Do real time GM loads in response to Patch commands.
    DWORD           m_dwCompress;       // Compression requested by app.
    DWORD           m_dwSampleRate;     // Sample rate requested by app.
    PWCHAR          m_pszFileName;      // Dls file name from registry.
    HANDLE          m_hGMCollection;    // Handle to GM Collection.
    GMInstrument    m_GMNew[16];    // Sixteen currently locked down instruments.
    GMInstrument    m_GMOld[16];    // Previous locked instruments.
};

/*  MIDIRecorder is used to keep track of a time
    slice of MIDI continuous controller events.
    This is subclassed by the PitchBend, Volume,
    Expression, and ModWheel Recorder classes, so
    each of them may reliably manage MIDI events
    coming in.
    MIDIRecorder uses a linked list of MIDIData
    structures to keep track of the changes within
    the time slice.
    Allocation and freeing of the MIDIData events
    is kept fast and efficient because they are
    always pulled from the static pool m_pFreeList,
    which is really a list of events pulled directly
    from the static array m_pFreeEventList. This is
    safe because we can make the assumption that
    the maximum MIDI rate is 1000 events per second.
    Since we are managing time slices of roughly
    1/16 of a second, a buffer of 100 events would
    be overkill.
    Although MIDIRecorder is subclassed to several
    different event types, they all share the one
    staticly declared free list.
*/

class MIDIData : public CListItem
{
public:
                MIDIData();
    MIDIData *  GetNext() {return (MIDIData *)CListItem::GetNext();};
    STIME       m_stTime;   // Time this event was recorded.
    long        m_lData;    // Data stored in event.

    void * operator new(size_t size);
    void operator delete(void *);
};

#define MAX_MIDI_EVENTS     1000

class MIDIDataList : public CList
{
public:
    MIDIDataList(): CList(MAX_MIDI_EVENTS) {};
    MIDIData *GetHead() {return (MIDIData *)CList::GetHead();};
    MIDIData *RemoveHead() {return (MIDIData *)CList::RemoveHead();};
};

class MIDIRecorder
{
public:
                MIDIRecorder();
                ~MIDIRecorder();        // Be sure to clear local list.
    static void DestroyEventList();
    static void InitTables();
    static BOOL InitEventList();
    void        FlushMIDI(STIME stTime); // Clear after time stamp.
    void        ClearMIDI(STIME stTime); // Clear up to time stamp.
    BOOL        RecordMIDI(STIME stTime, long lData); // MIDI input goes here.
    long        GetData(STIME stTime);  // Gets data at time.
    static VREL VelocityToVolume(WORD nVelocity);
protected:
    static CONSTTAB VREL m_vrMIDIToVREL[128]; // Array for converting MIDI to volume.

    static MIDIData *m_pEventPool;         // Pool of midi data.
    static CList    *m_pFreeEventList;     // free midi data list.
    static LONG      m_lRefCount;          // RefCount for EventPool

protected:
    MIDIDataList m_EventList;           // This recorder's list.
    STIME       m_stCurrentTime;        // Time for current value.
    long        m_lCurrentData;         // Current value.

    friend class MIDIData;
};

class Note {
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    BYTE        m_bKey;
    BYTE        m_bVelocity;
};

// Fake note values held in NoteIn's queue
// to indicate changes in the sustain pedal
// and "all notes off".
// This is a grab bag for synchronous events
// that should be queued in time, not simply done as
// soon as received.
// By putting them in the note queue, we ensure
// they are evaluated in the exact same order as
// the notes themselves.

const BYTE NOTE_ASSIGNRECEIVE   = 0xFB;
const BYTE NOTE_MASTERVOLUME    = 0xFC;
const BYTE NOTE_SOUNDSOFF       = 0xFD;
const BYTE NOTE_SUSTAIN         = 0xFE;
const BYTE NOTE_ALLOFF          = 0xFF;

class NoteIn : public MIDIRecorder
{
public:
    void        FlushMIDI(STIME stTime);
    void        FlushPart(STIME stTime, BYTE bChannel);
    BOOL        RecordNote(STIME stTime, Note * pNote);
    BOOL        GetNote(STIME stTime, Note * pNote); // Gets the next note.
};

/*  ModWheelIn handles one channel of Mod Wheel
    input. As such, it is not embedded in the Voice
    class, rather it is in the Channel class.
    ModWheelIn's task is simple: keep track of MIDI
    Mod Wheel events, each tagged with millisecond
    time and value, and return the value for a specific
    time request.
    ModWheelIn inherits almost all of its functionality
    from the MIDIRecorder Class.
    ModWheelIn receives MIDI mod wheel events through
    the RecordMIDI() command, which stores the
    time and value of the event.
    ModWheelIn is called by VoiceLFO to get the
    current values for the mod wheel to set the amount
    of LFO modulation for pitch and volume.
*/

class ModWheelIn : public MIDIRecorder
{
public:
    DWORD       GetModulation(STIME stTime);    // Gets the current Mod Wheel value.
};

/*  PitchBendIn handles one channel of Pitch Bend
    input. Like the Mod Wheel module, it inherits
    its abilities from the MIDIRecorder class.
    It has one additional routine, GetPitch(),
    which returns the current pitch bend value.
*/

class PitchBendIn : public MIDIRecorder
{
public:
                PitchBendIn();
    PREL        GetPitch(STIME stTime); // Gets the current pitch in pitch cents.

    // current pitch bend range.  Note that this is not timestamped!
    PREL        m_prRange;
};

/*  VolumeIn handles one channel of Volume
    input. It inherits its abilities from
    the MIDIRecorder class.
    It has one additional routine, GetVolume(),
    which returns the volume in decibels at the
    specified time.
*/

class VolumeIn : public MIDIRecorder
{
public:
                VolumeIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*  ExpressionIn handles one channel of Expression
    input. It inherits its abilities from
    the MIDIRecorder class.
    It has one additional routine, GetVolume(),
    which returns the volume in decibels at the
    specified time.
*/

class ExpressionIn : public MIDIRecorder
{
public:
                ExpressionIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*  PanIn handles one channel of Volume
    input. It inherits its abilities from
    the MIDIRecorder class.
    It has one additional routine, GetPan(),
    which returns the pan position (MIDI value)
    at the specified time.
*/

class PanIn : public MIDIRecorder
{
public:
                PanIn();
    long        GetPan(STIME stTime);       // Gets the current pan.
};

/*  ProgramIn handles one channel of Program change
    input. It inherits its abilities from
    the MIDIRecorder class.
    Unlike the other controllers, it actually
    records a series of bank select and program
    change events, so it's job is a little
    more complex. Three routines handle the
    recording of the three different commands (bank 1,
    bank 2, program change).
*/

class ProgramIn : public MIDIRecorder
{
public:
                ProgramIn();
    DWORD       GetProgram(STIME stTime);       // Gets the current program change.
    BOOL        RecordBankH(BYTE bBank1);
    BOOL        RecordBankL(BYTE bBank2);
    BOOL        RecordProgram(STIME stTime, BYTE bProgram);
private:
    BYTE        m_bBankH;
    BYTE        m_bBankL;
};

/*  The VoiceLFO class is used to track the behavior
    of an LFO within a voice. The LFO is hard wired to
    output both volume and pitch values, through separate
    calls to GetVolume and GetPitch.
    It also manages mixing Mod Wheel control of pitch and
    volume LFO output. It tracks the scaling of Mod Wheel
    for each of these in m_nMWVolumeScale and m_nMWPitchScale.
    It calls the Mod Wheel module to get the current values
    if the respective scalings are greater than 0.
    All of the preset values for the LFO are carried in
    the m_Source field, which is a replica of the file
    SourceLFO structure. This is initialized with the
    StartVoice call.
*/

class VoiceLFO
{
public:
                VoiceLFO();
    static void Init();             // Set up sine table.
    STIME       StartVoice(SourceLFO *pSource,
                    STIME stStartTime,ModWheelIn * pModWheelIn);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
private:
    long        GetLevel(STIME stTime, STIME *pstTime);
    SourceLFO   m_Source;           // All of the preset information.
    STIME       m_stStartTime;      // Time the voice started playing.
    ModWheelIn *m_pModWheelIn;      // Pointer to Mod Wheel for this channel.
    STIME       m_stRepeatTime;     // Repeat time for LFO.
    static CONSTTAB short m_snSineTable[256];    // Sine lookup table.
};

/*  The VoiceEG class is used to track the behavior of
    an Envelope Generator within a voice. There are two
    EG's, one for pitch and one for volume. However, they
    behave identically.
    All of the preset values for the EG are carried in
    the m_Source field, which is a replica of the file
    SourceEG structure. This is initialized with the
    StartVoice call.
*/
/* Not used any more
#define ADSR_ATTACK     1           // In attack segment.
#define ADSR_DECAY      2           // In decay segment.
#define ADSR_SUSTAIN    3           // In sustain segment.
#define ADSR_RELEASE    4           // In release segment.
#define ADSR_OFF        5           // Envelope finished.
*/
class VoiceEG
{
public:
    static void Init();             // Set up linear attack table.
                VoiceEG();
    STIME       StartVoice(SourceEG *pSource, STIME stStartTime,
                    WORD nKey, WORD nVelocity);
    void        StopVoice(STIME stTime);
    void        QuickStopVoice(STIME stTime, DWORD dwSampleRate);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
    BOOL        InAttack(STIME stTime);     // is voice still in attack?
    BOOL        InRelease(STIME stTime);    // is voice in release?
private:
    long        GetLevel(STIME stTime, STIME *pstTime, BOOL fVolume);
    SourceEG    m_Source;           // Preset values for envelope, copied from file.
    STIME       m_stStartTime;      // Time note turned on
    STIME       m_stStopTime;       // Time note turned off
    static CONSTTAB short m_snAttackTable[201];
};

/*  The DigitalAudio class is used to track the playback
    of a sample within a voice.
    It manages the loop points, the pointer to the sample.
    and the base pitch and base volume, which it initially sets
    when called via StartVoice().
    Pitch is stored in a fixed point format, where the leftmost
    20 bits define the sample increment and the right 12 bits
    define the factional increment within the sample. This
    format is also used to track the position in the sample.
    Mix is a critical routine. It is called by the Voice to blend
    the instrument into the data buffer. It is handed relative change
    values for pitch and volume (semitone cents and decibel
    cents.) These it converts into three linear values:
    Left volume, Right volume, and Pitch.
    It then compares these new values with the values that existed
    for the previous slice and divides by the number of samples to
    determine an incremental change at the sample rate.
    Then, in the critical mix loop, these are added to the
    volume and pitch indices to give a smooth linear slope to the
    change in volume and pitch.
*/

#define MAX_SAMPLE  4095
#define MIN_SAMPLE  (-4096)
#define NLEVELS         64      // # of volume levels for compression lookup table
#define NINTERP         16      // # of interpolation positions for lookup table

#define MAXDB           0
#define MINDB           -100
#define TEST_WRITE_SIZE     3000
#define TEST_SOURCE_SIZE    44100

class ControlLogic;

class DigitalAudio
{
public:
    void        InitMMX();
                DigitalAudio();
    STIME       StartVoice(ControlLogic *pControl,
                    SourceSample *pSample,
                    VREL vrBaseLVolume, VREL vrBaseRVolume,
                    PREL prBasePitch, long lKey);
    BOOL        Mix(short *pBuffer,DWORD dwLength,
                    VREL dwVolumeL, VREL dwVolumeR, PREL dwPitch,
                    DWORD dwStereo);
    static void Init();             // Set up lookup tables.
    static void InitCompression();
    static void ClearCompression();
    void        ClearVoice();
    BOOL        StartCPUTests();
    DWORD       TestCPU(DWORD dwType);
    void        EndCPUTests();
private:
    DWORD       Mix8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       Mix8NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono8NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       Mix16(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono16(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       Mix16NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono16NoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixC(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMonoC(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixCNoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMonoCNoI(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl Mix8X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl MixMono8X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl Mix16X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl MixMono16X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    static VFRACT VRELToVFRACT(VREL vrVolume); // dB to absolute.
    SourceSample m_Source;          // Preset values for sample.
    ControlLogic * m_pControl;      // For access to sample rate, etc.
    static CONSTTAB PFRACT  m_spfCents[201];    // Pitch increment lookup.
    static CONSTTAB PFRACT  m_spfSemiTones[97]; // Four octaves up and down.
                                                // dB conversion table.
    static CONSTTAB VFRACT  m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1];

    static BOOL             m_sfMMXEnabled;
    static CONSTTAB short   m_InterpMult[NINTERP * 512];
public:
    static short * m_pnDecompMult;
private:
    VREL        m_vrBaseLVolume;    // Overall left volume.
    VREL        m_vrBaseRVolume;    // Overall left volume.
    PFRACT      m_pfBasePitch;      // Overall pitch.
    VFRACT      m_vfLastLVolume;    // The last left volume value.
    VFRACT      m_vfLastRVolume;    // The last right volume value.
    PFRACT      m_pfLastPitch;      // The last pitch value.
    VREL        m_vrLastLVolume;    // The last left volume value, in VREL.
    VREL        m_vrLastRVolume;    // Same for right.
    PREL        m_prLastPitch;      // Same for pitch, in PREL.
    PFRACT      m_pfLastSample;     // The last sample position.
    PFRACT      m_pfLoopStart;      // Start of loop.
    PFRACT      m_pfLoopEnd;        // End of loop.
    PFRACT      m_pfSampleLength;   // Length of sample buffer.
    char *      m_pcTestSourceBuffer; // Buffer for testing cpu performance.
    short *     m_pnTestWriteBuffer; // Same, for writing to.
public: // expose utility function
    static PFRACT PRELToPFRACT(PREL prPitch); // Pitch cents to pitch.
};

/*  The Voice class pulls together everything needed to perform
    one voice. It has the envelopes, lfo, and sample embedded
    within it.

    StartVoice() initializes a voice structure for playback. The
    SourceRegion structure carries the region and sample as well
    as a pointer to the articulation, which is used to set up
    the various articulation modules. It also carries pointers to
    all the MIDI modulation inputs and the values for the note key
    and channel which are used by the parent ControlLogic object
    to match incoming note off events with the right voice.
*/

class Voice : public CListItem
{
public:
                Voice();
    Voice *     GetNext() {return (Voice *)CListItem::GetNext();};
    BOOL        StartVoice(ControlLogic *pControl,
                    SourceRegion *pRegion, STIME stStartTime,
                    ModWheelIn * pModWheelIn,
                    PitchBendIn * pPitchBendIn,
                    ExpressionIn * pExpressionIn,
                    VolumeIn * pVolumeIn,
                    PanIn * pPanIn,
                    WORD nKey,WORD nVelocity,
                    VREL vrVolume,           // Added for GS
                    PREL prPitch);           // Added for GS
    static void Init();                      // Initialize LFO, Digital Audio.
    void        StopVoice(STIME stTime);     // Called on note off event.
    void        QuickStopVoice(STIME stTime);// Called to get quick release.
    void        ClearVoice();                // Release use of sample.
    void        ResetVoice();                // Resets all members.
    PREL        GetNewPitch(STIME stTime);   // Return current pitch value
    void        GetNewVolume(STIME stTime, VREL& vrVolume, VREL &vrVolumeR);
                                             // Return current volume value
    DWORD       Mix(short *pBuffer,DWORD dwLength,STIME stStart,STIME stEnd);
private:
    static CONSTTAB VREL m_svrPanToVREL[128]; // Converts Pan to db.
    VoiceLFO    m_LFO;              // LFO.
    VoiceEG     m_PitchEG;          // Pitch Envelope.
    VoiceEG     m_VolumeEG;         // Volume Envelope.
    DigitalAudio m_DigitalAudio;    // The Digital Audio Engine structure.
    PitchBendIn *m_pPitchBendIn;    // Pitch bend source.
    ExpressionIn *m_pExpressionIn;  // Expression source.
    VolumeIn    *m_pVolumeIn;       // Volume source, if allowed to vary
    PanIn       *m_pPanIn;          // Pan source, if allowed to vary
    ControlLogic *m_pControl;       // To access sample rate, etc.
    STIME       m_stMixTime;        // Next time we need a mix.
    long        m_lDefaultPan;      // Default pan
    STIME       m_stLastMix;        // Last sample position mixed.
public:
    STIME       m_stStartTime;      // Time the sound starts.
    STIME       m_stStopTime;       // Time the sound stops.
    BOOL        m_fInUse;           // This is currently in use.
    BOOL        m_fNoteOn;          // Note is considered on.
    BOOL        m_fTag;             // Used to track note stealing.
    VREL        m_vrVolume;         // Volume, used for voice stealing...
    BOOL        m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD        m_nPart;            // Part that is playbg this (channel).
    WORD        m_nKey;             // Note played.
    BOOL        m_fAllowOverlap;    // Allow overlapped note.
    DWORD       m_dwGroup;          // Group this voice is playing now
    DWORD       m_dwProgram;        // Bank and Patch choice.
};


class VoiceList : public CList
{
public:
    Voice *     GetHead() {return (Voice *)CList::GetHead();};
    Voice *     RemoveHead() {return (Voice *)CList::RemoveHead();};
    Voice *     GetItem(LONG lIndex) {return (Voice *) CList::GetItem(lIndex);};
};

/*  Finally, ControlLogic is the big Kahuna that manages
    the whole system. It parses incoming MIDI events
    by channel and event type. And, it manages the mixing
    of voices into the buffer.

  MIDI Input:

    The most important events are the note on and
    off events. When a note on event comes in,
    ControlLogic searches for an available voice.
    ControlLogic matches the channel and finds the
    instrument on that channel. It then call the instrument's
    ScanForRegion() command which finds the region
    that matches the note. At this point, it can copy
    the region and associated articulation into the
    voice, using the StartVoice command.
    When it receives the sustain pedal command,
    it artificially sets all notes on the channel on
    until a sustain off arrives. To keep track of notes
    that have been shut off while the sustain was on
    it uses an array of 128 shorts, with each bit position
    representing a channel. When the sustain releases,
    it scans through the array and creates a note off for
    each bit that was set.
    It also receives program change events to set the
    instrument choice for the channel. When such
    a command comes in, it consults the softsynth.ini file
    and loads an instrument with the file name described
    in the ini file.
    Additional continuous controller events are managed
    by the ModWheelIn, PitchBendIn, etc., MIDI input recording
    modules.

  Mixing:

    Control Logic is also called to mix the instruments into
    a buffer at regular intervals. The buffer is provided by the
    calling sound driver (initially, AudioMan.)
    Each voice is called to mix its sample into the buffer.
    Once all have, the buffer is scanned and samples that
    overflow too high or low (over 12 bits) are clamped.
    Then, the samples are shifted up 4 additional bits
    to maximum volume.
*/

#if BUILDSTATS

typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices10;
    DWORD dwCPU100k;
    DWORD dwMaxAmplitude;
} PerfStats;

#endif

#define MIX_BUFFER_LEN      500     // Set the sample buffer size to 500 mils

//#define MAX_NUM_VOICES      32
#define NUM_EXTRA_VOICES    6       // Extra voices for when we overload.
#define MAX_NUM_VOICES      48     // trying to avoid voice overflow

CONST LONGLONG kOptimalMSecOffset = 40; //  We want Midi events to be timestamped
                                        //  approx. 41 msec ahead of the mix engine.
CONST LONGLONG kStartMSecOffset = 125;  //  We want the whole system to start with approx.
                                        //  125 msec of initial delay, from MIDI event
                                        //  arrival to emergence from the mix engine.
CONST LONGLONG kPLLForce    =   100;    //  Nudge 1/100 of the delta between optimal and actual.
CONST LONGLONG kMsBrickWall =   1000;   //  If we are ever this far off(ms), readjust our
                                        //  notion of system time to what it really is.
class ControlLogic
{
public:
                    ControlLogic();
                    ~ControlLogic();
    void            SetSampleRate(DWORD dwSampleRate);
    void            SetMixDelay(DWORD dwMixDelay);
    HRESULT         GetMixDelay(DWORD * pdwMixDelay);
    void            SetStartTime(MTIME mtTime,STIME stStart);
    void            AdjustTiming(MTIME mtDeltaTime, STIME stDeltaSamples);
    void            ResetPerformanceStats();
    HRESULT         AllNotesOff();
    STIME           MilsToSamples(MTIME mtTime);
    MTIME           SamplesToMils(STIME stTime);
    STIME           SamplesPerMs(void);
    STIME           Unit100NsToSamples(LONGLONG unit100Ns);
    STIME           CalibrateSampleTime(STIME sTime);
#if BUILDSTATS
    HRESULT         GetPerformanceStats(PerfStats *pStats);
#endif
    void            Flush(STIME stTime); // Clears all events after time.
    void            FlushChannel( BYTE bChannel, STIME stTime);
    void            Mix(short *pBuffer,DWORD dwLength);
    BOOL            RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    BOOL            RecordSysEx(STIME stTime,DWORD dwSysExLength,BYTE *pSysExData);
    DWORD           m_dwSampleRate;
    DWORD           m_dwStereo;

    // DLS-1 compatibility parameters: set these off to emulate hardware
    // which can't vary volume/pan during playing of a note.
    BOOL            m_fAllowPanWhilePlayingNote;
    BOOL            m_fAllowVolumeChangeWhilePlayingNote;
    STIME           m_stMinSpan;        // Minimum time allowed for mix time span.
    STIME           m_stMaxSpan;        // Maximum time allowed for mix time span.
    InstManager     m_Instruments;      // Instrument manager.

    void            GMReset();
    void            SWMidiClearAll(STIME stTime);
    void            SWMidiResetPatches(STIME stTime);
    STIME           GetLastMixTime()    {   return m_stLastMixTime; };

private:
    Voice *         OldestVoice();
    Voice *         StealVoice();
    void            QueueNotes(STIME stEndTime);
    void            StealNotes(STIME stTime);
    void            FinishMix(short *pBuffer,DWORD dwlength);

    NoteIn          m_Notes;            // All Note ons and offs.
    STIME           m_stLastMixTime;    // Sample time of last mix.
    STIME           m_stLastCalTime;    // Sample time of last MIDI event.
    STIME           m_stTimeOffset;     // Sample delay.
    STIME           m_stOptimalOffset;  // samples
    LONGLONG        m_lCalibrate;       // samples * 100
    STIME           m_stBrickWall;      // outer limit for calibration.  If exceeded, use new sys time

    DWORD           m_dwConvert;        // Used for converting from mils to samples.
    MTIME           m_mtStartTime;      // Initial millisecond time, when started.
    VoiceList       m_VoicesFree;       // List of available voices.
    VoiceList       m_VoicesExtra;      // Extra voices for temporary overload.
    VoiceList       m_VoicesInUse;      // List of voices currently in use.
    ModWheelIn      m_ModWheel[16];     // Sixteen channels of Mod Wheel.
    PitchBendIn     m_PitchBend[16];    // Sixteen channels of Pitch Bend.
    VolumeIn        m_Volume[16];       // Sixteen channels of Volume.
    ExpressionIn    m_Expression[16];   // Sixteen channels of Expression.
    PanIn           m_Pan[16];          // Sixteen channels of Pan.
    ProgramIn       m_Program[16];      // Sixteen channels of Program Change & Bank select.
    BOOL            m_fSustain[16];     // Sustain on / off.
    int             m_CurrentRPN[16];   // RPN number

    short           m_nMaxVoices;       // Number of allowed voices.
    short           m_nExtraVoices;     // Number of voices over the limit that can be used in a pinch.
#if BUILDSTATS
    STIME           m_stLastStats;      // Last perfstats refresh.
    PerfStats       m_BuildStats;       // Performance info accumulator.
    PerfStats       m_CopyStats;        // Performance information for display.
#endif  //  BUILDSTATS

//  New stuff for GS implementation
    BOOL            m_fGSActive;        // Is GS enabled?
public:
    BOOL            GetGSActive(void)
                    {    return m_fGSActive; };
private:
    WORD            m_nData[16];        // Used to track RPN reading.
    VREL            m_vrMasterVolume;   // Master Volume.
    PREL            m_prFineTune[16];   // Fine tune for each channel.
    PREL            m_prScaleTune[16][12]; // Alternate scale for each channel.
    PREL            m_prCoarseTune[16]; // Coarse tune.
    BYTE            m_bPartToChannel[16]; // Channel to Part converter.
    BYTE            m_bDrums[16];       // Melodic or which drum?
    BOOL            m_fMono[16];        // Mono mode?
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\pins.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pins.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fltsafe.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

KSDISPATCH_TABLE PinDispatchTable =
{
    PinDispatchIoControl,
    NULL,
    PinDispatchWrite,
    NULL,
    PinDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

static const KSPROPERTY_ITEM ControlHandlers[] =
{
    DEFINE_KSPROPERTY_ITEM(
               KSPROPERTY_CONNECTION_STATE,        // idProperty
               PinStateHandler,                    // pfnGetHandler
               sizeof( KSPROPERTY ),               // cbMinSetPropertyInput
               sizeof( ULONG ),                    // cbMinSetDataOutput
               PinStateHandler,                    // pfnSetHandler
               0,                                  // Values
               0,                                  // RelationsCount
               NULL,                               // Relations
               NULL,                               // SupportHandler
               0                                   // SerializedSize
              )
};

static const KSPROPERTY_SET Properties[] =
{
   {
      &KSPROPSETID_Connection,
      SIZEOF_ARRAY( ControlHandlers ),
      (PKSPROPERTY_ITEM) ControlHandlers
   }
};

NTSTATUS
ProcessMidiMessage(
           IN PIRP               pIrp,
           IN PIO_STACK_LOCATION pIrpStack,
           IN PFILTER_INSTANCE   pFilterInstance
          );

IO_STATUS_BLOCK	DummyIoStatusBlock ;

//===========================================================================
//===========================================================================

//  Upon referencing the parent file object, we request to up the timer resolution to 1 ms.
NTSTATUS
PinDispatchCreate(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    FLOATSAFE fs;

    PKSPIN_CONNECT      pConnect;
    PFILE_OBJECT        pFileObject;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;
    int                 i;
    ULONG               returnVal;
    BOOLEAN             createdControlLogic = false;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("PinDispatchCreate()"));

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Status = KsValidateConnectRequest(
                      pIrp,
                      SIZEOF_ARRAY( PinDescs ),
                      PinDescs,
                      &pConnect);
    if (!NT_SUCCESS(Status))
    {
        Trap();
        goto exit;
    }

    pFileObject = pIrpStack->FileObject->RelatedFileObject ;

    // Get the filter instance data
    pFilterInstance = (PFILTER_INSTANCE) pFileObject->FsContext;

    // Check the pin instance count.  Only one create per pin per filter.
    if (pFilterInstance->cPinInstances[pConnect->PinId].CurrentCount >=
        pFilterInstance->cPinInstances[pConnect->PinId].PossibleCount)
    {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    // Create a new instance of the synthesizer if needed
    if (pFilterInstance->pSynthesizer == NULL)
    {
        pFilterInstance->pSynthesizer = new ControlLogic;
        if (pFilterInstance->pSynthesizer)
        {
            createdControlLogic = true;
        }
        else
        {
            Trap();
            Status = STATUS_NO_MEMORY;
            goto exit;
        }
    }

    switch (pConnect->PinId)
    {
        case PIN_ID_MIDI_SINK:
            break;

        case PIN_ID_PCM_SOURCE:
            Status = ObReferenceObjectByHandle(
                               pConnect->PinToHandle,
                               GENERIC_READ | GENERIC_WRITE,
                               NULL,
                               KernelMode,
                               (void **)&pFilterInstance->pNextFileObject,
                               NULL
                              );
            if (!NT_SUCCESS(Status))
            {
                if (createdControlLogic)
                {
                    delete pFilterInstance->pSynthesizer;
                    pFilterInstance->pSynthesizer = NULL;
                }

                Trap();
                goto exit;
            }
            pFilterInstance->DeviceState = KSSTATE_STOP;

            pFilterInstance->pNextDevice =
            IoGetRelatedDeviceObject( pFilterInstance->pNextFileObject );

            pIrpStack->DeviceObject->StackSize =
            pFilterInstance->pNextDevice->StackSize;

            for (i = 0; i < NUM_WRITE_CONTEXT; i++)
            {
                PWRITE_CONTEXT pWriteContext = &pFilterInstance->aWriteContext[i];

                pWriteContext->pFilterInstance = pFilterInstance;
                pWriteContext->pFilterFileObject = pFileObject ;
                pWriteContext->fulFlags = 0;

                pWriteContext->StreamHdr.Data = (char *)
                    ExAllocatePoolWithTag(NonPagedPool,SRC_BUF_SIZE,'iMwS');    //  SwMi
                if (pWriteContext->StreamHdr.Data == NULL)
                {
                    //  we can trash "i"
                    for (i = 0; i < NUM_WRITE_CONTEXT; i++)
                    {
                        if (pFilterInstance->aWriteContext[i].StreamHdr.Data)
                        {
                            ExFreePool(pFilterInstance->aWriteContext[i].StreamHdr.Data);
                            pFilterInstance->aWriteContext[i].StreamHdr.Data = NULL;
                        }
                    }
                    ObDereferenceObject( pFilterInstance->pNextFileObject );

                    if (createdControlLogic)
                    {
                        delete pFilterInstance->pSynthesizer;
                        pFilterInstance->pSynthesizer = NULL;
                    }
                    Trap();
                    Status = STATUS_NO_MEMORY;
                    goto exit;
                }
                pWriteContext->StreamHdr.Size = sizeof( KSSTREAM_HEADER );
                pWriteContext->StreamHdr.TypeSpecificFlags = 0;
                pWriteContext->StreamHdr.FrameExtent = SRC_BUF_SIZE;
                pWriteContext->StreamHdr.DataUsed = SRC_BUF_SIZE;

                ExInitializeWorkItem(
                             &pWriteContext->WorkItem,
                             WriteCompleteWorker,
                             pWriteContext
                            );

                KeInitializeEvent(
                          &pWriteContext->KEvent,
                          NotificationEvent,
                          TRUE
                         );
            }
            break;

        default:
            if (createdControlLogic)
            {
                delete pFilterInstance->pSynthesizer;
                pFilterInstance->pSynthesizer = NULL;
            }
            Trap();
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
    }
    // Increment the reference count on this pin
    (void) InterlockedIncrement((LONG *) &(pFilterInstance->cPinInstances[pConnect->PinId].CurrentCount));

    // Save the pin's instance data pointer in the file handle
    pIrpStack->FileObject->FsContext =
    &pFilterInstance->PinInstanceData[pConnect->PinId];

    // Setup the pin's instance data
    Status = KsAllocateObjectHeader(&pFilterInstance->PinInstanceData[pConnect->PinId].ObjectHeader,
                                    0,
                                    NULL,
                                    pIrp,
                                    (PKSDISPATCH_TABLE)&PinDispatchTable);
    if (!NT_SUCCESS(Status))
    {
        (void) InterlockedDecrement((LONG *) &(pFilterInstance->cPinInstances[pConnect->PinId].CurrentCount));
        if (pConnect->PinId == PIN_ID_PCM_SOURCE)
        {
            for (i = 0; i < NUM_WRITE_CONTEXT; i++)
            {
                if (pFilterInstance->aWriteContext[i].StreamHdr.Data)
                {
                    ExFreePool(pFilterInstance->aWriteContext[i].StreamHdr.Data);
                    pFilterInstance->aWriteContext[i].StreamHdr.Data = NULL;
                }
            }
            ObDereferenceObject( pFilterInstance->pNextFileObject );
        }
        if (createdControlLogic)
        {
            delete pFilterInstance->pSynthesizer;
            pFilterInstance->pSynthesizer = NULL;
        }
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pFilterInstance->PinInstanceData[pConnect->PinId].PinId = pConnect->PinId;
    pFilterInstance->PinInstanceData[pConnect->PinId].pFilterFileObject = pFileObject;
    pFilterInstance->PinInstanceData[pConnect->PinId].pFilterInstance = pFilterInstance;

    // "AddRef" the parent file object
    ObReferenceObject(pFileObject);
#if kAdjustingTimerRes
    returnVal = ExSetTimerResolution(kMidiTimerResolution100Ns,TRUE);
    _DbgPrintF( DEBUGLVL_TERSE, ("*** SWMidi: set timer resolution request (is now %d.%04d ms) ***",returnVal/10000,returnVal%10000));
#endif  //  kAdjustingTimerRes

exit:
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;
}

//  Upon dereferencing the parent file object, we rescind our request to up the resolution to 1 ms.
NTSTATUS PinDispatchClose(
              IN PDEVICE_OBJECT   DeviceObject,
              IN PIRP             pIrp
             )
{
    PFILTER_INSTANCE    pFilterInstance;
    PPIN_INSTANCE_DATA  pPinInstanceData;
    PIO_STACK_LOCATION  pIrpStack;
    int i;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pPinInstanceData = (PPIN_INSTANCE_DATA)pIrpStack->FileObject->FsContext;
    pFilterInstance = pPinInstanceData->pFilterInstance;
    if (pFilterInstance->DeviceState != KSSTATE_STOP)
    {
        SetDeviceState(pFilterInstance, KSSTATE_STOP);
    }

    ASSERT(pFilterInstance->cPinInstances[pPinInstanceData->PinId].CurrentCount > 0);
    (void) InterlockedDecrement((LONG *) &(pFilterInstance->cPinInstances[pPinInstanceData->PinId].CurrentCount));

    switch (pPinInstanceData->PinId)
    {
        case PIN_ID_MIDI_SINK:
            break;

        case PIN_ID_PCM_SOURCE:
            for(i = 0; i < NUM_WRITE_CONTEXT; i++)
            {
                if (pFilterInstance->aWriteContext[i].StreamHdr.Data)
                {
                    ExFreePool(pFilterInstance->aWriteContext[i].StreamHdr.Data);
                    pFilterInstance->aWriteContext[i].StreamHdr.Data = NULL;
                }
            }
            ObDereferenceObject( pFilterInstance->pNextFileObject );

            break;
    }
    KsFreeObjectHeader( pPinInstanceData->ObjectHeader ) ;
    ObDereferenceObject( pPinInstanceData->pFilterFileObject );
#if kAdjustingTimerRes
    ULONG returnVal = ExSetTimerResolution(kMidiTimerResolution100Ns,FALSE);
    _DbgPrintF( DEBUGLVL_TERSE, ("*** SWMidi: cleared timer resolution request (is now %d.%04d ms) ***",returnVal/10000,returnVal%10000));
#endif  //  kAdjustingTimerRes

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS PinDispatchIoControl(
                  IN PDEVICE_OBJECT   DeviceObject,
                  IN PIRP             pIrp
                 )
{
    NTSTATUS            Status;
    PFILTER_INSTANCE    pFilterInstance;
    PPIN_INSTANCE_DATA  pPinInstanceData;
    PIO_STACK_LOCATION  pIrpStack;

    pIrp->IoStatus.Information = 0;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pPinInstanceData = (PPIN_INSTANCE_DATA)pIrpStack->FileObject->FsContext;
    pFilterInstance = pPinInstanceData->pFilterInstance;

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_KS_PROPERTY:
            Status = KsPropertyHandler(
                           pIrp,
                           SIZEOF_ARRAY( Properties ),
                           (PKSPROPERTY_SET) Properties
                          );
            break;

        case IOCTL_KS_WRITE_STREAM:
            Status = ProcessMidiMessage( pIrp, pIrpStack, pFilterInstance );
            break;
#if (DBG)
        case IOCTL_KS_READ_STREAM:
            _DbgPrintF( DEBUGLVL_TERSE, ("READ_STREAM called!!!"));
#endif
        default:
            _DbgPrintF( DEBUGLVL_TERSE, ("Unknown Device Request: %x\n", pIrpStack->Parameters.DeviceIoControl.IoControlCode));
            return KsDefaultDeviceIoCompletion(DeviceObject,pIrp);
    }
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp,IO_NO_INCREMENT);
    return Status;
}

#if (0)
VOID
KdPrintMessage(BYTE *buffer,ULONG numBytes)
{
    ULONG count = 0;
    while (count < numBytes)
    {
        KdPrint(("' %02x ",buffer[count++]));
    }
    KdPrint(("'\n"));
}
#endif

NTSTATUS
ProcessMidiMessage(
           IN PIRP               pIrp,
           IN PIO_STACK_LOCATION pIrpStack,
           IN PFILTER_INSTANCE   pFilterInstance
          )
{
    if ((!pIrp) || (!pIrpStack) || (!pFilterInstance))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("*** SWMidi: NULL param to ProcessMidiMessage()! ***\n"));
        return STATUS_INVALID_PARAMETER;
    }

    PKSSTREAM_HEADER    pStreamHeader;
    PKSMUSICFORMAT      pMidiFormat;
    ULONG       remainingIrpBytes,bytesRecorded;
    NTSTATUS    ntStatus;
    BOOL        success;
    BYTE        *pbMusicData,event,note,velocity;
    STIME       adjustedSampleTime;
    ControlLogic *pSynth;
    KSTIME      *pKSTime;
    LONGLONG   presTime100Ns;

    ntStatus= KsProbeStreamIrp(pIrp,KSPROBE_STREAMREAD,sizeof(KSSTREAM_HEADER));
    if (NT_SUCCESS(ntStatus))
    {
        pSynth = pFilterInstance->pSynthesizer;
        if (!pSynth)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("SWMidi: ControlLogic object is NULL\n"));
            return STATUS_INVALID_PARAMETER;
        }
        pStreamHeader = PKSSTREAM_HEADER(pIrp->AssociatedIrp.SystemBuffer);
        if (!pStreamHeader)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("*** SWMidi: WRITE irp w/ invalid stream header! ***\n"));
            return STATUS_INVALID_PARAMETER;
        }

        _DbgPrintF(DEBUGLVL_MUTEX, ("\t ProcessMIDIMessage waiting for Mutex"));
        KeWaitForSingleObject(&gMutex,Executive,KernelMode,FALSE,NULL);

        remainingIrpBytes = pStreamHeader->DataUsed;
        pMidiFormat = (PKSMUSICFORMAT)(pStreamHeader->Data);

        if (!pMidiFormat)
        {
            remainingIrpBytes = 0;
            _DbgPrintF(DEBUGLVL_TERSE,("*** SWMidi stream header w/ no MidiFormat! ***\n"));
        }
        pKSTime = &(pStreamHeader->PresentationTime);
        presTime100Ns = (pKSTime->Time * pKSTime->Numerator) / pKSTime->Denominator;
        adjustedSampleTime = pSynth->Unit100NsToSamples(presTime100Ns);
        adjustedSampleTime = pSynth->CalibrateSampleTime(adjustedSampleTime);   //  calibrate STIME

        while (remainingIrpBytes > 0)   //  do entire IRP, regardless of individual parse errors
        {
            if (remainingIrpBytes >= (sizeof(KSMUSICFORMAT) + sizeof(ULONG)))
            {
                adjustedSampleTime += ((pMidiFormat->TimeDeltaMs) * (pSynth->SamplesPerMs()));

                pbMusicData = (BYTE *)(pMidiFormat + 1);
                event = note = velocity = 0;

                if (pMidiFormat->ByteCount > (remainingIrpBytes - sizeof(KSMUSICFORMAT)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE,("*** SWMidi: ByteCount is too big! ***\n"));
                    pMidiFormat->ByteCount = remainingIrpBytes - sizeof(KSMUSICFORMAT);
                }
                if (pMidiFormat->ByteCount >= 1)
                {
                    event = pbMusicData[0];
                    if (event >= 0x80)
                    {
                        if (pMidiFormat->ByteCount > 1)
                            note     = pbMusicData[1];
                        if (pMidiFormat->ByteCount > 2)
                            velocity = pbMusicData[2];
                        if (event <= 0xF0)
                            pFilterInstance->bRunningStatus = event;
                        else if (event <= 0xF7)
                            pFilterInstance->bRunningStatus = 0;
                        //KdPrintMessage(pbMusicData,pMidiFormat->ByteCount);
                    }
                    else    //  message starts with data, not status?  Use running status.
                    {
                        if (pFilterInstance->bRunningStatus)
                        {
                            note  = event;
                            event = pFilterInstance->bRunningStatus;

                            if (pMidiFormat->ByteCount > 1)
                                velocity = pbMusicData[1];
                            //KdPrint(("'(%02x)",pFilterInstance->bRunningStatus));
                            //KdPrintMessage(pbMusicData,pMidiFormat->ByteCount);
                        }
                        else
                        {
                            event = 0;      //  drop the nonsensical data on the floor
                            KeReleaseMutex(&gMutex, FALSE);
                            //KdPrintMessage(pbMusicData,pMidiFormat->ByteCount);
                            //KdPrint(("'XXX Bogus message! XXX"));
                            _DbgPrintF(DEBUGLVL_MUTEX, ("\t ProcessMidiMessage released Mutex, nonsense message"));
                            return STATUS_INVALID_PARAMETER;
                        }
                    }
                    if (pbMusicData[pMidiFormat->ByteCount - 1] == 0xF7)    //  end of SysEx
                        pFilterInstance->bRunningStatus = 0;
                    if (event)
                    {
                        if (event != 0xF0)  //  not SysEx
                        {
                            if (!pSynth->RecordMIDI(adjustedSampleTime,event,note,velocity))
                            {
                                _DbgPrintF( DEBUGLVL_TERSE, ("RecordMIDI failure"));
                                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                        else                //  handle a SysEx
                        {
                            (void) pSynth->RecordSysEx(adjustedSampleTime,pMidiFormat->ByteCount,pbMusicData);
                            //  We ignore the return code.
                            //  RecordSysEx returns FALSE for SysEx msgs it doesn't know.
                            //      This shouldn't be an IRP failure, though.
                            //  ??? It returns TRUE even if an allocation fails.
                            //      This SHOULD be an IRP failure.
                            //  Better to return the appropriate NTSTATUS, really.
                        }
                    }
                }   //  if byteCount
                else
                {
                    _DbgPrintF(DEBUGLVL_TERSE,("NIL KSMUSICFORMAT.ByteCount!  Ignoring msg\n"));
                }
                bytesRecorded = (pMidiFormat->ByteCount + 3) & ~3;
                pMidiFormat = PKSMUSICFORMAT(pbMusicData + bytesRecorded);
                remainingIrpBytes -= (sizeof(KSMUSICFORMAT) + bytesRecorded);
            }   //  if remainingIrpBytes >= KSMUSICFORMAT + ULONG
            else
            {
                _DbgPrintF( DEBUGLVL_TERSE, ("MIDI irp w/o room for KSMUSICFORMAT struct"));
                remainingIrpBytes = 0;
            }   //  if !(bytesLeft < musicformat+ULONG)
        }   //  while we have bytes left in IRP
        KeReleaseMutex(&gMutex, FALSE);
        _DbgPrintF(DEBUGLVL_MUTEX, ("\t ProcessMidiMessage released Mutex"));
    }   //  if we probed the IRP with success
    return ntStatus;
}

NTSTATUS PinDispatchWrite(
              IN PDEVICE_OBJECT   DeviceObject,
              IN PIRP             pIrp
             )
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpStack;
    PPIN_INSTANCE_DATA  pPinInstanceData;
    PFILTER_INSTANCE    pFilterInstance;

    Status = STATUS_SUCCESS;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pPinInstanceData = (PPIN_INSTANCE_DATA)pIrpStack->FileObject->FsContext;
    pFilterInstance = pPinInstanceData->pFilterInstance;

    Status = ProcessMidiMessage( pIrp, pIrpStack, pFilterInstance );

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return Status;
}

VOID SetDeviceState(PFILTER_INSTANCE pFilterInstance,KSSTATE state)
{
    short i;

    _DbgPrintF(DEBUGLVL_MUTEX, ("SetDeviceState waiting for Mutex"));
    KeWaitForSingleObject(&gMutex,Executive,KernelMode,FALSE,NULL);

    switch(state)
    {
        case KSSTATE_STOP:
            pFilterInstance->DeviceState = state;
            KeReleaseMutex(&gMutex, FALSE);
            _DbgPrintF(DEBUGLVL_MUTEX, ("\t SetDeviceState (STOP) released Mutex"));

            for (i = 0; i < NUM_WRITE_CONTEXT; i++)
            {
                DPF1(9, "PinState WC: %08x",
                     &pFilterInstance->aWriteContext[i]);

                KeWaitForSingleObject(
                              &pFilterInstance->aWriteContext[i].KEvent,
                              Executive,
                              KernelMode,
                              FALSE,                  // not alertable
                              NULL
                             );
            }
            return;     // already released mutex

        case KSSTATE_ACQUIRE:
            pFilterInstance->DeviceState = state;
            break;

        case KSSTATE_PAUSE:
            pFilterInstance->DeviceState = state;
            break;

        case KSSTATE_RUN:
            pFilterInstance->DeviceState = state;
            BeginWrite(pFilterInstance);
            break;

        default:
            break;
    }
    KeReleaseMutex(&gMutex, FALSE);
    _DbgPrintF(DEBUGLVL_MUTEX, ("\t SetDeviceState released Mutex"));
}

NTSTATUS PinStateHandler(
             IN PIRP             pIrp,
             IN PKSPROPERTY      pProperty,
             IN OUT PVOID        Data
            )
{
    PIO_STACK_LOCATION  pIrpStack;
    PKSSTATE            pDeviceState = (PKSSTATE)Data;
    PPIN_INSTANCE_DATA  pPinInstanceData;
    PFILTER_INSTANCE    pFilterInstance;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pPinInstanceData = (PPIN_INSTANCE_DATA)pIrpStack->FileObject->FsContext;
    pFilterInstance = pPinInstanceData->pFilterInstance;

    if (pProperty->Flags & KSPROPERTY_TYPE_GET)
    {
        *pDeviceState = pFilterInstance->DeviceState;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("PinState Set: from %d to %d",pFilterInstance->DeviceState,*pDeviceState));
        if (pFilterInstance->DeviceState != *pDeviceState)
        {
            //  mutex handled within function
            SetDeviceState(pFilterInstance,*pDeviceState);
        }
    }
    pIrp->IoStatus.Information = sizeof(KSSTATE);
    return STATUS_SUCCESS;
}

NTSTATUS BeginWrite(PFILTER_INSTANCE pFilterInstance)
{
    if (pFilterInstance->DeviceState == KSSTATE_RUN)
    {
        for (int i = 0; i < NUM_WRITE_CONTEXT; i++)
        {
            PWRITE_CONTEXT pWriteContext = &pFilterInstance->aWriteContext[i];
            if (pWriteContext->fulFlags & WRITE_CONTEXT_FLAGS_BUSY)
            {
                continue;
            }
            if (FillBuffer(pWriteContext))
            {
                WriteBuffer(pWriteContext);
            }
        }
    }
    return STATUS_SUCCESS;
}

BOOL FillBuffer(PWRITE_CONTEXT pWriteContext)
{
    if (pWriteContext)
    {
        if (pWriteContext->pFilterInstance)
        {
            ControlLogic        *pSynth;
            pSynth = pWriteContext->pFilterInstance->pSynthesizer;
            if (pSynth)
            {
                pSynth->Mix((short *)pWriteContext->StreamHdr.Data,
                            pWriteContext->StreamHdr.DataUsed >> (pSynth->m_dwStereo + 1));
                return true;
            }
            _DbgPrintF(DEBUGLVL_TERSE, ("FillBuffer failed, null pSynth!"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("FillBuffer failed, null pWriteContext->pFilterInstance!"));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("FillBuffer failed, null pWriteContext!"));
    }
    return false;
}

NTSTATUS WriteBuffer(PWRITE_CONTEXT pWriteContext)
{
    PIO_STACK_LOCATION pIrpStack;

    ASSERT((pWriteContext->fulFlags & WRITE_CONTEXT_FLAGS_BUSY) == 0);
    pWriteContext->fulFlags &= ~WRITE_CONTEXT_FLAGS_CANCEL;
    pWriteContext->fulFlags |= WRITE_CONTEXT_FLAGS_BUSY;
    DPF1(9, "WriteBuffer WC: %08x", pWriteContext);

    pWriteContext->pIrp = IoBuildDeviceIoControlRequest(
                            IOCTL_KS_WRITE_STREAM,
                            pWriteContext->pFilterInstance->pNextDevice,
                            &pWriteContext->StreamHdr,
                            sizeof(KSSTREAM_HEADER),
                            &pWriteContext->StreamHdr,
                            sizeof(KSSTREAM_HEADER),
                            FALSE,
                            NULL,
                            &DummyIoStatusBlock
                           );

    if (pWriteContext->pIrp == NULL)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("IoBuildDeviceIoControlRequest failed to return a non-zero IRP!"));
        return STATUS_UNSUCCESSFUL;
    }

    KeClearEvent(&pWriteContext->KEvent);
    pIrpStack = IoGetNextIrpStackLocation(pWriteContext->pIrp);
    pIrpStack->FileObject = pWriteContext->pFilterInstance->pNextFileObject;

    IoSetCompletionRoutine(
               pWriteContext->pIrp,
               WriteComplete,
               pWriteContext,
               TRUE,
               TRUE,
               TRUE
              );

    // don't we care about the return val?  seems odd.
    (void) IoCallDriver(pWriteContext->pFilterInstance->pNextDevice,
                        pWriteContext->pIrp);

    return (STATUS_SUCCESS);
}

// This can be called at DPC time

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS WriteComplete(PDEVICE_OBJECT pDeviceObject,PIRP pIrp,IN PVOID Context)
{
    PWRITE_CONTEXT pWriteContext = (PWRITE_CONTEXT)Context;
    PFILTER_INSTANCE pFilterInstance =
        (PFILTER_INSTANCE)(pWriteContext->pFilterFileObject->FsContext);

    if (pIrp->IoStatus.Status != STATUS_SUCCESS)
    {
        if (InterlockedIncrement(&pFilterInstance->cConsecutiveErrors) > MAX_ERROR_COUNT)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("WriteComplete, cancelled IRP after %d failed attempts",MAX_ERROR_COUNT));
            pIrp->Cancel=TRUE;
        }
    }
    else
    {
        pFilterInstance->cConsecutiveErrors = 0;
    }

    if (pIrp->Cancel)
    {
        DPF(1, "WriteComplete irp canceled");
        pWriteContext->fulFlags |= WRITE_CONTEXT_FLAGS_CANCEL;
    }
    ObReferenceObject ( pWriteContext->pFilterFileObject ) ;
    ExQueueWorkItem(&pWriteContext->WorkItem, HyperCriticalWorkQueue);

    return(STATUS_SUCCESS);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID WriteCompleteWorker(
             IN PVOID Parameter
            )
{
    PAGED_CODE();
    PWRITE_CONTEXT pWriteContext = (PWRITE_CONTEXT)Parameter;

    if ((pWriteContext->fulFlags & WRITE_CONTEXT_FLAGS_CANCEL) == 0)
    {
        _DbgPrintF(DEBUGLVL_MUTEX, ("WriteCompleteWorker waiting for Mutex"));
        KeWaitForSingleObject(&gMutex,Executive,KernelMode,FALSE,NULL);
    }
    pWriteContext->fulFlags &= ~WRITE_CONTEXT_FLAGS_BUSY;
    KeSetEvent(&pWriteContext->KEvent, 0, FALSE);
    DPF1(9, "WriteCompleteWorker WC: %08x", pWriteContext);

    // if the irp was canceled, don't send any more buffers
    if ((pWriteContext->fulFlags & WRITE_CONTEXT_FLAGS_CANCEL) == 0)
    {
        if (pWriteContext->pFilterInstance->DeviceState == KSSTATE_RUN)
        {
            if (FillBuffer(pWriteContext))
            {
                WriteBuffer(pWriteContext);
            }
        }
        KeReleaseMutex(&gMutex, FALSE);
        _DbgPrintF(DEBUGLVL_MUTEX, ("\t WriteCompleteWorker released Mutex"));
    }
    ObDereferenceObject ( pWriteContext->pFilterFileObject ) ;
}

//  Returns 100ns since system start
LONGLONG GetTime100Ns()
{
    LARGE_INTEGER liFrequency,liTime;

    //  total ticks since system booted
    liTime = KeQueryPerformanceCounter(&liFrequency);

    //  Convert ticks to 100ns units.
    //
    return (KSCONVERT_PERFORMANCE_TIME(liFrequency.QuadPart,liTime));
}
//---------------------------------------------------------------------------
//  End of File: pins.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\swmidi.h ===
//---------------------------------------------------------------------------
//
//  Module:   swmidi.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//
// Constants
//

#if (DBG)
#define STR_MODULENAME "'swmidi: "
#endif

#ifdef UNICODE
#define STR_LINKNAME    TEXT("\\DosDevices\\SWMIDI")
#define STR_DEVICENAME  TEXT("\\Device\\SWMIDI")
#else  // !UNICODE
#define STR_LINKNAME    TEXT(L"\\DosDevices\\SWMIDI")
#define STR_DEVICENAME  TEXT(L"\\Device\\SWMIDI")
#endif // !UNICODE

#define Trap()

#define SRC_BUF_SIZE        4096
#define NUM_WRITE_CONTEXT   2
#define MAX_NUM_PIN_TYPES   2
#define MAX_ERROR_COUNT     200

// Note that pin IDs reflect the direction of communication
// (sink or source) and not that of data flow.

#define PIN_ID_MIDI_SINK        0
#define PIN_ID_PCM_SOURCE       1

//
// These are some misc debug and error code defines used by the synthesizer
//


#define DPF(n,sz)
#define DPF1(n,sz,a)
#define DPF2(n,sz,a,b)
#define DPF3(n,sz,a,b,c)
#define DPF4(n,sz,a,b,c,d)
#define DPF5(n,sz,a,b,c,d,e)
#define DPF6(n,sz,a,b,c,d,e,f)
#define DPF7(n,sz,a,b,c,d,e,f,g)

#define STR_DLS_REGISTRY_KEY        (L"\\Registry\\Machine\\Software\\Microsoft\\DirectMusic")
#define STR_DLS_REGISTRY_NAME       (L"GMFilePath")
#define STR_DLS_DEFAULT             (L"\\SystemRoot\\System32\\Drivers\\gm.dls")

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// Data structures
//

typedef struct device_instance
{
    PVOID pDeviceHeader;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct write_context
{
    struct filter_instance *pFilterInstance;
    ULONG           fulFlags;
    PIRP            pIrp;
    PFILE_OBJECT    pFilterFileObject;
    KEVENT          KEvent;
    KSSTREAM_HEADER StreamHdr;
    WORK_QUEUE_ITEM WorkItem;
    IO_STATUS_BLOCK IoStatusBlock;
} WRITE_CONTEXT, *PWRITE_CONTEXT;

#define WRITE_CONTEXT_FLAGS_BUSY    0x00000001
#define WRITE_CONTEXT_FLAGS_CANCEL  0x00000002

typedef struct pin_instance_data
{
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate
    // handlers.  This structure is referenced by the device driver
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext
    //
    PVOID               ObjectHeader;
    PFILE_OBJECT    pFilterFileObject;
    struct filter_instance *pFilterInstance;
    ULONG       PinId;

} PIN_INSTANCE_DATA, *PPIN_INSTANCE_DATA;

typedef struct filter_instance
{
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate
    // handlers.  This structure is referenced by the device driver
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext
    //

    PVOID               ObjectHeader;
    PFILE_OBJECT        pNextFileObject;
    PDEVICE_OBJECT      pNextDevice;
    KSPIN_CINSTANCES    cPinInstances[MAX_NUM_PIN_TYPES];
    PIN_INSTANCE_DATA   PinInstanceData[MAX_NUM_PIN_TYPES];
    WRITE_CONTEXT       aWriteContext[NUM_WRITE_CONTEXT];
    KSSTATE             DeviceState;
    ControlLogic        *pSynthesizer;
    BYTE                bRunningStatus;
    BYTE                bSecondByte;
    BOOLEAN             fThirdByte;
    LONG                cConsecutiveErrors;

} FILTER_INSTANCE, *PFILTER_INSTANCE;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#define kAdjustingTimerRes      1
//
//  1 millisecond timer resolution
//
#if kAdjustingTimerRes
#define kMidiTimerResolution100Ns (10000)
#endif  //  kAdjustingTimerRes

#ifdef __cplusplus
extern "C" {
#endif

//
// global data
//

extern  KSPIN_DESCRIPTOR    PinDescs[MAX_NUM_PIN_TYPES];
extern  const KSPIN_CINSTANCES  gcPinInstances[MAX_NUM_PIN_TYPES];
extern  KSDISPATCH_TABLE    FilterDispatchTable;
extern  KSDISPATCH_TABLE    PinDispatchTable;
extern  KMUTEX              gMutex;

#define DEBUGLVL_MUTEX DEBUGLVL_BLAB
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// local prototypes
//

NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING usRegistryPathName
);

NTSTATUS DispatchPnp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
);

NTSTATUS PnpAddDevice
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
);

VOID PnpDriverUnload
(
    IN PDRIVER_OBJECT DriverObject
);

NTSTATUS FilterDispatchCreate
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS FilterDispatchIoControl
(
    IN PDEVICE_OBJECT   pdo,
    IN PIRP     pIrp
);

NTSTATUS FilterDispatchWrite
(
    IN PDEVICE_OBJECT   pdo,
    IN PIRP             pIrp
);

NTSTATUS FilterDispatchClose
(
    IN PDEVICE_OBJECT   pdo,
    IN PIRP             pIrp
);

NTSTATUS FilterPinInstances
(
    IN  PIRP                pIrp,
    IN  PKSP_PIN            pPin,
    OUT PKSPIN_CINSTANCES   pCInstances
);

NTSTATUS
FilterPinIntersection(
    IN PIRP     pIrp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
);

NTSTATUS FilterPinPropertyHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PVOID    pvData
);

NTSTATUS PinDispatchCreate
(
    IN PDEVICE_OBJECT   pdo,
    IN PIRP             pIrp
);

NTSTATUS PinDispatchClose
(
    IN PDEVICE_OBJECT   pdo,
    IN PIRP             pIrp
);

NTSTATUS PinDispatchWrite
(
    IN PDEVICE_OBJECT   pdo,
    IN PIRP             pIrp
);

NTSTATUS PinDispatchIoControl
(
    IN PDEVICE_OBJECT   pdo,
    IN PIRP             pIrp
);

VOID SetDeviceState
(
    IN PFILTER_INSTANCE pFilterInstance,
    IN KSSTATE          state
);

NTSTATUS PinStateHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PVOID    Data
);

NTSTATUS BeginWrite
(
    PFILTER_INSTANCE    pFilterInstance
);

BOOL FillBuffer
(
    PWRITE_CONTEXT  pWriteContext
);

NTSTATUS WriteBuffer
(
    PWRITE_CONTEXT  pWriteContext
);

NTSTATUS WriteComplete
(
    PDEVICE_OBJECT  pdo,
    PIRP            pIrp,
    IN PVOID        Context
);

VOID WriteCompleteWorker
(
    IN PVOID        Parameter
);

LONGLONG GetTime100Ns(VOID);

int MulDiv
(
    int nNumber,
    int nNumerator,
    int nDenominator
);

#ifdef __cplusplus
}
#endif

//---------------------------------------------------------------------------
//  End of File: swmidi.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\voice.cpp ===
//      Voice.cpp
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//      All rights reserved.
//

#include "common.h"
#include <math.h>


VoiceLFO::VoiceLFO()

{
    m_pModWheelIn = NULL;
}

STIME VoiceLFO::StartVoice(SourceLFO *pSource, 
            STIME stStartTime,ModWheelIn * pModWheelIn)
{
    m_pModWheelIn = pModWheelIn;
    m_Source = *pSource;
    m_stStartTime = stStartTime;
    if ((m_Source.m_prMWPitchScale == 0) && (m_Source.m_vrMWVolumeScale == 0) 
        && (m_Source.m_prPitchScale == 0) && (m_Source.m_vrVolumeScale == 0))
    {
        m_stRepeatTime = 44100;
    }
    else
    {
        m_stRepeatTime = 131072 / m_Source.m_pfFrequency; // (1/8 * 256 * 4096)
    }
    return (m_stRepeatTime);
}

long VoiceLFO::GetLevel(STIME stTime, STIME *pstNextTime)

{
    stTime -= (m_stStartTime + m_Source.m_stDelay);
    if (stTime < 0) 
    {
        *pstNextTime = -stTime;
        return (0);
    }
    *pstNextTime = m_stRepeatTime;
    stTime *= m_Source.m_pfFrequency;
    stTime = stTime >> 12;
    return (m_snSineTable[stTime & 0xFF]);
}

VREL VoiceLFO::GetVolume(STIME stTime, STIME *pstNextTime)

{
    VREL vrVolume = m_pModWheelIn->GetModulation(stTime);
    vrVolume *= m_Source.m_vrMWVolumeScale;
    vrVolume /= 127;
    vrVolume += m_Source.m_vrVolumeScale;
    vrVolume *= GetLevel(stTime,pstNextTime);
    vrVolume /= 100;
    return (vrVolume);
}

PREL VoiceLFO::GetPitch(STIME stTime, STIME *pstNextTime)

{
    PREL prPitch = m_pModWheelIn->GetModulation(stTime);
    prPitch *= m_Source.m_prMWPitchScale;
    prPitch /= 127;
    prPitch += m_Source.m_prPitchScale;
    prPitch *= GetLevel(stTime,pstNextTime);
    prPitch /= 100;
    return (prPitch);
}

VoiceEG::VoiceEG()
{
    m_stStopTime = 0;
}

void VoiceEG::StopVoice(STIME stTime)

{
    m_Source.m_stRelease *= GetLevel(stTime,&m_stStopTime,TRUE);    // Adjust for current sustain level.
    m_Source.m_stRelease /= 1000;
    m_stStopTime = stTime;
}

void VoiceEG::QuickStopVoice(STIME stTime, DWORD dwSampleRate)

{
    m_Source.m_stRelease *= GetLevel(stTime,&m_stStopTime,TRUE);    // Adjust for current sustain level.
    m_Source.m_stRelease /= 1000;
    dwSampleRate /= 70;
    if (m_Source.m_stRelease > (long) dwSampleRate)
    {
        m_Source.m_stRelease = dwSampleRate;
    }
    m_stStopTime = stTime;
}

STIME VoiceEG::StartVoice(SourceEG *pSource, STIME stStartTime, 
            WORD nKey, WORD nVelocity)

{
    m_stStartTime = stStartTime;
    m_stStopTime = MAX_STIME;      // set to indefinite future
    m_Source = *pSource;

    // apply velocity to attack length scaling here
    m_Source.m_stAttack *= DigitalAudio::PRELToPFRACT(nVelocity * m_Source.m_trVelAttackScale / 127);
    m_Source.m_stAttack /= 4096;

    m_Source.m_stDecay *= DigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stDecay /= 4096;

    m_Source.m_stDecay *= (1000 - m_Source.m_pcSustain);
    m_Source.m_stDecay /= 1000;
    return ((STIME)m_Source.m_stAttack);
}

BOOL VoiceEG::InAttack(STIME st)
{
    // has note been released?
    if (st >= m_stStopTime)
        return FALSE;

    // past length of attack?
    if (st >= m_stStartTime + m_Source.m_stAttack)
        return FALSE;

    return TRUE;
}
    
BOOL VoiceEG::InRelease(STIME st)
{
    // has note been released?
    if (st > m_stStopTime)
        return TRUE;

    return FALSE;
}
    
long VoiceEG::GetLevel(STIME stEnd, STIME *pstNext, BOOL fVolume)

{
    LONGLONG    lLevel = 0;

    if (stEnd <= m_stStopTime)
    {
        stEnd -= m_stStartTime;
        if (stEnd < 0)
        {
            stEnd = 0;  //  should never happen
        }
        // note not released yet.
        if (stEnd < m_Source.m_stAttack)
        {
            // still in attack
            lLevel = 1000 * stEnd;
            lLevel /= m_Source.m_stAttack;  //  m_Source.m_stAttack must > 0, see above IF
            *pstNext = m_Source.m_stAttack - stEnd;
            if (fVolume)
            {
                lLevel = m_snAttackTable[lLevel / 5];
            }
        }
        else 
        {
            stEnd -= m_Source.m_stAttack;
            
            if (stEnd < m_Source.m_stDecay)
            {
                // still in decay
                lLevel = (1000 - m_Source.m_pcSustain) * stEnd;
                lLevel /= m_Source.m_stDecay;
                lLevel = 1000 - lLevel;
// To improve the decay curve, set the next point to be 1/4, 1/2, or end of slope. 
// To avoid close duplicates, fudge an extra 100 samples.
                if (stEnd < ((m_Source.m_stDecay >> 2) - 100))
                {
                    *pstNext = (m_Source.m_stDecay >> 2) - stEnd;
                }       
                else if (stEnd < ((m_Source.m_stDecay >> 1) - 100))
                {
                    *pstNext = (m_Source.m_stDecay >> 1) - stEnd;
                }
                else
                {
                    *pstNext = m_Source.m_stDecay - stEnd;  // Next is end of decay.
                }
            }
            else
            {
                // in sustain
                lLevel = m_Source.m_pcSustain;
                *pstNext = 44100;
            }
        }
    }
    else
    {
        STIME stBogus;
        // in release
        stEnd -= m_stStopTime;

        if (stEnd < m_Source.m_stRelease)
        {
            lLevel = GetLevel(m_stStopTime,&stBogus,fVolume) * (m_Source.m_stRelease - stEnd);
            lLevel /= m_Source.m_stRelease;
            if (stEnd < ((m_Source.m_stRelease >> 2) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 2) - stEnd;
            }   
            else if (stEnd < ((m_Source.m_stRelease >> 1) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 1) - stEnd;
            }
            else
            {
                *pstNext = m_Source.m_stRelease - stEnd;  // Next is end of decay.
            }
        }
        else
        {
            lLevel = 0;   // !!! off
            *pstNext = 0x7FFFFFFFFFFFFFFF;
        }
    }

    return long(lLevel);
}

VREL VoiceEG::GetVolume(STIME stTime, STIME *pstNextTime)

{
    VREL vrLevel = GetLevel(stTime, pstNextTime, TRUE) * 96;
    vrLevel /= 10;
    vrLevel = vrLevel - 9600;
    return vrLevel;
}

PREL VoiceEG::GetPitch(STIME stTime, STIME *pstNextTime)

{
    PREL prLevel;
    if (m_Source.m_sScale != 0)
    {
        prLevel = GetLevel(stTime, pstNextTime,FALSE);
        prLevel *= m_Source.m_sScale;
        prLevel /= 1000;
    }
    else
    {
        *pstNextTime = 44100;
        prLevel = 0;
    }
    return prLevel;
}

DigitalAudio::DigitalAudio()
{
    m_pControl = NULL;
    m_pcTestSourceBuffer = NULL;
    m_pfBasePitch = 0;
    m_pfLastPitch = 0;
    m_pfLastSample = 0;
    m_pfLoopEnd = 0;
    m_pfLoopStart = 0;
    m_pfSampleLength = 0;
    m_pnTestWriteBuffer = NULL;
    m_prLastPitch = 0;
    m_vrLastLVolume = 0;
    m_vrLastRVolume = 0;
    m_vrBaseLVolume = 0;
    m_vrBaseRVolume = 0;
    m_vfLastLVolume = 0;
    m_vfLastRVolume = 0;
};

BOOL DigitalAudio::StartCPUTests()

{
    DWORD dwIndex;
    m_pcTestSourceBuffer = new char[TEST_SOURCE_SIZE];
    if (m_pcTestSourceBuffer == NULL)
    {
        return FALSE;
    }
    m_pnTestWriteBuffer = new short[TEST_WRITE_SIZE];
    if (m_pnTestWriteBuffer == NULL)
    {   
        EndCPUTests();
        return FALSE;
    }
    m_Source.m_pWave = new Wave;
    if (m_Source.m_pWave == NULL)
    {
        EndCPUTests();
        return FALSE;
    }
    for (dwIndex = 0;dwIndex < TEST_SOURCE_SIZE; dwIndex++)
    {
        m_pcTestSourceBuffer[dwIndex] = (char) (rand() & 0xFF);
    }
    for (dwIndex = 0;dwIndex < (TEST_SOURCE_SIZE - 1); dwIndex++)
    {
        if (((int) m_pcTestSourceBuffer[dwIndex + 1] - (int) m_pcTestSourceBuffer[dwIndex]) >= 128)
            m_pcTestSourceBuffer[dwIndex + 1] = m_pcTestSourceBuffer[dwIndex] + 127;
        else if (((int) m_pcTestSourceBuffer[dwIndex] - (int) m_pcTestSourceBuffer[dwIndex + 1]) > 128)
            m_pcTestSourceBuffer[dwIndex + 1] = m_pcTestSourceBuffer[dwIndex] - 128;
    }
    ASSERT(NULL == m_Source.m_pWave->m_pnWave);
    m_Source.m_pWave->m_pnWave = (short *) m_pcTestSourceBuffer;
    m_Source.m_dwLoopEnd = (TEST_SOURCE_SIZE / 2) - 1;
    m_Source.m_dwSampleLength = TEST_SOURCE_SIZE / 2;
    m_Source.m_dwLoopStart = 100;
    m_Source.m_bOneShot = FALSE;
    m_pfLoopEnd = m_Source.m_dwLoopEnd << 12;
    m_pfLoopStart = m_Source.m_dwLoopStart << 12;
    return TRUE;
}

void DigitalAudio::EndCPUTests()

{
    if (m_Source.m_pWave != NULL)
    {
        ASSERT(m_pcTestSourceBuffer == (char *)(m_Source.m_pWave->m_pnWave));
        m_Source.m_pWave->m_pnWave = NULL;
        delete m_Source.m_pWave;
        m_Source.m_pWave = NULL;
    }
    if (m_pnTestWriteBuffer != NULL)
    {   
        delete m_pnTestWriteBuffer;
        m_pnTestWriteBuffer = NULL;
    }
    if (m_pcTestSourceBuffer != NULL)
    {   
        delete m_pcTestSourceBuffer;
        m_pcTestSourceBuffer = NULL;
    }
}

DWORD DigitalAudio::TestCPU(DWORD dwMixChoice)

{
    DWORD dwResult = 1000;
    DWORD dwCount = 0;
    DWORD dwSpeed = 0;
    for (dwCount = 0;dwCount < 3; dwCount++)
    {
        DWORD dwStart = 0;
        DWORD dwLength;
        DWORD dwPeriod = 40;
        DWORD dwSoFar;
        VFRACT vfDeltaLVolume;
        VFRACT vfDeltaRVolume;
        PFRACT pfDeltaPitch;
        PFRACT pfEnd = m_Source.m_dwSampleLength << 12;
        PFRACT pfLoopLen = m_pfLoopEnd - m_pfLoopStart;

        LONGLONG    llTime100Ns = - (::GetTime100Ns());
        memset(m_pnTestWriteBuffer,0,TEST_WRITE_SIZE);
        m_pfLastSample = 0;
        m_vfLastLVolume = 0;
        m_vfLastRVolume = 0;
        m_pfLastPitch = 4096;
        if (dwMixChoice & SPLAY_STEREO)
        {
            dwLength = TEST_WRITE_SIZE / 2;
        }
        else
        {
            dwLength = TEST_WRITE_SIZE;
        }
#ifdef MMX_ENABLED
        if (m_sfMMXEnabled && 
//                      (dwMixChoice & SPLAY_STEREO) &&         //      OK to MMX mono streams now!
            (!(dwMixChoice & SFORMAT_COMPRESSED)))
        {
           dwMixChoice |= SPLAY_MMX | SPLAY_INTERPOLATE; 
        }
#endif
        if (m_pnDecompMult == NULL)
        {
            dwMixChoice &= ~SFORMAT_COMPRESSED;
        }
        for (dwSoFar = 0;dwSoFar < (DWORD)(22050 << dwSpeed);)
        {
            if ((dwLength + dwSoFar) > (DWORD)(22050 << dwSpeed)) 
            {
                dwLength = (22050 << dwSpeed) - dwSoFar;
            }
            if (dwLength <= 8)
            {
                dwMixChoice &= ~SPLAY_MMX;
            }
            if (dwLength == 0)
            {
                break;
            }
            vfDeltaLVolume = MulDiv((rand() % 4000) - m_vfLastLVolume,
            dwPeriod << 8,dwLength);
            vfDeltaRVolume = MulDiv((rand() % 4000) - m_vfLastRVolume,
            dwPeriod << 8,dwLength);
            pfDeltaPitch = MulDiv((rand() % 2000) + 3000 - m_pfLastPitch,
            dwPeriod << 8,dwLength);
            switch (dwMixChoice)
            {
                case SFORMAT_8 | SPLAY_STEREO | SPLAY_INTERPOLATE :
                    dwSoFar += Mix8(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_8 | SPLAY_INTERPOLATE :
                    dwSoFar += MixMono8(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_8 | SPLAY_STEREO :
                    dwSoFar += Mix8NoI(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfEnd, pfLoopLen );
                    break;
                case SFORMAT_8 :
                    dwSoFar += MixMono8NoI(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume,
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_16 | SPLAY_STEREO | SPLAY_INTERPOLATE :
                    dwSoFar += Mix16(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_16 | SPLAY_INTERPOLATE :
                    dwSoFar += MixMono16(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_16 | SPLAY_STEREO :
                    dwSoFar += Mix16NoI(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfEnd, pfLoopLen );
                    break;
                case SFORMAT_16 :
                    dwSoFar += MixMono16NoI(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume,
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_COMPRESSED | SPLAY_STEREO | SPLAY_INTERPOLATE :
                    dwSoFar += MixC(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_COMPRESSED | SPLAY_INTERPOLATE :
                    dwSoFar += MixMonoC(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_COMPRESSED | SPLAY_STEREO :
                    dwSoFar += MixCNoI(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfEnd, pfLoopLen );
                    break;
                case SFORMAT_COMPRESSED :
                    dwSoFar += MixMonoCNoI(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume,
                    pfEnd, pfLoopLen);
                    break;
#ifdef MMX_ENABLED
                case SFORMAT_8 | SPLAY_MMX | SPLAY_STEREO | SPLAY_INTERPOLATE :
                    dwSoFar += Mix8X(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_16 | SPLAY_MMX | SPLAY_STEREO | SPLAY_INTERPOLATE :
                    dwSoFar += Mix16X(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, vfDeltaRVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break; 
                case SFORMAT_8 | SPLAY_MMX | SPLAY_INTERPOLATE :
                    dwSoFar += MixMono8X(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume, 
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break;
                case SFORMAT_16 | SPLAY_MMX | SPLAY_INTERPOLATE :
                    dwSoFar += MixMono16X(m_pnTestWriteBuffer,dwLength,dwPeriod,
                    vfDeltaLVolume,
                    pfDeltaPitch, 
                    pfEnd, pfLoopLen);
                    break; 
                    //      OK to MMX mono now!
#endif
                default :
                return (1);
            }
        }
        llTime100Ns += ::GetTime100Ns();
        DWORD dwDelta = DWORD(llTime100Ns / 10000);
        //  convert to millisec
        dwDelta >>= dwSpeed;
        if (dwResult > dwDelta)
        {
            dwResult = dwDelta;
        }
        if (dwResult < 1)
        {
            dwSpeed++;
        }
    }
    if (dwResult < 1)
        dwResult = 1;
    return dwResult;
}

VFRACT DigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;
    if (vrVolume < MINDB * 10) 
        vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10) 
        vrVolume = MAXDB * 10;
    return (m_svfDbToVolume[vrVolume - MINDB * 10]);
}

PFRACT DigitalAudio::PRELToPFRACT(PREL prPitch)

{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        if (prPitch > 4800)
        {
            prPitch = 4800;
        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        if (prPitch < -4800)
        {
            prPitch = -4800;
        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}

void DigitalAudio::ClearVoice()
{
    if (m_Source.m_pWave != NULL)
    {
        if (m_Source.m_pWave->IsLocked())
        {
            m_Source.m_pWave->UnLock();     // Unlocks wave data.
        }
        m_Source.m_pWave->Release();    // Releases wave structure.
        m_Source.m_pWave = NULL;
    }
}

STIME DigitalAudio::StartVoice(ControlLogic *pControl,
                   SourceSample *pSample, 
                   VREL vrBaseLVolume,
                   VREL vrBaseRVolume,
                   PREL prBasePitch,
                   long lKey)
{
    m_vrBaseLVolume = vrBaseLVolume;
    m_vrBaseRVolume = vrBaseRVolume;
    m_vfLastLVolume = VRELToVFRACT(MIN_VOLUME); 
    m_vfLastRVolume = VRELToVFRACT(MIN_VOLUME);
    m_vrLastLVolume = 0;
    m_vrLastRVolume = 0;
    m_prLastPitch = 0;
    m_Source = *pSample;
    m_pControl = pControl;
    pSample->m_pWave->AddRef(); // Keeps track of Wave usage.

    pSample->m_pWave->Lock();   // Keeps track of Wave data usage.

    prBasePitch += pSample->m_prFineTune;
    prBasePitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= pSample->m_dwSampleRate;
    m_pfBasePitch /= pControl->m_dwSampleRate;
    m_pfLastSample = 0;
    m_pfLastPitch = m_pfBasePitch;
    m_pfLoopStart = pSample->m_dwLoopStart << 12; // !!! allow fractional loop points
    m_pfLoopEnd = pSample->m_dwLoopEnd << 12;     // in samples!
    if (m_pfLoopEnd <= m_pfLoopStart) // Should never happen, but death if it does!
    {
        m_Source.m_bOneShot = TRUE;
    }
    m_pfSampleLength = pSample->m_dwSampleLength << 12;

    DPF3(5, "Base Pitch: %ld, Base Volume: %ld, %ld",
        m_pfBasePitch,m_vrBaseLVolume,m_vrBaseRVolume);
    return (0); // !!! what is this return value?
}

/*long abs(long lValue)

{
    if (lValue < 0)
    {
        return (0 - lValue);
    }
    return lValue;
}*/

BOOL DigitalAudio::Mix(short *pBuffer,
               DWORD dwLength, // length in SAMPLES
               VREL vrVolumeL,
               VREL vrVolumeR,
               PREL prPitch,
               DWORD dwStereo)
{
    PFRACT pfDeltaPitch;
    PFRACT pfEnd;
    PFRACT pfLoopLen;
    PFRACT pfNewPitch;
    VFRACT vfNewLVolume;
    VFRACT vfNewRVolume;
    VFRACT vfDeltaLVolume;
    VFRACT vfDeltaRVolume;
    DWORD dwPeriod = 64;
    DWORD dwSoFar;
    DWORD dwStart; // position in WORDs
    DWORD dwMixChoice = dwStereo ? SPLAY_STEREO : 0;

    if (dwLength == 0)      // Attack was instant. 
    {
        m_pfLastPitch = (m_pfBasePitch * PRELToPFRACT(prPitch)) >> 12;
        m_vfLastLVolume = VRELToVFRACT(m_vrBaseLVolume + vrVolumeL);
        m_vfLastRVolume = VRELToVFRACT(m_vrBaseRVolume + vrVolumeR);
        m_prLastPitch = prPitch;
        m_vrLastLVolume = vrVolumeL;
        m_vrLastRVolume = vrVolumeR;
        return (TRUE);
    }
    if ((m_Source.m_pWave == NULL) || (m_Source.m_pWave->m_pnWave == NULL))
    {
        return FALSE;
    }
    DWORD dwMax = abs(vrVolumeL - m_vrLastLVolume);
    m_vrLastLVolume = vrVolumeL;
    dwMax = max((long)dwMax,abs(vrVolumeR - m_vrLastRVolume));
    m_vrLastRVolume = vrVolumeR;
    dwMax = max((long)dwMax,abs(prPitch - m_prLastPitch) << 1);
    dwMax >>= 1;
    m_prLastPitch = prPitch;
    if (dwMax > 0)
    {
        dwPeriod = (dwLength << 3) / dwMax;
        if (dwPeriod > 512)
        {
            dwPeriod = 512;
        }
        else if (dwPeriod < 1)
        {
            dwPeriod = 1;
        }
    }
    else
    {
        dwPeriod = 512;     // Make it happen anyway.
    }

    // This makes MMX sound a little better (MMX bug will be fixed)
    dwPeriod += 3;
    dwPeriod &= 0xFFFFFFFC;

    pfNewPitch = m_pfBasePitch * PRELToPFRACT(prPitch);
    pfNewPitch >>= 12;

    pfDeltaPitch = MulDiv(pfNewPitch - m_pfLastPitch,dwPeriod << 8,dwLength);
    vfNewLVolume = VRELToVFRACT(m_vrBaseLVolume + vrVolumeL);
    vfNewRVolume = VRELToVFRACT(m_vrBaseRVolume + vrVolumeR);
    vfDeltaLVolume = MulDiv(vfNewLVolume - m_vfLastLVolume,dwPeriod << 8,dwLength);
    vfDeltaRVolume = MulDiv(vfNewRVolume - m_vfLastRVolume,dwPeriod << 8,dwLength);
    // check for no change in pitch at all
    if ((pfDeltaPitch != 0) || (pfNewPitch != 0x1000) || (m_pfLastSample & 0xFFF ))
    {
        dwMixChoice |= SPLAY_INTERPOLATE;
    }
    //INTEL:  Logic added to support Multimedia engines
  
    // Don't use the Multimedia engines unless:
    // - The processor supports them
    // -     We are doing stereo output
    // - There are more than 8 samples to process.  (The Multimedia engines
    //   will not work if there are 8 or less sample points to process.  They
    //   may cause access violations!!!)
#ifdef MMX_ENABLED
    if (m_sfMMXEnabled && 
//              (dwMixChoice & SPLAY_STEREO) && 
        (m_Source.m_bSampleType != SFORMAT_COMPRESSED) && 
        dwLength > 8)
    {
    // Set the interpolate flag along the with the MMX flag.
    // Since there is almost no performance gain in a non interpolation
    // MMX engine, we don't have one.
        dwMixChoice |= SPLAY_MMX | SPLAY_INTERPOLATE;
    }
#endif

    dwMixChoice |= m_Source.m_bSampleType;
    if (m_pnDecompMult == NULL)
    {
        dwMixChoice &= ~SFORMAT_COMPRESSED;
    }
    dwStart = 0;
    if (m_Source.m_bOneShot)
    {
        pfEnd = m_pfSampleLength;
        pfLoopLen = 0;
    }
    else
    {
        pfEnd = m_pfLoopEnd;
        pfLoopLen = m_pfLoopEnd - m_pfLoopStart;
    }
    for (;;)
    {
        if (dwLength <= 8)
        {
            dwMixChoice &= ~SPLAY_MMX;
        }
        switch (dwMixChoice)
        {
            case SFORMAT_8 | SPLAY_STEREO | SPLAY_INTERPOLATE :
                dwSoFar = Mix8(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_8 | SPLAY_INTERPOLATE :
                dwSoFar = MixMono8(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_8 | SPLAY_STEREO :
                dwSoFar = Mix8NoI(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfEnd, pfLoopLen );
                break;
            case SFORMAT_8 :
                dwSoFar = MixMono8NoI(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_16 | SPLAY_STEREO | SPLAY_INTERPOLATE :
                dwSoFar = Mix16(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_16 | SPLAY_INTERPOLATE :
                dwSoFar = MixMono16(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_16 | SPLAY_STEREO :
                dwSoFar = Mix16NoI(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfEnd, pfLoopLen );
                break;
            case SFORMAT_16 :
                dwSoFar = MixMono16NoI(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_COMPRESSED | SPLAY_STEREO | SPLAY_INTERPOLATE :
                dwSoFar = MixC(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_COMPRESSED | SPLAY_INTERPOLATE :
                dwSoFar = MixMonoC(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_COMPRESSED | SPLAY_STEREO :
                dwSoFar = MixCNoI(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfEnd, pfLoopLen );
                break;
            case SFORMAT_COMPRESSED :
                dwSoFar = MixMonoCNoI(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfEnd, pfLoopLen);
                break;
#ifdef MMX_ENABLED
            case SFORMAT_8 | SPLAY_MMX | SPLAY_STEREO | SPLAY_INTERPOLATE :
                dwSoFar = Mix8X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_16 | SPLAY_MMX | SPLAY_STEREO | SPLAY_INTERPOLATE :
                dwSoFar = Mix16X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break; 
            case SFORMAT_8 | SPLAY_MMX | SPLAY_INTERPOLATE :
                dwSoFar = MixMono8X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break;
            case SFORMAT_16 | SPLAY_MMX | SPLAY_INTERPOLATE :
                dwSoFar = MixMono16X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, 
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
                break; 
                //      OK to MMX mono now!
#endif
            default :
                return (FALSE);
        }
        if (m_Source.m_bOneShot)
        {
            if (dwSoFar < dwLength) 
            {
                return (FALSE);
            }
            break;
        }
        else
        {
            if (dwSoFar >= dwLength) break;

// !!! even though we often handle loops in the mix function, sometimes
// we don't, so we still need this code.
            // otherwise we must have reached the loop's end.
            dwStart += dwSoFar << dwStereo;
            dwLength -= dwSoFar;
            m_pfLastSample -= (m_pfLoopEnd - m_pfLoopStart);  
        }
    }
   
    m_vfLastLVolume = vfNewLVolume;
    m_vfLastRVolume = vfNewRVolume;
    m_pfLastPitch = pfNewPitch;
    return (TRUE);
}

Voice::Voice()
{
    m_pPitchBendIn = NULL;
    m_pExpressionIn = NULL;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_stStartTime = 0;
    m_stStopTime = MAX_STIME;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
}

void Voice::StopVoice(STIME stTime)

{
    if (m_fNoteOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.StopVoice(stTime);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
}

void Voice::QuickStopVoice(STIME stTime)

{
    m_fTag = TRUE;
    if (m_fNoteOn || m_fSustainOn)
    {
        if (stTime <= m_stStartTime) 
            stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.QuickStopVoice(stTime,m_pControl->m_dwSampleRate);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
    else
    {
        m_VolumeEG.QuickStopVoice(m_stStopTime,m_pControl->m_dwSampleRate);
    }
}

BOOL Voice::StartVoice(
                        ControlLogic *pControl,
                        SourceRegion *pRegion, 
                        STIME stStartTime,
                        ModWheelIn * pModWheelIn,
                        PitchBendIn * pPitchBendIn,
                        ExpressionIn * pExpressionIn,
                        VolumeIn * pVolumeIn,
                        PanIn * pPanIn,
                        WORD nKey,
                        WORD nVelocity,
                        VREL vrVolume,
                        PREL prPitch)
{
    SourceArticulation * pArticulation = pRegion->m_pArticulation;
    if (pArticulation == NULL)
    {
        return FALSE;
    }
    // if we're going to handle volume later, don't read it now.
    if (!pControl->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += pVolumeIn->GetVolume(stStartTime);
    prPitch += pRegion->m_prTuning;
    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    m_pControl = pControl;

    vrVolume += ((MIDIRecorder::VelocityToVolume(nVelocity)
           * (long) pArticulation->m_sVelToVolScale) / -9600);

    vrVolume += pRegion->m_vrAttenuation;
    vrVolume += 1200;   // boost an additional 12dB

    m_lDefaultPan = pRegion->m_pArticulation->m_sDefaultPan;
    // ignore pan here if allowing pan to vary after note starts

    VREL vrLVolume;
    VREL vrRVolume;
    if (pControl->m_dwStereo && !pControl->m_fAllowPanWhilePlayingNote)
    {
        long lPan = pPanIn->GetPan(stStartTime) + m_lDefaultPan;
        if (lPan < 0)
            lPan = 0;
        if (lPan > 127)
            lPan = 127;
        vrLVolume = m_svrPanToVREL[127 - lPan] + vrVolume;
        vrRVolume = m_svrPanToVREL[lPan] + vrVolume;
    } 
    else
    {
        vrLVolume = vrVolume;
        vrRVolume = vrVolume;
    }
    
    m_stMixTime = m_LFO.StartVoice(&pArticulation->m_LFO,
    stStartTime, pModWheelIn);
    STIME stMixTime = m_PitchEG.StartVoice(&pArticulation->m_PitchEG,
    stStartTime, nKey, nVelocity);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }
    stMixTime = m_VolumeEG.StartVoice(&pArticulation->m_VolumeEG,
        stStartTime, nKey, nVelocity);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }
    if (m_stMixTime > pControl->m_stMaxSpan)
    {
        m_stMixTime = pControl->m_stMaxSpan;
    }
    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }
    m_DigitalAudio.StartVoice(pControl,&pRegion->m_Sample,
    vrLVolume, vrRVolume, prPitch, (long)nKey);

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pVolumeIn = pVolumeIn;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = MAX_STIME;
    

    if (m_stMixTime == 0)
    {
        // zero length attack, be sure it isn't missed....
        PREL prPitch1 = GetNewPitch(stStartTime);
        VREL vrVolume1, vrVolumeR;
        GetNewVolume(stStartTime, vrVolume1, vrVolumeR);

        if (m_stMixTime > pControl->m_stMaxSpan)
        {
            m_stMixTime = pControl->m_stMaxSpan;
        }

        m_DigitalAudio.Mix(NULL, 0,
                   vrVolume1, vrVolumeR, prPitch1,
                   m_pControl->m_dwStereo);
    }
    m_vrVolume = 0;
    return (TRUE);
}
    
void Voice::ClearVoice()
{
    m_DigitalAudio.ClearVoice();
}

void Voice::ResetVoice()
{
    m_fInUse = FALSE;
    m_fNoteOn = FALSE;
    m_fSustainOn = FALSE;
}

// return the volume delta at time <stTime>.
// volume is sum of volume envelope, LFO, expression, optionally the
// channel volume if we're allowing it to change, and optionally the current
// pan if we're allowing that to change.
// This will be added to the base volume calculated in Voice::StartVoice().
void Voice::GetNewVolume(STIME stTime, VREL& vrVolume, VREL &vrVolumeR)
{
    STIME stMixTime;
    vrVolume = m_VolumeEG.GetVolume(stTime,&stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;

    // save pre-LFO volume for code that detects whether this note is off
    m_vrVolume = vrVolume;

    vrVolume += m_LFO.GetVolume(stTime,&stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;
    vrVolume += m_pExpressionIn->GetVolume(stTime);

    if (m_pControl->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += m_pVolumeIn->GetVolume(stTime);

    vrVolumeR = vrVolume;
    
    // handle pan here if allowing pan to vary after note starts
    if (m_pControl->m_dwStereo 
        && m_pControl->m_fAllowPanWhilePlayingNote)
    {
        // add current pan & instrument default pan
        LONG lPan = m_pPanIn->GetPan(stTime) + m_lDefaultPan;

        // don't go off either end....
        if (lPan < 0)
            lPan = 0;
        if (lPan > 127)
            lPan = 127;
        vrVolume += m_svrPanToVREL[127 - lPan];
        vrVolumeR += m_svrPanToVREL[lPan];
    }
}

// Returns the current pitch for time <stTime>.
// Pitch is the sum of the pitch LFO, the pitch envelope, and the current
// pitch bend.
PREL Voice::GetNewPitch(STIME stTime)
{
    STIME stMixTime;
    PREL prPitch = m_LFO.GetPitch(stTime,&stMixTime);
    if (m_stMixTime > stMixTime) 
        m_stMixTime = stMixTime;
    prPitch += m_PitchEG.GetPitch(stTime,&stMixTime);
    if (m_stMixTime > stMixTime)
        m_stMixTime = stMixTime;
    prPitch += m_pPitchBendIn->GetPitch(stTime); 

    return prPitch;
}


DWORD Voice::Mix(short *pBuffer,DWORD dwLength,
         STIME stStart,STIME stEnd)
{
    BOOL fInUse = TRUE;
    BOOL fFullMix = TRUE;
    STIME stEndMix = stStart;

    STIME stStartMix = m_stStartTime;
    if (stStartMix < stStart) 
    {
        stStartMix = stStart;
    }
    if (m_stLastMix >= stEnd)
    {
        return (0);
    }
    if (m_stLastMix >= stStartMix)
    {
        stStartMix = m_stLastMix;
    }

    while (stStartMix < stEnd && fInUse)
    {   
        stEndMix = stStartMix + m_stMixTime;
        
        if (stEndMix > stEnd)
        {
            stEndMix = stEnd;
        }
        m_stMixTime = m_pControl->m_stMaxSpan;
        
        PREL prPitch = GetNewPitch(stEndMix);

        VREL vrVolume, vrVolumeR;
        GetNewVolume(stEndMix, vrVolume, vrVolumeR);
        
        if (m_VolumeEG.InRelease(stEndMix)) 
        {
            if (m_vrVolume < PERCEIVED_MIN_VOLUME) // End of release slope
            {
                fInUse = FALSE;
            }
        }

        ASSERT(stStartMix <= stEndMix);
        
        fFullMix = 
            m_DigitalAudio.Mix( &pBuffer[DWORD(stStartMix - stStart) << m_pControl->m_dwStereo],
                                DWORD(stEndMix - stStartMix), 
                                vrVolume, 
                                vrVolumeR, 
                                prPitch, 
                                m_pControl->m_dwStereo);
        stStartMix = stEndMix;
    }
    m_fInUse = fInUse && fFullMix;
    if (!m_fInUse) 
    {
        ClearVoice();
        m_stStopTime = stEndMix;    // For measurement purposes.
    }
    m_stLastMix = stEndMix;
    return (dwLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\inc\midi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       midi.h
//
//--------------------------------------------------------------------------

/*
 *   MIDI definitions
 *
 *   midi.h
 *
 */

#define MIDI_CHANNELS           16
#define MIDI_NOTES              128
#define MIDI_NOTE_MAP_SIZE      (MIDI_CHANNELS * MIDI_NOTES)


#define MIDI_NOTE_OFF(note,channel) \
    (0x007F0080 | ((note) << 8) | (channel))

#define MIDI_SUSTAIN(value,channel) \
    (0x000040B0 | ((value) << 16) | (channel))

#define IS_SYSEX(b)                     (b == 0xF0)
#define IS_DATA_BYTE(b)                 ((b & 0x80) == 0)
#define IS_EOX(b)                       (b == 0xF7)

#define IS_REALTIME(b)                  (((b) & 0xF8) == 0xF8)
#define IS_SYSTEM(b)                    (((b) & 0xF0) == 0xF0)
#define IS_CHANNEL(b)                   ((b) & 0x80)
#define IS_STATUS(b)                    ((b) & 0x80)

#define MIDI_CHANNEL(b)                 ((b) & 0x0F)
#define MIDI_STATUS(b)                  ((b) & 0xF0)

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_TUNEREQ    0xF6
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define MIDI_SYSRESET   0xFF

 // controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_MONOMODE             0x7E
#define CC_POLYMODE             0x7F

// rpn controllers
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB             0x62
#define CC_NRPN_MSB             0x63
#define CC_RPN_LSB      0x64
#define CC_RPN_MSB      0x65

// registered parameter numbers
#define RPN_PITCHBEND           0x00
#define RPN_FINETUNE            0x01
#define RPN_COARSETUNE          0x02

/*XLATOFF */
#pragma warning (disable:4200)  // turn off 0 length array warning

typedef struct
{
    ULONG msDelta;
    ULONG cbSize;
    BYTE  abMidiEvents[0];
} MIDIFORMAT, *PMIDIFORMAT;

#pragma warning (default:4200)  // turn on 0 length array warning
/*XLATON*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\swmidi\topology.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   topology.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     D.J. Sisolak
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

#define TOTAL_NUM_CATEGORIES    2
#define TOTAL_NUM_NODES		    1
#define TOTAL_NUM_CONNECTIONS	(TOTAL_NUM_NODES+1)

static GUID CategoryGUIDs[TOTAL_NUM_CATEGORIES] = {
    {   STATICGUIDOF(KSCATEGORY_DATATRANSFORM)  },
    {   STATICGUIDOF(KSCATEGORY_AUDIO)          }
};

static GUID NodeGUIDs[TOTAL_NUM_NODES] = {
    {   STATICGUIDOF(KSNODETYPE_SYNTHESIZER)    }
};

static GUID NodeNameGUIDs[TOTAL_NUM_NODES] = {
    {   STATICGUIDOF(KSNODETYPE_SWMIDI)         }
};

static const KSTOPOLOGY_CONNECTION Connections[TOTAL_NUM_CONNECTIONS] = {
    { KSFILTER_NODE, 0, 0, 1 },
    { 0, 0, KSFILTER_NODE, 1}
};

static const KSTOPOLOGY SwMidiTopology = {
    TOTAL_NUM_CATEGORIES,
    CategoryGUIDs,
    TOTAL_NUM_NODES,
    NodeGUIDs,
    TOTAL_NUM_CONNECTIONS,
    Connections,
    NodeNameGUIDs,
    0
};

NTSTATUS
FilterTopologyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
)
{
    NTSTATUS Status;

    Status = KsTopologyPropertyHandler(pIrp, pProperty, pData, &SwMidiTopology);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\inc\wdmaud.h ===
/****************************************************************************
 *
 *   wdmaud.h
 *
 *   Common defines for wdmaud.drv and wdmaud.sys
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "ks.h"
#include "ksmedia.h"

#define ANSI_TAG                0x42
#define UNICODE_TAG             0x43

#define MUSICBUFFERSIZE         20
#define STREAM_BUFFERS          128

#define MAXCALLBACKS 4

#ifdef DEBUG
#define DEVICEINFO_SIGNATURE 'IDAW'        // WADI as seen in memory
#define DEVICESTATE_SIGNATURE 'SDAW'       // WADS as seen in memory
#define MIDIDATALISTENTRY_SIGNATURE 'ELDM' // MDLE as seen in memory
#endif

//****************************************************************************
//
// Device Types
//
//****************************************************************************

#define WaveInDevice            0
#define WaveOutDevice           1
#define MidiInDevice            2
#define MidiOutDevice           3
#define MixerDevice             4
#define AuxDevice               5
#define MAX_DEVICE_CLASS        6

#if IS_16
#define HANDLE32    DWORD
#define BOOL32      DWORD
#else
#define HANDLE32    HANDLE
#define BOOL32      BOOL
#endif

#define IS16( DevInfo )   ( DevInfo->dwFormat == ANSI_TAG )
#define ISANSI( DevInfo ) IS16( DevInfo )
#define ISWIDE( DevInfo ) ( DevInfo->dwFormat == UNICODE_TAG )

//
//  stores the state of the wdm-based legacy device
//
typedef struct _DEVICESTATE {
    DWORD                   cSampleBits;  // used for wave position : Count of Bits per sample
    HANDLE32                hThread;
    DWORD                   dwThreadId;
    union _QUEUE {
        LPMIDIHDR           lpMidiInQueue;// Used for MidiIn
        LPWAVEHDR           lpWaveQueue;  // Used for WaveIn/Out
                                          // This is only required so that
                                          // CLOSE knows when things have
                                          // really finished.
    };
    struct _MIDIDATALISTENTRY  *lpMidiDataQueue;
    ULONG                   LastTimeMs;
    LPVOID                  csQueue;      // protection for queue
    HANDLE32                hevtQueue;
    HANDLE32                hevtExitThread;
    volatile BOOL32         fExit;        //
    volatile BOOL32         fPaused;      //
    volatile BOOL32         fRunning;     //
    volatile BOOL32         fThreadRunning;//
    LPBYTE                  lpNoteOnMap;  // What notes are turned on for MidiOut
    BYTE                    bMidiStatus;  // Last running status byte for MIDI
#ifdef DEBUG
    DWORD                   dwSig;    // WADS as seen in memory.
#endif
} DEVICESTATE, FAR *LPDEVICESTATE;

//
//  specifies which device to effect in wdmaud.sys
//
typedef struct _DEVICEINFO {
    struct _DEVICEINFO FAR  *Next;      // Must be first member
    DWORD                   DeviceNumber;
    DWORD                   DeviceType;
    HANDLE32                DeviceHandle;
    DWORD_PTR               dwInstance;   // client's instance data
    DWORD_PTR               dwCallback;   // client's callback
    DWORD                   dwCallback16; // wdmaud's 16-bit callback
    DWORD                   dwFlags;      // Open flags
    LPVOID                  DataBuffer;
    DWORD                   DataBufferSize;
    volatile DWORD          OpenDone;     // for deferred open
    volatile DWORD          OpenStatus;   // for deferred open

    HANDLE                  HardwareCallbackEventHandle;
    DWORD                   dwCallbackType;
    DWORD                   dwID[MAXCALLBACKS];
    DWORD                   dwLineID;
    LONG                    ControlCallbackCount;
    DWORD                   dwFormat;     // ANSI_TAG or UNICODE_TAG
    MMRESULT                mmr;          // Result of MM operation

    LPDEVICESTATE           DeviceState;

    DWORD                   dwSig;  //WADI as seen in memory.

    WCHAR                   wstrDeviceInterface[1]; // Device interface name
} DEVICEINFO, FAR *LPDEVICEINFO;


typedef struct _DEVICEINFO32 {
    UINT32                  Next;      // Must be first member
    DWORD                   DeviceNumber;
    DWORD                   DeviceType;
    UINT32                  DeviceHandle;
    UINT32                  dwInstance;   // client's instance data
    UINT32                  dwCallback;   // client's callback
    DWORD                   dwCallback16; // wdmaud's 16-bit callback
    DWORD                   dwFlags;      // Open flags
    UINT32                  DataBuffer;
    DWORD                   DataBufferSize;
    volatile DWORD          OpenDone;     // for deferred open
    volatile DWORD          OpenStatus;   // for deferred open

    UINT32                  HardwareCallbackEventHandle;
    DWORD                   dwCallbackType;
    DWORD                   dwID[MAXCALLBACKS];
    DWORD                   dwLineID;
    LONG                    ControlCallbackCount;
    DWORD                   dwFormat;     // ANSI_TAG or UNICODE_TAG
    MMRESULT                mmr;          // Result of MM operation

    UINT32                  DeviceState;

    DWORD                   dwSig;  //WADI as seen in memory.

    WCHAR                   wstrDeviceInterface[1]; // Device interface name
} DEVICEINFO32, FAR *LPDEVICEINFO32;


#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above DEVICEINFO32 structure up with the DEVICEINFO structure.
// It doesn't compile because someone didn't update DEVINCEINFO32 when
// they changed DEVICEINFO.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the DEVICEINFO32 typedefs in the
// wdmaud.sys directory.

struct deviceinfo_structures_are_in_sync {
char x[(sizeof (DEVICEINFO32) == sizeof (DEVICEINFO)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif


#ifdef _WIN64

#pragma pack(push, 1)

#define MAXDEVINTERFACE 256

typedef struct {
    DEVICEINFO DeviceInfo;
    WCHAR Space[MAXDEVINTERFACE];
} LOCALDEVICEINFO;

#pragma pack(pop)

#endif


#define CDAUDIO_CHANNEL_BIAS    0x80

#ifdef UNDER_NT

typedef struct _MIDIDATA {
    KSSTREAM_HEADER              StreamHeader;
    KSMUSICFORMAT                MusicFormat;
    DWORD                        MusicData[3];
} MIDIDATA, FAR *LPMIDIDATA;

typedef struct _MIDIDATALISTENTRY {
    MIDIDATA                     MidiData;
    LPVOID                       pOverlapped;  // Overlapped structure
                                               // for completion
    LPDEVICEINFO                 MidiDataDeviceInfo;
    struct _MIDIDATALISTENTRY    *lpNext;
#ifdef DEBUG
    DWORD                        dwSig;  // MDLE as seen in memory
#endif
} MIDIDATALISTENTRY, FAR *LPMIDIDATALISTENTRY;

#endif


// IOCTL set for WDMAUD

#ifdef UNDER_NT

#include <devioctl.h>
#define WDMAUD_CTL_CODE CTL_CODE

#else

#define FILE_DEVICE_SOUND               0x0000001d

//
// Define the method codes for how buffers are passed for I/O and FS controls
//
#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#define WDMAUD_CTL_CODE( DeviceType, Function, Method, Access ) (ULONG)(   \
    ((ULONG)(DeviceType) << 16) | ((ULONG)(Access) << 14) | ((ULONG)(Function) << 2) | (ULONG)(Method) \
)

#endif

#define IOCTL_SOUND_BASE    FILE_DEVICE_SOUND
#define IOCTL_WDMAUD_BASE   0x0000
#define IOCTL_WAVE_BASE     0x0040
#define IOCTL_MIDI_BASE     0x0080
#define IOCTL_MIXER_BASE    0x00C0

#define IOCTL_WDMAUD_INIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_ADD_DEVNODE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_REMOVE_DEVNODE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_CAPABILITIES          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_NUM_DEVS              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_OPEN_PIN                  WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_CLOSE_PIN                 WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0008, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_EXIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_PREFERRED_DEVICE      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x000a, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_OUT_PAUSE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_PLAY             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_POS          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_GET_POS           WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0014, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIXER_OPEN                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_CLOSE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINEINFO         WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINECONTROLS     WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\auxd.c ===
/****************************************************************************
 *
 *   waveout.c
 *
 *   WDM Audio support for Wave Output devices
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
 *
 *   History
 *      3-17-98 - Mike McLaughlin (mikem)
 *
 ***************************************************************************/

#include "wdmdrv.h"

//--------------------------------------------------------------------------
//
//  DWORD auxMessage
//
//  Description:
//      This function conforms to the standard auxilary driver
//      message procedure.
//
//  Parameters:
//      UINT uDevId
//
//      WORD msg
//
//      DWORD dwUser
//
//      DWORD dwParam1
//
//      DWORD dwParam2
//
//  Return (DWORD):
//      Message specific
//
//@@BEGIN_MSINTERNAL
//  History:   Date       Author      Comment
//              5/20/93   BryanW      Added this comment block.
//@@END_MSINTERNAL
//
//--------------------------------------------------------------------------

DWORD FAR PASCAL _loadds auxMessage
(
    UINT            uDevId,
    WORD            msg,
    DWORD_PTR       dwUser,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2
)
{
    LPDEVICEINFO DeviceInfo;
    MMRESULT mmr;

    switch (msg) {
	case AUXM_INIT:
	    DPF(DL_TRACE|FA_AUX, ("AUXDM_INIT") ) ;
            return(wdmaudAddRemoveDevNode(AuxDevice, (LPCWSTR)(ULONG_PTR)dwParam2, TRUE));
	
	case DRVM_EXIT:
	    DPF(DL_TRACE|FA_AUX, ("AUXM_EXIT") ) ;
            return(wdmaudAddRemoveDevNode(AuxDevice, (LPCWSTR)(ULONG_PTR)dwParam2, FALSE));

	case AUXDM_GETNUMDEVS:
	    DPF(DL_TRACE|FA_AUX, ("AUXDM_GETNUMDEVS") ) ;
            return wdmaudGetNumDevs(AuxDevice, (LPWSTR)(ULONG_PTR)dwParam1);

	case AUXDM_GETDEVCAPS:
	    DPF(DL_TRACE|FA_AUX, ("AUXDM_GETDEVCAPS") ) ;
	    if (DeviceInfo = GlobalAllocDeviceInfo((LPWSTR)(ULONG_PTR)dwParam2)) {
		DeviceInfo->DeviceType = AuxDevice;
		DeviceInfo->DeviceNumber = uDevId;
		mmr = wdmaudGetDevCaps(DeviceInfo, (MDEVICECAPSEX FAR*)(ULONG_PTR)dwParam1);
		GlobalFreeDeviceInfo(DeviceInfo);
		return mmr;
	    } else {
		MMRRETURN( MMSYSERR_NOMEM );
	    }

	case AUXDM_GETVOLUME:
	    DPF(DL_TRACE|FA_AUX, ("AUXDM_GETVOLUME") ) ;
	    if (DeviceInfo = GlobalAllocDeviceInfo((LPWSTR)(ULONG_PTR)dwParam2)) {
		DeviceInfo->DeviceType = AuxDevice;
		DeviceInfo->DeviceNumber = uDevId;
        PRESETERROR(DeviceInfo);
		mmr = wdmaudIoControl(DeviceInfo,
				      sizeof(DWORD),
				      (LPBYTE)(ULONG_PTR)dwParam1,
				      IOCTL_WDMAUD_GET_VOLUME);
        POSTEXTRACTERROR(mmr,DeviceInfo);

		GlobalFreeDeviceInfo(DeviceInfo);
		MMRRETURN( mmr );
	    } else {
		MMRRETURN( MMSYSERR_NOMEM );
	    }
		
	case AUXDM_SETVOLUME:
	    DPF(DL_TRACE|FA_AUX, ("AUXDM_SETVOLUME") ) ;
	    if (DeviceInfo = GlobalAllocDeviceInfo((LPWSTR)(ULONG_PTR)dwParam2)) {
		DeviceInfo->DeviceType = AuxDevice;
		DeviceInfo->DeviceNumber = uDevId;
        PRESETERROR(DeviceInfo);
		mmr = wdmaudIoControl(DeviceInfo,
				      sizeof(DWORD),
				      (LPBYTE)&dwParam1,
				      IOCTL_WDMAUD_SET_VOLUME);
        POSTEXTRACTERROR(mmr,DeviceInfo);

		GlobalFreeDeviceInfo(DeviceInfo);
		MMRRETURN( mmr );
	    } else {
		MMRRETURN( MMSYSERR_NOMEM );
	    }
   }

   MMRRETURN( MMSYSERR_NOTSUPPORTED );

} // auxMessage()

//---------------------------------------------------------------------------
//  End of File: auxd.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\debug.c ===
/****************************************************************************
 *
 *   wdmaud.c
 *
 *   WDM Audio mapper
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include <stdarg.h>
#include "wdmdrv.h"
#include "mixer.h"


#ifdef DEBUG

typedef struct tag_MSGS {
    ULONG ulMsg;
    char * pString;
} ERROR_MSGS, *PERROR_MSGS;

#define MAPERR(_x_) { _x_, #_x_ }


ERROR_MSGS MsgTable[] = {

    //
    // Standard error messages
    //
    MAPERR(MMSYSERR_ERROR),
    MAPERR(MMSYSERR_BADDEVICEID),
    MAPERR(MMSYSERR_NOTENABLED),
    MAPERR(MMSYSERR_ALLOCATED),
    MAPERR(MMSYSERR_INVALHANDLE),
    MAPERR(MMSYSERR_NODRIVER),
    MAPERR(MMSYSERR_NOMEM),
    MAPERR(MMSYSERR_NOTSUPPORTED),
    MAPERR(MMSYSERR_BADERRNUM),
    MAPERR(MMSYSERR_INVALFLAG),
    MAPERR(MMSYSERR_INVALPARAM),
    MAPERR(MMSYSERR_HANDLEBUSY),

    MAPERR(MMSYSERR_INVALIDALIAS),
    MAPERR(MMSYSERR_BADDB),
    MAPERR(MMSYSERR_KEYNOTFOUND),
    MAPERR(MMSYSERR_READERROR),
    MAPERR(MMSYSERR_WRITEERROR),
    MAPERR(MMSYSERR_DELETEERROR),
    MAPERR(MMSYSERR_VALNOTFOUND),
    MAPERR(MMSYSERR_NODRIVERCB),
    MAPERR(MMSYSERR_MOREDATA),
    MAPERR(MMSYSERR_LASTERROR),

    //
    // Wave error messages
    //
    MAPERR(WAVERR_BADFORMAT),
    MAPERR(WAVERR_STILLPLAYING),
    MAPERR(WAVERR_UNPREPARED),
    MAPERR(WAVERR_SYNC),
    MAPERR(WAVERR_LASTERROR),

    //
    // Midi Error messages
    //
    MAPERR(MIDIERR_UNPREPARED),
    MAPERR(MIDIERR_STILLPLAYING),
    MAPERR(MIDIERR_NOMAP),
    MAPERR(MIDIERR_NOTREADY),
    MAPERR(MIDIERR_NODEVICE),
    MAPERR(MIDIERR_INVALIDSETUP),
    MAPERR(MIDIERR_BADOPENMODE),
    MAPERR(MIDIERR_DONT_CONTINUE),
    MAPERR(MIDIERR_LASTERROR),

    //
    // Timer errors
    //
    MAPERR(TIMERR_NOCANDO),
    MAPERR(TIMERR_STRUCT),

    //
    // Joystick error return values
    //
    MAPERR(JOYERR_PARMS),
    MAPERR(JOYERR_NOCANDO),
    MAPERR(JOYERR_UNPLUGGED),

    //
    // MCI Error return codes.
    //
    MAPERR(MCIERR_INVALID_DEVICE_ID),
    MAPERR(MCIERR_UNRECOGNIZED_KEYWORD),
    MAPERR(MCIERR_UNRECOGNIZED_COMMAND),
    MAPERR(MCIERR_HARDWARE),
    MAPERR(MCIERR_INVALID_DEVICE_NAME),
    MAPERR(MCIERR_OUT_OF_MEMORY),
    MAPERR(MCIERR_DEVICE_OPEN),
    MAPERR(MCIERR_CANNOT_LOAD_DRIVER),
    MAPERR(MCIERR_MISSING_COMMAND_STRING),
    MAPERR(MCIERR_BAD_INTEGER),
    MAPERR(MCIERR_PARSER_INTERNAL),
    MAPERR(MCIERR_DRIVER_INTERNAL),
    MAPERR(MCIERR_MISSING_PARAMETER),
    MAPERR(MCIERR_UNSUPPORTED_FUNCTION),
    MAPERR(MCIERR_FILE_NOT_FOUND),
    MAPERR(MCIERR_DEVICE_NOT_READY),
    MAPERR(MCIERR_INTERNAL),
    MAPERR(MCIERR_DRIVER),
    MAPERR(MCIERR_CANNOT_USE_ALL),
    MAPERR(MCIERR_MULTIPLE),
    MAPERR(MCIERR_EXTENSION_NOT_FOUND),
    MAPERR(MCIERR_OUTOFRANGE),
    MAPERR(MCIERR_FLAGS_NOT_COMPATIBLE),  //sphelling?
    MAPERR(MCIERR_FILE_NOT_SAVED),
    MAPERR(MCIERR_DEVICE_TYPE_REQUIRED),
    MAPERR(MCIERR_DEVICE_LOCKED),
    MAPERR(MCIERR_DUPLICATE_ALIAS),
    MAPERR(MCIERR_BAD_CONSTANT),
    MAPERR(MCIERR_MUST_USE_SHAREABLE),
    MAPERR(MCIERR_MISSING_DEVICE_NAME),
    MAPERR(MCIERR_BAD_TIME_FORMAT),
    MAPERR(MCIERR_NO_CLOSING_QUOTE),
    MAPERR(MCIERR_DUPLICATE_FLAGS),
    MAPERR(MCIERR_INVALID_FILE),
    MAPERR(MCIERR_NULL_PARAMETER_BLOCK),
    MAPERR(MCIERR_UNNAMED_RESOURCE),
    MAPERR(MCIERR_NEW_REQUIRES_ALIAS),
    MAPERR(MCIERR_NOTIFY_ON_AUTO_OPEN),
    MAPERR(MCIERR_NO_ELEMENT_ALLOWED),
    MAPERR(MCIERR_NONAPPLICABLE_FUNCTION),
    MAPERR(MCIERR_ILLEGAL_FOR_AUTO_OPEN),
    MAPERR(MCIERR_FILENAME_REQUIRED),
    MAPERR(MCIERR_EXTRA_CHARACTERS),
    MAPERR(MCIERR_DEVICE_NOT_INSTALLED),
    MAPERR(MCIERR_GET_CD),
    MAPERR(MCIERR_SET_CD),
    MAPERR(MCIERR_SET_DRIVE),
    MAPERR(MCIERR_DEVICE_LENGTH),
    MAPERR(MCIERR_DEVICE_ORD_LENGTH),
    MAPERR(MCIERR_NO_INTEGER),

    MAPERR(MCIERR_WAVE_OUTPUTSINUSE),
    MAPERR(MCIERR_WAVE_SETOUTPUTINUSE),
    MAPERR(MCIERR_WAVE_INPUTSINUSE),
    MAPERR(MCIERR_WAVE_SETINPUTINUSE),
    MAPERR(MCIERR_WAVE_OUTPUTUNSPECIFIED),
    MAPERR(MCIERR_WAVE_INPUTUNSPECIFIED),
    MAPERR(MCIERR_WAVE_OUTPUTSUNSUITABLE),
    MAPERR(MCIERR_WAVE_SETOUTPUTUNSUITABLE),
    MAPERR(MCIERR_WAVE_INPUTSUNSUITABLE),
    MAPERR(MCIERR_WAVE_SETINPUTUNSUITABLE),

    MAPERR(MCIERR_SEQ_DIV_INCOMPATIBLE),
    MAPERR(MCIERR_SEQ_PORT_INUSE),
    MAPERR(MCIERR_SEQ_PORT_NONEXISTENT),
    MAPERR(MCIERR_SEQ_PORT_MAPNODEVICE),
    MAPERR(MCIERR_SEQ_PORT_MISCERROR),
    MAPERR(MCIERR_SEQ_TIMER),
    MAPERR(MCIERR_SEQ_PORTUNSPECIFIED),
    MAPERR(MCIERR_SEQ_NOMIDIPRESENT),

    MAPERR(MCIERR_NO_WINDOW),
    MAPERR(MCIERR_CREATEWINDOW),
    MAPERR(MCIERR_FILE_READ),
    MAPERR(MCIERR_FILE_WRITE),
    MAPERR(MCIERR_NO_IDENTITY),
    
    //
    // Mixer return values
    //
    MAPERR(MIXERR_INVALLINE),
    MAPERR(MIXERR_INVALCONTROL),
    MAPERR(MIXERR_INVALVALUE),
    MAPERR(MIXERR_LASTERROR),

    {0xDEADBEEF,"DEADBEEF"},
    //
    // Don't walk off the end of the list
    //

	{0,NULL},
    {0,"Unknown"}
};


//-----------------------------------------------------------------------------
// Globals that affect debug output:
//-----------------------------------------------------------------------------

//
// The documentation relies on these two variables being next to each other
// with uiDebugLevel first.  Do not separate them.
//
// Default to displaying all "Warning" messages
UINT uiDebugLevel = DL_WARNING ;

// Default to breaking on all "Error" messages
UINT uiDebugBreakLevel = DL_ERROR ;
  

char szReturningErrorStr[]="Ret Err %X:%s";
  
// for storing the deviceinfo's in debug.
//PDINODE gpdiActive=NULL;
//PDINODE gpdiFreeHead=NULL;
//PDINODE gpdiFreeTail=NULL;
//INT     giFree=0;
//INT     giAlloc=0;
//INT     giFreed=0;





//
// Make header for these functions....
//
char *MsgToAscii(ULONG ulMsg)
{
  PERROR_MSGS pTable=MsgTable;

  while(pTable->pString != NULL)
    {
     if (pTable->ulMsg==ulMsg) return pTable->pString;
     pTable++;
    }
  pTable++;
  //
  // If we get to the end of the list advance the pointer and return
  // "Unknown"
  //
  return pTable->pString;
}


VOID wdmaudDbgBreakPoint()
{
    DbgBreak();
}

//
// This routine will format the start of the string.  But, before it does that
// it will check to see if the user should even be seeing this message.
//
// uiMsgLevel is the flags in the code that classify the message.  This value
// is used if and only if the user is filtering on that class of messages.
//
// If the message is to be displayed, the return value will be non-zero so that
// the message in the code will be displayed.  See the macro DPF.
//
UINT wdmaudDbgPreCheckLevel(UINT uiMsgLevel,char *pFunction,int iLine)
{
    char szBuf[24];
    UINT uiRet=0;

    //
    // Read this like:  if there is a bit set in the upper 3 bytes of the uiDebugLevel
    // variable, then the user is viewing messages of a specific type.  We only 
    // want to show those messages.
    //
    if( (uiDebugLevel&FA_MASK) )
    {
        //
        // Yes, the user filtering on a particular class of messages.  Did
        // we find one to display?  We look at the message flags to determine this.
        //
        if( (uiMsgLevel&FA_MASK) & (uiDebugLevel&FA_MASK) )
        {
            //
            // Yes, we found a message of the right class.  Is it at the right
            // level for the user to see?
            // 
            if( (uiMsgLevel&DL_MASK) <= (uiDebugLevel&DL_MASK) ) {
                // Yes.
                uiRet=1;
            }
        }
    } else {

        // The user is not viewing a specific type of message "class".  Do we have
        // a message level worth displaying?
        if( (uiMsgLevel&DL_MASK) <= (uiDebugLevel&DL_MASK) )
        {
                // Yes.
                uiRet=1;
        }
    } 
    

    // Now just check to see if we need to display on this call.
    if( uiRet )
    {
        // Yes.  Every message needs to start where it's from!
        OutputDebugStringA("WDMAUD.DRV ");
        OutputDebugStringA(pFunction);
        wsprintfA(szBuf,"(%d)",iLine);
        OutputDebugStringA(szBuf);

        // Now lable it's type.
        switch(uiMsgLevel&DL_MASK)
        {
            case DL_ERROR:
                OutputDebugStringA(" Error ");
                break;
            case DL_WARNING:
                OutputDebugStringA(" Warning ");
                break;
            case DL_TRACE:
                OutputDebugStringA(" Trace ");
                break;
            case DL_MAX:
                OutputDebugStringA(" Max ");
                break;
            default:
                break;
        }
        // when uiRet is positive, we've displayed the header info.  Tell the 
        // macro that we're in display mode.        
    }

    return uiRet;
}


UINT wdmaudDbgPostCheckLevel(UINT uiMsgLevel)
{
    UINT uiRet=0;
//    char szBuf[32];

    // Always finish the line.    
//    wsprintfA(szBuf," &DL=%08X",&uiDebugLevel);
//    OutputDebugStringA(szBuf);

#ifdef HTTP
    OutputDebugStringA(", see \\\\debugtips\\msgs\\wdmauds.htm\n");
#else
    OutputDebugStringA("\n");
#endif

    //
    // Ok, here is the scoop.  uiDebugBreakLevel is set to DL_ERROR (0) by default
    // thus, any time we get an error message of DL_ERROR level we will break.
    //
    // Also, uiDebugBreakLevel can be set by the user to DL_WARNING or DL_TRACE
    // or DL_MAX.  If so, any time we encounter a message with this debug level
    // we will break in the debugger.
    // 
    //
    if( (uiMsgLevel&DL_MASK) <= uiDebugBreakLevel )
    {
        // The user wants to break on these messages.
        DbgBreak();
        uiRet = 1;
    }

    return uiRet;
}

VOID FAR __cdecl wdmaudDbgOut
(
    LPSTR lpszFormat,
    ...
)
{
    char buf[256];
    va_list va;

    va_start(va, lpszFormat);
    wvsprintfA(buf, lpszFormat, va);
    va_end(va);
    
    OutputDebugStringA(buf);
}

#endif // DEBUG


MMRESULT
IsValidMidiDataListEntry(
    LPMIDIDATALISTENTRY pMidiDataListEntry
    )
{
    MMRESULT mmr;

    if ( IsBadWritePtr( (LPVOID)(pMidiDataListEntry),sizeof(MIDIDATALISTENTRY) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Corrupted MidiDataListEntry %X",pMidiDataListEntry) );
        return MMSYSERR_INVALPARAM;
    }
#ifdef DEBUG
    if( pMidiDataListEntry->dwSig != MIDIDATALISTENTRY_SIGNATURE )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid MidiDataListEntry Signature %X",pMidiDataListEntry) );
        return MMSYSERR_INVALPARAM;
    }
#endif


    if( (mmr=IsValidOverLapped(pMidiDataListEntry->pOverlapped)) != MMSYSERR_NOERROR )
    {
        return mmr;
    }
    return MMSYSERR_NOERROR;
}


////////////////////////////////////////////////////////////////////////////////
//
// IsValidPrepareWaveHeader
//
// This routine is available in debug or retail to validate that we've got a valid
// structure.  In retail, we ask the OS if we've got a valid memory pointer.  In
// debug we also check other fields
//
// See WAVEPREPAREDATA structure
//
// returns MMSYSERR_NOERROR on success, error code otherwise.
//
MMRESULT
IsValidPrepareWaveHeader(
    PWAVEPREPAREDATA pPrepare
    )
{
    MMRESULT mmr;

    if ( IsBadWritePtr( (LPVOID)(pPrepare),sizeof(PWAVEPREPAREDATA) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Corrupted PrepareData %X",pPrepare) );
        return MMSYSERR_INVALPARAM;
    }
#ifdef DEBUG
    if ( pPrepare->dwSig != WAVEPREPAREDATA_SIGNATURE )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid PrepareData signature!") );
        return MMSYSERR_INVALPARAM;
    }
#endif

    if( (mmr=IsValidOverLapped(pPrepare->pOverlapped)) != MMSYSERR_NOERROR )
    {
        return mmr;
    }
    return MMSYSERR_NOERROR;
}

////////////////////////////////////////////////////////////////////////////////
//
// IsValidOverlapped
//
// Validates the overlapped structure.
//
// returns MMSYSERR_NOERROR on success, error code on failure.
//
MMRESULT
IsValidOverLapped(
    LPOVERLAPPED lpol
    )
{
    if ( IsBadWritePtr( (LPVOID)(lpol),sizeof(OVERLAPPED) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid Overlapped structure %X",lpol) );
        return MMSYSERR_INVALPARAM;
    }
    if( lpol->hEvent == NULL )
    {
        DPF(DL_ERROR|FA_ASSERT,("Invalid hEvent Overlapped=%08X",lpol) );
        return MMSYSERR_INVALPARAM;
    }

    return MMSYSERR_NOERROR;
}

////////////////////////////////////////////////////////////////////////////////
//
// IsValidDeviceState
//
// This routine is used in both debug and retail.  In retail it validates that
// the pointer that is passed in is the correct size and type.  Under debug
// it checks other fields.
//
// See DEVICESTATE structure
//
// returns MMSYSERR_NOERROR on success, error code otherwise.
//
MMRESULT 
IsValidDeviceState(
    LPDEVICESTATE lpDeviceState,
    BOOL bFullyConfigured
    )
{
    if ( IsBadWritePtr( (LPVOID)(lpDeviceState),sizeof(DEVICESTATE) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid DeviceState %X",lpDeviceState) );
        return MMSYSERR_INVALPARAM;
    }
    if( lpDeviceState->csQueue == NULL )
    {
        DPF(DL_ERROR|FA_ASSERT,("Invalid csQueue in DeviceState %08X",lpDeviceState) );
        return MMSYSERR_INVALPARAM;
    }

#ifdef DEBUG
    if( lpDeviceState->dwSig != DEVICESTATE_SIGNATURE )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid DeviceState dwSig %08X",lpDeviceState) );
        return MMSYSERR_INVALPARAM;
    }

    if( bFullyConfigured )
    {
        //
        // Now, check to see that the items in the structure looks good.
        //
        if( ( lpDeviceState->hevtExitThread == NULL ) || 
            ( lpDeviceState->hevtExitThread == (HANDLE)FOURTYEIGHT ) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid hevtExitThread in DeviceState %08X",lpDeviceState) );
            return MMSYSERR_INVALPARAM;
        }
        if( (lpDeviceState->hevtQueue == NULL) || 
            (lpDeviceState->hevtQueue == (HANDLE)FOURTYTWO) || 
            (lpDeviceState->hevtQueue == (HANDLE)FOURTYTHREE) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid hevtQueue in DeviceState %08X",lpDeviceState) );
            return MMSYSERR_INVALPARAM;
        }
    }
#endif
    return MMSYSERR_NOERROR;
}

////////////////////////////////////////////////////////////////////////////////
//
// IsValidDeviceInfo
//
// In retail, we validate that we have a pointer of the correct size and type.
// In debug we walk our active deviceinfo list and see if we can find it.  If 
// we can't, we'll look in our freed list to see if it's there.  Basically, when
// someone frees a deviceinfo structure, we add it to the freed list.  After the
// freed list grows to 100 in length, we start rolling them off the list and freeing
// them.  On shutdown, we clean them all up.
//
// See DEVICEINFO Structure
//
// returns MMSYSERR_NOERROR on success, error code otherwise.
//
MMRESULT 
IsValidDeviceInfo(
    LPDEVICEINFO lpDeviceInfo
    )
{
    LPDEVICEINFO lpdi;
    if ( IsBadWritePtr( (LPVOID)(lpDeviceInfo),sizeof(DEVICEINFO) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid DeviceInfo %X",lpDeviceInfo) );
        return MMSYSERR_INVALPARAM;
    }
#ifdef DEBUG
    if( lpDeviceInfo->dwSig != DEVICEINFO_SIGNATURE )
    {
        DPF(DL_ERROR|FA_ALL,("Invalid DeviceInfo %08x Signature!",lpDeviceInfo) );
        return MMSYSERR_INVALPARAM;
    }
#endif    
    return MMSYSERR_NOERROR;
}

////////////////////////////////////////////////////////////////////////////////
//
// IsValidWaveHeader
//
// In retail we validate that this pointer is of the correct size and type.  In
// debug we validate some flags and look for signatures.
//
// See WAVEHDR structure
//
// returns MMRERR_NOERROR on success, Error code otherwise.
//
// Note:
//
// To do this, the LPWAVEHDR structure is defined in mmsystem.h, thus we can not
// add a signiture to that structure.  But, we do add info to the reserved field
// that is a WAVEPREPAREDATA structure.  That structure has a signiture.  Thus,
// we'll add that check to this routine.
//
// To pass, the wave header must be a write pointer of the correct size.  The dwFLags
// field must not have any extra flags in it and the reserved field must be a 
// WAVEPREPAREDATA pointer.
//
MMRESULT
IsValidWaveHeader(
    LPWAVEHDR pWaveHdr
    )
{
    PWAVEPREPAREDATA pwavePrepareData;

    if ( IsBadWritePtr( (LPVOID)(pWaveHdr),sizeof(WAVEHDR) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid pWaveHdr pointer %X",pWaveHdr) );
        return MMSYSERR_INVALPARAM;
    }
#ifdef DEBUG
    if( pWaveHdr->dwFlags & ~(WHDR_DONE|WHDR_PREPARED|WHDR_BEGINLOOP|WHDR_ENDLOOP|WHDR_INQUEUE) )
    {
        DPF(DL_ERROR|FA_ALL,("Ivalid dwFlags %08x in pWaveHdr %08X",
                             pWaveHdr->dwFlags,pWaveHdr) );
        return MMSYSERR_INVALPARAM;
    }
#endif
/*
    if (!(pWaveHdr->dwFlags & WHDR_PREPARED))
    {
        DPF(DL_ERROR|FA_ASSERT,("Unprepared header %08X",pWaveHdr) );
        return( WAVERR_UNPREPARED );
    }
*/
    if ((DWORD_PTR)pWaveHdr->reserved == (DWORD_PTR)NULL)
    {
        return( WAVERR_UNPREPARED );
    } else {
        if ( IsBadWritePtr( (LPVOID)(pWaveHdr->reserved),sizeof(WAVEPREPAREDATA) ) )
        {
            DPF(DL_ERROR|FA_ALL, ("Invalid pWaveHdr->reserved %X",pWaveHdr->reserved) );
            return MMSYSERR_INVALPARAM;
        }
    }
#ifdef DEBUG
    pwavePrepareData = (PWAVEPREPAREDATA)pWaveHdr->reserved;
    if( pwavePrepareData->dwSig != WAVEPREPAREDATA_SIGNATURE )
    {
        DPF(DL_ERROR|FA_ALL,("Invalid Signature in WAVEPREPAREDATA structure!") );
        return MMSYSERR_INVALPARAM;
    }
#endif
    return MMSYSERR_NOERROR;
}

MMRESULT
IsValidMidiHeader(
    LPMIDIHDR     pMidiHdr
    )
{
    if ( IsBadWritePtr( (LPVOID)(pMidiHdr),sizeof(MIDIHDR) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid pMidiHdr %X",pMidiHdr) );
        return MMSYSERR_INVALPARAM;
    }
    return MMSYSERR_NOERROR;
}

MMRESULT
IsValidWaveOpenDesc(
    LPWAVEOPENDESC pwod
    )
{
    if ( IsBadWritePtr( (LPVOID)(pwod),sizeof(WAVEOPENDESC) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid pwod %X",pwod) );
        return MMSYSERR_INVALPARAM;
    }
    return MMSYSERR_NOERROR;
}

////////////////////////////////////////////////////////////////////////////////
//
// IsValidMixerInstance
//
// Validates that the pointer is the correct type and size.  Debug checks for
// the correct signature.
//
// returns TRUE on success FALSE otherwise.
//
MMRESULT 
IsValidMixerInstance(
    LPMIXERINSTANCE lpmi
    )
{
    LPMIXERINSTANCE currentinstance;

    if ( IsBadWritePtr( (LPVOID)(lpmi),sizeof(MIXERINSTANCE) ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid MixerInstance structure %X",lpmi) );
        return MMSYSERR_INVALPARAM;
    }
#ifdef DEBUG
    if( lpmi->dwSig != MIXERINSTANCE_SIGNATURE )
    {
        DPF(DL_ERROR|FA_ALL,("Invalid Signature in MixerInstance %08X",lpmi) );
        return MMSYSERR_INVALPARAM;
    }
#endif

    for (currentinstance=pMixerDeviceList;currentinstance!=NULL;currentinstance=currentinstance->Next)
        if (currentinstance==lpmi)
            return MMSYSERR_NOERROR;

    DPF(DL_ERROR|FA_ALL, ("Invalid Instance passed to mxdMessage in dwUser!") );

// Since tracking down the WINMM bug that causes this assert to fire is
// proving very difficult and fwong (current winmm owner) is blowing it off
// and I (joeball) have more important things to do, I am turning off this assert.
// We still spew, but simply fail the api calls that don't have what we think
// is valid instance data.

// I currently think it is one of 2 things:  either the winmm usage count is wrapping -
// higher than 255 - a possibility because of the PNP recursive calls
// in winmm, OR, the CleanUpDesertedHandles in the UpdateClientPnpInfo is
// getting stuff closed just before it is used.  Either is a very likely
// possibility.

//DPFASSERT( 0 );

    return MMSYSERR_INVALPARAM;
}

////////////////////////////////////////////////////////////////////////////////
//
// IsValidDeviceInterface
//
// This routine simply validates that we have a pointer to at least 1 byte that
// is readable.  In debug we check to make sure that the string is not absurd.
//
// returns TRUE on success FALSE otherwise.
//
BOOL 
IsValidDeviceInterface(
    LPCWSTR DeviceInterface
    )
{
    if ( IsBadReadPtr( (LPVOID)(DeviceInterface),1 ) )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid DeviceInterface string %08X",DeviceInterface) );
        return FALSE;
    }
#ifdef DEBUG
    if( (sizeof(WCHAR)*lstrlenW(DeviceInterface)) > 4096 )
    {
        DPF(DL_ERROR|FA_ALL, ("Invalid DeviceInterface string %08X",DeviceInterface) );
        return FALSE;
    }
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\mixer.h ===
//---------------------------------------------------------------------------
//
//  Module:   mixer.h
//
//  Description:
//    Contains user mode mixer driver declarations.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//           9/16/97      v-danba     File created.
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//---------------------------------------------------------------------------

#ifndef _MIXER_H_INCLUDED_
#define _MIXER_H_INCLUDED_

typedef struct _MIXERINSTANCE {
    struct _MIXERINSTANCE FAR* Next;            // Must be first member
    HDRVR       OpenDesc_hmx;
    DWORD_PTR   OpenDesc_dwCallback;
    DWORD_PTR   OpenDesc_dwInstance;
    DWORD       OpenFlags;
    DWORD_PTR   dwKernelInstance;
    ULONG   firstcallbackindex;
#ifdef UNDER_NT
	LONG        referencecount;
#endif
#ifdef DEBUG
    DWORD       dwSig;   // WAMI as seen in memory.
#endif
    WCHAR       wstrDeviceInterface[1];
} MIXERINSTANCE, FAR *LPMIXERINSTANCE;

extern LPMIXERINSTANCE pMixerDeviceList;

VOID
mxdRemoveClient(
    LPMIXERINSTANCE lpInstance
);


MMRESULT 
IsValidMixerInstance(
    LPMIXERINSTANCE lpmi
    );

#ifdef DEBUG
#define ISVALIDMIXERINSTANCE(x) IsValidMixerInstance(x)
#else
#define ISVALIDMIXERINSTANCE(x)
#endif

#endif // _MIXER_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\midiout.c ===
/****************************************************************************
 *
 *   midiout.c
 *
 *   WDM Audio support for Midi Output devices
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmdrv.h"

#ifndef UNDER_NT
#pragma alloc_text(FIXCODE, modMessage)
#pragma alloc_text(FIXCODE, midiOutWrite)
#endif

/****************************************************************************

    This function conforms to the standard Midi output driver message proc
    (modMessage), which is documented in mmddk.h

****************************************************************************/

DWORD FAR PASCAL _loadds modMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    LPDEVICEINFO pOutClient;
    LPDWORD      pVolume;
    LPDEVICEINFO DeviceInfo;
    MMRESULT     mmr;

    switch (msg)
    {
        case MODM_INIT:
            DPF(DL_TRACE|FA_MIDI, ("MODM_INIT") );
            return wdmaudAddRemoveDevNode(MidiOutDevice, (LPCWSTR)dwParam2, TRUE);

        case DRVM_EXIT:
            DPF(DL_TRACE|FA_MIDI, ("DRVM_EXIT: MidiOut") );
            return wdmaudAddRemoveDevNode(MidiOutDevice, (LPCWSTR)dwParam2, FALSE);

        case MODM_GETNUMDEVS:
            DPF(DL_TRACE|FA_MIDI, ("MODM_GETNUMDEVS") );
            return wdmaudGetNumDevs(MidiOutDevice, (LPCWSTR)dwParam1);

        case MODM_GETDEVCAPS:
            DPF(DL_TRACE|FA_MIDI, ("MODM_GETDEVCAPS") );
            if (DeviceInfo = GlobalAllocDeviceInfo((LPWSTR)dwParam2))
            {
                DeviceInfo->DeviceType = MidiOutDevice;
                DeviceInfo->DeviceNumber = id;
                mmr = wdmaudGetDevCaps(DeviceInfo, (MDEVICECAPSEX FAR*)dwParam1);
                GlobalFreeDeviceInfo(DeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM ); 
            }

	case MODM_PREFERRED:
            DPF(DL_TRACE|FA_MIDI, ("MODM_PREFERRED") );
	    return wdmaudSetPreferredDevice(
	      MidiOutDevice,
	      id,
	      dwParam1,
	      dwParam2);

        case MODM_OPEN:
        {
            LPMIDIOPENDESC pmod = (LPMIDIOPENDESC)dwParam1;

            DPF(DL_TRACE|FA_MIDI, ("MODM_OPEN") );
            if (DeviceInfo = GlobalAllocDeviceInfo((LPWSTR)pmod->dnDevNode))
            {
                DeviceInfo->DeviceType = MidiOutDevice;
                DeviceInfo->DeviceNumber = id;
#ifdef UNDER_NT
                DeviceInfo->DeviceHandle = (HANDLE32)pmod->hMidi;
#else
                DeviceInfo->DeviceHandle = (HANDLE32)MAKELONG(pmod->hMidi,0);
#endif
                mmr = midiOpen(DeviceInfo, dwUser, pmod, (DWORD)dwParam2);
                GlobalFreeDeviceInfo(DeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM );
            }
        }

        case MODM_CLOSE:
            DPF(DL_TRACE|FA_MIDI, ("MODM_CLOSE") );
            pOutClient = (LPDEVICEINFO)dwUser;

            if( ( (mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR) ||
                ( (mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) )
            {
                MMRRETURN( mmr );
            }

            midiOutAllNotesOff( pOutClient );
            mmr = wdmaudCloseDev( pOutClient );

            if (MMSYSERR_NOERROR == mmr)
            {
                //
                // Tell the caller we're done
                //
                midiCallback(pOutClient, MOM_CLOSE, 0L, 0L);

                ISVALIDDEVICEINFO(pOutClient);
                ISVALIDDEVICESTATE(pOutClient->DeviceState,FALSE);

                midiCleanUp(pOutClient);
            }

            return mmr;

        case MODM_DATA:
            DPF(DL_TRACE|FA_MIDI, ("MODM_DATA") );

            if( ( (mmr=IsValidDeviceInfo((LPDEVICEINFO)dwUser)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidDeviceState(((LPDEVICEINFO)dwUser)->DeviceState,FALSE)) != MMSYSERR_NOERROR ) )
            {
                MMRRETURN( mmr );
            }
            //
            // dwParam1 = MIDI event dword (1, 2 or 3 bytes)
            //
            return midiOutWrite((LPDEVICEINFO)dwUser, (DWORD)dwParam1);

        case MODM_LONGDATA:
            DPF(DL_TRACE|FA_MIDI, ("MODM_LONGDATA") );

            pOutClient = (LPDEVICEINFO)dwUser;
            {
                LPMIDIHDR lpHdr;

                if( ( (mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR ) ||
                    ( (mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) ||
                    ( (mmr=IsValidMidiHeader((LPMIDIHDR)dwParam1)) != MMSYSERR_NOERROR) )
                {
                    MMRRETURN( mmr );
                }

                //
                // check if it's been prepared
                //
                lpHdr = (LPMIDIHDR)dwParam1;
                if (!(lpHdr->dwFlags & MHDR_PREPARED))
                {
                    MMRRETURN( MIDIERR_UNPREPARED );
                }

                // Send the data long....

                mmr = wdmaudSubmitMidiOutHeader(pOutClient, lpHdr);
                //
                // The docs say that this call can return an error.  Why we didn't
                // I don't know.  Thus, these lines are getting commented out.
                //
//                DPFASSERT( mmr == MMSYSERR_NOERROR );
//                mmr = MMSYSERR_NOERROR;

                // note that clearing the done bit or setting the inqueue bit
                // isn't necessary here since this function is synchronous -
                // the client will not get control back until it's done.

                lpHdr->dwFlags |= MHDR_DONE;

                // notify client

                //BUGBUG: this is a no-op from the set above?

                if (mmr == MMSYSERR_NOERROR)
                {
                    midiCallback(pOutClient, MOM_DONE, (DWORD_PTR)lpHdr, 0L);
                }

                return mmr;
            }


        case MODM_RESET:
            DPF(DL_TRACE|FA_MIDI, ("MODM_RESET") );

            pOutClient = (LPDEVICEINFO)dwUser;

            if( ( (mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) )
            {
                MMRRETURN( mmr );
            }

            midiOutAllNotesOff(pOutClient);

            return MMSYSERR_NOERROR;

        case MODM_SETVOLUME:
            DPF(DL_TRACE|FA_MIDI, ("MODM_SETVOLUME") );

            pOutClient = GlobalAllocDeviceInfo((LPWSTR)dwParam2);
            if (NULL == pOutClient)
            {
                MMRRETURN( MMSYSERR_NOMEM );
            }

            pOutClient->DeviceType = MidiOutDevice;
            pOutClient->DeviceNumber = id;
            pOutClient->OpenDone = 0;
            PRESETERROR(pOutClient);

            mmr = wdmaudIoControl(pOutClient,
                                  sizeof(DWORD),
                                  (LPBYTE)&dwParam1,
                                  IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME);
            POSTEXTRACTERROR(mmr,pOutClient);

            GlobalFreeDeviceInfo(pOutClient);
            return mmr;

        case MODM_GETVOLUME:
            DPF(DL_TRACE|FA_MIDI, ("MODM_GETVOLUME") );

            pOutClient = GlobalAllocDeviceInfo((LPWSTR)dwParam2);
            if (pOutClient)
            {
                pVolume = (LPDWORD) GlobalAllocPtr( GPTR, sizeof(DWORD));
                if (pVolume)
                {
                    pOutClient->DeviceType = MidiOutDevice;
                    pOutClient->DeviceNumber = id;
                    pOutClient->OpenDone = 0;
                    PRESETERROR(pOutClient);

                    mmr = wdmaudIoControl(pOutClient,
                                          sizeof(DWORD),
                                          (LPBYTE)pVolume,
                                          IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME);
                    POSTEXTRACTERROR(mmr,pOutClient);

                    //
                    // Only copy back info on success.
                    //
                    if( MMSYSERR_NOERROR == mmr )
                        *((DWORD FAR *) dwParam1) = *pVolume;

                    GlobalFreePtr(pVolume);
                } else {
                    mmr = MMSYSERR_NOMEM;
                }

                GlobalFreeDeviceInfo(pOutClient);
            } else {
                mmr = MMSYSERR_NOMEM;
            }

            return mmr;

#ifdef MIDI_STREAM
        // TODO: Are we going to support the Midi Streaming
        // messages in this rev?
        case MODM_PROPERTIES:
           return modProperty (&gMidiOutClient, (LPBYTE)dwParam1, dwParam2);

        case MODM_STRMDATA:
           return modStreamData (&gMidiOutClient, (LPMIDIHDR)dwParam1, (UINT)dwParam2);

        case MODM_GETPOS:
           return modGetStreamPosition (&gMidiOutClient, (LPMMTIME)dwParam1);

        case MODM_STOP:
           return modStreamReset (&gMidiOutClient);

        case MODM_RESTART:
           return modStreamRestart (&gMidiOutClient, dwParam1, dwParam2);

        case MODM_PAUSE:
           return modStreamPause (&gMidiOutClient);

#endif // MIDI_STREAM support

#ifdef MIDI_THRU
        case DRVM_ADD_THRU:
        case DRVM_REMOVE_THRU:
            // TODO: How do a support thruing in the kernel if I
            // only get a device handle from this message.
#endif // MIDI_THRU support

        default:
            MMRRETURN( MMSYSERR_NOTSUPPORTED );
    }

    //
    // Should not get here
    //

    DPFASSERT(0);
    MMRRETURN( MMSYSERR_NOTSUPPORTED );
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiOutWrite | Synchronously process a midi output
 *       buffer.
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
MMRESULT FAR midiOutWrite
(
    LPDEVICEINFO pClient,
    DWORD        ulEvent
)
{
    MMRESULT    mmr = MMSYSERR_ERROR;
    BYTE        bStatus;
    BYTE        bNote;
    BYTE        bVelocity;
    UINT        uChannel;
    DWORD       idx;
    LPBYTE      lpEntry;

    bStatus = (BYTE)(ulEvent & 0xFF);

    if (!IS_STATUS( bStatus ))
    {
        bNote = bStatus;
        bVelocity = (BYTE)(( ulEvent >> 8 ) & 0x0FF );

        bStatus = pClient->DeviceState->bMidiStatus;
    }
    else
    {
        bNote = (BYTE)(( ulEvent >> 8 ) & 0xFF );
        bVelocity = (BYTE)(( ulEvent >> 16 ) & 0xFF );

        pClient->DeviceState->bMidiStatus = bStatus;
    }

    uChannel = MIDI_CHANNEL( bStatus );
    bStatus = MIDI_STATUS( bStatus );

    if (MIDI_NOTEON == bStatus ||
        MIDI_NOTEOFF == bStatus)
    {
        idx = ( uChannel << 7 ) | bNote;
        lpEntry = &pClient->DeviceState->lpNoteOnMap[idx];

        if (( 0 == bVelocity ) ||
            ( MIDI_NOTEOFF == bStatus ))
        {
            if (*lpEntry)
            {
                --*lpEntry;
            }
        }
        else
        {
            if (*lpEntry < 255)
            {
                ++*lpEntry;
            }
        }
    }
    //
    //  Send the MIDI short message
    //
    mmr = wdmaudIoControl(pClient,
                          0, // DataBuffer contains a value and not a pointer
                             // so we don't need a size.
#ifdef UNDER_NT
                          UlongToPtr(ulEvent),
#else
                          &ulEvent,
#endif
                          IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA);
    return mmr;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | midiOutAllNotesOff | Turn off all the notes on this client,
 *  using the note on map that has been built from outgoing short messages.
 *
 ***************************************************************************/
VOID FAR midiOutAllNotesOff
(
    LPDEVICEINFO pClient
)
{
    UINT        uNote;
    UINT        uChannel;
    LPBYTE      lpNoteOnMap;
    LPBYTE      lpNoteOnMapEnd;
    DWORD       dwMessage;
    UINT        uNoteOffs = 0;

    // First turn off the sustain controller on all channels to terminate
    // post-note off sound
    //
    for (uChannel = 0;
         uChannel < MIDI_CHANNELS;
         uChannel++)
    {
        dwMessage = MIDI_SUSTAIN( 0, uChannel );

// WorkItem: shouldn't we check the return value here?

        wdmaudIoControl(pClient,
                        0, // DataBuffer contains a value and not a pointer
                           // so we don't need a size.
#ifdef UNDER_NT
                        UlongToPtr(dwMessage),
#else
                        &dwMessage,
#endif
                        IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA);
    }

    // Iterate through the map and track what note and channel each entry corresponds
    // to
    //
    lpNoteOnMap = pClient->DeviceState->lpNoteOnMap;
    lpNoteOnMapEnd = lpNoteOnMap + MIDI_NOTE_MAP_SIZE;
    uNote = 0;
    uChannel = 0;

    for ( ;
         lpNoteOnMap < lpNoteOnMapEnd;
         lpNoteOnMap++ )
    {
        BYTE bCount = *lpNoteOnMap;

        if (bCount)
        {

            // This note on this channel has some instances playing. Build a note off
            // and shut them down
            //
            *lpNoteOnMap = 0;
            dwMessage = MIDI_NOTE_OFF( uNote, uChannel );

            while (bCount--)
            {
                wdmaudIoControl(pClient,
                                0, // DataBuffer contains a value and not a pointer
                                   // so we don't need a size.
#ifdef UNDER_NT
                                UlongToPtr(dwMessage),
#else
                                &dwMessage,
#endif
                                IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA);

                uNoteOffs++;
            }
        }

        if (++uNote >= MIDI_NOTES)
        {
            uNote = 0;
            ++uChannel;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\midiin.c ===
/****************************************************************************
 *
 *   midiin.c
 *
 *   WDM Audio support for Midi Input devices
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmdrv.h"
#include <stdarg.h>

#ifndef UNDER_NT
#pragma alloc_text(FIXCODE, midiCallback)
#pragma alloc_text(FIXCODE, midiInCompleteHeader)
#endif

/****************************************************************************

    This function conforms to the standard Midi input driver message proc
    (midMessage), which is documented in mmddk.h

****************************************************************************/
DWORD FAR PASCAL _loadds midMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    LPDEVICEINFO  DeviceInfo;
    LPDEVICEINFO  pInClient;
    MMRESULT      mmr;

    switch (msg)
    {
        case MIDM_INIT:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_INIT") );
            return wdmaudAddRemoveDevNode(MidiInDevice, (LPCWSTR)dwParam2, TRUE);

        case DRVM_EXIT:
            DPF(DL_TRACE|FA_MIDI, ("DRVM_EXIT: MidiIn") );
            return wdmaudAddRemoveDevNode(MidiInDevice, (LPCWSTR)dwParam2, FALSE);

        case MIDM_GETNUMDEVS:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_GETNUMDEVS") );
            return wdmaudGetNumDevs(MidiInDevice, (LPCWSTR)dwParam1);

        case MIDM_GETDEVCAPS:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_GETDEVCAPS") );
            if (DeviceInfo = GlobalAllocDeviceInfo((LPWSTR)dwParam2))
            {
                DeviceInfo->DeviceType = MidiInDevice;
                DeviceInfo->DeviceNumber = id;
                mmr = wdmaudGetDevCaps(DeviceInfo, (MDEVICECAPSEX FAR*)dwParam1);
                GlobalFreeDeviceInfo(DeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM );
            }

        case MIDM_OPEN:
        {
            LPMIDIOPENDESC pmod = (LPMIDIOPENDESC)dwParam1;

            DPF(DL_TRACE|FA_MIDI, ("MIDM_OPEN") );
            if (DeviceInfo = GlobalAllocDeviceInfo((LPWSTR)pmod->dnDevNode))
            {
                DeviceInfo->DeviceType = MidiInDevice;
                DeviceInfo->DeviceNumber = id;
                mmr = midiOpen(DeviceInfo, dwUser, pmod, (DWORD)dwParam2);
                DPF(DL_TRACE|FA_MIDI,("dwUser(DI)=%08X",dwUser) );
                GlobalFreeDeviceInfo(DeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM );
            }
        }

        case MIDM_CLOSE:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_CLOSE dwUser(DI)=%08X",dwUser) );
            pInClient = (LPDEVICEINFO)dwUser;

            if( (mmr=IsValidDeviceInfo(pInClient)) != MMSYSERR_NOERROR )
            {
                MMRRETURN( mmr );
            }

            mmr = wdmaudCloseDev( pInClient );

            if (MMSYSERR_NOERROR == mmr)
            {
#ifdef UNDER_NT
                //
                //  Wait for all of the queued up I/O to come back from
                //  wdmaud.sys.
                //
                wdmaudDestroyCompletionThread ( pInClient );
#endif

                //
                // Tell the caller we're done
                //
                midiCallback( pInClient, MIM_CLOSE, 0L, 0L);

                ISVALIDDEVICEINFO(pInClient);
                ISVALIDDEVICESTATE(pInClient->DeviceState,FALSE);

                midiCleanUp( pInClient );
            }

            return mmr;

        case MIDM_ADDBUFFER:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_ADDBUFFER") );

            //
            // Don't touch bad pointers!
            //
            pInClient = (LPDEVICEINFO)dwUser;

            if( ( (mmr=IsValidDeviceInfo(pInClient)) != MMSYSERR_NOERROR) ||
                ( (mmr=IsValidDeviceState(pInClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidMidiHeader((LPMIDIHDR)dwParam1)) != MMSYSERR_NOERROR)
                )
            {
                MMRRETURN( mmr );
            }

            // check if it's been prepared
            if (!(((LPMIDIHDR)dwParam1)->dwFlags & MHDR_PREPARED))
                MMRRETURN( MIDIERR_UNPREPARED );

            DPFASSERT(!(((LPMIDIHDR)dwParam1)->dwFlags & MHDR_INQUEUE));

            // if it is already in our Q, then we cannot do this
            if ( ((LPMIDIHDR)dwParam1)->dwFlags & MHDR_INQUEUE )
                MMRRETURN( MIDIERR_STILLPLAYING );

            DPF(DL_TRACE|FA_MIDI,("dwUser(DI)=%08X,dwParam1(HDR)=%08X",pInClient,dwParam1) );
            return midiInRead( pInClient, (LPMIDIHDR)dwParam1);

        case MIDM_STOP:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_STOP dwUser(DI)=%08X",dwUser) );

            pInClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pInClient,
                                        IOCTL_WDMAUD_MIDI_IN_STOP);

        case MIDM_START:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_START dwUser(DI)=%08X",dwUser) );

            pInClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pInClient,
                                        IOCTL_WDMAUD_MIDI_IN_RECORD);

        case MIDM_RESET:
            DPF(DL_TRACE|FA_MIDI, ("MIDM_RESET dwUser(DI)=%08X",dwUser) );

            pInClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pInClient,
                                        IOCTL_WDMAUD_MIDI_IN_RESET);
#ifdef MIDI_THRU
        case DRVM_ADD_THRU:
        case DRVM_REMOVE_THRU:
#endif

        default:
            MMRRETURN( MMSYSERR_NOTSUPPORTED );
    }

    //
    // Should not get here
    //

    DPFASSERT(0);
    MMRRETURN( MMSYSERR_NOTSUPPORTED );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiCallback | This calls DriverCallback for a MIDIHDR.
 *
 * @parm LPDEVICEINFO | pMidiDevice | pointer to midi device.
 *
 * @parm UINT | msg | The message.
 *
 * @parm DWORD | dw1 | message DWORD (dw2 is always set to 0).
 *
 * @rdesc There is no return value.
 ***************************************************************************/
VOID FAR midiCallback
(
    LPDEVICEINFO pMidiDevice,
    UINT         msg,
    DWORD_PTR    dw1,
    DWORD_PTR    dw2
)
{

    // invoke the callback function, if it exists.  dwFlags contains
    // midi driver specific flags in the LOWORD and generic driver
    // flags in the HIWORD

    if (pMidiDevice->dwCallback)
        DriverCallback(pMidiDevice->dwCallback,                       // user's callback DWORD
                       HIWORD(pMidiDevice->dwFlags),                  // callback flags
                       (HDRVR)pMidiDevice->DeviceHandle,              // handle to the midi device
                       msg,                                           // the message
                       pMidiDevice->dwInstance,                       // user's instance data
                       dw1,                                           // first DWORD
                       dw2);                                          // second DWORD
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiOpen | Open midi device and set up logical device data
 *
 * @parm LPDEVICEINFO | DeviceInfo | Specifies if it's a midi input or output
 *                                   device
 *
 * @parm DWORD | dwUser | Input parameter to modMessage - pointer to
 *   application's handle (generated by this routine)
 *
 * @parm DWORD | pmod | pointer to MIDIOPENDESC, was dwParam1 parameter
 *                      to modMessage
 *
 * @parm DWORD | dwParam2 | Input parameter to modMessage
 *
 * @rdesc modMessage return code.
 ***************************************************************************/
MMRESULT FAR midiOpen
(
    LPDEVICEINFO   DeviceInfo,
    DWORD_PTR      dwUser,
    LPMIDIOPENDESC pmod,
    DWORD          dwParam2
)
{
    LPDEVICEINFO  pClient;  // pointer to client information structure
    MMRESULT      mmr;
#ifndef UNDER_NT
    DWORD        dwCallback16;
#else
    ULONG        BufferCount;
#endif


    // pmod contains a pointer to a MIDIOPENDESC
    // dwParam2 contains midi driver specific flags in the LOWORD
    // and generic driver flags in the HIWORD

    //
    // allocate my per-client structure
    //
    pClient = GlobalAllocDeviceInfo(DeviceInfo->wstrDeviceInterface);
    if (NULL == pClient)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    pClient->DeviceState = (LPVOID) GlobalAllocPtr( GPTR, sizeof( DEVICESTATE ) );
    if (NULL == pClient->DeviceState)
    {
        GlobalFreeDeviceInfo( pClient );
        MMRRETURN( MMSYSERR_NOMEM );
    }

#ifdef UNDER_NT
    //
    // Allocate memory for our critical section
    //
    pClient->DeviceState->csQueue = (LPVOID) GlobalAllocPtr( GPTR, sizeof( CRITICAL_SECTION ) );
    if (NULL == pClient->DeviceState->csQueue)
    {
        GlobalFreePtr( pClient->DeviceState );
        GlobalFreeDeviceInfo( pClient );
        MMRRETURN( MMSYSERR_NOMEM );
    }

    try
    {
        InitializeCriticalSection( (LPCRITICAL_SECTION)pClient->DeviceState->csQueue );
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        GlobalFreePtr( pClient->DeviceState->csQueue );
        GlobalFreePtr( pClient->DeviceState );
        GlobalFreeDeviceInfo( pClient );
        MMRRETURN( MMSYSERR_NOMEM );
    }
#endif

    //
    //  fill out context data
    //
    pClient->DeviceNumber= DeviceInfo->DeviceNumber;
    pClient->DeviceType  = DeviceInfo->DeviceType;
    pClient->dwInstance  = pmod->dwInstance;
    pClient->dwCallback  = pmod->dwCallback;
#ifdef UNDER_NT
    pClient->DeviceHandle= (HANDLE32)pmod->hMidi;
#else
    pClient->DeviceHandle= (HANDLE32)MAKELONG(pmod->hMidi,0);
    _asm
    {
        mov ax, offset MidiEventDeviceCallback
        mov word ptr [dwCallback16], ax
        mov ax, seg MidiEventDeviceCallback
        mov word ptr [dwCallback16+2], ax
    }
    pClient->dwCallback16= dwCallback16;
#endif
    pClient->dwFlags     = dwParam2;

    //
    //  initialize the device state
    //
    DPF(DL_TRACE|FA_SYNC,("DI=%08X New DeviceState",pClient) );
    pClient->DeviceState->lpMidiInQueue= NULL;
    pClient->DeviceState->fPaused     = FALSE;
    pClient->DeviceState->fRunning    = FALSE;
    pClient->DeviceState->fExit       = FALSE;

    pClient->DeviceState->bMidiStatus = 0;
    pClient->DeviceState->lpNoteOnMap = NULL;
#ifdef DEBUG
    pClient->DeviceState->dwSig = DEVICESTATE_SIGNATURE;
#endif
    if (pClient->DeviceType == MidiOutDevice)
    {
        //
        // For MIDI out, allocate one byte per note per channel to track
        // what's been played. This is used to avoid doing a brute-force
        // all notes off on MODM_RESET.
        //
        pClient->DeviceState->lpNoteOnMap = GlobalAllocPtr( GPTR, MIDI_NOTE_MAP_SIZE );
        if (NULL == pClient->DeviceState->lpNoteOnMap)
        {
#ifdef UNDER_NT
            GlobalFreePtr( pClient->DeviceState->csQueue );
#endif
            GlobalFreePtr( pClient->DeviceState );
            GlobalFreeDeviceInfo( pClient );
            MMRRETURN( MMSYSERR_NOMEM );
        }
    }

    //
    // See if we can open our device
    //
    mmr = wdmaudOpenDev( pClient, NULL );

    if (mmr != MMSYSERR_NOERROR)
    {
        if ( pClient->DeviceState->lpNoteOnMap )
        {
            GlobalFreePtr( pClient->DeviceState->lpNoteOnMap );
        }
#ifdef UNDER_NT
        DeleteCriticalSection( (LPCRITICAL_SECTION)pClient->DeviceState->csQueue );
        GlobalFreePtr( pClient->DeviceState->csQueue );
#endif
        GlobalFreePtr( pClient->DeviceState );
        GlobalFreeDeviceInfo( pClient ) ;
        return mmr;
    }

    //
    // Add instance to chain of devices
    //
    EnterCriticalSection(&wdmaudCritSec);
    pClient->Next = pMidiDeviceList;
    pMidiDeviceList = pClient;
    LeaveCriticalSection(&wdmaudCritSec);

    //
    // give the client my driver dw
    //
    {
        LPDEVICEINFO FAR *pUserHandle;

        pUserHandle = (LPDEVICEINFO FAR *)dwUser;
        *pUserHandle = pClient;
    }

#ifndef UNDER_NT
    // If this is a MIDI output device, page lock the memory because it can
    // be accessed at interrupt time.
    //
    GlobalSmartPageLock( (HGLOBAL)HIWORD( pClient ));
    GlobalSmartPageLock( (HGLOBAL)HIWORD( pClient->DeviceState ));
    GlobalSmartPageLock( (HGLOBAL)HIWORD( pClient->DeviceState->lpNoteOnMap ));
#endif

#ifdef UNDER_NT
    //
    //  If this is a MIDI input device on NT, send some buffers
    //  down to the device in order so that once recording starts
    //  we can get some data back.  The pin is paused after
    //  the call to wdmaudOpenDev.
    //
    if ( MidiInDevice == pClient->DeviceType )
    {
        for (BufferCount = 0; BufferCount < STREAM_BUFFERS; BufferCount++)
        {
            mmr = wdmaudGetMidiData( pClient, NULL );
            if ( MMSYSERR_NOERROR != mmr )
            {
                //
                //  We hope that this doesn't happen, but if it does
                //  we need to try to close down the device.
                //
                if ( MMSYSERR_NOERROR == wdmaudCloseDev( pClient ) )
                {
                    wdmaudDestroyCompletionThread ( pClient );
                    midiCleanUp( pClient );
                }
                DPF( 2, ("midiInOpen failed: returning mmr = %d", mmr ) );
                return mmr;
            }
        }
    }
#endif

    //
    // sent client his OPEN callback message
    //
    midiCallback(pClient, DeviceInfo->DeviceType == MidiOutDevice ? MOM_OPEN : MIM_OPEN,
                 0L, 0L);

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiCleanUp | Free resources for a midi device
 *
 * @parm LPDEVICEINFO | pClient | Pointer to a DEVICEINFO structure describing
 *      resources to be freed.
 *
 * @rdesc There is no return value.
 *
 * @comm If the pointer to the resource is NULL then the resource has not
 *     been allocated.
 ***************************************************************************/
VOID FAR midiCleanUp
(
    LPDEVICEINFO pClient
)
{
    LPDEVICEINFO FAR *ppCur ;

    //
    //  remove from device chain
    //
    EnterCriticalSection(&wdmaudCritSec);
    for (ppCur = &pMidiDeviceList;
         *ppCur != NULL;
         ppCur = &(*ppCur)->Next)
    {
       if (*ppCur == pClient)
       {
          *ppCur = (*ppCur)->Next;
          break;
       }
    }
    LeaveCriticalSection(&wdmaudCritSec);

    DPF(DL_TRACE|FA_SYNC,("DI=%08X Freed DeviceState",pClient) );

#ifdef UNDER_NT
    DeleteCriticalSection( (LPCRITICAL_SECTION)pClient->DeviceState->csQueue );
    GlobalFreePtr( pClient->DeviceState->csQueue );
#endif

    if (pClient->DeviceState->lpNoteOnMap)
    {
#ifndef UNDER_NT
        GlobalSmartPageUnlock( (HGLOBAL)HIWORD( pClient->DeviceState->lpNoteOnMap ));
#endif
        GlobalFreePtr( pClient->DeviceState->lpNoteOnMap );
    }

#ifndef UNDER_NT
    GlobalSmartPageUnlock( (HGLOBAL)HIWORD( pClient->DeviceState ));
    GlobalSmartPageUnlock( (HGLOBAL)HIWORD( pClient ));
#endif
#ifdef DEBUG
    //
    // In debug, let's set all the values in the DEVICESTATE structure to bad
    // values.
    //
    pClient->DeviceState->cSampleBits=0xDEADBEEF;
    pClient->DeviceState->hThread=NULL;
    pClient->DeviceState->dwThreadId=0xDEADBEEF;
    pClient->DeviceState->lpWaveQueue=NULL;
    pClient->DeviceState->csQueue=NULL;
    pClient->DeviceState->hevtQueue=NULL;
    pClient->DeviceState->hevtExitThread=NULL;

#endif                       
    GlobalFreePtr( pClient->DeviceState );
    pClient->DeviceState=NULL;
#ifdef DEBUG
    //
    // Now set all the values in the DEVICEINFO structure to bad values.
    //
//    pClient->Next=(LPDEVICEINFO)0xDEADBEEF;
    pClient->DeviceNumber=-1;
    pClient->DeviceType=0xDEADBEEF;
    pClient->DeviceHandle=NULL;
    pClient->dwInstance=(DWORD_PTR)NULL;
    pClient->dwCallback=(DWORD_PTR)NULL;
    pClient->dwCallback16=0xDEADBEEF;
    pClient->dwFlags=0xDEADBEEF;
    pClient->DataBuffer=NULL;
    pClient->HardwareCallbackEventHandle=NULL;
    pClient->dwCallbackType=0xDEADBEEF;
    pClient->dwLineID=0xDEADBEEF;
    pClient->dwFormat=0xDEADBEEF;
//    pClient->DeviceState=(LPDEVICESTATE)0xDEADBEEF;

#endif
    GlobalFreeDeviceInfo( pClient ) ;
    pClient=NULL;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiInRead | Pass a new buffer to the Auxiliary thread for
 *       a midi device.
 *
 * @parm LPDEVICEINFO | pClient | The data associated with the logical midi
 *     device.
 *
 * @parm LPMIDIHDR | pHdr | Pointer to a midi buffer
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
MMRESULT midiInRead
(
    LPDEVICEINFO  DeviceInfo,
    LPMIDIHDR     pHdr
)
{
    MMRESULT     mmr = MMSYSERR_NOERROR;
    LPMIDIHDR    pTemp;
    DWORD        dwCallback16;

    //
    // Put the request at the end of our queue.
    //
    pHdr->dwFlags |= MHDR_INQUEUE;
    pHdr->dwFlags &= ~MHDR_DONE;
    pHdr->dwBytesRecorded = 0;
    pHdr->lpNext = NULL;

    //
    // Store the context for this write in the header so that
    // we know which client to send this back to on completion.
    //
    pHdr->reserved = (DWORD_PTR)DeviceInfo;

#ifndef UNDER_NT
    //
    //  Put the long message callback handler into the
    //  DeviceInfo structure.
    //
    _asm
    {
        mov ax, offset MidiInDeviceCallback
        mov word ptr [dwCallback16], ax
        mov ax, seg MidiInDeviceCallback
        mov word ptr [dwCallback16+2], ax
    }
    DeviceInfo->dwCallback16 = dwCallback16;
#endif

    //
    //  Add the MIDI header to the queue
    //
    CRITENTER ;

    if (!DeviceInfo->DeviceState->lpMidiInQueue)
    {
        DeviceInfo->DeviceState->lpMidiInQueue = pHdr;
        pTemp = NULL;
#ifdef UNDER_NT
        if( (DeviceInfo->DeviceState->hevtQueue) &&
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTHREE) &&
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTWO) )
        {
            DPF(DL_TRACE|FA_SYNC,("REMOVED: SetEvent on hevtQueue") );
//            SetEvent( DeviceInfo->DeviceState->hevtQueue );
        }
#endif
    }
    else
    {
        for (pTemp = DeviceInfo->DeviceState->lpMidiInQueue;
             pTemp->lpNext != NULL;
             pTemp = pTemp->lpNext);

        pTemp->lpNext = pHdr;
    }

    CRITLEAVE ;

#ifndef UNDER_NT
    //
    //  Call the 16 routine to send the buffer down
    //  to the kernel.  On NT, do all the processing
    //  of the MIDI data in User mode.
    //
    mmr = wdmaudSubmitMidiInHeader(DeviceInfo, pHdr);
    if (mmr != MMSYSERR_NOERROR)
    {
        // Unlink...
        GlobalFreePtr( pHdr );

        if (pTemp)
        {
            pTemp->lpNext = NULL;
        }
        else
            DeviceInfo->DeviceState->lpMidiInQueue = NULL;
        pHdr->dwFlags &= ~WHDR_INQUEUE;

        DbgBreak();
        MMRRETURN( mmr );  // used to return MMSYSERR_INVALPARAM for all errors!
    }
#endif

    return mmr;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | midiInCompleteHeader |
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical midi
 *     device.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ****************************************************************************/
VOID midiInCompleteHeader
(
    LPDEVICEINFO  DeviceInfo,
    DWORD         dwTimeStamp,
    WORD          wDataType
)
{
    LPMIDIHDR   pHdr;

    DPFASSERT(DeviceInfo);

    //
    //  Only remove headers from the front of the queue
    //  so that order is maintained.
    //
    if (pHdr = DeviceInfo->DeviceState->lpMidiInQueue)
    {
        DeviceInfo->DeviceState->lpMidiInQueue = DeviceInfo->DeviceState->lpMidiInQueue->lpNext;

        DPF(DL_TRACE|FA_MIDI, ("Pulling header out of queue") );
        pHdr->dwFlags &= ~MHDR_INQUEUE;
        pHdr->dwFlags |= MHDR_DONE;
        pHdr->lpNext = NULL;

        midiCallback((LPDEVICEINFO)pHdr->reserved,
                     wDataType,  // MIM_LONGDATA or MIM_LONGERROR
                     (DWORD_PTR)pHdr,
                     dwTimeStamp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\wavein.c ===
/****************************************************************************
 *
 *   wavein.c
 *
 *   WDM Audio support for Wave Input devices
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmdrv.h"

#ifndef UNDER_NT
#pragma alloc_text(FIXCODE, waveCallback)
#endif

/****************************************************************************

    This function conforms to the standard Wave input driver message proc
    (widMessage), which is documented in mmddk.d.

****************************************************************************/
DWORD FAR PASCAL _loadds widMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    LPDEVICEINFO pInClient;
    LPDEVICEINFO pDeviceInfo;
    LPWAVEHDR    lpWaveHdr;
    MMRESULT     mmr;

    switch (msg)
    {
        case WIDM_INIT:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_INIT") );
            return(wdmaudAddRemoveDevNode(WaveInDevice, (LPCWSTR)dwParam2, TRUE));

        case DRVM_EXIT:
            DPF(DL_TRACE|FA_WAVE, ("DRVM_EXIT WaveIn") );
            return(wdmaudAddRemoveDevNode(WaveInDevice, (LPCWSTR)dwParam2, FALSE));

        case WIDM_GETNUMDEVS:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_GETNUMDEVS") );
            return wdmaudGetNumDevs(WaveInDevice, (LPCWSTR)dwParam1);

        case WIDM_GETDEVCAPS:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_GETDEVCAPS") );
            if (pDeviceInfo = GlobalAllocDeviceInfo((LPCWSTR)dwParam2))
            {
                pDeviceInfo->DeviceType = WaveInDevice;
                pDeviceInfo->DeviceNumber = id;
                mmr = wdmaudGetDevCaps(pDeviceInfo, (MDEVICECAPSEX FAR*)dwParam1);
                GlobalFreeDeviceInfo(pDeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM );
            }

        case WIDM_PREFERRED:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_PREFERRED") );
            return wdmaudSetPreferredDevice(
              WaveInDevice,
              id,
              dwParam1,
              dwParam2);

        case WIDM_OPEN:
        {
            LPWAVEOPENDESC pwod = (LPWAVEOPENDESC)dwParam1;

            if( (mmr=IsValidWaveOpenDesc(pwod)) != MMSYSERR_NOERROR )
            {
                MMRRETURN( mmr );
            }

            DPF(DL_TRACE|FA_WAVE, ("WIDM_OPEN") );
            if (pDeviceInfo = GlobalAllocDeviceInfo((LPCWSTR)pwod->dnDevNode))
            {
                pDeviceInfo->DeviceType = WaveInDevice;
                pDeviceInfo->DeviceNumber = id;
                mmr = waveOpen(pDeviceInfo, dwUser, pwod, (DWORD)dwParam2);
                GlobalFreeDeviceInfo(pDeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM );
            }
        }

        case WIDM_CLOSE:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_CLOSE") );
            pInClient = (LPDEVICEINFO)dwUser;

            //
            // At this point, we've committed to closing down this DeviceInfo.
            // We mark the DeviceState as closing and hope for the best!  If
            // someone calls WIDM_ADDBUFFER while we're in this state, we've got
            // problems!
            //
            if( ( (mmr=IsValidDeviceInfo(pInClient)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidDeviceState(pInClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) )
            {
                MMRRETURN( mmr );
            }

            mmr = wdmaudCloseDev(pInClient);
            if (MMSYSERR_NOERROR == mmr)
            {
                waveCallback(pInClient, WIM_CLOSE, 0L);

                ISVALIDDEVICEINFO(pInClient);
                ISVALIDDEVICESTATE(pInClient->DeviceState,FALSE);

                waveCleanUp(pInClient);
            }
            return mmr;

        case WIDM_ADDBUFFER:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_ADDBUFFER") );
            lpWaveHdr = (LPWAVEHDR)dwParam1;
            pInClient = (LPDEVICEINFO)dwUser;

            //
            // Perform our asserts 
            //
            if( ( (mmr=IsValidDeviceInfo(pInClient)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidDeviceState(pInClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidWaveHeader(lpWaveHdr)) != MMSYSERR_NOERROR ) )
            {
                MMRRETURN( mmr );
            }

            // sanity check on the wavehdr
            DPFASSERT(lpWaveHdr != NULL);
            if (lpWaveHdr == NULL)
                MMRRETURN( MMSYSERR_INVALPARAM );

            // check if it's been prepared
            DPFASSERT(lpWaveHdr->dwFlags & WHDR_PREPARED);
            if (!(lpWaveHdr->dwFlags & WHDR_PREPARED))
                MMRRETURN( WAVERR_UNPREPARED );

            // if it is already in our Q, then we cannot do this
            DPFASSERT(!(lpWaveHdr->dwFlags & WHDR_INQUEUE));
            if ( lpWaveHdr->dwFlags & WHDR_INQUEUE )
                MMRRETURN( WAVERR_STILLPLAYING );
            //
            // Put the request at the end of our queue.
            //
            return waveWrite(pInClient, lpWaveHdr);

        case WIDM_STOP:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_STOP") );
            pInClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pInClient,
                                        IOCTL_WDMAUD_WAVE_IN_STOP);

        case WIDM_START:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_START") );
            pInClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pInClient,
                                        IOCTL_WDMAUD_WAVE_IN_RECORD);

        case WIDM_RESET:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_RESET") );
            pInClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pInClient,
                                        IOCTL_WDMAUD_WAVE_IN_RESET);

        case WIDM_GETPOS:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_GETPOS") );
            pInClient = (LPDEVICEINFO)dwUser;

            if( ( (mmr=IsValidDeviceInfo(pInClient)) != MMSYSERR_NOERROR) ||
                ( (mmr=IsValidDeviceState(pInClient->DeviceState,FALSE)) != MMSYSERR_NOERROR) )
            {
                MMRRETURN( mmr );
            }

            return wdmaudGetPos(pInClient,
                                (LPMMTIME)dwParam1,
                                (DWORD)dwParam2,
                                WaveInDevice);

#ifdef UNDER_NT
        case WIDM_PREPARE:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_PREPARE") );
            pInClient = (LPDEVICEINFO)dwUser;

            if( ( (mmr=IsValidDeviceInfo(pInClient)) != MMSYSERR_NOERROR) ||
                ( (mmr=IsValidDeviceState(pInClient->DeviceState,FALSE)) != MMSYSERR_NOERROR) )
            {
                MMRRETURN( mmr );
            }

            return wdmaudPrepareWaveHeader(pInClient, (LPWAVEHDR)dwParam1);

        case WIDM_UNPREPARE:
            DPF(DL_TRACE|FA_WAVE, ("WIDM_UNPREPARE") );
            pInClient = (LPDEVICEINFO)dwUser;

            if( ( (mmr=IsValidDeviceInfo(pInClient)) != MMSYSERR_NOERROR) ||
                ( (mmr=IsValidDeviceState(pInClient->DeviceState,FALSE)) != MMSYSERR_NOERROR) )
            {
                MMRRETURN( mmr );
            }

            return wdmaudUnprepareWaveHeader(pInClient, (LPWAVEHDR)dwParam1);
#endif

        default:
            MMRRETURN( MMSYSERR_NOTSUPPORTED );
    }

    //
    // Should not get here
    //

    DPFASSERT(0);
    MMRRETURN( MMSYSERR_NOTSUPPORTED );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCallback | This calls DriverCallback for a WAVEHDR.
 *
 * @parm LPDEVICEINFO | pWave | Pointer to wave device.
 *
 * @parm DWORD | msg | The message.
 *
 * @parm DWORD | dw1 | message DWORD (dw2 is always set to 0).
 *
 * @rdesc There is no return value.
 ***************************************************************************/
VOID FAR waveCallback
(
    LPDEVICEINFO pWave,
    UINT         msg,
    DWORD_PTR    dw1
)
{

    // invoke the callback function, if it exists.  dwFlags contains
    // wave driver specific flags in the LOWORD and generic driver
    // flags in the HIWORD

    if (pWave->dwCallback)
        DriverCallback(pWave->dwCallback,                     // user's callback DWORD
                       HIWORD(pWave->dwFlags),                // callback flags
                       (HDRVR)pWave->DeviceHandle,            // handle to the wave device
                       msg,                                   // the message
                       pWave->dwInstance,                     // user's instance data
                       dw1,                                   // first DWORD
                       0L);                                   // second DWORD
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveOpen | Open wave device and set up logical device data
 *
 * @parm LPDEVICEINFO | DeviceInfo | Specifies if it's a wave input or output
 *                                   device
 *
 * @parm DWORD | dwUser | Input parameter to wodMessage - pointer to
 *   application's handle (generated by this routine)
 *
 * @parm LPWAVEOPENDESC | pwod | pointer to WAVEOPENDESC.  Was dwParam1
 *                               parameter to wodMessage
 *
 * @parm DWORD | dwParam2 | Input parameter to wodMessage
 *
 * @rdesc wodMessage return code.
 ***************************************************************************/
MMRESULT waveOpen
(
    LPDEVICEINFO   DeviceInfo,
    DWORD_PTR      dwUser,
    LPWAVEOPENDESC pwod,
    DWORD          dwParam2
)
{
    LPDEVICEINFO pClient;  // pointer to client information structure
    MMRESULT     mmr;
#ifndef UNDER_NT
    DWORD        dwCallback16;
#endif

    //
    // allocate my per-client structure
    //
    pClient = GlobalAllocDeviceInfo(DeviceInfo->wstrDeviceInterface);
    if (NULL == pClient)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    pClient->DeviceState = (LPVOID) GlobalAllocPtr( GPTR, sizeof( DEVICESTATE ) );
    if (NULL == pClient->DeviceState)
    {
        GlobalFreeDeviceInfo( pClient );
        MMRRETURN( MMSYSERR_NOMEM );
    }

    //
    //  Handle the query case and return early
    //
    if (WAVE_FORMAT_QUERY & dwParam2)
    {
        pClient->DeviceType   = DeviceInfo->DeviceType;
        pClient->DeviceNumber = DeviceInfo->DeviceNumber;
        pClient->dwFlags      = dwParam2;

        mmr = wdmaudOpenDev( pClient, (LPWAVEFORMATEX)pwod->lpFormat );

        if (mmr == MMSYSERR_NOTSUPPORTED)
        {
            mmr = WAVERR_BADFORMAT;
        }

        GlobalFreePtr( pClient->DeviceState );
        GlobalFreeDeviceInfo( pClient );
        return mmr;
    }

#ifdef UNDER_NT
    //
    // Allocate memory for our critical section
    //
    pClient->DeviceState->csQueue = (LPVOID) GlobalAllocPtr( GPTR, sizeof( CRITICAL_SECTION ) );
    if (NULL == pClient->DeviceState->csQueue)
    {
        GlobalFreePtr( pClient->DeviceState );
        GlobalFreeDeviceInfo( pClient );
        MMRRETURN( MMSYSERR_NOMEM );
    }

    try
    {
        InitializeCriticalSection( (LPCRITICAL_SECTION)pClient->DeviceState->csQueue );
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        GlobalFreePtr( pClient->DeviceState->csQueue );
        GlobalFreePtr( pClient->DeviceState );
        GlobalFreeDeviceInfo( pClient );
        MMRRETURN( MMSYSERR_NOMEM );
    }
#endif

    //
    //  fill out context data
    //
    pClient->DeviceNumber= DeviceInfo->DeviceNumber;
    pClient->DeviceType  = DeviceInfo->DeviceType;
    pClient->dwInstance  = pwod->dwInstance;
    pClient->dwCallback  = pwod->dwCallback;
    pClient->dwFlags     = dwParam2;
#ifdef UNDER_NT
    pClient->DeviceHandle= (HANDLE32)pwod->hWave;
#else
    pClient->DeviceHandle= (HANDLE32)MAKELONG(pwod->hWave,0);
    _asm
    {
        mov ax, offset WaveDeviceCallback
        mov word ptr [dwCallback16], ax
        mov ax, seg WaveDeviceCallback
        mov word ptr [dwCallback16+2], ax
    }
    pClient->dwCallback16= dwCallback16;
#endif


    //
    //  initialize the device state
    //
    pClient->DeviceState->lpWaveQueue = NULL;
    pClient->DeviceState->fRunning    = FALSE;
    pClient->DeviceState->fExit       = FALSE;
    if (pClient->DeviceType == WaveOutDevice)
        pClient->DeviceState->fPaused     = FALSE;
    else
        pClient->DeviceState->fPaused     = TRUE;
#ifdef DEBUG
    pClient->DeviceState->dwSig = DEVICESTATE_SIGNATURE;
#endif
    //
    // See if we can open our device
    //
    mmr = wdmaudOpenDev( pClient, (LPWAVEFORMATEX)pwod->lpFormat );

    if (mmr != MMSYSERR_NOERROR)
    {
        if (mmr == MMSYSERR_NOTSUPPORTED)
        {
            mmr = WAVERR_BADFORMAT;
        }

#ifdef UNDER_NT
        DeleteCriticalSection( (LPCRITICAL_SECTION)pClient->DeviceState->csQueue );
        GlobalFreePtr( pClient->DeviceState->csQueue );
        //
        // explicitly clear these values!  We don't want to ever see these set
        // again!
        //
        pClient->DeviceState->csQueue=NULL;
#endif
        GlobalFreePtr( pClient->DeviceState );
        pClient->DeviceState=NULL;
        GlobalFreeDeviceInfo( pClient );
        pClient=NULL;

        MMRRETURN( mmr );
    }

    //
    // Add instance to chain of devices
    //
    EnterCriticalSection(&wdmaudCritSec);
    pClient->Next = pWaveDeviceList;
    pWaveDeviceList = pClient;
    LeaveCriticalSection(&wdmaudCritSec);

    //
    // give the client my driver dw
    //
    {
        LPDEVICEINFO FAR *pUserHandle;

        pUserHandle = (LPDEVICEINFO FAR *)dwUser;
        *pUserHandle = pClient;
    }

    //
    // sent client his OPEN callback message
    //
    waveCallback(pClient, DeviceInfo->DeviceType == WaveOutDevice ? WOM_OPEN : WIM_OPEN, 0L);

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCleanUp | Free resources for a wave device
 *
 * @parm LPWAVEALLOC | pClient | Pointer to a WAVEALLOC structure describing
 *      resources to be freed.
 *
 * @rdesc There is no return value.
 *
 * @comm If the pointer to the resource is NULL then the resource has not
 *     been allocated.
 ***************************************************************************/
VOID waveCleanUp
(
    LPDEVICEINFO pClient
)
{
    LPDEVICEINFO FAR *ppCur ;

    //
    //  remove from device chain
    //
    EnterCriticalSection(&wdmaudCritSec);
    for (ppCur = &pWaveDeviceList;
         *ppCur != NULL;
         ppCur = &(*ppCur)->Next)
    {
       if (*ppCur == pClient)
       {
          *ppCur = (*ppCur)->Next;
          break;
       }
    }
    LeaveCriticalSection(&wdmaudCritSec);

#ifdef UNDER_NT
    DeleteCriticalSection( (LPCRITICAL_SECTION)pClient->DeviceState->csQueue );
    GlobalFreePtr( pClient->DeviceState->csQueue );
#endif
#ifdef DEBUG
    //
    // In debug, let's set all the values in the DEVICESTATE structure to bad
    // values.
    //
    pClient->DeviceState->cSampleBits=0xDEADBEEF;
    pClient->DeviceState->hThread=NULL;
    pClient->DeviceState->dwThreadId=0xDEADBEEF;
    pClient->DeviceState->lpWaveQueue=NULL;
    pClient->DeviceState->csQueue=NULL;
    pClient->DeviceState->hevtQueue=NULL;
    pClient->DeviceState->hevtExitThread=NULL;

#endif                       
    GlobalFreePtr( pClient->DeviceState );
    pClient->DeviceState=NULL;

#ifdef DEBUG
    //
    // Now set all the values in the DEVICEINFO structure to bad values.
    //
//    pClient->Next=(LPDEVICEINFO)0xDEADBEEF;
    pClient->DeviceNumber=-1;
    pClient->DeviceType=0xDEADBEEF;
    pClient->DeviceHandle=NULL;
    pClient->dwInstance=(DWORD_PTR)NULL;
    pClient->dwCallback=(DWORD_PTR)NULL;
    pClient->dwCallback16=0xDEADBEEF;
    pClient->dwFlags=0xDEADBEEF;
    pClient->DataBuffer=NULL;
    pClient->HardwareCallbackEventHandle=NULL;
    pClient->dwCallbackType=0xDEADBEEF;
    pClient->dwLineID=0xDEADBEEF;
    pClient->dwFormat=0xDEADBEEF;
//    pClient->DeviceState=(LPDEVICESTATE)0xDEADBEEF;

#endif
    GlobalFreeDeviceInfo( pClient ) ;
    pClient=NULL;
    DPF(DL_TRACE|FA_WAVE,("DeviceState gone!") );
}

#ifdef UNDER_NT
/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudPrepareWaveHeader |
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical wave
 *     device.
 *
 * @parm LPWAVEHDR | pHdr | Pointer to a wave buffer
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 ***************************************************************************/
MMRESULT wdmaudPrepareWaveHeader
(
    LPDEVICEINFO DeviceInfo,
    LPWAVEHDR    pHdr
)
{
    PWAVEPREPAREDATA pWavePrepareData;

    DPFASSERT(pHdr);

    pHdr->lpNext = NULL;
    pHdr->reserved = (DWORD_PTR)NULL;

    //
    //  Allocate memory for the prepared header instance data
    //
    pWavePrepareData = (PWAVEPREPAREDATA) GlobalAllocPtr( GPTR, sizeof(*pWavePrepareData));
    if (pWavePrepareData == NULL)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    //
    //  Allocate memory for our overlapped structure
    //
    pWavePrepareData->pOverlapped =
       (LPOVERLAPPED)HeapAlloc( GetProcessHeap(), 0, sizeof( OVERLAPPED ));
    if (NULL == pWavePrepareData->pOverlapped)
    {
        GlobalFreePtr( pWavePrepareData );
        MMRRETURN( MMSYSERR_NOMEM );
    }

    RtlZeroMemory( pWavePrepareData->pOverlapped, sizeof( OVERLAPPED ) );

    //
    //  Initialize the event once per preparation
    //
    if (NULL == (pWavePrepareData->pOverlapped->hEvent =
                    CreateEvent( NULL, FALSE, FALSE, NULL )))
    {
       HeapFree( GetProcessHeap(), 0, pWavePrepareData->pOverlapped);
       GlobalFreePtr( pWavePrepareData );
       MMRRETURN( MMSYSERR_NOMEM );
    }
#ifdef DEBUG
    pWavePrepareData->dwSig=WAVEPREPAREDATA_SIGNATURE;
#endif

    //
    // This next line adds this info to the main header.  Only after this point
    // will the info be used.
    //
    pHdr->reserved = (DWORD_PTR)pWavePrepareData;

    // Still have WinMM prepare this header
    return( MMSYSERR_NOTSUPPORTED );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudUnprepareWaveHeader |
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical wave
 *     device.
 *
 * @parm LPWAVEHDR | pHdr | Pointer to a wave buffer
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 ***************************************************************************/
MMRESULT wdmaudUnprepareWaveHeader
(
    LPDEVICEINFO DeviceInfo,
    LPWAVEHDR    pHdr
)
{
    MMRESULT mmr;
    PWAVEPREPAREDATA pWavePrepareData;

    if( ((mmr=IsValidWaveHeader(pHdr)) !=MMSYSERR_NOERROR ) ||
        ((mmr=IsValidPrepareWaveHeader((PWAVEPREPAREDATA)(pHdr->reserved))) != MMSYSERR_NOERROR ) )
    {
        MMRRETURN( mmr );
    }

    pWavePrepareData = (PWAVEPREPAREDATA)pHdr->reserved;
    //
    // This next line removes the WaveHeader from the list.  It is no longer
    // valid after this point!
    //
    pHdr->reserved = (DWORD_PTR)NULL;

    CloseHandle( pWavePrepareData->pOverlapped->hEvent );
    //
    // When you free something, you should make sure that you trash it before
    // the free.  But, in this case, the only thing we use in the pOverlapped
    // structure is the hEvent!
    //
    pWavePrepareData->pOverlapped->hEvent=NULL;
    HeapFree( GetProcessHeap(), 0, pWavePrepareData->pOverlapped);    
#ifdef DEBUG
    pWavePrepareData->pOverlapped=NULL;
    pWavePrepareData->dwSig=0;
#endif
    GlobalFreePtr( pWavePrepareData );

    // Still have WinMM prepare this header
    return( MMSYSERR_NOTSUPPORTED );
}

#endif
/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveWrite | This routine adds the header
 *     to the queue and then submits the buffer to the device
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical wave
 *     device.
 *
 * @parm LPWAVEHDR | pHdr | Pointer to a wave buffer
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
MMRESULT waveWrite
(
    LPDEVICEINFO DeviceInfo,
    LPWAVEHDR    pHdr
)
{
    MMRESULT     mmr;
    LPWAVEHDR    pTemp;

    //
    // Mark this buffer because kmixer doesn't handle the dwFlags
    //
    pHdr->dwFlags |= WHDR_INQUEUE;
    pHdr->dwFlags &= ~WHDR_DONE;

#ifndef UNDER_NT
    //
    // Store the context for this write in the header so that
    // we know which client to send this back to on completion.
    //
    pHdr->reserved = (DWORD)DeviceInfo;
#endif

    CRITENTER ;
    DPF(DL_MAX|FA_WAVE, ("(ECS)") ); // Enter critical section

    if (!DeviceInfo->DeviceState->lpWaveQueue)
    {
        DeviceInfo->DeviceState->lpWaveQueue = pHdr;
        pTemp = NULL;

#ifdef UNDER_NT
        if( (DeviceInfo->DeviceState->hevtQueue) &&
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTHREE) &&
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTWO) )
        {
            //
            // If we get here, waveThread is waiting on hevtQueue because lpWaveQueue
            // was empty and the completion thread exists == hevtQueue exists.
            // So,we want to signal the thread to wake up so we can have this
            // header serviced.  Note: the difference between this call and the
            // call made in wdmaudDestroyCompletionThread is that we don't set
            // fExit to TRUE before making the call.
            //
            DPF(DL_MAX|FA_WAVE, ("Setting DeviceInfo->hevtQueue"));
            SetEvent( DeviceInfo->DeviceState->hevtQueue );
        }
#endif
    }
    else
    {
        for (pTemp = DeviceInfo->DeviceState->lpWaveQueue;
             pTemp->lpNext != NULL;
             pTemp = pTemp->lpNext);

        pTemp->lpNext = pHdr;
    }

    DPF(DL_MAX|FA_WAVE, ("(LCS)") ); // Leave critical section
    CRITLEAVE ;

    //
    //  Call the 16 or 32-bit routine to send the buffer down
    //  to the kernel
    //
    mmr = wdmaudSubmitWaveHeader(DeviceInfo, pHdr);
    if (mmr != MMSYSERR_NOERROR)
    {
        // Unlink...
        if (pTemp)
        {
            pTemp->lpNext = NULL;
        } else {
            DeviceInfo->DeviceState->lpWaveQueue = NULL;        
        }
        pHdr->dwFlags &= ~WHDR_INQUEUE;
        DPF(DL_WARNING|FA_WAVE,("wdmaudSubmitWaveHeader failed mmr=%08X", mmr) );
    }
    else
    {
        //
        //  Kick start the device if it has been shutdown because of
        //  starvation.  Also this allows waveOut to start when the
        //  first waveheader is submitted to the device.
        //
        if (!DeviceInfo->DeviceState->fRunning && !DeviceInfo->DeviceState->fPaused)
        {
            mmr = wdmaudSetDeviceState(DeviceInfo, (DeviceInfo->DeviceType == WaveOutDevice) ?
                                             IOCTL_WDMAUD_WAVE_OUT_PLAY :
                                             IOCTL_WDMAUD_WAVE_IN_RECORD);
            if (mmr != MMSYSERR_NOERROR)
            {
                MMRESULT mmrError;

                mmrError = wdmaudSetDeviceState(DeviceInfo, (DeviceInfo->DeviceType == WaveOutDevice) ?
                                                IOCTL_WDMAUD_WAVE_OUT_RESET :
                                                IOCTL_WDMAUD_WAVE_IN_RESET);
                if (mmrError != MMSYSERR_NOERROR)
                {
                    DPF(DL_WARNING|FA_WAVE, ("Couldn't reset device after error putting into run state"));
                }
            }

        }
        else
        {
            DPF(DL_MAX|FA_WAVE, ("DeviceInfo = x%08lx, fRunning = %d, fPaused = %d",
                    DeviceInfo,
                    DeviceInfo->DeviceState->fRunning,
                    DeviceInfo->DeviceState->fPaused) );
        }
    }

    MMRRETURN( mmr );
}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | waveCompleteHeader |
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical wave
 *     device.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
VOID waveCompleteHeader
(
    LPDEVICEINFO  DeviceInfo
)
{
    LPWAVEHDR           pHdr;
    MMRESULT            mmr;

    // NOTE: This routine is called from within the csQueue critical section!!!
    //
    // Only remove headers from the front of the queue so that order is maintained.  
    // Note that pHdr is the head, The DeviceInfo structure's DeviceState's
    // lpWaveQueue pointer then gets updated to the next location.
    //

    //
    // Never use bad data when handling this Completion!
    //
    if( (pHdr = DeviceInfo->DeviceState->lpWaveQueue) &&
        ( (mmr=IsValidWaveHeader(pHdr)) == MMSYSERR_NOERROR ) )
    {        
        DeviceInfo->DeviceState->lpWaveQueue = DeviceInfo->DeviceState->lpWaveQueue->lpNext;

#ifdef UNDER_NT
        //
        //  Free temporary DeviceInfo for the asynchronous i/o
        //
        {
            PWAVEPREPAREDATA    pWavePrepareData;

            pWavePrepareData = (PWAVEPREPAREDATA)pHdr->reserved;

            //
            // Never attempt to free garbage!
            //
            if( (mmr=IsValidPrepareWaveHeader(pWavePrepareData)) == MMSYSERR_NOERROR )
                GlobalFreePtr( pWavePrepareData->pdi );
        }
        // Invoke the callback function..
        DPF(DL_TRACE|FA_WAVE, ("WaveHdr being returned: pHdr = 0x%08lx dwBytesRecorded = 0x%08lx",
                  pHdr, pHdr->dwBytesRecorded) );

        pHdr->lpNext = NULL ;
        pHdr->dwFlags &= ~WHDR_INQUEUE ;
        pHdr->dwFlags |= WHDR_DONE ;


        // NOTE: This callback is within the csQueue critical section !!!

        waveCallback(DeviceInfo,
                     DeviceInfo->DeviceType == WaveOutDevice ? WOM_DONE : WIM_DATA,
                     (DWORD_PTR)pHdr);

        DPF(DL_TRACE|FA_WAVE, ("Done") );
#else
        pHdr->dwFlags &= ~WHDR_INQUEUE;
        pHdr->dwFlags |= WHDR_DONE;
        pHdr->lpNext = NULL;

        waveCallback((LPDEVICEINFO)pHdr->reserved,
                     DeviceInfo->DeviceType == WaveOutDevice ? WOM_DONE : WIM_DATA,
                     (DWORD)pHdr);
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\drvproc.c ===
/****************************************************************************
 *
 *   drvproc.c
 *
 *   Generic WDM Audio driver message dispatch routines
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmdrv.h"

volatile BYTE  cPendingOpens = 0 ;
volatile BYTE  fExiting = 0 ;

#ifdef DEBUG

//UINT uiDebugLevel = DL_WARNING ;          // debug level

static TCHAR STR_DRIVER[]     = TEXT("wdmaud") ;
static TCHAR STR_MMDEBUG[]    = TEXT("uidebuglevel") ;

#endif

LRESULT _loadds CALLBACK DriverProc
    (
    DWORD           id,
    HDRVR           hDriver,
    WORD            msg,
    LPARAM          lParam1,
    LPARAM          lParam2
    )
{
    LPDEVICEINFO lpDeviceInfo;
    //DWORD dwCallback16;

    switch (msg)
    {
    case DRV_LOAD:

        //
        // Sent to the driver when it is loaded. Always the first
        // message received by a driver.
        //
        // dwDriverID is 0L.
        // lParam1 is 0L.
        // lParam2 is 0L.
        //
        // Return 0L to fail the load.
        //
        // DefDriverProc will return NON-ZERO so we don't have to
        // handle DRV_LOAD
        //

        DPF(DL_TRACE|FA_DRV, ("DRV_LOAD") ) ;

        return 1L ;

    case DRV_FREE:

        //
        // Sent to the driver when it is about to be discarded. This
        // will always be the last message received by a driver before
        // it is freed.
        //
        // dwDriverID is 0L.
        // lParam1 is 0L.
        // lParam2 is 0L.
        //
        // Return value is ignored.
        //

        DPF(DL_TRACE|FA_DRV, ("DRV_FREE") ) ;

        return 1L ;

    case DRV_OPEN:

        //
        // Sent to the driver when it is opened.
        //
        // dwDriverID is 0L.
        //
        // lParam1 is a far pointer to a zero-terminated string
        // containing the name used to open the driver.
        //
        // lParam2 is passed through from the drvOpen call.
        //
        // Return 0L to fail the open.
        //
        // DefDriverProc will return ZERO so we do have to
        // handle the DRV_OPEN message.
        //

        DPF(DL_TRACE|FA_DRV, ("DRV_OPEN") ) ;
        return 1L ;

    case DRV_CLOSE:

        //
        // Sent to the driver when it is closed. Drivers are unloaded
        // when the close count reaches zero.
        //
        // dwDriverID is the driver identifier returned from the
        // corresponding DRV_OPEN.
        //
        // lParam1 is passed through from the drvOpen call.
        //
        // lParam2 is passed through from the drvOpen call.
        //
        // Return 0L to fail the close.
        //
        // DefDriverProc will return ZERO so we do have to
        // handle the DRV_CLOSE message.
        //

        DPF(DL_TRACE|FA_DRV, ("DRV_CLOSE") ) ;

        return 1L ;

    case DRV_ENABLE:

        //
        // Sent to the driver when the driver is loaded or reloaded
        // and whenever Windows is enabled. Drivers should only
        // hook interrupts or expect ANY part of the driver to be in
        // memory between enable and disable messages
        //
        // dwDriverID is 0L.
        // lParam1 is 0L.
        // lParam2 is 0L.
        //
        // Return value is ignored.
        //

        DPF(DL_TRACE|FA_DRV, ("DRV_ENABLE") ) ;

        if (!DrvInit())
            return 0L ;    // error

        //
        //  Make sure that we don't take the critical section
        //  in wdmaudIoControl
        //
        lpDeviceInfo = GlobalAllocDeviceInfo(L"BogusDeviceString");
        if( lpDeviceInfo )
        {
            lpDeviceInfo->OpenDone = 0;
            lpDeviceInfo->DeviceType = AuxDevice;

            wdmaudIoControl(lpDeviceInfo,
                            0,
                            NULL,
                            IOCTL_WDMAUD_INIT);

            GlobalFreeDeviceInfo(lpDeviceInfo);
            return 1L;
        } else 
            return 0L;
        

    case DRV_DISABLE:

        //
        // Sent to the driver before the driver is freed.
        // and whenever Windows is disabled
        //
        // dwDriverID is 0L.
        // lParam1 is 0L.
        // lParam2 is 0L.
        //
        // Return value is ignored.
        //
        DPF(DL_TRACE|FA_DRV, ("DRV_DISABLE") ) ;

        //
        //  Make sure that we don't take the critical section
        //  in wdmaudIoControl
        //
        lpDeviceInfo = GlobalAllocDeviceInfo(L"BogusDeviceString");
        if( lpDeviceInfo )
        {
            lpDeviceInfo->OpenDone = 0;
            lpDeviceInfo->DeviceType = AuxDevice;

            wdmaudIoControl(lpDeviceInfo,
                            0,
                            NULL,
                            IOCTL_WDMAUD_EXIT);
            DrvEnd() ;

            GlobalFreeDeviceInfo(lpDeviceInfo);

            return 1L ;
        } else {
            return 0L;
        }

#ifndef UNDER_NT
    case DRV_EXITSESSION:

        //
        // Sent to the driver when windows is exiting
        //
        DPF(DL_TRACE|FA_DRV, ("DRV_EXITSESSION") ) ;

        fExiting = 1;
        while (cPendingOpens != 0)
        {
            Yield();
        }
        return 1L ;
#endif
    case DRV_QUERYCONFIGURE:

        //
        // Sent to the driver so that applications can
        // determine whether the driver supports custom
        // configuration. The driver should return a
        // non-zero value to indicate that configuration
        // is supported.
        //
        // For WDM drivers the settings dialog will be completely
        // tied to the Device Manager.  The individual drivers will
        // have to register a property page that will be invoked
        // when the user changes the device settings via the Device
        // Manager.
        //
        // dwDriverID is the value returned from the DRV_OPEN
        // call that must have succeeded before this message
        // was sent.
        //
        // lParam1 is passed from the app and is undefined.
        // lParam2 is passed from the app and is undefined.
        //
        // Return 0L to indicate configuration NOT supported.
        //

        DPF(DL_TRACE|FA_DRV, ("DRV_QUERYCONFIGURE") ) ;
        return 0L ;

    case DRV_CONFIGURE:

        //
        // Sent to the driver so that it can display a custom
        // configuration dialog box.
        //
        // lParam1 is passed from the app. and should contain
        // the parent window handle in the loword.
        // lParam2 is passed from the app and is undefined.
        //
        // Return value is REBOOT, OK, RESTART.
        //

        DPF(DL_TRACE|FA_DRV, ("DRV_CONFIGURE") ) ;
        return 0L ;

    case DRV_INSTALL:
        //
        // TODO: Should wdmaud.sys be added here so that I
        // don't have to reboot?
        //
        DPF(DL_TRACE|FA_DRV, ("DRV_INSTALL") ) ;
        return DRV_OK ;     // Install OK, Don't reboot

    case DRV_REMOVE:
        DPF(DL_TRACE|FA_DRV, ("DRV_REMOVE") ) ;
        return 0 ;

        //
        //  TODO: Handle ACPI power management messages.
        //
        //  Do I need to handle this case or is it
        //  completely covered by the kernel mode driver?
        //
    }

    return DefDriverProc( id, hDriver, msg, lParam1, lParam2 ) ;

} // DriverProc()


/**************************************************************************

    @doc EXTERNAL

    @api BOOL | LibMain | Entry point for 16-bit driver.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/
BOOL FAR PASCAL LibMain
    (
    HANDLE hInstance,
    WORD   wHeapSize,
    LPSTR  lpszCmdLine
    )
{

#ifdef DEBUG
    // get debug level - default should be DL_WARNING not DL_ERROR
    uiDebugLevel = GetProfileInt( STR_MMDEBUG, STR_DRIVER, DL_ERROR );   
#endif

#ifdef HTTP
    DPF(DL_WARNING|FA_ALL, ("************************************************************") );
    DPF(DL_WARNING|FA_ALL, ("* uiDebugLevel=%08X controls the debug output. To change",uiDebugLevel) );
    DPF(DL_WARNING|FA_ALL, ("* edit uiDebugLevel like: e uidebuglevel and set to         ") );
    DPF(DL_WARNING|FA_ALL, ("* 0 - show only fatal error messages and asserts            ") );
    DPF(DL_WARNING|FA_ALL, ("* 1 (Default) - Also show non-fatal errors and return codes ") );
    DPF(DL_WARNING|FA_ALL, ("* 2 - Also show trace messages                              ") );
    DPF(DL_WARNING|FA_ALL, ("* 4 - Show Every message                                    ") );
    DPF(DL_WARNING|FA_ALL, ("* See http:\\\\debugtips\\msgs\\wdmaud.htm for more info    ") );
    DPF(DL_WARNING|FA_ALL, ("************************************************************") );
#else
    DPF(DL_TRACE|FA_ALL, ("************************************************************") );
    DPF(DL_TRACE|FA_ALL, ("* uiDebugLevel=%08X controls the debug output. To change",uiDebugLevel) );
    DPF(DL_TRACE|FA_ALL, ("* edit uiDebugLevel like: e uidebuglevel and set to         ") );
    DPF(DL_TRACE|FA_ALL, ("* 0 - show only fatal error messages and asserts            ") );
    DPF(DL_TRACE|FA_ALL, ("* 1 (Default) - Also show non-fatal errors and return codes ") );
    DPF(DL_TRACE|FA_ALL, ("* 2 - Also show trace messages                              ") );
    DPF(DL_TRACE|FA_ALL, ("* 4 - Show Every message                                    ") );
    DPF(DL_TRACE|FA_ALL, ("************************************************************") );
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\mixer.c ===
//---------------------------------------------------------------------------
//
//  Module:   mixer.c
//
//  Description:
//    Contains the kernel mode portion of the mixer line driver.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "wdmdrv.h"
#include "mixer.h"

#ifndef UNDER_NT
extern volatile BYTE cPendingOpens;
extern volatile BYTE fExiting;
#else
HANDLE serializemixerapi=NULL;
SECURITY_ATTRIBUTES mutexsecurity;
SECURITY_DESCRIPTOR mutexdescriptor;
#endif

LPMIXERINSTANCE pMixerDeviceList = NULL;


#ifdef UNDER_NT

#define MXDM_GETHARDWAREEVENTDATA 0xffffffff

HANDLE mixercallbackevent=NULL;
HANDLE mixerhardwarecallbackevent=NULL;
HANDLE mixercallbackthread=NULL;
DWORD mixerthreadid=0;

ULONG localindex=0;
extern PCALLBACKS gpCallbacks;
extern DWORD sndTranslateStatus();

#pragma data_seg()

#define StoreCallback(Type,Id) {\
                                if (gpCallbacks) {\
                                 gpCallbacks->Callbacks[gpCallbacks->GlobalIndex%CALLBACKARRAYSIZE].dwCallbackType = Type;\
                                 gpCallbacks->Callbacks[gpCallbacks->GlobalIndex%CALLBACKARRAYSIZE].dwID = Id;\
                                 gpCallbacks->GlobalIndex++;\
                                }\
                               };

ULONG GetGlobalCallbackIndex()
{
    if (gpCallbacks != NULL) {
        return(gpCallbacks->GlobalIndex);
    }
    return (0);
}

BOOLEAN
CallbacksExist
(
    ULONG    localindex,
    DWORD    *Type,
    DWORD    *Id
)
{
    if (gpCallbacks == NULL) {
        return (FALSE);
    }

    if (localindex < gpCallbacks->GlobalIndex) {
        *Type = gpCallbacks->Callbacks[localindex%CALLBACKARRAYSIZE].dwCallbackType;
        *Id = gpCallbacks->Callbacks[localindex%CALLBACKARRAYSIZE].dwID;
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}

///////////////////////////////////////////////////////////////////////
//
// MIXERCOMPLETE
//
// Receives the callbacks from the kernel and calls all the clients.
//
//

#define MIXER_CONTROL_CALLBACK 0x01
#define MIXER_LINE_CALLBACK    0x02


VOID MIXERCOMPLETE
(
    ULONG  index,
    DWORD  dwID,
    DWORD  dwCallbackType
)
{
    LPMIXERINSTANCE lpInstance;
    LPMIXERINSTANCE deletelpInstance=NULL;
    
    // We have to syncronize the access to the instance list with the mixer
    // close code that removes elements from this list, and with the mixer
    // open code that adds elements to this list.  The easiest way to do
    // this is to use our global mixer api serialization mutex.

    WaitForSingleObject(serializemixerapi,INFINITE);

//    DPF( (2,  "<----" ) );

    for (lpInstance = pMixerDeviceList;
        lpInstance != NULL;
        lpInstance = lpInstance->Next
        ) {

        ISVALIDMIXERINSTANCE(lpInstance);

        if (deletelpInstance!=NULL) {
#ifdef DEBUG
            deletelpInstance->dwSig=0;
#endif
            GlobalFreePtr( deletelpInstance );
            deletelpInstance=NULL;
            }

        // Wait until the index is at the first callback data
        // for this instance before allowing any callbacks.  If
        // we are at the first callback data then allow all
        // future callbacks.
        if (lpInstance->firstcallbackindex) {
            if (index<lpInstance->firstcallbackindex) {
                continue;
                }
            else {
                lpInstance->firstcallbackindex=0;
                }
            }

        InterlockedIncrement(&lpInstance->referencecount);

        if( dwCallbackType == MIXER_CONTROL_CALLBACK ) {

/*
            DPF( (2, "MIXER_CONTROL_CALLBACK(%lX,%lX,%lX,%lX)",
                dwID,
                lpInstance->OpenDesc_dwCallback,
                lpInstance->OpenDesc_hmx,
                lpInstance->OpenDesc_dwInstance
                )
            );
*/
            ReleaseMutex(serializemixerapi);

            DriverCallback( lpInstance->OpenDesc_dwCallback,
                            DCB_FUNCTION,
                            lpInstance->OpenDesc_hmx,
                            MM_MIXM_CONTROL_CHANGE,
                            lpInstance->OpenDesc_dwInstance,
                            dwID,
                            0L
                            );

            WaitForSingleObject(serializemixerapi,INFINITE);

        } else if( dwCallbackType == MIXER_LINE_CALLBACK ) {

/*
            DPF( (2, "MIXER_LINE_CALLBACK(%lX,%lX,%lX,%lX)",
                dwID,
                lpInstance->OpenDesc_dwCallback,
                lpInstance->OpenDesc_hmx,
                lpInstance->OpenDesc_dwInstance
                )
            );
*/
            ReleaseMutex(serializemixerapi);

            DriverCallback( lpInstance->OpenDesc_dwCallback,
                            DCB_FUNCTION,
                            lpInstance->OpenDesc_hmx,
                            MM_MIXM_LINE_CHANGE,
                            lpInstance->OpenDesc_dwInstance,
                            dwID,
                            0L
                            );

            WaitForSingleObject(serializemixerapi,INFINITE);

        } else {
            //
            // The callback wasn't one that is recognized.  Just
            // return and abort the loop
            //
//            DPF( (2, "Invalid Mixer Callback -- %d!", dwCallbackType) );

            if (InterlockedDecrement(&lpInstance->referencecount)<0) {
                deletelpInstance=lpInstance;
                }


            DPFASSERT(0);

            break;
        }

        if (InterlockedDecrement(&lpInstance->referencecount)<0) {
            deletelpInstance=lpInstance;
            }

    }

//    DPF( (2,  "---->" ) );

    if (deletelpInstance!=NULL) {
#ifdef DEBUG
        deletelpInstance->dwSig=0;
#endif
        GlobalFreePtr( deletelpInstance );
        deletelpInstance=NULL;
        }

    ReleaseMutex(serializemixerapi);

}


DWORD 
WINAPI
MixerCallbackThread(
    LPVOID lpParamNotUsed
    )
{
    MMRESULT status=MMSYSERR_NOERROR;
    DWORD  dwID;
    WORD   wCallbackType;
    HANDLE callbackevents[2];
    DWORD index;
    DWORD Type, Id;

    // Setup the handles array.
    callbackevents[0]=mixerhardwarecallbackevent;
    callbackevents[1]=mixercallbackevent;

    if (!SetThreadPriority(mixercallbackthread,THREAD_PRIORITY_TIME_CRITICAL)) {
        status=GetLastError();
    }

    while (1) {

        // Block until a callback may be needed.
        index=WaitForMultipleObjects(2,callbackevents,FALSE,INFINITE);

        // Did hardware event happen?  If so get the new data.
        if (index==0) {
            mxdMessage(0,MXDM_GETHARDWAREEVENTDATA,0,0,0);
        }

        // Scan through all new callbacks - looking for any that
        // we need to make for this process.

        while (CallbacksExist(localindex,&Type, &Id)) {

            DPF(DL_TRACE|FA_EVENT, ("Thrd id %d, lindex %d, gindex %d, dwid %d, cbtype %d ",
                    mixerthreadid,
                    localindex,
                    gpCallbacks->GlobalIndex,
                    Id,
                    Type
                    ));

            MIXERCOMPLETE(localindex, Id, Type);

            localindex++;
        }
    }
    return ERROR_SUCCESS;
}

MMRESULT SetupMixerCallbacks(VOID)
{

MMRESULT status=MMSYSERR_NOERROR;


// First get a handle to a named global callback event so that
// the callback threads can block.

if (NULL==mixercallbackevent) {

    // First assume event exists and try to open it.
    // This will succeed in all cases except the very first
    // time it is run.
    mixercallbackevent=OpenEvent(SYNCHRONIZE | EVENT_MODIFY_STATE, TRUE, L"Global\\mixercallback");

    if (NULL==mixercallbackevent) {

        // Didn't exist, so now create it.

        SECURITY_ATTRIBUTES SecurityAttributes;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;

        // First build the required security descriptor.

        pSecurityDescriptor=BuildSecurityDescriptor(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
        if(pSecurityDescriptor==NULL) {
            status= sndTranslateStatus();
            return status;
            }

        //
        // Create an event such that all processes have access to it.
        //

        SecurityAttributes.nLength = sizeof(SecurityAttributes);
        SecurityAttributes.lpSecurityDescriptor = pSecurityDescriptor;
        SecurityAttributes.bInheritHandle = FALSE;

        mixercallbackevent=CreateEvent(&SecurityAttributes, TRUE, FALSE, L"Global\\mixercallback");


        // Now free the security descriptor memory we allocated.
        DestroySecurityDescriptor(pSecurityDescriptor);

        if (NULL==mixercallbackevent) {

            // Handle the race condition that exists when 2
            // threads both try to Create and only the first succeeds.
            mixercallbackevent=OpenEvent(SYNCHRONIZE | EVENT_MODIFY_STATE, TRUE, L"Global\\mixercallback");

            if (NULL==mixercallbackevent) {
                status= sndTranslateStatus();
                return status;
                }

            }

        }

    }

// Now get a handle to the global hardware callback event.

if (NULL==mixerhardwarecallbackevent) {

    // First assume event exists and try to open it.
    // This will succeed in all cases except the very first
    // time it is run.
    mixerhardwarecallbackevent=OpenEvent(SYNCHRONIZE | EVENT_MODIFY_STATE, TRUE, L"Global\\hardwaremixercallback");

    if (NULL==mixerhardwarecallbackevent) {

        // Didn't exist, so now create it.

        SECURITY_ATTRIBUTES SecurityAttributes;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;

        // First build the required security descriptor.

        pSecurityDescriptor=BuildSecurityDescriptor(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
        if(pSecurityDescriptor==NULL) {
            status= sndTranslateStatus();
            return status;
            }

        //
        // Create an event such that all processes have access to it.
        //

        SecurityAttributes.nLength = sizeof(SecurityAttributes);
        SecurityAttributes.lpSecurityDescriptor = pSecurityDescriptor;
        SecurityAttributes.bInheritHandle = FALSE;

        // Note that this event releases only 1 thread at a time
        // whereas the other callback event releases them all!
        mixerhardwarecallbackevent=CreateEvent(&SecurityAttributes, FALSE, FALSE, L"Global\\hardwaremixercallback");

        // Now free the security descriptor memory we allocated.
        DestroySecurityDescriptor(pSecurityDescriptor);

        if (NULL==mixerhardwarecallbackevent) {

            // Handle the race condition that exists when 2
            // threads both try to Create and only the first succeeds.
            mixerhardwarecallbackevent=OpenEvent(SYNCHRONIZE | EVENT_MODIFY_STATE, TRUE, L"Global\\hardwaremixercallback");

            if (NULL==mixerhardwarecallbackevent) {
                status= sndTranslateStatus();
                return status;
                }

            }

        }

    }


// Now create a thread in this process for making the
// callbacks if not already done.

if ( NULL == mixercallbackthread ) {

    mixercallbackthread=CreateThread(NULL, 0, MixerCallbackThread, NULL, CREATE_SUSPENDED, &mixerthreadid);

    if ( NULL == mixercallbackthread ) {
        status= sndTranslateStatus();
        return status;
    } else {

        // if we successfully created the thread, we can now activate it.  

        if( ResumeThread(mixercallbackthread) == -1 ) {
            status= sndTranslateStatus();
            return status;
        }
    }
}

return status;

}

#endif  // UNDER_NT


//--------------------------------------------------------------------------
// LPDEVICEINFO AllocMixerDeviceInfo
//--------------------------------------------------------------------------
LPDEVICEINFO GlobalAllocMixerDeviceInfo(LPWSTR DeviceInterface, UINT id, DWORD_PTR dwKernelInstance)
{
    LPDEVICEINFO pDeviceInfo;

    pDeviceInfo = GlobalAllocDeviceInfo(DeviceInterface);
    if (pDeviceInfo)
    {
        pDeviceInfo->dwInstance = dwKernelInstance;
        pDeviceInfo->DeviceNumber = id;
        pDeviceInfo->DeviceType = MixerDevice;
        pDeviceInfo->dwCallbackType = 0;
        pDeviceInfo->ControlCallbackCount=0;
#ifndef UNDER_NT
        pDeviceInfo->dwFormat     = ANSI_TAG;
#else
        pDeviceInfo->dwFormat     = UNICODE_TAG;
#endif // !UNDER_NT
    }
    return pDeviceInfo;
}


///////////////////////////////////////////////////////////////////////
//
// mxdMessage
//
//

DWORD FAR PASCAL _loadds mxdMessage
(
    UINT            id,         // The device Id the message is for
    UINT            msg,        // The message to perform
    DWORD_PTR       dwUser,     // The instance data.
    DWORD_PTR       dwParam1,   // Message specific parameter 1
    DWORD_PTR       dwParam2    // Message specific parmaeter 2
)
{

    MMRESULT mmr;

    ULONG initialcallbackindex;

    if (NULL==serializemixerapi) 
    {
        //
        // To synchronize between this routine and the MixerCallbackThread we
        // want a process specific mutex.  Thus, we create one the first time
        // through.
        //
        serializemixerapi=CreateMutex(NULL,FALSE,NULL);
        if (NULL==serializemixerapi) 
        {
            MMRRETURN( MMSYSERR_NOMEM );
        }
    }

    WaitForSingleObject(serializemixerapi,INFINITE);

    initialcallbackindex=GetGlobalCallbackIndex();

    switch (msg)
    {
        ///////////////////////////////////////////////////////////////
        case MXDM_INIT:
        ///////////////////////////////////////////////////////////////

            mmr=wdmaudAddRemoveDevNode( MixerDevice, (LPCWSTR)dwParam2, TRUE);
            break;

        ///////////////////////////////////////////////////////////////
        case DRVM_EXIT:
        ///////////////////////////////////////////////////////////////

            mmr=wdmaudAddRemoveDevNode( MixerDevice, (LPCWSTR)dwParam2, FALSE);
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_GETNUMDEVS:
        ///////////////////////////////////////////////////////////////

            DPF(DL_TRACE|FA_MIXER, ("MIXM_GETNUMDEVS(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            mmr=wdmaudGetNumDevs(MixerDevice, (LPCWSTR)dwParam1);
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_GETDEVCAPS:
        ///////////////////////////////////////////////////////////////
            {
            LPDEVICEINFO pDeviceInfo;

            DPF(DL_TRACE|FA_MIXER, ("MIXM_GETDEVCAPS(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            pDeviceInfo = GlobalAllocMixerDeviceInfo((LPWSTR)dwParam2, id, 0);
            if (pDeviceInfo) {
                mmr = wdmaudGetDevCaps(pDeviceInfo, (MDEVICECAPSEX FAR*)dwParam1);
                GlobalFreeDeviceInfo(pDeviceInfo);
                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            }
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_OPEN:
        ///////////////////////////////////////////////////////////////
            {
            LPMIXEROPENDESC pMixerOpenDesc = (LPMIXEROPENDESC)dwParam1;
            LPMIXERINSTANCE pMixerInstance;

            DPF(DL_TRACE|FA_MIXER, ("MIXM_OPEN(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            pMixerInstance = (LPMIXERINSTANCE) GlobalAllocPtr(
                GPTR | GMEM_SHARE,
                sizeof( MIXERINSTANCE ) + (sizeof(WCHAR)*lstrlenW((LPWSTR)pMixerOpenDesc->dnDevNode)));

            if( pMixerInstance == NULL ) {
                mmr=MMSYSERR_NOMEM;
                break;
                }

            pMixerInstance->referencecount=0;
#ifdef DEBUG
            pMixerInstance->dwSig=MIXERINSTANCE_SIGNATURE;
#endif

            if (mixercallbackthread==NULL) {
                localindex=GetGlobalCallbackIndex();
                }
            pMixerInstance->firstcallbackindex=GetGlobalCallbackIndex();

            if (mixercallbackthread==NULL) {
                if ((mmr=SetupMixerCallbacks())!=MMSYSERR_NOERROR) {
                    GlobalFreePtr( pMixerInstance );
                    break;
                    }
                }

            // We allocate a DEVICEINFO and MIXEROPENDESC with GlobalAlloc so
            // that on Win98 it is in system global memory.  This is necessary
            // because the following IOCTL is async on Win98.  This isn't really
            // necessary on NT 5, but in the interest of common sources we do it
            // this way even on NT 5.

            pMixerOpenDesc = GlobalAllocPtr(GPTR, sizeof(*pMixerOpenDesc));
            if (pMixerOpenDesc) {

                LPDEVICEINFO pDeviceInfo;

                // Copy the input MIXEROPENDESC to our globally allocated MIXEROPENDESC
                *pMixerOpenDesc = *((LPMIXEROPENDESC)dwParam1);

                pDeviceInfo = GlobalAllocMixerDeviceInfo((LPWSTR)pMixerOpenDesc->dnDevNode, id, 0);
                if (pDeviceInfo) {

                    pDeviceInfo->dwFlags = (DWORD)dwParam2;
                    pDeviceInfo->HardwareCallbackEventHandle=0;
                    if (mixerhardwarecallbackevent) {
                        pDeviceInfo->HardwareCallbackEventHandle=mixerhardwarecallbackevent;
                        }
                    pDeviceInfo->mmr = MMSYSERR_ERROR;
                    mmr = wdmaudIoControl(pDeviceInfo,
                        0,
                        NULL,
                        IOCTL_WDMAUD_MIXER_OPEN);

                    EXTRACTERROR(mmr,pDeviceInfo);

                        if (MMSYSERR_NOERROR == mmr) {
                            // Fill in the MixerInstance structure
                            pMixerInstance->Next = NULL;
                            pMixerInstance->OpenDesc_hmx        = (HDRVR)pMixerOpenDesc->hmx;
                            pMixerInstance->OpenDesc_dwCallback = pMixerOpenDesc->dwCallback;
                            pMixerInstance->OpenDesc_dwInstance = pMixerOpenDesc->dwInstance;
                            pMixerInstance->OpenFlags           = (DWORD)dwParam2;
                        lstrcpyW(pMixerInstance->wstrDeviceInterface, (LPWSTR)pMixerOpenDesc->dnDevNode);

                        pMixerInstance->dwKernelInstance = pDeviceInfo->dwInstance;
                    }                    
                    GlobalFreeDeviceInfo(pDeviceInfo);
                    pDeviceInfo = NULL;

                }
                else {
                    mmr = MMSYSERR_NOMEM;
                }

                GlobalFreePtr(pMixerOpenDesc);
                pMixerOpenDesc = NULL;

                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            if( mmr == MMSYSERR_NOERROR ) {

                pMixerInstance->Next = pMixerDeviceList;
                pMixerDeviceList = pMixerInstance;
                *((PDWORD_PTR) dwUser) = (DWORD_PTR) pMixerInstance;

                // Sanity check that we put a valid mixer instance structure in the list.
                ISVALIDMIXERINSTANCE(pMixerInstance);
                }
            else {
#ifdef DEBUG
                pMixerInstance->dwSig=0;
#endif
                GlobalFreePtr( pMixerInstance );
                }

            }
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_CLOSE:
        ///////////////////////////////////////////////////////////////
            {
            LPMIXERINSTANCE pInstance = (LPMIXERINSTANCE)dwUser;
            LPDEVICEINFO pDeviceInfo;

            DPF(DL_TRACE|FA_MIXER, ("MIXM_CLOSE(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            if( (mmr=IsValidMixerInstance(pInstance)) != MMSYSERR_NOERROR)
                break;
            
            pDeviceInfo = GlobalAllocMixerDeviceInfo(pInstance->wstrDeviceInterface, id, pInstance->dwKernelInstance);

            if (pDeviceInfo) {
                mxdRemoveClient( pInstance );
                pDeviceInfo->mmr = MMSYSERR_ERROR;
                mmr = wdmaudIoControl(
                    pDeviceInfo,
                    0,
                    NULL,
                    IOCTL_WDMAUD_MIXER_CLOSE
                    );
                EXTRACTERROR(mmr,pDeviceInfo);
                GlobalFreeDeviceInfo(pDeviceInfo);
                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            }
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_GETLINEINFO:
        ///////////////////////////////////////////////////////////////
            {
            LPMIXERINSTANCE pInstance = (LPMIXERINSTANCE)dwUser;
            LPDEVICEINFO pDeviceInfo;

            DPF(DL_TRACE|FA_MIXER, ("MIXM_GETLINEINFO(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            if( (mmr=IsValidMixerInstance(pInstance)) != MMSYSERR_NOERROR)
                break;

            pDeviceInfo = GlobalAllocMixerDeviceInfo(pInstance->wstrDeviceInterface, id, pInstance->dwKernelInstance);

            if (pDeviceInfo) {
                pDeviceInfo->dwFlags = (DWORD)dwParam2;
                pDeviceInfo->mmr     = MMSYSERR_ERROR;
                mmr = wdmaudIoControl(
                    pDeviceInfo,
                    ((LPMIXERLINE) dwParam1)->cbStruct,
                    (LPVOID) dwParam1,
                    IOCTL_WDMAUD_MIXER_GETLINEINFO
                    );
                EXTRACTERROR(mmr,pDeviceInfo);
                GlobalFreeDeviceInfo(pDeviceInfo);
                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            }
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_GETLINECONTROLS:
        ///////////////////////////////////////////////////////////////
            {
            LPMIXERINSTANCE pInstance = (LPMIXERINSTANCE)dwUser;
            LPDEVICEINFO pDeviceInfo;

            DPF(DL_TRACE|FA_MIXER, ("MIXM_GETLINECONTROLS(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            if( (mmr=IsValidMixerInstance(pInstance)) != MMSYSERR_NOERROR)
                break;

            pDeviceInfo = GlobalAllocMixerDeviceInfo(pInstance->wstrDeviceInterface, id, pInstance->dwKernelInstance);

            if (pDeviceInfo) {
                pDeviceInfo->dwFlags = (DWORD)dwParam2;
                pDeviceInfo->mmr     = MMSYSERR_ERROR;
                mmr = wdmaudIoControl(
                    pDeviceInfo,
                    ((LPMIXERLINECONTROLS) dwParam1)->cbStruct,
                    (LPVOID) dwParam1,
                    IOCTL_WDMAUD_MIXER_GETLINECONTROLS
                    );
                EXTRACTERROR(mmr,pDeviceInfo);
                GlobalFreeDeviceInfo(pDeviceInfo);
                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            }
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_GETCONTROLDETAILS:
        ///////////////////////////////////////////////////////////////
            {
            LPMIXERINSTANCE pInstance = (LPMIXERINSTANCE)dwUser;
            LPDEVICEINFO pDeviceInfo;

            DPF(DL_TRACE|FA_MIXER, ("MIXM_GETCONTROLDETAILS(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            if( (mmr=IsValidMixerInstance(pInstance)) != MMSYSERR_NOERROR)
                break;

            pDeviceInfo = GlobalAllocMixerDeviceInfo(pInstance->wstrDeviceInterface, id, pInstance->dwKernelInstance);

            if (pDeviceInfo) {
                pDeviceInfo->dwFlags = (DWORD)dwParam2;
                pDeviceInfo->mmr     = MMSYSERR_ERROR;
                mmr = wdmaudIoControl(
                    pDeviceInfo,
                    ((LPMIXERCONTROLDETAILS) dwParam1)->cbStruct,
                    (LPVOID) dwParam1,
                    IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS
                    );
                EXTRACTERROR(mmr,pDeviceInfo);
                GlobalFreeDeviceInfo(pDeviceInfo);
                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            }
            break;

        ///////////////////////////////////////////////////////////////
        case MXDM_SETCONTROLDETAILS:
        ///////////////////////////////////////////////////////////////
            {
            LPMIXERINSTANCE pInstance = (LPMIXERINSTANCE)dwUser;
            LPDEVICEINFO pDeviceInfo;

            DPF(DL_TRACE|FA_MIXER, ("MIXM_SETCONTROLDETAILS(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            if( (mmr=IsValidMixerInstance(pInstance)) != MMSYSERR_NOERROR)
                break;

            pDeviceInfo = GlobalAllocMixerDeviceInfo(pInstance->wstrDeviceInterface, id, pInstance->dwKernelInstance);

            if (pDeviceInfo) {
                pDeviceInfo->dwFlags = (DWORD)dwParam2;
                pDeviceInfo->mmr     = MMSYSERR_ERROR;
                pDeviceInfo->dwCallbackType=0;
                mmr = wdmaudIoControl(
                    pDeviceInfo,
                    ((LPMIXERCONTROLDETAILS) dwParam1)->cbStruct,
                    (LPVOID) dwParam1,
                    IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS
                    );
                EXTRACTERROR(mmr,pDeviceInfo);

                if (pDeviceInfo->dwCallbackType&MIXER_CONTROL_CALLBACK) {
                        LONG j;
                        for (j=0; j<pDeviceInfo->ControlCallbackCount; j++) {
                            StoreCallback(MIXER_CONTROL_CALLBACK,
                                          (pDeviceInfo->dwID)[j]);
                            }
                    }
                if (pDeviceInfo->dwCallbackType&MIXER_LINE_CALLBACK) {
                    StoreCallback(MIXER_LINE_CALLBACK,
                                  pDeviceInfo->dwLineID);
                    }
                GlobalFreeDeviceInfo(pDeviceInfo);
                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            }

            // Map invalid error codes to valid ones.
            switch (mmr) {

                case MMSYSERR_ERROR:
                    mmr = MMSYSERR_NOMEM;
                    break;

                default:
                    break;
                }


            break;

#ifdef UNDER_NT
        ///////////////////////////////////////////////////////////////
        case MXDM_GETHARDWAREEVENTDATA:
        ///////////////////////////////////////////////////////////////
            {
            LPMIXERINSTANCE pInstance = (LPMIXERINSTANCE)dwUser;
            LPDEVICEINFO pDeviceInfo;

            DPF(DL_TRACE|FA_MIXER, ("MXDM_GETHARDWAREEVENTDATA(%d,%lx,%lx,%lx)", id, dwUser, dwParam1, dwParam2) );

            DPFASSERT( dwUser==0 && dwParam1==0 && dwParam2==0 );

            if (dwUser!=0 || dwParam1!=0 || dwParam2!=0) {
                mmr=MMSYSERR_INVALPARAM;
                break;
                }

            pDeviceInfo = GlobalAllocMixerDeviceInfo(L" ", 0, 0);

            if (pDeviceInfo) {
                pDeviceInfo->dwCallbackType=1;

// WorkItem: Hey, this loop continually calls the driver and doesn't error out!!!!!  Shouldn't it?

                while(pDeviceInfo->dwCallbackType) {
                    pDeviceInfo->dwFlags = 0;
                    pDeviceInfo->mmr     = MMSYSERR_ERROR;
                    pDeviceInfo->dwCallbackType=0;
                    mmr = wdmaudIoControl(
                        pDeviceInfo,
                        0,
                        NULL,
                        IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA
                        );
                    EXTRACTERROR(mmr,pDeviceInfo);
                    if (pDeviceInfo->dwCallbackType&MIXER_CONTROL_CALLBACK) {
                                                LONG j;
                                for (j=0; j<pDeviceInfo->ControlCallbackCount; j++) {
                                    StoreCallback(MIXER_CONTROL_CALLBACK,
                                                  (pDeviceInfo->dwID)[j]);
                                }
                        }
                    if (pDeviceInfo->dwCallbackType&MIXER_LINE_CALLBACK) {
                        StoreCallback(MIXER_LINE_CALLBACK,
                                      pDeviceInfo->dwLineID);
                        }
                    }

                mmr = pDeviceInfo->mmr;  // WorkItem: Why isn't this inside the loop?
                GlobalFreeDeviceInfo(pDeviceInfo);
                }
            else {
                mmr = MMSYSERR_NOMEM;
                }

            }

            break;
#endif

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            mmr=MMSYSERR_NOTSUPPORTED;
            break;
    }

//#if 0
#ifdef UNDER_NT
    ReleaseMutex(serializemixerapi);

    // Now check if any callbacks were logged while we were
    // running.  If so, make them.
    if (GetGlobalCallbackIndex()!=initialcallbackindex) {
        if (mixercallbackevent!=NULL) {
            PulseEvent(mixercallbackevent);
        }
    }

#endif


MMRRETURN( mmr );

} // mxdMessage()

///////////////////////////////////////////////////////////////////////
//
// mxdRemoveClient
//
//

VOID
mxdRemoveClient(
    LPMIXERINSTANCE lpInstance
)
{
    LPMIXERINSTANCE lp, lpPrevious;

    lpPrevious = (LPMIXERINSTANCE)&pMixerDeviceList;
    for(lp = pMixerDeviceList; lp != NULL; lp = lp->Next) {

        ISVALIDMIXERINSTANCE(lp);

        if(lp == lpInstance) {

            lpPrevious->Next = lp->Next;

#ifdef UNDER_NT

            if (InterlockedDecrement(&lpInstance->referencecount)<0) {
                // The instance is not in use by a callback.  So OK to free it.
#ifdef DEBUG
                lpInstance->dwSig=0;
#endif
                GlobalFreePtr( lpInstance );
                }

            // This instance is in use by a callback, so do not free it now.
            // We are already setup so the callback will free it, since we have
            // changed the referencecount so it will not be zero after the callback
            // code decrements it.  That will prompt the callback code to release
            // the instance memory.

#else

            GlobalFreePtr( lpInstance );

#endif

            break;
        }
        lpPrevious = lp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\waveout.c ===
/****************************************************************************
 *
 *   waveout.c
 *
 *   WDM Audio support for Wave Output devices
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmdrv.h"

/****************************************************************************

    This function conforms to the standard Wave output driver message proc
    (wodMessage), which is documented in mmddk.h.

****************************************************************************/
DWORD FAR PASCAL _loadds wodMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    LPDEVICEINFO pOutClient;
    LPDEVICEINFO pDeviceInfo;
    LPWAVEHDR    lpWaveHdr;
    MMRESULT     mmr;

    switch (msg) {
        case WODM_INIT:
            DPF(DL_TRACE|FA_WAVE, ("WODM_INIT") );
            return(wdmaudAddRemoveDevNode(WaveOutDevice, (LPCWSTR)dwParam2, TRUE));

        case DRVM_EXIT:
            DPF(DL_TRACE|FA_WAVE, ("DRVM_EXIT: WaveOut") );
            return(wdmaudAddRemoveDevNode(WaveOutDevice, (LPCWSTR)dwParam2, FALSE));

        case WODM_GETNUMDEVS:
            DPF(DL_TRACE|FA_WAVE, ("WODM_GETNUMDEVS") );
            return wdmaudGetNumDevs(WaveOutDevice, (LPCWSTR)dwParam1);

        case WODM_GETDEVCAPS:
            DPF(DL_TRACE|FA_WAVE, ("WODM_GETDEVCAPS") );
            if (pDeviceInfo = GlobalAllocDeviceInfo((LPCWSTR)dwParam2))
            {
                pDeviceInfo->DeviceType = WaveOutDevice;
                pDeviceInfo->DeviceNumber = id;
                mmr = wdmaudGetDevCaps(pDeviceInfo, (MDEVICECAPSEX FAR*)dwParam1);
                GlobalFreeDeviceInfo(pDeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM );
            }

    case WODM_PREFERRED:
            DPF(DL_TRACE|FA_WAVE, ("WODM_PREFERRED: %d", id) );
        return wdmaudSetPreferredDevice(
          WaveOutDevice,
          id,
          dwParam1,
          dwParam2);

        case WODM_OPEN:
        {
            LPWAVEOPENDESC pwod = (LPWAVEOPENDESC)dwParam1;
            DPF(DL_TRACE|FA_WAVE, ("WODM_OPEN") );
            if (pDeviceInfo = GlobalAllocDeviceInfo((LPCWSTR)pwod->dnDevNode))
            {
                pDeviceInfo->DeviceType = WaveOutDevice;
                pDeviceInfo->DeviceNumber = id;
#ifdef UNDER_NT
                pDeviceInfo->DeviceHandle = (HANDLE32)pwod->hWave;
#else
                pDeviceInfo->DeviceHandle = (HANDLE32)MAKELONG(pwod->hWave,0);
#endif
                mmr = waveOpen(pDeviceInfo, dwUser, pwod, (DWORD)dwParam2);
                GlobalFreeDeviceInfo(pDeviceInfo);
                return mmr;
            } else {
                MMRRETURN( MMSYSERR_NOMEM );
            }
        }

        case WODM_CLOSE:
            DPF(DL_TRACE|FA_WAVE, ("WODM_CLOSE") );
            pOutClient = (LPDEVICEINFO)dwUser;

            if( ((mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR ) ||
                ((mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR) )
            {
                MMRRETURN( mmr );
            }

            mmr = wdmaudCloseDev( pOutClient );
            if (MMSYSERR_NOERROR == mmr)
            {
                waveCallback(pOutClient, WOM_CLOSE, 0L);

                ISVALIDDEVICEINFO(pOutClient);
                ISVALIDDEVICESTATE(pOutClient->DeviceState,FALSE);

                waveCleanUp(pOutClient);
            }
            return mmr;

        case WODM_WRITE:
            DPF(DL_TRACE|FA_WAVE, ("WODM_WRITE") );
            lpWaveHdr = (LPWAVEHDR)dwParam1;
            pOutClient = (LPDEVICEINFO)dwUser;

            //
            // Sanity check the parameters and fail bad data!
            //
            if( ( (mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) ||
                ( (mmr=IsValidWaveHeader(lpWaveHdr)) != MMSYSERR_NOERROR ) )
            {
                MMRRETURN( mmr );
            }

            // check if it's been prepared
            DPFASSERT(lpWaveHdr->dwFlags & WHDR_PREPARED);
            if (!(lpWaveHdr->dwFlags & WHDR_PREPARED))
                MMRRETURN( WAVERR_UNPREPARED );

            // if it is already in our Q, then we cannot do this
            DPFASSERT(!(lpWaveHdr->dwFlags & WHDR_INQUEUE));
            if ( lpWaveHdr->dwFlags & WHDR_INQUEUE )
                MMRRETURN( WAVERR_STILLPLAYING );

            //
            // Put the request at the end of our queue.
            //
            return waveWrite(pOutClient, lpWaveHdr);

        case WODM_PAUSE:
            DPF(DL_TRACE|FA_WAVE, ("WODM_PAUSE") );
            pOutClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pOutClient,
                                        IOCTL_WDMAUD_WAVE_OUT_PAUSE);

        case WODM_RESTART:
            DPF(DL_TRACE|FA_WAVE, ("WODM_RESTART") );
            pOutClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pOutClient,
                                        IOCTL_WDMAUD_WAVE_OUT_PLAY);

        case WODM_RESET:
            DPF(DL_TRACE|FA_WAVE, ("WODM_RESET") );
            pOutClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pOutClient,
                                        IOCTL_WDMAUD_WAVE_OUT_RESET);

        case WODM_BREAKLOOP:
            DPF(DL_TRACE|FA_WAVE, ("WODM_BREAKLOOP") );
            pOutClient = (LPDEVICEINFO)dwUser;
            return wdmaudSetDeviceState(pOutClient,
                                        IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP);

        case WODM_GETPOS:
            DPF(DL_TRACE|FA_WAVE, ("WODM_GETPOS") );

            pOutClient = (LPDEVICEINFO)dwUser;

            if( ((mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR ) ||
                ((mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) ) 
            {
                MMRRETURN( mmr );
            }
                
            mmr = wdmaudGetPos(pOutClient,
                               (LPMMTIME)dwParam1,
                               (DWORD)dwParam2,
                               WaveOutDevice);
            DPF(DL_TRACE|FA_WAVE, ("GetPos: returned %lu", ((LPMMTIME)(dwParam1))->u.ms));
            return mmr;

        case WODM_SETVOLUME:
            DPF(DL_TRACE|FA_WAVE, ("WODM_SETVOLUME") );

            pOutClient = GlobalAllocDeviceInfo((LPWSTR)dwParam2);
            if (NULL == pOutClient)
            {
                MMRRETURN( MMSYSERR_NOMEM );
            }

            pOutClient->DeviceType = WaveOutDevice;
            pOutClient->DeviceNumber = id;
            pOutClient->OpenDone = 0;
            PRESETERROR(pOutClient);

            mmr = wdmaudIoControl(pOutClient,
                                  sizeof(DWORD),
                                  (LPBYTE)&dwParam1,
                                  IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME);
            POSTEXTRACTERROR(mmr,pOutClient);
            GlobalFreeDeviceInfo(pOutClient);
            return mmr;

        case WODM_GETVOLUME:
            DPF(DL_TRACE|FA_WAVE, ("WODM_GETVOLUME") );

            pOutClient = GlobalAllocDeviceInfo((LPWSTR)dwParam2);
            if (pOutClient)
            {
                LPDWORD pVolume;

                pVolume = (LPDWORD) GlobalAllocPtr( GPTR, sizeof(DWORD));
                if (pVolume)
                {
                    pOutClient->DeviceType = WaveOutDevice;
                    pOutClient->DeviceNumber = id;
                    pOutClient->OpenDone = 0;

                    mmr = wdmaudIoControl(pOutClient,
                                          sizeof(DWORD),
                                          (LPBYTE)pVolume,
                                          IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME);

                    //
                    // Only write back information on success.
                    //
                    if( MMSYSERR_NOERROR == mmr )
                        *((DWORD FAR *) dwParam1) = *pVolume;

                    GlobalFreePtr(pVolume);
                } else {
                    mmr = MMSYSERR_NOMEM;
                }

                GlobalFreeDeviceInfo(pOutClient);
            } else {
                mmr = MMSYSERR_NOMEM;
            }

            MMRRETURN( mmr );

#ifdef UNDER_NT
        case WODM_PREPARE:
            DPF(DL_TRACE|FA_WAVE, ("WODM_PREPARE") );
            pOutClient = (LPDEVICEINFO)dwUser;

            if( ((mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR ) ||
                ((mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) ) 
            {
                MMRRETURN( mmr );
            }

            return wdmaudPrepareWaveHeader(pOutClient, (LPWAVEHDR)dwParam1);

        case WODM_UNPREPARE:
            DPF(DL_TRACE|FA_WAVE, ("WODM_UNPREPARE") );
            pOutClient = (LPDEVICEINFO)dwUser;

            if( ((mmr=IsValidDeviceInfo(pOutClient)) != MMSYSERR_NOERROR ) ||
                ((mmr=IsValidDeviceState(pOutClient->DeviceState,FALSE)) != MMSYSERR_NOERROR ) ) 
            {
                MMRRETURN( mmr );
            }

            return wdmaudUnprepareWaveHeader(pOutClient, (LPWAVEHDR)dwParam1);
#endif

        case WODM_GETPITCH:
        case WODM_SETPITCH:
        case WODM_GETPLAYBACKRATE:
        case WODM_SETPLAYBACKRATE:
            MMRRETURN( MMSYSERR_NOTSUPPORTED );

        default:
            MMRRETURN( MMSYSERR_NOTSUPPORTED );
    }

    //
    // Should not get here
    //

    DPFASSERT(0);
    MMRRETURN( MMSYSERR_NOTSUPPORTED );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\wdmdrv.h ===
/****************************************************************************
 *
 *   wdmdrv.h
 *
 *   Function declarations, etc. for WDMAUD.DRV
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include <stdio.h>

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>

#include <ks.h>
#include <ksmedia.h>

#include <setupapi.h>

#ifdef UNDER_NT
#if (DBG)
#define DEBUG
#endif
#endif

#include <wdmaud.h>
#include <midi.h>

/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/

#ifdef DEBUG

extern VOID FAR __cdecl wdmaudDbgOut(LPSTR lpszFormat, ...);
extern UINT uiDebugLevel;     // debug level
extern char szReturningErrorStr[];
extern char *MsgToAscii(ULONG ulMsg);

//
// Debug message levels:
//
#define DL_ERROR   0x00000000
#define DL_WARNING 0x00000001
#define DL_TRACE   0x00000002
#define DL_MAX     0x00000004

#define DL_MASK    0x000000FF

//
// 20 bits reserved for functional areas.  If we find that this bit is set
// in the DebugLevel variable, we will display every message of this type.
//          
#define FA_AUX           0x80000000  
#define FA_DEVICEIO      0x40000000
#define FA_SETUP         0x20000000
#define FA_MIDI          0x10000000
#define FA_WAVE          0x08000000
#define FA_RECORD        0x04000000
#define FA_EVENT         0x02000000
#define FA_MIXER         0x01000000
#define FA_DRV           0x00800000
#define FA_ASSERT        0x00400000
#define FA_RETURN        0x00200000
#define FA_SYNC          0x00100000
#define FA_MASK          0xFFFFF000
#define FA_ALL           0x00001000


extern VOID 
wdmaudDbgBreakPoint(
    );

extern UINT 
wdmaudDbgPreCheckLevel(
    UINT uiMsgLevel,
    char *pFunction,
    int iLine
    );

extern UINT 
wdmaudDbgPostCheckLevel(
    UINT uiMsgLevel
    );

extern char * 
wdmaudReturnString(
    ULONG ulMsg
    );


extern char szReturningErrorStr[];

//----------------------------------------------------------------------------
//
// This debug macro is used like this:
//
// DPF(DL_WARNING|FA_MIXER,("Message %X %X %X ...",x,y,z,...) );
//
// The output for this message will look like:
//
// WDMAUD.DRV FooFunction Warning Message 5 6 7 - Set BP on 64003452 to DBG
//
// The only difference between this code and the code in wdmaud.sys is that
// to break in the debugger, you call DbgBreak() and to display a string you
//  call OutputDebugString(...).
//
// The call to wdmaudDbgPreCheckLevel displays:
//
// "WDMAUD.DRV FooFunction Warning "
//
// The call to wdmaudDbgOut displays the actual message
//
// "Message 5 6 7 ..."
//
// and the call to wdmaudDbgPostCheckLevel finishs the line
//
// " - Set BP on 64003452 to DBG"
//
//----------------------------------------------------------------------------

#define DPF(_x_,_y_) {if( wdmaudDbgPreCheckLevel(_x_,__FUNCTION__,__LINE__) ) { wdmaudDbgOut _y_; \
    wdmaudDbgPostCheckLevel( _x_ ); }}
    
//
// Warning: Do not rap function calls in this return macro!  Notice that 
// _mmr_ is used more then once, thus the function call would be made more
// than once!
//

#define MMRRETURN( _mmr_ ) {if ( _mmr_ != MMSYSERR_NOERROR) \
        { DPF(DL_WARNING|FA_RETURN, (szReturningErrorStr, _mmr_,MsgToAscii(_mmr_)) ); } \
        return _mmr_;}

//
// It's bad form to put more then one expression in an assert macro.  Why? because
// you will not know exactly what expression failed the assert!
//
// dDbgAssert should be: 
//
#define DPFASSERT(_exp_) {if( !(_exp_) ) {DPF(DL_ERROR|FA_ASSERT,("'%s'",#_exp_) );}} 
    
//    #define WinAssert(exp) ((exp) ? (VOID)0 : dDbgAssert(#exp, __FILE__, __LINE__))

#define DbgBreak() DebugBreak()

// The path trap macro ...
#define DPFBTRAP() DPF(DL_ERROR|FA_ASSERT,("Path Trap, Please report") );
    
//
// There are a number of internal structures that we want to keep tabs on.  In 
// every case, there will be a signature in the structure that we can use when
// verifying the content.
//
#define WAVEPREPAREDATA_SIGNATURE   'DPPW' //WPPD as seen in memory
#define MIXERINSTANCE_SIGNATURE     'IMAW' // WAMI as seen in memory

#else

#define DPF( _x_,_y_ )
#define MMRRETURN( _mmr_ ) return (_mmr_)
#define DPFASSERT(x) 0
#define DbgBreak()

#endif

#ifdef DEBUG
//
// Here are a couple of defines used to look for corruption paths
//
#define FOURTYTHREE  0x43434343
#define FOURTYTWO    0x42424242
#define FOURTYEIGHT  0x48484848
#else
#define FOURTYTHREE  NULL
#define FOURTYTWO    NULL
#define FOURTYEIGHT  NULL
#endif

/***************************************************************************

    UNICODE SUPPORT

 ***************************************************************************/

//
// Taken from winnt.h
//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
#define _TCHAR_DEFINED
#define TEXT(quote) L##quote
#endif /* !_TCHAR_DEFINED */

#else   /* UNICODE */

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
#define _TCHAR_DEFINED
#define TEXT(quote) quote
#endif /* !_TCHAR_DEFINED */

#endif /* UNICODE */

/****************************************************************************

 Random defines and global variables

 ***************************************************************************/

#define WDMAUD_MAX_DEVICES  100

extern LPDEVICEINFO pWaveDeviceList;
extern LPDEVICEINFO pMidiDeviceList;
extern CRITICAL_SECTION wdmaudCritSec;

#ifdef UNDER_NT
#define CRITENTER         EnterCriticalSection( (LPCRITICAL_SECTION)DeviceInfo->DeviceState->csQueue )
#define CRITLEAVE         LeaveCriticalSection( (LPCRITICAL_SECTION)DeviceInfo->DeviceState->csQueue )
#else
extern  WORD                gwCritLevel ;        // critical section counter
#define CRITENTER         if (!(gwCritLevel++)) _asm { cli }
#define CRITLEAVE         if (!(--gwCritLevel)) _asm { sti }
#endif

#ifdef UNDER_NT


#define CALLBACKARRAYSIZE 128

typedef struct {
    DWORD   dwID;
    DWORD   dwCallbackType;
} CBINFO;

typedef struct {
    ULONG    GlobalIndex;
    CBINFO   Callbacks[CALLBACKARRAYSIZE];
} CALLBACKS, *PCALLBACKS;

#endif
//
// These two macros are for validating error return codes from wdmaud.sys.
//
// This first one sets the input and output buffer for a DeviceIoControl call to
// a known bad value.
//
#define PRESETERROR(_di) _di->mmr=0xDEADBEEF

//
// This macro reads: if the return value from wdmaudIoControl is SUCCESS THEN 
// check to see if there was an error code placed in the device info structure.
// If so (we don't find DEADBEEF there), that is the real error value to return.
// But, if during the call the value didn't get set, we'll find DEADBEEF in the
// error location!  Thus,the check for DEADBEEF that simply restores the device
// info mmr entry to SUCCESS.
//
#define POSTEXTRACTERROR(r, _di)  if( r == MMSYSERR_NOERROR ) { \
                                    if( _di->mmr != 0xDEADBEEF ) { \
                                      r = _di->mmr; \
                                    } else {           \
DPF(DL_TRACE|FA_DEVICEIO, ("wdmaudIoControl didn't set mmr %X:%s", r, MsgToAscii(r)) ); \
                                      _di->mmr = MMSYSERR_NOERROR; } }

#define EXTRACTERROR(r, _di)  if( r == MMSYSERR_NOERROR ) { r = _di->mmr; }

/****************************************************************************

 Struture definitions

 ***************************************************************************/

typedef struct _WAVEPREPAREDATA
{
    struct _DEVICEINFO FAR       *pdi;
    LPOVERLAPPED                 pOverlapped;  // Overlapped structure
                                               // for completion
#ifdef DEBUG
    DWORD dwSig;  // WPPD
#endif
} WAVEPREPAREDATA, FAR *PWAVEPREPAREDATA;

/****************************************************************************

 Driver entry points

 ***************************************************************************/


BOOL FAR PASCAL LibMain
(
    HANDLE hInstance,
    WORD   wHeapSize,
    LPSTR  lpszCmdLine
);

BOOL WINAPI DllEntryPoint
(
    HINSTANCE hinstDLL,
    DWORD     fdwReason,
    LPVOID    lpvReserved
);

LRESULT _loadds CALLBACK DriverProc
(
    DWORD id,
    HDRVR hDriver,
    WORD msg,
    LPARAM lParam1,
    LPARAM lParam2
);

DWORD FAR PASCAL _loadds wodMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

DWORD FAR PASCAL _loadds widMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

DWORD FAR PASCAL _loadds modMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

DWORD FAR PASCAL _loadds midMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

DWORD FAR PASCAL _loadds mxdMessage
(
    UINT      id,
    UINT      msg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

/****************************************************************************

 Local routines

 ***************************************************************************/

BOOL DrvInit();
HANDLE wdmaOpenKernelDevice();
VOID DrvEnd();

LPDEVICEINFO GlobalAllocDeviceInfo(LPCWSTR DeviceInterface);
VOID GlobalFreeDeviceInfo(LPDEVICEINFO lpdi);


MMRESULT wdmaudOpenDev
(
    LPDEVICEINFO    DeviceInfo,
    LPWAVEFORMATEX  lpWaveFormat
);

MMRESULT FAR wdmaudCloseDev
(
    LPDEVICEINFO DeviceInfo
);

MMRESULT FAR wdmaudGetDevCaps
(
    LPDEVICEINFO DeviceInfo,
    MDEVICECAPSEX FAR *MediaDeviceCapsEx
);

DWORD FAR wdmaudGetNumDevs
(
    UINT    DeviceType,
    LPCWSTR DeviceInterface
);

DWORD FAR wdmaudAddRemoveDevNode
(
    UINT    DeviceType,
    LPCWSTR DeviceInterface,
    BOOL    fAdd
);

DWORD FAR wdmaudSetPreferredDevice
(
    UINT    DeviceType,
    UINT    DeviceNumber,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
);

MMRESULT FAR wdmaudIoControl
(
    LPDEVICEINFO DeviceInfo,
    DWORD        dwSize,
    LPVOID       pData,
    ULONG        IoCode
);

MMRESULT wdmaudSetDeviceState
(
    LPDEVICEINFO DeviceInfo,
    ULONG        IoCode
);

MMRESULT wdmaudGetPos
(
    LPDEVICEINFO    pClient,
    LPMMTIME        lpmmt,
    DWORD           dwSize,
    UINT            DeviceType
);

VOID FAR midiCallback
(
    LPDEVICEINFO pMidi,
    UINT         msg,
    DWORD_PTR    dw1,
    DWORD_PTR    dw2
);

MMRESULT FAR midiOpen
(
    LPDEVICEINFO   DeviceInfo,
    DWORD_PTR      dwUser,
    LPMIDIOPENDESC pmod,
    DWORD          dwParam2
);

VOID FAR midiCleanUp
(
    LPDEVICEINFO pClient
);

MMRESULT midiInRead
(
    LPDEVICEINFO  pClient,
    LPMIDIHDR     pHdr
);

MMRESULT FAR midiOutWrite
(
    LPDEVICEINFO pClient,
    DWORD        ulEvent
);

VOID FAR midiOutAllNotesOff
(
    LPDEVICEINFO pClient
);

VOID FAR waveCallback
(
    LPDEVICEINFO pWave,
    UINT         msg,
    DWORD_PTR    dw1
);

MMRESULT waveOpen
(
    LPDEVICEINFO   DeviceInfo,
    DWORD_PTR      dwUser,
    LPWAVEOPENDESC pwod,
    DWORD          dwParam2
);

VOID waveCleanUp
(
    LPDEVICEINFO pClient
);

MMRESULT waveWrite
(
    LPDEVICEINFO pClient,
    LPWAVEHDR    pHdr
);

MMRESULT wdmaudSubmitWaveHeader
(
    LPDEVICEINFO DeviceInfo,
    LPWAVEHDR    pHdr
);

MMRESULT FAR wdmaudSubmitMidiOutHeader
(
    LPDEVICEINFO  DeviceInfo,
    LPMIDIHDR     pHdr
);

MMRESULT wdmaudSubmitMidiInHeader
(
    LPDEVICEINFO DeviceInfo,
    LPMIDIHDR    pHdrex
);

VOID waveCompleteHeader
(
    LPDEVICEINFO DeviceInfo
);

VOID midiInCompleteHeader
(
    LPDEVICEINFO  DeviceInfo,
    DWORD         dwTimeStamp,
    WORD          wDataType
);

VOID midiInEventCallback
(
    HANDLE  MidiHandle,
    DWORD   dwEvent
);

#ifdef UNDER_NT
PSECURITY_DESCRIPTOR BuildSecurityDescriptor
(
    DWORD AccessMask
);

void DestroySecurityDescriptor
(
    PSECURITY_DESCRIPTOR pSd
);

MMRESULT wdmaudPrepareWaveHeader
(
    LPDEVICEINFO DeviceInfo,
    LPWAVEHDR    pHdr
);

MMRESULT wdmaudUnprepareWaveHeader
(
    LPDEVICEINFO DeviceInfo,
    LPWAVEHDR    pHdr
);

MMRESULT wdmaudGetMidiData
(
    LPDEVICEINFO        DeviceInfo,
    LPMIDIDATALISTENTRY pOldMidiDataListEntry
);

void wdmaudParseMidiData
(
    LPDEVICEINFO        DeviceInfo,
    LPMIDIDATALISTENTRY pMidiData
);

void wdmaudFreeMidiData
(
    LPDEVICEINFO        DeviceInfo,
    LPMIDIDATALISTENTRY pMidiData
);

MMRESULT wdmaudFreeMidiQ
(
    LPDEVICEINFO  DeviceInfo
);

MMRESULT wdmaudCreateCompletionThread
(
    LPDEVICEINFO DeviceInfo
);

MMRESULT wdmaudDestroyCompletionThread
(
    LPDEVICEINFO DeviceInfo
);
#endif

MMRESULT 
IsValidDeviceInfo(
    LPDEVICEINFO lpDeviceInfo
    );

MMRESULT 
IsValidDeviceState(
    LPDEVICESTATE lpDeviceState,
    BOOL bFullyConfigured
    );

MMRESULT
IsValidWaveHeader(
    LPWAVEHDR pWaveHdr
    );

MMRESULT
IsValidMidiHeader(
    LPMIDIHDR pMidiHdr
    );

MMRESULT
IsValidPrepareWaveHeader(
    PWAVEPREPAREDATA pPrepare
    );

BOOL 
IsValidDeviceInterface(
    LPCWSTR DeviceInterface
    );

MMRESULT
IsValidOverLapped(
    LPOVERLAPPED lpol
    );

MMRESULT
IsValidMidiDataListEntry(
    LPMIDIDATALISTENTRY pMidiDataListEntry
    );

MMRESULT
IsValidWaveOpenDesc(
    LPWAVEOPENDESC pwod
    );


#ifdef DEBUG
#define ISVALIDDEVICEINFO(x)        IsValidDeviceInfo(x)
#define ISVALIDDEVICESTATE(x,y)     IsValidDeviceState(x,y)
#define ISVALIDWAVEHEADER(x)        IsValidWaveHeader(x)
#define ISVALIDMIDIHEADER(x)        IsValidMidiHeader(x)
#define ISVALIDPREPAREWAVEHEADER(x) IsValidPrepareWaveHeader(x)
#define ISVALIDDEVICEINTERFACE(x)   IsValidDeviceInterface(x)
#define ISVALIDOVERLAPPED(x)        IsValidOverLapped(x)
#define ISVALIDMIDIDATALISTENTRY(x) IsValidMidiDataListEntry(x)
#define ISVALIDWAVEOPENDESC(x)      IsValidWaveOpenDesc(x)

#else
#define ISVALIDDEVICEINFO(x) 
#define ISVALIDDEVICESTATE(x,y) 
#define ISVALIDWAVEHEADER(x) 
#define ISVALIDMIDIHEADER(x) 
#define ISVALIDPREPAREWAVEHEADER(x) 
#define ISVALIDDEVICEINTERFACE(x) 
#define ISVALIDOVERLAPPED(x) 
#define ISVALIDMIDIDATALISTENTRY(x) 
#define ISVALIDWAVEOPENDESC(x) 
#endif


#ifndef UNDER_NT
VOID WaveDeviceCallback();
VOID MidiInDeviceCallback();
VOID MidiEventDeviceCallback();
VOID MixerDeviceCallback();
#endif

PCALLBACKS wdmaGetCallbacks();
PCALLBACKS wdmaCreateCallbacks();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\wdmaud32.c ===
/****************************************************************************
 *
 *   wdmaud32.c
 *
 *   32-bit specific interfaces for WDMAUD
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmdrv.h"

HANDLE ghCallbacks = NULL;
PCALLBACKS gpCallbacks = NULL;

HANDLE ghDevice = NULL;

//
// gpszDeviceInterfacePath is a pointer to the device interface string
// that represents wdmaud.sys to this driver.
//
LPWSTR gpszDeviceInterfacePath = NULL;

BOOL   wdmaudCritSecInit;
CRITICAL_SECTION wdmaudCritSec;
static TCHAR gszCallbacks[] = TEXT("Global\\WDMAUD_Callbacks");

extern HANDLE mixercallbackevent;
extern HANDLE mixerhardwarecallbackevent;
extern HANDLE mixercallbackthread;

DWORD waveThread(LPDEVICEINFO DeviceInfo);
DWORD midThread(LPDEVICEINFO DeviceInfo);

DWORD sndTranslateStatus();

typedef struct _SETUPAPIDLINFO {
    HINSTANCE   hInstSetupAPI;
    BOOL        (WINAPI *pfnDestroyDeviceInfoList)(HDEVINFO);
    BOOL        (WINAPI *pfnGetDeviceInterfaceDetailW)(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, PSP_DEVICE_INTERFACE_DETAIL_DATA_W, DWORD, PDWORD, PSP_DEVINFO_DATA);
    BOOL        (WINAPI *pfnEnumDeviceInterfaces)(HDEVINFO, PSP_DEVINFO_DATA, CONST GUID*, DWORD, PSP_DEVICE_INTERFACE_DATA);
    HDEVINFO    (WINAPI *pfnGetClassDevsW)(CONST GUID*, PCWSTR, HWND, DWORD);
} SETUPAPIDLINFO;

SETUPAPIDLINFO  saInfo = {NULL, NULL, NULL, NULL};

/****************************************************************************

                         Dynalinking setupapi

****************************************************************************/

BOOL Init_SetupAPI();
BOOL End_SetupAPI();

BOOL 
dl_SetupDiDestroyDeviceInfoList(
    HDEVINFO    DeviceInfoSet
);

BOOL 
dl_SetupDiGetDeviceInterfaceDetail(
    HDEVINFO                            DeviceInfoSet,
    PSP_DEVICE_INTERFACE_DATA           DeviceInterfaceData,
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W  DeviceInterfaceDetailData,
    DWORD                               DeviceInterfaceDetailDataSize,
    PDWORD                              RequiredSize,
    PSP_DEVINFO_DATA                    DeviceInfoData
);

BOOL 
dl_SetupDiEnumDeviceInterfaces(
    HDEVINFO                    DeviceInfoSet,
    PSP_DEVINFO_DATA            DeviceInfoData,
    CONST GUID                  *InterfaceClassGuid,
    DWORD                       MemberIndex,
    PSP_DEVICE_INTERFACE_DATA   DeviceInterfaceData
);

HDEVINFO 
dl_SetupDiGetClassDevs(
    CONST GUID  *ClassGuid,
    PCWSTR      Enumerator,
    HWND        hwndParent,
    DWORD       Flags
);

/****************************************************************************

                   Setting up SetupAPI Dynalink...

****************************************************************************/

BOOL 
Init_SetupAPI(
    void
    )
{
    if(NULL != saInfo.hInstSetupAPI)
    {
        return TRUE;
    }

    DPF(DL_TRACE|FA_SETUP, ("Loading SetupAPI!!!") );
    saInfo.hInstSetupAPI = LoadLibrary(TEXT("setupapi.dll"));

    if(NULL == saInfo.hInstSetupAPI)
    {
        return FALSE;
    }

    saInfo.pfnDestroyDeviceInfoList     = (LPVOID)GetProcAddress(saInfo.hInstSetupAPI, 
                                                                 "SetupDiDestroyDeviceInfoList");
    saInfo.pfnGetDeviceInterfaceDetailW = (LPVOID)GetProcAddress(saInfo.hInstSetupAPI, 
                                                                 "SetupDiGetDeviceInterfaceDetailW");
    saInfo.pfnEnumDeviceInterfaces      = (LPVOID)GetProcAddress(saInfo.hInstSetupAPI, 
                                                                 "SetupDiEnumDeviceInterfaces");
    saInfo.pfnGetClassDevsW             = (LPVOID)GetProcAddress(saInfo.hInstSetupAPI, 
                                                                 "SetupDiGetClassDevsW");

    if ((NULL == saInfo.pfnDestroyDeviceInfoList) ||
        (NULL == saInfo.pfnGetDeviceInterfaceDetailW) ||
        (NULL == saInfo.pfnEnumDeviceInterfaces) ||
        (NULL == saInfo.pfnGetClassDevsW))
    {
        FreeLibrary(saInfo.hInstSetupAPI);
        ZeroMemory(&saInfo, sizeof(saInfo));
        return FALSE;
    }

    return TRUE;
}

BOOL 
End_SetupAPI(
    void
    )
{
    HINSTANCE   hInst;

    hInst = saInfo.hInstSetupAPI;

    if(NULL == hInst)
    {
        DPF(DL_WARNING|FA_SETUP, ("SetupAPI not dynalinked") );
        return FALSE;
    }

    ZeroMemory(&saInfo, sizeof(saInfo));
    FreeLibrary(hInst);

    return TRUE;
}

BOOL 
dl_SetupDiDestroyDeviceInfoList(
    HDEVINFO    DeviceInfoSet
    )
{
    if (NULL == saInfo.hInstSetupAPI)
    {
        DPF(DL_WARNING|FA_SETUP, ("SetupAPI not dynalinked") );
        return FALSE;
    }

    return (saInfo.pfnDestroyDeviceInfoList)(DeviceInfoSet);
}

BOOL 
dl_SetupDiGetDeviceInterfaceDetail(
    HDEVINFO                            DeviceInfoSet,
    PSP_DEVICE_INTERFACE_DATA           DeviceInterfaceData,
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W  DeviceInterfaceDetailData,
    DWORD                               DeviceInterfaceDetailDataSize,
    PDWORD                              RequiredSize,
    PSP_DEVINFO_DATA                    DeviceInfoData
    )
{
    if (NULL == saInfo.hInstSetupAPI)
    {
        DPF(DL_WARNING|FA_SETUP, ("SetupAPI not dynalinked") );
        return FALSE;
    }

    return (saInfo.pfnGetDeviceInterfaceDetailW)(DeviceInfoSet,
                                                 DeviceInterfaceData,
                                                 DeviceInterfaceDetailData,
                                                 DeviceInterfaceDetailDataSize,
                                                 RequiredSize,
                                                 DeviceInfoData);
}

BOOL 
dl_SetupDiEnumDeviceInterfaces(
    HDEVINFO                    DeviceInfoSet,
    PSP_DEVINFO_DATA            DeviceInfoData,
    CONST GUID                  *InterfaceClassGuid,
    DWORD                       MemberIndex,
    PSP_DEVICE_INTERFACE_DATA   DeviceInterfaceData
    )
{
    if (NULL == saInfo.hInstSetupAPI)
    {
        DPF(DL_WARNING|FA_SETUP, ("SetupAPI not dynalinked") );
        return FALSE;
    }

    return (saInfo.pfnEnumDeviceInterfaces)(DeviceInfoSet,
                                            DeviceInfoData,
                                            InterfaceClassGuid,
                                            MemberIndex,
                                            DeviceInterfaceData);
}

HDEVINFO 
dl_SetupDiGetClassDevs(
    CONST GUID  *ClassGuid,
    PCWSTR      Enumerator,
    HWND        hwndParent,
    DWORD       Flags
    )
{
    if (NULL == saInfo.hInstSetupAPI)
    {
        DPF(DL_WARNING|FA_SETUP, ("SetupAPI not dynalinked") );
        return FALSE;
    }

    return (saInfo.pfnGetClassDevsW)(ClassGuid,
                                     Enumerator,
                                     hwndParent,
                                     Flags);
}

PSECURITY_DESCRIPTOR 
BuildSecurityDescriptor(
    DWORD AccessMask
    )
{
    PSECURITY_DESCRIPTOR pSd;
    PSID pSidSystem;
    PSID pSidEveryone;
    PACL pDacl;
    ULONG cbDacl;
    BOOL fSuccess;
    BOOL f;

    SID_IDENTIFIER_AUTHORITY AuthorityNt = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY AuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;

    fSuccess = FALSE;

    pSd = HeapAlloc(GetProcessHeap(), 0, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSd)
    {
        if (InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION))
        {
            if (AllocateAndInitializeSid(&AuthorityNt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem))
            {
                DPFASSERT(IsValidSid(pSidSystem));
                if (AllocateAndInitializeSid(&AuthorityWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidEveryone))
                {
                    DPFASSERT(IsValidSid(pSidEveryone));
                    cbDacl = sizeof(ACL) +
                             2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                             GetLengthSid(pSidSystem) +
                             GetLengthSid(pSidEveryone);

                    pDacl = HeapAlloc(GetProcessHeap(), 0, cbDacl);
                    if (pDacl) {
                        if (InitializeAcl(pDacl, cbDacl, ACL_REVISION))
                        {
                            if (AddAccessAllowedAce(pDacl, ACL_REVISION, GENERIC_ALL, pSidSystem))
                            {
                                if (AddAccessAllowedAce(pDacl, ACL_REVISION, AccessMask, pSidEveryone))
                                {
                                    if (SetSecurityDescriptorDacl(pSd, TRUE, pDacl, FALSE))
                                    {
                                        fSuccess = TRUE;
                                    } else {
                                        DPF(DL_WARNING|FA_SETUP, ("BuildSD: SetSecurityDescriptorDacl failed"));
                                    }
                                } else {
                                    DPF(DL_WARNING|FA_SETUP, ("BuildSD: AddAccessAlloweAce for Everyone failed"));
                                }
                            } else {
                                DPF(DL_WARNING|FA_SETUP, ("BuildSD: AddAccessAllowedAce for System failed"));
                            }
                        } else {
                            DPF(DL_WARNING|FA_SETUP, ("BuildSD: InitializeAcl failed"));
                        }

                        if (!fSuccess) {
                            f = HeapFree(GetProcessHeap(), 0, pDacl);
                            DPFASSERT(f);
                        }
                    }
                    FreeSid(pSidEveryone);
                } else {
                    DPF(DL_WARNING|FA_SETUP, ("BuildSD: AllocateAndInitizeSid failed for Everyone"));
                }
                FreeSid(pSidSystem);
            } else {
                DPF(DL_WARNING|FA_SETUP, ("BuildSD: AllocateAndInitizeSid failed for System"));
            }
        } else {
            DPF(DL_WARNING|FA_SETUP, ("BuildSD: InitializeSecurityDescriptor failed"));
        }

        if (!fSuccess) {
            f = HeapFree(GetProcessHeap(), 0, pSd);
            DPFASSERT(f);
        }
    }

    return fSuccess ? pSd : NULL;
}

void 
DestroySecurityDescriptor(
    PSECURITY_DESCRIPTOR pSd
    )
{
    PACL pDacl;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    BOOL f;

    if (GetSecurityDescriptorDacl(pSd, &fDaclPresent, &pDacl, &fDaclDefaulted))
    {
        if (fDaclPresent)
        {
            f = HeapFree(GetProcessHeap(), 0, pDacl);
            DPFASSERT(f);
        }
    } else {
        DPF(DL_WARNING|FA_SETUP, ("DestroySD: GetSecurityDescriptorDacl failed"));
    }

    f = HeapFree(GetProcessHeap(), 0, pSd);
    DPFASSERT(f);

    return;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllEntryPoint | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/
BOOL WINAPI 
DllEntryPoint(
    HINSTANCE hinstDLL,
    DWORD     fdwReason,
    LPVOID    lpvReserved
    )
{
    BOOL bRet;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hinstDLL);

        bRet = LibMain((HANDLE)hinstDLL, 0, NULL);
    }
    else
    {
        if (fdwReason == DLL_PROCESS_DETACH)
        {
            DPF(DL_TRACE|FA_ALL, ("Ending") );
            DrvEnd();
        }

        bRet = TRUE;
    }

    return bRet;
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DrvInit | Driver initialization takes place here.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL 
DrvInit(
    )
{
    if (NULL == ghDevice)
    {
        ghDevice = wdmaOpenKernelDevice();

        if(INVALID_HANDLE_VALUE == ghDevice)
        {
            ghDevice = NULL;
            return 0L;
        }
    }

    if(NULL == gpCallbacks)
    {
        if(NULL == (gpCallbacks = wdmaGetCallbacks()))
        {
            gpCallbacks = wdmaCreateCallbacks();
        }
    }

    try
    {
        wdmaudCritSecInit = FALSE;
        InitializeCriticalSection(&wdmaudCritSec);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return 0L;
    }

    wdmaudCritSecInit = TRUE;

    return ( 1L ) ;
}

PCALLBACKS 
wdmaGetCallbacks(
    )
{
    PCALLBACKS pCallbacks = NULL;

    if(NULL == gpCallbacks) 
    {
        ghCallbacks = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE,
                                      FALSE,
                                      gszCallbacks);
        if(NULL != ghCallbacks)
        {
            pCallbacks = MapViewOfFile(ghCallbacks,
                                       FILE_MAP_READ|FILE_MAP_WRITE,
                                       0,
                                       0,
                                       sizeof(CALLBACKS));
            if(NULL == pCallbacks)
            {
                CloseHandle(ghCallbacks);
                ghCallbacks = NULL;
            }
        }
    }
    return (pCallbacks);
}

PCALLBACKS 
wdmaCreateCallbacks(
    )
{
    SECURITY_ATTRIBUTES     saCallbacks;
    PSECURITY_DESCRIPTOR    pSdCallbacks;
    PCALLBACKS              pCallbacks = NULL;

    pSdCallbacks = BuildSecurityDescriptor(FILE_MAP_READ|FILE_MAP_WRITE);

    if(NULL == pSdCallbacks)
    {
        return (NULL);
    }

    saCallbacks.nLength = sizeof(SECURITY_ATTRIBUTES);
    saCallbacks.lpSecurityDescriptor = pSdCallbacks;
    saCallbacks.bInheritHandle = FALSE;

    ghCallbacks = CreateFileMapping(GetCurrentProcess(),
                                    &saCallbacks,
                                    PAGE_READWRITE,
                                    0,
                                    sizeof(CALLBACKS),
                                    gszCallbacks);

    DestroySecurityDescriptor(pSdCallbacks);

    if(NULL == ghCallbacks)
    {
        return (NULL);
    }

    pCallbacks = (PCALLBACKS) MapViewOfFile(ghCallbacks,
                                            FILE_MAP_READ|FILE_MAP_WRITE,
                                            0,
                                            0,
                                            sizeof(CALLBACKS));
    if(NULL == pCallbacks)
    {
        CloseHandle(ghCallbacks);
        ghCallbacks = NULL;
        return (NULL);
    }

    pCallbacks->GlobalIndex = 0;
    return (pCallbacks);
}

/*
This routine is the one that grovels setup API looking for the device
path for wdmaud.sys.  Once it is found, we allocate a global block of memory
to store it in.  When we call CreateFile, we use this string.
*/
LPWSTR 
wdmaGetGlobalDeviceInterfaceViaSetupAPI(
    )
{
    LPWSTR                              pszInterfacePath    = NULL;
    HDEVINFO                            hDeviceInfoSet      = NULL;
    SP_DEVICE_INTERFACE_DATA            DeviceInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDeviceInterfaceDetailData  = NULL;
    BOOL                                fResult;
    DWORD                               dwSize;
    GUID                                guidWDMAUD = KSCATEGORY_WDMAUD;

    //
    //  Because setupapi is such a pig, we must dynaload it in order to keep it from slowing
    //  down all processes.
    //
    if (!Init_SetupAPI())
        return NULL;

    //
    // Open the device information set
    //
    hDeviceInfoSet = dl_SetupDiGetClassDevs(&guidWDMAUD,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);

    if((!hDeviceInfoSet) || (INVALID_HANDLE_VALUE == hDeviceInfoSet))
    {
        DPF(DL_WARNING|FA_SETUP, ("Can't open device info set (%lu)", GetLastError()) );
        fResult = FALSE;
    } else {
        fResult = TRUE;
    }

    if (fResult)
    {
        //
        // Get the first interface in the set
        //
        DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
        fResult = dl_SetupDiEnumDeviceInterfaces(hDeviceInfoSet,
                                                 NULL,
                                                 &guidWDMAUD,
                                                 0,
                                                 &DeviceInterfaceData);
        if(!fResult)
        {
            DPF(DL_WARNING|FA_SETUP, ("No interfaces matching KSCATEGORY_WDMAUD exist") );
        }
    }

    //
    // Get the interface's path
    //
    if (fResult)
    {
        fResult = dl_SetupDiGetDeviceInterfaceDetail(hDeviceInfoSet,
                                                     &DeviceInterfaceData,
                                                     NULL,
                                                     0,
                                                     &dwSize,
                                                     NULL);
        //
        // because SetupApi reverses their logic here
        //
        if(fResult || ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            DPF(DL_WARNING|FA_SETUP, ("Can't get interface detail size (%lu)", GetLastError()));
            fResult = FALSE;
        } else {
            fResult = TRUE;
        }

        if (fResult)
        {
            pDeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) GlobalAllocPtr( GPTR, dwSize );
            if (NULL == pDeviceInterfaceDetailData)
            {
                fResult = FALSE;
            }
        }

        if (fResult)
        {
            pDeviceInterfaceDetailData->cbSize = sizeof(*pDeviceInterfaceDetailData);
            fResult = dl_SetupDiGetDeviceInterfaceDetail(hDeviceInfoSet,
                                                         &DeviceInterfaceData,
                                                         pDeviceInterfaceDetailData,
                                                         dwSize,
                                                         NULL,
                                                         NULL);
            if (!fResult)
            {
                GlobalFreePtr(pDeviceInterfaceDetailData);
                DPF(DL_WARNING|FA_SETUP, ("Can't get device interface detail (%lu)", GetLastError()) );
            }
        }

        if (fResult)
        {
            //
            // Here, we have the Device Interface name.  Let's allocate a block
            // of memory to hold it and save it for later.
            //
            DPFASSERT(NULL == gpszDeviceInterfacePath);
            gpszDeviceInterfacePath = (LPWSTR) GlobalAllocPtr( GPTR, 
                                      sizeof(WCHAR)*(lstrlenW(pDeviceInterfaceDetailData->DevicePath) + 1));
            if (NULL == gpszDeviceInterfacePath)
            {
                fResult = FALSE;
            } else {
                //
                // We now store the device interface name.
                //
                lstrcpyW(gpszDeviceInterfacePath, pDeviceInterfaceDetailData->DevicePath);
            }

            GlobalFreePtr(pDeviceInterfaceDetailData);
        }
    }

    if((hDeviceInfoSet) && (INVALID_HANDLE_VALUE != hDeviceInfoSet))
    {
        dl_SetupDiDestroyDeviceInfoList(hDeviceInfoSet);
    }

    End_SetupAPI();

    return gpszDeviceInterfacePath;
}


/*
We should be able to remove wdmaGetDeviceInterface and call
wdmaGetGlobalDeviceInterfaceViaSetupAPI directly.  wdmaGetDeviceInterface
only gets the cached string.
*/
HANDLE 
wdmaOpenKernelDevice(
    )
{
    HANDLE  hDevice = INVALID_HANDLE_VALUE;

    if( NULL == gpszDeviceInterfacePath )
    {
        wdmaGetGlobalDeviceInterfaceViaSetupAPI();
    }
    if (gpszDeviceInterfacePath)
    {
        // Open the interface
        hDevice = CreateFile(gpszDeviceInterfacePath,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL );

        if((!hDevice) || (INVALID_HANDLE_VALUE == hDevice))
        {
            DPF(DL_WARNING|FA_SETUP, ("CreateFile failed to open %S with error %lu", 
                                      gpszDeviceInterfacePath, GetLastError()) );
        }
    } else {
        DPF(DL_WARNING|FA_SETUP, ("wdmaOpenKernelDevice failed with NULL pathname" ));
    }

    return hDevice;
}

/**************************************************************************

    @doc EXTERNAL

    @api void | DrvEnd | Driver cleanup takes place here.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/
VOID DrvEnd()
{
    if (gpszDeviceInterfacePath)
    {
        GlobalFreePtr(gpszDeviceInterfacePath);
        gpszDeviceInterfacePath = NULL;
    }

    if (NULL != ghDevice)
    {
        CloseHandle(ghDevice);
        ghDevice = NULL;
    }
    if (NULL != gpCallbacks)
    {
        UnmapViewOfFile(gpCallbacks);
        gpCallbacks = NULL;
    }

    if (NULL != ghCallbacks)
    {
        CloseHandle(ghCallbacks);
        ghCallbacks = NULL;
    }

    if (wdmaudCritSecInit)
    {
        wdmaudCritSecInit=FALSE;
        DeleteCriticalSection(&wdmaudCritSec);
    }

    if( NULL != mixercallbackevent )
    {
        DPF(DL_WARNING|FA_ALL,("freeing mixercallbackevent") );
        CloseHandle(mixercallbackevent);
        mixercallbackevent=NULL;
    }

    if( NULL != mixerhardwarecallbackevent )
    {
        DPF(DL_WARNING|FA_ALL,("freeing mixerhardwarecallbackevent") );
        CloseHandle(mixerhardwarecallbackevent);
        mixerhardwarecallbackevent=NULL;
    }

    if( NULL != mixercallbackthread )
    {       
        DPF(DL_WARNING|FA_ALL,("freeing mixercallbackthread") );
        CloseHandle(mixercallbackthread);
        mixercallbackthread=NULL;
    }


    return;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | wdmaudGetDevCaps | This function returns the device capabilities
 *                                 of a WDM driver.
 *
 * @parm DWORD | id | Device id
 *
 * @parm UINT | DeviceType | type of device
 *
 * @parm LPBYTE | lpCaps | Far pointer to a WAVEOUTCAPS structure to
 *      receive the information.
 *
 * @parm DWORD | dwSize | Size of the WAVEOUTCAPS structure.
 *
 * @rdesc MMSYS.. return code
 ***************************************************************************/
MMRESULT FAR wdmaudGetDevCaps
(
    LPDEVICEINFO       DeviceInfo,
    MDEVICECAPSEX FAR* pdc
)
{
    if (pdc->cbSize == 0)
        return MMSYSERR_NOERROR;

    //
    //  Make sure that we don't take the critical section
    //  in wdmaudIoControl
    //
    DeviceInfo->OpenDone = 0;

    //
    //  Inject a tag into the devcaps to signify that it is
    //  Unicode
    //
    ((LPWAVEOUTCAPS)pdc->pCaps)->wMid = UNICODE_TAG;

    return wdmaudIoControl(DeviceInfo,
                           pdc->cbSize,
                           pdc->pCaps,
                           IOCTL_WDMAUD_GET_CAPABILITIES);
}

/**************************************************************************

    @doc EXTERNAL

    @api void | wdmaudIoControl | Proxies requests for information
    to and from wdmaud.sys. This routine is synchronous.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/
/*
    Note:  wdmaudIoControl calls wdmaud.sys through the DeviceIoControl routine.  Take note that if wdmaud.sys
    returns an error, like STATUS_INVALID_PARAMETER or STATUS_INSUFFICIENT_RESOURCES the
    output buffer will not get filled!  DeviceIoControl will only fill that buffer on STATUS_SUCCESS.

    Why is this important to know?  Well, wdmaud.sys takes advantage of this in order to return specific error
    codes.  In other words, in order for wdmaud.sys to return MIXERR_INVALCONTROL it returns
    STATUS_SUCCESS with the mmr value of the DeviceInfo structure set to MIXERR_INVALCONTROL.

*/
MMRESULT FAR wdmaudIoControl
(
    LPDEVICEINFO     DeviceInfo,
    DWORD            dwSize,
    PVOID            pData,
    ULONG            IoCode
)
{
    BOOL        fResult;
    MMRESULT    mmr;
    OVERLAPPED  ov;
    ULONG       cbDeviceInfo;
    ULONG       cbReturned;

    if (NULL == ghDevice)
    {
        MMRRETURN( MMSYSERR_NOTENABLED );
    }

    RtlZeroMemory( &ov, sizeof( OVERLAPPED ) );
    if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ))) 
       MMRRETURN( MMSYSERR_NOMEM );

    //
    //  Only take the critical section if there is an open
    //  wave handle.  This is to ensure that the lpWaveQueue
    //  is not modified during the ioctl.  Without this
    //  protection the copy at the end of the DeviceIoControl
    //  could copy an old DeviceInfo that is not in sync
    //  with the current DeviceInfo.
    //
    if ( (DeviceInfo->DeviceType != MixerDevice) &&
         (DeviceInfo->DeviceType != AuxDevice) &&
         (DeviceInfo->OpenDone == 1) )
        CRITENTER ;

    //
    //  Wrap the data buffer around the device context.
    //
    DeviceInfo->DataBuffer = pData;
    DeviceInfo->DataBufferSize = dwSize;

    //
    //  Since we are not letting the OS do the user-to-kernel
    //  space mapping, we will have to do the mapping ourselves
    //  for writes to data buffers in wdmaud.sys.
    //
    cbDeviceInfo = sizeof(*DeviceInfo) +
                   (lstrlenW(DeviceInfo->wstrDeviceInterface) * sizeof(WCHAR));

    fResult =
       DeviceIoControl( ghDevice,
                        IoCode,
                        DeviceInfo,
                        cbDeviceInfo,
                        DeviceInfo,
                        sizeof(*DeviceInfo),
                        &cbReturned,
                        &ov );
    if (!fResult)
    {
        if (ERROR_IO_PENDING == GetLastError())
        {
            WaitForSingleObject( ov.hEvent, INFINITE );
        }

        mmr = sndTranslateStatus();
    }
    else
    {
        mmr = MMSYSERR_NOERROR;
    }

    if ( (DeviceInfo->DeviceType != MixerDevice) &&
         (DeviceInfo->DeviceType != AuxDevice) &&
         (DeviceInfo->OpenDone == 1) )
        CRITLEAVE ;

    CloseHandle( ov.hEvent );

    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | sndTranslateStatus | This function translates an NT status
 *     code into a multimedia error code as far as possible.
 *
 * @parm NTSTATUS | Status | The NT base operating system return status.
 *
 * @rdesc The multimedia error code.
 ***************************************************************************/
DWORD sndTranslateStatus()
{
#if DBG
    UINT n;
    switch (n=GetLastError()) {
#else
    switch (GetLastError()) {
#endif
    case NO_ERROR:
    case ERROR_IO_PENDING:
        return MMSYSERR_NOERROR;

    case ERROR_BUSY:
        return MMSYSERR_ALLOCATED;

    case ERROR_NOT_SUPPORTED:
    case ERROR_INVALID_FUNCTION:
        return MMSYSERR_NOTSUPPORTED;

    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_NO_SYSTEM_RESOURCES:
        return MMSYSERR_NOMEM;

    case ERROR_ACCESS_DENIED:
        return MMSYSERR_BADDEVICEID;

    case ERROR_INSUFFICIENT_BUFFER:
    case ERROR_INVALID_PARAMETER:
    case ERROR_INVALID_USER_BUFFER:
        return MMSYSERR_INVALPARAM;

    case ERROR_NOT_READY:
    case ERROR_GEN_FAILURE:
        return MMSYSERR_ERROR;

    case ERROR_FILE_NOT_FOUND:
        return MMSYSERR_NODRIVER;

    default:
        DPF(DL_WARNING|FA_DEVICEIO, ("sndTranslateStatus:  LastError = %d", n));
        return MMSYSERR_ERROR;
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudSubmitWaveHeader | Pass a new buffer to the Auxiliary
 *       thread for a wave device.
 *
 * @parm LPWAVEALLOC | DeviceInfo | The data associated with the logical wave
 *     device.
 *
 * @parm LPWAVEHDR | pHdr | Pointer to a wave buffer
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
MMRESULT wdmaudSubmitWaveHeader
(
    LPDEVICEINFO DeviceInfo,
    LPWAVEHDR    pHdr
)
{
    LPDEVICEINFO        WaveHeaderDeviceInfo;
    PWAVEPREPAREDATA    pWavePrepareData;
    ULONG               cbRead;
    ULONG               cbWritten;
    ULONG               cbDeviceInfo;
    BOOL                fResult;
    MMRESULT            mmr;

    if (NULL == ghDevice)
    {
        MMRRETURN( MMSYSERR_NOTENABLED );
    }

    WaveHeaderDeviceInfo = GlobalAllocDeviceInfo(DeviceInfo->wstrDeviceInterface);
    if (!WaveHeaderDeviceInfo)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    //
    //  Catch the case when an application doesn't prepare headers correctly
    //
    if (!pHdr->reserved)
    {
        //
        // This should never happen! wdmaudSubmitWaveHeader is called from 
        // waveWrite which is called from handling the WIDM_ADDBUFFER and 
        // WODM_WRITE messages.  On both of these messages, we check that 
        // the header has been prepared!
        //
        DPF(DL_ERROR|FA_SYNC,("Unprepared header!") );
        GlobalFreeDeviceInfo( WaveHeaderDeviceInfo );
        return MMSYSERR_INVALPARAM;
    }
    //
    //  Free later in the callback routine
    //
    pWavePrepareData      = (PWAVEPREPAREDATA)pHdr->reserved;
    pWavePrepareData->pdi = WaveHeaderDeviceInfo;

    cbDeviceInfo = sizeof(*WaveHeaderDeviceInfo) +
                   (lstrlenW(WaveHeaderDeviceInfo->wstrDeviceInterface) * sizeof(WCHAR));
    //
    //  Fill the wave header's deviceinfo structure
    //
    WaveHeaderDeviceInfo->DeviceType   = DeviceInfo->DeviceType;
    WaveHeaderDeviceInfo->DeviceNumber = DeviceInfo->DeviceNumber;
    WaveHeaderDeviceInfo->DeviceHandle = DeviceInfo->DeviceHandle;
    WaveHeaderDeviceInfo->DataBuffer = pHdr;
    WaveHeaderDeviceInfo->DataBufferSize = sizeof( WAVEHDR );

    if (WaveInDevice == DeviceInfo->DeviceType)
    {
        fResult = DeviceIoControl(ghDevice, IOCTL_WDMAUD_WAVE_IN_READ_PIN,
                                  WaveHeaderDeviceInfo, cbDeviceInfo,
                                  WaveHeaderDeviceInfo, sizeof(*WaveHeaderDeviceInfo),
                                  &cbWritten, pWavePrepareData->pOverlapped);

    }
    else  // WaveOutDevice
    {
        fResult = DeviceIoControl(ghDevice, IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN,
                                  WaveHeaderDeviceInfo, cbDeviceInfo,
                                  WaveHeaderDeviceInfo, sizeof(*WaveHeaderDeviceInfo),
                                  &cbRead, pWavePrepareData->pOverlapped);
    }

    mmr = sndTranslateStatus();

    if (MMSYSERR_NOERROR == mmr)
    {
        mmr = wdmaudCreateCompletionThread ( DeviceInfo );
    }

    return mmr;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | wdmaudSubmitMidiOutHeader | Synchronously process a midi output
 *       buffer.
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
MMRESULT FAR wdmaudSubmitMidiOutHeader
(
    LPDEVICEINFO  DeviceInfo,
    LPMIDIHDR     pHdr
)
{
    BOOL        fResult;
    MMRESULT    mmr;
    OVERLAPPED  ov;
    ULONG       cbReturned;
    ULONG       cbDeviceInfo;

    if (NULL == ghDevice)
    {
        MMRRETURN( MMSYSERR_NOTENABLED );
    }

    RtlZeroMemory( &ov, sizeof( OVERLAPPED ) );
    if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
       return FALSE;

    cbDeviceInfo = sizeof(*DeviceInfo) +
                   (lstrlenW(DeviceInfo->wstrDeviceInterface) * sizeof(WCHAR));
    //
    //  Wrap the data buffer around the device context.
    //
    DeviceInfo->DataBuffer = pHdr;
    DeviceInfo->DataBufferSize = sizeof( MIDIHDR );

    //
    //  Since we are not letting the OS do the user-to-kernel
    //  space mapping, we will have to do the mapping ourselves
    //  for writes to data buffers in wdmaud.sys.
    //
    fResult =
       DeviceIoControl( ghDevice,
                        IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA,
                        DeviceInfo, cbDeviceInfo,
                        DeviceInfo, sizeof(*DeviceInfo),
                        &cbReturned,
                        &ov );
    if (!fResult)
    {
        if (ERROR_IO_PENDING == GetLastError())
        {
            WaitForSingleObject( ov.hEvent, INFINITE );
            mmr = MMSYSERR_NOERROR;
        }
        else
        {
            mmr = sndTranslateStatus();
        }
    }
    else
    {
        mmr = MMSYSERR_NOERROR;
    }

    CloseHandle( ov.hEvent );

    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudGetMidiData | Pass a buffer down to
 *       wdmaud.sys to be filled in with KSMUSICFORMAT data.
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
MMRESULT wdmaudGetMidiData
(
    LPDEVICEINFO        DeviceInfo,
    LPMIDIDATALISTENTRY pOldMidiDataListEntry
)
{
    LPDEVICEINFO        MidiDataDeviceInfo;
    ULONG               cbWritten;
    ULONG               cbDeviceInfo;
    LPMIDIDATALISTENTRY pMidiDataListEntry;
    LPMIDIDATALISTENTRY pTemp;
    MMRESULT            mmr;

    if (NULL == ghDevice)
    {
        MMRRETURN( MMSYSERR_NOTENABLED );
    }

    //
    //  Don't need to allocate another buffer and create another
    //  event if we can reuse the old one
    //
    if (pOldMidiDataListEntry)
    {
        //
        //  Make sure to pull it off the front of the queue
        //  before adding again
        //
        CRITENTER ;
        DeviceInfo->DeviceState->lpMidiDataQueue = DeviceInfo->DeviceState->lpMidiDataQueue->lpNext;
        CRITLEAVE ;

        pMidiDataListEntry = pOldMidiDataListEntry;
//        RtlZeroMemory( &pMidiDataListEntry->MidiData, sizeof(MIDIDATA) );
//        ResetEvent( ((LPOVERLAPPED)(pMidiDataListEntry->pOverlapped))->hEvent );
    }
    else
    {
        //
        //  Allocate a buffer to receive the music data
        //
        pMidiDataListEntry = (LPMIDIDATALISTENTRY) GlobalAllocPtr( GPTR, sizeof(MIDIDATALISTENTRY));
        if (NULL == pMidiDataListEntry)
        {
            MMRRETURN( MMSYSERR_NOMEM );
        }
#ifdef DEBUG
        pMidiDataListEntry->dwSig=MIDIDATALISTENTRY_SIGNATURE;
#endif
        pMidiDataListEntry->MidiDataDeviceInfo = GlobalAllocDeviceInfo(DeviceInfo->wstrDeviceInterface);
        if (!pMidiDataListEntry->MidiDataDeviceInfo)
        {
            GlobalFreePtr(pMidiDataListEntry);
            MMRRETURN( MMSYSERR_NOMEM );
        }

        //
        //  Initialize music data structure
        //
        pMidiDataListEntry->pOverlapped =
           (LPOVERLAPPED)HeapAlloc( GetProcessHeap(), 0, sizeof( OVERLAPPED ));
        if (NULL == pMidiDataListEntry->pOverlapped)
        {
            GlobalFreePtr(pMidiDataListEntry->MidiDataDeviceInfo );
            GlobalFreePtr(pMidiDataListEntry);
            MMRRETURN( MMSYSERR_NOMEM );
        }

        RtlZeroMemory( pMidiDataListEntry->pOverlapped, sizeof( OVERLAPPED ) );

        if (NULL == ( ((LPOVERLAPPED)(pMidiDataListEntry->pOverlapped))->hEvent =
                        CreateEvent( NULL, FALSE, FALSE, NULL )))
        {
           HeapFree( GetProcessHeap(), 0, pMidiDataListEntry->pOverlapped);
           GlobalFreePtr(pMidiDataListEntry->MidiDataDeviceInfo );
           GlobalFreePtr(pMidiDataListEntry);
           MMRRETURN( MMSYSERR_NOMEM );
        }
    }

    //
    //  Cauterize the next pointer for new and old list entries
    //
    pMidiDataListEntry->lpNext = NULL;

    //
    //  Add music data structure to a queue
    //
    CRITENTER ;

    if (!DeviceInfo->DeviceState->lpMidiDataQueue)
    {
        DeviceInfo->DeviceState->lpMidiDataQueue = pMidiDataListEntry;
        pTemp = NULL;
#ifdef UNDER_NT
        if( (DeviceInfo->DeviceState->hevtQueue) &&
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTHREE) &&
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTWO) )
        {
            DPF(DL_TRACE|FA_MIDI,("SetEvent on hevtQueue") );
            SetEvent( DeviceInfo->DeviceState->hevtQueue );
        }
#endif
    }
    else
    {
        for (pTemp = DeviceInfo->DeviceState->lpMidiDataQueue;
             pTemp->lpNext != NULL;
             pTemp = pTemp->lpNext);

        pTemp->lpNext = pMidiDataListEntry;
    }

    CRITLEAVE ;

    DPF(DL_TRACE|FA_MIDI, ("MidiData submitted: pMidiDataListEntry = 0x%08lx", pMidiDataListEntry) );

    MidiDataDeviceInfo = pMidiDataListEntry->MidiDataDeviceInfo;

    cbDeviceInfo = sizeof(*MidiDataDeviceInfo) +
                   (lstrlenW(MidiDataDeviceInfo->wstrDeviceInterface) * sizeof(WCHAR));

    //
    //  Wrap the data buffer around the device context.
    //
    MidiDataDeviceInfo->DeviceType   = DeviceInfo->DeviceType;
    MidiDataDeviceInfo->DeviceNumber = DeviceInfo->DeviceNumber;
    MidiDataDeviceInfo->DataBuffer = &pMidiDataListEntry->MidiData;
    MidiDataDeviceInfo->DataBufferSize = sizeof( MIDIDATA );

    //
    //  Send this buffer down to wdmaud.sys to fill in data
    //
    DeviceIoControl(ghDevice, IOCTL_WDMAUD_MIDI_IN_READ_PIN,
                    MidiDataDeviceInfo, cbDeviceInfo,
                    MidiDataDeviceInfo, sizeof(*MidiDataDeviceInfo),
                    &cbWritten, pMidiDataListEntry->pOverlapped);

    mmr = sndTranslateStatus();

    //
    //  Make sure that the completion thread is running
    //
    if (MMSYSERR_NOERROR == mmr)
    {
        mmr = wdmaudCreateCompletionThread ( DeviceInfo );
    }
    else
    {
        // Unlink...
        CloseHandle( ((LPOVERLAPPED)(pMidiDataListEntry->pOverlapped))->hEvent );
        HeapFree( GetProcessHeap(), 0, pMidiDataListEntry->pOverlapped);
        GlobalFreePtr( MidiDataDeviceInfo );
        GlobalFreePtr( pMidiDataListEntry );

        if (pTemp)
        {
            pTemp->lpNext = NULL;
        }
        else
        {
            DeviceInfo->DeviceState->lpMidiDataQueue = NULL;
        }
    }

    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudCreateCompletionThread |
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 ***************************************************************************/

MMRESULT wdmaudCreateCompletionThread
(
    LPDEVICEINFO DeviceInfo
)
{
    PTHREAD_START_ROUTINE fpThreadRoutine;

    DPFASSERT(DeviceInfo->DeviceType == WaveOutDevice ||
              DeviceInfo->DeviceType == WaveInDevice ||
              DeviceInfo->DeviceType == MidiInDevice);

    //
    //  Thread already created so...forget about it.
    //
    if (DeviceInfo->DeviceState->fThreadRunning)
    {
        ISVALIDDEVICESTATE(DeviceInfo->DeviceState,TRUE);
        return MMSYSERR_NOERROR;
    }

    //
    //  Pick which thread routine we want to create
    //
    if (WaveInDevice == DeviceInfo->DeviceType ||
        WaveOutDevice == DeviceInfo->DeviceType)
    {
        fpThreadRoutine = (PTHREAD_START_ROUTINE)waveThread;
    }
    else if (MidiInDevice == DeviceInfo->DeviceType)
    {
        fpThreadRoutine = (PTHREAD_START_ROUTINE)midThread;
    }
    else
    {
        MMRRETURN( MMSYSERR_ERROR );
    }


    //
    // Is there a problem with hThread?  Well, here is where it gets set
    // to a non-zero value.  Basically, during this creation process, we
    // look to see if there is already a work item scheduled on this thread.  if
    // not, we create one and schedule it.
    //
    // But, between the point where we check this value and the point where it
    // gets set
    //
    if (NULL == DeviceInfo->DeviceState->hThread)
    {
#ifdef DEBUG
        if( (DeviceInfo->DeviceState->hevtQueue != NULL) && 
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTHREE) &&
            (DeviceInfo->DeviceState->hevtQueue != (HANDLE)FOURTYTWO) ) 
        {
            DPF(DL_ERROR|FA_ALL,("hevtQueue getting overwritten! %08X",DeviceInfo) );
        }
#endif
        DeviceInfo->DeviceState->hevtQueue =
            CreateEvent( NULL,      // no security
                         FALSE,     // auto reset
                         FALSE,     // initially not signalled
                         NULL );    // unnamed
#ifdef DEBUG
        if( (DeviceInfo->DeviceState->hevtExitThread != NULL) && 
            (DeviceInfo->DeviceState->hevtExitThread != (HANDLE)FOURTYEIGHT) ) 
        {
            DPF(DL_ERROR|FA_ALL,("hevtExitThread getting overwritten %08X",DeviceInfo) );
        }
#endif
        DeviceInfo->DeviceState->hevtExitThread =
            CreateEvent( NULL,      // no security
                         FALSE,     // auto reset
                         FALSE,     // initially not signalled                         
                         NULL );    // unnamed

        DPFASSERT(NULL == DeviceInfo->DeviceState->hThread);

        DPF(DL_TRACE|FA_SYNC,("Creating Completion Thread") );

        DeviceInfo->DeviceState->hThread =
            CreateThread( NULL,                            // no security
                          0,                               // default stack
                          (PTHREAD_START_ROUTINE) fpThreadRoutine,
                          (PVOID) DeviceInfo,              // parameter
                          0,                               // default create flags
                          &DeviceInfo->DeviceState->dwThreadId );       // container for
                                                           //    thread id

        //
        // TODO: I need to wait for the thread to actually start
        //       before I can move on
        //

        if (DeviceInfo->DeviceState->hThread)
            SetThreadPriority(DeviceInfo->DeviceState->hThread, THREAD_PRIORITY_TIME_CRITICAL);

    }

    if (NULL == DeviceInfo->DeviceState->hThread)
    {
        if (DeviceInfo->DeviceState->hevtQueue)
        {
            CloseHandle( DeviceInfo->DeviceState->hevtQueue );
            DeviceInfo->DeviceState->hevtQueue = NULL;
            CloseHandle( DeviceInfo->DeviceState->hevtExitThread );
            DeviceInfo->DeviceState->hevtExitThread = NULL;
        }
        MMRRETURN( MMSYSERR_ERROR );
    }

    InterlockedExchange( (LPLONG)&DeviceInfo->DeviceState->fThreadRunning, TRUE );

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudDestroyCompletionThread |
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 ***************************************************************************/

MMRESULT wdmaudDestroyCompletionThread
(
    LPDEVICEINFO DeviceInfo
)
{
    MMRESULT mmr;

    if( (mmr=IsValidDeviceInfo(DeviceInfo)) != MMSYSERR_NOERROR )
    {
        MMRRETURN( mmr );
    }

    CRITENTER;
    if( DeviceInfo->DeviceState->hThread ) 
    {
        ISVALIDDEVICESTATE(DeviceInfo->DeviceState,FALSE);
        InterlockedExchange( (LPLONG)&DeviceInfo->DeviceState->fExit, TRUE );
        //
        // If the thread handling the completion notifications, waveThread and 
        // midThread have completed, then hevtQueue will be invalid.  We don't
        // want to call SetEvent with invalid info.  Also, if the thread has
        // completed, then we know that hevtExitThread will have been signaled and
        // fThreadRunning will be FALSE.
        //
        if( DeviceInfo->DeviceState->fThreadRunning )
        {
            ISVALIDDEVICESTATE(DeviceInfo->DeviceState,TRUE);
            SetEvent( DeviceInfo->DeviceState->hevtQueue );
        }

        CRITLEAVE;
        //
        // Ok, here we're going to wait until that routine below, waveThread
        // completes and signals us.
        //
        DPF(DL_TRACE|FA_SYNC, ("DestroyThread: Waiting for thread to go away") );
        WaitForSingleObject( DeviceInfo->DeviceState->hevtExitThread, INFINITE );
        DPF(DL_TRACE|FA_SYNC, ("DestroyThread: Done waiting for thread to go away") );

        CRITENTER;
        CloseHandle( DeviceInfo->DeviceState->hThread );
        DeviceInfo->DeviceState->hThread = NULL;

        CloseHandle( DeviceInfo->DeviceState->hevtExitThread );
        DeviceInfo->DeviceState->hevtExitThread = (HANDLE)FOURTYEIGHT; //NULL;
    } 

    InterlockedExchange( (LPLONG)&DeviceInfo->DeviceState->fExit, FALSE );

    ISVALIDDEVICEINFO(DeviceInfo);
    ISVALIDDEVICESTATE(DeviceInfo->DeviceState,FALSE);
    CRITLEAVE;

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | waveThread |
 *
 ***************************************************************************/

DWORD waveThread
(
    LPDEVICEINFO DeviceInfo
)
{
    BOOL          fDone;
    LPWAVEHDR     pWaveHdr;
    MMRESULT      mmr;

    //
    // Keep looping until all notifications are posted...
    //
    fDone = FALSE;
    while (!fDone ) 
    {
        fDone = FALSE;
        CRITENTER ;

        ISVALIDDEVICEINFO(DeviceInfo);
        ISVALIDDEVICESTATE(DeviceInfo->DeviceState,TRUE);

        if(pWaveHdr = DeviceInfo->DeviceState->lpWaveQueue) 
        {
            PWAVEPREPAREDATA pWavePrepareData;
            HANDLE hEvent;

            if( (mmr=IsValidWaveHeader(pWaveHdr)) == MMSYSERR_NOERROR )
            {
                pWavePrepareData = (PWAVEPREPAREDATA)pWaveHdr->reserved;

                if( (mmr=IsValidPrepareWaveHeader(pWavePrepareData)) == MMSYSERR_NOERROR )
                {
                    hEvent = pWavePrepareData->pOverlapped->hEvent;

                    CRITLEAVE ;
                    WaitForSingleObject( hEvent, INFINITE );
                    CRITENTER ;

                    //
                    // Validate that our data is still intact
                    //
                    if( ( (mmr=IsValidDeviceInfo(DeviceInfo)) ==MMSYSERR_NOERROR ) &&
                        ( (mmr=IsValidDeviceState(DeviceInfo->DeviceState,TRUE)) == MMSYSERR_NOERROR ) )
                    {
                        DPF(DL_TRACE|FA_WAVE, ("Calling waveCompleteHeader") );

                        waveCompleteHeader(DeviceInfo);
                    } else {
                        //
                        // Problem: Major structures have changed.  How can we complete
                        // this header?  The only thing I can think of here is to
                        // terminate the thread.
                        //
                        goto Terminate_waveThread;
                    }
                } else {
                    //
                    // Problem: reserved field that contains the Prepare data info
                    // is corrupt, thus we will not have a valid hEvent to wait on.  
                    // remove this header and go on to the next.
                    //
                    DeviceInfo->DeviceState->lpWaveQueue = DeviceInfo->DeviceState->lpWaveQueue->lpNext;
                }
            } else {
                //
                // Problem: Our header is corrupt.  We can't possibly wait on this
                // because we'll never get signaled! thus we will not have a valid 
                // hEvent to wait on. Remove this header and go on to the next.
                //
                DeviceInfo->DeviceState->lpWaveQueue = DeviceInfo->DeviceState->lpWaveQueue->lpNext;
            }
            CRITLEAVE ;
        }
        else
        {
//            fDone = TRUE;

            if (DeviceInfo->DeviceState->fRunning)
            {
                wdmaudIoControl(DeviceInfo,
                                0,
                                NULL,
                                DeviceInfo->DeviceType == WaveOutDevice ?
                                IOCTL_WDMAUD_WAVE_OUT_PAUSE :
                                IOCTL_WDMAUD_WAVE_IN_STOP);
                InterlockedExchange( (LPLONG)&DeviceInfo->DeviceState->fRunning, FALSE );
            }

            CRITLEAVE ;

            WaitForSingleObject( DeviceInfo->DeviceState->hevtQueue, INFINITE );

            //
            // We could have been here for two reasons 1) the thread got starved
            // ie. the header list went empty or 2) we're done with the headers.
            // Only when we're done do we really want to exit this thread.
            //
            if( DeviceInfo->DeviceState->fExit )
            {
                fDone = TRUE;
            }
        }
    }

    CRITENTER;
    ISVALIDDEVICEINFO(DeviceInfo);
    ISVALIDDEVICESTATE(DeviceInfo->DeviceState,TRUE);

    CloseHandle( DeviceInfo->DeviceState->hevtQueue );
    DeviceInfo->DeviceState->hevtQueue = (HANDLE)FOURTYTWO; // WAS NULL
    InterlockedExchange( (LPLONG)&DeviceInfo->DeviceState->fThreadRunning, FALSE );
    SetEvent( DeviceInfo->DeviceState->hevtExitThread );

    DPF(DL_TRACE|FA_WAVE, ("waveThread: Closing") );

Terminate_waveThread:
    CRITLEAVE;
    return 0;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midThread |
 *
 ***************************************************************************/

DWORD midThread
(
    LPDEVICEINFO DeviceInfo
)
{
    BOOL                fDone;
    LPMIDIDATALISTENTRY pMidiDataListEntry;
    int                 i;
    MMRESULT            mmr;

    DPF(DL_TRACE|FA_MIDI, ("Entering") );

    //
    // Keep looping until all notifications are posted...
    //
    fDone = FALSE;
    while (!fDone)
    {
        CRITENTER ;

        ISVALIDDEVICEINFO(DeviceInfo);
        ISVALIDDEVICESTATE(DeviceInfo->DeviceState,TRUE);

        if (pMidiDataListEntry = DeviceInfo->DeviceState->lpMidiDataQueue)
        {
            HANDLE hEvent;

            if( (mmr=IsValidMidiDataListEntry(pMidiDataListEntry)) == MMSYSERR_NOERROR)
            {
                hEvent = ((LPOVERLAPPED)(pMidiDataListEntry->pOverlapped))->hEvent;

                DPF(DL_TRACE|FA_MIDI, ("Waiting on pMidiDataListEntry = 0x%08lx", pMidiDataListEntry) );

                CRITLEAVE ;
                WaitForSingleObject( hEvent, INFINITE );
                CRITENTER ;

                DPF(DL_TRACE|FA_MIDI, ("Completed pMidiDataListEntry = 0x%08lx", pMidiDataListEntry) );

                if( ((mmr=IsValidDeviceInfo(DeviceInfo)) == MMSYSERR_NOERROR) &&
                    ((mmr=IsValidDeviceState(DeviceInfo->DeviceState,TRUE)) == MMSYSERR_NOERROR ) )
                {
                    //
                    //  Parse and callback clients
                    //
                    wdmaudParseMidiData(DeviceInfo, pMidiDataListEntry);

                    if (DeviceInfo->DeviceState->fExit ||
                        !DeviceInfo->DeviceState->fRunning)
                    {
                        //
                        //  Unlink from queue and free memory
                        //
                        wdmaudFreeMidiData(DeviceInfo, pMidiDataListEntry);
                    }
                    else
                    {
                        //
                        //  Reuse this buffer to read Midi data
                        //
                        wdmaudGetMidiData(DeviceInfo, pMidiDataListEntry);
                    }
                } else {
                    //
                    // Problem:  Our major structure is bad.  There is nothing that
                    // we can do, exit and hope for the best.
                    //
                    goto Terminate_midThread;
                }
            } else {
                //
                // Problem: the pMidiDataListEntry is invalid.  We can't use it
                // so we simply move on to the next one and hope for the best.
                //
                DeviceInfo->DeviceState->lpMidiDataQueue = DeviceInfo->DeviceState->lpMidiDataQueue->lpNext;
            }
            CRITLEAVE ;
        }
        else
        {

            fDone = TRUE;

            CRITLEAVE ;

            DPF(DL_TRACE|FA_MIDI, ("Waiting for signal to kill thread") );
            WaitForSingleObject( DeviceInfo->DeviceState->hevtQueue, INFINITE );
            DPF(DL_TRACE|FA_MIDI, ("Done waiting for signal to kill thread") );
        }
    }

    CRITENTER;
    ISVALIDDEVICEINFO(DeviceInfo);
    ISVALIDDEVICESTATE(DeviceInfo->DeviceState,TRUE);

    CloseHandle( DeviceInfo->DeviceState->hevtQueue );
    DeviceInfo->DeviceState->hevtQueue = (HANDLE)FOURTYTHREE; //NULL;
    InterlockedExchange( (LPLONG)&DeviceInfo->DeviceState->fThreadRunning, FALSE );
    SetEvent( DeviceInfo->DeviceState->hevtExitThread );

    DPF(DL_TRACE|FA_MIDI, ("Closing") );

Terminate_midThread:
    CRITLEAVE;
    return 0;
}

BOOL IsMidiDataDiscontinuous
(
    PKSSTREAM_HEADER    pHeader
)
{
    DPFASSERT(pHeader);

    //
    //  Check the OptionFlags for the end of the midi stream
    //
    return (pHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY);
}

ULONG GetStreamHeaderSize
(
    PKSSTREAM_HEADER    pHeader
)
{
    DPFASSERT(pHeader);

    //
    //  Check the OptionFlags for the end of the midi stream
    //
    return (pHeader->DataUsed);
}

BOOL IsSysExData
(
    LPBYTE      MusicData
)
{
    DPFASSERT(MusicData);

    return ( IS_SYSEX(*MusicData) ||
             IS_EOX(*MusicData)   ||
             IS_DATA_BYTE(*MusicData) );
}

BOOL IsEndofSysEx
(
    LPBYTE      MusicData
)
{
    DPFASSERT(MusicData);

    return IS_EOX(*(MusicData));
}

void wdmaudParseSysExData
(
    LPDEVICEINFO    DeviceInfo,
    LPMIDIDATA      pMidiData,
    BOOL            MidiDataDiscontinuous
)
{
    BOOL            fCompleteSysEx = FALSE;
    LPMIDIHDR       pMidiInHdr;
    PKSMUSICFORMAT  MusicFormat;
    ULONG           MusicDataLeft;
    LPBYTE          MusicData;
    ULONG           RunningTimeMs;
    ULONG           DataCopySize;
    ULONG           HeaderFreeSpace;
    ULONG           MusicFormatDataLeft;
    ULONG           MusicFormatDataPosition = 0;

    //
    //  Easier to use locals
    //
    MusicFormat     = (PKSMUSICFORMAT)&pMidiData->MusicFormat;
    MusicData       = (LPBYTE)pMidiData->MusicData;
    MusicDataLeft   = pMidiData->StreamHeader.DataUsed;
    RunningTimeMs   = 0;

    if ( MidiDataDiscontinuous ||
         IsEndofSysEx(MusicData + MusicFormat->ByteCount - 1) )
    {
        fCompleteSysEx = TRUE;
    }

    while (MusicDataLeft || MidiDataDiscontinuous)
    {
        //
        //  update the running time for this Music Format header
        //
        if (MusicFormat->ByteCount == 0)
        {
            RunningTimeMs = DeviceInfo->DeviceState->LastTimeMs;
        }
        else
        {
            RunningTimeMs += MusicFormat->TimeDeltaMs;
            DeviceInfo->DeviceState->LastTimeMs = RunningTimeMs;
        }

        //
        //  Get the next header from the queue
        //
        pMidiInHdr = DeviceInfo->DeviceState->lpMidiInQueue;

        while (pMidiInHdr &&
               MusicFormatDataPosition <= MusicFormat->ByteCount)
        {

            HeaderFreeSpace = pMidiInHdr->dwBufferLength -
                              pMidiInHdr->dwBytesRecorded;

            MusicFormatDataLeft = MusicFormat->ByteCount -
                                  MusicFormatDataPosition;

            //
            // Compute the size of the copy
            //
            DataCopySize = min(HeaderFreeSpace,MusicFormatDataLeft);

            //
            // Fill this, baby
            //
            if (DataCopySize)
            {
                RtlCopyMemory(pMidiInHdr->lpData + pMidiInHdr->dwBytesRecorded,
                              MusicData + MusicFormatDataPosition,
                              DataCopySize);
            }

            //
            // update the number of bytes recorded
            //
            pMidiInHdr->dwBytesRecorded += DataCopySize;
            MusicFormatDataPosition += DataCopySize;

            DPF(DL_TRACE|FA_RECORD, ("Record SysEx: %d(%d) Data=0x%08lx",
                DataCopySize,
                pMidiInHdr->dwBytesRecorded,
                *MusicData) );

            //
            //  If the buffer is full or end-of-sysex byte is received,
            //  the buffer is marked as 'done' and it's owner is called back.
            //
            if ( (fCompleteSysEx && pMidiInHdr->dwBytesRecorded && (MusicFormatDataPosition == MusicFormat->ByteCount) ) // copied whole SysEx
                 || (pMidiInHdr->dwBufferLength == pMidiInHdr->dwBytesRecorded) ) // filled entire buffer
            {

                if (MidiDataDiscontinuous)
                {
                    midiInCompleteHeader(DeviceInfo,
                                         RunningTimeMs,
                                         MIM_LONGERROR);
                }
                else
                {
                    midiInCompleteHeader(DeviceInfo,
                                         RunningTimeMs,
                                         MIM_LONGDATA);
                }

                //
                //  Grab the next header to fill, if it exists
                //
                pMidiInHdr = DeviceInfo->DeviceState->lpMidiInQueue;
            }

            //
            // Break out of loop when all of the data is copied
            //
            if (MusicFormatDataPosition == MusicFormat->ByteCount)
            {
                break;
            }

            //
            // in the middle of a sysex and we still
            // have room left in the header
            //

        } // while we have more headers and data to copy

        //
        //  don't continue messin' with this irp
        //
        if (MidiDataDiscontinuous)
        {
            break;
        }

        MusicDataLeft -= sizeof(KSMUSICFORMAT) + ((MusicFormat->ByteCount + 3) & ~3);
        MusicFormat    = (PKSMUSICFORMAT)(MusicData + ((MusicFormat->ByteCount + 3) & ~3));
        MusicData      = (LPBYTE)(MusicFormat + 1);

    } // while IrpDataLeft

    return;
}

void wdmaudParseShortMidiData
(
    LPDEVICEINFO    DeviceInfo,
    LPMIDIDATA      pMidiData,
    BOOL            MidiDataDiscontinuous
)
{
    BOOL            fCompleteSysEx = FALSE;
    LPMIDIHDR       pMidiInHdr;
    PKSMUSICFORMAT  MusicFormat;
    ULONG           MusicDataLeft;
    LPBYTE          MusicData;
    ULONG           RunningTimeMs;
    ULONG           DataCopySize;
    ULONG           HeaderFreeSpace;
    ULONG           MusicFormatDataLeft;
    ULONG           MusicFormatDataPosition = 0;

    //
    //  Easier to use locals
    //
    MusicFormat     = (PKSMUSICFORMAT)&pMidiData->MusicFormat;
    MusicData       = (LPBYTE)pMidiData->MusicData;
    MusicDataLeft   = pMidiData->StreamHeader.DataUsed;
    RunningTimeMs   = 0;

    while (MusicDataLeft || MidiDataDiscontinuous)
    {
        //
        //  update the running time for this Music Format header
        //
        if (MusicFormat->ByteCount == 0)
        {
            RunningTimeMs = DeviceInfo->DeviceState->LastTimeMs;
        }
        else
        {
            RunningTimeMs += MusicFormat->TimeDeltaMs;
            DeviceInfo->DeviceState->LastTimeMs = RunningTimeMs;
        }

        //
        //  Non-used bytes should be zero'ed out
        //
        midiCallback(DeviceInfo,
                     MIM_DATA,
                     *((LPDWORD)MusicData),
                     RunningTimeMs);

        //
        //  don't continue messin' with this irp
        //
        if (MidiDataDiscontinuous)
        {
            break;
        }

        MusicDataLeft -= sizeof(KSMUSICFORMAT) + ((MusicFormat->ByteCount + 3) & ~3);
        MusicFormat    = (PKSMUSICFORMAT)(MusicData + ((MusicFormat->ByteCount + 3) & ~3));
        MusicData      = (LPBYTE)(MusicFormat + 1);

    } // while IrpDataLeft

    return;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | wdmaudParseMidiData | This routine takes the MIDI data retrieved
 *     from kernel mode and calls back the application with the long or short
 *     messages packed in the buffer.
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical midi
 *     device.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ****************************************************************************/
void wdmaudParseMidiData
(
    LPDEVICEINFO            DeviceInfo,
    LPMIDIDATALISTENTRY     pMidiDataListEntry
)
{
    BOOL     MidiDataDiscontinuous;
    ULONG    DataRemaining;
    ULONG    BytesUsed;
    MMRESULT mmr;

    if( (mmr=IsValidMidiDataListEntry(pMidiDataListEntry)) == MMSYSERR_NOERROR )
    {
        DataRemaining = GetStreamHeaderSize(&pMidiDataListEntry->MidiData.StreamHeader);

        MidiDataDiscontinuous = IsMidiDataDiscontinuous(&pMidiDataListEntry->MidiData.StreamHeader);

        if ( IsSysExData((LPBYTE)pMidiDataListEntry->MidiData.MusicData) )
        {
            wdmaudParseSysExData(DeviceInfo,
                                 &pMidiDataListEntry->MidiData,
                                 MidiDataDiscontinuous);
        }
        else
        {
            // Must be short messages
            wdmaudParseShortMidiData(DeviceInfo,
                                     &pMidiDataListEntry->MidiData,
                                     MidiDataDiscontinuous);
        }
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | wdmaudFreeMidiData | This routine unlinks and free the MIDI
 *     data structure pointed to on input.
 *
 * @parm LPDEVICEINFO | DeviceInfo | The data associated with the logical midi
 *     device.
 *
 * @parm LPMIDIDATA | pMidiData | The data buffer to be cleaned up
 *
 ****************************************************************************/
void wdmaudFreeMidiData
(
    LPDEVICEINFO            DeviceInfo,
    LPMIDIDATALISTENTRY     pMidiDataListEntry
)
{
    //
    //  Advance the head of the queue
    //
    DeviceInfo->DeviceState->lpMidiDataQueue = DeviceInfo->DeviceState->lpMidiDataQueue->lpNext;

    //
    //  Free all associated data members
    //
    CloseHandle( ((LPOVERLAPPED)(pMidiDataListEntry->pOverlapped))->hEvent );
    HeapFree( GetProcessHeap(), 0, pMidiDataListEntry->pOverlapped );
    GlobalFreeDeviceInfo( pMidiDataListEntry->MidiDataDeviceInfo );
    GlobalFreePtr( pMidiDataListEntry );

}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudFreeMidiQ |
 *
 ***************************************************************************/
MMRESULT wdmaudFreeMidiQ
(
    LPDEVICEINFO  DeviceInfo
)
{
    LPMIDIHDR  pHdr;
    LPMIDIHDR  pTemp;


    DPF(DL_TRACE|FA_MIDI, ("entering") );

    CRITENTER ;

    //
    //  Grab the head of the MIDI In queue and iterate through
    //  completing the headers
    //
    pHdr = DeviceInfo->DeviceState->lpMidiInQueue;

    DeviceInfo->DeviceState->lpMidiInQueue = NULL ;   // mark the queue as empty

    while (pHdr)
    {
        pTemp = pHdr->lpNext;

        pHdr->dwFlags &= ~MHDR_INQUEUE ;
        pHdr->dwFlags |= MHDR_DONE ;
        pHdr->dwBytesRecorded = 0;

        //
        // Invoke the callback function
        //
        midiCallback(DeviceInfo,
                     MIM_LONGDATA,
                     (DWORD_PTR)pHdr,
                     DeviceInfo->DeviceState->LastTimeMs);  // NOTE: This is not precise, but there is no way to
                                                            // know what the kernel time is without defining
                                                            // a new interface just for this.
        pHdr = pTemp;
    }

    CRITLEAVE ;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.drv\wdmaud.c ===
/****************************************************************************
 *
 *   wdmaud.c
 *
 *   WDM Audio mapper
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include <stdarg.h>
#include "wdmdrv.h"

LPDEVICEINFO pWaveDeviceList = NULL;
LPDEVICEINFO pMidiDeviceList = NULL;

#ifdef DEBUG
INT giAllocs=0;
INT giFrees=0;
#endif

//--------------------------------------------------------------------------
// LPDEVICEINFO GlobalAllocDeviceInfo
//
// Note: when allocating DeviceInfo structure, we know that the structure's
// definition includes one character for the DeviceInterface, so we only need
// to allocate additional length for the string but not its NULL terminator
//--------------------------------------------------------------------------
LPDEVICEINFO GlobalAllocDeviceInfo(LPCWSTR DeviceInterface)
{
    LPDEVICEINFO DeviceInfo;

    IsValidDeviceInterface(DeviceInterface);

    DeviceInfo = GlobalAllocPtr(GPTR, sizeof(*DeviceInfo)+(sizeof(WCHAR)*lstrlenW(DeviceInterface)));
    if (DeviceInfo) {
        lstrcpyW(DeviceInfo->wstrDeviceInterface, DeviceInterface);
#ifdef DEBUG
        DeviceInfo->dwSig=DEVICEINFO_SIGNATURE;
#endif
    }
    DPF(DL_TRACE|FA_ALL,("Allocated DI=%08X, giAllocs=%d, giFrees=%d",
                         DeviceInfo,++giAllocs,giFrees) );

    return DeviceInfo;
}

VOID GlobalFreeDeviceInfo(LPDEVICEINFO lpdi)
{
    //
    // Now free the deviceinfo structure.
    //
    if( lpdi )
    {
#ifdef DEBUG
        giFrees++;
        // remove the signature from the block.
        lpdi->dwSig=0;
#endif
        GlobalFreePtr( lpdi );
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudOpenDev | Open the kernel driver device corresponding
 *       to a logical wave device id
 *
 * @parm UINT | DeviceType | The type of device
 *
 * @parm DWORD | dwId | The device id
 *
 * @comm For our sound devices the only relevant access are read and
 *    read/write.  Device should ALWAYS allow opens for read unless some
 *    resource or access-rights restriction occurs.
 ***************************************************************************/
MMRESULT wdmaudOpenDev
(
    LPDEVICEINFO    DeviceInfo,
    LPWAVEFORMATEX  lpWaveFormat
)
{
    MMRESULT mmr;
    UINT     cbSize;

    DPFASSERT(DeviceInfo->DeviceType == WaveOutDevice ||
              DeviceInfo->DeviceType == WaveInDevice ||
              DeviceInfo->DeviceType == MidiOutDevice ||
              DeviceInfo->DeviceType == MidiInDevice ||
              DeviceInfo->DeviceType == MixerDevice);

    //
    // Check it's not out of range
    //
    if (DeviceInfo->DeviceNumber > WDMAUD_MAX_DEVICES)
    {
        MMRRETURN( MMSYSERR_BADDEVICEID );
    }


    if (NULL != lpWaveFormat)
    {
        if (WAVE_FORMAT_PCM == lpWaveFormat->wFormatTag)
        {
            cbSize = sizeof(PCMWAVEFORMAT);
        }
        else
        {
            //
            //  because MMSYSTEM does not (currently) validate for the extended
            //  format information, we validate this pointer
            //
            cbSize = sizeof(WAVEFORMATEX) + lpWaveFormat->cbSize;
            if (IsBadReadPtr(lpWaveFormat, cbSize))
            {
                MMRRETURN( MMSYSERR_INVALPARAM );
            }
        }

        //
        //  Store this for positional information
        //
        DeviceInfo->DeviceState->cSampleBits = lpWaveFormat->nChannels * lpWaveFormat->wBitsPerSample;

    }
    else
    {
        cbSize = 0L;
    }

    mmr = wdmaudIoControl(DeviceInfo,
                          cbSize,
                          lpWaveFormat,
                          IOCTL_WDMAUD_OPEN_PIN);

    //
    // Return status to caller
    //
    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudCloseDev | Close the kernel driver device corresponding
 *       to a logical device id
 *
 * @parm UINT | DeviceType | The type of device
 *
 * @parm DWORD | dwId | The device id
 *
 * @comm For our sound devices the only relevant access are read and
 *    read/write.  Device should ALWAYS allow opens for read unless some
 *    resource or access-rights restriction occurs.
 ***************************************************************************/
MMRESULT FAR wdmaudCloseDev
(
    LPDEVICEINFO DeviceInfo
)
{
    MMRESULT mmr;

    DPFASSERT(DeviceInfo->DeviceType == WaveOutDevice ||
              DeviceInfo->DeviceType == WaveInDevice  ||
              DeviceInfo->DeviceType == MidiOutDevice ||
              DeviceInfo->DeviceType == MidiInDevice  ||
              DeviceInfo->DeviceType == MixerDevice);

    //
    // Check it's not out of range
    //
    if (DeviceInfo->DeviceNumber > WDMAUD_MAX_DEVICES)
    {
        MMRRETURN( MMSYSERR_BADDEVICEID );
    }

    if (WaveOutDevice == DeviceInfo->DeviceType ||
        WaveInDevice == DeviceInfo->DeviceType)
    {
        if (DeviceInfo->DeviceState->lpWaveQueue)
        {
            return WAVERR_STILLPLAYING;
        }
        //
        // Wait for the thread to be destroyed.
        //
        mmr = wdmaudDestroyCompletionThread(DeviceInfo);
        if (MMSYSERR_NOERROR != mmr)
        {
            MMRRETURN( mmr );
        }
    }
    else if (MidiInDevice == DeviceInfo->DeviceType)
    {
        if (DeviceInfo->DeviceState->lpMidiInQueue)
        {
            DPF(DL_WARNING|FA_MIDI,("Error closing midi device") );
            return MIDIERR_STILLPLAYING;
        }

        InterlockedExchange( (LPLONG)&DeviceInfo->DeviceState->fExit, TRUE );
    }
    mmr = wdmaudIoControl(DeviceInfo,
                          0,
                          NULL,
                          IOCTL_WDMAUD_CLOSE_PIN);

    //
    // Return status to caller
    //
    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | wdmaudGetNumDevs | This function returns the number of (kernel)
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @parm LPCWSTR | DeviceInterface | Pointer to a buffer containing the
 *      device interface name of the SysAudio device for which we should
 *      obtain the count of device of the type DeviceType
 *
 * @rdesc The number of devices.
 ***************************************************************************/

DWORD FAR wdmaudGetNumDevs
(
    UINT    DeviceType,
    LPCWSTR DeviceInterface
)
{
    LPDEVICEINFO DeviceInfo;
    DWORD        NumDevs;
    MMRESULT     mmr;

    DPFASSERT(DeviceType == WaveOutDevice ||
              DeviceType == WaveInDevice  ||
              DeviceType == MidiOutDevice ||
              DeviceType == MidiInDevice  ||
              DeviceType == MixerDevice ||
              DeviceType == AuxDevice);

    DeviceInfo = GlobalAllocDeviceInfo(DeviceInterface);
    if (NULL == DeviceInfo)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    //
    // Call wdmaud.sys to get the number of devices for each
    // type of function.
    //
    DeviceInfo->DeviceType   = DeviceType;

    //
    //  Make sure that we don't take the critical section
    //  in wdmaudIoControl (NT only)
    //
    DeviceInfo->OpenDone = 0;

    mmr = wdmaudIoControl(DeviceInfo,
                          0L,
                          NULL,
                          IOCTL_WDMAUD_GET_NUM_DEVS);
#ifdef DEBUG
    if( mmr != MMSYSERR_NOERROR) 
        DPF(DL_WARNING|FA_DEVICEIO, (szReturningErrorStr,mmr,MsgToAscii(mmr)) );
#endif
    NumDevs = DeviceInfo->DeviceNumber;
    GlobalFreeDeviceInfo( DeviceInfo );

    //
    // DeviceNumber is overloaded so we don't have to map
    // an address into kernel mode
    //

    return MAKELONG(NumDevs, mmr);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | wdmaudDrvExit | This function indicates DevNode removal
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @parm LPCWSTR | DeviceInterface | Pointer to a buffer containing the
 *      device interface name of the SysAudio device that we are adding
 *      or removing
 *
 * @rdesc The number of devices.
 ***************************************************************************/

DWORD FAR wdmaudAddRemoveDevNode
(
    UINT    DeviceType,
    LPCWSTR DeviceInterface,
    BOOL    fAdd
)
{
    LPDEVICEINFO DeviceInfo;
    MMRESULT     mmr;

    DPFASSERT(DeviceType == WaveOutDevice ||
              DeviceType == WaveInDevice  ||
              DeviceType == MidiOutDevice ||
              DeviceType == MidiInDevice  ||
              DeviceType == MixerDevice ||
              DeviceType == AuxDevice);

    DeviceInfo = GlobalAllocDeviceInfo(DeviceInterface);
    if (NULL == DeviceInfo)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    //
    // Call wdmaud.sys to get the number of devices for each
    // type of function.
    //
    DeviceInfo->DeviceType = DeviceType;
    mmr = wdmaudIoControl(DeviceInfo,
                          0L,
                          NULL,
                          fAdd ?
                          IOCTL_WDMAUD_ADD_DEVNODE :
                          IOCTL_WDMAUD_REMOVE_DEVNODE);

    GlobalFreeDeviceInfo( DeviceInfo );

    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | wdmaudSetPreferredDevice | sets the preferred evice
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @parm LPCWSTR | DeviceInterface | Pointer to a buffer containing the
 *      device interface name of the SysAudio device that we are adding
 *      or removing
 *
 * @rdesc The number of devices.
 ***************************************************************************/

DWORD FAR wdmaudSetPreferredDevice
(
    UINT    DeviceType,
    UINT    DeviceNumber,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    LPDEVICEINFO DeviceInfo;
    MMRESULT     mmr;

    DPFASSERT(DeviceType == WaveOutDevice ||
              DeviceType == WaveInDevice  ||
              DeviceType == MidiOutDevice ||
              DeviceType == MidiInDevice  ||
              DeviceType == MixerDevice ||
              DeviceType == AuxDevice);

    DeviceInfo = GlobalAllocDeviceInfo((LPCWSTR)dwParam2);
    if (NULL == DeviceInfo)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    DeviceInfo->DeviceType = DeviceType;
    DeviceInfo->DeviceNumber = DeviceNumber;
    DeviceInfo->dwFlags = (DWORD) dwParam1;

    mmr = wdmaudIoControl(DeviceInfo,
                          0L,
                          NULL,
                          IOCTL_WDMAUD_SET_PREFERRED_DEVICE);
    GlobalFreeDeviceInfo( DeviceInfo );

    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudSetDeviceState |
 *
 * @parm DWORD | DeviceType | The Device type
 *
 * @parm ULONG | State | The state to set the device to
 *
 * @rdesc MMSYS.. return code
 ***************************************************************************/
MMRESULT wdmaudSetDeviceState
(
    LPDEVICEINFO     DeviceInfo,
    ULONG            State
)
{
    MMRESULT mmr;
    ULONG    BufferCount;

    if( ( (mmr=IsValidDeviceInfo(DeviceInfo)) != MMSYSERR_NOERROR ) ||
        ( (mmr=IsValidDeviceState(DeviceInfo->DeviceState,FALSE)) != MMSYSERR_NOERROR ) )
    {
        MMRRETURN( mmr );
    }

    if (IOCTL_WDMAUD_WAVE_OUT_PLAY    == State ||
        IOCTL_WDMAUD_WAVE_IN_RECORD   == State ||
        IOCTL_WDMAUD_MIDI_IN_RECORD   == State )
    {
        //
        // We need to create a thread here on NT because we need
        // to get notified when our IO requests complete.  This
        // requires another thread of execution to be able to
        // process the completed IO.
        //
        mmr = wdmaudCreateCompletionThread ( DeviceInfo );
        if (MMSYSERR_NOERROR != mmr)
        {
            MMRRETURN( mmr );
        }
        DeviceInfo->DeviceState->fRunning = TRUE;

        IsValidDeviceState(DeviceInfo->DeviceState,TRUE);
    }

    if (IOCTL_WDMAUD_MIDI_IN_RESET == State ||
        IOCTL_WDMAUD_MIDI_IN_STOP == State)
    {
        CRITENTER;
        if (DeviceInfo->DeviceState->fRunning)
        {
            DeviceInfo->DeviceState->fRunning = FALSE;
            CRITLEAVE;
        }
        else
        {
            CRITLEAVE;
            if (IOCTL_WDMAUD_MIDI_IN_RESET == State)
            {
                return( wdmaudFreeMidiQ( DeviceInfo ) );
            }
            else
            {
                MMRRETURN( MMSYSERR_NOERROR );
            }
        }
    }

    //
    //  Call the device to set the state.  Note that some calls will wait in
    // kernel mode for events to complete.  Thus, this thread may be pre-empted
    // and the waveThread or midThread routines will completely finish and unload
    // by the time we come back.  Thus, the calls to wdmaudDestroyCompletionThread
    // will be no-ops.
    //
    DPF(DL_TRACE|FA_SYNC,("Setting state=%08X",State) );
    mmr = wdmaudIoControl(DeviceInfo,
                          0,
                          NULL,
                          State);
    DPF(DL_TRACE|FA_SYNC,("Done Setting state mmr=%08X",mmr) );

    if (MMSYSERR_NOERROR == mmr)
    {
        if ((IOCTL_WDMAUD_WAVE_OUT_PAUSE == State) ||
            (IOCTL_WDMAUD_WAVE_IN_STOP == State) ||
            (IOCTL_WDMAUD_WAVE_IN_RESET == State) )
        {
            DeviceInfo->DeviceState->fPaused = TRUE;
        }

        if ((IOCTL_WDMAUD_WAVE_OUT_PLAY == State) ||
            (IOCTL_WDMAUD_WAVE_OUT_RESET == State) ||
            (IOCTL_WDMAUD_WAVE_IN_RECORD == State) )
        {
            DeviceInfo->DeviceState->fPaused = FALSE;
        }
    }
    else
    {
        DPF(DL_WARNING|FA_ALL,("Error Setting State: mmr = %d", mmr ) );
    }

    if (IOCTL_WDMAUD_WAVE_OUT_RESET == State ||
        IOCTL_WDMAUD_WAVE_IN_RESET  == State)
    {
        DeviceInfo->DeviceState->fRunning = FALSE;

        //
        // Wait for all of the pending IO to come back from the
        // reset operation.
        //
        mmr = wdmaudDestroyCompletionThread ( DeviceInfo );
    }

    if (IOCTL_WDMAUD_MIDI_IN_RESET == State)
    {
        mmr = wdmaudDestroyCompletionThread ( DeviceInfo );
        if (MMSYSERR_NOERROR == mmr)
        {
            mmr = wdmaudFreeMidiQ( DeviceInfo );

            for (BufferCount = 0; BufferCount < STREAM_BUFFERS; BufferCount++)
            {
                wdmaudGetMidiData( DeviceInfo, NULL );
            }
        }
    }
    else if (IOCTL_WDMAUD_MIDI_IN_STOP == State)
    {
        mmr = wdmaudDestroyCompletionThread ( DeviceInfo );
        if (MMSYSERR_NOERROR == mmr)
        {
            for (BufferCount = 0; BufferCount < STREAM_BUFFERS; BufferCount++)
            {
                wdmaudGetMidiData( DeviceInfo, NULL );
            }
        }
    }

    MMRRETURN( mmr );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wdmaudGetPos |
 *
 * @parm DWORD | DeviceInfo | The Device instance structure
 *
 * @parm ULONG | | The state to set the device to
 *
 * @parm ULONG | State | The state to set the device to
 *
 * @rdesc MMSYS.. return code
 ***************************************************************************/
MMRESULT wdmaudGetPos
(
    LPDEVICEINFO    pClient,
    LPMMTIME        lpmmt,
    DWORD           dwSize,
    UINT            DeviceType
)
{
    DWORD        dwPos;
    MMRESULT     mmr;
    LPDEVICEINFO DeviceInfo;

    if (dwSize < sizeof(MMTIME))
        MMRRETURN( MMSYSERR_ERROR );

    DeviceInfo = GlobalAllocDeviceInfo(pClient->wstrDeviceInterface);
    if (NULL == DeviceInfo)
    {
        MMRRETURN( MMSYSERR_NOMEM );
    }

    //
    // Call wdmaud.sys to get the number of devices for each
    // type of function.
    //
    DeviceInfo->DeviceType   = pClient->DeviceType;
    DeviceInfo->DeviceNumber = pClient->DeviceNumber;
    DeviceInfo->DeviceHandle = pClient->DeviceHandle;
    DeviceInfo->OpenDone     = 0;

    //
    // Get the current position from the driver
    //
    mmr = wdmaudIoControl(DeviceInfo,
                          sizeof(DWORD),
                          (LPBYTE)&dwPos,
                          DeviceType == WaveOutDevice ?
                          IOCTL_WDMAUD_WAVE_OUT_GET_POS :
                          IOCTL_WDMAUD_WAVE_IN_GET_POS);

    if (mmr == MMSYSERR_NOERROR)
    {
        //
        //  dwPos is in bytes
        //
        if (lpmmt->wType == TIME_BYTES)
        {
            lpmmt->u.cb = dwPos;
        }
        else
        {
            lpmmt->wType = TIME_SAMPLES;
            if (pClient->DeviceState->cSampleBits != 0)
            {
                lpmmt->u.sample = (dwPos * 8) / pClient->DeviceState->cSampleBits;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
    }

    GlobalFreeDeviceInfo( DeviceInfo );

    MMRRETURN( mmr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\device.c ===
/****************************************************************************
 *
 *   device.c
 *
 *   Kernel mode entry point for WDM drivers
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *                S.Mohanraj (MohanS)
 *                M.McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#define IRPMJFUNCDESC

#include "wdmsys.h"

KMUTEX       wdmaMutex;
KMUTEX       mtxNote;
LIST_ENTRY   WdmaContextListHead;
KMUTEX       WdmaContextListMutex;

//
// For hardware notifications, we need to init these two values.
//
extern KSPIN_LOCK      HardwareCallbackSpinLock;
extern LIST_ENTRY      HardwareCallbackListHead;
extern PKSWORKER       HardwareCallbackWorkerObject;
extern WORK_QUEUE_ITEM HardwareCallbackWorkItem;
//VOID kmxlPersistHWControlWorker(VOID);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS AddFsContextToList(PWDMACONTEXT pWdmaContext)
{
    NTSTATUS Status;

    PAGED_CODE();
    KeEnterCriticalRegion();
    Status = KeWaitForMutexObject(&WdmaContextListMutex, Executive, KernelMode,
                                  FALSE, NULL);
    if (NT_SUCCESS(Status))
    {
        InsertTailList(&WdmaContextListHead, &pWdmaContext->Next);
        KeReleaseMutex(&WdmaContextListMutex, FALSE);
    }
    pWdmaContext->fInList = NT_SUCCESS(Status);
    KeLeaveCriticalRegion();

    RETURN( Status );
}

NTSTATUS RemoveFsContextFromList(PWDMACONTEXT pWdmaContext)
{
    NTSTATUS Status;

    PAGED_CODE();
    if (pWdmaContext->fInList) {
        KeEnterCriticalRegion();
        Status = KeWaitForMutexObject(&WdmaContextListMutex, Executive,
                                      KernelMode, FALSE, NULL);
        if (NT_SUCCESS(Status)) {
            RemoveEntryList(&pWdmaContext->Next);
            KeReleaseMutex(&WdmaContextListMutex, FALSE);
        }
        KeLeaveCriticalRegion();
    } else {
        Status = STATUS_SUCCESS;
    }

    RETURN( Status );
}

//
// This routine walks the list of global context structures and calls the callback
// routine with the structure.  If the callback routine returns STATUS_MORE_DATA
// the routine will keep on searching the list.  If it returns an error or success
// the search will end.
//
NTSTATUS
EnumFsContext(
    FNCONTEXTCALLBACK fnCallback,
    PVOID pvoidRefData,
    PVOID pvoidRefData2
    )
{
    NTSTATUS    Status;
    PLIST_ENTRY ple;
    PWDMACONTEXT pContext;

    PAGED_CODE();

    //
    // Make sure that we can walk are list without being interrupted.
    //
    KeEnterCriticalRegion();
    Status = KeWaitForMutexObject(&WdmaContextListMutex, Executive,
                                  KernelMode, FALSE, NULL);
    if (NT_SUCCESS(Status)) 
    {
        //
        // Walk the list here and call the callback routine.
        //
        for(ple = WdmaContextListHead.Flink;
            ple != &WdmaContextListHead;
            ple = ple->Flink) 
        {
            pContext = CONTAINING_RECORD(ple, WDMACONTEXT, Next);

            //
            // The callback routine will return STATUS_MORE_ENTRIES
            // if it's not done.
            //
            DPF(DL_TRACE|FA_USER,( "Calling fnCallback: %x %x",pvoidRefData,pvoidRefData2 ) );
            Status = fnCallback(pContext,pvoidRefData,pvoidRefData2);

            if( STATUS_MORE_ENTRIES != Status )
            {
                break;
            }
        }

        //
        // "break;" should bring us here to release our locks.
        //
        KeReleaseMutex(&WdmaContextListMutex, FALSE);
    } else {
        DPF(DL_WARNING|FA_USER,( "Failed to get Mutex: %x %x",pvoidRefData,pvoidRefData2 ) );
    }
    KeLeaveCriticalRegion();

    //
    // If the callback routine doesn't return a NTSTATUS, it didn't find
    // what it was looking for, thus, EnumFsContext returns as error.
    //
    if( STATUS_MORE_ENTRIES == Status )
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    DPF(DL_TRACE|FA_USER,( "Returning Status: %x",Status ) );
    return Status;
}


NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING      usRegistryPathName
)
{
    NTSTATUS Status;
    PAGED_CODE();
#ifdef DEBUG
    GetuiDebugLevel();
#endif
    DPF(DL_TRACE|FA_ALL, ("************************************************************") );
    DPF(DL_TRACE|FA_ALL, ("* uiDebugLevel=%08X controls the debug output. To change",uiDebugLevel) );
    DPF(DL_TRACE|FA_ALL, ("* edit uiDebugLevel like: e uidebuglevel and set to         ") );
    DPF(DL_TRACE|FA_ALL, ("* 0 - show only fatal error messages and asserts            ") );
    DPF(DL_TRACE|FA_ALL, ("* 1 (Default) - Also show non-fatal errors and return codes ") );
    DPF(DL_TRACE|FA_ALL, ("* 2 - Also show trace messages                              ") );
    DPF(DL_TRACE|FA_ALL, ("* 4 - Show Every message                                    ") );
    DPF(DL_TRACE|FA_ALL, ("************************************************************") );

    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = PnpDriverUnload; // KsNullDriverUnload;

    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SoundDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SoundDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SoundDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = SoundDispatchCleanup;

    KeInitializeMutex(&wdmaMutex, 0);
    KeInitializeMutex(&mtxNote, 0);

    //
    // Initialize the hardware event items
    //
    InitializeListHead(&HardwareCallbackListHead);
    KeInitializeSpinLock(&HardwareCallbackSpinLock);
    ExInitializeWorkItem(&HardwareCallbackWorkItem,
                         (PWORKER_THREAD_ROUTINE)kmxlPersistHWControlWorker,
                         (PVOID)NULL); //pnnode

    Status = KsRegisterWorker( DelayedWorkQueue, &HardwareCallbackWorkerObject );
    if (!NT_SUCCESS(Status))
    {
        DPFBTRAP();
        HardwareCallbackWorkerObject = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;

    PAGED_CODE();
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch(pIrpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            //
            // Mark the device as not disableable.
            //
            pIrp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            break;
    }
    return(KsDefaultDispatchPnp(pDeviceObject, pIrp));
}

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
)
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    NTSTATUS            Status;
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    pDeviceInstance;

    PAGED_CODE();
    DPF(DL_TRACE|FA_ALL, ("Entering"));

    //
    // The Software Bus Enumerator expects to establish links
    // using this device name.
    //
    Status = IoCreateDevice(
                DriverObject,
                sizeof( DEVICE_INSTANCE ),
                NULL,                           // FDOs are unnamed
                FILE_DEVICE_KS,
                0,
                FALSE,
                &FunctionalDeviceObject );
    if (!NT_SUCCESS(Status)) {
        RETURN( Status );
    }

    pDeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;

    Status = KsAllocateDeviceHeader(
                &pDeviceInstance->pDeviceHeader,
                0,
                NULL );

    if (NT_SUCCESS(Status))
    {
        KsSetDevicePnpAndBaseObject(
            pDeviceInstance->pDeviceHeader,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject,
                PhysicalDeviceObject ),
            FunctionalDeviceObject );

        FunctionalDeviceObject->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }
    else
    {
        IoDeleteDevice( FunctionalDeviceObject );
    }

#ifdef PROFILE
    WdmaInitProfile();
#endif

    InitializeListHead(&WdmaContextListHead);
    KeInitializeMutex(&WdmaContextListMutex, 0);

    InitializeListHead(&wdmaPendingIrpQueue.WdmaPendingIrpListHead);
    KeInitializeSpinLock(&wdmaPendingIrpQueue.WdmaPendingIrpListSpinLock);

    IoCsqInitialize( &wdmaPendingIrpQueue.Csq,
                     WdmaCsqInsertIrp,
                     WdmaCsqRemoveIrp,
                     WdmaCsqPeekNextIrp,
                     WdmaCsqAcquireLock,
                     WdmaCsqReleaseLock,
                     WdmaCsqCompleteCanceledIrp );

    RETURN( Status );
}

VOID
PnpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
    PAGED_CODE();
    DPF(DL_TRACE|FA_ALL,("Entering"));

    //
    // Wait for all or our scheduled work items to complete.
    //
    if( HardwareCallbackWorkerObject )
    {
        KsUnregisterWorker( HardwareCallbackWorkerObject );
        HardwareCallbackWorkerObject = NULL;
    }

    kmxlCleanupNoteList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\kmxluser.c ===
//---------------------------------------------------------------------------
//
//  Module:   kmxluser.c
//
//  Description:
//    Contains the handlers for the ring 3 mixer line api functions.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          I N C L U D E S                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#include "WDMSYS.H"


FAST_MUTEX ReferenceCountMutex;
ULONG      ReferenceCount = 0;

#define NOT16( di ) if( di->dwFormat == ANSI_TAG ) DPF(DL_WARNING|FA_USER,("Invalid dwFormat.") );

#pragma PAGEABLE_CODE

///////////////////////////////////////////////////////////////////////
//
// kmxlInitializeMixer
//
// Queries SysAudio to find the number of devices and builds the mixer
// line structures for each of those devices.
//
//

NTSTATUS
kmxlInitializeMixer(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    ULONG cDevices
)
{
    NTSTATUS     Status;
    ULONG        Device;
    BOOLEAN      Error = FALSE;
//    PFILE_OBJECT pfo;
    PMIXERDEVICE pmxd;

    PAGED_CODE();

    ExInitializeFastMutex( &ReferenceCountMutex );

    DPF(DL_TRACE|FA_USER, ("Found %d mixer devices for DI: %ls", cDevices, DeviceInterface));


    //
    // Current limitation is MAXNUMDEVS.  If more devices are supported
    // than that, limit it to the first MAXNUMDEVS.
    //

    if( cDevices > MAXNUMDEVS ) {
        cDevices = MAXNUMDEVS;
    }

    for( Device = 0; Device < cDevices; Device++ ) {

        DWORD TranslatedDeviceNumber;

        TranslatedDeviceNumber =
                  wdmaudTranslateDeviceNumber(pWdmaContext,
                                              MixerDevice,
                                              DeviceInterface,
                                              Device);

        if(TranslatedDeviceNumber == MAXULONG) {
             continue;
        }

        pmxd = &pWdmaContext->MixerDevs[ TranslatedDeviceNumber ];
        //
        // Open SysAudio
        //
        DPFASSERT(pmxd->pfo == NULL);

        pmxd->pfo = kmxlOpenSysAudio();
        if( pmxd->pfo == NULL ) {
            DPF(DL_WARNING|FA_USER,( "failed to open SYSAUDIO!" ) );
            RETURN( STATUS_UNSUCCESSFUL );
        }
        //
        // Set the current device instance in SysAudio.
        //

        Status = SetSysAudioProperty(
            pmxd->pfo,
            KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
            sizeof( pmxd->Device ),
            &pmxd->Device
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER, ( "failed to set SYSAUDIO device instance" ) );
//            DPF(DL_ERROR|FA_ALL,("If fo is NULL, we must exit here!") );
            kmxlCloseSysAudio( pmxd->pfo );
            pmxd->pfo=NULL;
            Error = TRUE;
        } else {

            //
            // Initialize the topology for this device
            //

            Status = kmxlInit( pmxd->pfo, pmxd );
            if( !NT_SUCCESS( Status ) ) {
                DPF(DL_WARNING|FA_USER, ( "failed to initialize topology for device %d (%x)!",
                                  TranslatedDeviceNumber, Status ) );
                Error = TRUE;
            } else {
                //
                // Here we want to optimize out the restoring of values on the mixer
                // device.  If we find that there is another mixer device in some
                // other open context, then we will NOT call kmxlRetrieveAll to
                // set the values on the device.
                //
                DPF(DL_TRACE|FA_USER,( "Looking for Mixer: %S",pmxd->DeviceInterface ) );

                if( !NT_SUCCESS(EnumFsContext( HasMixerBeenInitialized, pmxd, pWdmaContext )) )
                {
                    //
                    // Here we find that this device was not found, thus this is
                    // the first time through.  Set the defaults here.
                    //
                    DPF(DL_TRACE|FA_USER,( "Did not find Mixer - initializing: %S",pmxd->DeviceInterface ) );

                    kmxlRetrieveAll( pmxd->pfo, pmxd );
                } else {
                    DPF(DL_TRACE|FA_USER,( "Found Mixer: %S",pmxd->DeviceInterface ) );
                }
            }
        }
    }

    if( Error ) {
        RETURN( STATUS_UNSUCCESSFUL );
    } else {
        return( STATUS_SUCCESS );
    }
}

//
// This routine looks in the WDMACONTEXT structure to see if this mixer device
// has already been initialized.  It does this by walking the MixerDevice list and
// checking to see if there are any devices that match this mixer devices's
// DeviceInterface string.  If it finds that there is a match, it routines 
// STATUS_SUCCESS, else it returns STATUS_MORE_ENTRIES so that the enum function
// will call it again until the list is empty.
//
NTSTATUS
HasMixerBeenInitialized(
    PWDMACONTEXT pContext,
    PVOID pvoidRefData,
    PVOID pvoidRefData2
    )
{
    NTSTATUS     Status;
    PMIXERDEVICE pmxdMatch;
    PMIXERDEVICE pmxd;
    DWORD        TranslatedDeviceNumber;
    ULONG        Device;
    PWDMACONTEXT pCurContext;

    //
    // Default is that we did not find this entry in the list.
    //
    Status = STATUS_MORE_ENTRIES;
    //
    // The reference data is a PMIXERDEVICE.
    //
    pmxdMatch = (PMIXERDEVICE)pvoidRefData;
    pCurContext = (PWDMACONTEXT)pvoidRefData2;

    if( pCurContext != pContext )
    {
        for( Device = 0; Device < MAXNUMDEVS; Device++ ) 
        {
            //
            // If this mixer device translates, that means that it can
            // be found in this context.
            //
            TranslatedDeviceNumber =
                      wdmaudTranslateDeviceNumber(pContext,
                                                  MixerDevice,
                                                  pmxdMatch->DeviceInterface,
                                                  Device);

            //
            // If it doesn't, we'll keep looking.
            //
            if( MAXULONG != TranslatedDeviceNumber ) 
            {
                DPF(DL_TRACE|FA_USER,( "Found Mixer: %S",pmxdMatch->DeviceInterface ) );

                Status = STATUS_SUCCESS;
                break;
            }
        }
    } else {
        DPF(DL_TRACE|FA_USER,( "Same context: %x",pCurContext ) );
    }
    return Status;
}

///////////////////////////////////////////////////////////////////////
//
// kmxlOpenHandler
//
// Handles the MXDM_OPEN message.  Copies the callback info from the
// caller and opens an instance of SysAudio set to the device number
// the caller has selected.
//
//

NTSTATUS
kmxlOpenHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,      // Info structure
    IN LPVOID       DataBuffer       // Unused
)
{
    NTSTATUS       Status = STATUS_SUCCESS;
    PMIXERDEVICE   pmxd;

    PAGED_CODE();

    ASSERT( DeviceInfo );
    //
    // BUGBUG: we should not need this any more!
    //
    ASSERT( DeviceInfo->dwInstance == 0 );

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        goto exit;
    }
    DPF(DL_TRACE|FA_INSTANCE,( "param=( %d ) = pmxd = %X",
              DeviceInfo->DeviceNumber,pmxd));

    ExAcquireFastMutex( &ReferenceCountMutex );

    ++ReferenceCount;

    ExReleaseFastMutex( &ReferenceCountMutex );

    DeviceInfo->mmr = MMSYSERR_NOERROR;

exit:
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlCloseHandler
//
// Handles the MXDM_CLOSE message.  Clears the callback info and
// closes the handle to SysAudio.
//
//

NTSTATUS
kmxlCloseHandler(
    IN LPDEVICEINFO DeviceInfo,         // Info structure
    IN LPVOID       DataBuffer          // Unused
)
{
    PAGED_CODE();
    ASSERT( DeviceInfo );
    ASSERT( DeviceInfo->dwInstance );

    DPF(DL_TRACE|FA_INSTANCE,( "kmxlCloseHandler"));
    
    ExAcquireFastMutex( &ReferenceCountMutex );

    --ReferenceCount;

    ExReleaseFastMutex( &ReferenceCountMutex );

    DeviceInfo->mmr = MMSYSERR_NOERROR;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoHandler
//
// Handles the MXDM_GETLINEINFO message.  Determines which query
// is requested by looking at dwFlags and performs that query.
//
//

NTSTATUS
kmxlGetLineInfoHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer          // MIXERLINE(16) to fill
)
{
    MIXERLINE ml;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    if( DataBuffer == NULL ) {
        DPF(DL_WARNING|FA_USER,( "DataBuffer is NULL" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    ml.cbStruct = sizeof( MIXERLINE );

    switch( DeviceInfo->dwFlags & MIXER_GETLINEINFOF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_COMPONENTTYPE:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwComponentType                                         //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.cbStruct        = sizeof( MIXERLINE );
            ml.dwComponentType = ( (LPMIXERLINE) DataBuffer) ->dwComponentType;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoByComponent( %s )",
                    ComponentTypeToString( ml.dwComponentType ) ));

            return( kmxlGetLineInfoByComponent( pWdmaContext,
                                                DeviceInfo,
                                                DataBuffer,
                                                ml.dwComponentType
                                              )
                  );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_DESTINATION:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwDestination                                           //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.dwDestination = ( (LPMIXERLINE) DataBuffer)->dwDestination;
            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoById( S=%08X, D=%08X )",
                       -1, ml.dwDestination ));

            return( kmxlGetLineInfoByID( pWdmaContext,
                                         DeviceInfo,
                                         DataBuffer,
                                         (WORD) -1,
                                         (WORD) ml.dwDestination ) );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_LINEID:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwLineID                                                //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.dwLineID = ( (LPMIXERLINE) DataBuffer)->dwLineID;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoById( S=%08X, D=%08X )",
                       HIWORD( ml.dwLineID ), LOWORD( ml.dwLineID ) ));

            return( kmxlGetLineInfoByID( pWdmaContext,
                                         DeviceInfo,
                                         DataBuffer,
                                         HIWORD( ml.dwLineID ),
                                         LOWORD( ml.dwLineID ) ) );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_SOURCE:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwSource                                                //
        //   dwDestination                                           //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.dwSource      = ( (LPMIXERLINE) DataBuffer)->dwSource;
            ml.dwDestination = ( (LPMIXERLINE) DataBuffer)->dwDestination;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoById( S=%08X, D=%08X )",
                       ml.dwSource, ml.dwDestination ));

            return( kmxlGetLineInfoByID( pWdmaContext,
                                         DeviceInfo,
                                         DataBuffer,
                                         (WORD) ml.dwSource,
                                         (WORD) ml.dwDestination ) );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_TARGETTYPE:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   Target.dwType                                           //
        //   Target.wMid                                             //
        //   Target.wPid                                             //
        //   Target.vDriverVersion                                   //
        //   Target.szPname                                          //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.Target.dwType         = ((LPMIXERLINE) DataBuffer)->Target.dwType;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoByType( %x -- %s )",
                       ml.Target.dwType,
                       TargetTypeToString( ml.Target.dwType ) ));

            return( kmxlGetLineInfoByType( pWdmaContext,
                                           DeviceInfo,
                                           DataBuffer,
                                           ml.Target.dwType ) );

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DPF(DL_WARNING|FA_USER,( "invalid flags ( %x )", DeviceInfo->dwFlags ));
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( STATUS_SUCCESS );
    }

    DPF(DL_WARNING|FA_USER,("Unmatched di->dwFlag") );
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineControlsHandler
//
// Handles the MXDM_GETLINECONTROLS message.  Determines the query
// requested and finds the controls.
//
//

NTSTATUS
kmxlGetLineControlsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERLINECONTROLS(16) to fill
    IN LPVOID       pamxctrl
)
{
    PMIXERDEVICE   pmxd;
    PMXLLINE       pLine;
    PMXLCONTROL    pControl;
    ULONG          Count;
    DWORD          dwLineID,
                   dwControlID,
                   dwControlType,
                   cControls,
                   cbmxctrl;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    //
    // Check some pre-conditions so we don't blow up later.
    //

    if( DataBuffer == NULL ) {
        DPF(DL_WARNING|FA_USER,( "DataBuffer is NULL!" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pamxctrl == NULL ) {
        DPF(DL_WARNING|FA_USER,( "pamxctrl is NULL!" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "device Id is invalid!" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    //
    // Get a instance reference
    //

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Copy out some parameters necessary to find the controls
    //

    NOT16( DeviceInfo );
    dwLineID      = ((LPMIXERLINECONTROLS) DataBuffer)->dwLineID;
    dwControlID   = ((LPMIXERLINECONTROLS) DataBuffer)->dwControlID;
    dwControlType = ((LPMIXERLINECONTROLS) DataBuffer)->dwControlType;
    cControls     = ((LPMIXERLINECONTROLS) DataBuffer)->cControls;
    cbmxctrl      = ((LPMIXERLINECONTROLS) DataBuffer)->cbmxctrl;

    switch( DeviceInfo->dwFlags & MIXER_GETLINECONTROLSF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINECONTROLSF_ALL:
        ///////////////////////////////////////////////////////////////

            //
            // Find the line that matches the dwLineID field
            //

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineControls( ALL, %08X )",dwLineID ));

            pLine = kmxlFindLine( pmxd, dwLineID );
            if( pLine == NULL ) {
                DPF(DL_WARNING|FA_USER,( "ALL - invalid line Id %x!",dwLineID ));
                DeviceInfo->mmr = MIXERR_INVALLINE;
                return( STATUS_SUCCESS );
            }

            //
            // Loop through the controls, copying them into the user buffer.
            //

            Count = 0;
            pControl = kmxlFirstInList( pLine->Controls );
            while( pControl && Count < cControls ) {

                NOT16( DeviceInfo );
                RtlCopyMemory(
                    &((LPMIXERCONTROL) pamxctrl)[ Count ],
                    &pControl->Control,
                    min(cbmxctrl,sizeof(MIXERCONTROL)) );

                pControl = kmxlNextControl( pControl );
                ++Count;
            }

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINECONTROLSF_ONEBYID:
        ///////////////////////////////////////////////////////////////

            pControl = kmxlFindControl( pmxd, dwControlID );
            pLine = kmxlFindLineForControl(
                    pControl,
                    pmxd->listLines
                    );
            if( pLine == NULL ) {
                DPF(DL_WARNING|FA_USER,( "ONEBYID - invalid control Id %x!", dwControlID ));
                DeviceInfo->mmr = MIXERR_INVALCONTROL;
                return( STATUS_SUCCESS );
            }

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineControls( ONEBYID, Ctrl=%08X, Line=%08X )",
                       dwControlID, pLine->Line.dwLineID ));

            if( pControl ) {

                NOT16( DeviceInfo );
                RtlCopyMemory((LPMIXERLINECONTROLS) pamxctrl,
                              &pControl->Control,
                              min(cbmxctrl,sizeof(MIXERCONTROL)) );

                ((PMIXERLINECONTROLS) DataBuffer)->dwLineID =
                    (DWORD) pLine->Line.dwLineID;

                DeviceInfo->mmr = MMSYSERR_NOERROR;
                return( STATUS_SUCCESS );

            } else {
                DPF(DL_WARNING|FA_USER,( "ONEBYID - invalid dwControlID %08X!", dwControlID ));
                DeviceInfo->mmr = MIXERR_INVALCONTROL;
                return( STATUS_SUCCESS );
            }

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINECONTROLSF_ONEBYTYPE:
        ///////////////////////////////////////////////////////////////

            //
            // Find the line that matches the dwLineID field
            //

            pLine = kmxlFindLine( pmxd, dwLineID );
            if( pLine == NULL ) {
                DPF(DL_WARNING|FA_USER,( "ONEBYTYPE - invalid dwLineID %08X!", dwControlType ));
                DeviceInfo->mmr = MIXERR_INVALLINE;
                return( STATUS_SUCCESS );
            }

            DPF(DL_TRACE|FA_USER, ("kmxlGetLineControls( ONEBYTYPE, Type=%s, Line=%08X )",
                    ControlTypeToString( dwControlType ),
                    pLine->Line.dwLineID ));

            //
            // Now look through the controls and find the control that
            // matches the type the caller has passed.
            //

            pControl = kmxlFirstInList( pLine->Controls );
            while( pControl ) {

                if( pControl->Control.dwControlType == dwControlType )
                {

                    NOT16 ( DeviceInfo );
                    RtlCopyMemory((LPMIXERCONTROL) pamxctrl,
                                  &pControl->Control,
                                  min(cbmxctrl,sizeof(MIXERCONTROL)) );
                    DeviceInfo->mmr = MMSYSERR_NOERROR;
                    return( STATUS_SUCCESS );
                }

                pControl = kmxlNextControl( pControl );
            }

            DPF(DL_WARNING|FA_USER,( "(ONEBYTYPE,Type=%x,Line=%08X ) no such control type on line",
                             dwControlType, pLine->Line.dwLineID ));
            DeviceInfo->mmr = MIXERR_INVALCONTROL;
            return( STATUS_SUCCESS );

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DPF(DL_WARNING|FA_USER,( "invalid flags %x",DeviceInfo->dwFlags ));
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( STATUS_SUCCESS );

    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlDetailsHandler
//
// Determines which control is being queried and calls the appropriate
// handler to perform the get property.
//
//

NTSTATUS
kmxlGetControlDetailsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info Structure
    IN LPVOID       DataBuffer,         // MIXERCONTROLDETAILS structure
    IN LPVOID       paDetails           // Flat pointer to details struct(s)
)
{
    LPMIXERCONTROLDETAILS pmcd     = (LPMIXERCONTROLDETAILS) DataBuffer;
    PMXLCONTROL           pControl;
    PMIXERDEVICE          pmxd;
    NTSTATUS              Status;
    PMXLLINE              pLine;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    pControl = kmxlFindControl( pmxd, pmcd->dwControlID );
    if( pControl == NULL ) {
        DPF(DL_WARNING|FA_USER,( "control %x not found",pmcd->dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    pLine = kmxlFindLineForControl(
        pControl,
        pmxd->listLines
        );
    if( pLine == NULL ) {
        DPF(DL_WARNING|FA_USER,( "invalid control id %x!",pmcd->dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    if( ( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) &&
        ( pmcd->cChannels != 1 ) &&
        ( pControl->Control.dwControlType != MIXERCONTROL_CONTROLTYPE_MUX )) {
        DPF(DL_WARNING|FA_USER,( "incorrect cChannels ( %d ) on UNIFORM control %x!",
            pmcd->cChannels, pmcd->dwControlID  ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cChannels > pLine->Line.cChannels ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of channels( %d )!",pmcd->cChannels ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cMultipleItems != pControl->Control.cMultipleItems ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of items( %d )!",pmcd->cMultipleItems ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    switch( DeviceInfo->dwFlags & MIXER_GETCONTROLDETAILSF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_GETCONTROLDETAILSF_LISTTEXT:
        ///////////////////////////////////////////////////////////////

        {
            ULONG cMultipleItems;
            LPMIXERCONTROLDETAILS_LISTTEXT lplt;

            DPF(DL_TRACE|FA_USER,( "kmxlGetControlDetails( Ctrl=%d )",
                       pControl->Control.dwControlID ));

            NOT16( DeviceInfo );

            lplt = (LPMIXERCONTROLDETAILS_LISTTEXT) paDetails;
            for( cMultipleItems = 0;
                 cMultipleItems < pmcd->cMultipleItems;
                 cMultipleItems++ )
            {
                RtlCopyMemory(
                    &lplt[ cMultipleItems ],
                    &pControl->Parameters.lpmcd_lt[ cMultipleItems ],
                    sizeof( MIXERCONTROLDETAILS_LISTTEXT )
                    );
            }
        }

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            break;

        ///////////////////////////////////////////////////////////////
        case MIXER_GETCONTROLDETAILSF_VALUE:
        ///////////////////////////////////////////////////////////////

            switch( pControl->Control.dwControlType ) {

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MIXER:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
                    DPF(DL_WARNING|FA_USER,( "mixers are not supported" ));
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_PEAKMETER:
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleGetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        MIXER_FLAG_SCALE
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MUTE:
                ///////////////////////////////////////////////////////

                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUTE ) ) {
                        Status = kmxlHandleGetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            KSPROPERTY_AUDIO_MUTE,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            0
                            );
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleGetMuteFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            0
                            );
                    } else {
                        DPF(DL_WARNING|FA_USER,("Unmatched GUID") );
                    }
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_VOLUME:
                //////////////////////////////////////////////////////

                    #ifdef SUPERMIX_AS_VOL
                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_VOLUME ) ) {
                    #endif
                        Status = kmxlHandleGetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            pControl->PropertyId,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            MIXER_FLAG_SCALE
                            );
                    #ifdef SUPERMIX_AS_VOL
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleGetVolumeFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            MIXER_FLAG_SCALE
                            );

                    } else {
                        DPF(DL_WARNING|FA_USER,("Invalid GUID for Control.") );
                    }
                    #endif // SUPERMIX_AS_VOL
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_TREBLE:
                case MIXERCONTROL_CONTROLTYPE_BASS:
                ///////////////////////////////////////////////////////
                // These all take 32-bit parameters per channel but  //
                // need to be scale from dB to linear                //
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleGetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        MIXER_FLAG_SCALE
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_LOUDNESS:
                case MIXERCONTROL_CONTROLTYPE_ONOFF:
                case MIXERCONTROL_CONTROLTYPE_BOOLEAN:
                case MIXERCONTROL_CONTROLTYPE_MUX:
                case MIXERCONTROL_CONTROLTYPE_FADER:
                case MIXERCONTROL_CONTROLTYPE_BASS_BOOST:
                ///////////////////////////////////////////////////////
                // These all take up to 32-bit parameters per channel//
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleGetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        0
                        );
                    break;

                ///////////////////////////////////////////////////////
                default:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                    break;
            }
            break;

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
            break;
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlSetControlDetailsHandler
//
// Determines which control is being set and calls the appropriate
// handler to perform the set property.
//
//

NTSTATUS
kmxlSetControlDetailsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN OUT LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERCONTROLDETAILS structure
    IN LPVOID       paDetails,          // Flat pointer to detail struct(s)
    IN ULONG        Flags
)
{
    LPMIXERCONTROLDETAILS pmcd     = (LPMIXERCONTROLDETAILS) DataBuffer;
    PMXLCONTROL           pControl;
    NTSTATUS              Status;
    PMIXERDEVICE          pmxd;
    PMXLLINE              pLine;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    //
    // Get a instance reference
    //

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    pControl = kmxlFindControl( pmxd, pmcd->dwControlID );
    if( pControl == NULL ) {
        DPF(DL_WARNING|FA_USER,( "control %d not found",pmcd->dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    pLine = kmxlFindLineForControl(
        pControl,
        pmxd->listLines
        );
    if( pLine == NULL ) {
        DPF(DL_WARNING|FA_USER,( "invalid control id %d",pControl->Control.dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    if( ( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) &&
        ( pmcd->cChannels != 1 ) &&
        ( pControl->Control.dwControlType != MIXERCONTROL_CONTROLTYPE_MUX )) {
        DPF(DL_WARNING|FA_USER,( "incorrect cChannels ( %d ) on UNIFORM control %d",
                         pmcd->cChannels,
                         pControl->Control.dwControlID ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cChannels > pLine->Line.cChannels ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of channels ( %d ) on line %08x",
                         pmcd->cChannels,
                         pLine->Line.dwLineID ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cMultipleItems != pControl->Control.cMultipleItems ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of items ( %d ) on control %d ( %d )",
                         pmcd->cMultipleItems,
                         pControl->Control.dwControlID,
                         pControl->Control.cMultipleItems ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    switch( DeviceInfo->dwFlags & MIXER_SETCONTROLDETAILSF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_SETCONTROLDETAILSF_VALUE:
        ///////////////////////////////////////////////////////////////

            switch( pControl->Control.dwControlType ) {

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MIXER:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
                    DPF(DL_WARNING|FA_USER,( "mixers are not supported" ));
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_PEAKMETER:
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleSetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        Flags | MIXER_FLAG_SCALE
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MUTE:
                ///////////////////////////////////////////////////////

                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUTE ) ) {
                        Status = kmxlHandleSetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            KSPROPERTY_AUDIO_MUTE,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags
                            );
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleSetMuteFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags
                            );
                    } else {
                        DPF(DL_WARNING|FA_USER,("Invalid GUID for Control Type Mute.") );
                    }

                    kmxlNotifyLineChange(
                        DeviceInfo,
                        pmxd,
                        pLine,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_VOLUME:
                ///////////////////////////////////////////////////////

                    #ifdef SUPERMIX_AS_VOL
                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_VOLUME ) ) {
                    #endif // SUPERMIX_AS_VOL
                        Status = kmxlHandleSetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            pControl->PropertyId,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags | MIXER_FLAG_SCALE
                            );
                    #ifdef SUPERMIX_AS_VOL
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleSetVolumeFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags | MIXER_FLAG_SCALE
                            );
                    } else {
                        DPF(DL_WARNING|FA_USER,("Invalid GUID for Control Type Volume.") );
                    }
                    #endif
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_TREBLE:
                case MIXERCONTROL_CONTROLTYPE_BASS:
                ///////////////////////////////////////////////////////
                // These all take 32-bit parameters per channel but  //
                // need to be scale from linear to dB                //
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleSetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        Flags | MIXER_FLAG_SCALE
                        );
                     break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_LOUDNESS:
                case MIXERCONTROL_CONTROLTYPE_ONOFF:
                case MIXERCONTROL_CONTROLTYPE_BOOLEAN:
                case MIXERCONTROL_CONTROLTYPE_MUX:
                case MIXERCONTROL_CONTROLTYPE_FADER:
                case MIXERCONTROL_CONTROLTYPE_BASS_BOOST:
                ///////////////////////////////////////////////////////
                // These all take up to 32-bit parameters per channel//
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleSetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        Flags
                        );
                    break;

                ///////////////////////////////////////////////////////
                default:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                    break;
            }
            break;

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DPF(DL_WARNING|FA_USER,( "invalid flags %x",DeviceInfo->dwFlags ));
            DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
            break;
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindControl
//
//

PMXLCONTROL
kmxlFindControl(
    IN PMIXERDEVICE pmxd,             // The mixer instance to search
    IN DWORD        dwControlID       // The control ID to find
)
{
    PMXLLINE    pLine;
    PMXLCONTROL pControl;

    PAGED_CODE();
    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {
            if( pControl->Control.dwControlID == dwControlID ) {
                return( pControl );
            }
            pControl = kmxlNextControl( pControl );
        }

        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindLine
//
// For the given line ID, kmxlFindLine will find the matching
// MXLLINE structure for it.
//
//

PMXLLINE
kmxlFindLine(
    IN PMIXERDEVICE   pmxd,
    IN DWORD          dwLineID          // The line ID to find
)
{
    PMXLLINE pLine;

    PAGED_CODE();
    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( pLine->Line.dwLineID == dwLineID ) {
            return( pLine );
        }

        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByID
//
// Loops through the lines looking for a line that has a matching
// source and destination Id.
//
//

NTSTATUS
kmxlGetLineInfoByID(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERLINE(16) structure
    IN WORD         Source,             // Source line id
    IN WORD         Destination         // Destination line id
)
{
    PMIXERDEVICE   pmxd;
    PMXLLINE       pLine;
    BOOL           bDestination;

    PAGED_CODE();

    ASSERT( DeviceInfo );
    ASSERT( DataBuffer );

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "invalid device number %d",DeviceInfo->DeviceNumber ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // If the source is -1 (0xFFFF), then this line is a destination.
    //

    if( Source == (WORD) -1 ) {
        bDestination = TRUE;
        Source       = 0;
    } else {
        bDestination = FALSE;
    }

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( ( bDestination                                 &&
              ( pLine->Line.dwDestination == Destination ) &&
              ( pLine->Line.cConnections > 0             ) ) ||
            ( ( pLine->Line.dwSource      == Source )      &&
              ( pLine->Line.dwDestination == Destination ) ) )
        {

            NOT16( DeviceInfo );
            RtlCopyMemory((LPMIXERLINE) DataBuffer,
                          &pLine->Line,
                          sizeof( MIXERLINE ) );

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );
        }
        pLine = kmxlNextLine( pLine );
    }

    //
    // There are no lines for the device number.
    //

    DPF(DL_WARNING|FA_USER,( "no matching lines for (S=%08X, D=%08X)",
                     Source,
                     Destination ));
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByType
//
// Loops through all the lines looking for the first line that matches
// the Target type specified. Note that this will always only find the
// first one!
//
//

NTSTATUS
kmxlGetLineInfoByType(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device info structure
    IN LPVOID       DataBuffer,         // MIXERLINE(16) structure
    IN DWORD        dwType              // Line type to search for
)
{
    PMXLLINE       pLine;
    PMIXERDEVICE   pmxd;

    PAGED_CODE();
    ASSERT( DeviceInfo );
    ASSERT( DataBuffer );

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "invalid device id %x",DeviceInfo->DeviceNumber ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Loop through all the lines looking for a line that has the
    // specified target type.  Note that this will only return the
    // first one.
    //

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( pLine->Line.Target.dwType == dwType ) {

            LPMIXERLINE lpMxl = (LPMIXERLINE) DataBuffer;
            NOT16( DeviceInfo );

            if( lpMxl->Target.wMid != pLine->Line.Target.wMid ) {
                DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                return( STATUS_SUCCESS );
            }

            if( lpMxl->Target.wPid != pLine->Line.Target.wPid ) {
                DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                return( STATUS_SUCCESS );
            }

            if( wcscmp( pLine->Line.Target.szPname, lpMxl->Target.szPname ) )
            {
                DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                return( STATUS_SUCCESS );
            }

            RtlCopyMemory((LPMIXERLINE) DataBuffer,
                          &pLine->Line,
                          sizeof( MIXERLINE ) );

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );
        }
        pLine = kmxlNextLine( pLine );
    }

    //
    // The line was not found.  Return invalid parameter.
    //

    DPF(DL_WARNING|FA_USER,( "no matching line found for %x",dwType ));
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByComponent
//
// Loops through the list of lines looking for a line that has a matching
// dwComponentType.  Note that this will always find only the first!
//
//

NTSTATUS
kmxlGetLineInfoByComponent(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERLINE(16) structure
    IN DWORD        dwComponentType     // Component type to search for
)
{
    PMXLLINE       pLine;
    PMIXERDEVICE   pmxd;

    PAGED_CODE();
    ASSERT( DeviceInfo );
    ASSERT( DataBuffer );

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "invalid device id %x",DeviceInfo->DeviceNumber ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Loop through all the lines looking for a line that has a component
    // type matching what the user requested.
    //

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( pLine->Line.dwComponentType == dwComponentType ) {

            //
            // Copy the data into the user buffer
            //
            NOT16( DeviceInfo );
            RtlCopyMemory((LPMIXERLINE) DataBuffer,
                          &pLine->Line,
                          sizeof( MIXERLINE ) );

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );
        }

        pLine = kmxlNextLine( pLine );
    }

    DPF(DL_WARNING|FA_USER,( "no matching line found for type %x",dwComponentType ));
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNumDestinations
//
// Returns the number of destinations stored in the mixer device
//
//

DWORD
kmxlGetNumDestinations(
    IN PMIXERDEVICE pMixerDevice        // The device
)
{
    PAGED_CODE();

    return( pMixerDevice->cDestinations );
}



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               I N S T A N C E   R O U T I N E S                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// kmxlReferenceInstance
//
// Determines if the dwInstance field of the DeviceInfo structure
// is valid.  If not, it creates a valid instance and sets a
// reference count of 1 on it.
//
//

LONG nextinstanceid=0;

DWORD kmxlUniqueInstanceId(VOID)
{
    PAGED_CODE();
    // Update our next valid instance id.  Do NOT allow zero.
    // Since that is used to signal that we want to allocate
    // a new instance.
    if (0==InterlockedIncrement(&nextinstanceid))
        InterlockedIncrement(&nextinstanceid);

    return nextinstanceid;
}



/////////////////////////////////////////////////////////////////////////////
//
// kmxlReferenceMixerDevice
//
// This routine Translates the device number and makes sure that there is a
// open SysAudio PFILE_OBJECT in this mixier device.  This will be the FILE_OBJECT
// that we use to talk to this mixer device.
//
// return:  PMIXERDEVICE on success NULL otherwise.
//
PMIXERDEVICE
kmxlReferenceMixerDevice(
    IN     PWDMACONTEXT pWdmaContext,
    IN OUT LPDEVICEINFO DeviceInfo      // Device Information
)
{
    NTSTATUS       Status;
    DWORD          TranslatedDeviceNumber;
    PMIXERDEVICE   pmxd;


    PAGED_CODE();
    DPFASSERT(IsValidDeviceInfo(DeviceInfo));


    TranslatedDeviceNumber =
              wdmaudTranslateDeviceNumber(pWdmaContext,
                                          DeviceInfo->DeviceType,
                                          DeviceInfo->wstrDeviceInterface,
                                          DeviceInfo->DeviceNumber);

    if( TranslatedDeviceNumber == MAXULONG ) {
        DPF(DL_WARNING|FA_INSTANCE,("Could not translate DeviceNumber! DT=%08X, DI=%08X, DN=%08X",
                                    DeviceInfo->DeviceType,
                                    DeviceInfo->wstrDeviceInterface,
                                    DeviceInfo->DeviceNumber) );
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( NULL );
    }

    pmxd = &pWdmaContext->MixerDevs[ TranslatedDeviceNumber ];

    if( pmxd->pfo == NULL )
    {
        DPF(DL_WARNING|FA_NOTE,("pmxd->pfo should have been set!") );
        //
        // This is the first time through this code.  Open SysAudio on this device
        // and set the mixer device.
        //
        // set the SysAudio file object
        if( NULL==(pmxd->pfo=kmxlOpenSysAudio())) {
            DPF(DL_WARNING|FA_INSTANCE,("OpenSysAudio failed") );
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( NULL );
        }

        Status = SetSysAudioProperty(
            pmxd->pfo,
            KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
            sizeof( pmxd->Device ),
            &pmxd->Device
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlCloseSysAudio( pmxd->pfo );
            pmxd->pfo=NULL;
            DPF(DL_WARNING|FA_INSTANCE,("SetSysAudioProperty DEVICE_INSTANCE failed %X",Status) );
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( NULL );
        }
    }
    //
    // BUGBUG:  we should not need this any more.
    //
    DeviceInfo->dwInstance=kmxlUniqueInstanceId();;

    return pmxd;
}



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//           G E T / S E T  D E T A I L  H A N D L E R S             //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlIsSpeakerDestinationVolume
//
// Returns TRUE if the control is a volume control on the Speakers
// destination.
//
//

BOOL
kmxlIsSpeakerDestinationVolume(
     IN PMIXERDEVICE   pmxd,         // The mixer
     IN PMXLCONTROL    pControl      // The control to check
)
{
     PMXLLINE pLine;

     PAGED_CODE();
     DPFASSERT( IsValidMixerDevice(pmxd) );
     DPFASSERT( IsValidControl(pControl) );

     //
     // Find a line for this control.  If none is found, then this can't
     // be a destination volume.
     //

     pLine = kmxlFindLineForControl( pControl, pmxd->listLines );
     if( !pLine ) {
          return( FALSE );
     }

     if( pLine->Line.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ) {
          return( TRUE );
     } else {
          return( FALSE );
     }

}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetUnsigned
//
//
// Handles getting an unsigned (32-bit) value for a control.  Note
// that signed 32-bit and boolean values are also retrieved via this
// handler.
//
//

NTSTATUS
kmxlHandleGetUnsigned(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     ULONG                          ulProperty,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG     Level;
    DWORD    dwLevel;
    ULONG    i;
    ULONG    Channel;
    MIXERMAPPING Mapping = MIXER_MAPPING_LOGRITHMIC;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    DPFASSERT( IsValidControl(pControl)  );

    if( paDetails == NULL ) {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    //
    // Use a different mapping algorithm if this is a speaker
    // dest volume control.
    //

    if( kmxlIsSpeakerDestinationVolume( pmxd, pControl ) ) {
         Mapping = pmxd->Mapping;
    }

    //
    // Service the Mux
    //
    if ( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX) {

        Status = kmxlGetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            pControl->PropertyId,
            pControl->Id,
            0,
            NULL,
            &Level,
            sizeof( Level )
        );
        if( !NT_SUCCESS( Status ) ) {            
            DPF(DL_WARNING|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d, Id=%d ) failed GET on MUX with %x",
                             pControl->Control.dwControlID,
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

        DPF(DL_TRACE|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d, Id=%d ) = %d [1]",
                   pControl->Control.dwControlID,
                   pControl->Id,
                   Level ));

        for( i = 0; i < pControl->Parameters.Count; i++ ) {
            if( (ULONG) Level == pControl->Parameters.pPins[ i ] ) {
//                APITRACE(( "1" ));
                paDetails[ i ].dwValue = 1;
            } else {
                paDetails[ i ].dwValue = 0;
//                APITRACE(( "1" ));
            }
        }

//        APITRACE(( "]\n" ));

    }
    else {

        paDetails->dwValue = 0; // initialize to zero for now so that the coalesced case works

        // Loop over the channels for now.  Fix this so that only one request is made.
        Channel = 0;
        do
        {
            Status = kmxlGetAudioNodeProperty(
                pmxd->pfo,
                ulProperty,
                pControl->Id,
                Channel,
                NULL,   0,                  // No extra input bytes
                &Level, sizeof( Level )
                );
            if ( !NT_SUCCESS( Status ) ) {                
                DPF(DL_TRACE|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d [%s], Id=%d ) failed GET on MASTER channel with %x",
                           pControl->Control.dwControlID,
                           ControlTypeToString( pControl->Control.dwControlType ),
                           pControl->Id,
                           Status ));
                DPF(DL_WARNING|FA_PROPERTY, 
                    ( "GetAudioNodeProp failed on MASTER channel with %X for %s!",
                       Status,
                       ControlTypeToString( pControl->Control.dwControlType ) ) );
                DeviceInfo->mmr = MMSYSERR_ERROR;
                return( STATUS_SUCCESS );
            }

            if ( pControl->bScaled ) {
                dwLevel = kmxlVolLogToLinear( pControl, Level, Mapping, Channel );
            } else {
                dwLevel = (DWORD)Level;
            }

            if(  ( pmcd->cChannels == 1 ) &&
                !( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) ) {

                //
                // Coalesce values: If the user requests only 1 channel for a N channel
                // control, then return the greatest channel value.
                //
                if (dwLevel > paDetails->dwValue) {
                    paDetails->dwValue = dwLevel;
                }

            } else if (Channel < pmcd->cChannels) {

                paDetails[ Channel ].dwValue = dwLevel;
                DPF(DL_TRACE|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d, Id=%d ) returning (Chan#%d) = (%x)",
                      pControl->Control.dwControlID,
                      pControl->Id,
                      Channel,
                      paDetails[ Channel ].dwValue
                      ));

            } else {
                // No need to keep trying
                break;
            }

            Channel++;

        } while ( Channel < pControl->NumChannels );
    }

    if( NT_SUCCESS( Status ) ) {
        DeviceInfo->mmr = MMSYSERR_NOERROR;
    } else {
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetMuteFromSuperMix
//
// Handles getting the mute state from a supermix node.
//

NTSTATUS
kmxlHandleGetMuteFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i;
    BOOL bMute = FALSE;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl );

    ASSERT( pControl->Parameters.pMixCaps   );
    ASSERT( pControl->Parameters.pMixLevels );

    //
    // Read the current state of the supermix
    //

    Status = kmxlGetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleGetMuteFromSupermix ( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                   pControl->Control.dwControlID,
                   ControlTypeToString( pControl->Control.dwControlType ),
                   pControl->Id,
                   Status
                   ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
        return( STATUS_SUCCESS );
    }

    for( i = 0; i < pControl->Parameters.Size; i++ ) {

        if( pControl->Parameters.pMixLevels[ i ].Mute )
        {
            bMute = TRUE;
            continue;
        }

        if( pControl->Parameters.pMixLevels[ i ].Level == LONG_MIN )
        {
            bMute = TRUE;
            continue;
        }

        bMute = FALSE;
        break;
    }

    paDetails->dwValue = (DWORD) bMute;
    DeviceInfo->mmr = MMSYSERR_NOERROR;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetUnsigned
//
// Handles setting an unsigned (32-bit) value for a control.  Note
// that signed 32-bit and boolean values are also set via this
// handler.
//
//

NTSTATUS
kmxlHandleSetUnsigned(
    IN OUT LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     ULONG                          ulProperty,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS       Status = STATUS_SUCCESS;
    LONG           Level, Current;
    DWORD          dwValue;
    BOOL           bUniform, bEqual = TRUE;
    ULONG          i;
    ULONG          Channel;
    MIXERMAPPING   Mapping = MIXER_MAPPING_LOGRITHMIC;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl  );

    if( paDetails == NULL ) {
        DPF(DL_WARNING|FA_USER,( "paDetails is NULL" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_INVALID_PARAMETER );
    }

    bUniform = ( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) ||
               ( pmcd->cChannels == 1 );

    //
    // Use a different mapping if this control is a speaker destination
    // volume control.
    //

    if( kmxlIsSpeakerDestinationVolume( pmxd, pControl ) ) {
         Mapping = pmxd->Mapping;
    }

    //
    //  Service the mux
    //
    if ( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX) {

        // Proken APITRACE statement.
        //DPF(DL_TRACE|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d, " ));


        // First validate the paDetails parameter and make sure it has the correct
        // format.  If not, then punt with an invalid parameter error.
                {
                LONG selectcount=0;

        for( i = 0; i < pmcd->cMultipleItems; i++ ) {
            if( paDetails[ i ].dwValue ) {
                selectcount++;
//                APITRACE(( "1" ));
            } else {
//                APITRACE(( "0" ));
            }

        }

        if (selectcount!=1) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d ) invalid paDetails parameter for SET on MUX",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id));
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( STATUS_SUCCESS );
                }

                }


        for( i = 0; i < pmcd->cMultipleItems; i++ ) {
            if( paDetails[ i ].dwValue ) {
//                APITRACE(( "1" ));
                Level = pControl->Parameters.pPins[ i ];
            } else {
//                APITRACE(( "0" ));
            }

        }

//        APITRACE(( " ). Setting pin %d on MUX.\n", Level ));

        Status = kmxlSetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            pControl->PropertyId,
            pControl->Id,
            0,
            NULL,
            &Level,
            sizeof( Level )
        );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d ) failed SET on MUX with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }
        bEqual = FALSE;
    }
    else {
        // Loop over the channels for now.  Fix this so that only one request is made.
        Channel = 0;
        do
        {
            if( bUniform ) {
                //
                // Some controls are mono in the eyes of SNDVOL but are in
                // fact stereo.  This hack fixes this problem.
                //
                dwValue = paDetails[ 0 ].dwValue;
            } else if (Channel < pmcd->cChannels) {
                dwValue = paDetails[ Channel ].dwValue;
            } else {
                // No need to keep trying
                break;
            }

            if( pControl->bScaled ) {
                Level = kmxlVolLinearToLog( pControl, dwValue, Mapping, Channel );
            } else {
                Level = (LONG)dwValue;
            }

            Status = kmxlGetAudioNodeProperty(
                pmxd->pfo,
                ulProperty,
                pControl->Id,
                Channel,
                NULL,   0,                  // No extra input bytes
                &Current, sizeof( Current )
                );
            if( !NT_SUCCESS( Status ) ) {
                DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d ) failed GET on channel %d with %x",
                                 pControl->Control.dwControlID,
                                 ControlTypeToString( pControl->Control.dwControlType ),
                                 pControl->Id,
                                 Channel,
                                 Status ));
                DeviceInfo->mmr = MMSYSERR_ERROR;
                return( STATUS_SUCCESS );
            }

            if( Level != Current ) {

                bEqual = FALSE;

                Status = kmxlSetAudioNodeProperty(
                    pmxd->pfo,
                    ulProperty,
                    pControl->Id,
                    Channel,
                    NULL,   0,                  // No extra input bytes
                    &Level, sizeof( Level )
                    );
                if( !NT_SUCCESS( Status ) ) {
                    DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%x ) failed SET on channel %d with %x",
                                     pControl->Control.dwControlID,
                                     ControlTypeToString( pControl->Control.dwControlType ),
                                     pControl->Id,
                                     Channel,
                                     Status ));
                    DeviceInfo->mmr = MMSYSERR_ERROR;
                    return( STATUS_SUCCESS );
                }

                DPF(DL_TRACE|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d, Id=%d ) using (%x) on Chan#%d",
                          pControl->Control.dwControlID,
                          pControl->Id,
                          paDetails[ Channel ].dwValue,
                          Channel
                        ));
            }

            Channel++;

        } while ( Channel < pControl->NumChannels );
    }

    if( NT_SUCCESS( Status ) ) {

        DeviceInfo->mmr = MMSYSERR_NOERROR;

        if( Flags & MIXER_FLAG_PERSIST ) {

            kmxlPersistControl(
                pmxd->pfo,
                pmxd,
                pControl,
                paDetails
                );
        }

        if( !bEqual && !( Flags & MIXER_FLAG_NOCALLBACK ) ) {
            kmxlNotifyControlChange( DeviceInfo, pmxd, pControl );
        }

    } else {
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetMuteFromSuperMix
//
//  Handles setting the mute state using a supermixer.
//
//

NTSTATUS
kmxlHandleSetMuteFromSuperMix(
    IN OUT LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl );

    ASSERT( pControl->Parameters.pMixCaps   );
    ASSERT( pControl->Parameters.pMixLevels );

    if( paDetails->dwValue ) {

        //
        // Query the current values from the supermix and save those away.
        // These values will be used to restore the supermix to the state
        // we found it prior to muting.
        //

        Status = kmxlGetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

        //
        // For any entry in the table that supports muting, mute it.
        //

        for( i = 0; i < pControl->Parameters.Size; i++ ) {

            if( pControl->Parameters.pMixCaps->Capabilities[ i ].Mute ) {
                pControl->Parameters.pMixLevels[ i ].Mute = TRUE;
            }
        }

        //
        // Set this new supermixer state.
        //

        Status = kmxlSetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed SET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

    } else {

        Status = kmxlGetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

        //
        // For any entry in the table that supports muting, mute it.
        //

        for( i = 0; i < pControl->Parameters.Size; i++ ) {

            if( pControl->Parameters.pMixCaps->Capabilities[ i ].Mute ) {
                pControl->Parameters.pMixLevels[ i ].Mute = FALSE;
            }
        }

        //
        // Set this new supermixer state.
        //

        Status = kmxlSetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed SET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

    }

    if( NT_SUCCESS( Status ) ) {
        if( Flags & MIXER_FLAG_PERSIST ) {

            kmxlPersistControl(
                pmxd->pfo,
                pmxd,
                pControl,
                paDetails
                );

        }

        kmxlNotifyControlChange( DeviceInfo, pmxd, pControl );
        DeviceInfo->mmr = MMSYSERR_NOERROR;
    } else {
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }

    return( STATUS_SUCCESS );
}

#ifdef SUPERMIX_AS_VOL
///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetVolumeFromSuperMix
//
//

NTSTATUS
kmxlHandleGetVolumeFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i, Channels, Index, MaxChannel = 0;
    LONG  Max = LONG_MIN; // -Inf dB

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl  );
    ASSERT( pmcd      );
    ASSERT( paDetails );

    Status = kmxlGetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleGetVolumeFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                         pControl->Control.dwControlID,
                         ControlTypeToString( pControl->Control.dwControlType ),
                         pControl->Id,
                         Status ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
        return( STATUS_SUCCESS );
    }

    //
    // Count the number of channels
    //

    for( i = 0, Channels = 0;
         i < pControl->Parameters.Size;
         i += pControl->Parameters.pMixCaps->OutputChannels + 1,
         Channels++ )
    {
        if( pControl->Parameters.pMixLevels[ i ].Level > Max ) {
            Max = pControl->Parameters.pMixLevels[ i ].Level;
            MaxChannel = Channels;
        }
    }

    //
    // Return the translated volume levels
    //

    if( ( pmcd->cChannels == 1 ) && ( Channels > 1 ) ) {

        //
        // As per SB16 sample, if the caller wants only 1 channel but
        // the control is multichannel, return the maximum of all the
        // channels.
        //

        paDetails->dwValue = kmxlVolLogToLinear(
            pControl,
            Max,
            MIXER_MAPPING_LOGRITHMIC,
            MaxChannel
            );
    } else {

        //
        // Translate each of the channel value into linear and
        // store them away.
        //

        for( i = 0; i < pmcd->cChannels; i++ ) {

            Index = i * ( pControl->Parameters.pMixCaps->OutputChannels + 1 );
            paDetails[ i ].dwValue = kmxlVolLogToLinear(
                pControl,
                pControl->Parameters.pMixLevels[ Index ].Level,
                MIXER_MAPPING_LOGRITHMIC,
                i
                );
        }

    }

    DeviceInfo->mmr = MMSYSERR_NOERROR;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetVolumeFromSuperMix
//
//

NTSTATUS
kmxlHandleSetVolumeFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i, Index;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl  );
    ASSERT( pmcd      );
    ASSERT( paDetails );

    //
    // Query the current values for the mix levels.
    //

    Status = kmxlGetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleSetVolumeFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                         pControl->Control.dwControlID,
                         ControlTypeToString( pControl->Control.dwControlType ),
                         pControl->Id,
                         Status ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
        return( STATUS_SUCCESS );
    }

    //
    // Adjust the values on the diagonal to those the user specified.
    //

    for( i = 0; i < pmcd->cChannels; i++ ) {

        Index = i * ( pControl->Parameters.pMixCaps->OutputChannels + 1 );
        pControl->Parameters.pMixLevels[ Index ].Level = kmxlVolLinearToLog(
            pControl,
            paDetails[ i ].dwValue,
            MIXER_MAPPING_LOGRITHMIC,
            i
            );
    }

    //
    // Set these new values.
    //

    Status = kmxlSetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL )
        );

    if( NT_SUCCESS( Status ) ) {
        DeviceInfo->mmr = MMSYSERR_NOERROR;
    } else {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleSetVolumeFromSuperMix( Ctrl=%d [%s], Id=%d ) failed SET on MIX_LEVEL_TABLE with %x",
                         pControl->Control.dwControlID,
                         ControlTypeToString( pControl->Control.dwControlType ),
                         pControl->Id,
                         Status ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }
    return( STATUS_SUCCESS );
}
#endif // SUPERMIX_AS_VOL

///////////////////////////////////////////////////////////////////////
//
// kmxlNotifyLineChange
//
//

VOID
kmxlNotifyLineChange(
    OUT LPDEVICEINFO                  DeviceInfo,
    IN PMIXERDEVICE                   pmxd,
    IN PMXLLINE                       pLine,
    IN LPMIXERCONTROLDETAILS_UNSIGNED paDetails
)
{
    PAGED_CODE();
        ASSERT( (DeviceInfo->dwCallbackType&MIXER_LINE_CALLBACK) == 0 );

        DeviceInfo->dwLineID=pLine->Line.dwLineID;
        DeviceInfo->dwCallbackType|=MIXER_LINE_CALLBACK;
}


///////////////////////////////////////////////////////////////////////
//
// kmxlNotifyControlChange
//
//

VOID
kmxlNotifyControlChange(
    OUT LPDEVICEINFO  DeviceInfo,
    IN PMIXERDEVICE   pmxd,
    IN PMXLCONTROL    pControl
)
{
    WRITE_CONTEXT* pwc;

    PAGED_CODE();

    //
    // If there are no open instances, there is no reason to even attempt
    // a callback... no one is listening.
    //

    ExAcquireFastMutex( &ReferenceCountMutex );

    if( ReferenceCount == 0 ) {
        ExReleaseFastMutex( &ReferenceCountMutex );
        return;
    }

    ExReleaseFastMutex( &ReferenceCountMutex );


    {
        PMXLLINE    pLine;
        PMXLCONTROL pCtrl;

        LONG callbackcount;

        callbackcount=0;

        pLine = kmxlFirstInList( pmxd->listLines );
        while( pLine ) {

            pCtrl = kmxlFirstInList( pLine->Controls );
            while( pCtrl ) {


                if ( pCtrl->Id == pControl->Id ) {

                    //ASSERT( (DeviceInfo->dwCallbackType&MIXER_CONTROL_CALLBACK) == 0 );
                    ASSERT( callbackcount < MAXCALLBACKS );

                    if ( callbackcount < MAXCALLBACKS ) {
                        (DeviceInfo->dwID)[callbackcount++]=pCtrl->Control.dwControlID;
                        }

                    DeviceInfo->dwCallbackType|=MIXER_CONTROL_CALLBACK;

                    }

                pCtrl = kmxlNextControl( pCtrl );
            }
            pLine = kmxlNextLine( pLine );
        }

    DeviceInfo->ControlCallbackCount=callbackcount;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\kmxltop.c ===
//---------------------------------------------------------------------------
//
//  Module:   kmxltop.c
//
//  Description:
//    Topology parsing routines for the kernel mixer line driver
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          I N C L U D E S                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#include "WDMSYS.H"
#include "kmxluser.h"

///////////////////////////////////////////////////////////////////////
//
// kmxlQueryTopology
//
// Queries the topology from the device and stores all the information
// in pTopology.
//
//

NTSTATUS
kmxlQueryTopology(
    IN  PFILE_OBJECT    pfoInstance, // The handle to query the topology for
    OUT PKSTOPOLOGY     pTopology    // The topology structure to fill in
)
{
    NTSTATUS         Status;
    PKSMULTIPLE_ITEM pCategories   = NULL;
    PKSMULTIPLE_ITEM pNodes        = NULL;
    PKSMULTIPLE_ITEM pConnections  = NULL;

    ASSERT( pfoInstance );
    ASSERT( pTopology );

    PAGED_CODE();

    //
    // Get device's topology categories
    //

    Status = kmxlGetProperty(
        pfoInstance,
        &KSPROPSETID_Topology,
        KSPROPERTY_TOPOLOGY_CATEGORIES,
        0,                              // 0 extra input bytes
        NULL,                           // No input data
        0,                              // Flags
        &pCategories
        );
    if( !NT_SUCCESS( Status ) ) {
        RETURN( Status );
    }

    //
    // Get the list of nodes types in the topology
    //

    Status = kmxlGetProperty(
        pfoInstance,
        &KSPROPSETID_Topology,
        KSPROPERTY_TOPOLOGY_NODES,
        0,                              // 0 extra input bytes
        NULL,                           // No input data
        0,                              // Flags
        &pNodes
        );
    if( !NT_SUCCESS( Status ) ) {
        AudioFreeMemory_Unknown( &pCategories );
        RETURN( Status );
    }

    //
    // Get the list of connections in the meta-topology
    //

    Status = kmxlGetProperty(
        pfoInstance,
        &KSPROPSETID_Topology,
        KSPROPERTY_TOPOLOGY_CONNECTIONS,
        0,                              // 0 extra input butes
        NULL,                           // No input data
        0,                              // Flags
        &pConnections
        );
    if( !NT_SUCCESS( Status ) ) {
        AudioFreeMemory_Unknown( &pCategories );
        AudioFreeMemory_Unknown( &pNodes );
        RETURN( Status );
    }

    //
    // Fill in the topology structure so this information is available
    // later.  For the Categories and TopologyNodes, the pointers are
    // pointers to a KSMULTIPLE_ITEM structure.  The definition of this
    // is that the data will follow immediately after the structure.
    //

    pTopology->CategoriesCount          = pCategories->Count;
    pTopology->Categories               = ( GUID* )( pCategories + 1 );
    pTopology->TopologyNodesCount       = pNodes->Count;
    pTopology->TopologyNodes            = ( GUID* )( pNodes + 1 );
    pTopology->TopologyConnectionsCount = pConnections->Count;
    pTopology->TopologyConnections      =
        (PKSTOPOLOGY_CONNECTION) ( pConnections + 1 );

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlParseTopology
//
// Loops through all the pins building up lists of sources and
// destinations.  For each source, a child graph is the built.
//
//

NTSTATUS
kmxlParseTopology(
    IN      PMIXEROBJECT pmxobj,
    OUT     NODELIST*    plistSources, // Pointer to the sources list to build
    OUT     NODELIST*    plistDests    // Pointer to the dests list to build
)
{
    NTSTATUS  Status;
    ULONG     cPins,
              PinID;
    PMXLNODE  pTemp;
    NODELIST  listSources = NULL;
    NODELIST  listDests   = NULL;

    ASSERT( pmxobj       );
    ASSERT( plistSources );
    ASSERT( plistDests   );

    PAGED_CODE();

    //
    // Query the number of pins
    //

    DPF(DL_TRACE|FA_MIXER,("Parsing Topology for: %ls",pmxobj->pMixerDevice->DeviceInterface) );
    
    Status = GetPinProperty(
        pmxobj->pfo,
        KSPROPERTY_PIN_CTYPES,
        0,
        sizeof( cPins ),
        &cPins );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,("GetPinProperty CTYPES Failed Status=%X",Status) );
        RETURN( Status );
    }

    DPF(DL_TRACE|FA_MIXER,("Number of Pins %u",cPins));
    //
    // Now scan through each of the pins identifying those that are
    // sources and destinations.
    //

    for( PinID = 0; PinID < cPins; PinID++ ) {
        KSPIN_DATAFLOW      DataFlow;

        //
        // Read the direction of dataflow of this pin.
        //

        Status = GetPinProperty(
            pmxobj->pfo,
            KSPROPERTY_PIN_DATAFLOW,
            PinID,
            sizeof( KSPIN_DATAFLOW ),
            &DataFlow
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,("GetPinProperty DATAFLOW Failed Status=%X",Status) );
            continue;
        }

        //
        // Based on the DataFlow, identify if the pin is a source,
        // a destination, or neither.
        //

        switch( DataFlow ) {

            ///////////////////////////////////////////////////////////
            case KSPIN_DATAFLOW_IN:
            ///////////////////////////////////////////////////////////
            // DATAFLOW_IN pins are sources.                         //
            ///////////////////////////////////////////////////////////

                //
                // Create a new mixer node structure for this source
                // and fill in the known information about it.
                //

                pTemp = kmxlAllocateNode( TAG_AudN_NODE );
                if( !pTemp ) {
                    Status=STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                pTemp->Type = SOURCE;
                pTemp->Id   = PinID;

                //
                // Retrieve the category of this pin and store it away.
                // The return does not need to be checked because the
                // GUID will remain at GUID_NULL and be categorized
                // properly.
                //

                GetPinProperty(
                    pmxobj->pfo,
                    KSPROPERTY_PIN_CATEGORY,
                    PinID,
                    sizeof( pTemp->NodeType ),
                    &pTemp->NodeType
                    );

                DPF(DL_TRACE|FA_MIXER,( "Identified SOURCE Pin %d: %s", PinID,
                             PinCategoryToString( &pTemp->NodeType ) ) );
                //
                // Retrieve the commmunication of this pin and store it away so
                // we can tell if this is a wave out or wave in source
                //

                Status = GetPinProperty(
                                pmxobj->pfo,
                                KSPROPERTY_PIN_COMMUNICATION,
                                PinID,
                                sizeof( pTemp->Communication ),
                                &pTemp->Communication
                                );
                if (!NT_SUCCESS(Status)) {
                    pTemp->Communication = KSPIN_COMMUNICATION_NONE;
                }

                //
                // Add this new source node to the list of source
                // nodes.
                //

                kmxlAddToList( listSources, pTemp );
                break;

            ///////////////////////////////////////////////////////////
            case KSPIN_DATAFLOW_OUT:
            ///////////////////////////////////////////////////////////
            // DATAFLOW_OUT pins are destinations                    //
            ///////////////////////////////////////////////////////////

                //
                // Create a new mixer node structure for this dest
                // and fill in the known information about it.
                //

                pTemp = kmxlAllocateNode( TAG_AudN_NODE );
                if( !pTemp ) {
                    Status=STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                pTemp->Type = DESTINATION;
                pTemp->Id   = PinID;

                //
                // Retrieve the category of this pin and store it away.
                // The return does not need to be checked because the
                // GUID will remain at GUID_NULL and be categorized
                // properly.
                //

                GetPinProperty(
                    pmxobj->pfo,
                    KSPROPERTY_PIN_CATEGORY,
                    PinID,
                    sizeof( pTemp->NodeType ),
                    &pTemp->NodeType
                    );

                DPF(DL_TRACE|FA_MIXER,( "Identified DESTINATION Pin %d: %s", PinID,
                    PinCategoryToString( &pTemp->NodeType ) ) );

                //
                // Retrieve the commmunication of this pin and store it away so
                // we can tell if this is a wave out or wave in destination
                //

                Status = GetPinProperty(
                                pmxobj->pfo,
                                KSPROPERTY_PIN_COMMUNICATION,
                                PinID,
                                sizeof( pTemp->Communication ),
                                &pTemp->Communication
                                );
                if (!NT_SUCCESS(Status)) {
                    pTemp->Communication = KSPIN_COMMUNICATION_NONE;
                }

                //
                // Add this new destination node to the list of destination
                // nodes.
                //

                kmxlAddToList( listDests, pTemp );
                break;

            ///////////////////////////////////////////////////////////
            default:
            ///////////////////////////////////////////////////////////
            // DATAFLOW_BOTH and others are currently not supported. //
            ///////////////////////////////////////////////////////////

                DPF(DL_WARNING|FA_USER,("Invalid DataFlow value =%X",DataFlow) );
        }

    }

    DPF(DL_TRACE|FA_MIXER,("DataFlow done. PIN_COMMUNICATION read.") );
    //
    // For each source found, build the graphs of their children.  This
    // will recurse builing the graph of the children's children, etc.
    //

    pTemp = kmxlFirstInList( listSources );
    while( pTemp ) {

        Status=kmxlBuildChildGraph(
            pmxobj,                 // The mixer object
            listDests,              // The list of all the destinations
            pTemp,                  // The source node to build the graph for
            KSFILTER_NODE,          // Sources are always KSFILTER_NODEs
            pTemp->Id               // The Pin id of the source
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_USER,("kmxlBuildChildGraph failed Status=%X",Status) );
            goto exit;
            }

        pTemp = kmxlNextNode( pTemp );

    }

exit:

    //
    // Finally fill in the client pointers
    //

    *plistSources = listSources;
    *plistDests   = listDests;

    //We must have a destination and a source

    if (listSources == NULL || listDests == NULL)
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return Status;
}

///////////////////////////////////////////////////////////////////////
//
// BuildChildGraph
//
// Builds the graph of the child of the given node.  For each child
// of the node, it recurses to find their child, etc.
//
//

NTSTATUS
kmxlBuildChildGraph(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST    listDests,     // The list of destinations
    IN PMXLNODE    pNode,         // The node to build the graph for
    IN ULONG       FromNode,      // The node's ID
    IN ULONG       FromNodePin    // The Pin connection to look for
)
{
    ULONG        Index         = 0;
    PMXLNODE     pNewNode      = NULL;
    PMXLNODE     pTemp         = NULL;
    BOOL         bEndOfTheLine = FALSE;
    PEERNODE*    pPeerNode     = NULL;
    NTSTATUS     Status=STATUS_SUCCESS;

    PAGED_CODE();

        //
        // Find the index of the requested connection.  A return of -1
        // indicates that the connection was not found.  Searches start
        // at Index, which starts with 0 and is > 0 if the last was a match.
        //

    while ( (Index = kmxlFindTopologyConnection(pmxobj, Index, FromNode, FromNodePin))
            != (ULONG) -1) {

        //
        // Check to see if this connection is a KSFILTER_NODE.  That will
        // indicate that it's connected to a destination and not another node.
        //

        if( pmxobj->pTopology->TopologyConnections[ Index ].ToNode == KSFILTER_NODE ) {

            //
            // Find the destination node so that the parent field can be
            // updated to include this node.  bEndOfTheLine is set to TRUE
            // since there can be no other connections after the destination.
            //

            pNewNode = kmxlFindDestination(
                listDests,
                pmxobj->pTopology->TopologyConnections[ Index ].ToNodePin
                );

            bEndOfTheLine = TRUE;

            //
            // We better find a destination; if not, something's really wrong.
            //

            if (pNewNode==NULL) {
                RETURN( STATUS_UNSUCCESSFUL );
                }

        } else {

            //
            // Using the identifier stored in the ToNode of the topology
            // connections, index into the node table and retrieve the
            // mixer node associated with that id.
            //

            pNewNode = &pmxobj->pNodeTable[
                pmxobj->pTopology->TopologyConnections[ Index ].ToNode
                ];

            //
            // Fill in a couple of missing details.  Note that these details
            // may already be filled in but it doesn't hurt to overwrite
            // them with the same values.
            //

            pNewNode->Type = NODE;
            pNewNode->Id   = pmxobj->pTopology->TopologyConnections[ Index ].ToNode;
        }

        //
        // Insert the new node into the childlist of the current node only
        // if it isn't already there.  It only wastes memory to add it more
        // than once and prevents the proper updating of the child and parent
        // lists.
        //


        if( !kmxlInChildList( pNode, pNewNode ) ) {
            pPeerNode = kmxlAllocatePeerNode( pNewNode, TAG_Audn_PEERNODE );
            if( !pPeerNode ) {
                RETURN( STATUS_INSUFFICIENT_RESOURCES );
            }

            DPF(DL_TRACE|FA_MIXER,( "Added %s(%d-0x%08x) to child list of %s(%d-0x%08x).",
                    pPeerNode->pNode->Type == SOURCE      ? "SOURCE" :
                    pPeerNode->pNode->Type == DESTINATION ? "DEST"   :
                    pPeerNode->pNode->Type == NODE        ? "NODE"   :
                        "Huh?",
                    pPeerNode->pNode->Id,
                    pPeerNode,
                    pNode->Type == SOURCE      ? "SOURCE" :
                    pNode->Type == DESTINATION ? "DEST"   :
                    pNode->Type == NODE        ? "NODE"   :
                        "Huh?",
                    pNode->Id,
                    pNode ) );

            kmxlAddToChildList( pNode, pPeerNode );
        }

        //
        // Insert the new node into the parentlist of the new node only
        // if it isn't already there.  It only wastes memory to add it more
        // than once and prevents the proper updating the child and parent
        // lists.
        //

        if( !kmxlInParentList( pNewNode, pNode ) ) {
            pPeerNode = kmxlAllocatePeerNode( pNode, TAG_Audn_PEERNODE );
            if( !pPeerNode ) {
                RETURN( STATUS_INSUFFICIENT_RESOURCES );
            }

            DPF(DL_TRACE|FA_MIXER,("Added %s(%d-0x%08x) to parent list of %s(%d-0x%08x).",
                    pPeerNode->pNode->Type == SOURCE      ? "SOURCE" :
                    pPeerNode->pNode->Type == DESTINATION ? "DEST"   :
                    pPeerNode->pNode->Type == NODE        ? "NODE"   :
                        "Huh?",
                    pPeerNode->pNode->Id,
                    pPeerNode,
                    pNewNode->Type == SOURCE      ? "SOURCE" :
                    pNewNode->Type == DESTINATION ? "DEST"   :
                    pNewNode->Type == NODE        ? "NODE"   :
                        "Huh?",
                    pNewNode->Id,
                    pNewNode ) );
            

            kmxlAddToParentList( pNewNode, pPeerNode );
        }

        //
        // Skip past the connection we just processed.
        //

        ++Index;

    } // Loop until FindConnection fails.

    //
    // The last connection found connects to a destination node.  Do not
    // try to enumerate the children, since there are none.
    //

    if( bEndOfTheLine ) {
        RETURN( Status );
    }

    //
    // For each of the children of this node, recurse to build up the lists
    // of the child's nodes.
    //

    pPeerNode = kmxlFirstChildNode( pNode );
    while( pPeerNode ) {

        Status = kmxlBuildChildGraph(            
            pmxobj,
            listDests,            // The list of destination nodes
            pPeerNode->pNode,     // The parent node
            pPeerNode->pNode->Id, // The Id of the parent
            PINID_WILDCARD        // Look for any connection by this node
            );

        if (!NT_SUCCESS(Status)) {
            break;
            }

        pPeerNode = kmxlNextPeerNode( pPeerNode );
    }

    RETURN( Status );

}


///////////////////////////////////////////////////////////////////////
//
// BuildNodeTable
//
// Allocates enough memory to hold TopologyNodeCount MXLNODE structures.
// The GUIDs from the Topology are copied over into the MXLNODE structures.
//
//

PMXLNODE
kmxlBuildNodeTable(
    IN PKSTOPOLOGY pTopology  // The topology structure
)
{
    PMXLNODE pTable = NULL;
    ULONG    i;

    ASSERT( pTopology );

    PAGED_CODE();

    //
    // If we don't have any node count, we don't want to allocate a zero byte buffer.
    // simply return the error case.
    //

    if( 0 == pTopology->TopologyNodesCount )
    {
        return NULL;
    }

    //
    // Allocate an array of nodes the same size as the Topology Node
    // table.
    //

    if( !NT_SUCCESS( AudioAllocateMemory_Paged(pTopology->TopologyNodesCount * sizeof( MXLNODE ),
                                               TAG_AudN_NODE,
                                               ZERO_FILL_MEMORY,
                                               &pTable) ) ) 
    {
        return( NULL );
    }

    //
    // Initialize the nodes.  All the can be filled in here is the GUIDs,
    // copied from the node table.
    //

    for( i = 0; i < pTopology->TopologyNodesCount; i++ ) {
        pTable[ i ].NodeType = pTopology->TopologyNodes[ i ];
    }

    return( pTable );
}

///////////////////////////////////////////////////////////////////////
//
// FindTopologyConnection
//
// Scans through the connection table looking for a connection that
// matches the FromNode/FromNodePin criteria.
//
//

ULONG
kmxlFindTopologyConnection(
    IN PMIXEROBJECT pmxobj,
    IN ULONG                        StartIndex,     // Index to start search
    IN ULONG                        FromNode,       // The Node ID to look for
    IN ULONG                        FromNodePin     // The Pin ID to look for
)
{
    ULONG i;

    PAGED_CODE();
    for( i = StartIndex; i < pmxobj->pTopology->TopologyConnectionsCount; i++ ) {
        if( ( ( pmxobj->pTopology->TopologyConnections[ i ].FromNode    == FromNode       )||
              ( FromNode    == PINID_WILDCARD ) ) &&
            ( ( pmxobj->pTopology->TopologyConnections[ i ].FromNodePin == FromNodePin )   ||
              ( FromNodePin == PINID_WILDCARD ) ) ) {
            //#ifdef PARSE_TRACE
            //TRACE( "WDMAUD: Found connection from (%d,%d) -> %d.\n",
            //    FromNode, FromNodePin, i );
            //#endif
            return( i );
        }
    }
    return( (ULONG) -1 );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetProperty
//
// Queries a property by first determining the correct number of
// output bytes, allocating that much memory, and quering the
// actual data.
//
//

NTSTATUS
kmxlGetProperty(
    PFILE_OBJECT pFileObject,       // The instance of the filter
    CONST GUID   *pguidPropertySet, // The requested property set
    ULONG        ulPropertyId,      // The ID of the specific property
    ULONG        cbInput,           // The number of extra input bytes
    PVOID        pInputData,        // Pointer to the extra input bytes
    ULONG        Flags,             // Additional flags
    PVOID        *ppPropertyOutput  // Pointer to a pointer of the output
)
{
    ULONG       BytesReturned;
    ULONG       cbPropertyInput = sizeof(KSPROPERTY);
    PKSPROPERTY pPropertyInput = NULL;
    NTSTATUS    Status;

    PAGED_CODE();

    ASSERT( pFileObject );

    //
    // Allocate enough memory for the KSPROPERTY structure and any additional
    // input the callers wants to include.
    //

    cbPropertyInput += cbInput;
    Status = AudioAllocateMemory_Paged(cbPropertyInput,
                                       TAG_AudV_PROPERTY,
                                       ZERO_FILL_MEMORY,
                                       &pPropertyInput );
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Set up the field of the KSPROPERTY structure
    //

    pPropertyInput->Set   = *pguidPropertySet;
    pPropertyInput->Id    = ulPropertyId;
    pPropertyInput->Flags = KSPROPERTY_TYPE_GET | Flags;

    //
    // Copy the additional input from the caller.
    //

    if(pInputData != NULL) {
        RtlCopyMemory(pPropertyInput + 1, pInputData, cbInput);
    }

    //
    // This first call will query the number of bytes the output needs.
    //
    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY pPropertyInput=%X",pPropertyInput) );

    Status = KsSynchronousIoControlDevice(
        pFileObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        pPropertyInput,
        cbPropertyInput,
        NULL,
        0,
        &BytesReturned
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Status=%X",Status) );

    ASSERT(!NT_SUCCESS(Status));
    if(Status != STATUS_BUFFER_OVERFLOW) {
        goto exit;
    }

    if(BytesReturned == 0) {
        *ppPropertyOutput = NULL;
        Status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Allocate enough memory to hold all of the output.
    //

    Status = AudioAllocateMemory_Paged(BytesReturned,
                                       TAG_Audv_PROPERTY,
                                       ZERO_FILL_MEMORY | LIMIT_MEMORY,
                                       ppPropertyOutput );
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Now actually get the output data.
    //
    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY pPropertyInput=%X",pPropertyInput) );

    Status = KsSynchronousIoControlDevice(
        pFileObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        pPropertyInput,
        cbPropertyInput,
        *ppPropertyOutput,
        BytesReturned,
        &BytesReturned
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Status=%X",Status) );

    if(!NT_SUCCESS(Status)) {
        AudioFreeMemory_Unknown(ppPropertyOutput);
        goto exit;
    }

exit:

    AudioFreeMemory_Unknown(&pPropertyInput);
    if(!NT_SUCCESS(Status)) {
        *ppPropertyOutput = NULL;
        DPF(DL_WARNING|FA_USER,("Failed to get Property Status=%X",Status) );
    }
    RETURN(Status);
}

///////////////////////////////////////////////////////////////////////
//
// kmxlNodeProperty
//
// Creates a KSNODEPROPERTY structure with additional input data
// after it and uses KsSychronousIoControlDevice() to query or set the
// property.  Only memory for the input is allocated here.
//
//

NTSTATUS
kmxlNodeProperty(
    IN  PFILE_OBJECT pFileObject,       // Instance of the filter owning node
    IN  CONST GUID*  pguidPropertySet,  // The GUID of the property set
    IN  ULONG        ulPropertyId,      // The specific property in the set
    IN  ULONG        ulNodeId,          // The virtual node id
    IN  ULONG        cbInput,           // # of extra input bytes
    IN  PVOID        pInputData,        // Pointer to the extra input bytes
    OUT PVOID        pPropertyOutput,   // Pointer to the output data
    IN  ULONG        cbPropertyOutput,  // Size of the output data buffer
    IN  ULONG        Flags              // KSPROPERTY_TYPE_GET or SET
)
{
    NTSTATUS        Status;
    KSNODEPROPERTY  NodeProperty;
    ULONG           cbPropertyIn = sizeof( KSNODEPROPERTY );
    PKSNODEPROPERTY pInData = NULL;
    ULONG           BytesReturned;

    PAGED_CODE();

    ASSERT( pFileObject );
    ASSERT( pguidPropertySet );

    if( cbInput > 0 ) {

        //
        // If the caller passed in some extra input, add that size
        // to the size of the required KSNODEPROPERTY and allocate
        // a chunk of memory.
        //

        cbPropertyIn += cbInput;
        Status = AudioAllocateMemory_Paged(cbPropertyIn,
                                           TAG_AudU_PROPERTY,
                                           ZERO_FILL_MEMORY,
                                           &pInData );
        if( !NT_SUCCESS( Status ) ) {
            goto exit;
        }

        RtlCopyMemory( pInData + 1, pInputData, cbInput );

    } else {

        pInData = &NodeProperty;

    }

    //
    // Fill in the property and node information.
    //

    pInData->Property.Set   = *pguidPropertySet;
    pInData->Property.Id    = ulPropertyId;
    pInData->Property.Flags = Flags |
                              KSPROPERTY_TYPE_TOPOLOGY;
    pInData->NodeId         = ulNodeId;
    pInData->Reserved       = 0;

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY pInData=%X",pInData) );

    Status = KsSynchronousIoControlDevice(
        pFileObject,            // The FILE_OBJECT for SysAudio
        KernelMode,             // Call originates in Kernel mode
        IOCTL_KS_PROPERTY,      // KS PROPERTY IOCTL
        pInData,                // Pointer to the KSNODEPROPERTY struct
        cbPropertyIn,           // Number or bytes input
        pPropertyOutput,        // Pointer to the buffer to store output
        cbPropertyOutput,       // Size of the output buffer
        &BytesReturned          // Number of bytes returned from the call
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Status=%X",Status) );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

exit:

    //
    // If the user passed in extra byte, we allocated memory to hold them.
    // Now the memory must be deallocated.
    //

    if( cbInput > 0 ) {
        AudioFreeMemory_Unknown( &pInData );
    }

    RETURN( Status );

}

///////////////////////////////////////////////////////////////////////
//
// kmxlAudioNodeProperty
//
// Similar to kmxlNodeProperty except for the property set is assumed
// to be KSPROPSETID_Audio and a KSNODEPROPERTY_AUDIO_CHANNEL structure
// is used instead of KSNODEPROPERTY to allow channel selection.
//
//

NTSTATUS
kmxlAudioNodeProperty(
    IN  PFILE_OBJECT pfo,               // Instance of the filter owning node
    IN  ULONG        ulPropertyId,      // The audio property to get
    IN  ULONG        ulNodeId,          // The virtual node id
    IN  LONG         lChannel,          // The channel number
    IN  PVOID        pInData,           // Pointer to extra input bytes
    IN  ULONG        cbInData,          // Number of extra input bytes
    OUT PVOID        pOutData,          // Pointer to output buffer
    IN  LONG         cbOutData,         // Size of the output buffer
    IN  ULONG        Flags              // KSPROPERTY_TYPE_GET or SET
)
{
    NTSTATUS                      Status;
    KSNODEPROPERTY_AUDIO_CHANNEL  Channel;
    PKSNODEPROPERTY_AUDIO_CHANNEL pInput = NULL;
    ULONG                         cbInput;
    ULONG                         BytesReturned;

    PAGED_CODE();

    ASSERT( pfo );

    //
    // Determine the minimum number of input bytes
    //

    cbInput = sizeof( KSNODEPROPERTY_AUDIO_CHANNEL );

    //
    // If the caller passed in additional data, allocate enough memory
    // to hold the KSNODEPROPERTY_AUDIO_CHANNEL plus the input bytes
    // and copy the input bytes into the new memory immediately after
    // the KSNODEPROPERTY_AUDIO_CHANNEL structure.
    //

    if( cbInData > 0 ) {

        cbInput += cbInData;
        Status = AudioAllocateMemory_Paged(cbInput,
                                           TAG_Audu_PROPERTY,
                                           ZERO_FILL_MEMORY,
                                           &pInput );
        if( !NT_SUCCESS( Status ) ) {
            goto exit;
        }

        RtlCopyMemory( pInput + 1, pInData, cbInData );

    } else {

        //
        // Memory saving hack... if the user didn't give any additional
        // bytes, just point to memory on the stack.
        //

        pInput = &Channel;

    }

    //
    // Fill in the property fields.
    //

    pInput->NodeProperty.Property.Set   = KSPROPSETID_Audio;
    pInput->NodeProperty.Property.Id    = ulPropertyId;
    pInput->NodeProperty.Property.Flags = Flags |
                                          KSPROPERTY_TYPE_TOPOLOGY;

    //
    // Fill in the node details.
    //

    pInput->NodeProperty.NodeId         = ulNodeId;
    pInput->NodeProperty.Reserved       = 0;

    //
    // Fill in the channel details.
    //

    pInput->Channel                     = lChannel;
    pInput->Reserved                    = 0;

    //
    // And execute the property.
    //
    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY pInput=%X",pInput) );

    Status = KsSynchronousIoControlDevice(
        pfo,                            // The FILE_OBJECT for SysAudio
        KernelMode,                     // Call originates in Kernel mode
        IOCTL_KS_PROPERTY,              // KS PROPERTY IOCTL
        pInput,                         // Pointer to the KSNODEPROPERTY struct
        cbInput,                        // Number or bytes input
        pOutData,                       // Pointer to the buffer to store output
        cbOutData,                      // Size of the output buffer
        &BytesReturned                  // Number of bytes returned from the call
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY result=%X",Status) );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

exit:

    //
    // If the user passed in extra bytes, we allocated memory to hold them.
    // Now the memory must be deallocated.
    //

    if( cbInData > 0 ) {
        AudioFreeMemory_Unknown( &pInData );
    }

    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetPinName
//
// Calls GetPinPropertyEx to guery and allocate memory for the pin
// name.  If that call fails, a default name is copy based on the
// pin type.
//
// The short name is made identical to the long name, but using only
// the first sizeof( szShortName ) / sizeof( WCHAR ) characters.
//
//

VOID
kmxlGetPinName(
    IN PFILE_OBJECT pfo,                // Instance of the owning filter
    IN ULONG        PinId,              // Id of the pin
    IN PMXLLINE     pLine               // The line to store the name into
)
{
    WCHAR*    szName = NULL;
    NTSTATUS  Status;
    KSP_PIN   Pin;
    ULONG     BytesReturned = 0;
    ULONG     BytesReturned2 = 0;

    PAGED_CODE();
    Pin.Property.Set    = KSPROPSETID_Pin;
    Pin.Property.Id     = KSPROPERTY_PIN_NAME;
    Pin.Property.Flags  = KSPROPERTY_TYPE_GET;
    Pin.PinId           = PinId;
    Pin.Reserved        = 0;

    //
    // Query to see how many bytes of storage we need to allocate.
    // Note that the pointer and number of bytes must both be zero
    // or this will fail!
    //
    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Pin=%X",&Pin) );

    Status = KsSynchronousIoControlDevice(
        pfo,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(KSP_PIN),
        NULL,
        0,
        &BytesReturned
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY result=%X",Status) );

    ASSERT(!NT_SUCCESS(Status));
    if( Status != STATUS_BUFFER_OVERFLOW  ) {
        goto exit;
    }

    //
    // Allocate what was returned.
    //

    Status = AudioAllocateMemory_Paged(BytesReturned,
                                       TAG_Audp_NAME,
                                       ZERO_FILL_MEMORY | LIMIT_MEMORY,
                                       &szName );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,("Setting Default szName") );
        goto exit;
    }

    //
    // Call again to get the pin name.  
    //
    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Pin=%X",&Pin) );

    BytesReturned2=BytesReturned;
    Status = KsSynchronousIoControlDevice(
        pfo,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(KSP_PIN),
        szName,
        BytesReturned2,
        &BytesReturned2
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY result=%X",Status) );

    //
    // If successful, copy as much of the name that will fit into the
    // short name and name fields of the line.
    //

    if( NT_SUCCESS( Status ) && szName ) {
#ifdef DEBUG
        //
        // There is no good reason that I can think of for a driver to return 
        // a different return value the second time it's called.  That would just
        // be stupid.
        //
        if( BytesReturned != BytesReturned2 )
        {
            DPF(DL_WARNING|FA_SYSAUDIO,("Unequal returns! BR=%08x,BR2=%08x",BytesReturned,BytesReturned2));
        }
        //
        // Let's explicitly look for the case that made this driver fault.  The
        // BytesReturned value was 8 and it contained MUX\0 in the buffer.  The problem
        // was that wcsncpy walked MIXER_SHORT_NAME_CHARS number of characters.
        // Thus it walked off the end of the source buffer.
        //
        if( (BytesReturned/sizeof(WCHAR) < MIXER_SHORT_NAME_CHARS) && 
            (szName[BytesReturned/sizeof(WCHAR)-1] != (WCHAR)NULL) )
        {
            DPF(DL_ERROR|FA_SYSAUDIO,("Hit short name assert! BR=%08x",BytesReturned));
        }
#endif
        wcsncpy(
            pLine->Line.szShortName,
            szName,
            min(BytesReturned/sizeof(WCHAR),MIXER_SHORT_NAME_CHARS)
            );
        pLine->Line.szShortName[ min(BytesReturned/sizeof(WCHAR),MIXER_SHORT_NAME_CHARS) - 1 ] = (WCHAR)NULL;
        wcsncpy(
            pLine->Line.szName,
            szName,
            min(BytesReturned/sizeof(WCHAR),MIXER_LONG_NAME_CHARS) );
        pLine->Line.szName[ min(BytesReturned/sizeof(WCHAR),MIXER_LONG_NAME_CHARS) - 1 ] = (WCHAR)NULL;
        AudioFreeMemory_Unknown( &szName );
        return;
    }

    AudioFreeMemory_Unknown( &szName );

exit:

    //
    // The pin doesn't support the property.  Copy in a good default.
    //

    CopyAnsiStringtoUnicodeString(
        pLine->Line.szName,
        PinCategoryToString( &pLine->Type ),
        min(MIXER_LONG_NAME_CHARS, strlen(PinCategoryToString(&pLine->Type)) + 1)
        );

    wcsncpy(
        pLine->Line.szShortName,
        pLine->Line.szName,
        MIXER_SHORT_NAME_CHARS
        );
    pLine->Line.szShortName[ MIXER_SHORT_NAME_CHARS - 1 ] = 0x00;

}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNodeName
//
// Retrieves the name of a node (control).
//
//

VOID
kmxlGetNodeName(
    IN PFILE_OBJECT pfo,                // Instance of the owning filter
    IN ULONG        NodeId,             // The node id
    IN PMXLCONTROL  pControl            // The control to store the name
)
{
    NTSTATUS Status;
    LONG     cbName=0;
    WCHAR*   szName = NULL;
    KSNODEPROPERTY NodeProperty;

    PAGED_CODE();
    ASSERT( pfo );
    ASSERT( pControl );

    //
    // Query the number of bytes the node name is
    //

    NodeProperty.Property.Set   = KSPROPSETID_Topology;
    NodeProperty.Property.Id    = KSPROPERTY_TOPOLOGY_NAME;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET |
                                  KSPROPERTY_TYPE_TOPOLOGY;
    NodeProperty.NodeId         = NodeId;
    NodeProperty.Reserved       = 0;

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Node=%X",&NodeProperty) );

    Status = KsSynchronousIoControlDevice(
        pfo,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &NodeProperty,
        sizeof( NodeProperty ),
        NULL,
        0,
        &cbName
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY result=%X",Status) );

    if( ( Status == STATUS_BUFFER_OVERFLOW  ) ||
        ( Status == STATUS_BUFFER_TOO_SMALL ) ) {

        //
        // Allocate enough space to hold the entire name
        //

        if( !NT_SUCCESS( AudioAllocateMemory_Paged(cbName, 
                                                   TAG_Audp_NAME,
                                                   ZERO_FILL_MEMORY | LIMIT_MEMORY,
                                                   &szName ) ) ) 
        {
            goto exit;
        }

        ASSERT( szName );

        //
        // Requery for the name with the previously allocated buffer.
        //
        Status = kmxlNodeProperty(
            pfo,
            &KSPROPSETID_Topology,
            KSPROPERTY_TOPOLOGY_NAME,
            NodeId,
            0,
            NULL,
            szName,
            cbName,
            KSPROPERTY_TYPE_GET
        );
        if( NT_SUCCESS( Status ) && szName ) {

            //
            // Copy the names retrieved into the szShortName and Name
            // fields of the control.  The short name is just a shortened
            // version of the full name.
            //
            //
            // Note: cbName is a byte value and wcsncpy takes a count of characters,
            // We are dealing with wide characters, thus we must adjust the
            // memory size to characters!  Note that the driver could have
            // returned a source buffer less then MIXER_SHORT_NAME_CHARS in length!
            //
#ifdef DEBUG
            if( (cbName/sizeof(WCHAR) < MIXER_SHORT_NAME_CHARS) && 
                (szName[cbName/sizeof(WCHAR)-1] != (WCHAR)NULL) )
            {
                DPF(DL_ERROR|FA_SYSAUDIO,("Hit short name assert! cbName=%08x",cbName));
            }
#endif

            wcsncpy(
                pControl->Control.szShortName,
                szName,
                min(cbName/sizeof(WCHAR),MIXER_SHORT_NAME_CHARS)
                );
            pControl->Control.szShortName[ min(cbName/sizeof(WCHAR),MIXER_SHORT_NAME_CHARS) - 1 ] = (WCHAR)NULL;
            wcsncpy(
                pControl->Control.szName,
                szName,
                min(cbName/sizeof(WCHAR),MIXER_LONG_NAME_CHARS) );
            pControl->Control.szName[ min(cbName/sizeof(WCHAR),MIXER_LONG_NAME_CHARS) - 1 ] = (WCHAR)NULL;
            AudioFreeMemory_Unknown( &szName );
            return;
        }
    }


    //
    // Looks like we might leak memory on the error condition.  See
    // kmxlGetPinName above!
    //
    AudioFreeMemory_Unknown( &szName );
exit:

    //
    // The node doesn't support the property.  Copy in a good default.
    //

    CopyAnsiStringtoUnicodeString(
        pControl->Control.szName,
        NodeTypeToString( pControl->NodeType ),
        min(MIXER_LONG_NAME_CHARS, strlen(NodeTypeToString(pControl->NodeType)) + 1)
        );

    wcsncpy(
        pControl->Control.szShortName,
        pControl->Control.szName,
        MIXER_SHORT_NAME_CHARS
        );
    pControl->Control.szShortName[ MIXER_SHORT_NAME_CHARS - 1 ] = 0x00;

}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetSuperMixCaps
//
//

NTSTATUS
kmxlGetSuperMixCaps(
    IN PFILE_OBJECT        pfo,
    IN ULONG               ulNodeId,
    OUT PKSAUDIO_MIXCAP_TABLE* paMixCaps
)
{
    NTSTATUS Status;
    ULONG Size;
    struct {
        ULONG InputChannels;
        ULONG OutputChannels;
    } SuperMixSize;
    PKSAUDIO_MIXCAP_TABLE pMixCaps = NULL;

    PAGED_CODE();

    ASSERT( pfo );
    ASSERT( paMixCaps );

    *paMixCaps = NULL;

    //
    // Query the node with just the first 2 DWORDs of the MIXCAP table.
    // This will return the dimensions of the supermixer.
    //

    Status = kmxlNodeProperty(
        pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
        ulNodeId,
        0,
        NULL,
        &SuperMixSize,
        sizeof( SuperMixSize ),
        KSPROPERTY_TYPE_GET
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_MIXER,( "kmxlNodeProperty failed with %X!", Status ) );
        RETURN( Status );
    }

    //
    // Allocate a MIXCAPS table big enough to hold all the entires.
    // The size needs to include the first 2 DWORDs in the MIXCAP
    // table besides the array ( InputCh * OutputCh ) of MIXCAPs
    //

    Size = sizeof( SuperMixSize ) +
           SuperMixSize.InputChannels * SuperMixSize.OutputChannels *
           sizeof( KSAUDIO_MIX_CAPS );

    Status = AudioAllocateMemory_Paged(Size,
                                       TAG_AudS_SUPERMIX,
                                       ZERO_FILL_MEMORY | LIMIT_MEMORY,
                                       &pMixCaps );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_MIXER,( "failed to allocate caps memory!" ) );
        RETURN( Status );
    }

    //
    // Query the node once again to fill in the MIXCAPS structures.
    //

    Status = kmxlNodeProperty(
        pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
        ulNodeId,
        0,
        NULL,
        pMixCaps,
        Size,
        KSPROPERTY_TYPE_GET
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_PROPERTY ,( "kmxlNodeProperty failed with %X!", Status ) );
        AudioFreeMemory( Size,&pMixCaps );
        RETURN( Status );
    }

    *paMixCaps = pMixCaps;
    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlQueryPropertyRange
//
//

NTSTATUS
kmxlQueryPropertyRange(
    IN  PFILE_OBJECT             pfo,
    IN  CONST GUID*              pguidPropSet,
    IN  ULONG                    ulPropertyId,
    IN  ULONG                    ulNodeId,
    OUT PKSPROPERTY_DESCRIPTION* ppPropDesc
)
{
    NTSTATUS                Status;
    KSNODEPROPERTY          NodeProperty;
    KSPROPERTY_DESCRIPTION  PropertyDescription;
    PKSPROPERTY_DESCRIPTION pPropDesc = NULL;
    ULONG                   BytesReturned;

    PAGED_CODE();
    //
    // We don't want to allocate some arbitrary memory size if the driver
    // does not set this value.
    //
    PropertyDescription.DescriptionSize=0;

    NodeProperty.Property.Set   = *pguidPropSet;
    NodeProperty.Property.Id    = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT |
                                  KSPROPERTY_TYPE_TOPOLOGY;
    NodeProperty.NodeId         = ulNodeId;
    NodeProperty.Reserved       = 0;

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Query Node=%X",&NodeProperty) );

    Status = KsSynchronousIoControlDevice(
        pfo,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &NodeProperty,
        sizeof( NodeProperty ),
        &PropertyDescription,
        sizeof( PropertyDescription ),
        &BytesReturned
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY result=%X",Status) );

    if( !NT_SUCCESS( Status ) ) {
        RETURN( Status );
    }
    //
    // Never use a buffer that is smaller then we think it should be!
    //
    if( PropertyDescription.DescriptionSize < sizeof(KSPROPERTY_DESCRIPTION) )
    {
#ifdef DEBUG
        DPF(DL_ERROR|FA_ALL,("KSPROPERTY_DESCRIPTION.DescriptionSize!>=sizeof(KSPROPERTY_DESCRIPTION)") );
#endif
        RETURN(STATUS_INVALID_PARAMETER);
    }

    Status = AudioAllocateMemory_Paged(PropertyDescription.DescriptionSize,
                                       TAG_Auda_PROPERTY,
                                       ZERO_FILL_MEMORY | LIMIT_MEMORY,
                                       &pPropDesc );
    if( !NT_SUCCESS( Status ) ) {
        RETURN( Status );
    }

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Get Node=%X",&NodeProperty) );

    Status = KsSynchronousIoControlDevice(
        pfo,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &NodeProperty,
        sizeof( NodeProperty ),
        pPropDesc,
        PropertyDescription.DescriptionSize,
        &BytesReturned
        );

    DPF(DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY result=%X",Status) );

    if( !NT_SUCCESS( Status ) ) {
        AudioFreeMemory( PropertyDescription.DescriptionSize,&pPropDesc );
        RETURN( Status );
    }

    *ppPropDesc = pPropDesc;
    return( STATUS_SUCCESS );
}


///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlChannels
//
//

NTSTATUS
kmxlGetControlChannels(
    IN PFILE_OBJECT pfo,
    IN PMXLCONTROL  pControl
)
{
    NTSTATUS                  Status;
    PKSPROPERTY_DESCRIPTION   pPropDesc = NULL;
    PKSPROPERTY_MEMBERSHEADER pMemberHeader;
    PCHANNEL_STEPPING         pChannelStepping;
    ULONG                     i;

    PAGED_CODE();

    Status = kmxlQueryPropertyRange(
        pfo,
        &KSPROPSETID_Audio,
        pControl->PropertyId,
        pControl->Id,
        &pPropDesc
        );

    //
    // Do some checking on the returned value.  Look for things that we
    // support.
    //
    if ( NT_SUCCESS(Status) ) {
        ASSERT(pPropDesc);
        pMemberHeader = (PKSPROPERTY_MEMBERSHEADER) ( pPropDesc + 1 );
#ifdef DEBUG
        //
        // If the MembersListCount is greater then zero and the GUID's are equal
        // then we will reference the pMemberHeader value that we create here.
        // If we do, then we must make sure that the memory that we allocated
        // is large enough to handle it!
        //
        if( ( pPropDesc->MembersListCount > 0 ) &&
            (IsEqualGUID( &pPropDesc->PropTypeSet.Set, &KSPROPTYPESETID_General )) )
        {
            //
            // if this is the case, we will touch the pMemberHeader->MembersCount
            // field.
            //
            if (pPropDesc->DescriptionSize < (sizeof(KSPROPERTY_DESCRIPTION) + 
                                              sizeof(KSPROPERTY_MEMBERSHEADER)) )
            {
                DPF(DL_ERROR|FA_ALL,("Incorrectly reported DescriptionSize in KSPROPERTY_DESCRIPTION structure") );
                RETURN(STATUS_INVALID_PARAMETER);
            }
        }
#endif
    }

    if( ( NT_SUCCESS( Status )                                                ) &&
        ( pPropDesc->MembersListCount > 0                                     ) &&
        ( IsEqualGUID( &pPropDesc->PropTypeSet.Set, &KSPROPTYPESETID_General )) &&
        ( pMemberHeader->MembersCount > 0                                     ) &&
        ( pMemberHeader->Flags & KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL ) )
    {
        //
        // Volume controls may either be of MIXERTYPE_CONTROLF_UNIFORM
        // or not.  Uniform controls adjust all channels (or are mono
        // in the first place) with one control.  Those that have the
        // fdwControl field set to 0 can set all channels of the volume
        // independently.  This information will have to come from the
        // node itself, by checking to see if the node uniform control.
        //

        pControl->NumChannels = pMemberHeader->MembersCount;

        if( (pMemberHeader->Flags & KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM) ||
            (pMemberHeader->MembersCount == 1) ) {
            pControl->Control.fdwControl = MIXERCONTROL_CONTROLF_UNIFORM;
        }
    }
    else {

        // Fall through to using the old method which checks if volume is supported on
        // each channel one at a time
        Status = kmxlSupportsMultiChannelControl(pfo,
                                                 pControl->Id,
                                                 pControl->PropertyId);
        if (NT_SUCCESS(Status)) {
            pControl->NumChannels = 2; // we have stereo
            pControl->Control.fdwControl = 0;
        } else {
            pControl->NumChannels = 1; // we have mono or master channel
            pControl->Control.fdwControl = MIXERCONTROL_CONTROLF_UNIFORM;
        }
    }

    // Done with the pPropDesc
    AudioFreeMemory_Unknown( &pPropDesc );

    ASSERT(pControl->NumChannels > 0);
    ASSERT(pControl->pChannelStepping == NULL);

    Status = AudioAllocateMemory_Paged(pControl->NumChannels * sizeof( CHANNEL_STEPPING ),
                                       TAG_AuDB_CHANNEL,
                                       ZERO_FILL_MEMORY,
                                       &pControl->pChannelStepping );
    if( !NT_SUCCESS( Status ) ) {
        pControl->NumChannels = 0;
        return( Status );
    }

    // For a failure, set the default range.
    pChannelStepping = pControl->pChannelStepping;
    for (i = 0; i < pControl->NumChannels; i++, pChannelStepping++) {
        pChannelStepping->MinValue = DEFAULT_RANGE_MIN;
        pChannelStepping->MaxValue = DEFAULT_RANGE_MAX;
        pChannelStepping->Steps    = DEFAULT_RANGE_STEPS;
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlRange
//
//

NTSTATUS
kmxlGetControlRange(
    IN PFILE_OBJECT pfo,
    IN PMXLCONTROL  pControl
)
{
    NTSTATUS                  Status;
    PKSPROPERTY_DESCRIPTION   pPropDesc;
    PKSPROPERTY_MEMBERSHEADER pMemberHeader;
    PKSPROPERTY_STEPPING_LONG pSteppingLong;
    PCHANNEL_STEPPING         pChannelStepping;
    ULONG                     i;

    PAGED_CODE();

    //
    // Query the range for this control and initialize pControl in case of failure
    //

    ASSERT( pControl->pChannelStepping == NULL );    
    pControl->pChannelStepping = NULL;

    Status = kmxlQueryPropertyRange(
        pfo,
        &KSPROPSETID_Audio,
        pControl->PropertyId,
        pControl->Id,
        &pPropDesc
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_MIXER,( "Failed to get BASICSUPPORT on control %x!", pControl ) );
        //  If BASICSUPPORT fails, kmxlGetControlChannels to handle the default behavior
        Status = kmxlGetControlChannels( pfo, pControl );
        RETURN( Status );
    }

    //
    // Do some checking on the returned value.  Look for things that we
    // support.
    //

    if( ( pPropDesc->MembersListCount == 0                                      ) ||
        ( !IsEqualGUID( &pPropDesc->PropTypeSet.Set, &KSPROPTYPESETID_General ) ) ||
        ( pPropDesc->PropTypeSet.Id != VT_I4                                    ) )
    {
        AudioFreeMemory_Unknown( &pPropDesc );
        RETURN( STATUS_NOT_SUPPORTED );
    }

    pMemberHeader = (PKSPROPERTY_MEMBERSHEADER) ( pPropDesc + 1 );

#ifdef DEBUG

    //
    // If the MembersListCount is greater then zero and the GUID's are equal
    // then we will reference the pMemberHeader value that we create here.
    // If we do, then we must make sure that the memory that we allocated
    // is large enough to handle it!
    //
    if (pPropDesc->DescriptionSize < (sizeof(KSPROPERTY_DESCRIPTION) + 
                                      sizeof(KSPROPERTY_MEMBERSHEADER)) )
    {
        DPF(DL_ERROR|FA_ALL,("Incorrectly reported DescriptionSize in KSPROPERTY_DESCRIPTION structure") );
        RETURN(STATUS_INVALID_PARAMETER);
    }

#endif

    //
    //  Do some more checking on the returned value.
    //
    if ( (pMemberHeader->MembersCount == 0) ||
         (pMemberHeader->MembersSize != sizeof(KSPROPERTY_STEPPING_LONG)) ||
         (!(pMemberHeader->MembersFlags & KSPROPERTY_MEMBER_STEPPEDRANGES)) )
    {
        AudioFreeMemory_Unknown( &pPropDesc );
        RETURN( STATUS_NOT_SUPPORTED );
    }

    //
    // Volume controls may either be of MIXERTYPE_CONTROLF_UNIFORM
    // or not.  Uniform controls adjust all channels (or are mono
    // in the first place) with one control.  Those that have the
    // fdwControl field set to 0 can set all channels of the volume
    // independently.  This information will have to come from the
    // node itself, by checking to see if the node uniform control.
    //
    if (pMemberHeader->Flags & KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL) {

        pControl->NumChannels = pMemberHeader->MembersCount;

        if( (pMemberHeader->Flags & KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM) ||
            (pMemberHeader->MembersCount == 1) ) {
            pControl->Control.fdwControl = MIXERCONTROL_CONTROLF_UNIFORM;
        }
    } else {
        // Use the old method which checks if volume is supported on
        // each channel one at a time
        Status = kmxlSupportsMultiChannelControl(pfo,
                                                 pControl->Id,
                                                 pControl->PropertyId);
        if (NT_SUCCESS(Status)) {
            pControl->NumChannels = 2; // we have stereo
            pControl->Control.fdwControl = 0;
        } else {
            pControl->NumChannels = 1; // we have mono or master channel
            pControl->Control.fdwControl = MIXERCONTROL_CONTROLF_UNIFORM;
        }
    }

    DPF(DL_TRACE|FA_MIXER,(
        "KMXL: Found %d channel ranges on control %x",
        pControl->NumChannels,
        pControl
        ) );

    ASSERT(pControl->NumChannels > 0);
    ASSERT(pControl->pChannelStepping == NULL);

    Status = AudioAllocateMemory_Paged(pControl->NumChannels * sizeof( CHANNEL_STEPPING ),
                                       TAG_AuDA_CHANNEL,
                                       ZERO_FILL_MEMORY,
                                       &pControl->pChannelStepping );
    if( !NT_SUCCESS( Status ) ) {
        pControl->NumChannels = 0;
        AudioFreeMemory_Unknown( &pPropDesc );
        RETURN( Status );
    }

    pSteppingLong = (PKSPROPERTY_STEPPING_LONG) ( pMemberHeader + 1 );
    pChannelStepping = pControl->pChannelStepping;

    //  Assuming that MemberSize is sizeof(KSPROPERTY_STEPPING_LONG) for now
    for (i = 0; i < pControl->NumChannels; pChannelStepping++) {
        if ( pSteppingLong->Bounds.SignedMaximum == pSteppingLong->Bounds.SignedMinimum ) {
            DPF(DL_WARNING|FA_MIXER,( "Channel %d has pSteppingLong->Bounds.SignedMaximum == pSteppingLong->Bounds.SignedMinimum", i ) );
            AudioFreeMemory_Unknown( &pPropDesc );
            RETURN( STATUS_NOT_SUPPORTED );
        }

        pChannelStepping->MinValue = pSteppingLong->Bounds.SignedMinimum;
        pChannelStepping->MaxValue = pSteppingLong->Bounds.SignedMaximum;

        if( pSteppingLong->SteppingDelta == 0 ) {
            DPF(DL_WARNING|FA_MIXER,( "Channel %d has pSteppingLong->SteppingDelta == 0", i ) );
            AudioFreeMemory_Unknown( &pPropDesc );
            RETURN( STATUS_NOT_SUPPORTED );
        }

        pChannelStepping->Steps = (LONG) ( ( (LONGLONG) pSteppingLong->Bounds.SignedMaximum -
                                             (LONGLONG) pSteppingLong->Bounds.SignedMinimum ) /
                                             (LONGLONG) pSteppingLong->SteppingDelta );

        if( pChannelStepping->Steps == 0 ) {
            DPF(DL_WARNING|FA_MIXER, ( "Channel %d has pChannelStepping->Steps == 0", i ) );
            AudioFreeMemory_Unknown( &pPropDesc );
            RETURN( STATUS_NOT_SUPPORTED );
        }

        //
        // Need to correct any out of bounds min, max and stepping values.  This code use to be
        // in persist.c.
        //
        /*
        ASSERT ( pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536 );
        ASSERT ( pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536 );
        ASSERT ( pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535 );
        */

        if (!(pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536)) {
            DPF(DL_WARNING|FA_MIXER,
                ("MinValue %X of Control %X of type %X on Channel %X is out of range! Correcting",
                pChannelStepping->MinValue,
                pControl->Control.dwControlID,
                pControl->Control.dwControlType,
                i) );
            pChannelStepping->MinValue = DEFAULT_RANGE_MIN;
        }
        if (!(pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536)) {
            DPF(DL_WARNING|FA_MIXER,
                ("MaxValue %X of Control %X of type %X on Channel %X is out of range! Correcting",
                pChannelStepping->MaxValue,
                pControl->Control.dwControlID,
                pControl->Control.dwControlType,
                i) );
            pChannelStepping->MaxValue = DEFAULT_RANGE_MAX;
        }
        if (!(pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535)) {
            DPF(DL_WARNING|FA_MIXER,
                ("Steps %X of Control %X of type %X on Channel %X is out of range! Correcting",
                pChannelStepping->Steps,
                pControl->Control.dwControlID,
                pControl->Control.dwControlType,
                i) );
            pChannelStepping->Steps    = DEFAULT_RANGE_STEPS;
            pControl->Control.Metrics.cSteps = DEFAULT_RANGE_STEPS;
        }

        DPF(DL_TRACE|FA_MIXER,( "Channel %d ranges from %08x to %08x by %08x steps",
               i,
               pChannelStepping->MinValue,
               pChannelStepping->MaxValue,
               pChannelStepping->Steps ) );

        // Use the next Stepping structure, if there is one.
        if (++i < pMemberHeader->MembersCount) {
            pSteppingLong++;
        }
    }

    AudioFreeMemory_Unknown( &pPropDesc );
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// FindTopologyConnectionTo
//
// Scans through the connection table looking for a connection that
// matches the ToNode/ToNodePin criteria.
//
//

ULONG
kmxlFindTopologyConnectionTo(
    IN CONST KSTOPOLOGY_CONNECTION* pConnections,   // The connection table
    IN ULONG                        cConnections,   // The # of connections
    IN ULONG                        StartIndex,     // Index to start search
    IN ULONG                        ToNode,         // The Node ID to look for
    IN ULONG                        ToNodePin       // The Pin ID to look for
)
{
    ULONG i;

    PAGED_CODE();
    for( i = StartIndex; i < cConnections; i++ ) {
        if( ( ( pConnections[ i ].ToNode      == ToNode         )   ||
              ( ToNode                        == PINID_WILDCARD ) ) &&
            ( ( pConnections[ i ].ToNodePin   == ToNodePin      )   ||
              ( ToNodePin                     == PINID_WILDCARD ) ) ) {
            return( i );
        }
    }
    return( (ULONG) -1 );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNumMuxLines
//
//

DWORD
kmxlGetNumMuxLines(
    IN PKSTOPOLOGY  pTopology,
    IN ULONG        NodeId
)
{
    ULONG Index = 0,
          Count = 0;

    PAGED_CODE();
    do {

        Index = kmxlFindTopologyConnectionTo(
            pTopology->TopologyConnections,
            pTopology->TopologyConnectionsCount,
            Index,
            NodeId,
            PINID_WILDCARD
            );
        if( Index == (ULONG) -1 ) {
            break;
        }

        ++Count;
        ++Index;


    } while( 1 );

    return( Count );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetMuxLineNames
//
//

VOID
kmxlGetMuxLineNames(
    IN PMIXEROBJECT pmxobj,
    IN PMXLCONTROL  pControl
)
{
    PMXLNODE  pNode;
    ULONG i, Index = 0, NodeId;

    ASSERT( pmxobj );
    ASSERT( pControl );
    PAGED_CODE();


    if( !NT_SUCCESS( AudioAllocateMemory_Paged(pControl->Control.cMultipleItems * sizeof( MIXERCONTROLDETAILS_LISTTEXT ),
                                               TAG_AudG_GETMUXLINE,
                                               ZERO_FILL_MEMORY,
                                               &pControl->Parameters.lpmcd_lt ) ) )
    {
        DPF(DL_WARNING|FA_USER,("Failing non failable routine!") );
        return;
    }


    if( !NT_SUCCESS( AudioAllocateMemory_Paged(pControl->Control.cMultipleItems * sizeof( ULONG ),
                                               TAG_AudG_GETMUXLINE,
                                               ZERO_FILL_MEMORY,
                                               &pControl->Parameters.pPins ) ) )
    {
        AudioFreeMemory( pControl->Control.cMultipleItems * sizeof( MIXERCONTROLDETAILS_LISTTEXT ),
                         &pControl->Parameters.lpmcd_lt );
        pControl->Parameters.Count = 0;
        DPF(DL_WARNING|FA_USER,("Failing non failable routine!") );
        return;
    }

    ASSERT( pControl->Parameters.lpmcd_lt );
    ASSERT( pControl->Parameters.pPins );

    pControl->Parameters.Count = pControl->Control.cMultipleItems;

    for( i = 0; i < pControl->Control.cMultipleItems; i++ ) {

        Index = kmxlFindTopologyConnectionTo(
            pmxobj->pTopology->TopologyConnections,
            pmxobj->pTopology->TopologyConnectionsCount,
            Index,
            pControl->Id,
            PINID_WILDCARD
            );
        if( Index != (ULONG) -1 ) {

            NodeId = pmxobj->pTopology->TopologyConnections[ Index ].FromNode;
            if( NodeId == KSFILTER_NODE ) {
                pControl->Parameters.lpmcd_lt[ i ].dwParam1 = pmxobj->pTopology->TopologyConnections[ Index ].FromNodePin;
                pControl->Parameters.lpmcd_lt[ i ].dwParam2 = (DWORD) -1;
                pControl->Parameters.pPins[ i ]
                    = pmxobj->pTopology->TopologyConnections[ Index ].ToNodePin;

                ++Index;
                continue;
            } else {
                pNode = &pmxobj->pNodeTable[ NodeId ];
            }
            ++Index;
            while( pNode ) {

                if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUM ) ||
                    IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX ) ||
                    ( kmxlParentListLength( pNode ) > 1 ) )
                {
                    pControl->Parameters.lpmcd_lt[ i ].dwParam1 = 0x8000 + pNode->Id;
                    pControl->Parameters.lpmcd_lt[ i ].dwParam2 = (DWORD) -1;
                    pControl->Parameters.pPins[ i ]
                        = pmxobj->pTopology->TopologyConnections[ Index - 1 ].ToNodePin;
                    break;
                }

                if( pNode->Type == SOURCE ) {
                    pControl->Parameters.lpmcd_lt[ i ].dwParam1 = pNode->Id;
                    pControl->Parameters.lpmcd_lt[ i ].dwParam2 = (DWORD) -1;
                    pControl->Parameters.pPins[ i ]
                        = pmxobj->pTopology->TopologyConnections[ Index - 1 ].ToNodePin;
                    break;
                } // if
                if( kmxlFirstParentNode( pNode ) ) {
                    pNode = (kmxlFirstParentNode( pNode ))->pNode;
                } else {
                    pNode = NULL;
                }
            } // while
        } // if
    } // for

} // kmxlGetMuxLineNames
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\ioctl.c ===
/****************************************************************************
 *
 *   ioctl.c
 *
 *   DeviceIoControl communication interface between 32-bit wdmaud.drv
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *                S.Mohanraj (MohanS)
 *                M.McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmsys.h"
#include <devioctl.h>

extern ULONG gWavePreferredSysaudioDevice;

#pragma LOCKED_CODE
#pragma LOCKED_DATA

WDMAPENDINGIRP_QUEUE    wdmaPendingIrpQueue;

#ifdef PROFILE

LIST_ENTRY   WdmaAllocatedMdlListHead;
KSPIN_LOCK   WdmaAllocatedMdlListSpinLock;

// Initialize the List Heads and Mutexes in order to track resources
VOID WdmaInitProfile()
{
    InitializeListHead(&WdmaAllocatedMdlListHead);
    KeInitializeSpinLock(&WdmaAllocatedMdlListSpinLock);
}

NTSTATUS AddMdlToList
(
    PMDL            pMdl,
    PWDMACONTEXT    pWdmaContext
)
{
    PALLOCATED_MDL_LIST_ITEM    pAllocatedMdlListItem = NULL;
    NTSTATUS                    Status;

    Status = AudioAllocateMemory_Fixed(sizeof(*pAllocatedMdlListItem),
                                       TAG_AudM_MDL,
                                       ZERO_FILL_MEMORY,
                                       &pAllocatedMdlListItem);
    if (NT_SUCCESS(Status))
    {
        pAllocatedMdlListItem->pMdl     = pMdl;
        pAllocatedMdlListItem->pContext = pWdmaContext;

        ExInterlockedInsertTailList(&WdmaAllocatedMdlListHead,
                                    &pAllocatedMdlListItem->Next,
                                    &WdmaAllocatedMdlListSpinLock);
    }

    RETURN( Status );
}

NTSTATUS RemoveMdlFromList
(
    PMDL            pMdl
)
{
    PLIST_ENTRY                 ple;
    PALLOCATED_MDL_LIST_ITEM    pAllocatedMdlListItem;
    KIRQL                       OldIrql;
    NTSTATUS                    Status = STATUS_UNSUCCESSFUL;

    ExAcquireSpinLock(&WdmaAllocatedMdlListSpinLock, &OldIrql);

    for(ple = WdmaAllocatedMdlListHead.Flink;
        ple != &WdmaAllocatedMdlListHead;
        ple = ple->Flink)
    {
        pAllocatedMdlListItem = CONTAINING_RECORD(ple, ALLOCATED_MDL_LIST_ITEM, Next);

        if (pAllocatedMdlListItem->pMdl == pMdl)
        {
            RemoveEntryList(&pAllocatedMdlListItem->Next);
            AudioFreeMemory(sizeof(*pAllocatedMdlListItem),&pAllocatedMdlListItem);
            Status = STATUS_SUCCESS;
            break;
        }
    }

    ExReleaseSpinLock(&WdmaAllocatedMdlListSpinLock, OldIrql);

    RETURN( Status );
}
#endif

VOID WdmaCsqInsertIrp
(
    IN struct _IO_CSQ   *Csq,
    IN PIRP              Irp
)
{
    PWDMAPENDINGIRP_QUEUE PendingIrpQueue = CONTAINING_RECORD(Csq, WDMAPENDINGIRP_QUEUE, Csq);

    InsertTailList(&PendingIrpQueue->WdmaPendingIrpListHead,
                   &Irp->Tail.Overlay.ListEntry);
}

VOID WdmaCsqRemoveIrp
(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
)
{
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
}

PIRP WdmaCsqPeekNextIrp
(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
)
{
    PWDMAPENDINGIRP_QUEUE PendingIrpQueue = CONTAINING_RECORD(Csq, WDMAPENDINGIRP_QUEUE, Csq);
    PIRP          nextIrp;
    PLIST_ENTRY   listEntry;

    if (Irp == NULL) {
        listEntry = PendingIrpQueue->WdmaPendingIrpListHead.Flink;
        if (listEntry == &PendingIrpQueue->WdmaPendingIrpListHead) {
            DPF(DL_TRACE|FA_IOCTL, ("Irp is NULL, queue is empty"));
            return NULL;
        }

        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        DPF(DL_TRACE|FA_IOCTL, ("Irp is NULL, nextIrp %x", nextIrp));
        return nextIrp;
    }

    listEntry = Irp->Tail.Overlay.ListEntry.Flink;


    //
    // Enumerated to end of queue.
    //

    if (listEntry == &PendingIrpQueue->WdmaPendingIrpListHead) {
        DPF(DL_TRACE|FA_IOCTL, ("End of queue reached Irp %x", Irp));
        return NULL;
    }


    nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
    return nextIrp;
}

VOID WdmaCsqAcquireLock
(
    IN  PIO_CSQ Csq,
    OUT PKIRQL  Irql
)
{
    PWDMAPENDINGIRP_QUEUE PendingIrpQueue = CONTAINING_RECORD(Csq, WDMAPENDINGIRP_QUEUE, Csq);
    KeAcquireSpinLock(&PendingIrpQueue->WdmaPendingIrpListSpinLock, Irql);
}

VOID WdmaCsqReleaseLock
(
    IN PIO_CSQ Csq,
    IN KIRQL   Irql
)
{
    PWDMAPENDINGIRP_QUEUE PendingIrpQueue = CONTAINING_RECORD(Csq, WDMAPENDINGIRP_QUEUE, Csq);
    KeReleaseSpinLock(&PendingIrpQueue->WdmaPendingIrpListSpinLock, Irql);
}

VOID WdmaCsqCompleteCanceledIrp
(
    IN  PIO_CSQ             pCsq,
    IN  PIRP                Irp
)
{
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS AddIrpToPendingList
(
    PIRP                     pIrp,
    ULONG                    IrpDeviceType,
    PWDMACONTEXT             pWdmaContext,
    PWDMAPENDINGIRP_CONTEXT *ppPendingIrpContext
)
{
    PWDMAPENDINGIRP_CONTEXT     pPendingIrpContext = NULL;
    NTSTATUS                    Status;

    Status = AudioAllocateMemory_Fixed(sizeof(*pPendingIrpContext),
                                       TAG_AudR_IRP,
                                       ZERO_FILL_MEMORY,
                                       &pPendingIrpContext);
    if (NT_SUCCESS(Status))
    {
        *ppPendingIrpContext = pPendingIrpContext;

        pPendingIrpContext->IrpDeviceType  = IrpDeviceType;
        pPendingIrpContext->pContext       = pWdmaContext;

        IoCsqInsertIrp(&wdmaPendingIrpQueue.Csq,
                       pIrp,
                       &pPendingIrpContext->IrpContext);
    }

    RETURN( Status );
}

NTSTATUS RemoveIrpFromPendingList
(
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext
)
{
    PIO_CSQ_IRP_CONTEXT irpContext = &(pPendingIrpContext->IrpContext);
    PIRP Irp;
    NTSTATUS Status;

    Irp = IoCsqRemoveIrp(&wdmaPendingIrpQueue.Csq, irpContext);
    if (Irp) {
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_UNSUCCESSFUL;
    }
    AudioFreeMemory(sizeof(*pPendingIrpContext),&irpContext);

    RETURN( Status );
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | IsSysaudioInterfaceActive | Checks to see if the sysaudio
 *  device interface is active.
 *
 * @rdesc returns TRUE if sysaudio has been found, otherwise FALSE
 ***************************************************************************/
BOOL IsSysaudioInterfaceActive()
{
    NTSTATUS Status;
    PWSTR    pwstrSymbolicLinkList = NULL;
    BOOL     bRet = FALSE;

    Status = IoGetDeviceInterfaces(
      &KSCATEGORY_SYSAUDIO,
      NULL,
      0,
      &pwstrSymbolicLinkList);

    if (NT_SUCCESS(Status))
    {
        if (*pwstrSymbolicLinkList != UNICODE_NULL)
        {
            DPF(DL_TRACE|FA_IOCTL, ("yes"));
            bRet = TRUE;
        }
        AudioFreeMemory_Unknown(&pwstrSymbolicLinkList);
    } else {
        DPF(DL_WARNING|FA_IOCTL,("IoGetDeviceInterface failed Statue=%08X",Status) );
    }

    DPF(DL_TRACE|FA_IOCTL, ("No"));
    return bRet;
}

PVOID
GetSystemAddressForMdlWithFailFlag
(
    PMDL pMdl
)
{
    PVOID   pAddress;
    CSHORT  OldFlags;

    OldFlags = (pMdl->MdlFlags & MDL_MAPPING_CAN_FAIL);
    pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;

    pAddress = MmGetSystemAddressForMdl( pMdl ) ;

    pMdl->MdlFlags &= ~(MDL_MAPPING_CAN_FAIL);
    pMdl->MdlFlags |= OldFlags;

    return pAddress;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | wdmaudMapBuffer | Allocates an MDL and returns a system address
 *      mapped pointer to the passed in buffer.
 *
 * @rdesc returns nothing
 ***************************************************************************/
VOID wdmaudMapBuffer
(
    IN  PIRP            pIrp,
    IN  PVOID           DataBuffer,
    IN  DWORD           DataBufferSize,
    OUT PVOID           *ppMappedBuffer,
    OUT PMDL            *ppMdl,
    IN  PWDMACONTEXT    pContext,
    IN  BOOL            bWrite
)
{
    NTSTATUS ListAddStatus = STATUS_UNSUCCESSFUL;

    // Make sure that these are initialized to NULL
    *ppMdl = NULL;
    *ppMappedBuffer = NULL;

    if (DataBuffer)
    {
        if (DataBufferSize)
        {
            *ppMdl = MmCreateMdl( NULL,
                                  DataBuffer,
                                  DataBufferSize );
            if (*ppMdl)
            {
                try
                {
                    MmProbeAndLockPages( *ppMdl,
                                         pIrp->RequestorMode,
                                         bWrite ? IoWriteAccess:IoReadAccess );

                    *ppMappedBuffer = GetSystemAddressForMdlWithFailFlag( *ppMdl ) ;

                    ListAddStatus = AddMdlToList(*ppMdl, pContext);
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    if (NT_SUCCESS(ListAddStatus))
                    {
                        RemoveMdlFromList( *ppMdl );
                    }
                    IoFreeMdl( *ppMdl );
                    *ppMdl = NULL;
                    *ppMappedBuffer = NULL;
                }
            }

            //
            //  Must have failed in GetSystemAddressForMdlWithFailFlag, but since we set the
            //  MDL_MAPPING_CAN_FAIL flag our exception handler won't get executed.  Do the
            //  cleanup here for the MDL creation.
            //
            if (NULL == *ppMappedBuffer)
            {
                if (NT_SUCCESS(ListAddStatus))
                {
                    RemoveMdlFromList( *ppMdl );
                }

                if (*ppMdl)
                {
                    MmUnlockPages(*ppMdl);
                    IoFreeMdl( *ppMdl );
                    *ppMdl = NULL;
                }
            }
        }
    }

    return;
}

 
/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | wdmaudUnmapBuffer | Frees the MDL allocated by wdmaudMapBuffer
 *
 * @parm PMDL | pMdl | Pointer to the MDL to free.
 *
 * @rdesc returns nothing
 ***************************************************************************/
VOID wdmaudUnmapBuffer
(
    PMDL pMdl
)
{
    if (pMdl)
    {
        RemoveMdlFromList(pMdl);

        MmUnlockPages(pMdl);
        IoFreeMdl(pMdl);
    }

    return;
}

NTSTATUS 
CaptureBufferToLocalPool(
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *ppMappedBuffer
#ifdef _WIN64
    ,DWORD          ThunkBufferSize
#endif
)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    DWORD CopySize=DataBufferSize;

#ifdef _WIN64
    if (ThunkBufferSize) {
        DataBufferSize=ThunkBufferSize;
        ASSERT( DataBufferSize >= CopySize );
    }
#endif

    if (DataBufferSize)
    {
        Status = AudioAllocateMemory_Fixed(DataBufferSize,
                                           TAG_AudB_BUFFER,
                                           ZERO_FILL_MEMORY,
                                           ppMappedBuffer);
        if (NT_SUCCESS(Status))
        {
            // Wrap around a try/except because the user mode memory
            // might have been removed from underneath us.
            try
            {
                RtlCopyMemory( *ppMappedBuffer,
                               DataBuffer,
                               CopySize);
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                AudioFreeMemory(DataBufferSize,ppMappedBuffer);
                Status = GetExceptionCode();
            }
        }
    }

    RETURN( Status );
}

NTSTATUS 
CopyAndFreeCapturedBuffer(
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *ppMappedBuffer
)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    ASSERT(DataBuffer);

    if (*ppMappedBuffer)
    {
        // Wrap around a try/except because the user mode memory
        // might have been removed from underneath us.
        try
        {
            RtlCopyMemory( DataBuffer,
                           *ppMappedBuffer,
                           DataBufferSize);
            Status = STATUS_SUCCESS;
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetExceptionCode();
        }

        AudioFreeMemory_Unknown(ppMappedBuffer);
    }

    RETURN( Status );
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS
SoundDispatchCreate(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PWDMACONTEXT        pContext = NULL;
    NTSTATUS            Status;
    int                 i;

    PAGED_CODE();
    DPF(DL_TRACE|FA_IOCTL, ("IRP_MJ_CREATE"));

    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)pDO->DeviceExtension)->pDeviceHeader );

    if (!NT_SUCCESS(Status))
    {
        RETURN( Status );
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    Status = AudioAllocateMemory_Fixed(sizeof(*pContext),
                                       TAG_Audx_CONTEXT,
                                       ZERO_FILL_MEMORY,
                                       &pContext);
    if (NT_SUCCESS(Status))
    {
        pIrpStack->FileObject->FsContext = pContext;

        //
        // Initialize out all the winmm device data structures.
        //
#ifdef DEBUG
        pContext->dwSig=CONTEXT_SIGNATURE;
#endif

        pContext->VirtualWavePinId = MAXULONG;
        pContext->VirtualMidiPinId = MAXULONG;
        pContext->VirtualCDPinId = MAXULONG;

        pContext->PreferredSysaudioWaveDevice = gWavePreferredSysaudioDevice;

        if ( IsSysaudioInterfaceActive() )
        {
            pContext->pFileObjectSysaudio = kmxlOpenSysAudio();
        } else {
            DPF(DL_WARNING|FA_SYSAUDIO,("sysaudio not available") );
        }

        for (i = 0; i < MAXNUMDEVS; i++)
        {
            pContext->WaveOutDevs[i].pWdmaContext     = pContext;
            pContext->WaveInDevs[i].pWdmaContext      = pContext;
            pContext->MidiOutDevs[i].pWdmaContext     = pContext;
            pContext->MidiInDevs[i].pWdmaContext      = pContext;
            pContext->MixerDevs[i].pWdmaContext       = pContext;
            pContext->AuxDevs[i].pWdmaContext         = pContext;

            pContext->WaveOutDevs[i].Device               = UNUSED_DEVICE;
            pContext->WaveInDevs[i].Device                = UNUSED_DEVICE;
            pContext->MidiOutDevs[i].Device               = UNUSED_DEVICE;
            pContext->MidiInDevs[i].Device                = UNUSED_DEVICE;
            pContext->MixerDevs[i].Device                 = UNUSED_DEVICE;
            pContext->AuxDevs[i].Device                   = UNUSED_DEVICE;
#ifdef DEBUG
            pContext->MixerDevs[i].dwSig                  = MIXERDEVICE_SIGNATURE;           
#endif
                          
            DPFASSERT(pContext->WaveOutDevs[i].pWavePin == NULL);

            pContext->apCommonDevice[WaveInDevice][i]  = (PCOMMONDEVICE)&pContext->WaveInDevs[i];
            pContext->apCommonDevice[WaveOutDevice][i] = (PCOMMONDEVICE)&pContext->WaveOutDevs[i];
            pContext->apCommonDevice[MidiInDevice][i]  = (PCOMMONDEVICE)&pContext->MidiInDevs[i];
            pContext->apCommonDevice[MidiOutDevice][i] = (PCOMMONDEVICE)&pContext->MidiOutDevs[i];
            pContext->apCommonDevice[MixerDevice][i]   = (PCOMMONDEVICE)&pContext->MixerDevs[i];
            pContext->apCommonDevice[AuxDevice][i]     = (PCOMMONDEVICE)&pContext->AuxDevs[i];
        }

        InitializeListHead(&pContext->DevNodeListHead);
        pContext->DevNodeListCount = 0;
        InitializeListHead(&pContext->WorkListHead);
        KeInitializeSpinLock(&pContext->WorkListSpinLock);
        ExInitializeWorkItem(&pContext->WorkListWorkItem, WorkListWorker, pContext);

        ExInitializeWorkItem(&pContext->SysaudioWorkItem, SysaudioAddRemove, pContext);

        KeInitializeEvent(&pContext->InitializedSysaudioEvent, NotificationEvent, FALSE);

        Status = KsRegisterWorker( DelayedWorkQueue, &pContext->WorkListWorkerObject );
        if (NT_SUCCESS(Status))
        {
            Status = KsRegisterWorker( DelayedWorkQueue, &pContext->SysaudioWorkerObject );
            if (NT_SUCCESS(Status))
            {
                Status = IoRegisterPlugPlayNotification(
                    EventCategoryDeviceInterfaceChange,
                    PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                    (GUID *)&KSCATEGORY_SYSAUDIO,
                    pIrpStack->DeviceObject->DriverObject,
                    SysAudioPnPNotification,
                    pContext,
                    &pContext->NotificationEntry);

                if (NT_SUCCESS(Status))
                {
                    AddFsContextToList(pContext);
                    DPF(DL_TRACE|FA_IOCTL, ("New pContext=%08Xh", pContext) );
                }
                if (!NT_SUCCESS(Status))
                {
                    KsUnregisterWorker( pContext->SysaudioWorkerObject );
                    pContext->SysaudioWorkerObject = NULL;
                }
            }

            if (!NT_SUCCESS(Status))
            {
                KsUnregisterWorker( pContext->WorkListWorkerObject );
                pContext->WorkListWorkerObject = NULL;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            AudioFreeMemory(sizeof(*pContext),&pContext);
            pIrpStack->FileObject->FsContext = NULL;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)pDO->DeviceExtension)->pDeviceHeader );
    }

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    RETURN( Status );
}

NTSTATUS
SoundDispatchClose(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PKSWORKER WorkListWorkerObject;
    PKSWORKER SysaudioWorkerObject;
    PWDMACONTEXT pContext;

    PAGED_CODE();
    DPF(DL_TRACE|FA_IOCTL, ("IRP_MJ_CLOSE"));
    //
    //  This routine is serialized by the i/o subsystem so there is no need to grab the
    //  mutex for protection.  Furthermore, it is not possible to release the mutex
    //  after UninitializeSysaudio is called.
    //

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    //
    //  Can't assume that FsContext is initialized if the device has
    //  been opened with FO_DIRECT_DEVICE_OPEN
    //
    if (pIrpStack->FileObject->Flags & FO_DIRECT_DEVICE_OPEN)
    {
        DPF(DL_TRACE|FA_IOCTL, ("Opened with FO_DIRECT_DEVICE_OPEN, no device context") );
        goto exit;
    }

    pContext = pIrpStack->FileObject->FsContext;
    ASSERT(pContext);

    DPF(DL_TRACE|FA_IOCTL, ("pWdmaContext=%08Xh", pContext) );

    if (pContext->NotificationEntry != NULL)
    {
        IoUnregisterPlugPlayNotification(pContext->NotificationEntry);
        pContext->NotificationEntry = NULL;
    }

    //
    //  force turds to be freed for a particular context
    //
    WdmaGrabMutex(pContext);

    CleanupWaveDevices(pContext);
    CleanupMidiDevices(pContext);
    WdmaContextCleanup(pContext);
    UninitializeSysaudio(pContext);

    WorkListWorkerObject = pContext->WorkListWorkerObject;
    pContext->WorkListWorkerObject = NULL;

    SysaudioWorkerObject = pContext->SysaudioWorkerObject;
    pContext->SysaudioWorkerObject = NULL;

    WdmaReleaseMutex(pContext);

    if (WorkListWorkerObject != NULL)
    {
        KsUnregisterWorker( WorkListWorkerObject );
    }

    if (SysaudioWorkerObject != NULL)
    {
        KsUnregisterWorker( SysaudioWorkerObject );
    }
    RemoveFsContextFromList(pContext);

    //
    // Workitem:  Shouldn't WdmaReleaseMutex(pContext) be here rather then above?
    // I would think that if we release the mutex before cleanly getting throug the
    // cleanup we could have reentrancy problems.  ???
    //
    // Also, note that all of pContext will be invalid after this AudioFreeMemory call!
    //
    kmxlRemoveContextFromNoteList(pContext);

    if( pContext->pFileObjectSysaudio )
    {
        kmxlCloseSysAudio(pContext->pFileObjectSysaudio);
        pContext->pFileObjectSysaudio = NULL;
    }

    AudioFreeMemory(sizeof(*pContext),&pContext);
    pIrpStack->FileObject->FsContext = NULL;

exit:
    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)pDO->DeviceExtension)->pDeviceHeader );

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
SoundDispatchCleanup(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PWDMACONTEXT pContext;

    PAGED_CODE();
    DPF(DL_TRACE|FA_IOCTL, ("IRP_MJ_CLEANUP"));

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    //
    //  Can't assume that FsContext is initialized if the device has
    //  been opened with FO_DIRECT_DEVICE_OPEN
    //
    if (pIrpStack->FileObject->Flags & FO_DIRECT_DEVICE_OPEN)
    {
        DPF(DL_TRACE|FA_IOCTL, ("Opened with FO_DIRECT_DEVICE_OPEN, no device context") );
        goto exit;
    }

    pContext = pIrpStack->FileObject->FsContext;
    ASSERT(pContext);

    DPF(DL_TRACE|FA_IOCTL, ("pWdmaContext=%08Xh", pContext) );

    //
    //  force turds to be freed for a particular context
    //
    WdmaGrabMutex(pContext);
    CleanupWaveDevices(pContext);
    CleanupMidiDevices(pContext);
    WdmaContextCleanup(pContext);
    WdmaReleaseMutex(pContext);

exit:
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
ValidateIoCode
(
    IN  ULONG   IoCode
)
{
    NTSTATUS Status;

    PAGED_CODE();
    switch (IoCode)
    {
        case IOCTL_WDMAUD_INIT:
        case IOCTL_WDMAUD_ADD_DEVNODE:
        case IOCTL_WDMAUD_REMOVE_DEVNODE:
        case IOCTL_WDMAUD_SET_PREFERRED_DEVICE:
        case IOCTL_WDMAUD_GET_CAPABILITIES:
        case IOCTL_WDMAUD_GET_NUM_DEVS:
        case IOCTL_WDMAUD_OPEN_PIN:
        case IOCTL_WDMAUD_CLOSE_PIN:
        case IOCTL_WDMAUD_GET_VOLUME:
        case IOCTL_WDMAUD_SET_VOLUME:
        case IOCTL_WDMAUD_EXIT:
        case IOCTL_WDMAUD_WAVE_OUT_PAUSE:
        case IOCTL_WDMAUD_WAVE_OUT_PLAY:
        case IOCTL_WDMAUD_WAVE_OUT_RESET:
        case IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP:
        case IOCTL_WDMAUD_WAVE_OUT_GET_POS:
        case IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME:
        case IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME:
        case IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN:
        case IOCTL_WDMAUD_WAVE_IN_STOP:
        case IOCTL_WDMAUD_WAVE_IN_RECORD:
        case IOCTL_WDMAUD_WAVE_IN_RESET:
        case IOCTL_WDMAUD_WAVE_IN_GET_POS:
        case IOCTL_WDMAUD_WAVE_IN_READ_PIN:
        case IOCTL_WDMAUD_MIDI_OUT_RESET:
        case IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME:
        case IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME:
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA:
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA:
        case IOCTL_WDMAUD_MIDI_IN_STOP:
        case IOCTL_WDMAUD_MIDI_IN_RECORD:
        case IOCTL_WDMAUD_MIDI_IN_RESET:
        case IOCTL_WDMAUD_MIDI_IN_READ_PIN:
        case IOCTL_WDMAUD_MIXER_OPEN:
        case IOCTL_WDMAUD_MIXER_CLOSE:
        case IOCTL_WDMAUD_MIXER_GETLINEINFO:
        case IOCTL_WDMAUD_MIXER_GETLINECONTROLS:
        case IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS:
        case IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS:
        case IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA:
            Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            break;
    }

    RETURN( Status );
}

NTSTATUS
ValidateDeviceType
(
    IN  ULONG   IoCode,
    IN  DWORD   DeviceType
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    switch (IoCode)
    {
        //  These IOCTLs can handle any DeviceType
        case IOCTL_WDMAUD_ADD_DEVNODE:
        case IOCTL_WDMAUD_REMOVE_DEVNODE:
        case IOCTL_WDMAUD_SET_PREFERRED_DEVICE:
        case IOCTL_WDMAUD_GET_CAPABILITIES:
        case IOCTL_WDMAUD_GET_NUM_DEVS:
        case IOCTL_WDMAUD_OPEN_PIN:
        case IOCTL_WDMAUD_CLOSE_PIN:
            if (DeviceType != WaveInDevice  &&
                DeviceType != WaveOutDevice &&
                DeviceType != MidiInDevice  &&
                DeviceType != MidiOutDevice &&
                DeviceType != MixerDevice   &&
                DeviceType != AuxDevice)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        //  These IOCTLs can handle only AUX devices
        case IOCTL_WDMAUD_GET_VOLUME:
        case IOCTL_WDMAUD_SET_VOLUME:
            if (DeviceType != AuxDevice)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        //  These IOCTLs can handle only WaveOut devices
        case IOCTL_WDMAUD_WAVE_OUT_PAUSE:
        case IOCTL_WDMAUD_WAVE_OUT_PLAY:
        case IOCTL_WDMAUD_WAVE_OUT_RESET:
        case IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP:
        case IOCTL_WDMAUD_WAVE_OUT_GET_POS:
        case IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME:
        case IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME:
        case IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN:
            if (DeviceType != WaveOutDevice)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        //  These IOCTLs can handle only WaveIn devices
        case IOCTL_WDMAUD_WAVE_IN_STOP:
        case IOCTL_WDMAUD_WAVE_IN_RECORD:
        case IOCTL_WDMAUD_WAVE_IN_RESET:
        case IOCTL_WDMAUD_WAVE_IN_GET_POS:
        case IOCTL_WDMAUD_WAVE_IN_READ_PIN:
            if (DeviceType != WaveInDevice)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        //  These IOCTLs can handle only MidiOut devices
        case IOCTL_WDMAUD_MIDI_OUT_RESET:
        case IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME:
        case IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME:
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA:
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA:
            if (DeviceType != MidiOutDevice)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        //  These IOCTLs can handle only MidiIn devices
        case IOCTL_WDMAUD_MIDI_IN_STOP:
        case IOCTL_WDMAUD_MIDI_IN_RECORD:
        case IOCTL_WDMAUD_MIDI_IN_RESET:
        case IOCTL_WDMAUD_MIDI_IN_READ_PIN:
            if (DeviceType != MidiInDevice)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        //  These IOCTLs can handle only Mixer devices
        case IOCTL_WDMAUD_MIXER_OPEN:
        case IOCTL_WDMAUD_MIXER_CLOSE:
        case IOCTL_WDMAUD_MIXER_GETLINEINFO:
        case IOCTL_WDMAUD_MIXER_GETLINECONTROLS:
        case IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS:
        case IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS:
        case IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA:
            if (DeviceType != MixerDevice)
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        //  No device type for these IOCTLs
        case IOCTL_WDMAUD_INIT:
        case IOCTL_WDMAUD_EXIT:
            // Status is already STATUS_SUCCESS
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            break;
    }

    RETURN( Status );
}


#ifdef _WIN64

// Note that on 64 bit Windows, handles have 32 bits of information in them,
// but no more.  Thus they can be safely zero extended and truncated for thunks.
// All memory allocations made in 32 bit processes are guaranteed to be in the
// first 4 Gigs, again so that pointers from those processes can be thunked simply
// by zero extending them and truncating them.

VOID ThunkDeviceInfo3264(
    LPDEVICEINFO32 DeviceInfo32,
    LPDEVICEINFO DeviceInfo
    )

{

ULONG i;

    PAGED_CODE();
    DeviceInfo->Next = (LPDEVICEINFO)(UINT_PTR)DeviceInfo32->Next;
    DeviceInfo->DeviceNumber = DeviceInfo32->DeviceNumber ;
    DeviceInfo->DeviceType = DeviceInfo32->DeviceType ;
    DeviceInfo->DeviceHandle = (HANDLE32)(UINT_PTR)DeviceInfo32->DeviceHandle ;
    DeviceInfo->dwInstance = (DWORD_PTR)DeviceInfo32->dwInstance ;
    DeviceInfo->dwCallback = (DWORD_PTR)DeviceInfo32->dwCallback ;
    DeviceInfo->dwCallback16 = DeviceInfo32->dwCallback16 ;
    DeviceInfo->dwFlags = DeviceInfo32->dwFlags ;
    DeviceInfo->DataBuffer = (LPVOID)(UINT_PTR)DeviceInfo32->DataBuffer ;
    DeviceInfo->DataBufferSize = DeviceInfo32->DataBufferSize ;
    DeviceInfo->OpenDone = DeviceInfo32->OpenDone ;
    DeviceInfo->OpenStatus = DeviceInfo32->OpenStatus ;
    DeviceInfo->HardwareCallbackEventHandle = (HANDLE)(UINT_PTR)DeviceInfo32->HardwareCallbackEventHandle ;
    DeviceInfo->dwCallbackType = DeviceInfo32->dwCallbackType ;

    for (i=0; i<MAXCALLBACKS; i++)
        DeviceInfo->dwID[i] = DeviceInfo32->dwID[i] ;

    DeviceInfo->dwLineID = DeviceInfo32->dwLineID ;
    DeviceInfo->ControlCallbackCount = DeviceInfo32->ControlCallbackCount ;
    DeviceInfo->dwFormat = DeviceInfo32->dwFormat ;
    DeviceInfo->mmr = DeviceInfo32->mmr ;
    DeviceInfo->DeviceState = (LPDEVICESTATE)(UINT_PTR)DeviceInfo32->DeviceState ;
    DeviceInfo->dwSig = DeviceInfo32->dwSig ;
    wcsncpy(DeviceInfo->wstrDeviceInterface, DeviceInfo32->wstrDeviceInterface, MAXDEVINTERFACE+1) ;

}

VOID ThunkDeviceInfo6432(
    LPDEVICEINFO DeviceInfo,
    LPDEVICEINFO32 DeviceInfo32
    )

{

ULONG i;

    PAGED_CODE();
    DeviceInfo32->Next = (UINT32)(UINT_PTR)DeviceInfo->Next;
    DeviceInfo32->DeviceNumber = DeviceInfo->DeviceNumber ;
    DeviceInfo32->DeviceType = DeviceInfo->DeviceType ;
    DeviceInfo32->DeviceHandle = (UINT32)(UINT_PTR)DeviceInfo->DeviceHandle ;
    DeviceInfo32->dwInstance = (UINT32)DeviceInfo->dwInstance ;
    DeviceInfo32->dwCallback = (UINT32)DeviceInfo->dwCallback ;
    DeviceInfo32->dwCallback16 = DeviceInfo->dwCallback16 ;
    DeviceInfo32->dwFlags = DeviceInfo->dwFlags ;
    DeviceInfo32->DataBuffer = (UINT32)(UINT_PTR)DeviceInfo->DataBuffer ;
    DeviceInfo32->DataBufferSize = DeviceInfo->DataBufferSize ;
    DeviceInfo32->OpenDone = DeviceInfo->OpenDone ;
    DeviceInfo32->OpenStatus = DeviceInfo->OpenStatus ;
    DeviceInfo32->HardwareCallbackEventHandle = (UINT32)(UINT_PTR)DeviceInfo->HardwareCallbackEventHandle ;
    DeviceInfo32->dwCallbackType = DeviceInfo->dwCallbackType ;

    for (i=0; i<MAXCALLBACKS; i++)
        DeviceInfo32->dwID[i] = DeviceInfo->dwID[i] ;

    DeviceInfo32->dwLineID = DeviceInfo->dwLineID ;
    DeviceInfo32->ControlCallbackCount = DeviceInfo->ControlCallbackCount ;
    DeviceInfo32->dwFormat = DeviceInfo->dwFormat ;
    DeviceInfo32->mmr = DeviceInfo->mmr ;
    DeviceInfo32->DeviceState = (UINT32)(UINT_PTR)DeviceInfo->DeviceState ;
    DeviceInfo32->dwSig = DeviceInfo->dwSig ;
    wcscpy(DeviceInfo32->wstrDeviceInterface, DeviceInfo->wstrDeviceInterface) ;

}

#endif


NTSTATUS
ValidateIrp
(
    IN  PIRP    pIrp
)
{
    PIO_STACK_LOCATION  pIrpStack;
    ULONG               InputBufferLength;
    ULONG               OutputBufferLength;
    LPDEVICEINFO        DeviceInfo;
    #ifdef _WIN64
    LPDEVICEINFO32      DeviceInfo32;
    LOCALDEVICEINFO     LocalDeviceInfo;
    #endif
    LPVOID              DataBuffer;
    DWORD               DataBufferSize;
    ULONG               IoCode;
    NTSTATUS            Status = STATUS_SUCCESS;

    PAGED_CODE();
    //
    //  Get the CurrentStackLocation and log it so we know what is going on
    //
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    IoCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

    //
    //  Checks to see that we have a WDMAUD Ioctl (buffered) request
    //
    Status = ValidateIoCode(IoCode);

    if (NT_SUCCESS(Status))
    {
        //
        // Check the sizes of the input and output buffers.
        //
        InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        OutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        #ifdef _WIN64
        if (IoIs32bitProcess(pIrp)) {

            if ((InputBufferLength < sizeof(DEVICEINFO32)) ||
                (OutputBufferLength != sizeof(DEVICEINFO32)) )
            {
                Status = STATUS_INVALID_BUFFER_SIZE;
                if (IoCode == IOCTL_WDMAUD_WAVE_OUT_GET_POS)
                {
                    DPF(DL_ERROR|FA_IOCTL, ("IOCTL_WDMAUD_WAVE_OUT_GET_POS: InputBufferLength = %d, OuputBufferLength = %d", InputBufferLength, OutputBufferLength));
                }
            }

        }
        else
        // WARNING!!!  If you add additional statements after the if that need
        // to be part of this else clause, you will need to add brackets!
        #endif

        if ((InputBufferLength < sizeof(DEVICEINFO)) ||
            (OutputBufferLength != sizeof(DEVICEINFO)) )
        {
            Status = STATUS_INVALID_BUFFER_SIZE;
            if (IoCode == IOCTL_WDMAUD_WAVE_OUT_GET_POS)
            {
                DPF(DL_WARNING|FA_IOCTL, ("IOCTL_WDMAUD_WAVE_OUT_GET_POS: InputBufferLength = %d, OuputBufferLength = %d", InputBufferLength, OutputBufferLength));
            }
        }

        if (NT_SUCCESS(Status))
        {

            #ifdef _WIN64
            if (IoIs32bitProcess(pIrp)) {
                DeviceInfo32=((LPDEVICEINFO32)pIrp->AssociatedIrp.SystemBuffer);
                RtlZeroMemory(&LocalDeviceInfo, sizeof(LOCALDEVICEINFO));
                DeviceInfo=&LocalDeviceInfo.DeviceInfo;
                ThunkDeviceInfo3264(DeviceInfo32, DeviceInfo);
            }
            else
            // WARNING!!!  If you add additional statements after the assignment that need
            // to be part of this else clause, you will need to add brackets!
            #endif

            DeviceInfo = ((LPDEVICEINFO)pIrp->AssociatedIrp.SystemBuffer);
            DataBuffer = DeviceInfo->DataBuffer;
            DataBufferSize = DeviceInfo->DataBufferSize;

            //
            //  Check to make sure that our DeviceInfo->wstrDeviceInterface is terminated
            //
            if (InputBufferLength % sizeof(WCHAR))  // must be WCHAR aligned
            {
                Status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                //
                //  Get the last widechar and compare with UNICODE_NULL
                //
                UINT TermCharPos;

                #ifdef _WIN64
                if (IoIs32bitProcess(pIrp)) {
                    TermCharPos = (InputBufferLength - sizeof(DEVICEINFO32)) / sizeof(WCHAR);
                    // Now make sure we had enough local buffer space to hold the whole string.
                    if (TermCharPos>MAXDEVINTERFACE) {
                        Status = STATUS_INVALID_PARAMETER;
                        // Make sure we don't go past end of local buffer space when
                        // we check if the last character is null.
                        TermCharPos=MAXDEVINTERFACE;
                    }
                }
                else
                // WARNING!!!  If you add additional statements after the assignment that need
                // to be part of this else clause, you will need to add brackets!
                #endif

                TermCharPos = (InputBufferLength - sizeof(DEVICEINFO)) / sizeof(WCHAR);
                if (DeviceInfo->wstrDeviceInterface[TermCharPos] != UNICODE_NULL)
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = ValidateDeviceType(IoCode,DeviceInfo->DeviceType);
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Validate the pointers if the client is not trusted.
        //
        if (pIrp->RequestorMode != KernelMode)
        {
            if (DataBufferSize)
            {
                try
                {
                    ASSERT(pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);
                    switch (IoCode)
                    {
                        //
                        //  IoCode's that require a probe for reading
                        //
                        case IOCTL_WDMAUD_OPEN_PIN:
                        case IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN:
                        case IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA:
                        case IOCTL_WDMAUD_MIXER_OPEN:
                        case IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS:
                            ProbeForRead(DataBuffer,
                                         DataBufferSize,
                                         sizeof(BYTE));
                            break;

                        //
                        //  IoCode's that require a probe for writing
                        //
                        case IOCTL_WDMAUD_GET_CAPABILITIES:
                        case IOCTL_WDMAUD_WAVE_IN_READ_PIN:
                        case IOCTL_WDMAUD_MIXER_GETLINEINFO:
                        case IOCTL_WDMAUD_MIXER_GETLINECONTROLS:
                        case IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS:

                            ProbeForWrite(DataBuffer,
                                          DataBufferSize,
                                          sizeof(BYTE));
                            break;


                        //
                        //  IoCode's that require a probe for reading on DWORD alignment
                        //
                        case IOCTL_WDMAUD_SET_VOLUME:
                        case IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME:
                        case IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME:
                            ProbeForRead(DataBuffer,
                                         DataBufferSize,
                                         sizeof(DWORD));
                            break;

                        //
                        //  IoCode's that require a probe for writing on DWORD alignment
                        //
                        case IOCTL_WDMAUD_GET_VOLUME:
                        case IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME:
                        case IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME:
                        case IOCTL_WDMAUD_WAVE_OUT_GET_POS:
                        case IOCTL_WDMAUD_WAVE_IN_GET_POS:
                        case IOCTL_WDMAUD_MIDI_IN_READ_PIN:
                            ProbeForWrite(DataBuffer,
                                          DataBufferSize,
                                          sizeof(DWORD));
                            break;

                        // Don't know about this ioctl
                        default:
                            Status = STATUS_NOT_SUPPORTED;
                            break;
                    }
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    Status = GetExceptionCode();
                }
            }
        }
    }

    RETURN( Status );
}


//
// Helper routines.
//

NTSTATUS
ValidateAndTranslate(
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    DWORD        ValidationSize,
    ULONG       *pTranslatedDeviceNumber
    )
{
    if (DeviceInfo->DataBufferSize != ValidationSize)
    {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    *pTranslatedDeviceNumber = wdmaudTranslateDeviceNumber(pContext,
                                                         DeviceInfo->DeviceType,
                                                         DeviceInfo->wstrDeviceInterface,
                                                         DeviceInfo->DeviceNumber);

    if (MAXULONG == *pTranslatedDeviceNumber) {

        DPF(DL_WARNING|FA_IOCTL,("IOCTL_WDMAUD_SET_VOLUME: invalid device number, C %08x [%ls] DT %02x DN %02x",
                        pContext,
                        DeviceInfo->wstrDeviceInterface,
                        DeviceInfo->DeviceType,
                        DeviceInfo->DeviceNumber) );
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}



NTSTATUS
ValidateAndTranslateEx(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
#ifdef _WIN64
    DWORD        ValidationSize32,
#endif
    DWORD        ValidationSize,
    ULONG       *pTranslatedDeviceNumber
    )
{
#ifdef _WIN64
    if (IoIs32bitProcess(pIrp)) {

        if (DeviceInfo->DataBufferSize != ValidationSize32)
        {
            RETURN( STATUS_INVALID_BUFFER_SIZE );
        }

    } else {
#endif
        if (DeviceInfo->DataBufferSize != ValidationSize)
        {
            RETURN( STATUS_INVALID_BUFFER_SIZE );
        }
#ifdef _WIN64
    }
#endif

    *pTranslatedDeviceNumber = wdmaudTranslateDeviceNumber(pContext,
                                                         DeviceInfo->DeviceType,
                                                         DeviceInfo->wstrDeviceInterface,
                                                         DeviceInfo->DeviceNumber);
    if (MAXULONG == *pTranslatedDeviceNumber) {

        DPF(DL_WARNING|FA_IOCTL,("IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA: invalid device number, C %08x [%ls] DT %02x DN %02x",
                        pContext,
                        DeviceInfo->wstrDeviceInterface,
                        DeviceInfo->DeviceType,
                        DeviceInfo->DeviceNumber) );
        RETURN( STATUS_INVALID_PARAMETER );
    }
    return STATUS_SUCCESS;
}


//
// Now come the dispatch routines.
//

NTSTATUS
Dispatch_WaveOutWritePin(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    OUT BOOL    *pCompletedIrp  // TRUE if Irp was completed.
    )
{
    ULONG             TranslatedDeviceNumber;
    PSTREAM_HEADER_EX pStreamHeader;
    LPWAVEHDR         pWaveHdr = NULL;
#ifdef _WIN64
    LPWAVEHDR32       pWaveHdr32;
#endif
    PWRITE_CONTEXT      pWriteContext = NULL;


    NTSTATUS Status = STATUS_SUCCESS; // Assume success

    //
    //  Verify that we received a valid waveheader
    //
    Status = ValidateAndTranslateEx(pIrp, pContext, DeviceInfo,
#ifdef _WIN64
                                    sizeof(WAVEHDR32),
#endif
                                    sizeof(WAVEHDR), &TranslatedDeviceNumber);

    if( NT_SUCCESS(Status) )
    {
        Status = AudioAllocateMemory_Fixed(sizeof(WRITE_CONTEXT) + sizeof(STREAM_HEADER_EX), 
                                           TAG_Audx_CONTEXT,
                                           ZERO_FILL_MEMORY,
                                           &pWriteContext);
        if(NT_SUCCESS(Status))
        {
            Status = CaptureBufferToLocalPool(DeviceInfo->DataBuffer,
                                              DeviceInfo->DataBufferSize,
                                              &pWaveHdr
#ifdef _WIN64
                                              ,0
#endif
                                              );
            if (!NT_SUCCESS(Status))
            {
                AudioFreeMemory( sizeof(WRITE_CONTEXT) + sizeof(STREAM_HEADER_EX),
                                 &pWriteContext );
                return STATUS_INSUFFICIENT_RESOURCES;

            } else {

#ifdef _WIN64
                if (IoIs32bitProcess(pIrp)) {
                    // Thunk pWaveHdr to 64 bits.
                    pWaveHdr32=(LPWAVEHDR32)pWaveHdr;
                    pWriteContext->whInstance.wh.lpData=(LPSTR)(UINT_PTR)pWaveHdr32->lpData;
                    pWriteContext->whInstance.wh.dwBufferLength=pWaveHdr32->dwBufferLength;
                    pWriteContext->whInstance.wh.dwBytesRecorded=pWaveHdr32->dwBytesRecorded;
                    pWriteContext->whInstance.wh.dwUser=(DWORD_PTR)pWaveHdr32->dwUser;
                    pWriteContext->whInstance.wh.dwFlags=pWaveHdr32->dwFlags;
                    pWriteContext->whInstance.wh.dwLoops=pWaveHdr32->dwLoops;
                    pWriteContext->whInstance.wh.lpNext=(LPWAVEHDR)(UINT_PTR)pWaveHdr32->lpNext;
                    pWriteContext->whInstance.wh.reserved=(DWORD_PTR)pWaveHdr32->reserved;
                } else {
#endif
                    //
                    //  Copy the wavehdr to our local structure
                    //
                    RtlCopyMemory( &pWriteContext->whInstance.wh,
                                   pWaveHdr,
                                   sizeof(WAVEHDR));
#ifdef _WIN64
                }
#endif

                try
                {
                    ProbeForRead(pWriteContext->whInstance.wh.lpData,
                                 pWriteContext->whInstance.wh.dwBufferLength,
                                 sizeof(BYTE));
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    AudioFreeMemory_Unknown( &pWaveHdr );
                    AudioFreeMemory( sizeof(WRITE_CONTEXT) + sizeof(STREAM_HEADER_EX),
                                     &pWriteContext );
                    Status = GetExceptionCode();
                }

                if (!NT_SUCCESS(Status))
                {
                    return Status;
                }

                wdmaudMapBuffer ( pIrp,
                                  (PVOID)pWriteContext->whInstance.wh.lpData,
                                  pWriteContext->whInstance.wh.dwBufferLength,
                                  &pWriteContext->whInstance.wh.lpData,
                                  &pWriteContext->pBufferMdl,
                                  pContext,
                                  FALSE);

                //
                // If we get a zero-length buffer, it is alright to not have
                // a kernel mapped buffer.  Otherwise, fail if no Mdl or buffer.
                //
                if ( (pWriteContext->whInstance.wh.dwBufferLength != 0) &&
                     ((NULL == pWriteContext->pBufferMdl) ||
                      (NULL == pWriteContext->whInstance.wh.lpData)) )
                {
                    wdmaudUnmapBuffer( pWriteContext->pBufferMdl );
                    AudioFreeMemory_Unknown( &pWaveHdr );
                    AudioFreeMemory_Unknown( &pWriteContext );
                    return STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    pWriteContext->whInstance.wh.reserved = (DWORD_PTR)pIrp;  // store to complete later
                    pWriteContext->pCapturedWaveHdr = pWaveHdr;

                    pStreamHeader = (PSTREAM_HEADER_EX)(pWriteContext + 1);
                    pStreamHeader->Header.Data = pWriteContext->whInstance.wh.lpData;

                    //
                    //  Must cleanup any mapped buffers and allocated memory
                    //  on error paths in WriteWaveOutPin
                    //
                    Status = WriteWaveOutPin(&pContext->WaveOutDevs[TranslatedDeviceNumber],
                                             DeviceInfo->DeviceHandle,
                                             (LPWAVEHDR)pWriteContext,
                                             pStreamHeader,
                                             pIrp,
                                             pContext,
                                             pCompletedIrp );
                    //
                    // Upon return from this routine, pCompetedIrp will be set.
                    // if TRUE, the issue of the Irp was successful and it was
                    // marked pending when it was added to the delay queue. Thus
                    // we must not complete it a second time.
                    // If FALSE, there was some error and the Irp should be 
                    // completed.
                    //  
                }
            }
        }
    }
    return Status;
}


NTSTATUS
Dispatch_WaveInReadPin(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    OUT BOOL    *pCompletedIrp  // TRUE if Irp was completed.
    )
{
    ULONG             TranslatedDeviceNumber;
    PSTREAM_HEADER_EX pStreamHeader = NULL;
    LPWAVEHDR         pWaveHdr;
#ifdef _WIN64
    LPWAVEHDR32       pWaveHdr32;
#endif

    NTSTATUS Status = STATUS_SUCCESS; // Assume success

    //
    // Assume that things will be successful. Write back that it's not completed.
    //
    *pCompletedIrp = FALSE;

    //
    //  Verify that we received a valid waveheader
    //
    Status = ValidateAndTranslateEx(pIrp, pContext, DeviceInfo,
#ifdef _WIN64
                                    sizeof(WAVEHDR32),
#endif
                                    sizeof(WAVEHDR), &TranslatedDeviceNumber);


    Status = AudioAllocateMemory_Fixed(sizeof(STREAM_HEADER_EX), 
                                       TAG_Audh_STREAMHEADER,
                                       ZERO_FILL_MEMORY,
                                       &pStreamHeader);
    if(NT_SUCCESS(Status))
    {
        wdmaudMapBuffer(pIrp,
                        DeviceInfo->DataBuffer,
                        DeviceInfo->DataBufferSize,
                        &pWaveHdr,
                        &pStreamHeader->pHeaderMdl,
                        pContext,
                        TRUE);
        if (NULL == pStreamHeader->pHeaderMdl)
        {
            AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
            return STATUS_INSUFFICIENT_RESOURCES;

        } else {

            LPVOID lpData;
            DWORD  dwBufferLength;

            Status = CaptureBufferToLocalPool(
                        DeviceInfo->DataBuffer,
                        DeviceInfo->DataBufferSize,
                        &pStreamHeader->pWaveHdrAligned
#ifdef _WIN64
                        ,(IoIs32bitProcess(pIrp))?sizeof(WAVEHDR):0
#endif
                        );
            if (!NT_SUCCESS(Status))
            {
                wdmaudUnmapBuffer( pStreamHeader->pHeaderMdl );
                AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
                return STATUS_INSUFFICIENT_RESOURCES;
            }

#ifdef _WIN64
            // Thunk the wave header if required.
            // Note this is an IN PLACE thunk, so we MUST do it in
            // last element to first element order!!!
            if (IoIs32bitProcess(pIrp)) {
                // Thunk pWaveHdrAligned to 64 bits.
                pWaveHdr32=(LPWAVEHDR32)pStreamHeader->pWaveHdrAligned;
                pStreamHeader->pWaveHdrAligned->reserved=(DWORD_PTR)pWaveHdr32->reserved;
                pStreamHeader->pWaveHdrAligned->lpNext=(LPWAVEHDR)(UINT_PTR)pWaveHdr32->lpNext;
                pStreamHeader->pWaveHdrAligned->dwLoops=pWaveHdr32->dwLoops;
                pStreamHeader->pWaveHdrAligned->dwFlags=pWaveHdr32->dwFlags;
                pStreamHeader->pWaveHdrAligned->dwUser=(DWORD_PTR)pWaveHdr32->dwUser;
                pStreamHeader->pWaveHdrAligned->dwBytesRecorded=pWaveHdr32->dwBytesRecorded;
                pStreamHeader->pWaveHdrAligned->dwBufferLength=pWaveHdr32->dwBufferLength;
                pStreamHeader->pWaveHdrAligned->lpData=(LPSTR)(UINT_PTR)pWaveHdr32->lpData;
            }
#endif

            //
            //  Capture these parameters before probing
            //
            lpData = pStreamHeader->pWaveHdrAligned->lpData;
            dwBufferLength = pStreamHeader->pWaveHdrAligned->dwBufferLength;

            try
            {
                ProbeForWrite(lpData,
                              dwBufferLength,
                              sizeof(BYTE));
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                AudioFreeMemory_Unknown( &pStreamHeader->pWaveHdrAligned );
                wdmaudUnmapBuffer(pStreamHeader->pHeaderMdl);
                AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
                Status = GetExceptionCode();
            }

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }

            wdmaudMapBuffer( pIrp,
                             lpData,
                             dwBufferLength,
                             &pStreamHeader->Header.Data,
                             &pStreamHeader->pBufferMdl,
                             pContext,
                             TRUE); // will be freed on completion

            //
            // If we get a zero-length buffer, it is alright to not have
            // a kernel mapped buffer.  Otherwise, fail if no Mdl or buffer.
            //
            if ( (dwBufferLength != 0) &&
                 ((NULL == pStreamHeader->pBufferMdl) ||
                 (NULL == pStreamHeader->Header.Data)) )
            {
                wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
                AudioFreeMemory_Unknown( &pStreamHeader->pWaveHdrAligned );
                wdmaudUnmapBuffer(pStreamHeader->pHeaderMdl);
                AudioFreeMemory_Unknown( &pStreamHeader );
                return STATUS_INSUFFICIENT_RESOURCES;

            } else {

                pStreamHeader->pIrp               = pIrp;  // store so we can complete later
                pStreamHeader->Header.FrameExtent = dwBufferLength ;
                pStreamHeader->pdwBytesRecorded   = &pWaveHdr->dwBytesRecorded;  // store so we can use later
#ifdef _WIN64
                // Fixup dwBytesRecorded pointer for 32 bit irps.
                if (IoIs32bitProcess(pIrp)) {
                    pStreamHeader->pdwBytesRecorded   = &((LPWAVEHDR32)pWaveHdr)->dwBytesRecorded;
                }
#endif

                //
                //  Must cleanup any mapped buffers and allocated memory
                //  on error paths in ReadWaveInPin
                //
                Status = ReadWaveInPin( &pContext->WaveInDevs[TranslatedDeviceNumber],
                                        DeviceInfo->DeviceHandle,
                                        pStreamHeader,
                                        pIrp,
                                        pContext,
                                        pCompletedIrp );
                //
                // If ReadWaveInPin returns something other then STATUS_PENDING
                // we could have problems.  But only if we marked the IRP as pending.
                // All other return codes should be handled normally.
                //
#ifdef DEBUG
                if( *pCompletedIrp ) {
                    ASSERT(Status == STATUS_PENDING);
                }
#endif
            }
        }
    }
    return Status;
}



NTSTATUS
Dispatch_MidiInReadPin(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    OUT BOOL    *pCompletedIrp  // TRUE if Irp was completed.
    )
{
    ULONG      TranslatedDeviceNumber;
    PMIDIINHDR pNewMidiInHdr = NULL;
    LPMIDIDATA pMidiData;

    NTSTATUS Status = STATUS_SUCCESS; // Assume success

    //
    // Assume that things will be successful. Write back that it's not completed.
    //
    ASSERT(FALSE == *pCompletedIrp );

    //
    //  Verify that we received a valid mididata structure
    //
    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  sizeof(MIDIDATA),
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        Status = AudioAllocateMemory_Fixed(sizeof(*pNewMidiInHdr), 
                                           TAG_Aude_MIDIHEADER,
                                           ZERO_FILL_MEMORY,
                                           &pNewMidiInHdr);
        if(NT_SUCCESS(Status))
        {
            wdmaudMapBuffer( pIrp,
                             DeviceInfo->DataBuffer,
                             DeviceInfo->DataBufferSize,
                             &pMidiData,
                             &pNewMidiInHdr->pMdl,
                             pContext,
                             TRUE);
            if (NULL == pNewMidiInHdr->pMdl)
            {
                AudioFreeMemory( sizeof(*pNewMidiInHdr),&pNewMidiInHdr );
                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

                //
                // wdmaudPreparteIrp marks the irp as pending, thus
                // we must not complete the irp when we get to this 
                // point in the code.
                //
                Status = wdmaudPrepareIrp ( pIrp, MidiInDevice, pContext,  &pPendingIrpContext );
                if (NT_SUCCESS(Status)) 
                {
                    //
                    //  Initialize this new MidiIn header
                    //
                    pNewMidiInHdr->pMidiData           = pMidiData;
                    pNewMidiInHdr->pIrp                = pIrp;
                    pNewMidiInHdr->pPendingIrpContext  = pPendingIrpContext;

                    //
                    //  Add this header to the tail of the queue
                    //
                    //  Must cleanup any mapped buffers and allocated memory
                    //  on error paths in AddBufferToMidiInQueue
                    //
                    Status = AddBufferToMidiInQueue( pContext->MidiInDevs[TranslatedDeviceNumber].pMidiPin,
                                                     pNewMidiInHdr );

                    if (STATUS_PENDING != Status)
                    {
                        // Must have been an error, complete Irp
                        wdmaudUnmapBuffer( pNewMidiInHdr->pMdl );
                        AudioFreeMemory_Unknown( &pNewMidiInHdr );

                        wdmaudUnprepareIrp( pIrp, Status, 0, pPendingIrpContext );

                    } 
                    //
                    // because we marked the irp pending, we don't want to 
                    // complete it when we return.  So, tell the caller not
                    // to complete the Irp.
                    //
                    *pCompletedIrp = TRUE;
                }
            }
        } 
    }
    return Status;
}


NTSTATUS
Dispatch_State(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    ULONG        IoCode
    )
{
    ULONG    TranslatedDeviceNumber;
    NTSTATUS Status = STATUS_SUCCESS; // Assume success

    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  0,
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        switch(IoCode)
        {
            //
            // Midi out state changes
            //
        case IOCTL_WDMAUD_MIDI_OUT_RESET:
            Status = StateMidiOutPin ( pContext->MidiOutDevs[TranslatedDeviceNumber].pMidiPin,
                                       KSSTATE_STOP );
            break;
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA:
            Status = WriteMidiEventPin(&pContext->MidiOutDevs[TranslatedDeviceNumber],
                                       PtrToUlong(DeviceInfo->DataBuffer));
            break;

            //
            // Midi in state changes
            //
        case IOCTL_WDMAUD_MIDI_IN_STOP:
            Status = StateMidiInPin ( pContext->MidiInDevs[TranslatedDeviceNumber].pMidiPin,
                                      KSSTATE_PAUSE );
            break;
        case IOCTL_WDMAUD_MIDI_IN_RECORD:
            Status = StateMidiInPin ( pContext->MidiInDevs[TranslatedDeviceNumber].pMidiPin,
                                      KSSTATE_RUN );
            break;
        case IOCTL_WDMAUD_MIDI_IN_RESET:
            Status = ResetMidiInPin ( pContext->MidiInDevs[TranslatedDeviceNumber].pMidiPin );
            break;


            //
            // Wave out state changes
            //

        case IOCTL_WDMAUD_WAVE_OUT_PAUSE:
            Status = StateWavePin ( &pContext->WaveOutDevs[TranslatedDeviceNumber],
                                    DeviceInfo->DeviceHandle,
                                    KSSTATE_PAUSE );
            break;
        case IOCTL_WDMAUD_WAVE_OUT_PLAY:
            Status = StateWavePin ( &pContext->WaveOutDevs[TranslatedDeviceNumber],
                                    DeviceInfo->DeviceHandle,
                                    KSSTATE_RUN );
            break;
        case IOCTL_WDMAUD_WAVE_OUT_RESET:
            Status = StateWavePin ( &pContext->WaveOutDevs[TranslatedDeviceNumber],
                                    DeviceInfo->DeviceHandle,
                                    KSSTATE_PAUSE );
            if ( NT_SUCCESS(Status) ) 
            {
                Status = ResetWaveOutPin ( &pContext->WaveOutDevs[TranslatedDeviceNumber],
                                           DeviceInfo->DeviceHandle ) ;
            }
            break;
        case IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP:
            Status = BreakLoopWaveOutPin ( &pContext->WaveOutDevs[TranslatedDeviceNumber],
                                           DeviceInfo->DeviceHandle );
            break;

            //
            // Wave In State changes
            //

        case IOCTL_WDMAUD_WAVE_IN_STOP:
            Status = StateWavePin ( &pContext->WaveInDevs[TranslatedDeviceNumber],
                                    DeviceInfo->DeviceHandle,
                                    KSSTATE_PAUSE );
            break;
        case IOCTL_WDMAUD_WAVE_IN_RECORD:
            Status = StateWavePin ( &pContext->WaveInDevs[TranslatedDeviceNumber],
                                    DeviceInfo->DeviceHandle,
                                    KSSTATE_RUN );
            break;
        case IOCTL_WDMAUD_WAVE_IN_RESET:
            Status = StateWavePin ( &pContext->WaveInDevs[TranslatedDeviceNumber],
                                    DeviceInfo->DeviceHandle,
                                    KSSTATE_STOP );
            break;
        default:
            break;
        }
    }
    return Status;
}


NTSTATUS
Dispatch_GetCapabilities(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo
    )
{
    ULONG        TranslatedDeviceNumber;
    PVOID        pMappedBuffer;
    PMDL         pMdl;
    NTSTATUS     Status = STATUS_SUCCESS; // Assume success

    //
    // Passing in DeviceInfo->DataBufferSize as the validation size because we don't care
    // about the buffer check but we still want the translation code.  It's just a short
    // cut on the ValidateAndTranslate function.
    //
    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  DeviceInfo->DataBufferSize, // Don't care about buffer
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        //
        // Map this buffer into a system address
        //
        wdmaudMapBuffer( pIrp,
                         DeviceInfo->DataBuffer,
                         DeviceInfo->DataBufferSize,
                         &pMappedBuffer,
                         &pMdl,
                         pContext,
                         TRUE);
        if (NULL == pMappedBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = wdmaudGetDevCaps( pContext,
                                       DeviceInfo->DeviceType,
                                       TranslatedDeviceNumber,
                                       pMappedBuffer,
                                       DeviceInfo->DataBufferSize);

            pIrp->IoStatus.Information = sizeof(DEVICEINFO);

            //
            //  Free the MDL
            //
            wdmaudUnmapBuffer( pMdl );
        }
    }
    return Status;
}


NTSTATUS
Dispatch_OpenPin(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo
    )
{
    ULONG        TranslatedDeviceNumber;
    NTSTATUS     Status = STATUS_SUCCESS; // Assume success

    //
    // Passing in DeviceInfo->DataBufferSize as the validation size because we don't care
    // about the buffer check but we still want the translation code.  It's just a short
    // cut on the ValidateAndTranslate function.
    //
    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  DeviceInfo->DataBufferSize, // Don't care about buffer
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        switch (DeviceInfo->DeviceType)
        {
            case WaveOutDevice:
            case WaveInDevice:

                if (DeviceInfo->DataBufferSize < sizeof(PCMWAVEFORMAT))
                {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                } else {
                    LPWAVEFORMATEX pWaveFmt = NULL;

                    //
                    //  Ensure alignment by copying to temporary buffer
                    //
                    Status = CaptureBufferToLocalPool(DeviceInfo->DataBuffer,
                                                      DeviceInfo->DataBufferSize,
                                                      &pWaveFmt
#ifdef _WIN64
                                                      ,0
#endif
                                                      );
                    if (!NT_SUCCESS(Status))
                    {
                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        if ((pWaveFmt->wFormatTag != WAVE_FORMAT_PCM) &&
                            ((DeviceInfo->DataBufferSize < sizeof(WAVEFORMATEX)) ||
                             (DeviceInfo->DataBufferSize != sizeof(WAVEFORMATEX) + pWaveFmt->cbSize)))
                        {
                            Status = STATUS_INVALID_BUFFER_SIZE;
                        }
                        else
                        {
                            Status = OpenWavePin( pContext,
                                                  TranslatedDeviceNumber,
                                                  pWaveFmt,
                                                  DeviceInfo->DeviceHandle,
                                                  DeviceInfo->dwFlags,
                                                  (WaveOutDevice == DeviceInfo->DeviceType?
                                                      KSPIN_DATAFLOW_IN:KSPIN_DATAFLOW_OUT) );
                        }

                        //
                        //  Free the temporary buffer
                        //
                        AudioFreeMemory_Unknown( &pWaveFmt );
                    }
                }

                break;

            case MidiOutDevice:
                Status = OpenMidiPin( pContext, TranslatedDeviceNumber, KSPIN_DATAFLOW_IN );
                break;

            case MidiInDevice:
                Status = OpenMidiPin( pContext, TranslatedDeviceNumber, KSPIN_DATAFLOW_OUT );
                break;

            default:
                Status = STATUS_NOT_SUPPORTED;
                break;
        }

        pIrp->IoStatus.Information = sizeof(DEVICEINFO);
    }
    return Status;
}

NTSTATUS
Dispatch_ClosePin(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo
    )
{
    ULONG        TranslatedDeviceNumber;
    NTSTATUS     Status = STATUS_SUCCESS; // Assume success

    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  0,
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        switch (DeviceInfo->DeviceType)
        {
            case WaveOutDevice:
                CloseTheWavePin( &pContext->WaveOutDevs[TranslatedDeviceNumber],
                                 DeviceInfo->DeviceHandle );
                break;

            case WaveInDevice:
                CloseTheWavePin( &pContext->WaveInDevs[TranslatedDeviceNumber],
                                 DeviceInfo->DeviceHandle );
                break;

            case MidiOutDevice:
                CloseMidiDevicePin( &pContext->MidiOutDevs[TranslatedDeviceNumber] );
                break;

            case MidiInDevice:
                CloseMidiDevicePin( &pContext->MidiInDevs[TranslatedDeviceNumber] );
                break;

            default:
                Status = STATUS_NOT_SUPPORTED;
                break;
        }
    }

    return Status;
}

NTSTATUS
Dispatch_GetVolume(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    ULONG        IoCode
    )
{
    DWORD    dwLeft, dwRight;
    ULONG    TranslatedDeviceNumber;
    PVOID    pMappedBuffer;
    PMDL     pMdl;
    ULONG    ulDeviceType;
    NTSTATUS Status = STATUS_SUCCESS; // Assume success

    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  sizeof(DWORD),
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        switch(IoCode)
        {
        case IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME:
            ulDeviceType = MidiOutDevice;
            break;
        case IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME:
            ulDeviceType = WaveOutDevice;
            break;
        case IOCTL_WDMAUD_GET_VOLUME:
            ulDeviceType = DeviceInfo->DeviceType;
            break;
        default:
            return STATUS_INVALID_PARAMETER;
            break;
        }

        Status = GetVolume(pContext,
                           TranslatedDeviceNumber,
                           ulDeviceType,
                           &dwLeft,
                           &dwRight);
        if( NT_SUCCESS( Status ) )
        {
            wdmaudMapBuffer( pIrp,           // Wave buffers look like
                             DeviceInfo->DataBuffer,     // DeviceInfo->DataBuffer
                             DeviceInfo->DataBufferSize, // DeviceInfo->DataBufferSize
                             &pMappedBuffer, 
                             &pMdl,
                             pContext,
                             TRUE);
            if (NULL == pMappedBuffer)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                //
                // Write this info back.
                //
                *((LPDWORD)pMappedBuffer) = MAKELONG(LOWORD(dwLeft),
                                                     LOWORD(dwRight));
                wdmaudUnmapBuffer( pMdl );
                pIrp->IoStatus.Information = sizeof(DEVICEINFO);
            }
        }
    }
    return Status;
}
                            

NTSTATUS
Dispatch_SetVolume(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    ULONG        IoCode
    )
{
    ULONG    TranslatedDeviceNumber;
    PVOID    pMappedBuffer;
    PMDL     pMdl;
    ULONG    ulDeviceType;
    NTSTATUS Status = STATUS_SUCCESS; // Assume success

    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  sizeof(DWORD),
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        wdmaudMapBuffer( pIrp,
                         DeviceInfo->DataBuffer,
                         DeviceInfo->DataBufferSize,
                         &pMappedBuffer,
                         &pMdl,
                         pContext,
                         TRUE);
        if (NULL == pMappedBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            switch(IoCode)
            {
            case IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME:
                ulDeviceType = MidiOutDevice;
                break;
            case IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME:
                ulDeviceType = WaveOutDevice;
                break;
            case IOCTL_WDMAUD_SET_VOLUME:
                ulDeviceType = DeviceInfo->DeviceType;
                break;
            default:
                return STATUS_INVALID_PARAMETER;
                break;
            }

            Status = SetVolume(pContext,
                               TranslatedDeviceNumber,
                               ulDeviceType,
                               LOWORD(*((LPDWORD)pMappedBuffer)),
                               HIWORD(*((LPDWORD)pMappedBuffer)));

            wdmaudUnmapBuffer( pMdl );
            pIrp->IoStatus.Information = sizeof(DEVICEINFO);
        }
    }
    return Status;
}

NTSTATUS
Dispatch_WaveGetPos(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    ULONG        IoCode
    )
{
    WAVEPOSITION WavePos;
    ULONG        TranslatedDeviceNumber;
    PVOID        pMappedBuffer;
    PMDL         pMdl;
    NTSTATUS     Status = STATUS_SUCCESS; // Assume success

    Status = ValidateAndTranslate(pContext,
                                  DeviceInfo,
                                  sizeof(DWORD),
                                  &TranslatedDeviceNumber);
    if( NT_SUCCESS(Status) )
    {
        //
        // Map this buffer into a system address
        //
        wdmaudMapBuffer( pIrp,
                         DeviceInfo->DataBuffer,
                         DeviceInfo->DataBufferSize,
                         &pMappedBuffer,
                         &pMdl,
                         pContext,
                         TRUE);
        if (NULL == pMappedBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            WavePos.Operation = KSPROPERTY_TYPE_GET;
            switch(IoCode)
            {
            case IOCTL_WDMAUD_WAVE_OUT_GET_POS:
                Status = PosWavePin(&pContext->WaveOutDevs[TranslatedDeviceNumber],
                                    DeviceInfo->DeviceHandle,
                                    &WavePos );
                break;
            case IOCTL_WDMAUD_WAVE_IN_GET_POS:
                Status = PosWavePin ( &pContext->WaveInDevs[TranslatedDeviceNumber],
                      DeviceInfo->DeviceHandle,
                      &WavePos );
                break;
            default:
                return STATUS_INVALID_PARAMETER;
                break;
            }
            *((LPDWORD)pMappedBuffer) = WavePos.BytePos;

            //
            //  Free the MDL
            //
            wdmaudUnmapBuffer( pMdl );

            pIrp->IoStatus.Information = sizeof(DEVICEINFO);
        }
    }
    return Status;
}

NTSTATUS
Dispatch_MidiOutWriteLongdata(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo,
    BOOL        *pCompletedIrp
    )
{
    ULONG             TranslatedDeviceNumber;
    LPMIDIHDR         pMidiHdr = NULL;
#ifdef _WIN64
    LPMIDIHDR32       pMidiHdr32;
#endif
    PSTREAM_HEADER_EX pStreamHeader = NULL;
    NTSTATUS          Status = STATUS_SUCCESS; // Assume success

    ASSERT( FALSE == *pCompletedIrp );
    //
    //  Verify that we received a valid midiheader
    //
    Status = ValidateAndTranslateEx(pIrp, pContext, DeviceInfo,
#ifdef _WIN64
                                    sizeof(MIDIHDR32),
#endif
                                    sizeof(MIDIHDR), &TranslatedDeviceNumber);
    if( !NT_SUCCESS(Status) )
    {
        return Status;
    }

    Status = AudioAllocateMemory_Fixed(sizeof(STREAM_HEADER_EX), 
                                       TAG_Audh_STREAMHEADER,
                                       ZERO_FILL_MEMORY,
                                       &pStreamHeader);
    if(NT_SUCCESS(Status))
    {
        Status = CaptureBufferToLocalPool(DeviceInfo->DataBuffer,
                                          DeviceInfo->DataBufferSize,
                                          &pMidiHdr
#ifdef _WIN64
                                          ,(IoIs32bitProcess(pIrp))?sizeof(MIDIHDR):0
#endif
                                          );
        if (!NT_SUCCESS(Status))
        {
            AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
            //
            // Why do we change the status here?
            //
            return STATUS_INSUFFICIENT_RESOURCES;

        } else {

            LPVOID lpData;
            DWORD  dwBufferLength;

#ifdef _WIN64
            // Thunk the midi header if required.
            // Note this is an IN PLACE thunk, so we MUST do it in
            // last element to first element order!!!
            if (IoIs32bitProcess(pIrp)) {
                // Thunk pMidiHdr to 64 bits.
                pMidiHdr32=(LPMIDIHDR32)pMidiHdr;
                #if (WINVER >= 0x0400)
                {
                ULONG i;
                // Again we must go from LAST element to first element in this array.
                // This IS the reverse of for (i=0; i<(sizeof(pMidiHdr32->dwReserved)/sizeof(UINT32)); i++)
                for (i=(sizeof(pMidiHdr32->dwReserved)/sizeof(UINT32)); i--;) {
                    pMidiHdr->dwReserved[i]=(DWORD_PTR)pMidiHdr32->dwReserved[i];
                    }
                }
                pMidiHdr->dwOffset=pMidiHdr32->dwOffset;
                #endif
                pMidiHdr->reserved=(DWORD_PTR)pMidiHdr32->reserved;
                pMidiHdr->lpNext=(LPMIDIHDR)(UINT_PTR)pMidiHdr32->lpNext;
                pMidiHdr->dwFlags=pMidiHdr32->dwFlags;
                pMidiHdr->dwUser=(DWORD_PTR)pMidiHdr32->dwUser;
                pMidiHdr->dwBytesRecorded=pMidiHdr32->dwBytesRecorded;
                pMidiHdr->dwBufferLength=pMidiHdr32->dwBufferLength;
                pMidiHdr->lpData=(LPSTR)(UINT_PTR)pMidiHdr32->lpData;
            }
#endif

            //
            //  Capture these parameters before probing
            //
            lpData = pMidiHdr->lpData;
            dwBufferLength = pMidiHdr->dwBufferLength;

            try
            {
                ProbeForRead(lpData, dwBufferLength, sizeof(BYTE));
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                AudioFreeMemory_Unknown( &pMidiHdr );
                AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
                Status = GetExceptionCode();
            }

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }

            wdmaudMapBuffer(pIrp,
                            lpData,
                            dwBufferLength,
                            &pStreamHeader->Header.Data,
                            &pStreamHeader->pBufferMdl,
                            pContext,
                            TRUE); // will be freed on completion

            //
            // If we get a zero-length buffer, it is alright to not have
            // a kernel mapped buffer.  Otherwise, fail if no Mdl or buffer.
            //
            if ( (dwBufferLength != 0) &&
                 ((NULL == pStreamHeader->pBufferMdl) ||
                  (NULL == pStreamHeader->Header.Data)) )
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
                AudioFreeMemory_Unknown( &pMidiHdr );
                AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );

            } else {

                pStreamHeader->pIrp = pIrp;  // store so we can complete later
                pStreamHeader->pMidiPin =
                    pContext->MidiOutDevs[TranslatedDeviceNumber].pMidiPin;
                pStreamHeader->Header.FrameExtent = dwBufferLength;

                //
                //  Must cleanup any mapped buffers and allocated memory
                //  on error paths in WriteMidiOutPin
                //
                Status = WriteMidiOutPin( pMidiHdr,pStreamHeader,pCompletedIrp );

                //
                // Because WriteMidiOutPin is synchronous, pCompetedIrp will
                // always come back FALSE so that the caller can clean up the
                // Irp.
                //
                ASSERT( FALSE == *pCompletedIrp );
            }
        }
    }
    return Status;
}

NTSTATUS
ValidateAndCapture(
    PIRP         pIrp,
    LPDEVICEINFO DeviceInfo,
#ifdef _WIN64
    DWORD        ValidationSize32,
#endif
    DWORD        ValidationSize,
    PVOID       *ppMappedBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Assume that we're going to have a problem.
    //
    *ppMappedBuffer = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess(pIrp)) {

        if (DeviceInfo->DataBufferSize != ValidationSize32)
        {
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return STATUS_INVALID_BUFFER_SIZE;
        }

    } else {
#endif
        if (DeviceInfo->DataBufferSize != ValidationSize)
        {
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return STATUS_INVALID_BUFFER_SIZE;
        }
#ifdef _WIN64
    }
#endif
    //
    // Copy to local data storage
    //
    Status = CaptureBufferToLocalPool(DeviceInfo->DataBuffer,
                                      DeviceInfo->DataBufferSize,
                                      ppMappedBuffer
#ifdef _WIN64
                                      ,(IoIs32bitProcess(pIrp))?ValidationSize:0
#endif
                                      );
    return Status;
}

NTSTATUS
Dispatch_GetLineInfo(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo
    )
{
    PVOID    pMappedBuffer;
    NTSTATUS Status = STATUS_SUCCESS; // Assume success
    //
    //  The size specified in this member must be large enough to
    //  contain the base MIXERLINE structure.
    //
    Status = ValidateAndCapture(pIrp,DeviceInfo,
#ifdef _WIN64
                                sizeof(MIXERLINE32),
#endif
                                sizeof(MIXERLINE), &pMappedBuffer);
    if( !NT_SUCCESS(Status) )
    {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        goto Exit;
    }

#ifdef _WIN64
    // Now thunk the MIXERLINE structure to 64 bits.
    // WARNING we do this a simple easy way, but it is DEPENDENT on the
    // structure of MIXERLINE.  There is currently only 1 parameter that
    // changes in size between the 32 and 64 bit structures.  dwUser.
    // This will have to get more complicated if the MIXERLINE structure
    // ever has more stuff in it that needs to be thunked.

    if (IoIs32bitProcess(pIrp)) {

        // First move everything following the dwUser field in the 32 bit
        // structure down 4 bytes.
        RtlMoveMemory(&((PMIXERLINE32)pMappedBuffer)->cChannels,
                      &((PMIXERLINE32)pMappedBuffer)->dwComponentType,
                      sizeof(MIXERLINE32)-FIELD_OFFSET(MIXERLINE32,dwComponentType));

        // Now thunk dwUser to 64 bits.
        ((PMIXERLINE)pMappedBuffer)->dwUser=(DWORD_PTR)((PMIXERLINE32)pMappedBuffer)->dwUser;

    }
#endif

    if (NT_SUCCESS(Status))
    {
        Status = kmxlGetLineInfoHandler( pContext, DeviceInfo, pMappedBuffer );
        //
        // This call should have set the DeviceInfo->mmr and returned a valid
        // NTSTATUS value.
        //

#ifdef _WIN64
        // Now thunk the MIXERLINE structure back to 32 bits.
        // WARNING we do this a simple easy way, but it is DEPENDENT on the
        // structure of MIXERLINE.  There is currently only 1 parameter that
        // changes in size between the 32 and 64 bit structures.  dwUser.
        // This will have to get more complicated if the MIXERLINE structure
        // ever has more stuff in it that needs to be thunked.

        // Note that for in place thunks we must do them from LAST to FIRST
        // field order when thunking up to 64 bits and in FIRST to LAST
        // field order when thunking back down to 32 bits!!!
        if (IoIs32bitProcess(pIrp)) {

            // Just move everything that now is after dwComponentType back up 4 bytes.
            RtlMoveMemory(&((PMIXERLINE32)pMappedBuffer)->dwComponentType,
                          &((PMIXERLINE32)pMappedBuffer)->cChannels,
                          sizeof(MIXERLINE32)-FIELD_OFFSET(MIXERLINE32,dwComponentType));

        }
#endif

        //
        //  Copy back the contents of the captured buffer
        //
        CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                                  DeviceInfo->DataBufferSize,
                                  &pMappedBuffer);
    }

Exit:
    pIrp->IoStatus.Information = sizeof(DEVICEINFO);
    return Status;
}


NTSTATUS
Dispatch_GetLineControls(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo
    )
{
    PVOID    pamxctrl = NULL;
    PVOID    pamxctrlUnmapped;
    DWORD    dwSize;
    PVOID    pMappedBuffer;
    NTSTATUS Status = STATUS_SUCCESS; // Assume success

    //
    //  The size specified in this member must be large enough to
    //  contain the base MIXERLINECONTROL structure.
    //
    Status = ValidateAndCapture(pIrp,DeviceInfo,
#ifdef _WIN64
                                sizeof(MIXERLINECONTROLS32),
#endif
                                sizeof(MIXERLINECONTROLS), &pMappedBuffer);
    if( !NT_SUCCESS(Status) )
    {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        goto Exit;
    }


#ifdef _WIN64
    // Now thunk the MIXERLINECONTROL structure to 64 bits.
    // Currently this is easy to do as only the last field is different
    // in size and simply needs to be zero extended.

    // NOTE:  This structure also thus does NOT need any thunking in
    // the reverse direction!  How nice.

    // NOTE:  None of the mixer controls themselves need any thunking.
    // YEAH!!!
    if (IoIs32bitProcess(pIrp)) {

        ((LPMIXERLINECONTROLS)pMappedBuffer)->pamxctrl=(LPMIXERCONTROL)(UINT_PTR)((LPMIXERLINECONTROLS32)pMappedBuffer)->pamxctrl;

    }
#endif

    //
    //  Pick reasonable max values for the size and number of controls to eliminate overflow
    //
    if ( ( ((LPMIXERLINECONTROLS) pMappedBuffer)->cbmxctrl > 10000 ) ||
         ( ((LPMIXERLINECONTROLS) pMappedBuffer)->cControls > 10000 ) )
    {
        CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                                  DeviceInfo->DataBufferSize,
                                  &pMappedBuffer);
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        Status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        pamxctrlUnmapped = ((LPMIXERLINECONTROLS) pMappedBuffer)->pamxctrl;
        dwSize = ((LPMIXERLINECONTROLS) pMappedBuffer)->cbmxctrl *
                 ((LPMIXERLINECONTROLS) pMappedBuffer)->cControls;
        try
        {
            ProbeForWrite(pamxctrlUnmapped, dwSize, sizeof(DWORD));
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                                      DeviceInfo->DataBufferSize,
                                      &pMappedBuffer);
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            Status = GetExceptionCode();
        }
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Map the array of mixer controls into system space.  The
        // size of this buffer is the number of controls times the
        // size of each control.
        //
        Status = CaptureBufferToLocalPool(pamxctrlUnmapped,
                                          dwSize,
                                          &pamxctrl
#ifdef _WIN64
                                          ,0
#endif
                                          );

        if (NT_SUCCESS(Status))
        {
            //
            // Call the handler.
            //
            Status = kmxlGetLineControlsHandler(pContext,
                                                DeviceInfo,
                                                pMappedBuffer,
                                                pamxctrl );
            //
            // The previous call should have set the DeviceInfo->mmr and returned
            // a valid Status value.
            //

            CopyAndFreeCapturedBuffer(pamxctrlUnmapped,
                                      dwSize,
                                      &pamxctrl);
        } else {
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        }
    } else {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    }

    CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                              DeviceInfo->DataBufferSize,
                              &pMappedBuffer);
Exit:
    pIrp->IoStatus.Information = sizeof(DEVICEINFO);
    return Status;
}

#ifdef _WIN64

void
ThunkMixerControlDetails_Enter(
    PVOID pMappedBuffer
    )
{
    // Now thunk the MIXERCONTROLDETAILS structure to 64 bits.
    // This is an IN PLACE thunk, so MUST be done from last to first fields.

    ((LPMIXERCONTROLDETAILS)pMappedBuffer)->paDetails=(LPVOID)(UINT_PTR)((LPMIXERCONTROLDETAILS32)pMappedBuffer)->paDetails;
    ((LPMIXERCONTROLDETAILS)pMappedBuffer)->cbDetails=((LPMIXERCONTROLDETAILS32)pMappedBuffer)->cbDetails;
    // We always thunk the next field as if it were an HWND since that works for both cases.
    ((LPMIXERCONTROLDETAILS)pMappedBuffer)->hwndOwner=(HWND)(UINT_PTR)((LPMIXERCONTROLDETAILS32)pMappedBuffer)->hwndOwner;
    ((LPMIXERCONTROLDETAILS)pMappedBuffer)->cChannels=((LPMIXERCONTROLDETAILS32)pMappedBuffer)->cChannels;
    ((LPMIXERCONTROLDETAILS)pMappedBuffer)->dwControlID=((LPMIXERCONTROLDETAILS32)pMappedBuffer)->dwControlID;
    ((LPMIXERCONTROLDETAILS)pMappedBuffer)->cbStruct=((LPMIXERCONTROLDETAILS32)pMappedBuffer)->cbStruct;
}

void
ThunkMixerControlDetails_Leave(
    PVOID pMappedBuffer
    )
{
    // Now thunk the MIXERCONTROLDETAILS structure back to 32 bits.
    // This is an IN PLACE thunk, so MUST be done from FIRST to LAST
    // fields.  Remember the order is different depending on direction!

    ((LPMIXERCONTROLDETAILS32)pMappedBuffer)->cbStruct=((LPMIXERCONTROLDETAILS)pMappedBuffer)->cbStruct;
    ((LPMIXERCONTROLDETAILS32)pMappedBuffer)->dwControlID=((LPMIXERCONTROLDETAILS)pMappedBuffer)->dwControlID;
    ((LPMIXERCONTROLDETAILS32)pMappedBuffer)->cChannels=((LPMIXERCONTROLDETAILS)pMappedBuffer)->cChannels;
    // We always thunk the next field as if it were an HWND since that works for both cases.
    ((LPMIXERCONTROLDETAILS32)pMappedBuffer)->hwndOwner=(UINT32)(UINT_PTR)((LPMIXERCONTROLDETAILS)pMappedBuffer)->hwndOwner;
    ((LPMIXERCONTROLDETAILS32)pMappedBuffer)->cbDetails=((LPMIXERCONTROLDETAILS)pMappedBuffer)->cbDetails;
    ((LPMIXERCONTROLDETAILS32)pMappedBuffer)->paDetails=(UINT32)(UINT_PTR)((LPMIXERCONTROLDETAILS)pMappedBuffer)->paDetails;
}
#endif

NTSTATUS
Dispatch_GetControlDetails(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo
    )
{
    PVOID    paDetails = NULL;
    PVOID    paDetailsUnmapped;
    DWORD    dwSize;
    PVOID    pMappedBuffer;
    NTSTATUS Status = STATUS_SUCCESS; // Assume success.

    Status = ValidateAndCapture(pIrp,DeviceInfo,
#ifdef _WIN64
                                sizeof(MIXERCONTROLDETAILS32),
#endif
                                sizeof(MIXERCONTROLDETAILS), &pMappedBuffer);
    if( !NT_SUCCESS(Status) )
    {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        goto Exit;
    }

#ifdef _WIN64
    if (IoIs32bitProcess(pIrp)) {
        ThunkMixerControlDetails_Enter(pMappedBuffer);
    }
#endif

    //
    //  Pick reasonable max values for the data and number of controls to eliminate overflow
    //
    if ( ( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cbDetails      > 10000 ) ||
         ( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cChannels      > 100 )   ||
         ( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cMultipleItems > 100 ) )
    {
#ifdef _WIN64
        if (IoIs32bitProcess(pIrp)) {
            ThunkMixerControlDetails_Leave(pMappedBuffer);
        }
#endif
        CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                                  DeviceInfo->DataBufferSize,
                                  &pMappedBuffer);
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        Status = STATUS_INVALID_PARAMETER;
    } else {
        //
        // Map the array control details into system space.
        //
        paDetailsUnmapped = ((LPMIXERCONTROLDETAILS) pMappedBuffer)->paDetails;
        if( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cMultipleItems )
        {
            dwSize = ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cChannels *
                     ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cMultipleItems *
                     ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cbDetails;

        } else {
            dwSize = ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cChannels *
                     ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cbDetails;
        }

        try
        {
            ProbeForWrite(paDetailsUnmapped,
                          dwSize,
                          sizeof(DWORD));
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
#ifdef _WIN64
            if (IoIs32bitProcess(pIrp)) {
                ThunkMixerControlDetails_Leave(pMappedBuffer);
            }
#endif
            CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                                      DeviceInfo->DataBufferSize,
                                      &pMappedBuffer);
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            Status = GetExceptionCode();
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = CaptureBufferToLocalPool(paDetailsUnmapped,
                                          dwSize,
                                          &paDetails
#ifdef _WIN64
                                          ,0
#endif
                                          );

        if (NT_SUCCESS(Status))
        {
            //
            // Call the handler.
            //
            Status = kmxlGetControlDetailsHandler(pContext,
                                                  DeviceInfo,
                                                  pMappedBuffer,
                                                  paDetails);
            //
            // The previous call should have set DeviceInfo->mmr and returned
            // a valid Status value.
            //
            CopyAndFreeCapturedBuffer(paDetailsUnmapped,
                                      dwSize,
                                      &paDetails);
        } else {
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        }
    } else {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    }

#ifdef _WIN64
    if (IoIs32bitProcess(pIrp) && pMappedBuffer) {
        ThunkMixerControlDetails_Leave(pMappedBuffer);
    }
#endif
    CopyAndFreeCapturedBuffer( DeviceInfo->DataBuffer,
                               DeviceInfo->DataBufferSize,
                               &pMappedBuffer);
Exit:
    //
    // Always return the DEVICEINFO number of bytes from this call.
    //
    pIrp->IoStatus.Information = sizeof(DEVICEINFO);
    return Status;
}

NTSTATUS
Dispatch_SetControlDetails(
    PIRP         pIrp,
    PWDMACONTEXT pContext,
    LPDEVICEINFO DeviceInfo
    )
{
    PVOID    paDetails = NULL;
    PVOID    paDetailsUnmapped;
    DWORD    dwSize;
    PVOID    pMappedBuffer;
    NTSTATUS Status = STATUS_SUCCESS; //Assume success.

    Status = ValidateAndCapture(pIrp,DeviceInfo,
#ifdef _WIN64
                                sizeof(MIXERCONTROLDETAILS32),
#endif
                                sizeof(MIXERCONTROLDETAILS), &pMappedBuffer);
    if( !NT_SUCCESS(Status) )
    {
        goto Exit;
    }

#ifdef _WIN64
    // Now thunk the MIXERCONTROLDETAILS structure to 64 bits.
    // This is an IN PLACE thunk, so MUST be done from last to first fields.

    if (IoIs32bitProcess(pIrp)) {
        ThunkMixerControlDetails_Enter(pMappedBuffer);
    }
#endif

    //
    //  Pick reasonable max values for the data and number of controls to eliminate overflow
    //
    if ( ( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cbDetails      > 10000 ) ||
         ( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cChannels      > 100 )   ||
         ( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cMultipleItems > 100 ) )
    {
#ifdef _WIN64
        if (IoIs32bitProcess(pIrp)) {
            ThunkMixerControlDetails_Leave(pMappedBuffer);
        }
#endif
        CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                                  DeviceInfo->DataBufferSize,
                                  &pMappedBuffer);
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        Status = STATUS_INVALID_PARAMETER;
    } else {
        //
        // Map the array control details into system space.
        //
        paDetailsUnmapped = ((LPMIXERCONTROLDETAILS) pMappedBuffer)->paDetails;
        if( ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cMultipleItems )
        {
            dwSize = ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cChannels *
                     ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cMultipleItems *
                     ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cbDetails;

        } else {
            dwSize = ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cChannels *
                     ((LPMIXERCONTROLDETAILS) pMappedBuffer)->cbDetails;
        }

        try
        {
            ProbeForRead(((LPMIXERCONTROLDETAILS) pMappedBuffer)->paDetails,
                         dwSize,
                         sizeof(DWORD));
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
#ifdef _WIN64
            if (IoIs32bitProcess(pIrp)) {
                ThunkMixerControlDetails_Leave(pMappedBuffer);
            }
#endif
            CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                                      DeviceInfo->DataBufferSize,
                                      &pMappedBuffer);
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            Status = GetExceptionCode();
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = CaptureBufferToLocalPool(paDetailsUnmapped,
                                          dwSize,
                                          &paDetails
#ifdef _WIN64
                                          ,0
#endif
                                          );

        if (NT_SUCCESS(Status))
        {
            //
            // Call the handler.
            //
            Status = kmxlSetControlDetailsHandler(pContext,
                                                  DeviceInfo,
                                                  pMappedBuffer,
                                                  paDetails,
                                                  MIXER_FLAG_PERSIST );
            //
            // The previous call should have set DeviceInfo->mmr and returned
            // a valid Status value.
            //

            CopyAndFreeCapturedBuffer(paDetailsUnmapped,
                                      dwSize,
                                      &paDetails);
        } else {
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        }
    } else {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    }

#ifdef _WIN64
    if (IoIs32bitProcess(pIrp) && pMappedBuffer) {
        ThunkMixerControlDetails_Leave(pMappedBuffer);
    }
#endif
    CopyAndFreeCapturedBuffer(DeviceInfo->DataBuffer,
                              DeviceInfo->DataBufferSize,
                              &pMappedBuffer);

Exit:
    //
    // Always return sizeof(DEVICEINFO) for this call.
    //
    pIrp->IoStatus.Information = sizeof(DEVICEINFO);
    return Status;
}


NTSTATUS
Dispatch_GetHardwareEventData(
    PIRP         pIrp,
    LPDEVICEINFO DeviceInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Always return sizeof(DEVICEINFO) for this call.
    //
    pIrp->IoStatus.Information = sizeof(DEVICEINFO);

    if (DeviceInfo->DataBufferSize != 0)
    {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        Status = STATUS_INVALID_PARAMETER;
    } else {
        GetHardwareEventData(DeviceInfo);
    }

    return Status;
}


NTSTATUS
SoundDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
/*++

Routine Description:
    Driver dispatch routine. Processes IRPs based on IRP MajorFunction

Arguments:
    pDO     -- pointer to the device object
    pIrp    -- pointer to the IRP to process

Return Value:
    Returns the value of the IRP IoStatus.Status

--*/
{
    PIO_STACK_LOCATION  pIrpStack;
    PWDMACONTEXT        pContext;
    LPDEVICEINFO        DeviceInfo;
#ifdef _WIN64
    LPDEVICEINFO32      DeviceInfo32=NULL;
    LOCALDEVICEINFO     LocalDeviceInfo;
#endif
    LPVOID              DataBuffer;
    DWORD               DataBufferSize;
    ULONG               IoCode;
    NTSTATUS            Status = STATUS_SUCCESS;

    PAGED_CODE();
    //
    //  Get the CurrentStackLocation and log it so we know what is going on
    //
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    IoCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
    pContext = pIrpStack->FileObject->FsContext;
    ASSERT(pContext);

    ASSERT(pIrpStack->MajorFunction != IRP_MJ_CREATE &&
           pIrpStack->MajorFunction != IRP_MJ_CLOSE);

    //
    //  Can't assume that FsContext is initialized if the device has
    //  been opened with FO_DIRECT_DEVICE_OPEN
    //
    if (pIrpStack->FileObject->Flags & FO_DIRECT_DEVICE_OPEN)
    {
        DPF(DL_TRACE|FA_IOCTL, ("IRP_MJ_DEVICE_CONTROL: Opened with FO_DIRECT_DEVICE_OPEN, no device context") );
       
        return KsDefaultDeviceIoCompletion(pDO, pIrp);
    }

    Status = ValidateIrp(pIrp);
    if (!NT_SUCCESS(Status))
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        RETURN( Status );
    }

#ifdef _WIN64
    if (IoIs32bitProcess(pIrp)) {
        DeviceInfo32=((LPDEVICEINFO32)pIrp->AssociatedIrp.SystemBuffer);
        RtlZeroMemory(&LocalDeviceInfo, sizeof(LOCALDEVICEINFO));
        DeviceInfo=&LocalDeviceInfo.DeviceInfo;
        ThunkDeviceInfo3264(DeviceInfo32, DeviceInfo);
    } else {
#endif
        DeviceInfo = ((LPDEVICEINFO)pIrp->AssociatedIrp.SystemBuffer);
#ifdef _WIN64
    }
#endif
    DataBufferSize = DeviceInfo->DataBufferSize;

    WdmaGrabMutex(pContext);

    switch (pIrpStack->MajorFunction)
    {
        case IRP_MJ_DEVICE_CONTROL:
        {
            switch (IoCode)
            {
                case IOCTL_WDMAUD_INIT:
                    DPF( DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_INIT"));
                    if (DataBufferSize != 0)
                    {
                        Status = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    WdmaReleaseMutex(pContext);

                    //
                    //  If sysaudio fails to load, the device interface
                    //  will be disabled and the SysAudioPnPNotification
                    //  will not be called anymore until the sysaudio
                    //  device interface is reenabled.
                    //
                    if ( IsSysaudioInterfaceActive() )
                    {
                        KeWaitForSingleObject(&pContext->InitializedSysaudioEvent,
                                              Executive, KernelMode, FALSE, NULL);

                        //  This could happen if there was an error in InitializeSysaudio or
                        //  the memory allocation failed in QueueWorkList
                        if (pContext->fInitializeSysaudio == FALSE)
                        {
                             Status = STATUS_NOT_SUPPORTED;
                             DPF(DL_WARNING|FA_IOCTL, ("IOCTL_WDMAUD_INIT: Didn't init sysaudio!  Failing IOCTL_WDMAUD_INIT: %08x", Status));
                        }
                    }
                    else
                    {
                        Status = STATUS_NOT_SUPPORTED;
                        DPF(DL_WARNING|FA_IOCTL, ("IOCTL_WDMAUD_INIT: Sysaudio Device interface disabled!  Failing IOCTL_WDMAUD_INIT: %08x", Status));
                    }

                    WdmaGrabMutex(pContext);
                    break;

                case IOCTL_WDMAUD_EXIT:
                    if (DataBufferSize != 0)
                    {
                        Status = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    DPF( DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_EXIT"));
                    break;

                case IOCTL_WDMAUD_ADD_DEVNODE:
                {
                    DPF( DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_ADD_DEVNODE"));
                    if (DataBufferSize != 0)
                    {
                        Status = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }
                    DPF(DL_TRACE|FA_INSTANCE,("pContext=%08X, DI=%08X DeviceType=%08X",
                                              pContext, 
                                              DeviceInfo->wstrDeviceInterface, 
                                              DeviceInfo->DeviceType) );
                    Status=AddDevNode(pContext, DeviceInfo->wstrDeviceInterface, DeviceInfo->DeviceType);
                    break;
                }

                case IOCTL_WDMAUD_REMOVE_DEVNODE:
                {
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_REMOVE_DEVNODE"));
                    if (DataBufferSize != 0)
                    {
                        Status = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }
                    RemoveDevNode(pContext, DeviceInfo->wstrDeviceInterface, DeviceInfo->DeviceType);
                    break;
                }

                case IOCTL_WDMAUD_GET_CAPABILITIES:
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_GET_CAPABILITIES"));

                    Status = Dispatch_GetCapabilities(pIrp,pContext,
                                                      DeviceInfo);
                    break;

                case IOCTL_WDMAUD_GET_NUM_DEVS:
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_GET_NUM_DEVS"));
                    if (DataBufferSize != 0)
                    {
                        Status = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    Status = wdmaudGetNumDevs(pContext,
                                              DeviceInfo->DeviceType,
                                              DeviceInfo->wstrDeviceInterface,
                                              &DeviceInfo->DeviceNumber);

                    pIrp->IoStatus.Information = sizeof(DEVICEINFO);

                    DeviceInfo->mmr=MMSYSERR_NOERROR;

                    break;

                case IOCTL_WDMAUD_SET_PREFERRED_DEVICE:
                    DPF(DL_TRACE|FA_IOCTL,
                      ("IOCTL_WDMAUD_SET_PREFERRED_DEVICE %d",
                      DeviceInfo->DeviceNumber));

                    Status = SetPreferredDevice(pContext, DeviceInfo);

                    break;

                case IOCTL_WDMAUD_OPEN_PIN:
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_OPEN_PIN"));

                    UpdatePreferredDevice(pContext);

                    Status = Dispatch_OpenPin(pIrp,
                                              pContext,
                                              DeviceInfo);

                    break;

                case IOCTL_WDMAUD_CLOSE_PIN:
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_CLOSE_PIN"));

                    Status = Dispatch_ClosePin(pIrp,
                                               pContext,
                                               DeviceInfo);

                    break;


                //
                // WaveOut, wavein, midiout and midiin routines
                //

                case IOCTL_WDMAUD_WAVE_OUT_PAUSE:
                case IOCTL_WDMAUD_WAVE_OUT_PLAY:
                case IOCTL_WDMAUD_WAVE_OUT_RESET:
                case IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP:
                case IOCTL_WDMAUD_WAVE_IN_STOP:
                case IOCTL_WDMAUD_WAVE_IN_RECORD:
                case IOCTL_WDMAUD_WAVE_IN_RESET:
                case IOCTL_WDMAUD_MIDI_OUT_RESET:
                case IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA:
                case IOCTL_WDMAUD_MIDI_IN_STOP:
                case IOCTL_WDMAUD_MIDI_IN_RECORD:
                case IOCTL_WDMAUD_MIDI_IN_RESET:
                    Status = Dispatch_State(pIrp,
                                            pContext,
                                            DeviceInfo,
                                            IoCode);
                    break;

                case IOCTL_WDMAUD_WAVE_OUT_GET_POS:
                case IOCTL_WDMAUD_WAVE_IN_GET_POS:
                    Status = Dispatch_WaveGetPos(pIrp,pContext,
                                                 DeviceInfo,IoCode);
                    break;

                case IOCTL_WDMAUD_GET_VOLUME:
                case IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME:
                case IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME:
                    Status = Dispatch_GetVolume(pIrp,pContext,
                                                DeviceInfo,IoCode);
                    break;

                case IOCTL_WDMAUD_SET_VOLUME:
                case IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME:
                case IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME:
                    Status = Dispatch_SetVolume(pIrp,pContext,
                                                DeviceInfo,IoCode);
                    break;

                case IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN:
                    {
                        BOOL bCompletedIrp = FALSE;
                        DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN"));

                        Status = Dispatch_WaveOutWritePin(pIrp,pContext,
                                                          DeviceInfo,&bCompletedIrp);
                        if( bCompletedIrp )
                        {
                            //
                            //  !!! NOTE: Must return here so that we don't call IoCompleteRequest later !!!
                            //
                            WdmaReleaseMutex(pContext);

                            // For 32 bit irps we do NOT need to thunk DeviceInfo back to 32 bits, since
                            // nothing in this case statement has written anything into the DeviceInfo
                            // structure.  If thunking back is ever required, make sure to NOT touch a
                            // potentially already completed irp.  WriteWaveOutPin now completes the irp
                            // in some cases.

                            return Status ;
                        }
                        //
                        // If there was some problem trying to schedule the Irp we will
                        // end up here.  bCompleteIrp will still be FALSE indicating that
                        // we need to complete the Irp.  So, we break out of the switch
                        // statement, endin up at the end of SoundDispatch perform cleanup
                        // and complete the Irp.
                        //
                    }
                    break;

                //
                // WaveIn routines
                //

                case IOCTL_WDMAUD_WAVE_IN_READ_PIN:
                {
                    BOOL bCompletedIrp = FALSE;
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_WAVE_IN_READ_PIN"));

                    Status = Dispatch_WaveInReadPin(pIrp,pContext,
                                                    DeviceInfo,&bCompletedIrp);
                    if( bCompletedIrp )
                    {
                        //
                        // Don't need the lock any longer.
                        //
                        WdmaReleaseMutex(pContext);

                        return Status;
                    }

                    // For 32 bit irps we do NOT need to thunk DeviceInfo back to 32 bits, since
                    // nothing in this case statement has written anything into the DeviceInfo
                    // structure.  If thunking back is ever required, make sure to NOT touch a
                    // potentially already completed irp.  ReadWaveInPin now completes the irp
                    // in some cases.
                    //
                    // If there was some problem trying to schedule the Irp we will
                    // end up here.  bCompleteIrp will still be FALSE indicating that
                    // we need to complete the Irp.  So, we break out of the switch
                    // statement, endin up at the end of SoundDispatch perform cleanup
                    // and complete the Irp.
                    //
                }
                break;
                //
                // MidiOut routines
                //

                case IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA:
                    {
                        BOOL bCompletedIrp = FALSE;
                        DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA"));

                        Status = Dispatch_MidiOutWriteLongdata(pIrp,
                                                               pContext,
                                                               DeviceInfo,
                                                               &bCompletedIrp);

                        //
                        // If it was completed already, don't do it again!
                        //
                        if( bCompletedIrp )
                        {
                            //
                            // Don't need the lock any longer.
                            //
                            WdmaReleaseMutex(pContext);

                            // For 32 bit irps we do NOT need to thunk DeviceInfo back to 32 bits, since
                            // nothing in this case statement has written anything into the DeviceInfo
                            // structure.  If thunking back is ever required, make sure to NOT touch a
                            // potentially already completed irp.  wdmaudUnprepareIrp now completes the irp
                            // in most cases.
                            return Status;
                        }
                        //
                        // If there was some problem trying to schedule the Irp we will
                        // end up here.  bCompleteIrp will still be FALSE indicating that
                        // we need to complete the Irp.  So, we break out of the switch
                        // statement, endin up at the end of SoundDispatch perform cleanup
                        // and complete the Irp.
                        //
                    }
                    break;

                //
                // MidiIn routines
                //
                //
                //  Buffers for recording MIDI messages...
                //
                case IOCTL_WDMAUD_MIDI_IN_READ_PIN:
                    {
                        BOOL bCompletedIrp = FALSE;
                        DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIDI_IN_READ_PIN"));

                        Status = Dispatch_MidiInReadPin(pIrp,pContext, 
                                                        DeviceInfo,&bCompletedIrp);
                        //
                        // If it was completed already, don't do it again!
                        //
                        if( bCompletedIrp )
                        {
                            //
                            // Don't need the lock any longer.
                            //
                            WdmaReleaseMutex(pContext);

                            // For 32 bit irps we do NOT need to thunk DeviceInfo back to 32 bits, since
                            // nothing in this case statement has written anything into the DeviceInfo
                            // structure.  If thunking back is ever required, make sure to NOT touch a
                            // potentially already completed irp.  wdmaudUnprepareIrp now completes the irp
                            // in most cases.
                            return Status;
                        }
                        //
                        // If there was some problem trying to schedule the Irp we will
                        // end up here.  bCompleteIrp will still be FALSE indicating that
                        // we need to complete the Irp.  So, we break out of the switch
                        // statement, endin up at the end of SoundDispatch perform cleanup
                        // and complete the Irp.
                        //
                    }
                    break;

                case IOCTL_WDMAUD_MIXER_OPEN:
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIXER_OPEN"));
                    {
                        extern PKEVENT pHardwareCallbackEvent;

                        if (DataBufferSize != 0)
                        {
                            Status = STATUS_INVALID_BUFFER_SIZE;
                            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                            pIrp->IoStatus.Information = sizeof(DEVICEINFO);
                            break;
                        }

                        if (pHardwareCallbackEvent==NULL && DeviceInfo->HardwareCallbackEventHandle) {
                            Status = ObReferenceObjectByHandle(DeviceInfo->HardwareCallbackEventHandle, EVENT_ALL_ACCESS, *ExEventObjectType, pIrp->RequestorMode, (PVOID *)&pHardwareCallbackEvent, NULL);
                            if (Status!=STATUS_SUCCESS) {
                                DPF(DL_WARNING|FA_IOCTL, ("Could not reference hardware callback event object!"));
                            }
                        }

                        Status = kmxlOpenHandler( pContext, DeviceInfo, NULL );

                        pIrp->IoStatus.Information = sizeof(DEVICEINFO);
                    }
                    break;

                case IOCTL_WDMAUD_MIXER_CLOSE:
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIXER_CLOSE"));
                    if (DataBufferSize != 0)
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                        pIrp->IoStatus.Information = sizeof(DEVICEINFO);
                        break;
                    }

                    Status = kmxlCloseHandler( DeviceInfo, NULL );

                    pIrp->IoStatus.Information = sizeof(DEVICEINFO);
                    break;

                case IOCTL_WDMAUD_MIXER_GETLINEINFO:
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIXER_GETLINEINFO"));

                    Status = Dispatch_GetLineInfo(pIrp,
                                                  pContext,
                                                  DeviceInfo);
                    break;

                case IOCTL_WDMAUD_MIXER_GETLINECONTROLS:
                {
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIXER_GETLINECONTROLS"));

                    Status = Dispatch_GetLineControls(pIrp,
                                                      pContext,
                                                      DeviceInfo);
                    break;
                }

                case IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS:
                {
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS"));
                    Status = Dispatch_GetControlDetails(pIrp,
                                                        pContext, 
                                                        DeviceInfo);
                    break;
                }

                case IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS:
                {
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS"));
                    Status = Dispatch_SetControlDetails(pIrp,
                                                        pContext, 
                                                        DeviceInfo);
                    break;
                }

                case IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA:
                {
                    DPF(DL_TRACE|FA_IOCTL, ("IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA"));
                    Status = Dispatch_GetHardwareEventData(pIrp,
                                                           DeviceInfo);
                    break;
                }

                default:
                {
                    Status = STATUS_NOT_SUPPORTED;
                    break;
                }
            } // end of switch on IOCTL
            break;
        }

        default:
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }
    }  // end of switch on IRP_MAJOR_XXXX

#ifdef _WIN64
    if (IoIs32bitProcess(pIrp)) {
        if (DeviceInfo32!=NULL) {
            ThunkDeviceInfo6432(DeviceInfo, DeviceInfo32);
        }
        else {
            DPF(DL_WARNING|FA_IOCTL,("DeviceInfo32") );
        }
    }
#endif

    //
    //  Now complete the IRP
    //
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    WdmaReleaseMutex(pContext);

    RETURN( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       debug.c
//
//--------------------------------------------------------------------------


#ifdef DBG

#include "wdmsys.h"

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//-----------------------------------------------------------------------------
// Globals that affect debug output:
//-----------------------------------------------------------------------------

//
// NOTE: The documentation expects uiDebugBreakLevel to follow uiDebugLevel
// in the data segment.  Thus, do not put any variables between these two.
//
// Default to displaying all "Warning" messages
UINT uiDebugLevel = DL_ERROR ; // This should be DL_WARNING

// Default to breaking on all "Error" messages
UINT uiDebugBreakLevel = DL_ERROR ;
  

char szReturningErrorStr[]="Returning Status %X";
  
VOID 
GetuiDebugLevel()
{
    //
    // This should read from the registry!
    //
    uiDebugLevel=DL_ERROR; //FA_NOTE|FA_HARDWAREEVENT|DL_TRACE;
}

VOID wdmaudDbgBreakPoint()
{
    DbgBreakPoint();
}

#define DEBUG_IT
//
// This routine will format the start of the string.  But, before it does that
// it will check to see if the user should even be seeing this message.
//
// uiMsgLevel is the flags in the code that classify the message.  This value
// is used if and only if the user is filtering on that class of messages.
//
UINT wdmaudDbgPreCheckLevel(UINT uiMsgLevel,char *pFunction, int iLine)
{
    UINT uiRet=0;

    //
    // If path trap, tag it and move on.
    //
    if( (uiMsgLevel&DL_MASK) == DL_PATHTRAP ) {
        uiRet=1;
    } else {
        //
        // Read this like:  if there is a bit set in the upper 3 bytes of the uiDebugLevel
        // variable, then the user is viewing messages of a specific type.  We only 
        // want to show those messages.
        //
        if( (uiDebugLevel&FA_MASK) )
        {
            //
            // Yes, the user filtering on a particular class of messages.  Did
            // we find one to display?  We look at the message flags to determine this.
            //
            if( (uiMsgLevel&FA_MASK) & (uiDebugLevel&FA_MASK) )
            {
                //
                // Yes, we found a message of the right class.  Is it at the right
                // level for the user to see?
                // 
                if( (uiMsgLevel&DL_MASK) <= (uiDebugLevel&DL_MASK) ) {
                    // Yes.
                    uiRet=1;
                }
            }
            //
            // But, we always want to break on DL_ERROR messages.  So, if we get here
            // we want to break on particular output messages but we may not have found
            // one.  Is this message a error message?
            //
            if( (uiMsgLevel&DL_MASK) == DL_ERROR )
                uiRet=1;


        } else {

            //
            // Now check to see if the return bit is set
            //
            if(uiMsgLevel&RT_RETURN) 
            {
                // we're dealing with return statement in the code.  We need to 
                // figure out what our debug level is to see if this code gets
                // viewed or not.
                // 
                switch(uiMsgLevel&RT_MASK)
                {
                    case RT_ERROR:
                        if( (uiDebugLevel&DL_MASK) >= DL_WARNING )
                        {
                            uiRet=1;
                        }
                        break;
                    case RT_WARNING:
                        if( (uiDebugLevel&DL_MASK) >= DL_TRACE ) 
                        {                    
                            uiRet=1;
#ifdef DEBUG_IT
                            DbgPrint("Yes Return Warning %X %X\n",(uiMsgLevel&RT_MASK),(uiDebugLevel&DL_MASK));
#endif
                        }
                        break;
                    case RT_INFO:
                    case 0: //SUCCESS
                        if( (uiDebugLevel&DL_MASK) >= DL_MAX ) 
                        {                    
                            uiRet=1;
#ifdef DEBUG_IT
                            DbgPrint("Yes Return Status %X %X\n",(uiMsgLevel&RT_MASK),(uiDebugLevel&DL_MASK));
#endif
                        }
                        break;
                    default:
#ifdef DEBUG_IT
                        DbgPrint("No Return %X&RT_MASK != %X&DL_MASK\n",(uiMsgLevel&RT_MASK),(uiDebugLevel&DL_MASK));            
#endif
                        break;
                }
            } else {
                // The user is not viewing a specific type of message "class".  Do we have
                // a message level worth displaying?
                if( (uiMsgLevel&DL_MASK) <= (uiDebugLevel&DL_MASK) )
                {
                    // Yes.
                    uiRet=1;
                }
            }           
        } 
    }

    

    // Now just check to see if we need to display on this call.
    if( uiRet )
    {
        // Yes.  Every message needs to start where it's from!
        DbgPrint("WDMAUD.SYS %s(%d) ",pFunction, iLine);

        // Now lable it's type.
        switch(uiMsgLevel&DL_MASK)
        {

            case DL_ERROR:
                // for return status messages, the level is not set in the 
                // uiMsgLevel in the normal way.  Thus, we need to look for it.
                if( uiMsgLevel&RT_RETURN )
                {
                    // we have a return message.
                    switch(uiMsgLevel&RT_MASK )
                    {
                    case RT_ERROR:
                        DbgPrint("Ret Error ");
                        break;
                    case RT_WARNING:
                        DbgPrint("Ret Warning ");
                        break;
                    case RT_INFO:
                        DbgPrint("Ret Info ");
                        break;
                    default:
                        DbgPrint("Ret Suc ");
                        break;
                    }
                } else {
                    DbgPrint("Error ");
                }
                break;

            case DL_WARNING:
                DbgPrint("Warning ");
                break;
            case DL_TRACE:
                DbgPrint("Trace ");
                break;
            case DL_MAX:
                DbgPrint("Max ");
                break;
            case DL_PATHTRAP:
                DbgPrint("Path Trap ");
                break;
            default:
                break;
        }
        // when uiRet is positive, we've displayed the header info.  Tell the 
        // macro that we're in display mode.        
    }

    return uiRet;
}


UINT wdmaudDbgPostCheckLevel(UINT uiMsgLevel)
{
    UINT uiRet=0;

    // Always finish the line.    
#ifdef HTTP
    DbgPrint(" &DL=%08X, see \\\\debugtips\\msgs\\wdmauds.htm\n",&uiDebugLevel);
#else
    DbgPrint(" &DL=%08X\n",&uiDebugLevel);
#endif

    //
    // uiDebugBreakLevel is set to DL_ERROR (0) by default.  Any time we come
    // across an error message we will break in the debugger.  If the user
    // wants to break on other messages, they can change uiDebugBreakLevel to
    // DL_WARNING, DL_TRACE or DL_MAX and break on any message of this level.
    //
    if( ( (uiMsgLevel&DL_MASK) <= uiDebugBreakLevel ) || 
        ( (uiMsgLevel&DL_MASK) == DL_PATHTRAP ) )
    {
        // The user wants to break on these messages.

        DbgBreakPoint();
        uiRet = 1;
    }

    return uiRet;
}

typedef struct _MSGS {
    ULONG ulMsg;
    char *pString;
} ERROR_MSGS, *PERROR_MSGS;

#define MAPERR(_msg_) {_msg_,#_msg_},

ERROR_MSGS ReturnCodes[]={

    MAPERR(STATUS_OBJECT_NAME_NOT_FOUND)
    MAPERR(STATUS_UNSUCCESSFUL)
    MAPERR(STATUS_INVALID_PARAMETER)
    MAPERR(STATUS_NOT_FOUND)
    MAPERR(STATUS_INVALID_DEVICE_REQUEST)
    MAPERR(STATUS_TOO_LATE)
    MAPERR(STATUS_NO_SUCH_DEVICE)
    MAPERR(STATUS_NOT_SUPPORTED)
    MAPERR(STATUS_DEVICE_OFF_LINE)
    MAPERR(STATUS_PROPSET_NOT_FOUND)
    MAPERR(STATUS_BUFFER_TOO_SMALL)
    MAPERR(STATUS_INVALID_BUFFER_SIZE)
    {0,NULL},
    {0,"Not Mapped"}
};

char * wdmaudReturnString(ULONG ulMsg)
{
    PERROR_MSGS pTable=ReturnCodes;

    while(pTable->pString != NULL)
    {
        if(pTable->ulMsg==ulMsg)
            return pTable->pString;
        pTable++;
    }
    pTable++;
    return pTable->pString;
}

//
// Sometimes there are return codes that are expected other then SUCCESS.  We
// need to be able to filter on them rather then displaying them.
//
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

//#define va_start(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define va_start(ap,v) ap = (va_list)&v
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


//
// This routine simply walks the parameter list looking to see if status
// matches any of the other parameters.  Why?  Well, sometimes error codes
// are expected.  Thus, you don't want to display an error if you are expecting
// that error message.
//
// Do, to use this function, the first parameter represents how many unsigned long
// parameters fallow.  The first unsigned long "status" is that actual return
// code.  All the other unsigned longs are the exceptable error codes.
//
// wdmaudExclusionList(2, status, STATUS_INVALID_PARAMETER);
//
// wdmaudExlutionList(4, status, STATUS_INVALID_PARAMETER,
//                               STATUS_NO_SUCH_DEVICE,
//                               STATUS_INVALID_DEVICE_REQUEST);
//
// it returns 1 if status == any one of the supplied status codes.  0 otherwise.
//
int __cdecl wdmaudExclusionList(int lcount, unsigned long status,... )
{
    int count,i;
    int iFound=0;  
    unsigned long value;
    unsigned long rstatus;
    va_list arglist;

    va_start(arglist, lcount);
    count = va_arg(arglist, int);
    rstatus = va_arg(arglist, unsigned long);
    for(i=1; i<count; i++) {
        value = va_arg(arglist, unsigned long);
        if( rstatus == value )
        {
            iFound = 1; //It's in the list! show the error.
            break;
        }
    }    
    va_end(arglist);

    return iFound;
}




/////////////////////////////////////////////////////////////////////////////
//
// These are helper routines so that no assumptions are made.
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// IsValidWdmaContext
//
// Validates that the pointer is a valid PWDMACONTEXT pointer.
//
BOOL
IsValidWdmaContext(
    IN PWDMACONTEXT pWdmaContext
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if( pWdmaContext->dwSig != CONTEXT_SIGNATURE )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pWdmaContext->dwSig(%08X)",pWdmaContext->dwSig) );
            Status=STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        DPFBTRAP();
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// IsValidDeviceInfo
//
// Validates that the pointer is a LPDEVICEINFO type.
//
BOOL
IsValidDeviceInfo(
    IN LPDEVICEINFO pDeviceInfo
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if( pDeviceInfo->DeviceNumber >= MAXNUMDEVS )
        {
            DPF(DL_ERROR|FA_ASSERT,("DeviceNumber(%d) >= MAXNUMDEVS(%d)",
                                    pDeviceInfo->DeviceNumber,MAXNUMDEVS) );
            Status=STATUS_UNSUCCESSFUL;
        }

    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        DPFBTRAP();
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// ValidMixerObject
//
// Validates that the pointer is a MIXEROBJECT type.
//
BOOL
IsValidMixerObject(
    IN PMIXEROBJECT pmxobj
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if( pmxobj->dwSig != MIXEROBJECT_SIGNATURE )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pmxobj->dwSig(%08X)",pmxobj->dwSig) );
            Status=STATUS_UNSUCCESSFUL;
        }
        if( pmxobj->pfo == NULL )
        {            
            DPF(DL_ERROR|FA_ASSERT,("Invalid pmxobj->pfo(%08X)",pmxobj->pfo) );
            Status=STATUS_UNSUCCESSFUL;
        }

        if( !IsValidMixerDevice(pmxobj->pMixerDevice) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pmxobj->pMixerDevice(%08X)",pmxobj->pMixerDevice) );
            Status=STATUS_UNSUCCESSFUL;
        }

    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        DPFBTRAP();
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// ValidMixerDevice
//
// Validates that the pointer is a MIXERDEVICE type.
//
BOOL
IsValidMixerDevice(
    IN PMIXERDEVICE pmxd
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if( pmxd->dwSig != MIXERDEVICE_SIGNATURE )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pmxd->dwSig(%08X)",pmxd->dwSig) );
            Status=STATUS_UNSUCCESSFUL;
        }
        if( !IsValidWdmaContext(pmxd->pWdmaContext) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pmxd->pWdmaContext(%08X)",pmxd->pWdmaContext) );
            Status=STATUS_UNSUCCESSFUL;
        }
        if( pmxd->pfo == NULL )
        {
            DPF(DL_ERROR|FA_ASSERT,("fo NULL in MixerDevice") );
            Status=STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// IsValidLine
//
// Validates that the pointer is a MXLLINE type.
//
BOOL
IsValidLine(
    IN PMXLLINE pLine
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if( ( pLine->SourceId == INVALID_ID ) ||
            ( pLine->DestId   == INVALID_ID ) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Bad SourceId(%08X) or DestId(%08X)",
                                    pLine->SourceId,pLine->DestId ) );
            Status=STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        DPFBTRAP();
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// IsValidControl
//
// Validates that the pointer is a MXLCONTROL type.
//
BOOL
IsValidControl(
    IN PMXLCONTROL pControl
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    //
    // Hack for contrls that fail to disable change notifications
    //
    if( pControl == LIVE_CONTROL )
    {
        DPF(DL_WARNING|FA_NOTE,("Fake control in list!") );
        return Status;
    }

    try
    {
        if( pControl->Tag != CONTROL_TAG )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pControl(%08X)->Tag(%08X)",pControl,pControl->Tag) );
            Status=STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\midi.c ===
/****************************************************************************
 *
 *   midi.c
 *
 *   Midi routines for wdmaud.sys
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *                S.Mohanraj (MohanS)
 *                M.McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmsys.h"

#define IRP_LATENCY_100NS   3000

//
// This is just a scratch location that is never used for anything
// but a parameter to core functions.  
//                
IO_STATUS_BLOCK gIoStatusBlock ;

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

ULONGLONG 
GetCurrentMidiTime()
{
    LARGE_INTEGER   liFrequency,liTime;

    PAGED_CODE();
    //  total ticks since system booted
    liTime = KeQueryPerformanceCounter(&liFrequency);

    //  Convert ticks to 100ns units using Ks macro
    //
    return (KSCONVERT_PERFORMANCE_TIME(liFrequency.QuadPart,liTime));
}

//
// This routine gives us a pMidiPin to play with.
//
NTSTATUS 
OpenMidiPin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    ULONG               DataFlow      //DataFlow is either in or out.
)
{
    PMIDI_PIN_INSTANCE  pMidiPin = NULL;
    NTSTATUS            Status;
    PKSPIN_CONNECT      pConnect = NULL;
    PKSDATARANGE        pDataRange;
    PCONTROLS_LIST      pControlList = NULL;
    ULONG               Device;
    ULONG               PinId;


    PAGED_CODE();
    //
    // Because of the ZERO_FILL_MEMORY flag, are pMidiPin structure will come
    // back zero'd out.
    //
    Status = AudioAllocateMemory_Fixed(sizeof(MIDI_PIN_INSTANCE),
                                       TAG_Audi_PIN,
                                       ZERO_FILL_MEMORY,
                                       &pMidiPin);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    pMidiPin->dwSig           = MIDI_PIN_INSTANCE_SIGNATURE;
    pMidiPin->DataFlow        = DataFlow;
    pMidiPin->DeviceNumber    = DeviceNumber;
    pMidiPin->PinState        = KSSTATE_STOP;

    KeInitializeSpinLock( &pMidiPin->MidiPinSpinLock );

    KeInitializeEvent ( &pMidiPin->StopEvent,SynchronizationEvent,FALSE ) ;

    if( KSPIN_DATAFLOW_IN == DataFlow )
    {
        pMidiPin->pMidiDevice = &pWdmaContext->MidiOutDevs[DeviceNumber];

        if (NULL == pWdmaContext->MidiOutDevs[DeviceNumber].pMidiPin)
        {
            pWdmaContext->MidiOutDevs[DeviceNumber].pMidiPin = pMidiPin;
        }
        else
        {
            DPF(DL_TRACE|FA_MIDI, ("Midi device in use") );

            AudioFreeMemory( sizeof(MIDI_PIN_INSTANCE),&pMidiPin );
            Status =  STATUS_DEVICE_BUSY;
            goto exit;
        }
    } else {
        //
        // KSPIN_DATAFLOW_OUT
        //
        pMidiPin->pMidiDevice = &pWdmaContext->MidiInDevs[DeviceNumber];

        InitializeListHead(&pMidiPin->MidiInQueueListHead);

        KeInitializeSpinLock(&pMidiPin->MidiInQueueSpinLock);

        if (NULL == pWdmaContext->MidiInDevs[DeviceNumber].pMidiPin)
        {
            pWdmaContext->MidiInDevs[DeviceNumber].pMidiPin = pMidiPin;
        }
        else
        {
            AudioFreeMemory( sizeof(MIDI_PIN_INSTANCE),&pMidiPin );
            Status =  STATUS_DEVICE_BUSY;
            goto exit;
        }
    }

    //
    // We only support one midi client at a time, the check above will
    // only add this structure if there is not already one there.  If there
    // was something there already, we skip all the following code and 
    // go directly to the exit lable.  Thus, fGraphRunning must not be
    // set when we are here.
    //
    ASSERT( !pMidiPin->fGraphRunning );

    pMidiPin->fGraphRunning++;

    //
    // Because of the ZERO_FILL_MEMORY flag our pConnect structure will
    // come back all zero'd out.
    //
    Status = AudioAllocateMemory_Fixed(sizeof(KSPIN_CONNECT) + sizeof(KSDATARANGE),
                                       TAG_Audt_CONNECT,
                                       ZERO_FILL_MEMORY,
                                       &pConnect);
    if(!NT_SUCCESS(Status))
    {
        pMidiPin->fGraphRunning--;
        goto exit ;
    }

    pDataRange = (PKSDATARANGE)(pConnect + 1);

    PinId = pMidiPin->pMidiDevice->PinId;
    Device = pMidiPin->pMidiDevice->Device;

    pConnect->Interface.Set = KSINTERFACESETID_Standard ;
    pConnect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    pConnect->Medium.Set = KSMEDIUMSETID_Standard;
    pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    pConnect->Priority.PrioritySubClass = 1;
    pDataRange->MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
    pDataRange->SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    pDataRange->Specifier = KSDATAFORMAT_SPECIFIER_NONE;
    pDataRange->FormatSize = sizeof( KSDATARANGE );
    pDataRange->Reserved = 0 ;

    Status = AudioAllocateMemory_Fixed((sizeof(CONTROLS_LIST) +
                                         ( (MAX_MIDI_CONTROLS - 1) * sizeof(CONTROL_NODE) ) ),
                                       TAG_AudC_CONTROL,
                                       ZERO_FILL_MEMORY,
                                       &pControlList) ;
    if(!NT_SUCCESS(Status))
    {
        pMidiPin->fGraphRunning--;
        AudioFreeMemory( sizeof(KSPIN_CONNECT) + sizeof(KSDATARANGE),&pConnect );
        goto exit ;
    }

    pControlList->Count = MAX_MIDI_CONTROLS ;
    pControlList->Controls[MIDI_CONTROL_VOLUME].Control = KSNODETYPE_VOLUME ;
    pMidiPin->pControlList = pControlList ;


    // Open a pin
    Status = OpenSysAudioPin(Device,
                             PinId,
                             pMidiPin->DataFlow,
                             pConnect,
                             &pMidiPin->pFileObject,
                             &pMidiPin->pDeviceObject,
                             pMidiPin->pControlList);


    AudioFreeMemory( sizeof(KSPIN_CONNECT) + sizeof(KSDATARANGE),&pConnect );

    if (!NT_SUCCESS(Status))
    {
        CloseMidiDevicePin(pMidiPin->pMidiDevice);
        goto exit ;
    }

    //
    // OpenSysAudioPin sets the file object in the pin.  Now that we have
    // successfully returned from the call, validate that we have non-NULL
    // items.
    //
    ASSERT(pMidiPin->pFileObject);
    ASSERT(pMidiPin->pDeviceObject);

    //
    //  For output we put the device in a RUN state on open
    //  For input we have to wait until the device gets told
    //     to start
    //
    if ( KSPIN_DATAFLOW_IN == pMidiPin->DataFlow )
    {
        Status = AttachVirtualSource(pMidiPin->pFileObject, pMidiPin->pMidiDevice->pWdmaContext->VirtualMidiPinId);

        if (NT_SUCCESS(Status))
        {
            Status = StateMidiOutPin(pMidiPin, KSSTATE_RUN);
        }

        if (!NT_SUCCESS(Status))
        {
            CloseMidiDevicePin(pMidiPin->pMidiDevice);
        }
    }
    else
    {
        //
        //  Pause will queue a bunch of IRPs
        //
        Status = StateMidiInPin(pMidiPin, KSSTATE_PAUSE);
        if (!NT_SUCCESS(Status))
        {
            CloseMidiDevicePin(pMidiPin->pMidiDevice);
        }
    }

exit:

    RETURN( Status );
}


//
// This routine is called from multiple places.  As long as it's not reentrant, it should be
// ok.  Should check for that.
//
// This routine gets called from RemoveDevNode.  RemoveDevNode gets called from user mode
// or from the ContextCleanup routine.  Both routines are in the global mutex.
//
VOID 
CloseMidiDevicePin(
    PMIDIDEVICE pMidiDevice
)
{
    PAGED_CODE();
    if (NULL != pMidiDevice->pMidiPin )
    {
        //
        // CloseMidiPin must not fail.
        //
        CloseMidiPin ( pMidiDevice->pMidiPin ) ;
        //
        // AudioFreeMemory Nulls out this memory location.
        //
        AudioFreeMemory( sizeof(MIDI_PIN_INSTANCE),&pMidiDevice->pMidiPin ) ;
    }
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// The idea behind this SpinLock is that we want to protect the NumPendingIos
// value in the Irp completion routine.  There, there is a preemption issue
// that we can't have an InterlockedIncrement or InterlockedDecrement interfer
// with.
//
void
LockedMidiIoCount(
    PMIDI_PIN_INSTANCE  pCurMidiPin,
    BOOL bIncrease
    )
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&pCurMidiPin->MidiPinSpinLock,&OldIrql);

    if( bIncrease )
        pCurMidiPin->NumPendingIos++;
    else 
        pCurMidiPin->NumPendingIos--;
    
    KeReleaseSpinLock(&pCurMidiPin->MidiPinSpinLock, OldIrql);
}

VOID 
FreeIrpMdls(
    PIRP pIrp
    )
{
    if (pIrp->MdlAddress != NULL)
    {
        PMDL Mdl, nextMdl;

        for (Mdl = pIrp->MdlAddress; Mdl != (PMDL) NULL; Mdl = nextMdl)
        {
            nextMdl = Mdl->Next;
            MmUnlockPages( Mdl );
            AudioFreeMemory_Unknown( &Mdl );
        }

        pIrp->MdlAddress = NULL;
    }
}


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// This routine can not fail.  When it returns, pMidiPin will be freed.  
//
VOID 
CloseMidiPin(
    PMIDI_PIN_INSTANCE pMidiPin
)
{
    PMIDIINHDR pHdr;
    PMIDIINHDR pTemp;
    KSSTATE    State;

    PAGED_CODE();

    // This is designed to bring us back to square one, even
    // if we were not completely opened
    if( !pMidiPin->fGraphRunning )
    {
        ASSERT(pMidiPin->fGraphRunning == 1);
        return ;
    }

    pMidiPin->fGraphRunning--;

    // Close the file object (pMidiPin->pFileObject, if it exists)
    if(pMidiPin->pFileObject)
    {
        //
        //  For Midi Input we need to flush the queued up scratch IRPs by
        //  issuing a STOP command.
        //
        //  We don't want to do that for Midi Output because we might loose
        //  the "all notes off" sequence that needs to get to the device.
        //
        //  Regardless, in both cases we need to wait until we have
        //  compeletely flushed the device before we can close it.
        //
        if ( KSPIN_DATAFLOW_OUT == pMidiPin->DataFlow )
        {
            PLIST_ENTRY ple;

            //
            //  This is kind of a catch-22.  We need to release
            //  the mutex which was grabbed when we entered the
            //  ioctl dispatch routine to allow the midi input
            //  irps which are queued up in a work item waiting
            //  until the mutex is free in order to be send
            //  down to portcls.
            //
            WdmaReleaseMutex(pMidiPin->pMidiDevice->pWdmaContext);
 
            //
            // This loop removes an entry and frees it until the list is empty.
            //
            while((ple = ExInterlockedRemoveHeadList(&pMidiPin->MidiInQueueListHead,
                                                     &pMidiPin->MidiInQueueSpinLock)) != NULL) 
            {
                LPMIDIDATA              pMidiData;
                PIRP                    UserIrp;
                PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

                pHdr = CONTAINING_RECORD(ple,MIDIINHDR,Next);
                //
                //  Get into locals and zero out midi data
                //
                UserIrp             = pHdr->pIrp;
                pMidiData           = pHdr->pMidiData;
                pPendingIrpContext  = pHdr->pPendingIrpContext;
                ASSERT(pPendingIrpContext);
                RtlZeroMemory(pMidiData, sizeof(MIDIDATA));

                //
                //  unlock memory before completing the Irp
                //
                wdmaudUnmapBuffer(pHdr->pMdl);
                AudioFreeMemory_Unknown(&pHdr);

                //
                //  Now complete the Irp for wdmaud.drv to process
                //
                DPF(DL_TRACE|FA_MIDI, ("CloseMidiPin: Freeing pending UserIrp: 0x%08lx",UserIrp));
                wdmaudUnprepareIrp ( UserIrp,
                                     STATUS_CANCELLED,
                                     sizeof(DEVICEINFO),
                                     pPendingIrpContext );
            }
        }

        //
        // At this point we know that the list is empty, but there
        // still might be an Irp in the completion process.  We have
        // to call the standard wait routine to make sure it gets completed.
        //
        pMidiPin->StoppingSource = TRUE ;

        if ( KSPIN_DATAFLOW_OUT == pMidiPin->DataFlow )
        {            
            StatePin ( pMidiPin->pFileObject, KSSTATE_STOP, &pMidiPin->PinState ) ;
        }

        //
        // Need to wait for all in and out data to complete.
        //
        MidiCompleteIo( pMidiPin, FALSE );

        if ( KSPIN_DATAFLOW_OUT == pMidiPin->DataFlow )
        {
            //
            //  Grab back the mutex which was freed before we started
            //  waiting on the I/O to complete.
            //
            WdmaGrabMutex(pMidiPin->pMidiDevice->pWdmaContext);
        }

        CloseSysAudio(pMidiPin->pMidiDevice->pWdmaContext, pMidiPin->pFileObject);
        pMidiPin->pFileObject = NULL;
    }

    //
    // AudioFreeMemory_Unknown Nulls out this location
    //
    AudioFreeMemory_Unknown ( &pMidiPin->pControlList ) ;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA
//
// This is the IRP completion routine.
//
NTSTATUS 
WriteMidiEventCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    KIRQL               OldIrql;
    PMIDI_PIN_INSTANCE  pMidiOutPin;

    pMidiOutPin = pStreamHeader->pMidiPin;

    if (pMidiOutPin)
    {
        KeAcquireSpinLock(&pMidiOutPin->MidiPinSpinLock,&OldIrql);
        //
        // One less Io packet outstanding, thus we always decrement the 
        // outstanding count.  Then, we compare to see if we're the last
        // packet and we're stopping then we signal the saiting thead.
        //
        if( ( 0 == --pMidiOutPin->NumPendingIos ) && pMidiOutPin->StoppingSource )
        {
            KeSetEvent ( &pMidiOutPin->StopEvent, 0, FALSE ) ;
        }

        //
        // Upon releasing this spin lock pMidiOutPin will no longer be valid.  
        // Thus we must not touch it.
        //
        KeReleaseSpinLock(&pMidiOutPin->MidiPinSpinLock,OldIrql);
    }

    //
    // If there are any Mdls, free them here otherwise IoCompleteRequest will do it after the
    // freeing of our data buffer below.
    //
    FreeIrpMdls(pIrp);
    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA


NTSTATUS 
WriteMidiEventPin(
    PMIDIDEVICE pMidiOutDevice,
    ULONG       ulEvent
)
{
    PKSMUSICFORMAT      pMusicFormat;
    PSTREAM_HEADER_EX   pStreamHeader = NULL;
    PMIDI_PIN_INSTANCE  pMidiPin;
    NTSTATUS            Status = STATUS_SUCCESS;
    BYTE                bEvent;
    ULONG               TheEqualizer;
    ULONGLONG           nsPlayTime;
    KEVENT              keEventObject;
    PWDMACONTEXT        pWdmaContext;

    PAGED_CODE();
    pMidiPin = pMidiOutDevice->pMidiPin;

    if (!pMidiPin ||!pMidiPin->fGraphRunning || !pMidiPin->pFileObject )
    {
        DPF(DL_WARNING|FA_MIDI,("Not ready pMidiPin=%X",pMidiPin) );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    //
    // allocate enough memory for the stream header
    // the midi/music header, the data, the work item,
    // and the DeviceNumber.  The memroy allocation
    // is zero'd with the ZERO_FILL_MEMORY flag
    //
    Status = AudioAllocateMemory_Fixed(sizeof(STREAM_HEADER_EX) + sizeof(KSMUSICFORMAT) +
                                           sizeof(ULONG),
                                       TAG_Audh_STREAMHEADER,
                                       ZERO_FILL_MEMORY,
                                       &pStreamHeader);   // ulEvent

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    // Get a pointer to the music header
    pMusicFormat = (PKSMUSICFORMAT)(pStreamHeader + 1);

    // Play 0 ms from the time-stamp in the KSSTREAM_HEADER
    pMusicFormat->TimeDeltaMs = 0;
    RtlCopyMemory((BYTE *)(pMusicFormat + 1), // the actual data
                  &ulEvent,
                  sizeof(ulEvent));

    // setup the stream header
    pStreamHeader->Header.Data = pMusicFormat;

    pStreamHeader->Header.FrameExtent  = sizeof(KSMUSICFORMAT) + sizeof(ULONG);
    pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
    pStreamHeader->Header.DataUsed     = pStreamHeader->Header.FrameExtent;

    nsPlayTime = GetCurrentMidiTime() - pMidiPin->LastTimeNs + IRP_LATENCY_100NS;
    pStreamHeader->Header.PresentationTime.Time        = nsPlayTime;
    pStreamHeader->Header.PresentationTime.Numerator   = 1;
    pStreamHeader->Header.PresentationTime.Denominator = 1;

    pStreamHeader->pMidiPin = pMidiPin;

    //
    // Figure out how many bytes in this
    // event are valid.
    //
    bEvent = (BYTE)ulEvent;
    TheEqualizer = 0;
    if(!IS_STATUS(bEvent))
    {
        if (pMidiPin->bCurrentStatus)
        {
            bEvent = pMidiPin->bCurrentStatus;
            TheEqualizer = 1;
        }
        else
        {
            // Bad MIDI Stream didn't have a running status
            DPF(DL_WARNING|FA_MIDI,("No running status") );
            AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
            RETURN( STATUS_UNSUCCESSFUL );
        }
    }

    if(IS_SYSTEM(bEvent))
    {
        if( IS_REALTIME(bEvent)    ||
            bEvent == MIDI_TUNEREQ ||
            bEvent == MIDI_SYSX    ||
            bEvent == MIDI_EOX )
        {
            pMusicFormat->ByteCount = 1;
        }
        else if(bEvent == MIDI_SONGPP)
        {
            pMusicFormat->ByteCount = 3;
        }
        else
        {
            pMusicFormat->ByteCount = 2;
        }
    }
    // Check for three byte messages
    else if((bEvent < MIDI_PCHANGE) || (bEvent >= MIDI_PBEND))
    {
        pMusicFormat->ByteCount = 3 - TheEqualizer;
    }
    else
    {
        pMusicFormat->ByteCount = 2 - TheEqualizer;
    }

    //
    //  Cache the running status
    //
    if ( (bEvent >= MIDI_NOTEOFF) && (bEvent < MIDI_CLOCK) )
    {
        pMidiPin->bCurrentStatus = (BYTE)((bEvent < MIDI_SYSX) ? bEvent : 0);
    }

    //
    // Initialize our wait event, in case we need to wait.
    //
    KeInitializeEvent(&keEventObject,
                      SynchronizationEvent,
                      FALSE);

    LockedMidiIoCount(pMidiPin,INCREASE);

    //
    //  Need to release the mutex so that during full-duplex
    //  situations, we can get the midi input buffers down
    //  to the device without blocking.
    //
    pWdmaContext = pMidiPin->pMidiDevice->pWdmaContext;
    WdmaReleaseMutex(pWdmaContext);

    // Set the packet to the device.
    Status = KsStreamIo(
        pMidiPin->pFileObject,
        &keEventObject,             // Event
        NULL,                   // PortContext
        WriteMidiEventCallBack,
        pStreamHeader,              // CompletionContext
        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
        &gIoStatusBlock,
        pStreamHeader,
        sizeof( KSSTREAM_HEADER ),
        KSSTREAM_WRITE | KSSTREAM_SYNCHRONOUS,
        KernelMode
    );

    if ( (Status != STATUS_PENDING) && (Status != STATUS_SUCCESS) )
    {
        DPF(DL_WARNING|FA_MIDI, ("KsStreamIO failed: 0x%08lx",Status));
    }

    //
    // Wait a minute here!!!  If the Irp comes back pending, we
    // can NOT complete our user mode Irp!  But, there is no
    // infastructure for storing the Irp in this call stack.  The
    // other routines use wdmaudPrepareIrp to complete that user
    // Irp.  Also, pPendingIrpContext is stored in the Irp context
    // so that the completion routine has the list to get the
    // user mode Irp from.
    //
    // .... Or, we need to make this routine synchronous and 
    // wait like WriteMidiOutPin.  I believe that this is bug
    // #551052.  It should be fixed eventually.
    //
    //
    // Here is the fix.  Wait if it is pending.
    //
    if ( STATUS_PENDING == Status )
    {
        //
        // Wait for the completion.
        //
        Status = KeWaitForSingleObject( &keEventObject,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );
    }
    //
    //  Now grab the mutex again
    //
    WdmaGrabMutex(pWdmaContext);

    RETURN( Status );
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// This is an IRP completion routine.
//
NTSTATUS 
WriteMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    //
    // If there are any Mdls, free them here otherwise IoCompleteRequest will do it after the
    // freeing of our data buffer below.
    //
    FreeIrpMdls(pIrp);
    //
    // Cleanup after this synchronous write
    //
    AudioFreeMemory_Unknown(&pStreamHeader->Header.Data);  // Music data

    wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
    AudioFreeMemory_Unknown(&pStreamHeader->pMidiHdr);

    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS 
WriteMidiOutPin(
    LPMIDIHDR           pMidiHdr,
    PSTREAM_HEADER_EX   pStreamHeader,
    BOOL               *pCompletedIrp
)
{
    NTSTATUS       Status = STATUS_INVALID_DEVICE_REQUEST;
    PKSMUSICFORMAT pMusicFormat = NULL;
    KEVENT         keEventObject;
    ULONG          AlignedLength;
    ULONGLONG      nsPlayTime;
    PMIDI_PIN_INSTANCE  pMidiPin;
    PWDMACONTEXT   pWdmaContext;

    PAGED_CODE();

    pMidiPin = pStreamHeader->pMidiPin;

    if (!pMidiPin ||!pMidiPin->fGraphRunning || !pMidiPin->pFileObject )
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
        AudioFreeMemory_Unknown( &pMidiHdr );
        AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    //
    //  FrameExtent contains dwBufferLength right now
    //
    AlignedLength = ((pStreamHeader->Header.FrameExtent + 3) & ~3);

    Status = AudioAllocateMemory_Fixed(sizeof(KSMUSICFORMAT) + AlignedLength,
                                       TAG_Audm_MUSIC,
                                       ZERO_FILL_MEMORY,
                                       &pMusicFormat);

    if(!NT_SUCCESS(Status))
    {
        wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
        AudioFreeMemory_Unknown( &pMidiHdr );
        AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
        return Status;
    }

    // Play 0 ms from the time-stamp in the KSSTREAM_HEADER
    pMusicFormat->TimeDeltaMs = 0;

    //
    //  the system mapped data was stored in the data field
    //  of the stream header
    //
    RtlCopyMemory((BYTE *)(pMusicFormat + 1), // the actual data
                  pStreamHeader->Header.Data,
                  pStreamHeader->Header.FrameExtent);

    //
    // Setup the number of bytes of midi data we're sending
    //
    pMusicFormat->ByteCount = pStreamHeader->Header.FrameExtent;

    // setup the stream header
    pStreamHeader->Header.Data        = pMusicFormat;

    // Now overwrite FrameExtent with the correct rounded up dword aligned value
    pStreamHeader->Header.FrameExtent = sizeof(KSMUSICFORMAT) + AlignedLength;
    pStreamHeader->Header.OptionsFlags= 0;
    pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
    pStreamHeader->Header.TypeSpecificFlags = 0;
    pStreamHeader->Header.DataUsed    = pStreamHeader->Header.FrameExtent;
    pStreamHeader->pMidiHdr           = pMidiHdr;

    nsPlayTime = GetCurrentMidiTime() - pStreamHeader->pMidiPin->LastTimeNs + IRP_LATENCY_100NS;
    pStreamHeader->Header.PresentationTime.Time        = nsPlayTime;
    pStreamHeader->Header.PresentationTime.Numerator   = 1;
    pStreamHeader->Header.PresentationTime.Denominator = 1;

    //
    // Initialize our wait event, in case we need to wait.
    //
    KeInitializeEvent(&keEventObject,
                      SynchronizationEvent,
                      FALSE);

    //
    //  Need to release the mutex so that during full-duplex
    //  situations, we can get the midi input buffers down
    //  to the device without blocking.
    //
    pWdmaContext = pMidiPin->pMidiDevice->pWdmaContext;
    WdmaReleaseMutex(pWdmaContext);

    // Send the packet to the device.
    Status = KsStreamIo(
        pMidiPin->pFileObject,
        &keEventObject,             // Event
        NULL,                       // PortContext
        WriteMidiCallBack,
        pStreamHeader,              // CompletionContext
        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
        &gIoStatusBlock,
        &pStreamHeader->Header,
        sizeof( KSSTREAM_HEADER ),
        KSSTREAM_WRITE | KSSTREAM_SYNCHRONOUS,
        KernelMode
    );

    //
    // Wait if it is pending.
    //
    if ( STATUS_PENDING == Status )
    {

        //
        // Wait for the completion.
        //
        Status = KeWaitForSingleObject( &keEventObject,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );
    }
    //
    // From the Wait above, we can see that this routine is
    // always synchronous.  Thus, any Irp that we passed down
    // in the KsStreamIo call will have been completed and KS
    // will have signaled keEventObject.  Thus, we can 
    // now complete our Irp.  
    //
    // ... Thus we leave pCompletedIrp set to FALSE.
    //

    //
    //  Now grab the mutex again
    //
    WdmaGrabMutex(pWdmaContext);

    RETURN( Status );
}

NTSTATUS 
ResetMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin
)
{
    NTSTATUS    Status;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    Status = StateMidiInPin ( pMidiPin, KSSTATE_PAUSE );

    RETURN( Status );
}

NTSTATUS 
StateMidiOutPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE State
)
{
    NTSTATUS  Status;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    if (State == KSSTATE_RUN)
    {
        pMidiPin->LastTimeNs = GetCurrentMidiTime();
    }
    else if (State == KSSTATE_STOP)
    {
        pMidiPin->LastTimeNs = 0;
    }

    Status = StatePin ( pMidiPin->pFileObject, State, &pMidiPin->PinState ) ;

    RETURN( Status );
}

//
// Waits for all the Irps to complete.
//
void
MidiCompleteIo(
    PMIDI_PIN_INSTANCE pMidiPin,
    BOOL Yield
    )
{
    PAGED_CODE();

    if ( pMidiPin->NumPendingIos )
    {
        DPF(DL_TRACE|FA_MIDI, ("Waiting on %d I/Os to flush Midi device",
                                      pMidiPin->NumPendingIos ));
        if( Yield )
        {
            //
            //  This is kind of a catch-22.  We need to release
            //  the mutex which was grabbed when we entered the
            //  ioctl dispatch routine to allow the midi input
            //  irps which are queued up in a work item waiting
            //  until the mutex is free in order to be send
            //  down to portcls.
            //
            WdmaReleaseMutex(pMidiPin->pMidiDevice->pWdmaContext);

        }
        //
        // Wait for all the Irps to complete.  The last one will
        // signal us to wake.
        //
        KeWaitForSingleObject ( &pMidiPin->StopEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL ) ;

        if( Yield )
        {
            WdmaGrabMutex(pMidiPin->pMidiDevice->pWdmaContext);
        }

        DPF(DL_TRACE|FA_MIDI, ("Done waiting to flush Midi device"));
    }

    //
    // Why do we have this?
    //
    KeClearEvent ( &pMidiPin->StopEvent );

    //
    // All the IRPs have completed. We now restore the StoppingSource
    // variable so that we can recycle the pMidiPin.
    //
    pMidiPin->StoppingSource = FALSE;

}
//
// If the driver failed the KSSTATE_STOP request, we return that error
// code to the caller.
//
NTSTATUS 
StopMidiPinAndCompleteIo(
    PMIDI_PIN_INSTANCE pMidiPin,
    BOOL Yield
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    //
    // Indicate to the completion routine that we are stopping now.
    //
    pMidiPin->StoppingSource = TRUE;

    //
    // Tell the driver to stop.  Regardless, we will wait for the 
    // IRPs to complete if there are any outstanding.
    //
    Status = StatePin( pMidiPin->pFileObject, KSSTATE_STOP, &pMidiPin->PinState ) ;
    //
    // NOTE: On success, the pMidiPin->PinState value will be
    // KSSTATE_STOP.  On Error it will be the old state.
    //
    // This raises the question - Do we hang on failure?
    //
    MidiCompleteIo( pMidiPin,Yield );

    return Status;
}

NTSTATUS
StateMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE State
)
{
    NTSTATUS           Status;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    //
    //  We need to complete any pending SysEx buffers on a midiInStop
    //
    //
    // Here, if we're asked to go to the paused state and we're not
    // already in the paused state, we have to go through a stop.
    // Thus we stop the driver, wait for it to complete all the outstanding
    // IRPs and then place the driver in pause and place buffers
    // down on it again.
    //
    if( (KSSTATE_PAUSE == State) &&
        (KSSTATE_PAUSE != pMidiPin->PinState) )
    {
        Status = StopMidiPinAndCompleteIo(pMidiPin,TRUE);

        //
        // If we were successful at stopping the driver, we set
        // the pin back up in the pause state.
        //
        if (NT_SUCCESS(Status))
        {
            ULONG BufferCount;

            //
            // Put the driver back in the pause state.
            //
            Status = StatePin ( pMidiPin->pFileObject, State, &pMidiPin->PinState ) ;

            if (NT_SUCCESS(Status))
            {
                //
                // This loop places STREAM_BUFFERS (128) of them down on the
                // device.  NumPendingIos should be 128 when this is done.
                //
                for (BufferCount = 0; BufferCount < STREAM_BUFFERS; BufferCount++)
                {
                    Status = ReadMidiPin( pMidiPin );
                    if (!NT_SUCCESS(Status))
                    {
                        CloseMidiPin( pMidiPin );
                        //
                        // Appears that this error path is not correct.  If we
                        // call CloseMidiPin fGraphRunning will get reduced to 0.
                        // Then, on the next close call CloseMidiPin will assert
                        // because the pin is not running.  We need to be able to
                        // error out of this path without messing up the fGraphRunning
                        // state.
                        //
                        break;
                    }
                }
            }
        }

    } else {

        //
        // Else we're not going to the pause state, so just make the state
        // change.
        //
        Status = StatePin ( pMidiPin->pFileObject, State, &pMidiPin->PinState ) ;
    }

    RETURN( Status );
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA


NTSTATUS 
ReadMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    WRITE_CONTEXT       *pwc;
    PMIDI_PIN_INSTANCE  pMidiInPin;
    PMIDIINHDR          pMidiInHdr;
    PKSMUSICFORMAT      IrpMusicHdr;
    ULONG               IrpDataLeft;
    LPBYTE              IrpData;
    ULONG               RunningTimeMs;
    BOOL                bResubmit = TRUE;
    BOOL                bDataError = FALSE;
    NTSTATUS            Status = STATUS_SUCCESS;
    KIRQL               OldIrql;
    PLIST_ENTRY         ple;

    DPF(DL_TRACE|FA_MIDI, ("Irp.Status = 0x%08lx",pIrp->IoStatus.Status));

    pMidiInPin = pStreamHeader->pMidiPin;

    //
    // No pin should ever be closed before all the Io comes back.  So
    // we'll sanity check that here.
    //
    ASSERT(pMidiInPin);

    if( pMidiInPin )
    {
        DPF(DL_TRACE|FA_MIDI, ("R%d: 0x%08x", pMidiInPin->NumPendingIos, pStreamHeader));

        //
        // This routine should do an ExInterlockedRemoveHeadList to get the
        // head of the list.
        //
        if((ple = ExInterlockedRemoveHeadList(&pMidiInPin->MidiInQueueListHead,
                                                 &pMidiInPin->MidiInQueueSpinLock)) != NULL) 
        {
            PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
            LPMIDIDATA              pMidiData;
            PIRP                    UserIrp;

            //
            // We have something to do.
            //
            pMidiInHdr = CONTAINING_RECORD(ple, MIDIINHDR, Next);

            //
            //  Pull some information into locals
            //
            IrpData             = (LPBYTE)((PKSMUSICFORMAT)(pStreamHeader->Header.Data) + 1);
            UserIrp             = pMidiInHdr->pIrp;
            pMidiData           = pMidiInHdr->pMidiData;
            pPendingIrpContext  = pMidiInHdr->pPendingIrpContext;
            ASSERT(pPendingIrpContext);

            //
            //  Let's see what we have here
            //
            DPF(DL_TRACE|FA_MIDI, ("IrpData = 0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                                          *(LPBYTE)IrpData,*(LPBYTE)IrpData+1,*(LPBYTE)IrpData+2,
                                          *(LPBYTE)IrpData+3,*(LPBYTE)IrpData+4,*(LPBYTE)IrpData+5,
                                          *(LPBYTE)IrpData+6,*(LPBYTE)IrpData+7,*(LPBYTE)IrpData+8,
                                          *(LPBYTE)IrpData+9,*(LPBYTE)IrpData+10,*(LPBYTE)IrpData+11) );
            //
            //  Copy over the good stuff...
            //
            RtlCopyMemory(&pMidiData->StreamHeader,
                          &pStreamHeader->Header,
                          sizeof(KSSTREAM_HEADER));
            RtlCopyMemory(&pMidiData->MusicFormat,
                          pStreamHeader->Header.Data,
                          sizeof(KSMUSICFORMAT));
            RtlCopyMemory(&pMidiData->MusicData,
                          ((PKSMUSICFORMAT)(pStreamHeader->Header.Data) + 1),
                          3 * sizeof( DWORD )); // cheesy

            //
            //  unlock memory before completing the Irp
            //
            wdmaudUnmapBuffer(pMidiInHdr->pMdl);
            AudioFreeMemory_Unknown(&pMidiInHdr);

            //
            //  Now complete the Irp for wdmaud.drv to process
            //
            wdmaudUnprepareIrp( UserIrp,
                                pIrp->IoStatus.Status,
                                sizeof(MIDIDATA),
                                pPendingIrpContext );
        } else {
            //  !!! Break here to catch underflow !!!
            if (pIrp->IoStatus.Status == STATUS_SUCCESS)
            {
                DPF(DL_TRACE|FA_MIDI, ("!!! Underflowing MIDI Input !!!"));
                //_asm { int 3 };
            }
        }
    }
    //
    // If there are any Mdls, free them here otherwise IoCompleteRequest will do it after the
    // freeing of our data buffer below.
    //
    FreeIrpMdls(pIrp);

    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);

    if(pMidiInPin)
    {
        KeAcquireSpinLock(&pMidiInPin->MidiPinSpinLock,&OldIrql);

        pMidiInPin->NumPendingIos--;

        if ( pMidiInPin->StoppingSource || (pIrp->IoStatus.Status == STATUS_CANCELLED) ||
             (pIrp->IoStatus.Status == STATUS_NO_SUCH_DEVICE) || (pIrp->Cancel) )
        {
            bResubmit = FALSE;

            if ( 0 == pMidiInPin->NumPendingIos )
            {
                 KeSetEvent ( &pMidiInPin->StopEvent, 0, FALSE ) ;
            }
        }
        //
        // We need to be careful about using pMidiPin after releasing the spinlock.
        // if we are closing down and the NumPendingIos goes to zero the pMidiPin
        // can be freed.  In that case we must not touch pMidiPin.  bResubmit
        // protects us below.
        //
        KeReleaseSpinLock(&pMidiInPin->MidiPinSpinLock, OldIrql);

        //
        //  Resubmit to keep the cycle going...and going. Note that bResubmit
        //  must be first in this comparison.  If bResubmit is FALSE, then pMidiInPin
        //  could be freed.  
        //
        if (bResubmit && pMidiInPin->fGraphRunning )
        {
            //
            // This call to ReadMidiPin causes wdmaud.sys to place another
            // buffer down on the device.  One call, one buffer.
            //
            ReadMidiPin(pMidiInPin);
        }
    }

    return STATUS_SUCCESS;
}

//
// Called from Irp completion routine, thus this code must be locked.
//
NTSTATUS 
ReadMidiPin(
    PMIDI_PIN_INSTANCE  pMidiPin
)
{
    PKSMUSICFORMAT      pMusicFormat;
    PSTREAM_HEADER_EX   pStreamHeader = NULL;
    PWORK_QUEUE_ITEM    pWorkItem;
    NTSTATUS            Status = STATUS_SUCCESS;

    DPF(DL_TRACE|FA_MIDI, ("Entered"));

    if (!pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Bad fGraphRunning") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    Status = AudioAllocateMemory_Fixed(sizeof(STREAM_HEADER_EX) + sizeof(WORK_QUEUE_ITEM) +
                                          MUSICBUFFERSIZE,
                                       TAG_Audh_STREAMHEADER,
                                       ZERO_FILL_MEMORY,
                                       &pStreamHeader);

    if(!NT_SUCCESS(Status))
    {
        RETURN( Status );
    }

    pWorkItem = (PWORK_QUEUE_ITEM)(pStreamHeader + 1);

    pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
    pStreamHeader->Header.PresentationTime.Numerator   = 10000;
    pStreamHeader->Header.PresentationTime.Denominator = 1;

    pMusicFormat = (PKSMUSICFORMAT)((BYTE *)pWorkItem + sizeof(WORK_QUEUE_ITEM));
    pStreamHeader->Header.Data         = pMusicFormat;
    pStreamHeader->Header.FrameExtent  = MUSICBUFFERSIZE;

    pStreamHeader->pMidiPin = pMidiPin;

    ASSERT( pMidiPin->pFileObject );

    //
    // Increase the number of outstanding IRPs as we get ready to add
    // this one to the list.
    //
    LockedMidiIoCount( pMidiPin,INCREASE );
    ObReferenceObject( pMidiPin->pFileObject );

    Status = QueueWorkList( pMidiPin->pMidiDevice->pWdmaContext,
                            ReadMidiEventWorkItem,
                            pStreamHeader,
                            0 );
    if (!NT_SUCCESS(Status))
    {
        //
        // If the memory allocation fails in QueueWorkItem then it can fail.  We
        // will need to free our memory and unlock things.
        //
        LockedMidiIoCount(pMidiPin,DECREASE);
        ObDereferenceObject(pMidiPin->pFileObject);
        AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
    }

    RETURN( Status );
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA
//
// This is a work item that midi schedules.  Notice that the caller did a reference
// on the file object so that it would still be valid when we're here. We should never
// get called and find that the file object is invalid.  Same holds for the StreamHeader
// and the corresponding pMidiPin.
//
VOID 
ReadMidiEventWorkItem(
    PSTREAM_HEADER_EX   pStreamHeader,
    PVOID               NotUsed
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PFILE_OBJECT    MidiFileObject;

    PAGED_CODE();

    ASSERT( pStreamHeader->pMidiPin->pFileObject );

    DPF(DL_TRACE|FA_MIDI, ("A%d: 0x%08x", pStreamHeader->pMidiPin->NumPendingIos, pStreamHeader));

    //
    // We need to store the MidiFileObject here because the pStreamHeader
    // will/may get freed during the KsStreamIo call.  Basically, when
    // you call KsStreamIo the Irp may get completed and the pStreamHeader
    // will get freed.  But, it's safe to store the file object because of
    // this reference count.
    //
    MidiFileObject = pStreamHeader->pMidiPin->pFileObject;

    Status = KsStreamIo(
        pStreamHeader->pMidiPin->pFileObject,
        NULL,                   // Event
        NULL,                   // PortContext
        ReadMidiCallBack,
        pStreamHeader,              // CompletionContext
        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
        &gIoStatusBlock,
        &pStreamHeader->Header,
        sizeof( KSSTREAM_HEADER ),
        KSSTREAM_READ,
        KernelMode
    );

    //
    // We are done with the file object.
    //
    ObDereferenceObject( MidiFileObject );

    // WorkItem: shouldn't this be if( !NTSUCCESS(Status) )?
    if ( STATUS_UNSUCCESSFUL == Status )
        DPF(DL_WARNING|FA_MIDI, ("KsStreamIo failed2: Status = 0x%08lx", Status));

    //
    // Warning: If, for any reason, the completion routine is not called
    // for this Irp, wdmaud.sys will hang.  It's been discovered that 
    // KsStreamIo may error out in low memory conditions.  There is an
    // outstanding bug to address this.
    //

    return;
}

//
// pNewMidiHdr will always be valid.  The caller just allocated it!
//
NTSTATUS 
AddBufferToMidiInQueue(
    PMIDI_PIN_INSTANCE  pMidiPin,
    PMIDIINHDR          pNewMidiInHdr
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PMIDIINHDR  pTemp;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Bad fGraphRunning") );
        RETURN( STATUS_DEVICE_NOT_READY ); 
    }

    DPF(DL_TRACE|FA_MIDI, ("received sysex buffer"));

    ExInterlockedInsertTailList(&pMidiPin->MidiInQueueListHead,
                                &pNewMidiInHdr->Next,
                                &pMidiPin->MidiInQueueSpinLock);

    Status = STATUS_PENDING;

    RETURN( Status );
}


VOID 
CleanupMidiDevices(
    IN  PWDMACONTEXT pWdmaContext
)
{
    DWORD               DeviceNumber;
    DWORD               DeviceType;
    PMIDI_PIN_INSTANCE  pMidiPin=NULL;

    PAGED_CODE();
    for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
    {
        for (DeviceType = MidiInDevice; DeviceType < MixerDevice; DeviceType++)
        {
            if (DeviceType == MidiInDevice)
            {
                pMidiPin = pWdmaContext->MidiInDevs[DeviceNumber].pMidiPin;
            }
            else if (DeviceType == MidiOutDevice)
            {
                pMidiPin = pWdmaContext->MidiOutDevs[DeviceNumber].pMidiPin;
            }
            else
            {
                ASSERT(!"CleanupMidiDevices: Out of range!");
            }

            if (pWdmaContext->apCommonDevice[DeviceType][DeviceNumber]->Device != UNUSED_DEVICE)
            {
                if (pMidiPin != NULL)
                {
                    NTSTATUS    Status;
                    KSSTATE     State;

                    StopMidiPinAndCompleteIo( pMidiPin, FALSE );

                    //
                    //  Probably redundant, but this frees memory associated
                    //  with the MIDI device.
                    //
                    if( DeviceType == MidiInDevice )
                    {
                        CloseMidiDevicePin(&pWdmaContext->MidiInDevs[DeviceNumber]);
                    }
                    if( DeviceType == MidiOutDevice )
                    {
                        CloseMidiDevicePin(&pWdmaContext->MidiOutDevs[DeviceNumber]);
                    }

                }  // end for active pins

            }  // end for valid Device

        } // end for DeviceTypes

    } // end for DeviceNumber

} // CleanupMidiDevices
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\kmxlutil.c ===
//---------------------------------------------------------------------------
//
//  Module:   kmxlutil.c
//
//  Description:
//    Utility routines used by the kernel mixer line driver (KMXL).
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          I N C L U D E S                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#include "WDMSYS.H"


#undef SUPER_DEBUG

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                   U T I L I T Y   F U N C T I O N S               //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//
// kmxlOpenSysAudio
//
// Opens the topology driver and dereferences the handle to get the
// file object.
//
//

PFILE_OBJECT
kmxlOpenSysAudio(
)
{
    PFILE_OBJECT pfo = NULL;
    HANDLE       hDevice = NULL;
    ULONG        ulDefault;
    NTSTATUS     Status;

    PAGED_CODE();
    //
    // Open the topology driver.
    //

    Status = OpenSysAudio(&hDevice, &pfo);

    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_SYSAUDIO,("OpenSysAudio failed Status=%X",Status) );
        return( NULL );
    }

    //
    // The handle is no longer necessary so close it.
    //

    NtClose( hDevice );

    ulDefault = KSPROPERTY_SYSAUDIO_MIXER_DEFAULT;

    Status = SetSysAudioProperty(
      pfo,
      KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
      sizeof(ulDefault),
      &ulDefault);

    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_SYSAUDIO,("SetSysAudioProperty failed Status=%X",Status) );
        return( NULL );
    }

    return( pfo );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlCloseSysAudio
//
// Close the topology device by dereferencing the file object.
//
//

VOID
kmxlCloseSysAudio(
    IN PFILE_OBJECT pfo     // Pointer to the file object to close
)
{
    PAGED_CODE();
    ObDereferenceObject( pfo );
}


///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestination
//
// In the list of destinations, it finds the destination matching
// the given id.
//
//

PMXLNODE
kmxlFindDestination(
    IN NODELIST listDests,  // The list of destinations to search
    IN ULONG    Id          // The node Id to look for in the list
)
{
    PMXLNODE pTemp = kmxlFirstInList( listDests );

    PAGED_CODE();
    while( pTemp ) {
        if( pTemp->Id == Id ) {
            return( pTemp );
        }
        pTemp = kmxlNextNode( pTemp );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToList
//
// Finds the end of the source list and makes the next element point
// to the head of target list.
//
//

VOID
kmxlAppendListToList(
    IN OUT PSLIST* plistTarget,   // The list to append to
    IN     PSLIST  listSource     // the list to append
)
{
    PSLIST pTemp;

    PAGED_CODE();

    if( *plistTarget == NULL ) {
        *plistTarget = listSource;
        return;
    }

    //
    // If source is NULL, there's no need to append.
    //

    if( listSource == NULL ) {
        return;
    }

    //
    // First find the end of the source list.  At this point,
    // listSource has at least 1 element.
    //

    pTemp = listSource;
    while( pTemp->Next ) {
        pTemp = pTemp->Next;
    }

    //
    // Attach the target list onto the end.
    //

    pTemp->Next = *plistTarget;
    *plistTarget = listSource;

}

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToEndOfList
//
// Finds the end of the target list and points the next to the source
// list.
//
//

VOID
kmxlAppendListToEndOfList(
    IN OUT PSLIST* plistTarget,         // The list to append to
    IN     PSLIST  listSource           // the list to append
)
{
    PSLIST pTemp;

    PAGED_CODE();

    if( *plistTarget == NULL ) {
        *plistTarget = listSource;
        return;
    }

    //
    // Find the end of the target list.  Target list must contain
    // at least one element at this point.
    //

    pTemp = *plistTarget;
    while( pTemp->Next ) {
        pTemp = pTemp->Next;
    }

    pTemp->Next = listSource;

}

////////////////////////////////////////////////////////////////////////
//
// kmxlListCount
//
// Loops through the Next fields to count the elements.
//
//

ULONG
kmxlListCount(
    IN PSLIST pList     // The list to count the elements of
)
{
    ULONG   Count = 0;
    PSLIST  pTemp = pList;

    PAGED_CODE();
    while( pTemp ) {
        ++Count;
        pTemp = pTemp->Next;
    }

    return( Count );
}


///////////////////////////////////////////////////////////////////////
//
// kmxlInList
//
// Loops through the given list looking for pNewNode.
//
//

BOOL
kmxlInList(
    IN PEERLIST  list,      // The list to search
    IN PMXLNODE  pNewNode   // The new to search for
)
{
    PEERNODE* pTemp = kmxlFirstInList( list );

    PAGED_CODE();
    // Zing through the list checking to see if there is a node with
    // the same Id and Type.  These two checks are suffient to ensure
    // uniquness.  Ids are unique among all sources and destinations,
    // and Ids, or node numbers, are unique among all nodes.  Note
    // that a source (or destination) node and a node can have the same
    // Id.

    while( pTemp ) {
        if( ( pTemp->pNode->Id   == pNewNode->Id   ) &&
            ( pTemp->pNode->Type == pNewNode->Type ) )
            return( TRUE );
        pTemp = kmxlNextPeerNode( pTemp );
    }

    // No match in the entire list, the new node is not already in the
    // list.

    return( FALSE );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlInChildList
//
// Calls kmxlInList on the child list of the node.
//
//

BOOL
kmxlInChildList(
    IN NODELIST list,       // The list to search the parent list
    IN PMXLNODE pNewNode    // The node to search for
)
{
    ASSERT( list )    ;
    ASSERT( pNewNode );

    PAGED_CODE();

    return( kmxlInList( list->Children, pNewNode ) );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlInParentList
//
// Calls kmxlInList on the parent list of the node.
//
//

BOOL
kmxlInParentList(
    IN NODELIST list,       // The list to search the parent list
    IN PMXLNODE pNewNode    // The node to search for
)
{
    ASSERT( list     );
    ASSERT( pNewNode );

    PAGED_CODE();

    return( kmxlInList( list->Parents, pNewNode ) );
}


///////////////////////////////////////////////////////////////////////
//
// kmxlFreePeerList
//
//
// NOTES
//   This only frees the peer nodes in a peer list.  The nodes pointed
//   to be the pNode member must be clean up in some other manner.
//
//

VOID
kmxlFreePeerList(
    IN PEERLIST list    // The PeerList to free
)
{
    PEERNODE* pPeerNode = kmxlRemoveFirstPeerNode( list );

    PAGED_CODE();
    while( pPeerNode ) {
        AudioFreeMemory( sizeof(PEERNODE),&pPeerNode );
        pPeerNode = kmxlRemoveFirstPeerNode( list );
    }
}


///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateMixerControl
//
// Calls AudioAllocateMemory() to allocate and zero fill the MXLCONTROL.
//
//

MXLCONTROL*
kmxlAllocateControl(
    IN ULONG ultag
)
{
    MXLCONTROL* p = NULL;

    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged(sizeof( MXLCONTROL ),
                                              ultag,
                                              ZERO_FILL_MEMORY,
                                              &p) ) )
    {    
#ifdef DEBUG
        p->Tag=CONTROL_TAG;
#endif

        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFreeControl
//
// Frees the memory associated with a control.  It also checkes the
// special cases for some controls that have special memory associated
// with them. And, if the control supports change notifications, it gets
// turned off here.
//
//
VOID
kmxlFreeControl(
    IN PMXLCONTROL pControl
)
{
    NTSTATUS Status;
    PAGED_CODE();
    DPFASSERT( IsValidControl( pControl ) );

    //
    // Need to disable change notifications on this node if it supported them!
    //
    kmxlDisableControlChangeNotifications(pControl);

    if( pControl->NodeType ) {

        if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUX ) &&
            !pControl->Parameters.bHasCopy ) {
            AudioFreeMemory_Unknown( &pControl->Parameters.lpmcd_lt );
            AudioFreeMemory_Unknown( &pControl->Parameters.pPins );
        }

        if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
            if (InterlockedDecrement(pControl->Parameters.pReferenceCount)==0) {
                AudioFreeMemory_Unknown( &pControl->Parameters.pMixCaps );
                AudioFreeMemory_Unknown( &pControl->Parameters.pMixLevels );
                AudioFreeMemory( sizeof(LONG),&pControl->Parameters.pReferenceCount );
                }
        }
    }

    // Check that we're not in the case where Numchannels == 0 And we have a valid
    // pControl->pChannelStepping.  If this were true, we'd end up leaking
    // pChannelStepping.
    
    ASSERT( !(pControl->pChannelStepping && pControl->NumChannels == 0) );
        
    if ( pControl->pChannelStepping && pControl->NumChannels > 0 ) {
        RtlZeroMemory( pControl->pChannelStepping, pControl->NumChannels * sizeof( CHANNEL_STEPPING ) );
        AudioFreeMemory_Unknown( &pControl->pChannelStepping );
    }
  
    //
    // Why do we zero the memory on this free?
    //
    RtlZeroMemory( pControl, sizeof( MXLCONTROL ) );
    AudioFreeMemory( sizeof( MXLCONTROL ),&pControl );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateLine
//
// Calls AudioAllocateMemory() to allocate and zero fill the MXLLINE.
//
//
//
// Workitem: Tag all these structures in debug!
//

MXLLINE*
kmxlAllocateLine(
    IN ULONG ultag
)
{
    MXLLINE* p = NULL;
    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged( sizeof( MXLLINE ), 
                                               ultag, 
                                               ZERO_FILL_MEMORY, 
                                               &p ) ) ) 
    {    
        p->SourceId = INVALID_ID;
        p->DestId   = INVALID_ID;
        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateNode
//
// Calls AudioAllocateMemory() to allocate and zero fill the MXLNODE.
//
//

MXLNODE*
kmxlAllocateNode(
    IN ULONG ultag
)
{
    MXLNODE* p = NULL;

    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged( sizeof( MXLNODE ), 
                                               ultag, 
                                               ZERO_FILL_MEMORY, 
                                               &p ) ) ) 
    {    
        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocatePeerNode
//
// Calls AudioAllocateMemory() to allocate and zero fill the PEERNODE.
//
//

PEERNODE*
kmxlAllocatePeerNode(
    IN PMXLNODE pNode OPTIONAL, // The node to associate with the peer
    IN ULONG ultag
)
{
    PEERNODE* p = NULL;

    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged( sizeof( PEERNODE ), 
                                               ultag, 
                                               ZERO_FILL_MEMORY, 
                                               &p ) ) ) 
    {
        p->pNode = pNode;
        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAddToEndOfList
//
// Finds the end of the list and sets the next field to the new element.
//
//

VOID
kmxlAddElemToEndOfList(
    IN OUT PSLIST* list,                // The list to add to the end of
    IN PSLIST      elem                 // The element or list to add
)
{
    PSLIST pTemp;

    PAGED_CODE();
    ASSERT( list );
    ASSERT( elem->Next == NULL );

    //
    // If the list doesn't have anything in it, the element becomes the
    // list.
    //

    if( *list == NULL ) {
        *list = elem;
        return;
    }

    //
    // Find the end of the list.
    //

    pTemp = *list;
    while( pTemp->Next ) {
        pTemp = pTemp->Next;
    }

    //
    // And attach the element to it.
    //

    pTemp->Next = elem;
}

#define LINEAR_RANGE 0xFFFF     // 64k

#define DFLINEAR_RANGE  ( 96.0 * 65535.0 )

#define NEG_INF_DB   0x80000000 // -32767 * 64k dB

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLogToLinear
//
// Converts from the hardware range (dB) to the liner mixer line range (0-64k).
//
//


DWORD
kmxlVolLogToLinear(
    IN PMXLCONTROL  pControl,
    IN LONG         Value,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
)
{
    KFLOATING_SAVE      FloatSave;
    double              LinearRange;
    double              dfValue;
    double              dfResult;
    double              dfRatio;
    DWORD               Result;
    PCHANNEL_STEPPING   pChannelStepping;

    PAGED_CODE();
    if( Value == NEG_INF_DB ) {
        return( 0 );
    }

    ASSERT( Channel < pControl->NumChannels );
    // Get the proper range for the specified channel
    pChannelStepping = &pControl->pChannelStepping[Channel];

    if( NT_SUCCESS( KeSaveFloatingPointState( &FloatSave ) ) ) {

        LinearRange = (double) LINEAR_RANGE;
        dfValue     = (double) Value;

        switch( Mapping ) {

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LOGRITHMIC:
            ////////////////////////////////////////////////////////////

                dfRatio = ( (double) pChannelStepping->MaxValue -
                            (double) pChannelStepping->MinValue ) / DFLINEAR_RANGE;

                if( dfRatio < 1.0 ) {
                    dfRatio = 1.0;
                }

                dfValue = ( dfValue - pChannelStepping->MaxValue ) / LinearRange;
                dfResult = LinearRange * pow( 10.0, dfValue / ( 20.0 * dfRatio ) );

                if( dfResult >= LINEAR_RANGE ) {
                    Result = LINEAR_RANGE;
                } else if ( dfResult < 0.0 ) {
                   Result = 0;
                } else {
                   Result = (DWORD) ( dfResult + 0.5 );
                }

                break;

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LINEAR:
            ////////////////////////////////////////////////////////////

                dfResult = ( LinearRange * ( dfValue - pChannelStepping->MinValue ) ) /
                           ( pChannelStepping->MaxValue - pChannelStepping->MinValue );
                Result = (DWORD) ( dfResult + 0.5 );
                break;

            ////////////////////////////////////////////////////////////
            default:
            ////////////////////////////////////////////////////////////

                ASSERT( 0 );
                Result = 0;
        }

        KeRestoreFloatingPointState( &FloatSave );

        DPF(DL_TRACE|FA_MIXER,
            ( "kmxlVolLogToLinear( %x [%d] ) =%d= %x [%d]",
            Value,
            Value,
            Mapping,
            (WORD) Result,
            (WORD) Result
            ) );

        return( Result );

    } else {

        return( (DWORD) ( LINEAR_RANGE *
                          ( (LONGLONG) Value - (LONGLONG) pChannelStepping->MinValue ) /
                            ( (LONGLONG) pChannelStepping->MaxValue -
                              (LONGLONG) pChannelStepping->MinValue ) ) );
    }


#ifdef LEGACY_SCALE
    WORD Result;

    Result = VolLogToLinear( (WORD) ( Value / ( -1 * LINEAR_RANGE ) ) );

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLogToLinear( %x [%d] ) = %x [%d]\n",
        Value,
        Value,
        (WORD) Result,
        (WORD) Result
        );
    #endif

    return( Result );

#endif // LEGACY_SCALE

#ifdef LONG_CALC_SCALE
    LONGLONG ControlRange = (LONGLONG) pChannelStepping->MaxValue -
                            (LONGLONG) pChannelStepping->MinValue;
    LONGLONG MinValue = (LONGLONG) pChannelStepping->MinValue;
    LONGLONG Result;

    ASSERT( ControlRange );

    Result = LINEAR_RANGE * ( (LONGLONG) Value - MinValue ) / ControlRange;

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLogToLinear( %x [%d] ) = %x [%d]\n",
        Value,
        Value,
        (WORD) Result,
        (WORD) Result
        );
    #endif

    return( (WORD) Result );
#endif // LONG_CALC_SCALE
}

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLinearToLog
//
// Converts from the mixer line range (0-64k) to the hardware range (dB).
//
//

LONG
kmxlVolLinearToLog(
    IN PMXLCONTROL  pControl,
    IN DWORD        Value,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
)
{
    KFLOATING_SAVE      FloatSave;
    double              LinearRange;
    double              dfValue;
    double              dfResult;
    double              dfRatio;
    LONG                Result;
    PCHANNEL_STEPPING   pChannelStepping;

    PAGED_CODE();
    if( Value == 0 ) {
        return( NEG_INF_DB );
    }

    ASSERT( Channel < pControl->NumChannels );
    // Get the proper range for the specified channel
    pChannelStepping = &pControl->pChannelStepping[Channel];

    if( NT_SUCCESS( KeSaveFloatingPointState( &FloatSave ) ) ) {

        LinearRange = (double) LINEAR_RANGE;
        dfValue     = (double) Value;

        switch( Mapping ) {

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LOGRITHMIC:
            ////////////////////////////////////////////////////////////

                dfRatio = ( (double) pChannelStepping->MaxValue -
                            (double) pChannelStepping->MinValue ) / DFLINEAR_RANGE;

                if( dfRatio < 1.0 ) {
                    dfRatio = 1.0;
                }

                dfResult = LinearRange * dfRatio * 20.0 * log10( dfValue / LinearRange );
                if( dfResult < 0.0 ) {
                    Result = (LONG) ( dfResult - 0.5 ) + pChannelStepping->MaxValue;
                } else {
                    Result = (LONG) ( dfResult + 0.5 ) + pChannelStepping->MaxValue;
                }
                break;

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LINEAR:
            ////////////////////////////////////////////////////////////

                dfResult = ( dfValue * ( pChannelStepping->MaxValue - pChannelStepping->MinValue ) ) /
                           LinearRange + pChannelStepping->MinValue;
                if( dfResult < 0.0 ) {
                    Result = (LONG) ( dfResult - 0.5 );
                } else {
                    Result = (LONG) ( dfResult + 0.5 );
                }
                break;

            ////////////////////////////////////////////////////////////
            default:
            ////////////////////////////////////////////////////////////

                ASSERT( 0 );
                Result = NEG_INF_DB;

        }

        KeRestoreFloatingPointState( &FloatSave );

        DPF(DL_TRACE|FA_MIXER, 
            ( "kmxlVolLinearToLog( %x [%d]) =%d= %x [%d]",
            Value,
            Value,
            Mapping,
            (LONG) Result,
            (LONG) Result
            ) );

        return( Result );

    } else {

        return( (LONG)
            ( (LONGLONG) Value *
              (LONGLONG) ( pChannelStepping->MaxValue - pChannelStepping->MinValue )
              / ( LONGLONG ) LINEAR_RANGE + (LONGLONG) pChannelStepping->MinValue )
            );
    }

#ifdef LEGACY_SCALE
    LONG Result;

    if( Value == 0 ) {
        Result = NEG_INF_DB;
    } else {
        Result = (LONG) VolLinearToLog( Value ) * -1 * (LONG) LINEAR_RANGE + pChannelStepping->MaxValue;
    }

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLinearToLog( %x [%d]) = %x [%d]\n",
        Value,
        Value,
        (LONG) Result,
        (LONG) Result
        );
    #endif

    return( Result );
#endif // LEGACY_SCALE

#ifdef LONG_CALC_SCALE

    LONGLONG ControlRange = (LONGLONG) pChannelStepping->MaxValue -
                            (LONGLONG) pChannelStepping->MinValue;
    LONGLONG MinValue = pChannelStepping->MinValue;
    LONGLONG Result;

    ASSERT( ControlRange );

    Result = (LONGLONG) Value * ControlRange / LINEAR_RANGE + MinValue;

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLinearToLog( %x [%d]) = %x [%d]\n",
        Value,
        Value,
        (LONG) Result,
        (LONG) Result
        );
    #endif

    return( (LONG) Result );
#endif // LONG_CALC_SCALE
}


///////////////////////////////////////////////////////////////////////
//
// kmxlSortByDestination
//
// Performs a sort by destination in numerical increasing order.
//
//

NTSTATUS
kmxlSortByDestination(
    IN LINELIST* list                   // The pointer to the list to sort
)
{
    PMXLLINE pTemp1,
             pTemp2;
    MXLLINE  Temp;
    ULONG    Count = kmxlListLength( *list );

    PAGED_CODE();
    //
    // If there are only 0 or 1 elements, there's no reason to even try to
    // sort.
    //

    if( Count < 2 ) {
        return( STATUS_SUCCESS );
    }

    //
    // Pretty standard BubbleSort.
    //

    while( --Count ) {

        //
        // Loop over each element in the list.
        //

        pTemp1 = kmxlFirstInList( *list );
        while( pTemp1 ) {

            //
            // Loop over the remaining elements.
            //

            pTemp2 = kmxlNextLine( pTemp1 );
            while( pTemp2 ) {

                //
                // The destination is strictly bigger.  Swap 'em.
                //

                if( pTemp1->DestId > pTemp2->DestId ) {
                    SwapEm( pTemp1, pTemp2, &Temp, sizeof( MXLLINE ) );
                    break;
                }

                //
                // The destinations are the same, but the source is
                // bigger.  Swap 'em.
                //

                if( pTemp1->DestId == pTemp2->DestId ) {
                    if( pTemp1->SourceId > pTemp2->SourceId ) {
                        SwapEm( pTemp1, pTemp2, &Temp, sizeof( MXLLINE ) );
                        break;
                    }
                }
                pTemp2 = kmxlNextLine( pTemp2 );
            }

            pTemp1 = kmxlNextLine( pTemp1 );
        }

    }

    return( STATUS_SUCCESS );

}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//              M I X E R L I N E  W R A P P E R S                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4273 )

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocDeviceInfo
//
// Note: when allocating DeviceInfo structure, we know that the structure's
// definition includes one character for the DeviceInterface, so we only need
// to allocate additional length for the string but not its NULL terminator
//
///////////////////////////////////////////////////////////////////////
NTSTATUS kmxlAllocDeviceInfo(
    LPDEVICEINFO *ppDeviceInfo, 
    PCWSTR DeviceInterface, 
    DWORD dwFlags,
    ULONG ultag
)
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = AudioAllocateMemory_Paged(sizeof(**ppDeviceInfo)+(wcslen(DeviceInterface)*sizeof(WCHAR)),
                                       ultag,
                                       ZERO_FILL_MEMORY,
                                       ppDeviceInfo);
    if (NT_SUCCESS(Status))
    {
        wcscpy((*ppDeviceInfo)->wstrDeviceInterface, DeviceInterface);
        (*ppDeviceInfo)->DeviceType   = MixerDevice;
        (*ppDeviceInfo)->dwFormat     = UNICODE_TAG;
        (*ppDeviceInfo)->dwFlags      = dwFlags;
    } else {
        *ppDeviceInfo = NULL;
    }
    return Status;
}

///////////////////////////////////////////////////////////////////////
//
// mixerGetControlDetails
//
//

MMRESULT
WINAPI
kmxlGetControlDetails(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERCONTROLDETAILS pmxcd,
    DWORD fdwDetails
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwDetails,TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status = kmxlGetControlDetailsHandler( pWdmaContext, DeviceInfo, pmxcd, pmxcd->paDetails );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown( &DeviceInfo);
    return mmr;
}

///////////////////////////////////////////////////////////////////////
//
// mixerGetLineControls
//
//

MMRESULT
WINAPI
kmxlGetLineControls(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERLINECONTROLS pmxlc,
    DWORD fdwControls
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwControls,TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status = kmxlGetLineControlsHandler( pWdmaContext, DeviceInfo, pmxlc, pmxlc->pamxctrl );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown( &DeviceInfo);
    return mmr;
}

///////////////////////////////////////////////////////////////////////
//
// mixerGetLineInfo
//
//

MMRESULT
WINAPI
kmxlGetLineInfo(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERLINE pmxl,
    DWORD fdwInfo
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwInfo, TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status = kmxlGetLineInfoHandler( pWdmaContext, DeviceInfo, pmxl );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown( &DeviceInfo);
    return mmr;
}

///////////////////////////////////////////////////////////////////////
//
// mixerSetControlDetails
//
//

MMRESULT
WINAPI
kmxlSetControlDetails(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERCONTROLDETAILS pmxcd,
    DWORD fdwDetails
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwDetails, TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status =
        kmxlSetControlDetailsHandler( pWdmaContext,
                                      DeviceInfo,
                                      pmxcd,
                                      pmxcd->paDetails,
                                      MIXER_FLAG_PERSIST
                                    );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown( &DeviceInfo);
    return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\mixer.c ===
//---------------------------------------------------------------------------
//
//  Module:   mixer.c
//
//  Description:
//    Contains the kernel mode portion of the mixer line driver.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          I N C L U D E S                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#include "WDMSYS.H"

typedef struct {
    VOID *pNext;
    PMXLCONTROL pControl;
#ifdef DEBUG
    DWORD dwSig;  // CONTROLLINK_SIGNATURE
#endif

} CONTROLLINK, *PCONTROLLINK;

//
// Data structure for Notification list.
//
typedef struct {    
    PVOID pNext;             // Pointer to next node in linked list.

    DWORD NodeId;            // This is the control's Id as seen by SysAudio

    DWORD LineID;            // Line that this control lives on
    DWORD ControlID;         // ControlID from pControl->Control.dwControlID
    DWORD ControlType;       //

    // context specific stuff...

    PWDMACONTEXT pContext;   // Pointer to Global Context structure
    PMIXERDEVICE pmxd;       // The mixer device for this control
//    PFILE_OBJECT pfo;        // File Object to SysAudio for this Context
    PCONTROLLINK pcLink;     // points to structure that contains valid
                             // pControl addresses in this context.
    KDPC NodeEventDPC;       // For handling the DPCs
    KSEVENTDATA NodeEventData;

#ifdef DEBUG
    DWORD dwSig;             // NOTIFICATION_SIGNATURE
#endif

} NOTENODE, *PNOTENODE;

#ifdef DEBUG
BOOL
IsValidNoteNode(
    IN PNOTENODE pnnode
    );

BOOL
IsValidControlLink(
    IN PCONTROLLINK pcLink
    );

/////////////////////////////////////////////////////////////////////////////
//
// IsValidNoteNode
//
// Validates that the pointer is a PNOTENODE type.
//
BOOL
IsValidNoteNode(
    IN PNOTENODE pnnode)
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if(pnnode->dwSig != NOTIFICATION_SIGNATURE)
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->dwSig(%08X)",pnnode->dwSig) );
            Status=STATUS_UNSUCCESSFUL;
        }      
/*
        if(pnnode->pfo == NULL)
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pfo(%08X)",pnnode->pfo) );
            Status=STATUS_UNSUCCESSFUL;
        }
*/
        if( !IsValidWdmaContext(pnnode->pContext) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pContext(%08X)",pnnode->pContext) );
            Status=STATUS_UNSUCCESSFUL;
        }

        if( !IsValidMixerDevice(pnnode->pmxd) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pmxd(%08X)",pnnode->pmxd) );
            Status=STATUS_UNSUCCESSFUL;
        }

        if( !IsValidControlLink(pnnode->pcLink) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pcLink(%08X)",pnnode->pcLink) );
            Status=STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// IsValidControlLink
//
// Validates that the pointer is a PNOTENODE type.
//
BOOL
IsValidControlLink(
    IN PCONTROLLINK pcLink)
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if(pcLink->dwSig != CONTROLLINK_SIGNATURE)
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pcLink->dwSig(%08X)",pcLink->dwSig) );
            Status=STATUS_UNSUCCESSFUL;
        }      
        if( !IsValidControl(pcLink->pControl) )
        {
            Status=STATUS_UNSUCCESSFUL;
        }
        //
        // pcLink->pNext is a pointer to another CONTROLLINK structure.  Thus,
        // if it's not NULL, the structure that it points to should also be valid.
        //
        if( pcLink->pNext )
        {
            PCONTROLLINK pTmp=pcLink->pNext;
            if( pTmp->dwSig != CONTROLLINK_SIGNATURE )
            {
                DPF(DL_ERROR|FA_ASSERT,("Invalid pcLink->pNext->dwSig(%08X)",pTmp->dwSig) );
                Status=STATUS_UNSUCCESSFUL;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}


#endif



PNOTENODE 
kmxlNewNoteNode(
    );

PCONTROLLINK
kmxlNewControlLink(
    IN PMXLCONTROL pControl
    );

VOID
kmxlFreeControlLink(
    IN OUT PCONTROLLINK pcLink
    );

VOID 
kmxlFreeNoteNode(
    IN OUT PNOTENODE pnnode
    );

VOID 
kmxlAddNoteNodeToList(
    IN OUT PNOTENODE pnnode
    );

VOID 
kmxlRemoveNoteNodeFromList(
    IN OUT PNOTENODE pnnode
    );

PNOTENODE
kmxlFindControlInNoteList(
    IN PMXLCONTROL pControl 
    );

NTSTATUS
kmxlFindNodeInNoteList(
    IN PNOTENODE pnlookupnode 
    );

PNOTENODE
kmxlFindIdInContextInNoteList(
    IN PWDMACONTEXT pWdmaContext,
    IN PMIXERDEVICE pmxd,
    IN DWORD Id
    );

PNOTENODE
kmxlFindContextInNoteList(
    IN PWDMACONTEXT pWdmaContext
    );

NTSTATUS
kmxlAddControlToNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    );

PCONTROLLINK 
kmxlRemoveControlFromNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    );

NTSTATUS
kmxlQueryControlChange(
    IN PFILE_OBJECT pfo,
    IN ULONG NodeId
    );

NTSTATUS
kmxlEnableControlChange(
    IN     PFILE_OBJECT pfo,
    IN     ULONG NodeId,
    IN OUT PKSEVENTDATA pksed
    );

NTSTATUS
kmxlDisableControlChange(
    IN     PFILE_OBJECT pfo,  
    IN     ULONG NodeId,
    IN OUT PKSEVENTDATA pksed
    );

NTSTATUS 
kmxlEnableControlChangeNotifications(
    IN PMIXEROBJECT pmxobj,
    IN PMXLLINE     pLine,
    IN PMXLCONTROL  pControl
    );

VOID
kmxlRemoveContextFromNoteList(
    IN PWDMACONTEXT pWdmaContext
    );

NTSTATUS
kmxlEnableAllControls(
    IN PMIXEROBJECT pmxobj
    );

//
// Used in persist
//
extern NTSTATUS
kmxlPersistSingleControl(
    IN PFILE_OBJECT pfo,
    IN PMIXERDEVICE pmxd,
    IN PMXLCONTROL  pControl,
    IN PVOID        paDetails
    );

VOID 
PersistHWControlWorker(
    IN LPVOID pData
    );

VOID
kmxlGrabNoteMutex(
    );

VOID
kmxlReleaseNoteMutex(
    );

VOID 
kmxlCloseMixerDevice(
    IN OUT PMIXERDEVICE pmxd
    );



#pragma LOCKED_CODE
#pragma LOCKED_DATA

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          F U N C T I O N S                        //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//
// This is the head of the notification list.  mtxNotification is used to
// handle the list manipulcation.  The allocated memory in the firstnotenode
// list will be touched at DPC level.
//
PNOTENODE firstnotenode=NULL;
extern KMUTEX mtxNote;
#ifdef DEBUG
LONG totalnotificationcount=0;
#endif

#define CALLBACKARRAYSIZE 128

typedef struct {
    DWORD  dwControlID;
    DWORD  dwLineID;
    DWORD  dwCallbackType;
} CBINFO, *PCBINFO;


ULONG emptyindex=0;

volatile ULONG loadindex=0;
CBINFO callbacks[CALLBACKARRAYSIZE]={0};

KSPIN_LOCK       HardwareCallbackSpinLock;
LIST_ENTRY       HardwareCallbackListHead;

PKEVENT          pHardwareCallbackEvent=NULL;
PKSWORKER        HardwareCallbackWorkerObject=NULL;
WORK_QUEUE_ITEM  HardwareCallbackWorkItem;
ULONG            HardwareCallbackScheduled=0;

typedef struct tagHWLink {
    LIST_ENTRY Next;
    PNOTENODE pnnode;
#ifdef DEBUG
    DWORD dwSig;
#endif    
} HWLINK, *PHWLINK;




/////////////////////////////////////////////////////////////////////////////
//
// NodeEventDPCHandler
//
// This routine is called at DISPATCH_LEVEL, thus you can not touch anything
// but pnnode ellements.  pnnode is fixed in memory thus it is safe.
//

VOID NodeEventDPCHandler(
    IN PKDPC Dpc, 
    IN PVOID DeferredContext, 
    IN PVOID SystemArgument1, 
    IN PVOID SystemArgument2
    )
{
    PHWLINK phwlink=NULL;
    PNOTENODE pnnode=(PNOTENODE)DeferredContext;
    PCBINFO pcbinfo;

    //
    // WorkItem: Use proper synchronization so that we never go away if there is
    // a work item scheduled!
    //
    DPFASSERT( pnnode->dwSig == NOTIFICATION_SIGNATURE );

    DPF(DL_TRACE|FA_HARDWAREEVENT, ("** ++ Event Signaled ++ **") );

    DPF(DL_TRACE|FA_HARDWAREEVENT, ("NodeId = %d LineID = %X ControlID = %X ControlType = %X",
                                    pnnode->NodeId,pnnode->LineID, 
                                    pnnode->ControlID,pnnode->ControlType) );

    callbacks[loadindex%CALLBACKARRAYSIZE].dwControlID=pnnode->ControlID;
    callbacks[loadindex%CALLBACKARRAYSIZE].dwLineID=pnnode->LineID;
    callbacks[loadindex%CALLBACKARRAYSIZE].dwCallbackType=MIXER_CONTROL_CALLBACK;

    //
    // Now we want to setup a work item to persist the hardware event.  The idea
    // is that we'll put all the events in a list and then remove them from the list
    // in the handler.  If we already have a workitem outstanding to service the
    // list, we don't schedule another.
    if( HardwareCallbackWorkerObject )
    {
        //
        // Always allocate an entry in our list to service this DPC.  We'll free this
        // event in the worker routine.
        //
        if( NT_SUCCESS(AudioAllocateMemory_Fixed(sizeof(HWLINK),
                                                 TAG_AuDF_HARDWAREEVENT,
                                                 ZERO_FILL_MEMORY,
                                                 &phwlink) ) )
        {
            phwlink->pnnode=pnnode;
#ifdef DEBUG
            phwlink->dwSig=HWLINK_SIGNATURE;
#endif

            ExInterlockedInsertTailList(&HardwareCallbackListHead,
                                        &phwlink->Next,
                                        &HardwareCallbackSpinLock);
            //
            // Now, if we haven't scheduled a work item yet, do so to service this
            // info in the list. HardwareCallbackSchedule will be 0 at
            // initialization time.  This variable will be set to 0 in the 
            // work item handler.  If we increment and it's any other value other 
            // then 1, we've already scheduled a work item.  
            //
            if( InterlockedIncrement(&HardwareCallbackScheduled) == 1 )
            {
                KsQueueWorkItem(HardwareCallbackWorkerObject, &HardwareCallbackWorkItem);
            } 
        }
    } 

    // Now if the control was a mute, then send line change as well.
    if (pnnode->ControlType==MIXERCONTROL_CONTROLTYPE_MUTE) {
        callbacks[loadindex%CALLBACKARRAYSIZE].dwCallbackType|=MIXER_LINE_CALLBACK;
    }

    loadindex++;

    if (pHardwareCallbackEvent!=NULL) {
        KeSetEvent(pHardwareCallbackEvent, 0 , FALSE);
    }
}


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA


/////////////////////////////////////////////////////////////////////////////
//
// kmxlNewNoteNode
//
// This routine allocates another Notification node.  Note that AudioAllocateMemory zeros
// all successful memory allocations.
//
// The return value is a pointer to a Notification Node or NULL.
//

PNOTENODE 
kmxlNewNoteNode(
    )
{
    PNOTENODE pnnode = NULL;
    NTSTATUS  Status;

    PAGED_CODE();
    Status = AudioAllocateMemory_Fixed(sizeof( NOTENODE ),
                                       TAG_AuDN_NOTIFICATION,
                                       ZERO_FILL_MEMORY,
                                       &pnnode );
    if( !NT_SUCCESS( Status ) ) {
        return( NULL );
    }
    DPF(DL_MAX|FA_NOTE, ("New notification node allocated %08X",pnnode) );

#ifdef DEBUG
    pnnode->dwSig=NOTIFICATION_SIGNATURE;
#endif

    return pnnode;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlNewControlLink
//
// This routine allocates another CONTROLLINK node.  Note that AudioAllocateMemory zeros
// all successful memory allocations.
//
// The return value is a pointer to a Notification Node or NULL.
//
PCONTROLLINK
kmxlNewControlLink(
    IN PMXLCONTROL pControl
    )
{
    PCONTROLLINK pcLink = NULL;
    NTSTATUS     Status;

    PAGED_CODE();
    Status = AudioAllocateMemory_Fixed(sizeof( CONTROLLINK ),
                                       TAG_AuDL_LINK,
                                       ZERO_FILL_MEMORY,
                                       &pcLink );
    if( !NT_SUCCESS( Status ) ) {
        return( NULL );
    }

    DPF(DL_MAX|FA_NOTE, ("New controllink node allocated %08X",pcLink) );

#ifdef DEBUG
    pcLink->dwSig=CONTROLLINK_SIGNATURE;
#endif
    //
    // Setup the pcontrol first and then link it in.
    //
    pcLink->pControl=pControl;

    return pcLink;
}

VOID
kmxlFreeControlLink(
    IN OUT PCONTROLLINK pcLink
    )
{
    DPFASSERT(IsValidControlLink(pcLink));
    PAGED_CODE();

#ifdef DEBUG
    pcLink->dwSig=(DWORD)0xDEADBEEF;
#endif

    AudioFreeMemory(sizeof( CONTROLLINK ),&pcLink);
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFreeNoteNode
//
// This routine frees a Notification Node.
//
VOID 
kmxlFreeNoteNode(
    IN OUT PNOTENODE pnnode
    )
{
    PCONTROLLINK pcLink,pcTmp;
    PAGED_CODE();

    DPFASSERT( pnnode->dwSig == NOTIFICATION_SIGNATURE );
    DPFASSERT( pnnode->pNext == NULL );
    DPFASSERT( pnnode->pcLink == NULL );

    DPF(DL_MAX|FA_NOTE,("NotificationNode freed %08X",pnnode) );
    AudioFreeMemory( sizeof( NOTENODE ),&pnnode );
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlAddNoteNodeToList
//
// This routine adds the NotificationNode to the list.  It places the node
// at the head of the list.
//
VOID 
kmxlAddNoteNodeToList(
    IN OUT PNOTENODE pnnode
    )
{
    PAGED_CODE();

    pnnode->pNext=firstnotenode;
    firstnotenode=pnnode;
#ifdef DEBUG
    totalnotificationcount++;
#endif
    DPF(DL_TRACE|FA_INSTANCE,("New NoteNode head %08X, Total=%d",pnnode,totalnotificationcount) );
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlRemoveNoteNodeFromList
//
// This routine removes a node from the list.
//
VOID 
kmxlRemoveNoteNodeFromList(
    IN OUT PNOTENODE pnnode
    )
{
    PNOTENODE pTmp;

    PAGED_CODE();

    DPFASSERT(pnnode->dwSig == NOTIFICATION_SIGNATURE);

    // are we the head of the list?  If so, move the next to the head.
    if( pnnode == firstnotenode )
    {
        firstnotenode=firstnotenode->pNext;
        DPF(DL_MAX|FA_NOTE,("removed notenode head") );
    } else {
        // we are somewhere in the list we need to walk the list until we find
        // our node and clip it out.
        for (pTmp=firstnotenode;pTmp!=NULL;pTmp=pTmp->pNext)
        {
            DPFASSERT(pTmp->dwSig==NOTIFICATION_SIGNATURE);

            // Did we find our node in the next position?  If so, we
            // need to clip it out.  Thus, pTmp.next needs to point to
            // (our node)'s next.
            if(pTmp->pNext == pnnode)
            {    
                pTmp->pNext = pnnode->pNext;
                DPF(DL_MAX|FA_NOTE,("removed middle") );
                break;
            }   
        }
    }
#ifdef DEBUG
    totalnotificationcount--;
#endif

    //
    // to indicate that this node has been removed, pNext gets set to NULL!
    //
    pnnode->pNext=NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindControlInNoteList
//
// This routine walks the linked list looking for this control.  Because all controls
// are globally allocated, all pControl addresses will be unique.  Thus, all
// we really need to do is find the control.  If an exact match is found, 
// pnnode is returned.
//
PNOTENODE
kmxlFindControlInNoteList(
    IN PMXLCONTROL pControl )
{
    PNOTENODE pnnode;
    PCONTROLLINK pcLink;

    PAGED_CODE();
    for (pnnode=firstnotenode;pnnode!=NULL;pnnode=pnnode->pNext)
    {
        //
        // Can't check entire structure because pmxd may have been cleaned out.
        //
        DPFASSERT(pnnode->dwSig == NOTIFICATION_SIGNATURE);

        for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
        {
            DPFASSERT(IsValidControlLink(pcLink));
            if( pcLink->pControl == pControl )
            {
                //
                // We found this control in the list!
                //
                return pnnode;
            }
        }
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindControlTypeInList
//
// This routine walks 
//
PMXLCONTROL
kmxlFindControlTypeInList(
    IN PNOTENODE pnnode,
    IN DWORD dwControlType )
{
    PCONTROLLINK pcLink;

    PAGED_CODE();

    for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
    {
        DPFASSERT(IsValidControlLink(pcLink));
        if( pcLink->pControl->Control.dwControlType == dwControlType )
        {
            //
            // We found this control in the list!  Types match.
            //
            DPF(DL_TRACE|FA_NOTE,("Found Correct pControl %08X",pcLink->pControl) );
            return pcLink->pControl;
        }
    }

    return NULL;
}


#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindAddressInNoteList
//
// This routine walks the linked list looking for this control within this
// context.  If an exact match is found, pnnode is returned.
//
VOID
kmxlFindAddressInNoteList(
    IN PMXLCONTROL pControl 
    )
{
    PNOTENODE pnnode;
    PCONTROLLINK pcLink;

    PAGED_CODE();
    for (pnnode=firstnotenode;pnnode!=NULL;pnnode=pnnode->pNext)
    {
        DPFASSERT(pnnode->dwSig == NOTIFICATION_SIGNATURE);
        //
        // Let's look to see if this address is one of our pControls!
        //
        for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
        {
            DPFASSERT(pcLink->dwSig == CONTROLLINK_SIGNATURE);
            if( pcLink->pControl == pControl )
            {
                //
                // We found this control in the list - in the right context!
                //
                DPF(DL_ERROR|FA_NOTE,("Found pControl(%08X) in our list!",pControl) );
                return ;
            }
        }
    }
    return ;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindNodeInNoteList
//
// Walks the node list looking for this node.  This must be called within the
// mtxMutex.
//
NTSTATUS
kmxlFindNodeInNoteList(
    IN PNOTENODE pnlookupnode )
{
    PNOTENODE pnnode;

    PAGED_CODE();
    for (pnnode=firstnotenode;pnnode!=NULL;pnnode=pnnode->pNext)
    {
        if( pnnode == pnlookupnode )
        {    
            //
            // Only if we find what we're looking for do we actually verify
            // that it's still good.
            //
            DPFASSERT(IsValidNoteNode(pnnode));
            //
            // we found this control in the list
            //
            return STATUS_SUCCESS;
        }   
    }
    return STATUS_UNSUCCESSFUL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindIdInContextInNoteList
//
// Walks the notification list looking for the node that contains this id in
// this context.
//
PNOTENODE
kmxlFindIdInContextInNoteList(
    IN PWDMACONTEXT pWdmaContext,
    IN PMIXERDEVICE pmxd,
    IN DWORD NodeId
)
{
    PNOTENODE pnTmp;

    PAGED_CODE();
    for (pnTmp=firstnotenode;pnTmp!=NULL;pnTmp=pnTmp->pNext)
    {
        DPFASSERT(IsValidNoteNode(pnTmp));

        if(( pnTmp->NodeId == NodeId ) &&
           ( pnTmp->pmxd == pmxd ) &&
           ( pnTmp->pContext == pWdmaContext ) )
        {    
            //
            // we found this control in the list in this context.
            //
            return pnTmp;
        }   
    }
    //
    // We have walked the list.  There is no control with this ID in this Context.
    //
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindContextInNoteList
//
PNOTENODE
kmxlFindContextInNoteList(
    IN PWDMACONTEXT pWdmaContext
    )
{
    PNOTENODE pnTmp;

    PAGED_CODE();
    for (pnTmp=firstnotenode;pnTmp!=NULL;pnTmp=pnTmp->pNext)
    {
        DPFASSERT(IsValidNoteNode(pnTmp));

        if( pnTmp->pContext == pWdmaContext )
        {    
            //
            // Found this context in our list.
            //
            DPFBTRAP();
            return pnTmp;
        }   
    }
    //
    // We have walked the list.  There is no control with this ID in this Context.
    //

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlAddControlToNoteList
//
// Adds this pControl to pcLink list.
//
NTSTATUS
kmxlAddControlToNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    PCONTROLLINK pcLink = NULL;

    PAGED_CODE();
#ifdef DEBUG
    //
    // Let's walk the list and make double sure that this node is not already in
    // the list.
    //
    for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
    {
        if( pcLink->pControl == pControl )
        {
            DPF(DL_ERROR|FA_NOTE,("pControl(%08X) already in list!") );
            return STATUS_UNSUCCESSFUL;
        }
    }
#endif

    Status = AudioAllocateMemory_Fixed(sizeof( CONTROLLINK ),
                                       TAG_AuDL_LINK,
                                       ZERO_FILL_MEMORY,
                                       &pcLink );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_ERROR|FA_NOTE,("Wasn't able to add control to list! Status=%08X",Status) );
        return Status;
    }

#ifdef DEBUG
    pcLink->dwSig=CONTROLLINK_SIGNATURE;
#endif
    pcLink->pControl=pControl;
    //
    // Make new head.
    //
//    if( pnnode->pcLink != NULL )
//        _asm int 3
    pcLink->pNext=pnnode->pcLink;
    pnnode->pcLink=pcLink;
    DPF(DL_TRACE|FA_NOTE,("Added pControl %d to pnnode(%08X)",pControl->Control.dwControlID,pnnode) );
    return Status;
}


PCONTROLLINK
kmxlRemoveControlFromNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    )
{
    PCONTROLLINK pcLink,pcTmp;

    PAGED_CODE();

    //
    // Does the first node contain our pControl?
    //
    DPFASSERT(IsValidControlLink(pnnode->pcLink));

    for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
    {
        if( pcLink->pControl == pControl )
            break;
    }

    if( pcLink == pnnode->pcLink )
    {
        pnnode->pcLink = pcLink->pNext;
        DPF(DL_TRACE|FA_NOTE,("removed head pControlLink") );
    } else {
        for( pcTmp=pnnode->pcLink;pcTmp!=NULL;pcTmp=pcTmp->pNext)
        {
            if( pcTmp->pNext == pcLink )
            {
                pcTmp->pNext = pcLink->pNext;
                DPF(DL_TRACE|FA_NOTE,("Removed Middle pControlLink") );
                break;
            }
        }
    }
//    DPFASSERT(IsValidNoteNode(pnnode));

    return pcLink;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlQueryControlChange
//
// Query's to see if control change notifications are supported on this 
// control.
//
NTSTATUS
kmxlQueryControlChange(
    IN PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN ULONG NodeId        //PMXLCONTROL pControl
    )
{
    NTSTATUS        Status;

    KSE_NODE        KsNodeEvent;
    ULONG           BytesReturned;

    PAGED_CODE();
    // initialize event for basic support query
    RtlZeroMemory(&KsNodeEvent,sizeof(KSE_NODE));
    KsNodeEvent.Event.Set = KSEVENTSETID_AudioControlChange;
    KsNodeEvent.Event.Id = KSEVENT_CONTROL_CHANGE;
    KsNodeEvent.Event.Flags = KSEVENT_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
    KsNodeEvent.NodeId = NodeId;

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_ENABLE_EVENT") );

    Status = KsSynchronousIoControlDevice(
        pfo,                    // The FILE_OBJECT for SysAudio
        KernelMode,             // Call originates in Kernel mode
        IOCTL_KS_ENABLE_EVENT,  // KS PROPERTY IOCTL
        &KsNodeEvent,           // Pointer to the KSNODEPROPERTY struct
        sizeof(KSE_NODE),        // Number or bytes input
        NULL,                   // Pointer to the buffer to store output
        0,                      // Size of the output buffer
        &BytesReturned          // Number of bytes returned from the call
        );

    if (!NT_SUCCESS(Status)) {
        DPF( DL_MAX|FA_HARDWAREEVENT, ("NODE #%d:  KSEVENT_CONTROL_CHANGE Not Supported Error %08X",NodeId,Status) );
        RETURN( Status );
    }

    DPF(DL_TRACE|FA_HARDWAREEVENT ,("NodeId #%d: KSEVENT_CONTROL_CHANGE Supported",NodeId) );

    return Status;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlEnableControlChange
//
// Turns on Control chnage notifications on this control.
//
NTSTATUS
kmxlEnableControlChange(
    IN     PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN     ULONG NodeId,        //PMXLCONTROL pControl,
    IN OUT PKSEVENTDATA pksed
    )
{
    NTSTATUS        Status;
    KSE_NODE        KsNodeEvent;
    ULONG           BytesReturned;

    PAGED_CODE();
    // try to add an event
    RtlZeroMemory(&KsNodeEvent,sizeof(KSE_NODE));
    KsNodeEvent.Event.Set = KSEVENTSETID_AudioControlChange;
    KsNodeEvent.Event.Id = KSEVENT_CONTROL_CHANGE;
    KsNodeEvent.Event.Flags = KSEVENT_TYPE_ENABLE | KSPROPERTY_TYPE_TOPOLOGY;
    KsNodeEvent.NodeId = NodeId;

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_ENABLE_EVENT") );

    Status = KsSynchronousIoControlDevice(
    pfo,                    // The FILE_OBJECT for SysAudio
    KernelMode,             // Call originates in Kernel mode
    IOCTL_KS_ENABLE_EVENT,  // KS PROPERTY IOCTL
    &KsNodeEvent,           // Pointer to the KSNODEPROPERTY struct
    sizeof(KSE_NODE),       // Number or bytes input
    pksed,                  // Pointer to the buffer to store output
    sizeof(KSEVENTDATA),    // Size of the output buffer
    &BytesReturned          // Number of bytes returned from the call
    );

    if (!NT_SUCCESS(Status)) {
        DPF(DL_WARNING|FA_HARDWAREEVENT ,("KSEVENT_CONTROL_CHANGE Enable FAILED Error %08X",Status) );
        RETURN( Status );
    }

    DPF(DL_TRACE|FA_HARDWAREEVENT ,
        ("KSEVENT_CONTROL_CHANGE Enabled on NodeId #%d",NodeId) );

    return Status;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlDisableControlChange
//
// Turns off Control chnage notifications on this control.
//
NTSTATUS
kmxlDisableControlChange(
    IN     PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN     ULONG NodeId,        //PMXLCONTROL pControl,
    IN OUT PKSEVENTDATA pksed
    )
{
    NTSTATUS        Status;
    KSE_NODE        KsNodeEvent;
    ULONG           BytesReturned;

    PAGED_CODE();
    // initialize event for basic support query
    RtlZeroMemory(&KsNodeEvent,sizeof(KSE_NODE));
    KsNodeEvent.Event.Set = KSEVENTSETID_AudioControlChange;
    KsNodeEvent.Event.Id = KSEVENT_CONTROL_CHANGE;
    KsNodeEvent.Event.Flags = KSEVENT_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
    KsNodeEvent.NodeId = NodeId;


    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_DISABLE_EVENT") );

    Status = KsSynchronousIoControlDevice(
              pfo,                    // The FILE_OBJECT for SysAudio
              KernelMode,             // Call originates in Kernel mode
              IOCTL_KS_DISABLE_EVENT, // KS PROPERTY IOCTL
              pksed,                  // Pointer to the buffer to store output
              sizeof(KSEVENTDATA),    // Size of the output buffer
              NULL,                   // Pointer to the KSNODEPROPERTY struct
              0,                      // Number or bytes input
              &BytesReturned          // Number of bytes returned from the call
             );

    if (!NT_SUCCESS(Status)) {
       DPF(DL_WARNING|FA_HARDWAREEVENT,("KSEVENT_CONTROL_CHANGE Disable FAILED") );
       RETURN( Status );
    }

    DPF(DL_TRACE|FA_HARDWAREEVENT, 
        ("KSEVENT_CONTROL_CHANGE disabled on NodeId #%d",NodeId) );

    return Status;
}


VOID
kmxlGrabNoteMutex(
    )
{
    //
    // Turn off the APCDisable flag in the thread structure before going for our
    // mutex.  This will prevent us from getting suspeneded while holding this
    // mutex.
    //
    KeEnterCriticalRegion();
    KeWaitForMutexObject(&mtxNote, Executive, KernelMode, FALSE, NULL);
}

VOID
kmxlReleaseNoteMutex(
    )
{
    KeReleaseMutex(&mtxNote, FALSE);
    KeLeaveCriticalRegion();
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlEnableControlChangeNotifications
//
// This routine gets called every time a new control is created.  At that point
// we're going to query the node to see if it supports change notifications
// and enable them in this context.
//
NTSTATUS 
kmxlEnableControlChangeNotifications(
    IN PMIXEROBJECT pmxobj,
    IN PMXLLINE     pLine,        // Line that owns control
    IN PMXLCONTROL  pControl      // Control to Enable
    )
{
    PNOTENODE pnnode;
    NTSTATUS    Status;
    LONG i;
    PMIXERDEVICE pmxd;
    PWDMACONTEXT pWdmaContext;
    
    kmxlGrabNoteMutex();

    DPFASSERT(IsValidMixerObject(pmxobj));

    pmxd=pmxobj->pMixerDevice;

    DPFASSERT(IsValidMixerDevice(pmxd));

    pWdmaContext=pmxd->pWdmaContext;

    PAGED_CODE();

    //
    // Never allow anything in the list if it's not valid!
    //
    DPFASSERT(IsValidControl(pControl));

    //
    // The first thing we do is look to see if a control of this ID is enabled in
    // this context.  If so, we'll get a PNOTENODE structure returned to us that
    // contains that ID.  All we should have to do is add our new pControl.
    //
    if( pnnode=kmxlFindIdInContextInNoteList(pWdmaContext,pmxd,pControl->Id) ) // Not pControl->Control.dwControlID
    {
        //
        // yes there is.  Add this pControl to this pnnode and we're done.
        //
        Status=kmxlAddControlToNoteList(pnnode,pControl);

    } else {
        //
        // There is no Control with this ID in this Context.  Let's try to 
        // Add one.
        //
        //
        // This node is not in our list, we need to add it if and only if it
        // supports change notifications
        //
        Status=kmxlQueryControlChange(pmxd->pfo,pControl->Id); //pLocfo
        if( NT_SUCCESS(Status) )
        {
            //
            // This control supports notifications, thus add info to our
            // global list - if it's not already there...
            //
            if( (pnnode=kmxlNewNoteNode()) != NULL )
            {
                if( (pnnode->pcLink=kmxlNewControlLink(pControl)) != NULL )
                {
                    pnnode->NodeId=pControl->Id;
                    //
                    // We have a new notification node to fill out.
                    //
                    pnnode->ControlID=pControl->Control.dwControlID;
                    pnnode->ControlType=pControl->Control.dwControlType;
                    pnnode->LineID=pLine->Line.dwLineID;

                    pnnode->pContext=pWdmaContext; //NOTENODE
                    pnnode->pmxd=pmxd;

                    DPF(DL_TRACE|FA_NOTE ,
                        ("Init pnnode, NodeId=#%d: CtrlID=%X CtrlType=%X Context=%08X",
                             pnnode->NodeId,             //pControl->Id
                             pnnode->ControlID,      //pControl->Control.dwControlID,
                             pnnode->ControlType,
                             pnnode->pContext) ); //pControl->Control.dwControlType) );
                    //
                    // Now setup the DPC handling
                    //
                    KeInitializeDpc(&pnnode->NodeEventDPC,NodeEventDPCHandler,pnnode);

                    pnnode->NodeEventData.NotificationType=KSEVENTF_DPC;
                    pnnode->NodeEventData.Dpc.Dpc=&pnnode->NodeEventDPC;

                    //
                    // At this point, we've got a little window.  We call and enable
                    // events on this control.  From that time until the time we actually
                    // add it to the list, if an event fires, we will not find this node
                    // in the list - thus we will not process it.
                    //
                    Status=kmxlEnableControlChange(pnnode->pmxd->pfo,
                                                   pnnode->NodeId, //pControl,
                                                   &pnnode->NodeEventData);
                                               //&NodeEvent[NumEventDPCs].NodeEventData);
                    if( NT_SUCCESS(Status) )
                    {
                        DPF(DL_TRACE|FA_HARDWAREEVENT,("Enabled Control #%d in context(%08X)!",pControl->Id,pWdmaContext) );
                        //
                        // Now let's add it to our global list
                        //
                        //
                        kmxlAddNoteNodeToList(pnnode);

                        DPFASSERT(IsValidNoteNode(pnnode));
                    } else {
                        DPF(DL_WARNING|FA_HARDWAREEVENT,("Failed to Enable Control #%d!",pControl->Id) );
                        DPFBTRAP();
                        //
                        // For some reason, this node failed to enable.
                        //
                        kmxlFreeControlLink(pnnode->pcLink);
                        kmxlFreeNoteNode(pnnode);
                    }

                } else {
                    DPF(DL_ERROR|FA_NOTE,("kmxlNewControlLink failed") );
                    kmxlFreeNoteNode(pnnode);
                }
            } else {
                DPF(DL_WARNING|FA_NOTE,("kmxlNewNoteNode failed") );
            }
        } else {
            DPF(DL_MAX|FA_HARDWAREEVENT,("This control #%d doesn't support change notifications",pControl->Id) );
        }
    }    

    kmxlReleaseNoteMutex();

    return Status;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlDisableControlChangeNotifications
//
// This routine gets called every time a control is freed.  We walk the list
// of enable controls and see if it's there.  If so, we disable and clean up.
// if it's not in the list, it didn't support change notifications.
//

NTSTATUS
kmxlDisableControlChangeNotifications(
    IN PMXLCONTROL pControl
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    PNOTENODE pnnode;

    PAGED_CODE();

    kmxlGrabNoteMutex();

    DPFASSERT(IsValidControl(pControl));

    //
    // Find this control in our list.
    //
    if(pnnode=kmxlFindControlInNoteList(pControl))  //pWdmaContext,
    {
        PCONTROLLINK pcLink;

#ifdef DEBUG
        if( pControl->Id != pnnode->NodeId )
        {
            DPF(DL_ERROR|FA_NOTE,("Control NodeId Changed! CtrlId=%08X,pnnodeID=%08X",
                                  pControl->Id,pnnode->NodeId) );
        }

#endif
        //
        // This call removes pControl from this node.  note that after this 
        // control is removed, pnnode->pcLink will be NULL if there are no
        // more controls hanging on this Notification node.  Thus, we need
        // to disable it.
        //
        pcLink=kmxlRemoveControlFromNoteList(pnnode,pControl);
        if( pnnode->pcLink == NULL )
        {
            //
            // During cleanup, the mixer device structure will have already been
            // cleaned up.  This can be seen because the pmxd->Device entry will
            // be UNUSED_DEVICE.  Thus, we can't do anything on that mixerdevice.
            //
            if( ( pnnode->pmxd->Device != UNUSED_DEVICE ) && 
                ( pnnode->pmxd->pfo != NULL ) )
            {
                //
                // There are no references to this node, we can free it. But, if
                // this disable call fails, then the node was already distroyed.
                //
                Status=kmxlDisableControlChange(pnnode->pmxd->pfo,pnnode->NodeId,&pnnode->NodeEventData);
                if( !NT_SUCCESS(Status) )
                {
                    DPF(DL_WARNING|FA_NOTE,("Not able to disable! pnnode %08X",pnnode) );
                }

            } else {
                DPF(DL_WARNING|FA_NOTE,("pmxd is invalid %08X",pnnode->pmxd) );
            }
            kmxlRemoveNoteNodeFromList(pnnode);

            kmxlFreeNoteNode(pnnode);
        } 

        DPF(DL_TRACE|FA_NOTE,("Removed PCONTROLLINK(%08X) for pControl(%08X)",pcLink,pcLink->pControl) );

        kmxlFreeControlLink(pcLink);

    } else {
        //
        // We get called on every control free.  Thus, many will not be in our list.
        //
        DPF(DL_MAX|FA_NOTE,("Control=%d not in List!",pControl->Id) );
    }

    kmxlReleaseNoteMutex();
    return Status;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlRemoveContextFromNoteList
//
// This routine gets called when this context is going away.  Thus, we need to
// remove it from our list.
//
VOID
kmxlRemoveContextFromNoteList(
    IN PWDMACONTEXT pContext
    )
{
    NTSTATUS Status;
    PNOTENODE pnnode;
    PCONTROLLINK pcLink;

    PAGED_CODE();

    kmxlGrabNoteMutex();

    //
    // If we find this context is still alive in our list, someone leaked a control.
    // Things should have been cleaned up when the controls went away!  But, for 
    // some reasons they didn't.
    //
    // There could be multiple pContext nodes in list.
    //
    while( (pnnode=kmxlFindContextInNoteList(pContext)) != NULL )
    {
        DPFASSERT(IsValidNoteNode(pnnode));

        kmxlRemoveNoteNodeFromList(pnnode);
        //
        // There can be multiple Controls on this Notification node.
        //
        while( (pnnode->pcLink != NULL) && 
               ( (pcLink=kmxlRemoveControlFromNoteList(pnnode,pnnode->pcLink->pControl)) != NULL) )
        {
            //
            // To get here, pcLink is Valid.  If it was the last pControl, then
            // we want to turn off change notifications on it.
            //
            if( pnnode->pcLink == NULL )
            {
                //
                // There are no references to this node, we can free it.
                //
                Status=kmxlDisableControlChange(pnnode->pmxd->pfo,pnnode->NodeId,&pnnode->NodeEventData);
                DPFASSERT( Status == STATUS_SUCCESS );
                DPFBTRAP();
            } 
            kmxlFreeControlLink(pcLink);
            DPFBTRAP();
        }
        kmxlFreeNoteNode(pnnode);
    } 

    DPF(DL_TRACE|FA_NOTE,("pWdmaContext %08X going away",pContext) );

    kmxlReleaseNoteMutex();
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlCleanupNotelist
//
// Driver is unloading, turn everything off and free the memory!
//
VOID
kmxlCleanupNoteList(
    )
{
    NTSTATUS Status;
    PNOTENODE pnnode,pnnodeFree;
    PCONTROLLINK pcLink;

    PAGED_CODE();

    kmxlGrabNoteMutex();

    //
    // If we find this context is still alive in our list, someone leaked a control.
    // Things should have been cleaned up when the controls went away!  But, for 
    // some reasons they didn't.
    //
    // There could be multiple pContext nodes in list.
    //
    pnnode=firstnotenode;
    while( pnnode )
    {
        DPFASSERT(IsValidNoteNode(pnnode));
        DPF(DL_ERROR|FA_NOTE,("pnnode(%08X) found in Notification List!",pnnode) );

        kmxlRemoveNoteNodeFromList(pnnode);
        //
        // There can be multiple Controls on this Notification node.
        //
        while( (pnnode->pcLink != NULL) && 
               ( (pcLink=kmxlRemoveControlFromNoteList(pnnode,pnnode->pcLink->pControl)) != NULL) )
        {
            //
            // To get here, pcLink is Valid.  If it was the last pControl, then
            // we want to turn off change notifications on it.
            //
            if( pnnode->pcLink == NULL )
            {
                //
                // There are no references to this node, we can free it.
                //
                Status=kmxlDisableControlChange(pnnode->pmxd->pfo,pnnode->NodeId,&pnnode->NodeEventData);
                DPFASSERT( Status == STATUS_SUCCESS );
                DPFBTRAP();
            } 
            kmxlFreeControlLink(pcLink);
            DPFBTRAP();
        }
        pnnodeFree=pnnode;
        pnnode=pnnode->pNext;
        kmxlFreeNoteNode(pnnodeFree);
        DPFBTRAP();
    } 

    DPF(DL_TRACE|FA_NOTE,("Done with cleanup") );

    kmxlReleaseNoteMutex();
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlPersistHWControlWorker
//
// When kmxlPersistHWControlWorker gets called, the pData value is a pointer
// to a globally allocated NOTENODE structure.  Thus, we have all the context
// we need with regard to persisting the control.  We just need to make sure
// that our node didn't go away between the time the evern was scheduled and
// when we got called.
//
VOID 
kmxlPersistHWControlWorker(
    PVOID pReference
    )
{
    NTSTATUS  Status;
    PMXLCONTROL pControl;
    PVOID     paDetails = NULL; // kmxlPersistSingleControl() allocates paDetails
                                // via kmxlGetCurrentControlValue()
    PNOTENODE pnnode;
    PHWLINK phwlink;

    PLIST_ENTRY ple;

    PAGED_CODE();
    //
    // We set HardwareCallbackSchedule to 0 here so that we can start adding new 
    // events for handling hardware notifications.  Note: we do that here at the 
    // start of the routine so that there will not be a window where we have 
    // something in the list that we never get a event scheduled for.  In other
    // words, this routine handles empty lists.
    //
    HardwareCallbackScheduled=0;
    //
    // while we have events in our queue, get one and service it.
    //
    while((ple = ExInterlockedRemoveHeadList(&HardwareCallbackListHead,
                                             &HardwareCallbackSpinLock)) != NULL) 
    {
        phwlink = CONTAINING_RECORD(ple, HWLINK, Next);

        DPFASSERT(phwlink->dwSig == HWLINK_SIGNATURE);

        //
        // Get our data for this event and then free the link that was allocated in
        // the DPC handler.
        //
        pnnode=phwlink->pnnode;
        AudioFreeMemory(sizeof(HWLINK),&phwlink);

        //
        // We are going to be working in this context for a while.  Thus, we're going
        // to enter our mtxNote mutex to make sure that our node doesn't go away
        // while we're persisting the values!
        //
        kmxlGrabNoteMutex();

        //
        // Now our list can't chnage!  Is this node still valid?  If we don't find
        // it in the list, it was removed before this event fired.  Thus, there is
        // nothing that we can do.  ---  Free mutex and leave.
        //
        Status=kmxlFindNodeInNoteList(pnnode);
        if( NT_SUCCESS(Status) )
        {
            DPF( DL_TRACE|FA_HARDWAREEVENT ,
                 ("Entering NodeId %d LineID %X  ControlID %d ControlType = %X",
                  pnnode->NodeId, pnnode->LineID, pnnode->ControlID, pnnode->ControlType) );

            //
            // Yes.  It's still valid.  Persist the control.
            //
            pControl=kmxlFindControlTypeInList(pnnode,pnnode->ControlType);
            if( pControl )
            {
                Status = kmxlPersistSingleControl(
                            pnnode->pmxd->pfo,
                            pnnode->pmxd,
                            pControl,  // pControl here...
                            paDetails
                            );
            }
            if( !NT_SUCCESS(Status) )
            {
                //
                // On shutdown, we might get an event that fires after things have 
                // been cleaned up.
                //
                if( Status != STATUS_TOO_LATE )
                {
                    DPF(DL_WARNING|FA_NOTE, ("Failure from kmxlPersistSingleControl Status=%X",Status) );
                }
            }
            else {
                DPF(DL_TRACE|FA_HARDWAREEVENT ,("Done - success") );
            }

        } else {
            DPF(DL_WARNING|FA_NOTE,("pnnode=%08X has been removed!",pnnode) );
        }

        //
        // Persist this control!
        //

        kmxlReleaseNoteMutex();

    }

    DPF(DL_TRACE|FA_HARDWAREEVENT ,("exit") );
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlGetLineForControl
//
// For every line on this mixer device, look at every control to see if we
// can find this control.  If found, return this line pointer.
//
NTSTATUS
kmxlEnableAllControls(
    IN PMIXEROBJECT pmxobj
    )
{
    NTSTATUS        Status=STATUS_SUCCESS;
    PMIXERDEVICE    pmxd;
    PMXLLINE        pLine;
    PMXLCONTROL     pControl;

    PAGED_CODE();

    //
    // The first time through we will most likily not have a pfo in the MIXERDEVICE
    // structure, thus fill it in!
    //
    DPFASSERT(pmxobj->dwSig == MIXEROBJECT_SIGNATURE );
    DPFASSERT(pmxobj->pMixerDevice != NULL );
    DPFASSERT(pmxobj->pMixerDevice->dwSig == MIXERDEVICE_SIGNATURE );

    pmxd=pmxobj->pMixerDevice;

    if( pmxd->pfo == NULL )
    {
        DPF(DL_WARNING|FA_NOTE,("fo is NULL, it should have been set!") );
        //
        // We need to assign a SysAudio FILE_OBJECT to this mixer device so that
        // we can talk to it.
        //
        if( NULL==(pmxd->pfo=kmxlOpenSysAudio())) {
            DPF(DL_WARNING|FA_NOTE,("OpenSysAudio failed") );
            return STATUS_UNSUCCESSFUL;
        }

        Status = SetSysAudioProperty(
            pmxd->pfo,
            KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
            sizeof( pmxd->Device ),
            &pmxd->Device
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlCloseSysAudio( pmxd->pfo );
            pmxd->pfo=NULL;
            DPF(DL_WARNING|FA_NOTE,("SetSysAudioProperty failed %X",Status) );
            return Status;
        }
    }

    DPFASSERT(IsValidMixerObject(pmxobj));

    for(pLine = kmxlFirstInList( pmxd->listLines );
        pLine != NULL;
        pLine = kmxlNextLine( pLine )
        )
    {
        DPFASSERT(IsValidLine(pLine));
        for(pControl = kmxlFirstInList( pLine->Controls );
            pControl != NULL;
            pControl = kmxlNextControl( pControl )
                )
        {
            DPFASSERT(IsValidControl(pControl));

            //
            // Enable Notifications if it supports it here.
            //
            DPF(DL_TRACE|FA_NOTE,("pControl->Id=%d, pControl->Control.dwControlID=%d",
                                  pControl->Id,pControl->Control.dwControlID) );

            Status = kmxlEnableControlChangeNotifications(pmxobj,pLine,pControl);

        }
    }
    return Status;
}

VOID 
kmxlCloseMixerDevice(
    IN OUT PMIXERDEVICE pmxd
    )
{
    if(pmxd->pfo)
    {
        kmxlCloseSysAudio( pmxd->pfo );
        pmxd->pfo = NULL;
    }
}





/////////////////////////////////////////////////////////////////////////////
//
// GetHardwareEventData
//
// Called by user mode driver to get the notification information.
//
VOID GetHardwareEventData(LPDEVICEINFO pDeviceInfo)
{
    PAGED_CODE();
    if (emptyindex!=loadindex) {
        (pDeviceInfo->dwID)[0]=callbacks[emptyindex%CALLBACKARRAYSIZE].dwControlID;
        pDeviceInfo->dwLineID=callbacks[emptyindex%CALLBACKARRAYSIZE].dwLineID;
        pDeviceInfo->dwCallbackType=callbacks[emptyindex%CALLBACKARRAYSIZE].dwCallbackType;
        pDeviceInfo->ControlCallbackCount=1;
        emptyindex++;
    }

    pDeviceInfo->mmr=MMSYSERR_NOERROR;

}



///////////////////////////////////////////////////////////////////////
//
// kmxdInit
//
// Checks to see if the mixer lines have been built for the given
// index.  If not, it calls kmxlBuildLines() to build up the lines.
//
// The topology information is kept around so that it can be dumped
// via a debugger command.
//
//

NTSTATUS
kmxlInit(
    IN PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN PMIXERDEVICE pMixer
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hKey;
    ULONG ResultLength;

    PAGED_CODE();
    //
    // Check to see if the lines have already been built for this device.
    // If so, return success.
    //

    if( pMixer->listLines ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // Build the lines for this device.
    //

    Status = kmxlBuildLines(
        pMixer,
        pfo,
        &pMixer->listLines,
        &pMixer->cDestinations,
        &pMixer->Topology
        );

    if( NT_SUCCESS( Status ) ) {

        Status = kmxlOpenInterfaceKey( pfo, pMixer->Device, &hKey );
        if( !NT_SUCCESS( Status ) ) {
            pMixer->Mapping = MIXER_MAPPING_LOGRITHMIC;
            Status = STATUS_SUCCESS;
            goto exit;
        }

        Status = kmxlRegQueryValue( hKey,
            L"CurveType",
            &pMixer->Mapping,
            sizeof( pMixer->Mapping ),
            &ResultLength
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlRegCloseKey( hKey );
            pMixer->Mapping = MIXER_MAPPING_LOGRITHMIC;
            Status = STATUS_SUCCESS;
            goto exit;
        }

        kmxlRegCloseKey( hKey );
    }

exit:
    //
    // Free up the topology allocated when the lines are built (RETAIL only).
    //

    #ifndef DEBUG
    if(pMixer->Topology.Categories) {
        ExFreePool(
            ( (( PKSMULTIPLE_ITEM )
            pMixer->Topology.Categories )) - 1 );
        pMixer->Topology.Categories = NULL;
    }
    if(pMixer->Topology.TopologyNodes) {
        ExFreePool(
        ( (( PKSMULTIPLE_ITEM )
            pMixer->Topology.TopologyNodes )) - 1 );
        pMixer->Topology.TopologyNodes = NULL;
    }
    if(pMixer->Topology.TopologyConnections) {
        ExFreePool(
        ( (( PKSMULTIPLE_ITEM )
            pMixer->Topology.TopologyConnections )) - 1 );
        pMixer->Topology.TopologyConnections = NULL;
    }
    #endif // !DEBUG

    RETURN( Status );
}

////////////////////////////////////////////////////////////////////////
//
// kmxdDeInit
//
// Loops through each of the lines freeing the control structures and
// then the line structures.
//
//

NTSTATUS
kmxlDeInit(
    PMIXERDEVICE pMixer
)
{
    PMXLLINE    pLine    = NULL;
    PMXLCONTROL pControl = NULL;

    PAGED_CODE();

    if( pMixer->Device != UNUSED_DEVICE ) {

        while( pMixer->listLines ) {
            pLine = kmxlRemoveFirstLine( pMixer->listLines );

            while( pLine && pLine->Controls ) {
                pControl = kmxlRemoveFirstControl( pLine->Controls );
                kmxlFreeControl( pControl );
            }

            AudioFreeMemory( sizeof(MXLLINE),&pLine );
        }

        //
        // Here we need to close sysaudio as used in this mixer device.
        //
        kmxlCloseMixerDevice(pMixer);

        ASSERT( pMixer->listLines == NULL );

        //
        // Free up the topology (DEBUG only)
        //

#ifdef DEBUG
        if(pMixer->Topology.Categories) {
            ExFreePool(( (( PKSMULTIPLE_ITEM )
                           pMixer->Topology.Categories )) - 1 );
            pMixer->Topology.Categories = NULL;
        }
        if(pMixer->Topology.TopologyNodes) {
            ExFreePool(( (( PKSMULTIPLE_ITEM )
                           pMixer->Topology.TopologyNodes )) - 1 );
            pMixer->Topology.TopologyNodes = NULL;
        }
        if(pMixer->Topology.TopologyConnections) {
            ExFreePool(( (( PKSMULTIPLE_ITEM )
                           pMixer->Topology.TopologyConnections )) - 1 );
            pMixer->Topology.TopologyConnections = NULL;
        }
#endif // !DEBUG

    } // if

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildLines
//
// Builds up the line structures and count of destinations for the
// given instance.
//
//

NTSTATUS
kmxlBuildLines(
    IN     PMIXERDEVICE pMixer,         // The mixer
    IN     PFILE_OBJECT pfoInstance,    // The FILE_OBJECT of a filter instance
    IN OUT LINELIST*    plistLines,     // Pointer to the list of all lines
    IN OUT PULONG       pcDestinations, // Pointer to the number of dests
    IN OUT PKSTOPOLOGY  pTopology       // Pointer to a topology structure
)
{
    NTSTATUS   Status          = STATUS_SUCCESS;
    MIXEROBJECT mxobj;
    LINELIST   listSourceLines = NULL;
    NODELIST   listSources     = NULL;
    NODELIST   listDests       = NULL;
    PMXLNODE   pTemp           = NULL;
    ULONG      i;

    PAGED_CODE();

    ASSERT( pfoInstance    );
    ASSERT( plistLines     );
    ASSERT( pcDestinations );
    ASSERT( pTopology      );

    RtlZeroMemory( &mxobj, sizeof( MIXEROBJECT ) );

    // Set up the MIXEROBJECT.  Note that this structure is used only within
    // the scope of this function, so it is okay to simply copy the
    // DeviceInterface pointer from the MIXERDEV structure.
    mxobj.pfo       = pfoInstance;
    mxobj.pTopology = pTopology;
    mxobj.pMixerDevice = pMixer;
    mxobj.DeviceInterface = pMixer->DeviceInterface;
#ifdef DEBUG
    mxobj.dwSig = MIXEROBJECT_SIGNATURE;
#endif
    //
    // Read the topology from the device
    //
    DPF(DL_TRACE|FA_MIXER,("Querying Topology") );

    Status = kmxlQueryTopology( mxobj.pfo, mxobj.pTopology );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    //
    // Build up the node table.  The node table is the mixer line's internal
    // representation of the topology for easier processing.
    //
    DPF(DL_TRACE|FA_MIXER,("Building Node Table") );

    mxobj.pNodeTable = kmxlBuildNodeTable( mxobj.pTopology );
    if( !mxobj.pNodeTable ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DPF(DL_WARNING|FA_MIXER,("kmxlBuildNodeTable failed") );
        goto exit;
    }

    //
    // Parse the topology and build the necessary data structures
    // to walk the topology.
    //
    DPF(DL_TRACE|FA_MIXER,("Parsing Topology") );

    Status = kmxlParseTopology(
        &mxobj,
        &listSources,
        &listDests );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_MIXER,("kmxlParseTopoloty failed Status=%X",Status) );
        goto exit;
    }

    //
    // Build up a list of destination lines.
    //
    DPF(DL_TRACE|FA_MIXER,("Building Destination lines") );

    *plistLines = kmxlBuildDestinationLines(
        &mxobj,
        listDests
        );
    if( !(*plistLines) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DPF(DL_WARNING|FA_MIXER,("kmxlBuildDestinationLines failed") );
        goto exit;
    }

    //
    // Assign the line Ids and the Control Ids for the destinations.  Also,
    // fill in the number of destinations.
    //

    kmxlAssignLineAndControlIds( &mxobj, (*plistLines), DESTINATION_LIST );
    *pcDestinations = kmxlListLength( (*plistLines) );

    //
    // Build up a list of source lines
    //
    DPF(DL_TRACE|FA_MIXER,("Building Source lines") );

    listSourceLines = kmxlBuildSourceLines(
        &mxobj,
        listSources,
        listDests
        );
    if( !listSourceLines ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DPF(DL_WARNING|FA_MIXER,("kmxlBuildSourceLines failed") );
        goto exit;
    }

    //
    // Polish off the lines.  First sort them by destination so that
    // the source Ids will be assigned correctly.
    //
    DPF(DL_TRACE|FA_MIXER,("Sort By Destination") );

    kmxlSortByDestination( &listSourceLines );
    DPF(DL_TRACE|FA_MIXER,("Assign Line and Control Ids") );
    kmxlAssignLineAndControlIds( &mxobj, listSourceLines, SOURCE_LIST );

    //
    // Now assign destinations to sources and construct the line Ids for
    // the source lines.
    //
    DPF(DL_TRACE|FA_MIXER,("Assign Destinations to Sources") );

    kmxlAssignDestinationsToSources( listSourceLines, (*plistLines) );

    //
    // Update the number of sources mapping to each of the destinations.
    //
    DPF(DL_TRACE|FA_MIXER,("Update Destination Connection Count") );

    kmxlUpdateDestintationConnectionCount( listSourceLines, (*plistLines) );

    //
    // Assign the dwComponentIds for the source and destination lines.
    //
    DPF(DL_TRACE|FA_MIXER,("Assign Conponent IDs") );

    kmxlAssignComponentIds( &mxobj, listSourceLines, (*plistLines) );

    //
    // Construct a single list of lines.  Destinations will be first in
    // increasing numerical order by line id, folowed by sources in
    // increasing numerical order.
    //

    kmxlAppendListToEndOfList( (PSLIST*) plistLines, (PSLIST) listSourceLines );

    //
    // Eliminate any lines that are invalid.
    //
    DPF(DL_TRACE|FA_MIXER,("Eliminate Invalid Lines") );

    kmxlEliminateInvalidLines( plistLines );

    //
    // Update the mux line IDs to match real line IDs
    //
    DPF(DL_TRACE|FA_MIXER,("Assign Mux IDs") );

    kmxlAssignMuxIds( &mxobj, *plistLines );

    //
    // Here is where we want to Enable Change Notifications on all controls
    // that support notifications.
    //
    DPF(DL_TRACE|FA_MIXER,("Enable All Controls") );

    kmxlEnableAllControls(&mxobj);


exit:

    //
    // If we got here because of an error, clean up all the mixer lines
    //

    if( !NT_SUCCESS( Status ) ) {
        PMXLLINE    pLine;
        PMXLCONTROL pControl;

        while( (*plistLines) ) {
            pLine = kmxlRemoveFirstLine( (*plistLines) );
            while( pLine && pLine->Controls ) {
                pControl = kmxlRemoveFirstControl( pLine->Controls );
                kmxlFreeControl( pControl );
            }
            AudioFreeMemory( sizeof(MXLLINE),&pLine );
        }
    }

    //
    // Free up the mux control list.  Note that we don't want to free
    // the controls using kmxlFreeControl() because we need the special
    // mux instance data to persist.
    //

    {
        PMXLCONTROL pControl;

        while( mxobj.listMuxControls ) {
            pControl = kmxlRemoveFirstControl( mxobj.listMuxControls );
            ASSERT( pControl->pChannelStepping == NULL);
            AudioFreeMemory( sizeof(MXLCONTROL),&pControl );
        }
    }

    //
    // Free up the source and destination lists.  Both types of these lists
    // are allocated list nodes and allocated nodes.  Both need to be freed.
    // The Children and Parent lists, though, are only allocated list nodes.
    // The actual nodes are contained in the node table and will be deallocated
    // in one chunk in the next block of code.
    //

    while( listSources ) {
        pTemp = kmxlRemoveFirstNode( listSources );
        kmxlFreePeerList( pTemp->Children );
        AudioFreeMemory( sizeof(MXLNODE),&pTemp );
    }

    while( listDests ) {
        pTemp = kmxlRemoveFirstNode( listDests );
        kmxlFreePeerList( pTemp->Parents );
        AudioFreeMemory( sizeof(MXLNODE),&pTemp );
    }

    //
    // Free up the peer lists for the children and parents inside the
    // nodes of the node table.  Finally, deallocate the array of nodes.
    //

    if( mxobj.pNodeTable ) {
        for( i = 0; i < mxobj.pTopology->TopologyNodesCount; i++ ) {
            kmxlFreePeerList( mxobj.pNodeTable[ i ].Children );
            kmxlFreePeerList( mxobj.pNodeTable[ i ].Parents );
        }
        AudioFreeMemory_Unknown( &mxobj.pNodeTable );
    }


    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               M I X E R L I N E  F U N C T I O N S                //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildDestinationLines
//
// Loops through each of the destination nodes, allocates a line
// structure for it, and calls kmxlBuildDestinationControls to
// build the controls for that line.
//
//

LINELIST
kmxlBuildDestinationLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listDests     // The list of destination nodes
)
{
    LINELIST    listDestLines = NULL;
    PMXLNODE    pDest         = NULL;
    PMXLLINE    pLine         = NULL;
    PMXLCONTROL pControl      = NULL;
    ULONG       MaxChannelsForLine;

    ASSERT( pmxobj );
    ASSERT( listDests );

    PAGED_CODE();

    //
    // Loop over all the destination node allocating a line structure
    // for each.
    //

    pDest = kmxlFirstInList( listDests );
    while( pDest ) {

        //
        // Allocate a new line structure and add it to the list of
        // destination lines.
        //
        pLine = kmxlAllocateLine( TAG_AudL_LINE );
        if( !pLine ) {
            goto exit;
        }

        kmxlAddToList( listDestLines, pLine );

        //
        // Fill in the details of the line structure.  Some fields will
        // be filled in later.
        //

        pLine->DestId             = pDest->Id;
        pLine->Type               = pDest->NodeType;
        pLine->Communication      = pDest->Communication;
        pLine->Line.cbStruct      = sizeof( MIXERLINE );
        pLine->Line.dwSource      = (DWORD) -1;
        pLine->Line.dwDestination = (DWORD) -1;

        kmxlGetPinName( pmxobj->pfo, pDest->Id, pLine );

        //
        // HACK! The ACTIVE flag should only be set when the line is active
        // but then no lines show up in SNDVOL32.  It works if the flag is
        // always set to ACTIVE for destinations.  Also, the number of channels
        // should be queried not hard coded.  WDM Audio does not provide a
        // way to easily query this.
        //

        pLine->Line.fdwLine       = MIXERLINE_LINEF_ACTIVE;
        pLine->Line.cChannels     = 1;  // should this default to 1 or 2?

        //
        // Build up a list of the controls on this destination
        //

        if( !NT_SUCCESS( kmxlBuildDestinationControls(
                            pmxobj,
                            pDest,
                            pLine
                            ) ) )
        {
            DPF(DL_WARNING|FA_MIXER,("kmxlBuildDestinationControls failed") );
            goto exit;
        }

        pDest = kmxlNextNode( pDest );
    }

    pLine = kmxlFirstInList( listDestLines );
    while( pLine ) {
        MaxChannelsForLine = 1;

        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {
            ASSERT( IsValidControl( pControl ) );
            if ( pControl->NumChannels > MaxChannelsForLine) {
                MaxChannelsForLine = pControl->NumChannels;
            }
            pControl = kmxlNextControl( pControl );
        }

        if( pLine->Controls == NULL ) {
            pLine->Line.cChannels = 1;  // should this default to 1 or 2?
        } else {
            pLine->Line.cChannels = MaxChannelsForLine;
        }

        pLine = kmxlNextLine( pLine );
    }

    return( listDestLines );

exit:

    //
    // A memory allocation failed.  Clean up the destination lines and
    // return failure.
    //

    while( listDestLines ) {
        pLine = kmxlRemoveFirstLine( listDestLines );
        while( pLine && pLine->Controls ) {
            pControl = kmxlRemoveFirstControl( pLine->Controls );
            kmxlFreeControl( pControl );
        }
        AudioFreeMemory_Unknown( &pLine );
    }

    return( NULL );

}

///////////////////////////////////////////////////////////////////////
//
// BuildDestinationControls
//
// Starts at the destination node and translates all the parent nodes
// to mixer line controls.  This process stops when the first SUM node
// is encountered, indicating the end of a destination line.
//
//

NTSTATUS
kmxlBuildDestinationControls(
    IN  PMIXEROBJECT pmxobj,
    IN  PMXLNODE     pDest,         // The destination to built controls for
    IN  PMXLLINE     pLine          // The line to add the controls to
)
{
    PPEERNODE    pTemp  = NULL;
    PMXLCONTROL  pControl;

    PAGED_CODE();

    ASSERT( pmxobj );
    ASSERT( pLine    );

    //
    // Start at the immediate parent of the node passed.
    //

    pTemp = kmxlFirstParentNode( pDest );
    while( pTemp ) {

        if( IsEqualGUID( &pTemp->pNode->NodeType, &KSNODETYPE_SUM ) ||
          ( pTemp->pNode->Type == SOURCE ) ||
      ( pTemp->pNode->Type == DESTINATION ) ) {

            //
            // We've found a SUM node.  Discontinue the loop... we've
            // found all the controls.
            //

            break;
        }

        if( IsEqualGUID( &pTemp->pNode->NodeType, &KSNODETYPE_MUX ) ) {
            if (kmxlTranslateNodeToControl( pmxobj, pTemp->pNode, &pControl )) {
                kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
            }
            break;
        }

        if( ( kmxlParentListLength( pTemp->pNode ) > 1 ) ) {
            //
            // Found a node with multiple parents that is not a SUM node.
            // Can't handle that here so add any controls for this node
            // and discontinue the loop.
            //

            if( kmxlTranslateNodeToControl( pmxobj, pTemp->pNode, &pControl ) ) {
                kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
            }

            break;

        }

        //
        // By going up through the parents and inserting nodes at
        // the front of the list, the list will contain the controls
        // in the right order.
        //

        if( kmxlTranslateNodeToControl( pmxobj, pTemp->pNode, &pControl ) ) {
            kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
        }

        pTemp = kmxlFirstParentNode( pTemp->pNode );
    }

    DPF(DL_TRACE|FA_MIXER,(
        "Found %d controls on destination %d:",
        kmxlListLength( pLine->Controls ),
        pDest->Id
        ) );

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildSourceLines
//
// Loops through each of the source nodes, allocating a new line
// structure, and calling kmxlBuildPath() to build the controls
// for the line (and possibly creating new lines if there are splits
// in the topology).
//
//

LINELIST
kmxlBuildSourceLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listSources,    // The list of source nodes
    IN NODELIST     listDests       // The list of dest. nodes
)
{
    NTSTATUS     Status;
    LINELIST     listSourceLines = NULL;
    PMXLNODE     pSource         = NULL;
    PMXLLINE     pTemp           = NULL;
    PMXLCONTROL  pControl;
    ULONG        MaxChannelsForLine;

    ASSERT( pmxobj             );
    ASSERT( pmxobj->pfo        );
    ASSERT( pmxobj->pNodeTable );
    ASSERT( listSources        );
    ASSERT( listDests          );

    PAGED_CODE();

    pSource = kmxlFirstInList( listSources );
    while( pSource ) {

        //
        // Allocate a new line structure and insert it into the list of
        // source lines.
        //
        pTemp = kmxlAllocateLine( TAG_AudL_LINE );
        if( !pTemp ) {
            goto exit;
        }

        kmxlAddToEndOfList( listSourceLines, pTemp );

        //
        // Fill in the fields of the line structure.  Some fields will need
        // to be filled in later.
        //

        pTemp->SourceId            = pSource->Id;
        pTemp->Type                = pSource->NodeType;
        pTemp->Communication       = pSource->Communication;
        pTemp->Line.cbStruct       = sizeof( MIXERLINE );
        pTemp->Line.dwSource       = (DWORD) -1;
        pTemp->Line.dwDestination  = (DWORD) -1;
        pTemp->Line.fdwLine        = MIXERLINE_LINEF_SOURCE |
                                     MIXERLINE_LINEF_ACTIVE;

        kmxlGetPinName( pmxobj->pfo, pSource->Id, pTemp );

//        DPF(DL_TRACE|FA_MIXER,( "Building path for %s (%d).",
//            PinCategoryToString( &pSource->NodeType ),
//            pSource->Id
//            ) );

        //
        // Build the controls for this line and identify the destination(s)
        // it conntects to.
        //

        Status = kmxlBuildPath(
            pmxobj,
            pSource,            // The source line to build controls for
            pSource,            // The node to start with
            pTemp,              // The line structure to add to
            &listSourceLines,   // The list of all source lines
            listDests           // THe list of all destinations
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_MIXER,("kmxlBuildPath failed Status=%X",Status) );
            goto exit;
        }


        pSource = kmxlNextNode( pSource );
    } // while( pSource )

    pTemp = kmxlFirstInList( listSourceLines );
    while( pTemp ) {
        MaxChannelsForLine = 1;

        pControl = kmxlFirstInList( pTemp->Controls );
        while( pControl ) {
            ASSERT( IsValidControl( pControl ) );
            if ( pControl->NumChannels > MaxChannelsForLine) {
                MaxChannelsForLine = pControl->NumChannels;
            }
            pControl = kmxlNextControl( pControl );
        }

        if( pTemp->Controls == NULL ) {
            pTemp->Line.cChannels = 1;  // should this default to 1 or 2?
        } else {
            pTemp->Line.cChannels = MaxChannelsForLine;
        }

        pTemp = kmxlNextLine( pTemp );
    }

    return( listSourceLines );

exit:

    //
    // Something went wrong.  Clean up all memory allocated and return NULL
    // to indicate the error.
    //

    while( listSourceLines ) {
        pTemp = kmxlRemoveFirstLine( listSourceLines );
        while( pTemp && pTemp->Controls ) {
            pControl = kmxlRemoveFirstControl( pTemp->Controls );
            kmxlFreeControl( pControl );
        }
        AudioFreeMemory_Unknown( &pTemp );
    }

    return( NULL );

}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildPath
//
// Builds the controls for a source line.  A source line ends when a
// SUM node, a destination node, a node contained in a destination line
// is encountered.  When splits are encountered in the topology, new
// lines need to be created and the controls on those lines enumerated.
//
// kmxlBuildPath will recurse to find the controls on subnodes.
//
//

NTSTATUS
kmxlBuildPath(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pSource,      // The source node for this path
    IN     PMXLNODE     pNode,        // The current node in the path
    IN     PMXLLINE     pLine,        // The current line
    IN OUT LINELIST*    plistLines,   // The list of lines build so far
    IN     NODELIST     listDests     // The list of the destinations
)
{
    NTSTATUS    Status;
    PMXLCONTROL pControl  = NULL;
    PMXLLINE    pNewLine  = NULL;
    ULONG       nControls;
    PPEERNODE   pChild    = NULL;

    ASSERT( pmxobj      );
    ASSERT( pSource     );
    ASSERT( pNode       );
    ASSERT( pLine       );
    ASSERT( plistLines  );

    PAGED_CODE();

    DPF(DL_TRACE|FA_MIXER,( "Building path for %d(0x%x) (%s) NODE=%08x",
        pNode->Id,pNode->Id,
        NodeTypeToString( &pNode->NodeType ),
        pNode ) );

    //
    // Check to see if this is the end of this line.
    //


    if( ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUM   ) ) ||
        ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX   ) ) ||
        ( pNode->Type == DESTINATION                       )   ||
        ( kmxlIsDestinationNode( listDests, pNode )        ) )
    {

        //
        // Find the destination node and update the line structure.
        // If this IS the destination node, then set the ID in the line
        // structure and return.  There is no need to check the children,
        // since there won't be any.
        //

        if( pNode->Type == DESTINATION ) {
            pLine->DestId = pNode->Id;
            RETURN( STATUS_SUCCESS );
        }

        //
        // Find the destination node for the source.  It is possible to
        // have branches in the topology, so this may recurse.
        //

        pLine->DestId = kmxlFindDestinationForNode(
            pmxobj,
            pNode,
            pNode,
            pLine,
            plistLines
            );

        RETURN( STATUS_SUCCESS );
    }

    //
    // Retrieve and translate the node for the first child, appending any
    // controls created onto the list of controls for this line.
    //

    pChild = kmxlFirstChildNode( pNode );
    if( pChild == NULL ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // Save the number of controls here.  If a split occurs beneath this
    // node, we don't want to include children followed on the first
    // child's path.
    //

    nControls = kmxlListLength( pLine->Controls );

    if (kmxlTranslateNodeToControl(pmxobj, pChild->pNode, &pControl) ) {

        if( pControl && IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUX ) ) {
            if( kmxlIsDestinationNode( listDests, pChild->pNode ) ) {
                pControl->Parameters.bPlaceholder = TRUE;
            }
        }
        kmxlAppendListToEndOfList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
    }

    //
    // Recurse to build the controls for this child.
    //

    Status = kmxlBuildPath(
            pmxobj,
            pSource,
            pChild->pNode,
            pLine,
            plistLines,
            listDests
            );

    if( !NT_SUCCESS( Status ) ) {
        RETURN( Status );
    }

    //
    // For the rest of the children
    //
    //   Create a new line based on pSource.
    //   Duplicate the list of controls in pLine.
    //   Recurse over the child node.
    //

    pChild = kmxlNextPeerNode( pChild );
    while( pChild ) {
        pNewLine = kmxlAllocateLine( TAG_AudL_LINE );
        if( pNewLine == NULL ) {
            RETURN( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        // Insert this new node into the list of source lines
        //

        RtlCopyMemory( pNewLine, pLine, sizeof( MXLLINE ) );
        pNewLine->List.Next = NULL;
        pNewLine->Controls  = NULL;

        kmxlAddToEndOfList( *plistLines, pNewLine );

        //
        // Since this is a new line, the control structures also need to be
        // duplicated.
        //

        Status = kmxlDuplicateLineControls( pNewLine, pLine, nControls );
        if( !NT_SUCCESS( Status ) ) {
            RETURN( Status );
        }

        //
        // Just as for the first child, translate the node, append the
        // controls to the list of controls for this list, and recurse
        // to build the controls for its children.
        //

        if (kmxlTranslateNodeToControl(
            pmxobj,
            pChild->pNode,
            &pControl ) ) {

            kmxlAppendListToEndOfList( (PSLIST*) &pNewLine->Controls, (PSLIST) pControl );
        }

        Status = kmxlBuildPath(
            pmxobj,
            pSource,
            pChild->pNode,
            pNewLine,
            plistLines,
            listDests
            );
        if( !NT_SUCCESS( Status ) ) {
            RETURN( Status );
        }

        pChild = kmxlNextPeerNode( pChild );
    } // while( pChild )


    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlIsDestinationNode
//
// Searches all the list of controls on the given list of destinations
// to see if the node appears in any of those lists.
//
//

BOOL
kmxlIsDestinationNode(
    IN NODELIST listDests,              // The list of destinations
    IN PMXLNODE pNode                   // The node to check
)
{
    PMXLNODE  pTemp;
    PPEERNODE pParent;

    PAGED_CODE();
    if( pNode->Type == SOURCE ) {
        return( FALSE );
    }

    if( pNode->Type == DESTINATION ) {
        return( TRUE );
    }

    ASSERT(pNode->Type == NODE);

    //
    // Loop over each of the destinations
    //

    pTemp = kmxlFirstInList( listDests );
    while( pTemp ) {

        //
        // Loop over the parent.
        //

        pParent = kmxlFirstParentNode( pTemp );
        while( pParent ) {

            if( ( pParent->pNode->Type == NODE   ) &&
                ( pParent->pNode->Id == pNode->Id) ) {

                return( TRUE );
            }

            if( ( IsEqualGUID( &pParent->pNode->NodeType, &KSNODETYPE_SUM   ) ) ||
                ( IsEqualGUID( &pParent->pNode->NodeType, &KSNODETYPE_MUX   ) ) ||
                ( pParent->pNode->Type == SOURCE                            ) )
            {
                break;
            }

            //
            // Check for the node Ids matching.
            //

            pParent = kmxlFirstParentNode( pParent->pNode );
        }

        pTemp = kmxlNextNode( pTemp );
    }

    return( FALSE );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLine
//
// Duplicates a line and the associated controls.
//
//

NTSTATUS
kmxlDuplicateLine(
    IN PMXLLINE* ppTargetLine,          // Pointer to the new line
    IN PMXLLINE  pSourceLine            // The line to duplicate
)
{
    PAGED_CODE();

    ASSERT( ppTargetLine );
    ASSERT( pSourceLine  );

    DPF(DL_TRACE|FA_MIXER,( "Duplicated line with source=%d.",
            pSourceLine->SourceId ) );

    //
    // Allocate a new line structure and copy the information from the
    // source line.
    //
    *ppTargetLine = kmxlAllocateLine( TAG_AudL_LINE );
    if( *ppTargetLine == NULL ) {
        RETURN( STATUS_INSUFFICIENT_RESOURCES );
    }

    ASSERT( *ppTargetLine );

//    DPF(DL_TRACE|FA_MIXER,( "Duplicated %s (%d).",
//        PinCategoryToString( &pSourceLine->Type ),
//        pSourceLine->SourceId
//        ) );

    RtlCopyMemory( *ppTargetLine, pSourceLine, sizeof( MXLLINE ) );

    //
    // Null out the controls and next pointer.  This line does not have
    // either of its own yet.
    //

    (*ppTargetLine)->List.Next = NULL;
    (*ppTargetLine)->Controls = NULL;

    //
    // Duplicate all the controls for the source line.
    //

    return( kmxlDuplicateLineControls(
        *ppTargetLine,
        pSourceLine,
        kmxlListLength( pSourceLine->Controls )
        )
    );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLineControls
//
// Duplicates the controls for a line by allocating a new control
// structure for each and copying the information to the new node.
//
//

NTSTATUS
kmxlDuplicateLineControls(
    IN PMXLLINE pTargetLine,            // The line to put the controls into
    IN PMXLLINE pSourceLine,            // The line with the controls to dup
    IN ULONG    nCount                  // The number of controls to dup
)
{
    PMXLCONTROL pControl,
                pNewControl;
    NTSTATUS    Status;

    PAGED_CODE();
    ASSERT( pTargetLine->Controls == NULL );

    if( nCount == 0 ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // Iterate over the list allocating and copying the controls
    //

    pControl = kmxlFirstInList( pSourceLine->Controls );
    while( pControl ) {
        ASSERT( IsValidControl( pControl ) );

        //
        // Allocate a new control structure.
        //
        pNewControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( pNewControl == NULL ) {
            goto exit;
        }

        //
        // Copy the entire MXLCONTROL structure and NULL out the
        // List.Next field.  This control will be part of a different
        // list.
        //

        RtlCopyMemory( pNewControl, pControl, sizeof( MXLCONTROL ) );

        pNewControl->List.Next = NULL;
        pNewControl->pChannelStepping = NULL;

        //
        // Copy the channel steppings from the original control
        //

        ASSERT(pControl->NumChannels > 0);

        Status = AudioAllocateMemory_Paged(pNewControl->NumChannels * sizeof( CHANNEL_STEPPING ),
                                           TAG_AuDD_CHANNEL,
                                           DEFAULT_MEMORY,
                                           &pNewControl->pChannelStepping );
        if( !NT_SUCCESS( Status ) ) {
            pNewControl->NumChannels = 0;
            goto exit;
        }

        RtlCopyMemory( pNewControl->pChannelStepping,
                       pControl->pChannelStepping,
                       pNewControl->NumChannels * sizeof( CHANNEL_STEPPING ) );

        //
        // We just made a copy of a MUX node.  Mark the datastructures
        // is has as a copy so it doesn't get freed from underneath
        // somebody else.
        //

        if( IsEqualGUID( pNewControl->NodeType, &KSNODETYPE_MUX ) ) {
            pNewControl->Parameters.bHasCopy = TRUE;
        }

        kmxlAddToList( pTargetLine->Controls, pNewControl );

        //
        // Decrement and check the number of controls copied.  If we copied
        // the requested number, stop.
        //

        --nCount;
        if( nCount == 0 ) {
            break;
        }

        pControl = kmxlNextControl( pControl );
    }
    RETURN( STATUS_SUCCESS );

exit:

    //
    // Failed to allocate the control structure.  Free up all the
    // controls already allocated and return an error.
    //

    while( pTargetLine->Controls ) {
        pControl = kmxlRemoveFirstControl( pTargetLine->Controls );
        kmxlFreeControl( pControl );
    }
    RETURN( STATUS_INSUFFICIENT_RESOURCES );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestinationForNode
//
// Finds a destination for the given node, duplicating lines if splits
// are found in the topology.
//
//

ULONG
kmxlFindDestinationForNode(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pNode,             // The node to find dest for
    IN     PMXLNODE     pParent,           // The original parent
    IN     PMXLLINE     pLine,             // The current line it's on
    IN OUT LINELIST*    plistLines         // The list of all lines
)
{
    PPEERNODE pChild, pPeerChild;
    PMXLLINE  pNewLine;
    PMXLNODE  pShadow = pNode;

    PAGED_CODE();
    DPF(DL_TRACE|FA_MIXER,( "Finding destination for node %d(0x%x) (%s), parent %d(0x%x) (%s).",
            pNode->Id,pNode->Id,
            NodeTypeToString( &pNode->NodeType ),
            pParent->Id,pParent->Id,
            NodeTypeToString( &pNode->NodeType ) ) );

    ASSERT( pmxobj )   ;
    ASSERT( pNode      );
    ASSERT( pParent    );
    ASSERT( pLine      );
    ASSERT( plistLines );

    if( pNode->Type == DESTINATION ) {
        return( pNode->Id );
    }

    //
    // Loop over the first children.
    //

    pChild = kmxlFirstChildNode( pNode );
    while( pChild ) {

            DPF(DL_TRACE|FA_MIXER,( "First child is %d(0x%x) (%s) NODE:%08x.",
                pChild->pNode->Id,
                pChild->pNode->Id,
                NodeTypeToString( &pChild->pNode->NodeType ),
                pChild->pNode ) );

        if( pChild->pNode == pParent ) {
            DPF(DL_TRACE|FA_MIXER,( "Child node is same as original parent!" ) );
            return( INVALID_ID );
        }

        //
        // Loop over the rest of the children.
        //

        pPeerChild = kmxlNextPeerNode( pChild );
        while( pPeerChild ) {

            if( pPeerChild->pNode == pParent ) {
                DPF(DL_TRACE|FA_MIXER,( "Child node is same as original parent!" ) );
                return( INVALID_ID );
            }

            DPF(DL_TRACE|FA_MIXER,( "Peer node of %d(0x%x) (%s) is %d(0x%x) (%s).",
                    pChild->pNode->Id,pChild->pNode->Id,
                    NodeTypeToString( &pChild->pNode->NodeType ),
                    pPeerChild->pNode->Id,pPeerChild->pNode->Id,
                    NodeTypeToString( &pPeerChild->pNode->NodeType ) ) );

            //
            // This line has more than 1 child.  Duplicate this line
            // and add it to the list of lines.
            //

            if( !NT_SUCCESS( kmxlDuplicateLine( &pNewLine, pLine ) ) ) {
                DPF(DL_WARNING|FA_MIXER,("kmxlDuplicateLine failed") );
                continue;
            }
            kmxlAddToEndOfList( *plistLines, pNewLine );

            if( IsEqualGUID( &pPeerChild->pNode->NodeType, &KSNODETYPE_MUX ) ) {

                //
                // We've found a MUX after a SUM or another MUX node.  Mark
                // the current line as invalid and build a new, virtual
                // line that feeds into the MUX.
                //

                pNewLine->DestId = INVALID_ID;
                kmxlBuildVirtualMuxLine(
                    pmxobj,
                    pShadow,
                    pPeerChild->pNode,
                    plistLines
                    );

            } else {

                //
                // Now to find the destination for this new line.  Recurse
                // on the node of this child.
                //

                pNewLine->DestId = kmxlFindDestinationForNode(
                    pmxobj,
                    pPeerChild->pNode,
                    pParent,
                    pNewLine,
                    plistLines
                    );
            }

            DPF(DL_TRACE|FA_MIXER,( "Found %x as dest for %d(0x%x) (%s).",
                    pNewLine->DestId, pPeerChild->pNode->Id,pPeerChild->pNode->Id,
                    NodeTypeToString( &pPeerChild->pNode->NodeType ),
                    pPeerChild->pNode ) );

            pPeerChild = kmxlNextPeerNode( pPeerChild );
        }

        if( IsEqualGUID( &pChild->pNode->NodeType, &KSNODETYPE_MUX ) ) {

                //
                // We've found a MUX after a SUM or another MUX node.  Mark
                // the current line as invalid and build a new, virtual
                // line that feeds into the MUX.
                //

                kmxlBuildVirtualMuxLine(
                    pmxobj,
                    pShadow,
                    pChild->pNode,
                    plistLines
                    );

                return( INVALID_ID );
        }

        //
        // Found the destination!
        //

        if( pChild->pNode->Type == DESTINATION ) {

            DPF(DL_TRACE|FA_MIXER,( "Found %x as dest for %d.",
                    pChild->pNode->Id,
                    pNode->Id ) );

            return( pChild->pNode->Id );
        }

        pShadow = pChild->pNode;
        pChild = kmxlFirstChildNode( pChild->pNode );
    }

    DPF(DL_WARNING|FA_MIXER,("returning INVALID_ID") );
    return( INVALID_ID );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildVirtualMuxLine
//
//

NTSTATUS
kmxlBuildVirtualMuxLine(
    IN PMIXEROBJECT  pmxobj,
    IN PMXLNODE      pParent,
    IN PMXLNODE      pMux,
    IN OUT LINELIST* plistLines
)
{
    PMXLLINE    pLine, pTemp;
    PMXLNODE    pNode;
    PMXLCONTROL pControl;
    MXLCONTROL  Control;

    PAGED_CODE();
    //
    // Allocate a new line to represent the virtual mux input line.
    //

    pLine = kmxlAllocateLine( TAG_AudL_LINE );
    if( pLine == NULL ) {
        RETURN( STATUS_INSUFFICIENT_RESOURCES );
    }

    DPF(DL_TRACE|FA_MIXER,("Virtual line %08x for Parent NODE:%08x",pLine,pParent) );
    //
    // Translate the mux control so that it will appear in this line.
    //

    if (kmxlTranslateNodeToControl(
        pmxobj,
        pMux,
        &pControl
        ) ) {

        pControl->Parameters.bPlaceholder = TRUE;
        kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );

    }

    //
    // Now start searching up from the parent.
    //

    pNode = pParent;
    while( pNode ) {

        //
        // Translate the control.
        //

        if (kmxlTranslateNodeToControl(
            pmxobj,
            pNode,
            &pControl
            ) ) {

            kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );

        }

        //
        // If we found a node with multiple parents, then this will be the
        // "pin" for this line.
        //

        if( ( kmxlParentListLength( pNode ) > 1                ) ||
            ( pNode->Type == SOURCE                            ) ||
            ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX ) ) ||
            ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUM ) ) ) {

            //
            // Check to see if this node has already been used in a virtual
            // line.
            //

            pTemp = kmxlFirstInList( *plistLines );
            while( pTemp ) {

                if( pTemp->SourceId == ( 0x8000 + pNode->Id ) ) {
                    while( pLine->Controls ) {
                        pControl = kmxlRemoveFirstControl( pLine->Controls );
                        kmxlFreeControl( pControl );
                    }
                    AudioFreeMemory_Unknown( &pLine );
                    RETURN( STATUS_SUCCESS );
                }

                pTemp = kmxlNextLine( pTemp );
            }

            //
            // Set up the pin.  The name will be the name of the node.
            //

            pLine->SourceId = 0x8000 + pNode->Id;
            Control.NodeType = &pNode->NodeType;
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, &Control );
            RtlCopyMemory(
                pLine->Line.szShortName,
                Control.Control.szShortName,
                min(
                    sizeof( pLine->Line.szShortName ),
                    sizeof( Control.Control.szShortName )
                    )
                );
            RtlCopyMemory(
                pLine->Line.szName,
                Control.Control.szName,
                min(
                    sizeof( pLine->Line.szName ),
                    sizeof( Control.Control.szName )
                   )
                );
            break;
        }

        pNode = (kmxlFirstParentNode( pNode ))->pNode;
    }

    //
    // By making this line type of "SUM" (which technically it is), it
    // will guarantee that this line gets a target type of UNDEFINED.
    //

    pLine->Type               = KSNODETYPE_SUM;
    pLine->Communication      = KSPIN_COMMUNICATION_NONE;
    pLine->Line.cbStruct      = sizeof( MIXERLINE );
    pLine->Line.dwSource      = (DWORD) -1;
    pLine->Line.dwDestination = (DWORD) -1;
    pLine->Line.fdwLine       = MIXERLINE_LINEF_SOURCE |
                                MIXERLINE_LINEF_ACTIVE;

    kmxlAddToEndOfList( plistLines, pLine );

    pLine->DestId = kmxlFindDestinationForNode(
        pmxobj, pMux, pMux, pLine, plistLines
        );

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlTranslateNodeToControl
//
//
// Translates a NodeType GUID into a mixer line control.  The memory
// for the control(s) is allocated and as much information about the
// control is filled in.
//
// NOTES
//   This function returns the number of controls added to the ppControl
// array.
//
// Returns the number of controls actually created.
//
//

ULONG
kmxlTranslateNodeToControl(
    IN  PMIXEROBJECT  pmxobj,
    IN  PMXLNODE      pNode,            // The node to translate into a control
    OUT PMXLCONTROL*  ppControl         // The control to fill in
)
{
    PMXLCONTROL            pControl;
    NTSTATUS               Status = STATUS_SUCCESS;

    ASSERT( pmxobj      );
    ASSERT( pNode       );
    ASSERT( ppControl   );

    PAGED_CODE();

    //
    // Bug fix.  The caller might not clear this.  This needs to be NULL do
    // the caller doesn't think controls were created when the function
    // fails.
    //

    *ppControl = NULL;

    //
    // If the node is NULL, there's nothing to do.
    //
    if( pNode == NULL ) {
        *ppControl = NULL;
        return( 0 );
    }

    DPF(DL_TRACE|FA_MIXER,( "Translating %d(0x%x) ( %s ) NODE:%08x",
        pNode->Id,pNode->Id,
        NodeTypeToString( &pNode->NodeType ),
        pNode ) );

    ///////////////////////////////////////////////////////////////////
    if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_AGC ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // AGC is represented by an ONOFF control.
    //
    // AGC is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports AGC.
        //

        Status = kmxlSupportsControl( pmxobj->pfo, pNode->Id, KSPROPERTY_AUDIO_AGC );
        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "AGC node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure.
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_AGC;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_AGC;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_ONOFF;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_LOUDNESS ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // LOUNDNESS is represented by an ONOFF-type control.
    //
    // LOUDNESS is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports LOUDNESS.
        //

        Status = kmxlSupportsControl( pmxobj->pfo, pNode->Id, KSPROPERTY_AUDIO_LOUDNESS );
        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Loudness node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_LOUDNESS;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_LOUDNESS;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_LOUDNESS;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUTE ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // MUTE is represented by an ONOFF-type control.
    //
    // MUTE is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports MUTE.
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_MUTE );
        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Mute node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_MUTE;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_MUTE;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_MUTE;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_TONE ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A TONE node can represent up to 3 controls:
    //   Treble:     A fader control
    //   Bass:       A fader control
    //   Bass Boost: A OnOff control
    //
    // Both Treble and Bass are UNIFORM (mono) controls.
    //
    // To determine which control(s) the TONE node represents, a helper
    // function is called to query the particular property.  If the
    // helper function succeeds, a control is created for that property.
    //
    ///////////////////////////////////////////////////////////////////

        Status = kmxlSupportsControl( pmxobj->pfo,
                                      pNode->Id,
                                      KSPROPERTY_AUDIO_BASS_BOOST );
        if (NT_SUCCESS(Status)) {
            //
            // Bass boost control is supported.  Allocate a new structure.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                goto exit;
            }

            //
            // Fill in as much information as possible.
            //

            pControl->NodeType                  = &KSNODETYPE_TONE;
            pControl->Id                        = pNode->Id;
            pControl->PropertyId                = KSPROPERTY_AUDIO_BASS_BOOST;
            pControl->bScaled                   = FALSE;
            pControl->Control.cbStruct          = sizeof( MIXERCONTROL );
            pControl->Control.dwControlType     = MIXERCONTROL_CONTROLTYPE_ONOFF;
            pControl->Control.cMultipleItems    = 0;
            pControl->Control.Bounds.dwMinimum  = 0;
            pControl->Control.Bounds.dwMaximum  = 1;
            pControl->Control.Metrics.cSteps    = 0;

            Status = kmxlGetControlChannels( pmxobj->pfo, pControl );
            if (!NT_SUCCESS(Status))
            {
                kmxlFreeControl( pControl );
                pControl = NULL;
                goto exit;
            }

            kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

            ASSERT( IsValidControl( pControl ) );

            //
            // Add this new control to the list.
            //

            kmxlAddToList( *ppControl, pControl );

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl ) {
                RtlCopyMemory( pControl, *ppControl, sizeof( MXLCONTROL ) );

                //
                // Copy the channel steppings from the original control
                //
                //
                // Sense we copied the control above, we might have gotten
                // a pChannelStepping pointer in the copy.  We'll NULL that out
                // for the memory allocation.
                //
                pControl->pChannelStepping = NULL;

                ASSERT(pControl->NumChannels > 0);
                
                Status = AudioAllocateMemory_Paged(pControl->NumChannels * sizeof( CHANNEL_STEPPING ),
                                                   TAG_AuDC_CHANNEL,
                                                   DEFAULT_MEMORY,
                                                   &pControl->pChannelStepping );
                if( !NT_SUCCESS( Status ) ) {
                    pControl->NumChannels = 0;
                    kmxlFreeControl( pControl );
                    pControl = NULL;
                    goto exit;
                }

                RtlCopyMemory( pControl->pChannelStepping,
                               (*ppControl)->pChannelStepping,
                               pControl->NumChannels * sizeof( CHANNEL_STEPPING ) );

                pControl->Control.dwControlType = MIXERCONTROL_CONTROLTYPE_BASS_BOOST;

                kmxlAddToList( *ppControl, pControl );
                ASSERT( IsValidControl( pControl ) );
            }

        }

        Status = kmxlSupportsBassControl( pmxobj->pfo, pNode->Id );
        if (NT_SUCCESS(Status)) {
            //
            // Bass control is supported.  Allocate a new structure.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                goto exit;
            }

            //
            // Fill in as much information as possible.
            //

            pControl->NodeType                  = &KSNODETYPE_TONE;
            pControl->Id                        = pNode->Id;
            pControl->PropertyId                = KSPROPERTY_AUDIO_BASS;
            pControl->bScaled                   = TRUE;
            pControl->Control.cbStruct          = sizeof( MIXERCONTROL );
            pControl->Control.dwControlType     = MIXERCONTROL_CONTROLTYPE_BASS;
            pControl->Control.fdwControl        = MIXERCONTROL_CONTROLF_UNIFORM;
            pControl->Control.cMultipleItems    = 0;
            pControl->Control.Bounds.dwMinimum  = DEFAULT_STATICBOUNDS_MIN;
            pControl->Control.Bounds.dwMaximum  = DEFAULT_STATICBOUNDS_MAX;
            pControl->Control.Metrics.cSteps    = DEFAULT_STATICMETRICS_CSTEPS;

            Status = kmxlGetControlRange( pmxobj->pfo, pControl );
            if (!NT_SUCCESS(Status))
            {
                kmxlFreeControl( pControl );
                pControl = NULL;
                goto exit;
            } else {

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

                //
                // Add this new control to the list.
                //

                ASSERT( IsValidControl( pControl ) );

                kmxlAddToList( *ppControl, pControl );
            }
        }

        Status = kmxlSupportsTrebleControl( pmxobj->pfo, pNode->Id );
        if (NT_SUCCESS(Status)) {
            //
            // Treble is supported.  Allocate a new control structure.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                goto exit;
            }

            //
            // Fill in as much information as possible.
            //

            pControl->NodeType                  = &KSNODETYPE_TONE;
            pControl->Id                        = pNode->Id;
            pControl->PropertyId                = KSPROPERTY_AUDIO_TREBLE;
            pControl->bScaled                   = TRUE;
            pControl->Control.cbStruct          = sizeof( MIXERCONTROL );
            pControl->Control.dwControlType     = MIXERCONTROL_CONTROLTYPE_TREBLE;
            pControl->Control.fdwControl        = MIXERCONTROL_CONTROLF_UNIFORM;
            pControl->Control.cMultipleItems    = 0;
            pControl->Control.Bounds.dwMinimum  = DEFAULT_STATICBOUNDS_MIN;
            pControl->Control.Bounds.dwMaximum  = DEFAULT_STATICBOUNDS_MAX;
            pControl->Control.Metrics.cSteps    = DEFAULT_STATICMETRICS_CSTEPS;

            Status = kmxlGetControlRange( pmxobj->pfo, pControl );
            if (!NT_SUCCESS(Status))
            {
                kmxlFreeControl( pControl );
                pControl = NULL;
                goto exit;
            } else {

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

                //
                // Add this new control to the list.
                //

                ASSERT( IsValidControl( pControl ) );

                kmxlAddToList( *ppControl, pControl );
            }
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_VOLUME ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A VOLUME is a fader-type control
    //
    // To determine if a node supports volume changes
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports volume
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_VOLUMELEVEL
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Volume node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_VOLUME;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_VOLUMELEVEL;
        (*ppControl)->bScaled                  = TRUE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_VOLUME;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        (*ppControl)->Control.cMultipleItems   = 0;

        Status = kmxlGetControlRange( pmxobj->pfo, (*ppControl) );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

        ASSERT( IsValidControl( *ppControl ) );

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_PEAKMETER ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // To determine if a node supports peak meter properties
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports peakmeter
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_PEAKMETER
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Peakmeter node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_PEAKMETER;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_PEAKMETER;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_PEAKMETER;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        (*ppControl)->Control.cMultipleItems   = 0;

        Status = kmxlGetControlRange( pmxobj->pfo, (*ppControl) );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

        ASSERT( IsValidControl( *ppControl ) );

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A MUX is a single select type control.
    //
    ///////////////////////////////////////////////////////////////////

    {
        ULONG Line;

        //
        // Do a quick check and see if the mux responds properly.
        // If not, just get out of here quick.
        //

        if( !NT_SUCCESS( kmxlGetNodeProperty(
            pmxobj->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MUX_SOURCE,
            pNode->Id,
            0,
            NULL,
            &Line,
            sizeof( Line ) ) ) )
        {
            goto exit;
        }

        //
        // Look to see if a control has already been generated for this
        // node.  If so, the control information can be used from it
        // instead of creating a new one.
        //

        pControl = kmxlFirstInList( pmxobj->listMuxControls );
        while( pControl ) {
            ASSERT( IsValidControl( pControl ) );

            if( pControl->Id == pNode->Id ) {
                break;
            }

            pControl = kmxlNextControl( pControl );
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        if( pControl == NULL ) {

            //
            // This node has not been seen before.  Fill in as much info as
            // possible.
            //

            (*ppControl)->NodeType                 = &KSNODETYPE_MUX;
            (*ppControl)->Id                       = pNode->Id;
            (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_MUX_SOURCE;
            (*ppControl)->bScaled                  = FALSE;
            (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
            (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_MUX;
            (*ppControl)->Control.cMultipleItems   = kmxlGetNumMuxLines(
                                                        pmxobj->pTopology,
                                                        pNode->Id
                                                        );
            (*ppControl)->Control.fdwControl       = MIXERCONTROL_CONTROLF_MULTIPLE |
                                                     MIXERCONTROL_CONTROLF_UNIFORM;
            (*ppControl)->Control.Bounds.dwMinimum = 0;
            (*ppControl)->Control.Bounds.dwMaximum = (*ppControl)->Control.cMultipleItems - 1;
            (*ppControl)->Control.Metrics.cSteps   = (*ppControl)->Control.cMultipleItems;

            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));
            kmxlGetMuxLineNames( pmxobj, *ppControl );


            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                kmxlFreeControl( *ppControl );
                *ppControl = NULL;
                goto exit;
            }

            //
            // Make a copy of this control for the mux list
            //

            (*ppControl)->Control.dwControlID = pmxobj->dwControlId++;
            RtlCopyMemory( pControl, *ppControl, sizeof( MXLCONTROL ) );
            ASSERT( IsValidControl( pControl ) );
            pControl->Parameters.bHasCopy = TRUE;
            (*ppControl)->Parameters.bHasCopy = FALSE;
            kmxlAddToList( pmxobj->listMuxControls, pControl );

        } else {

            RtlCopyMemory( *ppControl, pControl, sizeof( MXLCONTROL ) );
            ASSERT( IsValidControl( *ppControl ) );
            (*ppControl)->Parameters.bHasCopy = TRUE;
            (*ppControl)->List.Next = NULL;

        }
    }

#ifdef STEREO_ENHANCE
    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_STEREO_WIDE ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // Stereo Enhance is a boolean control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports stereo wide
        //

        Status = kmxlSupportsControl(
            pfoInstance,
            pNode->Id,
            KSPROPERTY_AUDIO_WIDE_MODE
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Stereo Wide node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_STEREO_ENHANCE;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_WIDE_MODE;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_STEREOENH;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pfoInstance, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pfoInstance, pNode->Id, (*ppControl));
#endif

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_STEREO_WIDE ) ) {
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports stereo wide
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_WIDENESS
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Stereo wide node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_STEREO_WIDE;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_WIDENESS;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_FADER;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;

        Status = kmxlGetControlRange( pmxobj->pfo, (*ppControl) );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

        ASSERT( IsValidControl( *ppControl ) );

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_CHORUS ) ) {
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports chorus
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_CHORUS_LEVEL
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Chorus node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_CHORUS;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_CHORUS_LEVEL;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_FADER;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        // (*ppControl)->Control.Metrics.cSteps   = 0xFFFF;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );  // Should we also get the range?
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_REVERB ) ) {
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports reverb
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_REVERB_LEVEL
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Reverb node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_REVERB;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_REVERB_LEVEL;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_FADER;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        // (*ppControl)->Control.Metrics.cSteps   = 0xFFFF;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );  // Should we also get the range?
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUPERMIX ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // SuperMix nodes can be supported as MUTE controls if the MUTE
    // property is supported.
    //
    ///////////////////////////////////////////////////////////////////

        PKSAUDIO_MIXCAP_TABLE pMixCaps;
        PLONG                pReferenceCount = NULL;
        ULONG                 i,
                              Size;
        BOOL                  bMutable;
        BOOL                  bVolume = FALSE;
        PKSAUDIO_MIXLEVEL     pMixLevels = NULL;
        #ifdef SUPERMIX_AS_VOL
        ULONG                 Channels;
        #endif

        if( !NT_SUCCESS( kmxlGetSuperMixCaps( pmxobj->pfo, pNode->Id, &pMixCaps ) ) ) {
            goto exit;
        }

        Status = AudioAllocateMemory_Paged(sizeof( LONG ),
                                           TAG_AudS_SUPERMIX,
                                           ZERO_FILL_MEMORY,
                                           &pReferenceCount );
        if( !NT_SUCCESS( Status ) ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            *ppControl = NULL;
            goto exit;
        }
        *pReferenceCount=0;

        Size = pMixCaps->InputChannels * pMixCaps->OutputChannels;

        Status = AudioAllocateMemory_Paged(Size * sizeof( KSAUDIO_MIXLEVEL ),
                                           TAG_Audl_MIXLEVEL,
                                           ZERO_FILL_MEMORY,
                                           &pMixLevels );
        if( !NT_SUCCESS( Status ) ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            *ppControl = NULL;
            goto exit;
        }

        Status = kmxlGetNodeProperty(
            pmxobj->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pNode->Id,
            0,
            NULL,
            pMixLevels,
            Size * sizeof( KSAUDIO_MIXLEVEL )
            );
        if( !NT_SUCCESS( Status ) ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            AudioFreeMemory_Unknown( &pMixLevels );
            DPF(DL_WARNING|FA_MIXER,("kmxlGetNodeProperty failed Status=%X",Status) );
            *ppControl = NULL;
            goto exit;
        }

        bMutable = TRUE;
        for( i = 0; i < Size; i++ ) {

            //
            // If the channel is mutable, then all is well for this entry.
            //

            if( pMixCaps->Capabilities[ i ].Mute ) {
                continue;
            }

            //
            // The the entry is not mutable but is fully attenuated,
            // this will work too.
            //

            if( ( pMixCaps->Capabilities[ i ].Minimum == LONG_MIN ) &&
                ( pMixCaps->Capabilities[ i ].Maximum == LONG_MIN ) &&
                ( pMixCaps->Capabilities[ i ].Reset   == LONG_MIN ) )
            {
                continue;
            }

            bMutable = FALSE;
            break;
        }

        #ifdef SUPERMIX_AS_VOL

        bVolume = TRUE;
        Channels = 0;
        for( i = 0; i < Size; i += pMixCaps->OutputChannels + 1 ) {

            if( ( pMixCaps->Capabilities[ i ].Maximum -
                  pMixCaps->Capabilities[ i ].Minimum ) > 0 )
            {
                ++Channels;
                continue;
            }

            bVolume = FALSE;
            break;
        }
        #endif
        //
        // This node cannot be used as a MUTE control.
        //

        if( !bMutable && !bVolume ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            AudioFreeMemory_Unknown( &pMixLevels );
            *ppControl = NULL;
            goto exit;
        }

        if( bMutable ) {

            //
            // The Supermix is verifiably usable as a MUTE.  Fill in all the
            // details.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );

            if( pControl != NULL ) {

                pControl->NodeType                 = &KSNODETYPE_SUPERMIX;
                pControl->Id                       = pNode->Id;
                pControl->PropertyId               = KSPROPERTY_AUDIO_MIX_LEVEL_TABLE;
                pControl->bScaled                  = FALSE;
                pControl->Control.cbStruct         = sizeof( MIXERCONTROL );
                pControl->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_MUTE;
                pControl->Control.fdwControl       = MIXERCONTROL_CONTROLF_UNIFORM;
                pControl->Control.cMultipleItems   = 0;
                pControl->Control.Bounds.dwMinimum = 0;
                pControl->Control.Bounds.dwMaximum = 1;
                pControl->Control.Metrics.cSteps   = 0;

                InterlockedIncrement(pReferenceCount);
                pControl->Parameters.pReferenceCount = pReferenceCount;
                pControl->Parameters.Size          = pMixCaps->InputChannels *
                                                     pMixCaps->OutputChannels;
                pControl->Parameters.pMixCaps      = pMixCaps;
                pControl->Parameters.pMixLevels    = pMixLevels;

                Status = AudioAllocateMemory_Paged(sizeof( CHANNEL_STEPPING ),
                                                   TAG_AuDE_CHANNEL,
                                                   ZERO_FILL_MEMORY,
                                                   &pControl->pChannelStepping );
                if( !NT_SUCCESS( Status ) ) {
                    AudioFreeMemory_Unknown( &pMixCaps );
                    AudioFreeMemory( sizeof(LONG),&pReferenceCount );
                    AudioFreeMemory_Unknown( &pMixLevels );
                    *ppControl = NULL;
                    goto exit;
                }

                pControl->NumChannels                       = 1;
                pControl->pChannelStepping->MinValue        = pMixCaps->Capabilities[ 0 ].Minimum;
                pControl->pChannelStepping->MaxValue        = pMixCaps->Capabilities[ 0 ].Maximum;
                pControl->pChannelStepping->Steps           = 32;

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

                kmxlAddToList( *ppControl, pControl );
                ASSERT( IsValidControl( pControl ) );
            }
        }

        #ifdef SUPERMIX_AS_VOL
        if( bVolume ) {

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl != NULL ) {

                pControl->NodeType                 = &KSNODETYPE_SUPERMIX;
                pControl->Id                       = pNode->Id;
                pControl->PropertyId               = KSPROPERTY_AUDIO_MIX_LEVEL_TABLE;
                pControl->bScaled                  = TRUE;
                pControl->Control.cbStruct         = sizeof( MIXERCONTROL );
                pControl->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_VOLUME;
                pControl->Control.cMultipleItems   = 0;
                pControl->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
                pControl->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
                pControl->Control.Metrics.cSteps   = 32;

                InterlockedIncrement(pReferenceCount);
                pControl->Parameters.pReferenceCount = pReferenceCount;
                pControl->Parameters.Size          = pMixCaps->InputChannels *
                                                     pMixCaps->OutputChannels;
                pControl->Parameters.pMixCaps      = pMixCaps;
                pControl->Parameters.pMixLevels    = pMixLevels;

                if( Channels == 1 ) {
                    pControl->Control.fdwControl = MIXERCONTROL_CONTROLF_UNIFORM;
                } else {
                    pControl->Control.fdwControl = 0;
                }

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl );

                kmxlAddToList( *ppControl, pControl );
                ASSERT( IsValidControl( pControl ) );

            }

        }
        #endif // SUPERMIX_AS_VOL

        if( *ppControl == NULL ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            AudioFreeMemory_Unknown( &pMixLevels );
        }
    }

exit:

    if( *ppControl ) {
        DPF(DL_TRACE|FA_MIXER,( "Translated %d controls.", kmxlListLength( *ppControl ) ) );
        return( kmxlListLength( *ppControl ) );
    } else {
        DPF(DL_TRACE|FA_MIXER,( "Translated no controls." ) );
        return( 0 );
    }
}

#define KsAudioPropertyToString( Property )                 \
    Property == KSPROPERTY_AUDIO_VOLUMELEVEL ? "Volume"   : \
    Property == KSPROPERTY_AUDIO_MUTE        ? "Mute"     : \
    Property == KSPROPERTY_AUDIO_BASS        ? "Bass"     : \
    Property == KSPROPERTY_AUDIO_TREBLE      ? "Treble"   : \
    Property == KSPROPERTY_AUDIO_AGC         ? "AGC"      : \
    Property == KSPROPERTY_AUDIO_LOUDNESS    ? "Loudness" : \
    Property == KSPROPERTY_AUDIO_PEAKMETER   ? "Peakmeter" : \
        "Unknown"

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsControl
//
// Queries for property on control to see if it is actually supported
//
//

NTSTATUS
kmxlSupportsControl(
    IN PFILE_OBJECT pfoInstance,    // The instance to check for
    IN ULONG        Node,           // The node id to query
    IN ULONG        Property        // The property to check for
)
{
    NTSTATUS      Status;
    LONG          Level;

    ASSERT( pfoInstance );

    PAGED_CODE();

    //
    // Check to see if the property works on the first channel.
    //
    Status = kmxlGetAudioNodeProperty(
        pfoInstance,
        Property,
        Node,
        0, // Channel 0 - first channel
        NULL, 0,
        &Level, sizeof( Level )
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_MIXER,( "SupportsControl for (%d,%X) failed on first channel with %x.",
                Node, Property, Status ) );
    }

    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsMultiChannelControl
//
// Queries for property on the second channel of the control to see
// independent levels can be set.  It is assumed that the first channel
// already succeeded in kmxlSupportsControl
//
//

NTSTATUS
kmxlSupportsMultiChannelControl(
    IN PFILE_OBJECT pfoInstance,    // The instance to check for
    IN ULONG        Node,           // The node id to query
    IN ULONG        Property        // The property to check for
)
{
    NTSTATUS                  Status;
    LONG                      Level;

    ASSERT( pfoInstance );

    PAGED_CODE();

    //
    // Just check the property on the second channel because we have already checked
    // the first channel already.
    //
    Status = kmxlGetAudioNodeProperty(
        pfoInstance,
        Property,
        Node,
        1, // Second channel equals a channel value of 1
        NULL, 0,
        &Level, sizeof( Level )
        );

    RETURN( Status );
}


NTSTATUS
kmxlAssignLineAndControlIdsWorker(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST listLines,              // The list to assign ids for
    IN ULONG    ListType,                // LIST_SOURCE or LIST_DESTINATION
    IN OUT ULONG *pLineID,
    IN GUID *pDestGuid
)
{
    NTSTATUS    Status    = STATUS_SUCCESS;
    PMXLLINE    pLine     = NULL;
    PMXLCONTROL pControl  = NULL;
    ULONG       LineID    = 0;
    ULONG       Dest;

    PAGED_CODE();
    ASSERT ( ListType==SOURCE_LIST || ListType==DESTINATION_LIST );

    if (pLineID!=NULL) {
        LineID=*pLineID;
        }

    //
    // Loop through each of the line structures
    //

    pLine = kmxlFirstInList( listLines );
    if( pLine == NULL ) {
        RETURN( Status );
    }

    Dest = pLine->DestId;
    while( pLine ) {

        //
        // For destinations, set the dwDestination field and set
        // the dwSource field for sources.
        //

        if( ListType == DESTINATION_LIST ) {

            // Check if this line has already been assigned an ID.
            // If so, then go to next line in list.
            if (pLine->Line.dwDestination!=(DWORD)(-1)) {
                pLine = kmxlNextLine( pLine );
                continue;
                }

            // Now if we can only number lines of a particular GUID,
            // then make sure this destination line type matches that guid.
            if (pDestGuid!=NULL && !IsEqualGUID( pDestGuid, &pLine->Type )) {
                pLine = kmxlNextLine( pLine );
                continue;
                }


            //
            // Assign the destination Id.  Create the line Id by
            // using -1 for the source in the highword and the
            // destination in the loword.
            //

            pLine->Line.dwDestination = LineID++;
            pLine->Line.dwLineID = MAKELONG(
                pLine->Line.dwDestination,
                -1
                );

            if (pLineID!=NULL) {
                *pLineID=LineID;
                }

        } else if( ListType == SOURCE_LIST ) {
            pLine->Line.dwSource = LineID++;
        } else {
            RETURN( STATUS_INVALID_PARAMETER );
        }

        //
        // Set up the number of controls on this line.
        //

        pLine->Line.cControls = kmxlListLength( pLine->Controls );

        //
        // Loop through the controls, assigning them a control ID
        // that is a pointer to the MXLCONTROL structure for that
        // control.
        //

        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {

            if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
                //
                // MUX controls are already numbered by this point.  Just skip
                // it and go onto the next one.
                //
                pControl = kmxlNextControl( pControl );
                continue;
            }

            pControl->Control.dwControlID = pmxobj->dwControlId++;
            pControl = kmxlNextControl( pControl );
        }

        pLine = kmxlNextLine( pLine );
        if( pLine == NULL ) {
            continue;
        }
        if( ( ListType == SOURCE_LIST ) && ( pLine->DestId != Dest ) ) {
            LineID = 0;
            Dest = pLine->DestId;
        }
    }

    RETURN( Status );
}



#define GUIDCOUNT 13

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignLineAndControlIds
//
// Loops through the list of lines and assigns ids for those line.
// For destinations, the Id starts a 0 and is incremented each time.
// The line id is a long of -1 and the dest id.  For sources, the
// line Ids will need to be specified elsewhere so only dwSource
// field is assigned.
//
// For controls, each control is given an Id of the address to the
// MXLCONTROL structure.
//
//

NTSTATUS
kmxlAssignLineAndControlIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST listLines,              // The list to assign ids for
    IN ULONG    ListType                // LIST_SOURCE or LIST_DESTINATION
)

{


    PAGED_CODE();
ASSERT ( ListType==SOURCE_LIST || ListType==DESTINATION_LIST );

if (SOURCE_LIST==ListType) {

    return( kmxlAssignLineAndControlIdsWorker(pmxobj, listLines, ListType, NULL, NULL) );

    }

else if (DESTINATION_LIST==ListType) {

    // In order to help sndvol32 do the right thing as far as which
    // lines displayed as the default playback and record lines, we
    // number lines based on what their destinations are.

    // We use guid the pLine->Type field to decide how to number lines.
    // Lines are prioritized in the following way: speakers, then
    // headphones, then telephones.  Non prioritized guids are assigned
    // last in whatever order they appear in the list.

    ULONG LineID=0;
    ULONG i;

    GUID prioritizeddestinationguids[GUIDCOUNT]= {
        STATIC_KSNODETYPE_ROOM_SPEAKER,
        STATIC_KSNODETYPE_DESKTOP_SPEAKER,
        STATIC_KSNODETYPE_SPEAKER,
        STATIC_KSNODETYPE_COMMUNICATION_SPEAKER,
        STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO,
        STATIC_KSNODETYPE_ANALOG_CONNECTOR,
        STATIC_KSNODETYPE_SPDIF_INTERFACE,
        STATIC_KSNODETYPE_HEADPHONES,
        STATIC_KSNODETYPE_TELEPHONE,
        STATIC_KSNODETYPE_PHONE_LINE,
        STATIC_KSNODETYPE_DOWN_LINE_PHONE,
        STATIC_PINNAME_CAPTURE,
        STATIC_KSCATEGORY_AUDIO,
        };

    // Cycle through the list for each prioritized guid and number
    // those lines that match that particular guid.
    for (i=0; i<GUIDCOUNT; i++) {

        kmxlAssignLineAndControlIdsWorker(pmxobj, listLines, ListType,
            &LineID, &prioritizeddestinationguids[i]);

        }

    // Now, number anything left over with a number that depends solely on
    // its random order in the list.

    return( kmxlAssignLineAndControlIdsWorker(pmxobj, listLines, ListType, &LineID, NULL) );

    }
else {
    RETURN( STATUS_INVALID_PARAMETER );
    }

}


///////////////////////////////////////////////////////////////////////
//
// kmxlAssignDestinationsToSources
//
// Loops through each source looking for a destination lines that
// have a matching destination id.  Source line Ids are assigned
// by putting the source id in the hiword and the dest id in the
// loword.
//
//

NTSTATUS
kmxlAssignDestinationsToSources(
    IN LINELIST listSourceLines,        // The list of all source lines
    IN LINELIST listDestLines           // The list of all dest lines
)
{
    PMXLLINE pSource = NULL,
             pDest   = NULL;

    PAGED_CODE();
    //
    // For each source line, loop throught the destinations until a
    // line is found matching the Id.  The dwDestination field will
    // be the zero-index Id of the destination.
    //

    pSource = kmxlFirstInList( listSourceLines );
    while( pSource ) {

        pDest = kmxlFirstInList( listDestLines );
        while( pDest ) {

            if( pSource->DestId == pDest->DestId ) {
                //
                // Heh, whatchya know?
                //
                pSource->Line.dwDestination = pDest->Line.dwDestination;
                pSource->Line.dwLineID = MAKELONG(
                    (WORD) pSource->Line.dwDestination,
                    (WORD) pSource->Line.dwSource
                    );
                break;
            }
            pDest = kmxlNextLine( pDest );
        }
        pSource = kmxlNextLine( pSource );
    }

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlUpdateDestinationConnectionCount
//
// For each of the destinations, loop through each of the sources
// and find those that connect to this destination.  That count is
// then stored in the MIXERLINE.cConnections for the line.
//
//

NTSTATUS
kmxlUpdateDestintationConnectionCount(
    IN LINELIST listSourceLines,    // The list of source lines
    IN LINELIST listDestLines       // The list of destination lines
)
{
    PMXLLINE pDest,
             pSource;
    ULONG    Count;

    PAGED_CODE();
    //
    // Loop through each destination finding all the sources that connect
    // to it.  The total number of sources connecting to a destination
    // is sourced in the cConnections field of the MIXERLINE struct.
    //

    pDest = kmxlFirstInList( listDestLines );
    while( pDest ) {

        //
        // Initialize the source ID.  This will mark this as a valid
        // destination.
        //

        pDest->SourceId = (ULONG) -1;

        Count = 0;

        //
        // Loop through the sources looking for sources that connect to
        // the current destination.
        //

        pSource = kmxlFirstInList( listSourceLines );
        while( pSource ) {

            //
            // Found a match.  Increment the count.
            //

            if( pSource->DestId == pDest->DestId ) {
                ++Count;
            }

            pSource = kmxlNextLine( pSource );
        }

        pDest->Line.cConnections = Count;
        pDest = kmxlNextLine( pDest );
    }

    RETURN( STATUS_SUCCESS );
}

VOID
CleanupLine(
    PMXLLINE pLine
    )
{
    PMXLCONTROL pControl;

    while( pLine->Controls ) {
        pControl = kmxlRemoveFirstControl( pLine->Controls );
        kmxlFreeControl( pControl );
    }
    AudioFreeMemory( sizeof(MXLLINE),&pLine );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlEliminateInvalidLines
//
// Loops through the lines removing lines that are invalid.  Refer
// to the function for IsValidLine() for details on what is an invalid
// line.
//
//

NTSTATUS
kmxlEliminateInvalidLines(
    IN LINELIST* listLines               // The list of lines
)
{
    PMXLLINE    pLine, pTemp, pShadow;

    PAGED_CODE();
    //
    // Eliminate all invalid lines at the start of the list.
    //

    pLine = kmxlFirstInList( *listLines );
    while( pLine ) {

        //
        // Found the first valid line.  Break out of this loop.
        //

        if( Is_Valid_Line( pLine ) ) {
            break;
        }

        //
        // This is an invalid line.  Remove it from the list, free up
        // all its control structures, and free the line structure.
        //

        pTemp = kmxlRemoveFirstLine( pLine );
        CleanupLine(pTemp);
    }

    //
    // Assign listLines to point to the first valid line.
    //

    *listLines = pLine;

    if( pLine == NULL ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // At this point, pLine is a valid line.  Keeping a hold on the prev
    // line, loop through the lines eliminating the invalid ones.
    //

    pShadow = pLine;
    while( pShadow && kmxlNextLine( pShadow ) ) {

        pLine = kmxlNextLine( pShadow );

        if( pLine && !Is_Valid_Line( pLine ) ) {

            //
            // Remove the invalid line from the list
            //

            pShadow->List.Next = pLine->List.Next;
            pLine->List.Next   = NULL;

            CleanupLine(pLine);

            continue;
        }
        pShadow = kmxlNextLine( pShadow );
    }


    // All the invalid lines have been eliminated.  Now eliminate bad
    // duplicates.

    pShadow = kmxlFirstInList( *listLines );
    while( pShadow ) {

        //
        // Walk all the lines looking for a match.
        //
        pLine = kmxlNextLine( pShadow );
        pTemp = NULL;
        while( pLine ) {
        
            if( ( pShadow->SourceId == pLine->SourceId ) &&
                ( pShadow->DestId   == pLine->DestId   ) )
            {
                DPF(DL_TRACE|FA_MIXER,( "Line %x is equal to line %x!",
                    pShadow->Line.dwLineID,
                    pLine->Line.dwLineID
                    ) );
                //
                // Found a match.
                //
                if( pTemp == NULL )
                {
                    //
                    // pShadow is our previous line.  Remove this line from the 
                    // list.
                    //
                    pShadow->List.Next = pLine->List.Next;
                    pLine->List.Next   = NULL;

                    CleanupLine(pLine);

                    //
                    // Now adjust pLine to the next line and loop
                    //
                    pLine = kmxlNextLine( pShadow );
                    continue;
                } else {
                    //
                    // pTemp is our previous line.  Remove this line from the
                    // list.
                    //
                    pTemp->List.Next = pLine->List.Next;
                    pLine->List.Next   = NULL;

                    CleanupLine(pLine);

                    //
                    // Now adjust pLine to the next line and loop
                    //
                    pLine = kmxlNextLine( pTemp );
                    continue;
                }
            }
            pTemp = pLine;  //temp is previous line
            pLine = kmxlNextLine( pLine );
        }

        pShadow = kmxlNextLine( pShadow );
    }

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignComponentIds
//
// Loops through all the destinations then the sources and determines
// their component type and target types.
//
//

VOID
kmxlAssignComponentIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST     listSourceLines,
    IN LINELIST     listDestLines
)
{
    PMXLLINE pLine;

    PAGED_CODE();
    //
    // Loop through the destinations...
    //

    pLine = kmxlFirstInList( listDestLines );
    while( pLine ) {
        pLine->Line.dwComponentType = kmxlDetermineDestinationType(
            pmxobj,
            pLine
            );
        pLine = kmxlNextLine( pLine );
    }

    //
    // Loop through the sources...
    //

    pLine = kmxlFirstInList( listSourceLines );
    while( pLine ) {
        pLine->Line.dwComponentType = kmxlDetermineSourceType(
            pmxobj,
            pLine
            );
        pLine = kmxlNextLine( pLine );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlUpdateMuxLines
//
// Updates the name, line ID, and componenttype of a line that has
// a mux control on it.  The MixerControlDetails array is searched for
// an entry that has a matching source id and replaced with the info
// from this line.
//
//

VOID
kmxlUpdateMuxLines(
    IN PMXLLINE    pLine,
    IN PMXLCONTROL pControl
)
{
    ULONG i;

    PAGED_CODE();
    for( i = 0; i < pControl->Parameters.Count; i++ ) {

        if( ( pLine->SourceId == pControl->Parameters.lpmcd_lt[ i ].dwParam1 ) &&
            ( pControl->Parameters.lpmcd_lt[ i ].dwParam2 == (DWORD) -1 ) )
        {

            wcscpy(
                pControl->Parameters.lpmcd_lt[ i ].szName,
                pLine->Line.szName
                );
            pControl->Parameters.lpmcd_lt[ i ].dwParam1 =
                pLine->Line.dwLineID;
            pControl->Parameters.lpmcd_lt[ i ].dwParam2 =
                pLine->Line.dwComponentType;
        }

    }
}


///////////////////////////////////////////////////////////////////////
//
// kmxlAssignMuxIds
//
// Updates the source IDs stored in the MixerControlDetails array of
// the muxes and removes the muxes placed in lines as place holders.
//
//

NTSTATUS
kmxlAssignMuxIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST     listLines
)
{
    PMXLLINE pLine;
    PMXLCONTROL pControl;
    CONTROLLIST listControls = NULL;

    PAGED_CODE();
    pLine = kmxlFirstInList( listLines );
    while( pLine ) {

        //
        // Loop through the controls by removing them from the line's
        // control list and building a new control list.  This new
        // control list will have the extra mux controls removed.
        //

        pControl = kmxlRemoveFirstControl( pLine->Controls );
        while( pControl ) {

            if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUX ) ) {

                kmxlUpdateMuxLines( pLine, pControl );

                if( pControl->Parameters.bPlaceholder ) {

                    //
                    // This mux was here only to mark this line.  Free
                    // up only the control memory and leave the parameters
                    // memeory alone.
                    //

                    ASSERT( pControl->pChannelStepping == NULL);
                    AudioFreeMemory_Unknown( &pControl );
                    --pLine->Line.cControls;
                } else {

                    //
                    // This is a real mux control. Add it back into the
                    // list.
                    //

                    kmxlAddToEndOfList( listControls, pControl );
                }

            } else {

                //
                // Wasn't a mux.  Put it onto the end of the new control
                // list.

                kmxlAddToEndOfList( listControls, pControl );

            }

            //
            // Remove the next one!
            //

            pControl = kmxlRemoveFirstControl( pLine->Controls );
        }

        //
        // Reassign the new control list back into this line.
        //

        pLine->Controls = listControls;
        pLine = kmxlNextLine( pLine );
        listControls = NULL;
    }

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// TargetCommon
//
// Fills in the common fields of the target function.
//
//

VOID
TargetCommon(
    IN PMIXEROBJECT  pmxobj,
    IN PMXLLINE      pLine,
    IN DWORD         DeviceType
)
{
    PWDMACONTEXT pWdmaContext;
    PWAVEDEVICE  paWaveOutDevs, paWaveInDevs;
    PMIDIDEVICE  paMidiOutDevs, paMidiInDevs;
    ULONG    i;

    PAGED_CODE();
    pWdmaContext  = pmxobj->pMixerDevice->pWdmaContext;
    paWaveOutDevs = pWdmaContext->WaveOutDevs;
    paWaveInDevs  = pWdmaContext->WaveInDevs;
    paMidiOutDevs = pWdmaContext->MidiOutDevs;
    paMidiInDevs  = pWdmaContext->MidiInDevs;

    for( i = 0; i < MAXNUMDEVS; i++ ) {

        if( DeviceType == WaveOutDevice ) {

            if( (paWaveOutDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paWaveOutDevs[ i ].DeviceInterface) ) {

                WAVEOUTCAPS wc;

                ((PWAVEOUTCAPSA)(PVOID)&wc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, WaveOutDevice, i, (BYTE*) &wc, sizeof( WAVEOUTCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, wc.szPname, MAXPNAMELEN );
                pLine->Line.Target.wMid           = wc.wMid;
                pLine->Line.Target.wPid           = wc.wPid;
                pLine->Line.Target.vDriverVersion = wc.vDriverVersion;
                return;

            }
        }

        if( DeviceType == WaveInDevice ) {

            if( (paWaveInDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paWaveInDevs[ i ].DeviceInterface) ) {

                WAVEINCAPS wc;

                ((PWAVEINCAPSA)(PVOID)&wc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, WaveInDevice, i, (BYTE*) &wc, sizeof( WAVEINCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, wc.szPname, MAXPNAMELEN );
                pLine->Line.Target.wMid           = wc.wMid;
                pLine->Line.Target.wPid           = wc.wPid;
                pLine->Line.Target.vDriverVersion = wc.vDriverVersion;
                return;

            }

        }

        if( DeviceType == MidiOutDevice ) {

            if( (paMidiOutDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paMidiOutDevs[ i ].DeviceInterface) ) {

                MIDIOUTCAPS mc;

                ((PMIDIOUTCAPSA)(PVOID)&mc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, MidiOutDevice, i, (BYTE*) &mc, sizeof( MIDIOUTCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, mc.szPname, MAXPNAMELEN );
                pLine->Line.Target.wMid           = mc.wMid;
                pLine->Line.Target.wPid           = mc.wPid;
                pLine->Line.Target.vDriverVersion = mc.vDriverVersion;
                return;
            }
        }

        if( DeviceType == MidiInDevice ) {

            if( (paMidiInDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paMidiInDevs[ i ].DeviceInterface) ) {

                MIDIINCAPS mc;

                ((PMIDIINCAPSA)(PVOID)&mc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, MidiInDevice, i, (BYTE*) &mc, sizeof( MIDIINCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, mc.szPname, MAXPNAMELEN) ;
                pLine->Line.Target.wMid           = mc.wMid;
                pLine->Line.Target.wPid           = mc.wPid;
                pLine->Line.Target.vDriverVersion = mc.vDriverVersion;
                return;
            }
        }

    }

}

///////////////////////////////////////////////////////////////////////
//
// TargetTypeWaveOut
//
// Fills in the fields of aLine's target structure to be a waveout
// target.
//
//

VOID
TargetTypeWaveOut(
    IN PMIXEROBJECT pmxobj,
    IN PMXLLINE     pLine
)
{
    PAGED_CODE();
    pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_WAVEOUT;
    TargetCommon( pmxobj, pLine, WaveOutDevice );
}

///////////////////////////////////////////////////////////////////////
//
// TargetTypeWaveIn
//
// Fills in the fields of aLine's target structure to be a wavein
// target.
//
//

#define TargetTypeWaveIn( pmxobj, pLine )                             \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_WAVEIN;    \
        (pLine)->Line.Target.wPid   = MM_MSFT_WDMAUDIO_WAVEIN;        \
        TargetCommon( pmxobj, pLine, WaveInDevice )

///////////////////////////////////////////////////////////////////////
//
// TargetTypeMidiOut
//
// Fills in the fields of aLine's target structure to be a midi out
// target.
//
//

#define TargetTypeMidiOut( pmxobj, pLine )                          \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_MIDIOUT; \
        (pLine)->Line.Target.wPid   = MM_MSFT_WDMAUDIO_MIDIOUT;     \
        TargetCommon( pmxobj, pLine, MidiOutDevice )

///////////////////////////////////////////////////////////////////////
//
// TargetTypeMidiIn
//
// Fills in the fields of aLine's target structure to be a midi in
// target.
//
//


#define TargetTypeMidiIn( pmxobj, pLine )                             \
        (aLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_MIDIOUT;   \
        (aLine)->Line.Target.wPid   = MM_MSFT_WDMAUDIO_MIDIIN;        \
        TargetCommon( pmxobj, pLine, MidiInDevice )

///////////////////////////////////////////////////////////////////////
//
// TargetTypeAuxCD
//
// Fills in the fields of aLine's target structure to be a CD
// target.
//
//


#define TargetTypeAuxCD( pmxobj, pLine )                              \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_AUX;       \
        TargetCommon( pmxobj, pLine, WaveOutDevice );   \
        (pLine)->Line.Target.wPid   = MM_MSFT_SB16_AUX_CD

///////////////////////////////////////////////////////////////////////
//
// TargetTypeAuxLine
//
// Fills in the fields of aLine's target structure to be a aux line
// target.
//
//


#define TargetTypeAuxLine( pmxobj, pLine )                         \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_AUX;    \
        TargetCommon( pmxobj, pLine, WaveOutDevice );\
        (pLine)->Line.Target.wPid   = MM_MSFT_SB16_AUX_LINE

///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineDestinationType
//
// Determines the destination and target types by using the Type
// GUID stored in the line structure.
//
//

ULONG
kmxlDetermineDestinationType(
    IN PMIXEROBJECT pmxobj,         // Instance data
    IN PMXLLINE     pLine           // The line to determine type of
)
{
    PAGED_CODE();
    //
    // Speaker type destinations
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_SPEAKER ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_DESKTOP_SPEAKER ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_ROOM_SPEAKER ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_COMMUNICATION_SPEAKER ) ) {

        TargetTypeWaveOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_DST_SPEAKERS );

    }

    //
    // WaveIn type destinations
    //

    if( IsEqualGUID( &pLine->Type, &KSCATEGORY_AUDIO )
        || IsEqualGUID( &pLine->Type, &PINNAME_CAPTURE )
        ) {

         TargetTypeWaveIn( pmxobj, pLine );
         return( MIXERLINE_COMPONENTTYPE_DST_WAVEIN );

    }

    //
    // Headphone destination
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_HEADPHONES ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO ) ) {

        TargetTypeWaveOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_DST_HEADPHONES );
    }

    //
    // Telephone destination
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_TELEPHONE       ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_PHONE_LINE      ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_DOWN_LINE_PHONE ) )
    {
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_DST_TELEPHONE );
    }

    //
    // Ambiguous destination type.  Figure out the destination type by looking
    // at the Communication.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_ANALOG_CONNECTOR ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_SPDIF_INTERFACE ) ) {

        if (pLine->Communication == KSPIN_COMMUNICATION_BRIDGE) {
            TargetTypeWaveOut( pmxobj, pLine );
            return( MIXERLINE_COMPONENTTYPE_DST_SPEAKERS );
        } else {
            TargetTypeWaveIn( pmxobj, pLine );
            return( MIXERLINE_COMPONENTTYPE_DST_WAVEIN );
        }

    }

    //
    // Does not match the others.  Default to Undefined destination.
    //

    pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
    return( MIXERLINE_COMPONENTTYPE_DST_UNDEFINED );

}

///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineSourceType
//
// Determines the destination and target types by using the Type
// GUID stored in the line structure.
//
//

ULONG
kmxlDetermineSourceType(
    IN PMIXEROBJECT pmxobj,         // Instance data
    IN PMXLLINE     pLine           // The line to determine type of
)
{
    PAGED_CODE();
    //
    // All microphone type sources are a microphone source.
    //

    //
    // We are only checking two microphone GUIDs here.  We may 
    // want to consider the rest of the microphone types in 
    // ksmedia.h
    //
    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_MICROPHONE ) 
        || IsEqualGUID( &pLine->Type, &KSNODETYPE_DESKTOP_MICROPHONE )
       ) 
    {

        TargetTypeWaveIn( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE );
    }

    //
    // Legacy audio connector and the speaker type sources represent a
    // waveout source.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_LEGACY_AUDIO_CONNECTOR    )
        || IsEqualGUID( &pLine->Type, &KSNODETYPE_SPEAKER                )
        || IsEqualGUID( &pLine->Type, &KSCATEGORY_AUDIO                  )
        )
    {

        TargetTypeWaveOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT );
    }

    //
    // CD player is a compact disc source.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_CD_PLAYER ) ) {

        TargetTypeAuxCD( pmxobj, pLine );
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC );

    }

    //
    // Synthesizer is a sythesizer source.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_SYNTHESIZER ) ) {

        TargetTypeMidiOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER );

    }

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_LINE_CONNECTOR ) ) {

        TargetTypeAuxLine( pmxobj, pLine );
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_SRC_LINE );

    }

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_PHONE_LINE      ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_TELEPHONE       ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_DOWN_LINE_PHONE ) )
    {
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE );
    }

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_ANALOG_CONNECTOR ) ) {
        //
        // Ambiguous src type.  Figure out the destination type by looking
        // at the Communication.
        //
        if (pLine->Communication == KSPIN_COMMUNICATION_BRIDGE) {
            TargetTypeWaveIn( pmxobj, pLine );
        }
        else {
            TargetTypeWaveOut( pmxobj, pLine );
        }
        return( MIXERLINE_COMPONENTTYPE_SRC_ANALOG );
    }

    //
    // Digital in/out (SPDIF) source
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_SPDIF_INTERFACE ) ) {
        //
        // Ambiguous src type.  Figure out the destination type by looking
        // at the Communication.
        //
        if (pLine->Communication == KSPIN_COMMUNICATION_BRIDGE) {
            TargetTypeWaveIn( pmxobj, pLine );
        }
        else {
            TargetTypeWaveOut( pmxobj, pLine );
        }
        return( MIXERLINE_COMPONENTTYPE_SRC_DIGITAL );
    }

    //
    // All others are lumped under Undefined source.
    //

    pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
    return( MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED );

}

///////////////////////////////////////////////////////////////////////
//
// PinCategoryToString
//
// Converts the Pin category GUIDs to a string.

#ifdef DEBUG
#pragma LOCKED_CODE
#endif

#define _EG_(x,y) if (IsEqualGUID( NodeType, &x)) { return y; }

const char*
PinCategoryToString
(
    IN CONST GUID* NodeType // The GUID to translate
)
{
    _EG_(KSNODETYPE_MICROPHONE,"Microphone");
    _EG_(KSNODETYPE_DESKTOP_MICROPHONE,"Desktop Microphone");
    _EG_(KSNODETYPE_SPEAKER,"Speaker");
    _EG_(KSNODETYPE_HEADPHONES,"Headphones");
    _EG_(KSNODETYPE_LEGACY_AUDIO_CONNECTOR,"Wave");
    _EG_(KSNODETYPE_CD_PLAYER,"CD Player");
    _EG_(KSNODETYPE_SYNTHESIZER,"Synthesizer");
    _EG_(KSCATEGORY_AUDIO,"Wave");
    _EG_(PINNAME_CAPTURE,"Wave In");
    _EG_(KSNODETYPE_LINE_CONNECTOR,"Aux Line");
    _EG_(KSNODETYPE_TELEPHONE,"Telephone");
    _EG_(KSNODETYPE_PHONE_LINE,"Phone Line");
    _EG_(KSNODETYPE_DOWN_LINE_PHONE,"Downline Phone");
    _EG_(KSNODETYPE_ANALOG_CONNECTOR,"Analog connector");

    //New debug names...
    _EG_(KSAUDFNAME_MONO_OUT,"Mono Out");
    _EG_(KSAUDFNAME_STEREO_MIX,"Stereo Mix");
    _EG_(KSAUDFNAME_MONO_MIX,"Mono Mix");
    _EG_(KSAUDFNAME_AUX,"Aux");
    _EG_(KSAUDFNAME_VIDEO,"Video");
    _EG_(KSAUDFNAME_LINE_IN,"Line In");

    DPF(DL_WARNING|FA_MIXER,("Path Trap send me GUID - dt %08X _GUID",NodeType) );
    return "Unknown Pin Category";
}

///////////////////////////////////////////////////////////////////////
//
// NodeTypeToString
//
// Converts a NodeType GUID to a string
//
//

const char*
NodeTypeToString
(
    IN CONST GUID* NodeType // The GUID to translate
)
{
   _EG_(KSNODETYPE_DAC,"DAC");
   _EG_(KSNODETYPE_ADC,"ADC");
   _EG_(KSNODETYPE_SRC,"SRC");
   _EG_(KSNODETYPE_SUPERMIX,"SuperMIX");
   _EG_(KSNODETYPE_SUM,"Sum");
   _EG_(KSNODETYPE_MUTE,"Mute");
   _EG_(KSNODETYPE_VOLUME,"Volume");
   _EG_(KSNODETYPE_TONE,"Tone");
   _EG_(KSNODETYPE_AGC,"AGC");
   _EG_(KSNODETYPE_DELAY,"Delay");
   _EG_(KSNODETYPE_LOUDNESS,"LOUDNESS");
   _EG_(KSNODETYPE_3D_EFFECTS,"3D Effects");
   _EG_(KSNODETYPE_DEV_SPECIFIC,"Dev Specific"); 
   _EG_(KSNODETYPE_STEREO_WIDE,"Stereo Wide");
   _EG_(KSNODETYPE_REVERB,"Reverb");
   _EG_(KSNODETYPE_CHORUS,"Chorus");
    _EG_(KSNODETYPE_ACOUSTIC_ECHO_CANCEL,"AEC");
   _EG_(KSNODETYPE_EQUALIZER,"Equalizer");
   _EG_(KSNODETYPE_MUX,"Mux");
   _EG_(KSNODETYPE_DEMUX,"Demux");
   _EG_(KSNODETYPE_STEREO_ENHANCE,"Stereo Enhance");
   _EG_(KSNODETYPE_SYNTHESIZER,"Synthesizer");
   _EG_(KSNODETYPE_PEAKMETER,"Peakmeter");
    _EG_(KSNODETYPE_LINE_CONNECTOR,"Line Connector");
   _EG_(KSNODETYPE_SPEAKER,"Speaker");
   _EG_(KSNODETYPE_DESKTOP_SPEAKER,"");
   _EG_(KSNODETYPE_ROOM_SPEAKER,"Room Speaker");
   _EG_(KSNODETYPE_COMMUNICATION_SPEAKER,"Communication Speaker");
   _EG_(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER,"? Whatever...");
   _EG_(KSNODETYPE_HANDSET,"Handset");
   _EG_(KSNODETYPE_HEADSET,"Headset");
   _EG_(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION,"Speakerphone no echo reduction");
   _EG_(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE,"Echo Suppressing Speakerphone");
   _EG_(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE,"Echo Canceling Speakerphone");
    _EG_(KSNODETYPE_CD_PLAYER,"CD Player");
   _EG_(KSNODETYPE_MICROPHONE,"Microphone");
   _EG_(KSNODETYPE_DESKTOP_MICROPHONE,"Desktop Microphone");
   _EG_(KSNODETYPE_PERSONAL_MICROPHONE,"Personal Microphone");
   _EG_(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE,"Omni Directional Microphone");
   _EG_(KSNODETYPE_MICROPHONE_ARRAY,"Microphone Array");
   _EG_(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY,"Processing Microphone Array");
    _EG_(KSNODETYPE_ANALOG_CONNECTOR,"Analog Connector");
   _EG_(KSNODETYPE_PHONE_LINE,"Phone Line");
   _EG_(KSNODETYPE_HEADPHONES,"Headphones");
   _EG_(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO,"Head Mounted Display Audio");
    _EG_(KSNODETYPE_LEGACY_AUDIO_CONNECTOR,"Legacy Audio Connector");
//   _EG_(KSNODETYPE_SURROUND_ENCODER,"Surround Encoder");
   _EG_(KSNODETYPE_NOISE_SUPPRESS,"Noise Suppress");
   _EG_(KSNODETYPE_DRM_DESCRAMBLE,"DRM Descramble");
   _EG_(KSNODETYPE_SWMIDI,"SWMidi");
   _EG_(KSNODETYPE_SWSYNTH,"SWSynth");
   _EG_(KSNODETYPE_MULTITRACK_RECORDER,"Multitrack Recorder");
   _EG_(KSNODETYPE_RADIO_TRANSMITTER,"Radio Transmitter");
   _EG_(KSNODETYPE_TELEPHONE,"Telephone");

   _EG_(KSAUDFNAME_MONO_OUT,"Mono Out");
   _EG_(KSAUDFNAME_LINE_IN,"Line in");
   _EG_(KSAUDFNAME_VIDEO,"Video");
   _EG_(KSAUDFNAME_AUX,"Aux");
   _EG_(KSAUDFNAME_MONO_MIX,"Mono Mix");
   _EG_(KSAUDFNAME_STEREO_MIX,"Stereo Mix");

    _EG_(KSCATEGORY_AUDIO,"Audio");
    _EG_(PINNAME_VIDEO_CAPTURE,"Video Capture");

    DPF(DL_WARNING|FA_MIXER,("Path Trap send me GUID - dt %08X _GUID",NodeType) );
    return "Unknown NodeType";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\kmxluser.h ===
//---------------------------------------------------------------------------
//
//  Module:   mixer.h
//
//  Description:
//
//    Contains the declarations for the mixer line user api handlers.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//---------------------------------------------------------------------------

#ifndef _KMXLUSER_H_INCLUDED_
#define _KMXLUSER_H_INCLUDED_

typedef struct tag_MIXERDEVICE* PMIXERDEVICE;

#ifdef DEBUG
#define NOTIFICATION_SIGNATURE 'ETON' // NOTE
#define CONTROLLINK_SIGNATURE 'KLTC'  // CTLK
#endif

#define UNUSED_DEVICE                       ((ULONG) -1)

#define MIXER_FLAG_SCALE                    0x1
#define MIXER_FLAG_PERSIST                  0x2
#define MIXER_FLAG_NONCACHED                0x4
#define MIXER_FLAG_NOCALLBACK               0x8

#define MIXER_CONTROL_CALLBACK              0x01
#define MIXER_LINE_CALLBACK                 0x02

#define MIXER_KEY_NAME                      L"Mixer"
#define VALID_MULTICHANNEL_MIXER_VALUE_NAME L"Valid Multichannel Mixer Settings"
#define LINE_COUNT_VALUE_NAME               L"Line Count"
#define LINE_ID_VALUE_NAME                  L"LineId"
#define CONTROL_COUNT_VALUE_NAME            L"Control Count"
#define SOURCE_ID_VALUE_NAME                L"SourceId"
#define DEST_ID_VALUE_NAME                  L"DestId"
#define CONTROLS_KEY_NAME                   L"Controls"
#define CONTROL_TYPE_VALUE_NAME             L"Control Type"
#define CHANNEL_COUNT_VALUE_NAME            L"Channel Count"
#define CONTROL_MINVAL_VALUE_NAME           L"Minimum Value"
#define CONTROL_MAXVAL_VALUE_NAME           L"Maximum Value"
#define CONTROL_STEPS_VALUE_NAME            L"Steps"
#define CONTROL_MULTIPLEITEMS_VALUE_NAME    L"Multiple Items"

#define LINE_KEY_NAME_FORMAT                L"%8X"
#define CONTROL_KEY_NAME_FORMAT             L"%8X"
#define CHANNEL_VALUE_NAME_FORMAT           L"Channel%8d"
#define MULTIPLEITEM_VALUE_NAME_FORMAT      L"Item%8d"

#define KMXL_TRACELEVEL_FATAL_ERROR 0x10
#define KMXL_TRACELEVEL_ERROR       0x20
#define KMXL_TRACELEVEL_WARNING     0x30
#define KMXL_TRACELEVEL_TRACE       0x40

#define DEFAULT_RANGE_MIN   ( -96 * 65536 )   // -96 dB
#define DEFAULT_RANGE_MAX   ( 0 )             // 0 dB
#define DEFAULT_RANGE_STEPS ( 48 )            // 2 dB steps

#define DEFAULT_STATICBOUNDS_MIN     ( 0 )
#define DEFAULT_STATICBOUNDS_MAX     ( 65535 )
#define DEFAULT_STATICMETRICS_CSTEPS ( 192 )


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                M I X E R  A P I  H A N D L E R S                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlInitializeMixer
//
// Initializes or re-initializes the mixer driver.
//
//

NTSTATUS
kmxlInitializeMixer(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    ULONG cDevices
);

///////////////////////////////////////////////////////////////////////
//
// kmxlInitHandler
//
// Handles the MXDM_INIT message.
//
//

NTSTATUS
kmxlInitHandler(
    IN LPDEVICEINFO DeviceInfo      // Device Input Parameters
);

///////////////////////////////////////////////////////////////////////
//
// kmxlOpenHandler
//
// Handles the MXDM_OPEN message.
//
//

NTSTATUS
kmxlOpenHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,      // Device Input Parameters
    IN LPVOID       DataBuffer       // Flat pointer to open desc
);

///////////////////////////////////////////////////////////////////////
//
// kmxlCloseHandler
//
// Handles the MXDM_CLOSE message.
//
//

NTSTATUS
kmxlCloseHandler(
    IN LPDEVICEINFO DeviceInfo,     // Device Input Parameters
    IN LPVOID       DataBuffer      // UNUSED
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoHandler
//
// Handles the MXDM_GETLINEINFO message.
//
//

NTSTATUS
kmxlGetLineInfoHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,     // Device Input Parameters
    IN LPVOID       DataBuffer      // Mapped MIXERLINE structure
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineControlsHandler
//
// Handles the MXDM_GETLINECONTROLS message.
//
//

NTSTATUS
kmxlGetLineControlsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,     // Device Input Parameters
    IN LPVOID       DataBuffer,     // Mapped MIXERLINECONTROLS structure
    IN LPVOID       pamxctrl        // Mapped MIXERCONTROL array
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlDetailsHandler
//
// Handles the MXDM_GETLINECONTROLS message.
//
//

NTSTATUS
kmxlGetControlDetailsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info Structure
    IN LPVOID       DataBuffer,         // MIXERCONTROLDETAILS structure
    IN LPVOID       paDetails           // Flat pointer to details struct(s)
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSetControlDetailsHandler
//
// Handles the MXDM_SetControlDetailsHandler
//
//

NTSTATUS
kmxlSetControlDetailsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,     // Device Input Parameters
    IN LPVOID       DataBuffer,     // Mapped MIXERCONTROLDETAILS struct.
    IN LPVOID       paDetails,      // Mapped array of DETAILS structures.
    IN ULONG        Flags
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                 H E L P E R  F U N C T I O N S                    //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlFindControl
//
// For the given control ID, kmxlFindControl will find the matching
// MXLCONTROL structure.
//
//

PMXLCONTROL
kmxlFindControl(
    IN PMIXERDEVICE pmxd,             // The mixer instance to search
    IN DWORD        dwControlID       // The control ID to find
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFindLine
//
// For the given line ID, kmxlFindLine will find the matching
// MXLLINE structure for it.
//
//

PMXLLINE
kmxlFindLine(
    IN PMIXERDEVICE   pmxd,             // The mixer to search
    IN DWORD          dwLineID          // The line ID to find
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByID
//
// Finds a line that matches the given source and destination line
// ids.
//
//

NTSTATUS
kmxlGetLineInfoByID(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,     // Device Input Parameters
    IN LPVOID       DataBuffer,     // Mapped MIXERLINE structure
    IN WORD         Source,         // Source line Id
    IN WORD         Destination     // Destination line Id
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByType
//
// Finds a line that matches the given target type.
//
//

NTSTATUS
kmxlGetLineInfoByType(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,     // Device Input Parameters
    IN LPVOID       DataBuffer,     // Mapped MIXERLINE structure
    IN DWORD        dwType          // The line target type to find
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByComponent
//
// Finds a line that matches the given component type.
//
//

NTSTATUS
kmxlGetLineInfoByComponent(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,     // Device Input Parameters
    IN LPVOID       DataBuffer,     // Mapped MIXERLINE structure
    IN DWORD        dwComponentType // The compontent type to match
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNumDestinations
//
// Returns the number of destinations on the given device number.
//
//

DWORD
kmxlGetNumDestinations(
    IN PMIXERDEVICE pMixerDevice    // The device to query
);

///////////////////////////////////////////////////////////////////////
//
// kmxlConvertMixerLineWto16
//
// Converts a UNICODE MIXERLINE structure to ANSI, optionally copying
// the Target structure.
//
//

VOID
kmxlConvertMixerLineWto16(
    IN     LPMIXERLINE   pMixerLineW,
    IN OUT LPMIXERLINE16 pMixerLine16,
    IN     BOOL          bCopyTarget
);

///////////////////////////////////////////////////////////////////////
//
// kmxlConvertMixerControlWto16
//
// Converts a UNICODE MIXERCONTROL structure to ANSI.
//
//

VOID
kmxlConvertMixerControlWto16(
    IN     LPMIXERCONTROL   pMixerControlW,
    IN OUT LPMIXERCONTROL16 pMixerControl16
);

///////////////////////////////////////////////////////////////////////
//
// kmxlConvertMixerControlDetails_ListTextWto16
//
// Converts an UNICODE MIXERCONTROLDETAILS_LISTTEXT structure to ANSI.
//
//

VOID
kmxlConvertMixerControlDetails_ListTextWto16(
    IN     LPMIXERCONTROLDETAILS_LISTTEXT   pListTextW,
    IN OUT LPMIXERCONTROLDETAILS_LISTTEXT16 pListText16
);


///////////////////////////////////////////////////////////////////////
//
// Instance list handling routines
//

DWORD 
kmxlUniqueInstanceId(
    VOID
);


PMIXERDEVICE
kmxlReferenceMixerDevice(
    IN     PWDMACONTEXT pWdmaContext,
    IN OUT LPDEVICEINFO DeviceInfo      // Device Information
);



///////////////////////////////////////////////////////////////////////
//
// kmxlNotifyLineChange
//
// Notifies all mixer line clients on a line status change.
//
//

VOID
kmxlNotifyLineChange(
    OUT LPDEVICEINFO                  DeviceInfo,
    IN PMIXERDEVICE                   pmxd,
    IN PMXLLINE                       pLine,
    IN LPMIXERCONTROLDETAILS_UNSIGNED paDetails
);

///////////////////////////////////////////////////////////////////////
//
// kmxlNotifyControlChange
//
// Notifies all mixer line clients on a control change.
//
//

VOID
kmxlNotifyControlChange(
    OUT LPDEVICEINFO  DeviceInfo,
    IN PMIXERDEVICE   pmxd,
    IN PMXLCONTROL    pControl
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//           G E T / S E T  D E T A I L  H A N D L E R S             //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetUnsigned
//
// Handles the get property for all 32-bit sized values: UNSIGNED,
// SIGNED, and BOOLEAN.
//
//

NTSTATUS
kmxlHandleGetUnsigned(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     ULONG                          ulProperty,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
);

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetUnsigned
//
// Handles the gSt property for all 32-bit sized values: UNSIGNED,
// SIGNED, and BOOLEAN.
//
//

NTSTATUS
kmxlHandleSetUnsigned(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     ULONG                          ulProperty,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
);

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetMuteFromSuperMix
//
//

NTSTATUS
kmxlHandleGetMuteFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
);

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetMuteFromSuperMix
//
//

NTSTATUS
kmxlHandleSetMuteFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
);

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetVolumeFromSuperMix
//
//

NTSTATUS
kmxlHandleGetVolumeFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
);

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetVolumeFromSuperMix
//
//

NTSTATUS
kmxlHandleSetVolumeFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//            P E R S I S T A N C E  F U N C T I O N S               //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistAll
//
//

NTSTATUS
kmxlPersistAll(
    IN PFILE_OBJECT pfo,        // The instance to persist
    IN PMIXERDEVICE pmxd        // The mixer device data
);

///////////////////////////////////////////////////////////////////////
//
// kmxlRetrieveAll
//
//

NTSTATUS
kmxlRetrieveAll(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd        // The mixer device data
);

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistControl
//
//

NTSTATUS
kmxlPersistControl(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd,       // Mixer device info
    IN PMXLCONTROL  pControl,   // The control to persist
    IN PVOID        paDetails   // The channel values to persist
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFindLineForControl
//
//

PMXLLINE
kmxlFindLineForControl(
    IN PMXLCONTROL pControl,
    IN LINELIST    listLines
);


///////////////////////////////////////////////////////////////////////
//
// mixerGetControlDetails
//
//

MMRESULT
WINAPI
kmxlGetControlDetails(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERCONTROLDETAILS pmxcd,
    DWORD fdwDetails
);

///////////////////////////////////////////////////////////////////////
//
// mixerGetLineControls
//
//

MMRESULT
WINAPI
kmxlGetLineControls(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERLINECONTROLS pmxlc,
    DWORD fdwControls
);

///////////////////////////////////////////////////////////////////////
//
// mixerGetLineInfo
//
//

MMRESULT
WINAPI
kmxlGetLineInfo(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERLINE pmxl,
    DWORD fdwInfo
);

///////////////////////////////////////////////////////////////////////
//
// mixerSetControlDetails
//
//

MMRESULT
WINAPI
kmxlSetControlDetails(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERCONTROLDETAILS pmxcd,
    DWORD fdwDetails
);

#endif // _KMXLUSER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\mixer.h ===
//---------------------------------------------------------------------------
//
//  Module:   mixer.h
//
//  Description:
//
//    Contains the declarations and prototypes for the Kernel Portion
//    of the mixer line driver (KMXL).
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

#ifndef _MIXER_H_INCLUDED_
#define _MIXER_H_INCLUDED_

//#define API_TRACE
//#define PARSE_TRACE
#define SUPERMIX_AS_VOL

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//       M I X E R   L I N E  1 6 - b i t  S T R U C T U R E S       //
//                            ( A N S I )                            //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#ifdef WIN32
#    include <pshpack1.h>
#else
#    ifndef RC_INVOKED
#        pragma pack(1)
#    endif
#endif

typedef struct tagMIXERLINE16 {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
        DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
        DWORD   dwDeviceID;             /* target device ID of device type */
        WORD    wMid;                   /* of target device */
        WORD    wPid;                   /*      " */
        WORD    vDriverVersion;       /*      " */
        CHAR    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINE16, *PMIXERLINE16, *LPMIXERLINE16;

typedef struct tagMIXERCONTROL16 {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    CHAR            szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR            szName[MIXER_LONG_NAME_CHARS];
    union {
        struct {
            LONG    lMinimum;           /* signed minimum for this control */
            LONG    lMaximum;           /* signed maximum for this control */
        };
        struct {
            DWORD   dwMinimum;          /* unsigned minimum for this control */
            DWORD   dwMaximum;          /* unsigned maximum for this control */
        };
        DWORD       dwReserved[6];
    } Bounds;
    union {
        DWORD       cSteps;             /* # of steps between min & max */
        DWORD       cbCustomData;       /* size in bytes of custom data */
        DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROL16, *PMIXERCONTROL16, *LPMIXERCONTROL16;

typedef struct tagMIXERLINECONTROLS16 {
    DWORD            cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD            dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
        DWORD        dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
        DWORD        dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD            cControls;      /* count of controls pmxctrl points to */
    DWORD            cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROL16 pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLS16, *PMIXERLINECONTROLS16, *LPMIXERLINECONTROLS16;

typedef struct tagMIXERCONTROLDETAILS_LISTTEXT16 {
    DWORD           dwParam1;
    DWORD           dwParam2;
    CHAR            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXT16, *PMIXERCONTROLDETAILS_LISTTEXT16, *LPMIXERCONTROLDETAILS_LISTTEXT16;

#ifdef WIN32
#    include <poppack.h>
#else
#    ifndef RC_INVOKED
#        pragma pack()
#    endif
#endif

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          D E F I N E S                            //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#define PINID_WILDCARD ( (ULONG) -2 )

#define DESTINATION_LIST ( 0x01 )
#define SOURCE_LIST      ( 0x02 )

#define SLIST  SINGLE_LIST_ENTRY
#define PSLIST SLIST*

#define MAX_CHANNELS    0xFFFF

//#define MIXERCONTROL_CONTROLTYPE_BASS_BOOST 0x20012277

#define INVALID_ID ( 0xDEADBEEF )

#define TOPOLOGY_DRIVER_NAME L"\\DosDevices\\sysaudio\\MIXER"
//#define TOPOLOGY_DRIVER_NAME L"\\DosDevices\\PortClass0\\TOPOLOGY"

#define STR_SHORT_AGC         "AGC"
#define STR_AGC               "Automatic Gain Control"
#define STR_SHORT_LOUDNESS    "Loudness"
#define STR_LOUDNESS          STR_SHORT_LOUDNESS
#define STR_SHORT_MUTE        "Mute"
#define STR_MUTE              STR_SHORT_MUTE
#define STR_SHORT_TREBLE      "Treble"
#define STR_TREBLE            STR_SHORT_TREBLE
#define STR_SHORT_BASS        "Bass"
#define STR_BASS              STR_SHORT_BASS
#define STR_SHORT_VOLUME      "Volume"
#define STR_VOLUME            STR_SHORT_VOLUME
#define STR_SHORT_MUX         "Mux"
#define STR_MUX               "Source Mux"
#define STR_SHORT_BASS_BOOST  "Bass Boost"
#define STR_BASS_BOOST        STR_SHORT_BASS_BOOST

//
// The SwapEm macro function will swap the contents of any SLIST based
// list.  A and B are the elements to swap.  T is a temporary variable
// of the same type as A and B to use a temporary storage.  size is
// the size of the structure in the list, including the SLIST element.
// The macro does not copy the pointer stored in SLIST.
//

#define SwapEm(A, B, T, size)                \
    memcpy( ((BYTE*) (T)) + sizeof( SLIST ), \
            ((BYTE*) (A)) + sizeof( SLIST ), \
            size - sizeof( SLIST ) );        \
    memcpy( ((BYTE*) (A)) + sizeof( SLIST ), \
            ((BYTE*) (B)) + sizeof( SLIST ), \
            size - sizeof( SLIST ) );        \
    memcpy( ((BYTE*) (B)) + sizeof( SLIST ), \
            ((BYTE*) (T)) + sizeof( SLIST ), \
            size - sizeof( SLIST ) )

//
// IsValidLine determines if the line pointed to by pLine is valid.  A valid
// line is determined by having valid Source and Dest Ids.
//

#define Is_Valid_Line( pLine ) ( ( pLine->SourceId != INVALID_ID ) && \
                                 ( pLine->DestId   != INVALID_ID ) )


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   F O R W A R D   R E F E R E N C E S
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

typedef struct tag_MIXERDEVICE *PMIXERDEVICE;

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                       S T R U C T U R E S                         //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

typedef struct tag_CHANNEL_STEPPING {
    LONG MinValue;
    LONG MaxValue;
    LONG Steps;
} CHANNEL_STEPPING, *PCHANNEL_STEPPING;

typedef enum tagMXLNODE_TYPE { SOURCE, DESTINATION, NODE } MXLNODE_TYPE;

typedef struct tagMXLCONTROL {
    SLIST         List;          // MUST BE THE FIRST MEMBER!
    MIXERCONTROL  Control;       // The MixerControl structure for the control
    CONST GUID*   NodeType;      // The type of node this control represents
    ULONG         Id;            // The Node Id this control represents
    ULONG         PropertyId;    // The KS property used for GET/SET
    BOOL          bScaled;       // Linear->Log scaling

    ULONG             NumChannels;
    PCHANNEL_STEPPING pChannelStepping;

    union {

        //
        // Supermixer parameters
        //

        struct {
            PLONG                 pReferenceCount;
            ULONG                 Size;
            PKSAUDIO_MIXCAP_TABLE pMixCaps;
            PKSAUDIO_MIXLEVEL     pMixLevels;   // Stored mix levels
        };

        //
        // Parameters for muxes
        //

        struct {
            BOOL                           bPlaceholder;
            BOOL                           bHasCopy;    // bHasCopy must be
                                                        // set to TRUE unless
                                                        // this control owns
                                                        // the original mem.
            ULONG                          Count;
            LPMIXERCONTROLDETAILS_LISTTEXT lpmcd_lt;
            ULONG*                         pPins;
        };

    } Parameters;
#ifdef DEBUG
    DWORD         Tag;           // 'CTRL' if valid control
#endif
} MXLCONTROL, *PMXLCONTROL, *CONTROLLIST;

typedef struct tagMXLLINE {
    SLIST               List;          // MUST BE THE FIRST MEMBER!
    MIXERLINE           Line;          // The MixerLine structure for the line
    CONTROLLIST         Controls;      // The list of controls associated with line
    ULONG               SourceId;      // Source Pin Id this line corresponds to
    ULONG               DestId;        // Dest Pin Id this line corresponds to
    GUID                Type;          // The type of line this is
    KSPIN_COMMUNICATION Communication; // KSPIN_COMMUNICATION of the line
    BOOL                bMute;
} MXLLINE, *PMXLLINE, *LINELIST;

typedef struct tagPEERNODE* PEERLIST;

typedef struct tagMXLNODE {
    SLIST               List;           // MUST BE THE FIRST MEMBER!
    MXLNODE_TYPE        Type;           // Type of node: SOURCE, DEST, or NODE
    GUID                NodeType;       // KSNODETYPE of the node
    KSPIN_COMMUNICATION Communication;  // KSPIN_COMMUNICATION of the node
    ULONG               Id;             // Pin or node ID
    PEERLIST            Children;       // List of Children
    PEERLIST            Parents;        // List of Parents
} MXLNODE, *PMXLNODE, *NODELIST;

typedef struct tagPEERNODE {
    SLIST        List;           // MUST BE THE FIRST MEMBER!
    PMXLNODE     pNode;          // Pointer to the mixer node
} PEERNODE, *PPEERNODE;

typedef struct tagMIXEROBJECT {
    PFILE_OBJECT pfo;
    PMXLNODE     pNodeTable;
    PKSTOPOLOGY  pTopology;
    CONTROLLIST  listMuxControls;
    DWORD        dwControlId;
    PMIXERDEVICE pMixerDevice;
#ifdef DEBUG
    DWORD        dwSig;
#endif
    PWSTR        DeviceInterface;
} MIXEROBJECT, *PMIXEROBJECT;

typedef enum {
     MIXER_MAPPING_LOGRITHMIC,
     MIXER_MAPPING_LINEAR,
     MIXER_MAPPING_EXPONENTIAL
} MIXERMAPPING;


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                        M A C R O  C I T Y :                       //
//    L I S T  M A N A G E M E N T  M A C R O  F U N C T I O N S     //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//
// Next in list retrieval macros
//

#define NextInList( pList, Type )   (( Type* ) ( pList->List.Next ) )

#define kmxlNextNode( pNode )       NextInList( pNode,    MXLNODE    )
#define kmxlNextPeerNode( pNode )   NextInList( pNode,    PEERNODE   )
#define kmxlNextControl( pControl ) NextInList( pControl, MXLCONTROL )
#define kmxlNextLine( pLine )       NextInList( pLine,    MXLLINE    )

//
// First in list retrieval macros
//

#define kmxlFirstInList( NodeList )  ( NodeList )
#define kmxlFirstChildNode( pNode )  (( PEERNODE* ) (pNode)->Children )
#define kmxlFirstParentNode( pNode ) (( PEERNODE* ) (pNode)->Parents  )

//
// List count macros
//

#define kmxlParentListLength( pNode ) kmxlListCount( (PSLIST) pNode->Parents  )
#define kmxlChildListLength( pNode )  kmxlListCount( (PSLIST) pNode->Children )
#define kmxlListLength( List )        kmxlListCount( (PSLIST) List            )

//
// Added to a list macros
//

#define kmxlAddToList( pNodeList, pNode )                             \
            if( pNodeList ) {                                         \
                (pNode)->List.Next = (PSLIST) (pNodeList);            \
                (pNodeList)        = (pNode);                         \
            } else {                                                  \
                (pNode)->List.Next = NULL;                            \
                (pNodeList) = (pNode);                                \
            }

#define kmxlAddToEndOfList( list, node )                              \
            kmxlAddElemToEndOfList( ((PSLIST*) &(list)), (PSLIST) (node) )

#define kxmlAddLineToEndOfList( list, node )
#define kmxlAddToChildList( NodeList, Node )                          \
            ASSERT( (Node)->pNode );                                  \
            kmxlAddToList( (NodeList)->Children, (Node) );

#define kmxlAddToParentList( NodeList, Node )                         \
            ASSERT( (Node)->pNode );                                  \
            kmxlAddToList( (NodeList)->Parents, (Node) );


//
// Remove from a list macros
//

#define RemoveFirstEntry( list, Type )                                \
            (Type*) (list);                                           \
            {                                                         \
                PSLIST pRFETemp;                                      \
                pRFETemp = (PSLIST) (list);                           \
                if( (list) ) {                                        \
                    (list) = (Type*) (list)->List.Next;               \
                    if( pRFETemp ) {                                  \
                        ((Type*) pRFETemp)->List.Next = NULL;         \
                    }                                                 \
                }                                                     \
            }


#define kmxlRemoveFirstNode( pNodeList )                              \
            RemoveFirstEntry( (pNodeList), MXLNODE )

#define kmxlRemoveFirstControl( pControlList )                        \
            RemoveFirstEntry( (pControlList), MXLCONTROL )

#define kmxlRemoveFirstLine( pLineList )                              \
            RemoveFirstEntry( (pLineList), MXLLINE )

#define kmxlRemoveFirstPeerNode( pPeerList )                          \
            RemoveFirstEntry( (pPeerList), PEERNODE )

#define kmxlRemoveFirstChildNode( pNode )                             \
            RemoveFirstEntry( (pNode)->Children, PEERNODE )

#define kmxlRemoveFirstParentNode( pNode )                            \
            RemoveFirstEntry( (pNode)->Parents, PEERNODE )

#ifdef DEBUG
#define CONTROL_TAG 'LRTC'  //CTRL as seen in memory.
#else
#define CONTROL_TAG
#endif // DEBUG

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                        P R O T O T Y P E S                        //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//   I N I T I A L I Z A T I O N / D E I N I T I A L I Z A T I O N   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlInit
//
// Retrieves and parses the topology for a given mixer device number.
// The pfo is an open file object to an instance of a filter that
// will provide the topology.
//
//

NTSTATUS
kmxlInit(
    IN PFILE_OBJECT pfo,        // Handle of the topology driver instance
    IN PMIXERDEVICE pMixerDevice    // The device to initialize for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDeInit
//
// Cleans up all memory for all devices.
//
//

NTSTATUS
kmxlDeInit(
    IN PMIXERDEVICE pMixerDevice
);

///////////////////////////////////////////////////////////////////////
//
// BuildMixerLines
//
// Build the list of mixer lines and stores them into plistLines.
// pcDestinations contains the count of total destinations for the
// given topology, pTopology.
//
//

NTSTATUS
kmxlBuildLines(
    IN     PMIXERDEVICE pMixer,         // The mixer device
    IN     PFILE_OBJECT pfoInstance,    // The FILE_OBJECT of a filter instance
    IN OUT LINELIST*    plistLines,     // Pointer to the list of all lines
    IN OUT PULONG       pcDestinations, // Pointer to the number of dests
    IN OUT PKSTOPOLOGY  pTopology       // Pointer to a topology structure
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                 T O P O L O G Y  F U N C T I O N S                //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// QueryTopology
//
// Queries the topology property on the given instance and stores
// it into pTopology.  Note that memory is allocated to store the
// topology.
//
//

NTSTATUS
kmxlQueryTopology(
    IN  PFILE_OBJECT pfoInstance,   // The instance to query
    OUT PKSTOPOLOGY  pTopology      // The topology structure to fill in
);

///////////////////////////////////////////////////////////////////////
//
// ParseTopology
//
// Parses the topology in pTopology and builds a graph of sources and
// destinations.  ppSources will contain a list of all sources nodes
// and ppDests will contain a list of dests.  The elements in pNodeTable
// will be updated.
//
//

NTSTATUS
kmxlParseTopology(
    IN      PMIXEROBJECT pmxobj,
    OUT     NODELIST*    ppSources,   // Pointer to the sources list to build
    OUT     NODELIST*    ppDests      // Pointer to the dests list to build
);

///////////////////////////////////////////////////////////////////////
//
// BuildChildGraph
//
// For a given node, BuildChildGraph() will build the graph of each
// of the node's children.  pNodeTable is updated.
//
//

NTSTATUS
kmxlBuildChildGraph(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST    listDests,     // The list of destinations
    IN PMXLNODE    pNode,         // The node to build the graph for
    IN ULONG       FromNode,      // The node's ID
    IN ULONG       FromNodePin    // The Pin connection to look for
);

///////////////////////////////////////////////////////////////////////
//
// BuildNodeTable
//
// Allocates and fills in the table of nodes for the topology.
//
//

PMXLNODE
kmxlBuildNodeTable(
    IN PKSTOPOLOGY pTopology       // The topology structure to build from
);

///////////////////////////////////////////////////////////////////////
//
// FindTopologyConnection
//
// Finds the specified connection, if it exists, starting at the
// StartIndex index into the connections table.  It will return the
// index into the connection table of a connection starting from
// the given FromNode and FromNodePin.  FromNodePin may be PINID_WILDCARD
// if a connection on a node is present rather than a specific connection.
//
//

ULONG
kmxlFindTopologyConnection(
    IN PMIXEROBJECT                 pmxobj,
    //IN CONST KSTOPOLOGY_CONNECTION* pConnections,   // The connection table
    //IN ULONG                        cConnections,   // The # of connections
    IN ULONG                        StartIndex,     // Index to start search
    IN ULONG                        FromNode,       // The Node ID to look for
    IN ULONG                        FromNodePin     // The Pin ID to look for
);

///////////////////////////////////////////////////////////////////////
//
// GetProperty
//
// Retrieves the specified property from an open filter.  Flags may
// contain values such as KSPROPERTY_TYPE_TOPOLOGY.  The output
// buffer is allocated to the correct size and returned by this
// function.
//
//

NTSTATUS
kmxlGetProperty(
    PFILE_OBJECT pFileObject,       // The instance of the filter
    CONST GUID   *pguidPropertySet, // The requested property set
    ULONG        ulPropertyId,      // The ID of the specific property
    ULONG        cbInput,           // The number of extra input bytes
    PVOID        pInputData,        // Pointer to the extra input bytes
    ULONG        Flags,             // Additional flags
    PVOID        *ppPropertyOutput  // Pointer to a pointer of the output
);

///////////////////////////////////////////////////////////////////////
//
// kmxlNodeProperty
//
// NodeProperty() gets or sets the property on an individual node.
// The output is not allocated and must be passed in by the caller.
// Flags can be KSPROPERTY_TYPE_GET or KSPROPERTY_TYPE_SET.
//
//

NTSTATUS
kmxlNodeProperty(
    IN  PFILE_OBJECT pFileObject,       // Instance of the filter owning node
    IN  CONST GUID*  pguidPropertySet,  // The GUID of the property set
    IN  ULONG        ulPropertyId,      // The specific property in the set
    IN  ULONG        ulNodeId,          // The virtual node id
    IN  ULONG        cbInput,           // # of extra input bytes
    IN  PVOID        pInputData,        // Pointer to the extra input bytes
    OUT PVOID        pPropertyOutput,   // Pointer to the output data
    IN  ULONG        cbPropertyOutput,  // Size of the output data buffer
    IN  ULONG        Flags              // KSPROPERTY_TYPE_GET or SET
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNodeProperty
//
// Get the specified property for a node.  See kmxlNodeProperty for
// details on parameters and returns.
//
//

#define kmxlGetNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut ) \
    kmxlNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut,KSPROPERTY_TYPE_GET )

///////////////////////////////////////////////////////////////////////
//
// kmxlSetNodeProperty
//
// Sets the specified property for a node.  See kmxlNodeProperty for
// details on parameters and returns.
//
//

#define kmxlSetNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut ) \
    kmxlNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut,KSPROPERTY_TYPE_SET )

///////////////////////////////////////////////////////////////////////
//
// kmxlAudioNodeProperty
//
// Sets or get the audio specific node property.  The property set
// is always KSPROPSETID_Audio.  lChannel specifies which channel to
// apply the property to.  0 is left, 1 is right, -1 is master (all).
// Flags can be either KSPROPERTY_TYPE_GET or KSPROPERTY_TYPE_SET.
//
//

NTSTATUS
kmxlAudioNodeProperty(
    IN  PFILE_OBJECT pfo,               // Instance of the filter owning node
    IN  ULONG        ulPropertyId,      // The audio property to get
    IN  ULONG        ulNodeId,          // The virtual node id
    IN  LONG         lChannel,          // The channel number
    IN  PVOID        pInData,           // Pointer to extra input bytes
    IN  ULONG        cbInData,          // Number of extra input bytes
    OUT PVOID        pOutData,          // Pointer to output buffer
    IN  LONG         cbOutData,         // Size of the output buffer
    IN  ULONG        Flags              // KSPROPERTY_TYPE_GET or SET
);

///////////////////////////////////////////////////////////////////////
//
// kxmlGetAudioNodeProperty
//
// Gets the specified audio property on a node.  See kmxlAudioNodeProperty
// for details on parameters and return values.
//
//

#define kmxlGetAudioNodeProperty(pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut) \
    kmxlAudioNodeProperty( pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut,KSPROPERTY_TYPE_GET )

///////////////////////////////////////////////////////////////////////
//
// kxmlSetAudioNodeProperty
//
// Sets the specified audio property on a node.  See kmxlAudioNodeProperty
// for details on parameters and return values.
//
//

#define kmxlSetAudioNodeProperty(pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut) \
    kmxlAudioNodeProperty( pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut,KSPROPERTY_TYPE_SET )

///////////////////////////////////////////////////////////////////////
//
// kmxlGetPinName
//
// Retrieves the name of the pin given by NodeId.
//
//

VOID
kmxlGetPinName(
    IN PFILE_OBJECT pfo,                // Instance of the owning filter
    IN ULONG        PinId,              // Id of the pin
    IN PMXLLINE     pLine               // The line to store the name into
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNodeName
//
// Retrieves the name of a node (control).
//
//

VOID
kmxlGetNodeName(
    IN PFILE_OBJECT pfo,                // Instance of the owning filter
    IN ULONG        NodeId,             // The node id
    IN PMXLCONTROL  pControl            // The control to store the name
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetSuperMixCaps
//
//

NTSTATUS
kmxlGetSuperMixCaps(
    IN PFILE_OBJECT        pfo,
    IN ULONG               ulNodeId,
    OUT PKSAUDIO_MIXCAP_TABLE* paMixCaps
);

///////////////////////////////////////////////////////////////////////
//
// kmxlQueryPropertyRange
//
//

NTSTATUS
kmxlQueryPropertyRange(
    IN  PFILE_OBJECT             pfo,
    IN  CONST GUID*              pguidPropSet,
    IN  ULONG                    ulPropertyId,
    IN  ULONG                    ulNodeId,
    OUT PKSPROPERTY_DESCRIPTION* ppPropDesc
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlChannels
//
//

NTSTATUS
kmxlGetControlChannels(
    IN PFILE_OBJECT pfo,
    IN PMXLCONTROL  pControl
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlRange
//
//

NTSTATUS
kmxlGetControlRange(
    IN PFILE_OBJECT pfo,
    IN PMXLCONTROL  pControl
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNumMuxLines
//
//

DWORD
kmxlGetNumMuxLines(
    IN PKSTOPOLOGY  pTopology,
    IN ULONG        NodeId
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetMuxLineNames
//
//

VOID
kmxlGetMuxLineNames(
    IN PMIXEROBJECT pmxobj,
    IN PMXLCONTROL  pControl
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               M I X E R L I N E  F U N C T I O N S                //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildDestinationLines
//
// Builds up a list of destination lines given a list of the destination
// nodes.
//
// Returns NULL on error.
//
//

LINELIST
kmxlBuildDestinationLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listDests     // The list of destination nodes
);

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildDestinationControls
//
// Builds a list of mixer line controls for a given destination line.
//
//

NTSTATUS
kmxlBuildDestinationControls(
    IN  PMIXEROBJECT pmxobj,
    IN  PMXLNODE     pDest,         // The destination to built controls for
    IN  PMXLLINE     pLine          // The line to add the controls to
);


///////////////////////////////////////////////////////////////////////
//
// kmxlBuildSourceLines
//
// Builds a list of mixer source lines for the given topology.
//
//

LINELIST
kmxlBuildSourceLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listSources,    // The list of source nodes
    IN NODELIST     listDests       // The list of dest. nodes
);

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildPath
//
// Builds the controls for each of the source lines, building new
// source lines of splits are detected in the topology.  plistLines
// may have new lines added if splits are encountered.  Destinations
// for each of the sources is also determined.
//
//

NTSTATUS
kmxlBuildPath(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pSource,      // The source node for this path
    IN     PMXLNODE     pNode,        // The current node in the path
    IN     PMXLLINE     pLine,        // The current line
    IN OUT LINELIST*    plistLines,   // The list of lines build so far
    IN     NODELIST     listDests     // The list of the destinations
);

///////////////////////////////////////////////////////////////////////
//
// kmxlIsDestinationNode
//
// Return TRUE if the given node appears in the node list of any
// of the destinations in listDests.
//
//

BOOL
kmxlIsDestinationNode(
    IN NODELIST listDests,              // The list of destinations
    IN PMXLNODE pNode                   // The node to check
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLine
//
// Duplicates the given line, including all controls on that line.
//
//

NTSTATUS
kmxlDuplicateLine(
    IN PMXLLINE* ppTargetLine,          // Pointer to the new line
    IN PMXLLINE  pSourceLine            // The line to duplicate
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLineControls
//
// Duplicate up to nCount controls on the source line and stores them
// into the target line.
//
//

NTSTATUS
kmxlDuplicateLineControls(
    IN PMXLLINE pTargetLine,            // The line to put the controls into
    IN PMXLLINE pSourceLine,            // The line with the controls to dup
    IN ULONG    nCount                  // The number of controls to dup
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestinationForNode
//
// For a given node, this function finds the destination it is assoicated
// with.  plistLines needs to be included since new lines will need to
// be created if a split is encountered in the topology.
//
//

ULONG
kmxlFindDestinationForNode(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pNode,             // The node to find dest for
    IN     PMXLNODE     pParent,           // The original parent
    IN     PMXLLINE     pLine,             // The current line it's on
    IN OUT LINELIST*    plistLines         // The list of all lines
);

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildVirtualMuxLine
//
//

NTSTATUS
kmxlBuildVirtualMuxLine(
    IN PMIXEROBJECT  pmxobj,
    IN PMXLNODE      pParent,
    IN PMXLNODE      pMux,
    IN OUT LINELIST* plistLines
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignLineAndControlIds
//
// For a specific set of lines, this function assigns the mixer line
// line Ids and controls Ids.  Only sources or only destinations can
// be assigned per call.
//
//

NTSTATUS
kmxlAssignLineAndControlIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST listLines,              // The list to assign ids for
    IN ULONG    ListType                // LIST_SOURCE or LIST_DESTINATION
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignDestinationsToSources
//
// For each line, the destination field of the MIXERLINE structure
// is filled in and a unique LineId is assigned.
//
//

NTSTATUS
kmxlAssignDestinationsToSources(
    IN LINELIST listSourceLines,        // The list of all source lines
    IN LINELIST listDestLines           // The list of all dest lines
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignMuxIds
//
//

NTSTATUS
kmxlAssignMuxIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST     listSourceLines
);

///////////////////////////////////////////////////////////////////////
//
// TranslateNodeToControl
//
// Translates the node specified by its GUID into 0 or more mixer
// line controls.  The return value indicates how many controls
// the node was really translated into.
//
//

ULONG
kmxlTranslateNodeToControl(
    IN  PMIXEROBJECT  pmxobj,
    IN  PMXLNODE      pNode,            // The node to translate into a control
    OUT PMXLCONTROL*  ppControl         // The control to fill in
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsControl
//
// Queries for property on control to see if it is actually supported
//
//

NTSTATUS
kmxlSupportsControl(
    IN PFILE_OBJECT pfoInstance,        // The instance to check for
    IN ULONG        Node,               // The node ID on the instance
    IN ULONG        Property            // The property to query support
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsMultiChannelControl
//
// Queries for property on the second channel of the control to see
// independent levels can be set.  It is assumed that the first channel
// already succeeded in kmxlSupportsControl
//
//

NTSTATUS
kmxlSupportsMultiChannelControl(
    IN PFILE_OBJECT pfoInstance,    // The instance to check for
    IN ULONG        Node,           // The node id to query
    IN ULONG        Property        // The property to check for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsTrebleControl
//
// Querys the node to see if it supports KSPROPERTY_AUDIO_TREBLE.
// See kmxlSupportsControl for return value details.
//
//

#define kmxlSupportsTrebleControl( pfo, Node ) \
    kmxlSupportsControl( pfo, Node, KSPROPERTY_AUDIO_TREBLE )

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsBassControl
//
// Querys the node to see if it supports KSPROPERTY_AUDIO_BASS.
// See kmxlSupportsControl for return value details.
//
//

#define kmxlSupportsBassControl( pfo, Node ) \
    kmxlSupportsControl( pfo, Node, KSPROPERTY_AUDIO_BASS )

///////////////////////////////////////////////////////////////////////
//
// kmxlUpdateDestinationConnectionCount
//
// Counts the number of sources mapping to a single destination and
// stores that value in the MIXERLINE.cConnections field for that
// destination.
//
//

NTSTATUS
kmxlUpdateDestintationConnectionCount(
    IN LINELIST listSourceLines,        // The list of sources
    IN LINELIST listDestLines           // The list of destinations
);

///////////////////////////////////////////////////////////////////////
//
// kmxlElminiateInvalidLines
//
// Loops through all the lines and eliminates the ones that are
// invalid by the IsValidLine() macro function test.
//
//

NTSTATUS
kmxlEliminateInvalidLines(
    IN LINELIST* listLines               // The list of sources
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignComponentIds
//
// For each source and destination line, it assignes the
// MIXERLINE.dwComonentType field for that line.
//
//

VOID
kmxlAssignComponentIds(
    IN PMIXEROBJECT pmxobj,             // Instance data
    IN LINELIST     listSourceLines,    // The list of source lines
    IN LINELIST     listDestLines       // The list of destination lines
);


///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineDestinationType
//
// Determines the dwComponentId and Target.dwType fields for the
// given line.  Determination is made by the MXLLINE.Type field.
//
//

ULONG
kmxlDetermineDestinationType(
    IN PMIXEROBJECT pmxobj,             // Instance data
    IN PMXLLINE     pLine               // The line to update
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineSourceType
//
// Determines the dwComponentId and Target.dwType fields for the
// given line.  Determination is made by the MXLLINE.Type field.
//
//

ULONG
kmxlDetermineSourceType(
    IN PMIXEROBJECT pmxobj,             // Instance data
    IN PMXLLINE     pLine               // The line to update
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                  U T I L I T Y  F U N C T I O N S                 //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlOpenSysAudio
//
// Opens the SysAudio device and returns the file object.
//
//

PFILE_OBJECT
kmxlOpenSysAudio(
);

///////////////////////////////////////////////////////////////////////
//
// kmxlCloseSysAudio
//
// Closes the SysAudio device opened by kmxlOpenSysAudio.
//
//

VOID
kmxlCloseSysAudio(
    IN PFILE_OBJECT pfo                 // The instance to close
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestination
//
// Finds a destination id in the list of all the destinations and returns
// a pointer to that node.  Returns NULL on failure.
//
//

PMXLNODE
kmxlFindDestination(
    IN NODELIST listDests,              // The list of destinations to search
    IN ULONG    Id                      // The node Id to look for in the list
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToList
//
// Appends listSource onto the front of plistTarget.
//
//

VOID
kmxlAppendListToList(
    IN OUT PSLIST* plistTarget,         // The list to append to
    IN     PSLIST  listSource           // the list to append
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToList
//
// Appends listSource onto the end of plistTarget
//
//


VOID
kmxlAppendListToEndOfList(
    IN OUT PSLIST* plistTarget,         // The list to append to
    IN     PSLIST  listSource           // the list to append
);

///////////////////////////////////////////////////////////////////////
//
// kmxlListCount
//
// Returns the number of elements in the list.
//
//

ULONG
kmxlListCount(
    IN PSLIST pList                     // The list to count the elements of
);

///////////////////////////////////////////////////////////////////////
//
// kmxlInList
//
// Return TRUE if pNewNode is in the list.
//
//

BOOL
kmxlInList(
    IN PEERLIST  list,                  // The list to search
    IN PMXLNODE  pNewNode               // The new to search for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAddElemToEndOfList
//
// Adds an element to the end of the given list.
//
//

VOID
kmxlAddElemToEndOfList(
    IN OUT PSLIST* list,                // The list to add to the end of
    IN PSLIST      elem                 // The element or list to add
);

///////////////////////////////////////////////////////////////////////
//
// kmxlInChildList
//
// Return TRUE if pNewNode is contained in the child list of the list.
//
//

BOOL
kmxlInChildList(
    IN NODELIST list,                   // The list to search the parent list
    IN PMXLNODE pNewNode                // The node to search for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlInParentList
//
// Returns TRUE if pNewNode is contained in the parent list of the list.
//
//

BOOL
kmxlInParentList(
    IN NODELIST list,                   // The list to search the parent list
    IN PMXLNODE pNewNode                // The node to search for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSortByDestination
//
// Sorts the given list by destination id in increasing order.
//
//

NTSTATUS
kmxlSortByDestination(
    IN LINELIST* list                   // The pointer to the list to sort
);

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLinearToLog
//
//

LONG
kmxlVolLinearToLog(
    IN PMXLCONTROL  pControl,
    IN DWORD        dwLin,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
);

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLogToLinear
//
//

DWORD
kmxlVolLogToLinear(
    IN PMXLCONTROL  pControl,
    IN LONG         lLog,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//    M E M O R Y  A L L O C A T I O N / D E A L L O C A T I O N     //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocMem
//
// Allocates size bytes and stores that pointer in pp.  Returns
// STATUS_SUCCESS or another STATUS failure code.
//
//

//NTSTATUS
//kmxlAllocMem(
//    IN PVOID *pp,                       // Pointer to put the new memory in
//    IN ULONG size,                      // The number of bytes to allocate
//    IN ULONG ultag
//);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocDeviceInfo
//

NTSTATUS kmxlAllocDeviceInfo(
    OUT LPDEVICEINFO *pp,
    PCWSTR DeviceInterface,
    DWORD dwFlags,
    ULONG ultag
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFreeMem
//
//
// Frees the memory pointed to by p.  Does nothing if p is NULL.
//
//

//VOID
//kmxlFreeMem(
//    IN PVOID p                          // The pointer to the buffer to free
//);

///////////////////////////////////////////////////////////////////////
//
// kmxlFreePeerList
//
// Loops through a peer list freeing all the peer nodes.
//
//

VOID
kmxlFreePeerList(
    IN PEERLIST list                    // The PeerList to free
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateControl
//
// Allocates and zero fills a new MXLCONTROL structure.
//
//

MXLCONTROL*
kmxlAllocateControl(
    IN ULONG ultag
);

VOID kmxlFreeControl(
    IN PMXLCONTROL pControl
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateLine
//
// Allocates and zero filles a new MXLLINE structure.
//
//

MXLLINE*
kmxlAllocateLine(
    IN ULONG ultag
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateNode
//
// Allocates and zero filles a new MXLNODE structure.
//
//

MXLNODE*
kmxlAllocateNode(
    IN ULONG ultag
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocatePeerNode
//
// Allocates and zero fills a new PEERNODE structure.
//
//

PEERNODE*
kmxlAllocatePeerNode(
    IN PMXLNODE pNode OPTIONAL,          // The node to associate with the peer
    IN ULONG ultag
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//             P E R S I S T A N C E  F U N C T I O N S              //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

NTSTATUS
kmxlOpenInterfaceKey(
    IN  PFILE_OBJECT pfo,
    IN  ULONG Device,
    OUT HANDLE* phKey
);

NTSTATUS
kmxlRegQueryValue(
    IN HANDLE  hKey,
    IN PWCHAR  szValueName,
    IN PVOID   pData,
    IN ULONG   cbData,
    OUT PULONG pResultLength
);




///////////////////////////////////////////////////////////////////////
//
// kmxlRegCloseKey
//
// Closes the given key and NULLs the pointer.
//
//

#define kmxlRegCloseKey( hKey ) \
    {                    \
        ZwClose( hKey ); \
        hKey = NULL;     \
    }


///////////////////////////////////////////////////////////////////////
//
// PinCategoryToString
//
// Translates a PinCategory GUID into a string.
//
//

const char*
PinCategoryToString
(
    IN CONST GUID* NodeType     // The node to translate
);


///////////////////////////////////////////////////////////////////////
//
// NodeTypeToString
//
// Translates a NodeType GUID to a string.
//
//

const char*
NodeTypeToString
(
    IN CONST GUID* NodeType     // The node to translate
);

#define ControlTypeToString( dwType )                                \
    (dwType) == MIXERCONTROL_CONTROLTYPE_BOOLEAN    ? "Boolean"        : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_ONOFF      ? "On Off"         : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MUTE       ? "Mute"           : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MONO       ? "Mono"           : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_LOUDNESS   ? "Loudness"       : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_STEREOENH  ? "Stereo Enhance" : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_VOLUME     ? "Volume"         : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_BASS       ? "Bass"           : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_TREBLE     ? "Treble"         : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_BASS_BOOST ? "Bass Boost"     : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_PEAKMETER  ? "Peakmeter"      : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MUX        ? "Mux"            : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MIXER      ? "Mixer"          : \
        "Unknown ControlType"

///////////////////////////////////////////////////////////////////////
//
// ComponentTypeToString
//
// Translates one of the MIXERLINE_COMPONENTTYPE constants to a string.
//
//

#define ComponentTypeToString( dwType )                                           \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_DIGITAL     ? "Digital line"        : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  ? "Headphones"          : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_LINE        ? "Line"                : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_MONITOR     ? "Monitor"             : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    ? "Speakers"            : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   ? "Telephone"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   ? "Undefined"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_VOICEIN     ? "Voicein"             : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_WAVEIN      ? "Wavein"              : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_ANALOG      ? "Analog line"         : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   ? "Auxiliary"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC ? "Compact disc"        : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     ? "Digital line"        : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_LINE        ? "Line"                : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  ? "Microphone"          : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   ? "PC Speaker"          : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER ? "Synthesizer"         : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   ? "Telephone"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   ? "Undefined"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     ? "Waveout"             : \
        "Unknown ComponentType"

///////////////////////////////////////////////////////////////////////
//
// TargetTypeToString
//
// Translates one of hte MIXERLINE_TARGETTYPE constants to a string.
//
//

#define TargetTypeToString( dwType )                            \
    (dwType) == MIXERLINE_TARGETTYPE_AUX       ? "Aux"       :  \
    (dwType) == MIXERLINE_TARGETTYPE_MIDIIN    ? "MidiIn"    :  \
    (dwType) == MIXERLINE_TARGETTYPE_MIDIOUT   ? "MidiOut"   :  \
    (dwType) == MIXERLINE_TARGETTYPE_UNDEFINED ? "Undefined" :  \
    (dwType) == MIXERLINE_TARGETTYPE_WAVEIN    ? "WaveIn"    :  \
    (dwType) == MIXERLINE_TARGETTYPE_WAVEOUT   ? "WaveOut"   :  \
        "Unknown TargetType"

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               D E B U G  O N L Y  F U N C T I O N S               //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#ifdef DEBUG

///////////////////////////////////////////////////////////////////////
//
// LineFlagsToString
//
// Converts on of the MIXERLINE_LINEF flags to a string.
//
//

#define LineFlagsToString( fdwFlags )                               \
    ( fdwFlags & MIXERLINE_LINEF_ACTIVE )       ? "ACTIVE "       : \
    ( fdwFlags & MIXERLINE_LINEF_DISCONNECTED ) ? "DISCONNECTED " : \
    ( fdwFlags & MIXERLINE_LINEF_SOURCE       ) ? "SOURCE "       : \
        "Unknown"


///////////////////////////////////////////////////////////////////////
//
// DumpChildGraph
//
// For a given node, it dumps the child of that node onto the debug
// monitor.  CurrentIndent is the number of spaces to indent before
// display.
//
//

VOID
DumpChildGraph(
    IN PMXLNODE pNode,          // The node to display the children of
    IN ULONG    CurrentIndent   // The number of spaces to ident
);

///////////////////////////////////////////////////////////////////////
//
// DumpMemList
//
// Dumps the list of currently allocated memory blocks.
//
//

VOID
DumpMemList(
);

#endif // DEBUG

VOID GetHardwareEventData(LPDEVICEINFO pDeviceInfo);

#endif // _MIXER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\persist.c ===
//---------------------------------------------------------------------------
//
//  Module:   persist.c
//
//  Description:
//
//    Contains the routines that persist the mixer line driver settings.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "WDMSYS.H"
#include "kmxluser.h"

///////////////////////////////////////////////////////////////////////
//
// kmxlGetInterfaceName
//
//

NTSTATUS
kmxlGetInterfaceName(
    IN  PFILE_OBJECT pfo,
    IN  ULONG        Device,
    OUT PWCHAR*      pszInterfaceName
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    Size;
    WCHAR*   szInterfaceName = NULL;

    PAGED_CODE();
    ASSERT( pfo );

    //
    // Retrieve the size of the internface name.
    //

    Status = GetSysAudioProperty(
        pfo,
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
        Device,
        sizeof( Size ),
        &Size
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_PERSIST,("GetSysAudioProperty failed Status=%X",Status) );
        goto exit;
    }

    //
    // Allocate enough memory to hold the interface name
    //

    Status = AudioAllocateMemory_Paged(Size,
                                       TAG_Audp_NAME,
                                       ZERO_FILL_MEMORY | LIMIT_MEMORY,
                                       &szInterfaceName );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    ASSERT( szInterfaceName );

    //
    // Retieve the interface name for this device.
    //

    Status = GetSysAudioProperty(
        pfo,
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
        Device,
        Size,
        szInterfaceName
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_PERSIST,("GetSysAudioProperty failed Status=%X",Status) );
        goto exit;
    }

exit:

    if( !NT_SUCCESS( Status ) ) {
        AudioFreeMemory_Unknown( &szInterfaceName );
    } else {
        *pszInterfaceName = szInterfaceName;
    }
    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlOpenInterfaceKey
//
//

NTSTATUS
kmxlOpenInterfaceKey(
    IN  PFILE_OBJECT pfo,
    IN  ULONG Device,
    OUT HANDLE* phKey
)
{
    NTSTATUS       Status;
    HANDLE         hKey;
    WCHAR*         szName;
    UNICODE_STRING ustr;

    PAGED_CODE();
    Status = kmxlGetInterfaceName( pfo, Device, &szName );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_PERSIST,("kmxlGetInterfaceName failed Status=%X",Status) );
        RETURN( Status );
    }

    RtlInitUnicodeString( &ustr, szName );

    Status = IoOpenDeviceInterfaceRegistryKey(
        &ustr,
        KEY_ALL_ACCESS,
        &hKey
        );
    if( !NT_SUCCESS( Status ) ) {
        AudioFreeMemory_Unknown( &szName );
        RETURN( Status );
    }

    *phKey = hKey;
    AudioFreeMemory_Unknown( &szName );
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegCreateKey
//
//

NTSTATUS
kmxlRegCreateKey(
    IN HANDLE hRootKey,
    IN PWCHAR szKeyName,
    OUT PHANDLE phKey
)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    ustr;
    ULONG             Disposition;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szKeyName );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &ustr,
        OBJ_KERNEL_HANDLE,      // Attributes
        hRootKey,
        NULL    // Security
        );

    return( ZwCreateKey(
            phKey,
            KEY_ALL_ACCESS,
            &ObjectAttributes,
            0,                  // TitleIndex
            NULL,               // Class
            REG_OPTION_NON_VOLATILE,
            &Disposition
            )
        );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegOpenKey
//
//

NTSTATUS
kmxlRegOpenKey(
    IN HANDLE hRootKey,
    IN PWCHAR szKeyName,
    OUT PHANDLE phKey
)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ustr;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szKeyName );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &ustr,
        OBJ_KERNEL_HANDLE,
        hRootKey,
        NULL
        );

    return( ZwOpenKey(
        phKey,
        KEY_ALL_ACCESS,
        &ObjectAttributes
        )
    );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegSetValue
//
//

NTSTATUS
kmxlRegSetValue(
    IN HANDLE hKey,
    IN PWCHAR szValueName,
    IN ULONG  Type,
    IN PVOID  pData,
    IN ULONG  cbData
)
{
    UNICODE_STRING ustr;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szValueName );
    return( ZwSetValueKey(
            hKey,
            &ustr,
            0,
            Type,
            pData,
            cbData
            )
        );

}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegQueryValue
//
//

NTSTATUS
kmxlRegQueryValue(
    IN HANDLE  hKey,
    IN PWCHAR  szValueName,
    IN PVOID   pData,
    IN ULONG   cbData,
    OUT PULONG pResultLength
)
{
    NTSTATUS Status;
    UNICODE_STRING ustr;
    KEY_VALUE_FULL_INFORMATION FullInfoHeader;
    PKEY_VALUE_FULL_INFORMATION FullInfoBuffer = NULL;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szValueName );
    Status = ZwQueryValueKey(
        hKey,
        &ustr,
        KeyValueFullInformation,
        &FullInfoHeader,
        sizeof( FullInfoHeader ),
        pResultLength
        );
    if( !NT_SUCCESS( Status ) ) {

        if( Status == STATUS_BUFFER_OVERFLOW ) {

            if( !NT_SUCCESS( AudioAllocateMemory_Paged(*pResultLength, 
                                                       TAG_AudA_PROPERTY,
                                                       ZERO_FILL_MEMORY,
                                                       &FullInfoBuffer ) ) ) 
            {            
                RETURN( STATUS_INSUFFICIENT_RESOURCES );
            }

            Status = ZwQueryValueKey(
                hKey,
                &ustr,
                KeyValueFullInformation,
                FullInfoBuffer,
                *pResultLength,
                pResultLength
                );

            if( NT_SUCCESS( Status ) ) {
                RtlCopyMemory(
                    pData,
                    (PUCHAR) FullInfoBuffer + FullInfoBuffer->DataOffset,
                    cbData
                    );
            }

            AudioFreeMemory_Unknown( &FullInfoBuffer );
        }
    }

    DPFRETURN( Status,(2,Status,STATUS_OBJECT_NAME_NOT_FOUND) );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegOpenMixerKey
//
//

NTSTATUS
kmxlRegOpenMixerKey(
    IN PFILE_OBJECT pfo,
    IN PMIXERDEVICE pmxd,
    OUT PHANDLE     phMixerKey
)
{
    NTSTATUS Status;
    HANDLE   hKey;

    PAGED_CODE();
    Status = kmxlOpenInterfaceKey( pfo, pmxd->Device, &hKey );
    if( !NT_SUCCESS( Status ) ) {
        RETURN( Status );
    }

    Status = kmxlRegOpenKey( hKey, MIXER_KEY_NAME, phMixerKey );
    if( NT_SUCCESS( Status ) ) {
        kmxlRegCloseKey( hKey );
    }
    RETURN( Status );

}


///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestById
//
//

PMXLLINE
kmxlFindDestById(
    IN LINELIST listLines,
    IN ULONG    LineId
)
{
    PMXLLINE pLine;

    PAGED_CODE();
    pLine = kmxlFirstInList( listLines );
    while( pLine ) {
        if( pLine->Line.dwLineID == LineId ) {
            return( pLine );
        }
        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}


extern instancereleasedcount;

///////////////////////////////////////////////////////////////////////
//
//
//

NTSTATUS
kmxlGetCurrentControlValue(
    IN PFILE_OBJECT pfo,        // The instance to persist for
    IN PMIXERDEVICE pmxd,
    IN PMXLLINE     pLine,
    IN PMXLCONTROL  pControl,   // The control to retrieve
    OUT PVOID*      ppaDetails
)
{
    NTSTATUS                      Status;
    LPDEVICEINFO                  pDevInfo = NULL;
    MIXERCONTROLDETAILS           mcd;
    PMIXERCONTROLDETAILS_UNSIGNED paDetails = NULL;
    ULONG                         Index;
    ULONG                         Devices;


    PAGED_CODE();
    *ppaDetails = NULL;

    //
    // Initialize a Device Info structure to make the query look like
    // it comes from user mode.
    //
    Status = kmxlAllocDeviceInfo(&pDevInfo, pmxd->DeviceInterface, MIXER_GETCONTROLDETAILSF_VALUE, TAG_AudD_DEVICEINFO );
    if (!NT_SUCCESS(Status)) {
        RETURN( Status );
    }

    for( Devices = 0, Index = 0; Devices < MAXNUMDEVS; Devices++ ) {

        if( pmxd == &pmxd->pWdmaContext->MixerDevs[ Devices ] ) {
            pDevInfo->DeviceNumber = Index;
            break;
        }

        if ( !MyWcsicmp(pmxd->DeviceInterface, pmxd->pWdmaContext->MixerDevs[ Devices ].DeviceInterface) ) {
            Index++;
        }

    }

    //
    // Create an MIXERCONTROLDETAILS structure for this query.
    //
    RtlZeroMemory( &mcd, sizeof( MIXERCONTROLDETAILS ) );
    mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
    mcd.dwControlID    = pControl->Control.dwControlID;
    mcd.cMultipleItems = pControl->Control.cMultipleItems;
    mcd.cChannels      = pControl->NumChannels;

    if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
        Status = AudioAllocateMemory_Paged(mcd.cMultipleItems * sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                           TAG_Audd_DETAILS,
                                           ZERO_FILL_MEMORY,
                                           &paDetails );
        mcd.cbDetails      = mcd.cMultipleItems * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    } else {
        Status = AudioAllocateMemory_Paged(mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                           TAG_Audd_DETAILS,
                                           ZERO_FILL_MEMORY,
                                           &paDetails );
        mcd.cbDetails      = mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    }

    if (NT_SUCCESS(Status))
    {
        mcd.paDetails      = paDetails;

        //
        // Make the actual query call.
        //
        Status = kmxlGetControlDetailsHandler(pmxd->pWdmaContext, pDevInfo, &mcd, paDetails);

        if( NT_SUCCESS( Status ) ) {
            *ppaDetails = paDetails;
        } else {
            AudioFreeMemory_Unknown( &paDetails );
        }
    }

    AudioFreeMemory_Unknown( &pDevInfo );
    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
//
//

NTSTATUS
kmxlSetCurrentControlValue(
    IN PFILE_OBJECT pfo,        // The instance to persist for
    IN PMIXERDEVICE pmxd,
    IN PMXLLINE     pLine,
    IN PMXLCONTROL  pControl,   // The control to retrieve
    IN PVOID        paDetails
)
{
    NTSTATUS                      Status;
    LPDEVICEINFO                  pDevInfo = NULL;
    MIXERCONTROLDETAILS           mcd;
    ULONG                         Index;
    ULONG                         Devices;

    PAGED_CODE();
    //
    // Initialize a Device Info structure to make the query look like
    // it comes from user mode.
    //
    Status = kmxlAllocDeviceInfo(&pDevInfo, pmxd->DeviceInterface, MIXER_SETCONTROLDETAILSF_VALUE, TAG_AudD_DEVICEINFO );
    if (!NT_SUCCESS(Status)) RETURN( Status );

    for( Devices = 0, Index = 0;
         Devices < MAXNUMDEVS;
         Devices++ ) {

        if( pmxd == &pmxd->pWdmaContext->MixerDevs[ Devices ] ) {
            pDevInfo->DeviceNumber = Index;
            break;
        }

        if ( !MyWcsicmp(pmxd->DeviceInterface, pmxd->pWdmaContext->MixerDevs[ Devices ].DeviceInterface) ) {
            Index++;
        }
    }

    //
    // Create an MIXERCONTROLDETAILS structure for this query.
    //
    RtlZeroMemory( &mcd, sizeof( MIXERCONTROLDETAILS ) );
    mcd.cMultipleItems   = pControl->Control.cMultipleItems;
    mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
    mcd.dwControlID    = pControl->Control.dwControlID;
    mcd.cChannels      = pControl->NumChannels;    
    //
    // For a MUX, we know that NumChannels will be zero and cChannels will be zero.
    //
    if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
        mcd.cbDetails      = mcd.cMultipleItems * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    } else {
        mcd.cbDetails      = mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    }
    mcd.paDetails      = paDetails;

    //
    // Make the actual query call.
    //
    Status = kmxlSetControlDetailsHandler( pmxd->pWdmaContext,
                       pDevInfo,
                       &mcd,
                       paDetails,
                       0
                     );

    //
    // workitem:  Should map the error code here for invalid topologies!
    //
    AudioFreeMemory_Unknown(&pDevInfo);
    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistAll
//
//

NTSTATUS
kmxlPersistAll(
    IN PFILE_OBJECT pfo,        // The instance to persist
    IN PMIXERDEVICE pmxd
)
{
    NTSTATUS          Status = STATUS_SUCCESS;
    HANDLE            hKey = NULL,
                      hMixerKey = NULL,
                      hLineKey = NULL,
                      hAllControlsKey = NULL,
                      hControlKey = NULL;
    WCHAR             sz[ 16 ];
    ULONG             LineNum,
                      ControlNum,
                      i,
                      Channels;
    PMXLLINE          pLine;
    PMXLCONTROL       pControl;
    PVOID             paDetails;
    PCHANNEL_STEPPING pChannelStepping;
    BOOL              bValidMultichannel;

    PAGED_CODE();

    ASSERT( pfo );
    ASSERT( pmxd );

    Status = kmxlOpenInterfaceKey( pfo, pmxd->Device, &hKey );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    Status = kmxlRegCreateKey(
        hKey,
        MIXER_KEY_NAME,
        &hMixerKey
        );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    kmxlRegCloseKey( hKey );

    i = kmxlListLength( pmxd->listLines );
    kmxlRegSetValue(
        hMixerKey,
        LINE_COUNT_VALUE_NAME,
        REG_DWORD,
        &i,
        sizeof( i )
        );

    LineNum = 0;
    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        //
        // Store the line id as the key
        //

        swprintf( sz, LINE_KEY_NAME_FORMAT, LineNum++ );
        Status = kmxlRegCreateKey(
            hMixerKey,
            sz,
            &hLineKey
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_PERSIST,("kmxlRegCreateKey failed Status=%X",Status) );
            goto exit;
        }

        kmxlRegSetValue(
            hLineKey,
            LINE_ID_VALUE_NAME,
            REG_DWORD,
            &pLine->Line.dwLineID,
            sizeof( pLine->Line.dwLineID )
            );

        //
        // Save the number of controls underneath the line id key
        //

        kmxlRegSetValue(
            hLineKey,
            CONTROL_COUNT_VALUE_NAME,
            REG_DWORD,
            &pLine->Line.cControls,
            sizeof( pLine->Line.cControls )
            );

        //
        // Save the source pin Id underneath the line id key
        //

        kmxlRegSetValue(
            hLineKey,
            SOURCE_ID_VALUE_NAME,
            REG_DWORD,
            &pLine->SourceId,
            sizeof( pLine->SourceId )
            );

        //
        // Save the destination pin Id underneath the line id key
        //

        kmxlRegSetValue(
            hLineKey,
            DEST_ID_VALUE_NAME,
            REG_DWORD,
            &pLine->DestId,
            sizeof( pLine->DestId )
            );

        //
        // Create the Controls key to store all the controls under
        //

        Status = kmxlRegCreateKey(
            hLineKey,
            CONTROLS_KEY_NAME,
            &hAllControlsKey
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_PERSIST,("kmxlRegCreateKey failed Status=%X",Status) );
            goto exit;
        }

        kmxlRegCloseKey( hLineKey );

        //
        // Persist all the controls underneath the controls key
        //

        ControlNum = 0;
        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {

            swprintf( sz, CONTROL_KEY_NAME_FORMAT, ControlNum++ );
            Status = kmxlRegCreateKey(
                hAllControlsKey,
                sz,
                &hControlKey
                );
            if( !NT_SUCCESS( Status ) ) {
                DPF(DL_WARNING|FA_PERSIST,("kmxlRegCreateKey failed Status=%X",Status) );
                goto exit;
            }

            kmxlRegSetValue(
                hControlKey,
                CONTROL_TYPE_VALUE_NAME,
                REG_DWORD,
                &pControl->Control.dwControlType,
                sizeof( pControl->Control.dwControlType )
                );

            kmxlRegSetValue(
                hControlKey,
                CONTROL_MULTIPLEITEMS_VALUE_NAME,
                REG_DWORD,
                &pControl->Control.cMultipleItems,
                sizeof( pControl->Control.cMultipleItems )
                );

            //
            // As in kmxlRetrieveAll, this code should be in the control creation
            // code path as well as here.  We should never write anything to the registry
            // that doesn't conform to what we understand.
            //
            if (pControl->pChannelStepping) {

                pChannelStepping = pControl->pChannelStepping;
                for (i = 0; i < pControl->NumChannels; i++, pChannelStepping++) {
                    /*
                    ASSERT ( pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536 );
                    ASSERT ( pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536 );
                    ASSERT ( pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535 );
                    */

                    if (!(pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536)) {
                        DPF(DL_WARNING|FA_PERSIST,
                            ("MinValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                            pChannelStepping->MinValue,
                            pControl->Control.dwControlID,
                            pControl->Control.dwControlType,
                            pLine->Line.dwLineID,
                            i) );
                        pChannelStepping->MinValue = DEFAULT_RANGE_MIN;
                    }
                    if (!(pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536)) {
                        DPF(DL_WARNING|FA_PERSIST,
                            ("MaxValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                            pChannelStepping->MaxValue,
                            pControl->Control.dwControlID,
                            pControl->Control.dwControlType,
                            pLine->Line.dwLineID,
                            i) );
                        pChannelStepping->MaxValue = DEFAULT_RANGE_MAX;
                    }
                    if (!(pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535)) {
                        DPF(DL_WARNING|FA_PERSIST,
                            ("Steps %X of Control %X of type %X on Line %X Channel %X is out of range!",
                            pChannelStepping->Steps,
                            pControl->Control.dwControlID,
                            pControl->Control.dwControlType,
                            pLine->Line.dwLineID,
                            i) );
                        pChannelStepping->Steps    = DEFAULT_RANGE_STEPS;
                        pControl->Control.Metrics.cSteps = DEFAULT_RANGE_STEPS;
                    }
                }
            }

            Status = kmxlGetCurrentControlValue(
                pfo,
                pmxd,
                pLine,
                pControl,
                &paDetails
                );

            if( NT_SUCCESS( Status ) ) {

                if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {

                    for( i = 0; i < pControl->Control.cMultipleItems; i++ ) {
                        swprintf( sz, MULTIPLEITEM_VALUE_NAME_FORMAT, i );

                        Status = kmxlRegSetValue(
                            hControlKey,
                            sz,
                            REG_DWORD,
                            &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                            sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                            );
                        if( !NT_SUCCESS( Status ) ) {
                            AudioFreeMemory_Unknown( &paDetails );
                            DPF(DL_WARNING|FA_PERSIST,("KmxlRegSetValue failed Status=%X",Status) );
                            goto exit;
                        }

                    }


                } else {

                    Channels = pControl->NumChannels;

                    kmxlRegSetValue(
                        hControlKey,
                        CHANNEL_COUNT_VALUE_NAME,
                        REG_DWORD,
                        &Channels,
                        sizeof( Channels )
                        );

                    for( i = 0; i < Channels; i++ ) {
                        swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, i );

                        Status = kmxlRegSetValue(
                            hControlKey,
                            sz,
                            REG_DWORD,
                            &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                            sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                            );
                        if( !NT_SUCCESS( Status ) ) {
                            AudioFreeMemory_Unknown( &paDetails );
                            DPF(DL_WARNING|FA_PERSIST,("KmxlRegSetValue failed Status=%X",Status) );
                            goto exit;
                        }
                    }
                }
                AudioFreeMemory_Unknown( &paDetails );
            }

            kmxlRegCloseKey( hControlKey );
            pControl = kmxlNextControl( pControl );
        }

        kmxlRegCloseKey( hAllControlsKey );
        pLine = kmxlNextLine( pLine );
    }

    //
    //  After all of the persisting is done, save out a value indicating that the channel
    //  values are all valid for a multichannel restore.  This is to avoid the situation
    //  where the data for some of the channels is invalid.
    //
    bValidMultichannel = TRUE;
    kmxlRegSetValue(
        hMixerKey,
        VALID_MULTICHANNEL_MIXER_VALUE_NAME,
        REG_DWORD,
        &bValidMultichannel,
        sizeof( bValidMultichannel )
        );

    kmxlRegCloseKey( hMixerKey );

exit:

    if( hControlKey ) {
        kmxlRegCloseKey( hControlKey );
    }

    if( hAllControlsKey ) {
        kmxlRegCloseKey( hAllControlsKey );
    }

    if( hLineKey ) {
        kmxlRegCloseKey( hLineKey );
    }

    if( hMixerKey ) {
        kmxlRegCloseKey( hMixerKey );
    }

    if( hKey ) {
        kmxlRegCloseKey( hKey );
    }

    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRetrieveAll
//
//

NTSTATUS
kmxlRetrieveAll(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd        // Mixer device info
)
{
    NTSTATUS    Status;
    WCHAR       sz[ 16 ];
    HANDLE      hMixerKey = NULL,
                hLineKey = NULL,
                hAllControlsKey = NULL,
                hControlKey = NULL;
    ULONG       ResultLength, Value, NumChannels, ControlCount;
    ULONG       LineCount = 0;
    ULONG       i,j;
    BOOL        bInvalidTopology = FALSE;
    PMXLLINE    pLine;
    PMXLCONTROL pControl;
    MIXERCONTROLDETAILS_UNSIGNED* paDetails = NULL;
    PCHANNEL_STEPPING pChannelStepping;
    BOOL              bValidMultichannel = FALSE;

    PAGED_CODE();
    //
    // Open the Mixer key under the interface key.  If somethings goes
    // wrong here, this does not have a valid topology.
    //

    Status = kmxlRegOpenMixerKey( pfo, pmxd, &hMixerKey );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_TRACE|FA_PERSIST,( "failed to open mixer reg key!" ) );
        bInvalidTopology = TRUE;
        goto exit;
    } // if

    //
    //  Query for a valid multichannel mixer persistance
    //
    Status = kmxlRegQueryValue(
        hMixerKey,
        VALID_MULTICHANNEL_MIXER_VALUE_NAME,
        &bValidMultichannel,
        sizeof( bValidMultichannel ),
        &ResultLength
        );
    if( !NT_SUCCESS( Status ) ) {
        //  This should be set to FALSE for upgrades from Win2000 where the registry
        //  entries could be invalid for channels other than the first channel.
        bValidMultichannel = FALSE;
    } // if

    //
    // Query the total number of lines that have been persisted.
    //

    Status = kmxlRegQueryValue(
        hMixerKey,
        LINE_COUNT_VALUE_NAME,
        &LineCount,
        sizeof( LineCount ),
        &ResultLength
        );
    if( !NT_SUCCESS( Status ) ) {    
        DPF(DL_TRACE|FA_PERSIST,( "failed to read number of persisted lines!" ) );        
        bInvalidTopology = TRUE;
        goto exit;
    } // if

    //
    // Check to ensure the number of lines persisted is the same as
    // what is stored in memory.
    //

    if( LineCount != kmxlListLength( pmxd->listLines ) ) {
        DPF(DL_TRACE|FA_PERSIST,( "# of persisted lines does not match current topology!" ) );
        bInvalidTopology = TRUE;
        goto exit;
    } // if

    for( i = 0; i < LineCount; i++ ) {

        //
        // Construct the line key name and open the key.
        //

        swprintf( sz, LINE_KEY_NAME_FORMAT, i );
        Status = kmxlRegOpenKey(
            hMixerKey,
            sz,
            &hLineKey
            );
        if( !NT_SUCCESS( Status ) ) {
            break;
        } // if

        //
        // Query the line Id of this line.
        //

        Status = kmxlRegQueryValue(
            hLineKey,
            LINE_ID_VALUE_NAME,
            &Value,
            sizeof( Value ),
            &ResultLength
            );
        if( !NT_SUCCESS( Status ) ) {
            continue;
        } // if

        //
        // Verify the line Id is valid and retrieve a pointer to the line
        // structure.
        //

        pLine = kmxlFindDestById( pmxd->listLines, Value );
        if( pLine == NULL ) {
            DPF(DL_TRACE|FA_PERSIST,( "persisted line ID is invalid!" ) );
            bInvalidTopology = TRUE;
            break;
        } // if

        //
        // Retrieve the number of controls for this line.
        //

        Status = kmxlRegQueryValue(
            hLineKey,
            CONTROL_COUNT_VALUE_NAME,
            &Value,
            sizeof( Value ),
            &ResultLength
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlRegCloseKey( hLineKey );
            continue;
        } // if

        if( Value != pLine->Line.cControls ) {
            DPF(DL_TRACE|FA_PERSIST,( "the number of controls for line %x is invalid!",
                pLine->Line.dwLineID
                ) );
            bInvalidTopology = TRUE;
            break;
        } // if

        Status = kmxlRegOpenKey(
            hLineKey,
            CONTROLS_KEY_NAME,
            &hAllControlsKey
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlRegCloseKey( hLineKey );
            continue;
        } // if

        //
        // Query all the information for each control
        //

        ControlCount = 0;
        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {

            swprintf( sz, CONTROL_KEY_NAME_FORMAT, Control