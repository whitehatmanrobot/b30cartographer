or (i=0; i<STAT_ITEM_CNT-1; i++, pItem++) {
        pItem->dValue = pItem->dNewValue = 0.0;
        pItem->iInitialized = 0;
    }
}       

void CStatsBar::Draw (HDC hDC, HDC /* hAttribDC */, PRECT prcUpdate)
{
    RECT    rectFrame;
    PSTAT_ITEM  pItem;
    HFONT   hFontOld;
    INT     i;
    RECT    rectPaint;
    RECT    rectClip;

    // if no space assigned, return
    if (m_Rect.top == m_Rect.bottom)
        return;

    // if no painting needed, return
    if (!IntersectRect(&rectPaint, &m_Rect, prcUpdate))
        return;

    SetBkMode(hDC, TRANSPARENT);
    SetTextColor(hDC, m_pCtrl->clrFgnd());
    SetTextAlign(hDC, TA_LEFT|TA_TOP);

    hFontOld = SelectFont(hDC, m_pCtrl->Font());

    pItem = &m_StatItem[0];

    // If the stat bar was hidden on Update, for example if 
    // the control was loaded from a property bag, or if a 
    // counter was selected while the stat bar was hidden,
    // initialize it here.
    if ( 0 == pItem->iInitialized ) {
        Update ( NULL, m_pGraphItemToInit );
    }

    // Draw Label and 3D box for each item
    for (i=0; i<STAT_ITEM_CNT; i++, pItem++) {

        rectClip.top = m_Rect.top + pItem->yPos + RECT_BORDER;
        rectClip.bottom = rectClip.top + m_iFontHeight;
        rectClip.left = m_Rect.left + pItem->xPos;
        rectClip.right = rectClip.left + pItem->xLabelWidth;

        ExtTextOut(
            hDC, 
            m_Rect.left + pItem->xPos, 
            m_Rect.top + pItem->yPos + RECT_BORDER,
            0,
            &rectClip,
            aszItemLabel[i], 
            lstrlen(aszItemLabel[i]),
            NULL );
                 
        if ( eAppear3D == m_pCtrl->Appearance() ) {
            rectFrame.left = m_Rect.left + pItem->xPos + pItem->xLabelWidth + VALUE_MARGIN;
            rectFrame.right = rectFrame.left + m_iValueWidth + 2 * RECT_BORDER;
            rectFrame.top = m_Rect.top + pItem->yPos;
            rectFrame.bottom = rectFrame.top + m_iFontHeight + 2 * RECT_BORDER;
            DrawEdge(hDC, &rectFrame, BDR_SUNKENOUTER, BF_RECT);
        }
    }

    SelectFont(hDC, hFontOld);

    SetBkMode(hDC, OPAQUE);
    SetBkColor(hDC, m_pCtrl->clrBackCtl());
    DrawValues(hDC, TRUE);
}


void CStatsBar::DrawValues(HDC hDC, BOOL bForce)
{
    RECT    rectValue ;
    TCHAR   szValue [20] ;
    HFONT   hFontOld;
    PSTAT_ITEM  pItem;
    INT     i;
    INT     nSecs, nMins, nHours, nDays;

    SetTextAlign(hDC, TA_RIGHT | TA_TOP);
    hFontOld = SelectFont(hDC, m_pCtrl->Font());

    pItem = &m_StatItem[0];
    for (i=0; i<STAT_ITEM_CNT; i++,pItem++) {
        if ((pItem->dValue == pItem->dNewValue) && !bForce)
            continue;

        pItem->dValue = pItem->dNewValue;

        rectValue.top = m_Rect.top + pItem->yPos + RECT_BORDER;
        rectValue.bottom = rectValue.top + m_iFontHeight;
        rectValue.left = m_Rect.left + pItem->xPos + pItem->xLabelWidth + VALUE_MARGIN + RECT_BORDER;
        rectValue.right = rectValue.left + m_iValueWidth - 1;

        if (i == STAT_TIME) {
            LPTSTR  pszTimeSep = NULL;

            pszTimeSep = GetTimeSeparator ( );

            nSecs = (INT)pItem->dValue;

            nMins = nSecs / 60;
            nSecs -= nMins * 60;

            nHours = nMins / 60;
            nMins -= nHours * 60;

            nDays = nHours / 24;
            nHours -= nDays * 24;

            if (nDays != 0) {
                _stprintf(szValue, SZ_DAYTIME_FORMAT, nDays, nHours, pszTimeSep, nMins);
            } else {
                if (nHours != 0)
                    _stprintf(szValue, SZ_HRTIME_FORMAT, nHours, pszTimeSep, nMins, pszTimeSep, nSecs);
                else
                    _stprintf(szValue, SZ_MINTIME_FORMAT, nMins, pszTimeSep, nSecs);
            }
        } else {

            if (pItem->dValue > E_MEDIUM_VALUE) {
                if (pItem->dValue > E_TOO_LARGE_VALUE) {
                    lstrcpy (szValue, SZ_VALUE_TOO_HIGH) ;
                } else {

                    if ( pItem->dValue <= E_LARGE_VALUE ) {

                        FormatNumber (
                            pItem->dValue,
                            szValue,
                            20,
                            eMinimumWidth,
                            eMediumPrecision );

                    } else {

                        FormatScientific (
                            pItem->dValue,
                            szValue,
                            20,
                            eMinimumWidth,
                            eLargePrecision );
                    }
                }

            } else if (pItem->dValue < -E_MEDIUM_VALUE) {
                if (pItem->dValue < -E_TOO_LARGE_VALUE) {
                    lstrcpy (szValue, SZ_VALUE_TOO_LOW) ;
                } else {
                    if ( pItem->dValue >= -E_LARGE_VALUE ) {
                        FormatNumber (
                            pItem->dValue,
                            szValue,
                            20,
                            eMinimumWidth,
                            eMediumPrecision );
                    } else {
                        FormatScientific (
                            pItem->dValue,
                            szValue,
                            20,
                            eMinimumWidth,
                            eLargePrecision );
                    }
                }
            } else {
                if ( ( m_StatItem[0].dwCounterType & 
                        ( PERF_TYPE_COUNTER | PERF_TYPE_TEXT ) ) ) {
                    FormatNumber (
                        pItem->dValue,
                        szValue,
                        20,
                        eMinimumWidth,
                        eSmallPrecision );
                } else {
                    FormatNumber (
                        pItem->dValue,
                        szValue,
                        20,
                        eMinimumWidth,
                        eIntegerPrecision );
                }
            }
        }

        //          TextOut (hDC, rectValue.right, rectValue.top, szValue, lstrlen (szValue)) ;

        ExtTextOut (hDC, rectValue.right, rectValue.top, ETO_OPAQUE, &rectValue,
                     szValue, lstrlen (szValue), NULL) ;
    }

    SelectFont(hDC, hFontOld);
}



INT  CStatsBar::Height (INT iMaxHeight, INT iMaxWidth)
{
    INT iHeight;
    INT xPos,yPos;
    PSTAT_ITEM  pItem;
    INT  i,j;
    INT  iItemWidth;
    INT  iFirst;
    INT  iRemainder;

    iMaxWidth -= 2 * RECT_BORDER;
    xPos = 0;
    yPos = 0;
    iFirst = 0;
    pItem = &m_StatItem[0];

    for (i=0; i<STAT_ITEM_CNT; i++,pItem++) {

        iItemWidth = pItem->xLabelWidth + VALUE_MARGIN + m_iValueWidth;
        if (iItemWidth > iMaxWidth)
            return 0;

        if (xPos + iItemWidth > iMaxWidth) {
            iRemainder = iMaxWidth - xPos + LABEL_MARGIN;
            xPos = 0;
            yPos += m_iFontHeight + LINE_SPACING;

            for (j=iFirst; j<i; j++) {
                m_StatItem[j].xPos += iRemainder;
            }
            iFirst = i;
        }

        pItem->xPos = xPos;
        pItem->yPos = yPos;
        xPos += (iItemWidth + LABEL_MARGIN);
    }

    iRemainder = (iMaxWidth - xPos) + LABEL_MARGIN;
    for (j=iFirst; j<STAT_ITEM_CNT; j++) {
        m_StatItem[j].xPos += iRemainder;
        }

    // if allowed height is not enough, return zero
    iHeight = yPos + m_iFontHeight + 2 * RECT_BORDER;

    return (iHeight <= iMaxHeight) ? iHeight : 0;
}



void CStatsBar::ChangeFont(
    HDC hDC
    )
{
    INT         xPos,yPos;
    TCHAR       szValue[20];
    HFONT       hFontOld;
    PSTAT_ITEM  pItem;
    INT         i;
    SIZE        size;

    hFontOld = (HFONT)SelectFont(hDC, m_pCtrl->Font());

    // Get width/height of longest value string
    FormatNumber (
        E_LARGE_VALUE,
        szValue,
        20,
        eMinimumWidth,
        eLargePrecision );

    GetTextExtentPoint32(hDC, szValue, lstrlen(szValue), &size);  
    m_iValueWidth = size.cx;
    m_iFontHeight = size.cy;

    // Do for all stat items
    xPos = 0;
    yPos = 0;
    pItem = &m_StatItem[0];

    for (i=0; i<STAT_ITEM_CNT; i++,pItem++) {
        pItem->xLabelWidth = TextWidth(hDC, aszItemLabel[i]);
    }

    SelectFont(hDC, hFontOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\stepper.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    stepper.h

Abstract:

    <abstract>

--*/

#ifndef _STEPPER_H_
#define _STEPPER_H_

class CStepper
{
private:
    INT     m_iStepCnt;
    INT     m_iRemainder;
    INT     m_iStepSize;
    INT     m_iState;
    INT     m_iStepNum;
    INT     m_iPos;

public:
    CStepper(void);
    void Init( INT iLength, INT nSteps ) ;
    void Reset ( void ) ;
    INT NextPosition (void) ;
    INT PrevPosition (void) ;
    INT StepTo (INT nSteps) ;

    INT StepNum (void) { return m_iStepNum; }
    INT PrevStepNum (INT iPosition);

    INT Position (void) { return m_iPos; }
    INT StepCount (void) { return m_iStepCnt; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\srcprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.cpp

Abstract:

    Implementation of the source property page.

--*/

#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include <sql.h>
#include <pdhmsg.h>
#include <pdhp.h>
#include "polyline.h"
#include "utils.h"
#include "smonmsg.h"
#include "strids.h"
#include "unihelpr.h"
#include "winhelpr.h"
#include "odbcinst.h"
#include "smonid.h"
#include "srcprop.h"



CSourcePropPage::CSourcePropPage()
:   m_pTimeRange ( NULL ),
    m_eDataSourceType ( sysmonCurrentActivity ),
    m_hDataSource(H_REALTIME_DATASOURCE),
    m_pInfoDeleted ( NULL ),
    m_bLogFileChg ( FALSE ),
    m_bSqlDsnChg ( FALSE ),
    m_bSqlLogSetChg ( FALSE ),
    m_bRangeChg ( FALSE ),
    m_bDataSourceChg ( FALSE )
{
    m_uIDDialog = IDD_SRC_PROPP_DLG;
    m_uIDTitle = IDS_SRC_PROPP_TITLE;
    m_szSqlDsnName[0] = _T('\0');
    m_szSqlLogSetName[0] = _T('\0');
}

CSourcePropPage::~CSourcePropPage(
    void
    )
{
    return;
}

/*
 * CSourcePropPage::Init
 *
 * Purpose:
 *  Performs initialization operations that might fail.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if initialization successful, FALSE
 *                  otherwise.
 */

BOOL 
CSourcePropPage::Init(void)
{
    BOOL bResult;

    bResult = RegisterTimeRangeClass();

    return bResult;
}

BOOL
CSourcePropPage::InitControls ( void )
{
    BOOL    bResult = FALSE;
    HWND    hwndTimeRange;
    
    // create time range object attached to dialog control
    
    hwndTimeRange = GetDlgItem(m_hDlg, IDC_TIMERANGE);

    if ( NULL != hwndTimeRange ) {

        m_pTimeRange = new CTimeRange(hwndTimeRange);
        if (m_pTimeRange) {
            bResult = m_pTimeRange->Init();
            if ( FALSE == bResult ) {
                delete m_pTimeRange;
                m_pTimeRange = NULL;
            }
        }
    }
    return bResult;
}

void
CSourcePropPage::DeinitControls ( void )
{
    HWND    hwndLogFileList = NULL;
    INT     iIndex;
    INT     iLogFileCnt = 0;;
    PLogItemInfo    pInfo = NULL;

    ISystemMonitor  *pObj;
    CImpISystemMonitor *pPrivObj;

    pObj = m_ppISysmon[0];  
    pPrivObj = (CImpISystemMonitor*)pObj;
    // Hide the log view start and stop bars on the graph
    pPrivObj->SetLogViewTempRange( MIN_TIME_VALUE, MAX_TIME_VALUE );

    // delete time range object attached to dialog control
    if (m_pTimeRange != NULL) {
        delete m_pTimeRange;
        m_pTimeRange = NULL;
    }

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCnt = LBNumItems(hwndLogFileList);
        for (iIndex = 0; iIndex < iLogFileCnt; iIndex++ ) {
            pInfo = (PLogItemInfo)LBData(hwndLogFileList,iIndex);
            if ( NULL != pInfo ) {
                if ( NULL != pInfo->pItem ) {
                    pInfo->pItem->Release();
                }
                if (NULL != pInfo->pszPath ) {
                    delete pInfo->pszPath;
                }
                delete pInfo;
            }
        }
    }
    return;
}

/*
 * CSourcePropPage::GetProperties
 * 
 */

BOOL CSourcePropPage::GetProperties(void)
{
    BOOL    bReturn = TRUE;
    DWORD   dwStatus = ERROR_SUCCESS;
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    BSTR    bstrPath;
    DATE    date;

    LPWSTR  szLogFileList   = NULL;
    ULONG   ulLogListBufLen = 0;
    BOOL    bIsValidLogFile = FALSE;
    BOOL    bIsValidLogFileRange = TRUE;
    ILogFileItem    *pItem = NULL;
    PLogItemInfo    pInfo = NULL;
    BSTR            bstrTemp     = NULL;
    INT     iLogFile = 0;
    INT     iIndex = 0;
    INT     nChar = 0;

    USES_CONVERSION

    if (m_cObjects == 0) {
        bReturn = FALSE;
    } else {
        pObj = m_ppISysmon[0];

        // Get pointer to actual object for internal methods
        pPrivObj = (CImpISystemMonitor*)pObj;
    }

    if ( NULL == pObj || NULL == pPrivObj ) {
        bReturn = FALSE;
    } else {
        
        // Set the data source type
        pObj->get_DataSourceType (&m_eDataSourceType);

        CheckRadioButton(
                m_hDlg, IDC_SRC_REALTIME, IDC_SRC_SQL,
                IDC_SRC_REALTIME + m_eDataSourceType - 1);

        SetSourceControlStates();

        while (SUCCEEDED(pPrivObj->LogFile(iLogFile, &pItem))) {

            // Create LogItemInfo to hold the log file item and path
            pInfo = new LogItemInfo;

            if ( NULL == pInfo ) {
                bReturn = FALSE;
                break;
            }

            ZeroMemory ( pInfo, sizeof(LogItemInfo) );
            
            pInfo->pItem = pItem;
            if ( FAILED ( pItem->get_Path( &bstrPath ) ) ) {
                bReturn = FALSE;
                delete pInfo;
                break;
            } else {
#if UNICODE
                nChar = lstrlen(bstrPath) + 1;
#else
                nChar = (wcslen(bstrPath) + 1) * 2;     // * 2???
#endif
                pInfo->pszPath = new TCHAR [nChar];

                if ( NULL == pInfo->pszPath ) {
                    delete pInfo;
                    SysFreeString(bstrPath);
                    bReturn = FALSE;
                    break;
                }
#if UNICODE
                lstrcpy(pInfo->pszPath, bstrPath);
#else
                WideCharToMultiByte(CP_ACP, 0, bstrPath, nChar,
                                pInfo->pszPath, nChar, NULL, NULL);
#endif
                SysFreeString(bstrPath);

            }
            // Add the log file name to the list box
            iIndex = AddItemToFileListBox(pInfo);
    
            if ( LB_ERR == iIndex ) {
                bReturn = FALSE;
                delete pInfo->pszPath;
                delete pInfo;                
                break;
            }

            iLogFile++;
        } 

        // Get SQL DSN name, populate list box.
        pObj->get_SqlDsnName(&bstrTemp);
        memset ( m_szSqlDsnName, 0, sizeof (m_szSqlDsnName) );
    
        if ( NULL != bstrTemp ) { 
            if ( bstrTemp[0] != _T('\0') ) {
                lstrcpyn ( 
                    m_szSqlDsnName, 
                    W2T( bstrTemp ), min(SQL_MAX_DSN_LENGTH, lstrlen (W2T(bstrTemp))+1) );
            }
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
        }
        InitSqlDsnList();

        // Get SQL log set name, populate list box.
        pObj->get_SqlLogSetName(&bstrTemp);
        memset ( m_szSqlLogSetName, 0, sizeof (m_szSqlLogSetName) );
    
        if ( NULL != bstrTemp ) { 
            if ( bstrTemp[0] != _T('\0') ) {
                lstrcpyn ( 
                    m_szSqlLogSetName, 
                    W2T( bstrTemp ), min(MAX_PATH-1, lstrlen (W2T(bstrTemp))+1) );
            }
            SysFreeString (bstrTemp);
        }
        InitSqlLogSetList();

        if ( m_eDataSourceType == sysmonLogFiles
            || m_eDataSourceType == sysmonSqlLog) {

            pPrivObj->GetLogFileRange(&m_llBegin, &m_llEnd);
            m_pTimeRange->SetBeginEnd(m_llBegin, m_llEnd);

            pObj->get_LogViewStart(&date);
            VariantDateToLLTime(date, &m_llStart);

            pObj->get_LogViewStop(&date);
            VariantDateToLLTime(date, &m_llStop);

            m_pTimeRange->SetStartStop(m_llStart, m_llStop);

            // OpenLogFile sets BeginEnd, StartStop values in the 
            // time range control, if the file and range are valid.
            dwStatus = OpenLogFile ();

            if ( ERROR_SUCCESS == dwStatus ) {
                bIsValidLogFile = TRUE;
                bIsValidLogFileRange = TRUE;
            } else {

                bIsValidLogFile = FALSE;
                bIsValidLogFileRange = FALSE;
                
                m_llStart = MIN_TIME_VALUE;
                m_llStop = MAX_TIME_VALUE;

                if ( sysmonLogFiles == m_eDataSourceType ) {
                    BuildLogFileList ( 
                        m_hDlg,
                        NULL,
                        &ulLogListBufLen );

                    szLogFileList =  (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
                    if ( NULL != szLogFileList ) {
                        BuildLogFileList ( 
                            m_hDlg,
                            szLogFileList,
                            &ulLogListBufLen );
                    }
                }

                if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                    DisplayDataSourceError (
                            m_hDlg,
                            dwStatus,
                            m_eDataSourceType,
                            szLogFileList,
                            m_szSqlDsnName,
                            m_szSqlLogSetName );

                    if ( NULL != szLogFileList ) {
                        delete szLogFileList;
                        szLogFileList = NULL;
                        ulLogListBufLen = 0;
                    }
                }
            }
        } else {
            bIsValidLogFile = FALSE;
            bIsValidLogFileRange = FALSE;
            
            m_llStart = MIN_TIME_VALUE;
            m_llStop = MAX_TIME_VALUE;            
        }

        // Set the start and stop time bars invisible or not, depending on time range
        pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

        SetTimeRangeCtrlState ( bIsValidLogFile, bIsValidLogFileRange );

        // Clear change flags
        m_bInitialTimeRangePending = !bIsValidLogFileRange;
        m_bLogFileChg = FALSE;
        m_bSqlDsnChg = FALSE;
        m_bSqlLogSetChg = FALSE;
        m_bRangeChg = FALSE;
        m_bDataSourceChg = FALSE;

        bReturn = TRUE; 
    }

    return bReturn;
}


/*
 * CSourcePropPage::SetProperties
 * 
 */

BOOL CSourcePropPage::SetProperties(void)
{
    ISystemMonitor* pObj = NULL;
    CImpISystemMonitor* pPrivObj = NULL;
    BOOL    bIsValidLogFile = TRUE;
    BOOL    bIsValidLogFileRange = TRUE;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szLogFileList   = NULL;
    ULONG   ulLogListBufLen = 0;
    PLogItemInfo    pInfo = NULL;
    PLogItemInfo    pInfoNext = NULL;
    DATE            date;
    BOOL            bReturn = TRUE;
    HWND            hwndLogFileList = NULL;
    INT             iLogFileCnt;
    INT             i;  
    UINT            uiMessage = 0;
    HRESULT         hr = NOERROR;
    BOOL            bNewFileIsValid = TRUE;
    BSTR            bstrTemp     = NULL;

    USES_CONVERSION
    
    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);

    if ( 0 != m_cObjects ) {
        pObj = m_ppISysmon[0];
        
        if ( NULL != pObj ) {
            // Get pointer to actual object for internal methods
            pPrivObj = (CImpISystemMonitor*)pObj;
        }
    }

    if ( NULL != hwndLogFileList && NULL != pPrivObj ) {

        iLogFileCnt = LBNumItems(hwndLogFileList);
        // Validate properties
        if (m_eDataSourceType == sysmonLogFiles ) {
            if ( 0 == iLogFileCnt ) {
                uiMessage = IDS_NOLOGFILE_ERR;
            } else {
                // Check validity of existing files.
                // LogFilesAreValid displays any errors.
                LogFilesAreValid ( NULL, bNewFileIsValid, bReturn );
            }
        } else if ( m_eDataSourceType == sysmonSqlLog ){
            if ( _T('\0') == m_szSqlDsnName[0] ) {
                uiMessage = IDS_NO_SQL_DSN_ERR;
            } else if ( _T('\0') == m_szSqlLogSetName[0] ) {
                uiMessage = IDS_NO_SQL_LOG_SET_ERR;
            }
        }
        if ( 0 != uiMessage ) {
            MessageBox(m_hDlg, ResourceString(uiMessage), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION);
            bReturn = FALSE;
        }

        if ( !bReturn ) {
            bIsValidLogFile = FALSE;
            // Todo:  Set log file time range?
        }

        if ( m_eDataSourceType == sysmonLogFiles
            || m_eDataSourceType == sysmonSqlLog) {
            if ( bReturn && m_bInitialTimeRangePending ) {
                // If log file or SQL specified, but range has not been determined
                // Try to open it now and get the range
                dwStatus = OpenLogFile();
                if ( ERROR_SUCCESS == dwStatus ) {
                    bIsValidLogFile = TRUE;
                    bIsValidLogFileRange = TRUE;
                    m_bInitialTimeRangePending = FALSE;
                } else {

                    bReturn = FALSE;

                    bIsValidLogFile = FALSE;
                    bIsValidLogFileRange = FALSE;
                    
                    m_llStart = MIN_TIME_VALUE;
                    m_llStop = MAX_TIME_VALUE;

                    if ( sysmonLogFiles == m_eDataSourceType ) {
                        BuildLogFileList ( 
                            m_hDlg,
                            NULL,
                            &ulLogListBufLen );

                        szLogFileList =  (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
                        if ( NULL != szLogFileList ) {
                            BuildLogFileList ( 
                                m_hDlg,
                                szLogFileList,
                                &ulLogListBufLen );
                        }
                    }

                    if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                        DisplayDataSourceError (
                            m_hDlg,
                            dwStatus,
                            m_eDataSourceType,
                            szLogFileList,
                            m_szSqlDsnName,
                            m_szSqlLogSetName );

                        if ( NULL != szLogFileList ) {
                            delete szLogFileList;
                            szLogFileList = NULL;
                            ulLogListBufLen = 0;
                        }
                    }
                }
            }
             // Set the start and stop time bars invisible or not, depending on time range
            pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

            SetTimeRangeCtrlState ( bIsValidLogFile, bIsValidLogFileRange );
       }
    }


    // Remove all deleted log files from the control.
    // Get first object
    if ( bReturn ) {

        if (m_bLogFileChg || m_bSqlDsnChg || m_bSqlLogSetChg ) {

            // Always set the log source to null data source before modifying the log file list
            // or database fields.
            // TodoLogFiles:  This can leave the user with state different than before, in the
            // case of log file load failure.
            pObj->put_DataSourceType ( sysmonNullDataSource );
            m_bDataSourceChg = TRUE;
        }

        if ( m_bSqlDsnChg) {
            bstrTemp = SysAllocString(T2W(m_szSqlDsnName));
            if ( NULL != bstrTemp ) {
                hr = pObj->put_SqlDsnName(bstrTemp);
            } else {
                hr = E_OUTOFMEMORY;
            }
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            bReturn = SUCCEEDED ( hr );
        }

        if ( bReturn && m_bSqlLogSetChg) {
            bstrTemp = SysAllocString(T2W(m_szSqlLogSetName));
            if ( NULL != bstrTemp ) {
                hr = pObj->put_SqlLogSetName(bstrTemp);
            } else {
                hr = E_OUTOFMEMORY;
            }
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            bReturn = SUCCEEDED ( hr );
        }

        if (m_bLogFileChg) {

            // Remove all items in the delete list from the control.
            pInfo = m_pInfoDeleted;
            while ( NULL != pInfo ) {

                // If this counter exists in the control
                if ( NULL != pInfo->pItem ) {

                    // Tell control to remove it
                    // Always set the log source to CurrentActivity before modifying the log file list.
                    pPrivObj->DeleteLogFile(pInfo->pItem);
                    // Release the local reference
                    pInfo->pItem->Release();
                }

                // Free the path string
                delete pInfo->pszPath;

                // Delete the Info structure and point to the next one
                pInfoNext = pInfo->pNextInfo;
                delete pInfo;
                pInfo = pInfoNext;
            }

            m_pInfoDeleted = NULL;
        
            // For each item
            for (i=0; i<iLogFileCnt; i++) {
                pInfo = (PLogItemInfo)LBData(hwndLogFileList,i);

                // If new item, create it now
                if (pInfo->pItem == NULL) {
                    // The following code inits the pItem field of pInfo.
#if UNICODE
                    bstrTemp = SysAllocString(T2W(pInfo->pszPath));
                    if ( NULL != bstrTemp ) {
                        hr = pPrivObj->AddLogFile(bstrTemp, &pInfo->pItem);
                        SysFreeString (bstrTemp);
                        bstrTemp = NULL;
                    } else {
                       hr = E_OUTOFMEMORY;
                    }
#else
                    INT nChar = lstrlen(pInfo->pszPath);
                    LPWSTR pszPathW = new WCHAR [nChar + 1];
                    if (pszPathW) {
                        MultiByteToWideChar(CP_ACP, 0, pInfo->pszPath, nChar+1, pszPathW, nChar+1);
                        bstrTemp = SysAllocString(pszPathW);
                        if ( NULL != bstrTemp ) {
                            hr = pPrivObj->AddLogFile(bstrTemp, &pInfo->pItem);
                            SysFreeString (bstrTemp);
                            bstrTemp = NULL;

                        } else {
                            hr = E_OUTOFMEMORY;
                        }
                        delete pszPathW;
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
#endif
                }
                if ( FAILED ( hr) ) {
                    break;
                }
            }
            bReturn = SUCCEEDED ( hr );
        }

        
        if ( bReturn && m_bDataSourceChg ) {
            // This covers CurrentActivity as well as log files, database 
            hr = pObj->put_DataSourceType(m_eDataSourceType);
            bReturn = SUCCEEDED ( hr );
            if ( SUCCEEDED ( hr ) ) {
                m_bDataSourceChg = FALSE;
                m_bLogFileChg = FALSE;
                m_bSqlDsnChg = FALSE;
                m_bSqlLogSetChg = FALSE;
            } else {
                if ( sysmonLogFiles == m_eDataSourceType
                    || sysmonSqlLog == m_eDataSourceType ) {

                    // Display error messages, then retry in 
                    // Current Activity data source type.

                    // TodoLogFiles: Message re: data source set to CurrentActivity if
                    // put_DataSourceType failed.

                    if ( sysmonLogFiles == m_eDataSourceType ) {
                        BuildLogFileList ( 
                            m_hDlg,
                            NULL,
                            &ulLogListBufLen );

                        szLogFileList =  (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
                        if ( NULL != szLogFileList ) {
                            BuildLogFileList ( 
                                m_hDlg,
                                szLogFileList,
                                &ulLogListBufLen );
                        }
                    }

                    if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                        DisplayDataSourceError (
                            m_hDlg,
                            (DWORD)hr,
                            m_eDataSourceType,
                            szLogFileList,
                            m_szSqlDsnName,
                            m_szSqlLogSetName );

                        if ( NULL != szLogFileList ) {
                            delete szLogFileList;
                            szLogFileList = NULL;
                            ulLogListBufLen = 0;
                        }
                    }
                }
                // m_hDataSource should always be cleared unless in OpenLogFile method.
                assert ( H_REALTIME_DATASOURCE == m_hDataSource );
                
                // TodoLogFiles:  Need separate method to handle all changes necesary
                // when the log source type changes.
                if ( sysmonCurrentActivity != m_eDataSourceType ) {
                    m_eDataSourceType = sysmonCurrentActivity;
        
                    CheckRadioButton(
                        m_hDlg, IDC_SRC_REALTIME, IDC_SRC_SQL,
                        IDC_SRC_REALTIME + m_eDataSourceType - 1);
                
                    m_bDataSourceChg = TRUE;

                    SetSourceControlStates();
    
                    SetTimeRangeCtrlState ( 
                        FALSE, 
                        FALSE );

                    hr = pObj->put_DataSourceType ( m_eDataSourceType );
                    bReturn = SUCCEEDED ( hr );

                    m_bDataSourceChg = FALSE;
                    
                    m_bLogFileChg = FALSE;
                    m_bSqlDsnChg = FALSE;
                    m_bSqlLogSetChg = FALSE;
                } // else setting to Current Activity failed.
            }
        }
        if ( bReturn ) {

            if (m_eDataSourceType == sysmonLogFiles || m_eDataSourceType == sysmonSqlLog) 
                pPrivObj->SetLogFileRange(m_llBegin, m_llEnd);
            else 
                pObj->UpdateGraph();

        } else {
            SetFocus(GetDlgItem(m_hDlg, IDC_ADDFILE));
        }

        if (bReturn && m_bRangeChg
                    && (   m_eDataSourceType == sysmonLogFiles
                        || m_eDataSourceType == sysmonSqlLog)) {

            // With active logs, the begin/end points might have changed.
            pPrivObj->SetLogFileRange(m_llBegin, m_llEnd);

            // Always set Stop time first, to handle live logs.
            LLTimeToVariantDate(m_llStop, &date);
            pObj->put_LogViewStop(date);

            LLTimeToVariantDate(m_llStart, &date);
            pObj->put_LogViewStart(date);

            // Set the start and stop time bars visible in the graph
            pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

            m_bRangeChg = FALSE;
        }
    } else {
        bReturn = FALSE;
    }
    return bReturn;
}

void
CSourcePropPage::LogFilesAreValid (
    PLogItemInfo pNewInfo,
    BOOL&   rbNewIsValid,
    BOOL&   rbExistingIsValid )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    INT     iIndex;
    INT     iLogFileCnt = 0;
    HWND    hwndLogFileList = NULL;
    TCHAR   szLogFile[MAX_PATH];
    LPCTSTR pszTestFile = NULL;
    PLogItemInfo pInfo = NULL;
    TCHAR*  pszMessage = NULL;
    TCHAR   szSystemMessage[MAX_PATH];
    DWORD   dwType = PDH_LOG_TYPE_BINARY;
    UINT    uiErrorMessageID = 0;

    rbNewIsValid = TRUE;
    rbExistingIsValid = TRUE;

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCnt = LBNumItems(hwndLogFileList);
    }

    if ( NULL != pNewInfo && NULL != hwndLogFileList ) {
        if ( NULL != pNewInfo->pszPath ) {
            // Check for duplicates.             
            for (iIndex = 0; iIndex < iLogFileCnt; iIndex++ ) {
                LBGetText(hwndLogFileList, iIndex, szLogFile);
                if ( 0 == lstrcmpi ( pNewInfo->pszPath, szLogFile ) ) {
                    MessageBox(
                        m_hDlg,
                        ResourceString(IDS_DUPL_LOGFILE_ERR), 
                        ResourceString(IDS_APP_NAME),
                        MB_OK | MB_ICONWARNING);
                    iIndex = LB_ERR;
                    rbNewIsValid = FALSE;
                    break;
                }    
            }

            // Validate added log file type if multiple log files
            if ( rbNewIsValid && 0 < iLogFileCnt ) {
                // Validate the new file
                dwType = PDH_LOG_TYPE_BINARY;

                pszTestFile = pNewInfo->pszPath;
                if ( NULL != pszTestFile ) {
                    dwStatus = PdhGetLogFileType ( 
                                    pszTestFile, 
                                    &dwType );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( PDH_LOG_TYPE_BINARY != dwType ) {
                            if ( (DWORD)ePdhLogTypeRetiredBinary == dwType ) {
                                uiErrorMessageID = IDS_MULTILOG_BIN_TYPE_ADD_ERR;
                            } else {
                                uiErrorMessageID = IDS_MULTILOG_TEXT_TYPE_ADD_ERR;
                            }
                            rbNewIsValid = FALSE;
                        }
                    } else {
                        // bad dwStatus error message handled below
                        rbNewIsValid = FALSE;
                    }
                }
            }
        } else {
            rbNewIsValid = FALSE;
            assert ( FALSE );
        }
    }

    // Validate existing files if the new count will be > 1
    if ( rbNewIsValid 
            && ( NULL != pNewInfo || iLogFileCnt > 1 ) )
    {
        dwType = PDH_LOG_TYPE_BINARY;

        for (iIndex=0; iIndex<iLogFileCnt; iIndex++) {
            pInfo = (PLogItemInfo)LBData(hwndLogFileList,iIndex);
            if ( NULL != pInfo ) {
                pszTestFile = pInfo->pszPath;
                if ( NULL != pszTestFile ) {
                
                    dwStatus = PdhGetLogFileType ( 
                                    pszTestFile, 
                                    &dwType );

                    if ( PDH_LOG_TYPE_BINARY != dwType ) {
                        rbExistingIsValid = FALSE;
                        break;
                    }
                }
            }
        }
        if ( ERROR_SUCCESS == dwStatus ) {
            if ( PDH_LOG_TYPE_BINARY != dwType ) {
                if ( (DWORD)ePdhLogTypeRetiredBinary == dwType ) {
                    uiErrorMessageID = IDS_MULTILOG_BIN_TYPE_ERR;
                } else {
                    uiErrorMessageID = IDS_MULTILOG_TEXT_TYPE_ERR;
                }
                rbExistingIsValid = FALSE;
            }
        } else {
            rbExistingIsValid = FALSE;
        }
    }

    if ( ( !rbNewIsValid || !rbExistingIsValid ) 
            && NULL != pszTestFile ) 
    {
        iIndex = LB_ERR;
        // Check dwStatus of PdhGetLogFileType call.
        if ( ERROR_SUCCESS == dwStatus ) {
            if ( PDH_LOG_TYPE_BINARY != dwType ) {
                assert ( 0 != uiErrorMessageID );
                pszMessage = new TCHAR [ ( 2*lstrlen(pszTestFile) )  + MAX_PATH];
                if ( NULL != pszMessage ) {
                    _stprintf ( 
                        pszMessage, 
                        ResourceString(uiErrorMessageID), 
                        pszTestFile,
                        pszTestFile );
                    MessageBox (
                        m_hDlg, 
                        pszMessage, 
                        ResourceString(IDS_APP_NAME), 
                        MB_OK | MB_ICONSTOP );
                    delete pszMessage;
                }
            }
        } else {
            pszMessage = new TCHAR [lstrlen(pszTestFile) + 2*MAX_PATH];

            if ( NULL != pszMessage ) {
                _stprintf ( 
                    pszMessage, 
                    ResourceString(IDS_MULTILOG_CHECKTYPE_ERR), 
                    pszTestFile );

                FormatSystemMessage ( 
                    dwStatus, szSystemMessage, MAX_PATH );

                lstrcat ( pszMessage, szSystemMessage );

                MessageBox (
                    m_hDlg, 
                    pszMessage, 
                    ResourceString(IDS_APP_NAME), 
                    MB_OK | MB_ICONSTOP);

                delete pszMessage;
            }
        }
    }

    return;
}


INT
CSourcePropPage::AddItemToFileListBox (
    IN PLogItemInfo pNewInfo )
/*++

Routine Description:

    AddItemToFileListBox adds a log file's path name to the dialog list box and
    attaches a pointer to the log file's LogItemInfo structure as item data.
    It also adjusts the horizontal scroll of the list box.


Arguments:

    pInfo - Pointer to log file's LogItemInfo structure

Return Value:

    List box index of added log file (LB_ERR on failure)

--*/
{
    INT     iIndex = LB_ERR;
    HWND    hwndLogFileList = NULL; 
    DWORD   dwItemExtent = 0;
    HDC     hDC = NULL;
    BOOL    bNewIsValid;
    BOOL    bExistingAreValid;

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);

    if ( NULL != pNewInfo && NULL != hwndLogFileList ) {
        LogFilesAreValid ( pNewInfo, bNewIsValid, bExistingAreValid );

        if ( bNewIsValid && NULL != pNewInfo->pszPath ) {
            iIndex = (INT)LBAdd ( hwndLogFileList, pNewInfo->pszPath );
            LBSetSelection( hwndLogFileList, iIndex);

            if ( LB_ERR != iIndex && LB_ERRSPACE != iIndex ) { 
    
                LBSetData(hwndLogFileList, iIndex, pNewInfo);

                hDC = GetDC ( hwndLogFileList );
                if ( NULL != hDC ) {
                    dwItemExtent = (DWORD)TextWidth ( hDC, pNewInfo->pszPath );

                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                        LBSetHorzExtent ( hwndLogFileList, dwItemExtent ); 
                    }
                    ReleaseDC ( hwndLogFileList, hDC );
                }
                OnLogFileChange();
            } else {
                iIndex = LB_ERR ; 
            }
        }
    }
    return iIndex;
}

BOOL
CSourcePropPage::RemoveItemFromFileListBox (
    void )
/*++

Routine Description:

    RemoveItemFromFileListBox removes the currently selected log file from 
    the dialog's log file name listbox. It adds the item to the deletion 
    list, so the actual log file can be deleted from the control when 
    (and if) the changes are applied.

    The routine selects selects the next log file in the listbox if there
    is one, and adjusts the horizontal scroll appropriately.

Arguments:
    
    None.

Return Value:

    None.

--*/
{
    BOOL    bChanged = FALSE;
    HWND    hWnd;
    INT     iIndex;
    PLogItemInfo    pInfo = NULL;
    LPTSTR  szBuffer = NULL;
    DWORD   dwItemExtent = 0;
    INT     iCurrentBufLen = 0;
    INT     iTextLen;
    HDC     hDC = NULL;

    // Get selected index
    hWnd = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    iIndex = LBSelection(hWnd);

    if ( LB_ERR != iIndex ) {

        // Get selected item info
        pInfo = (PLogItemInfo)LBData(hWnd, iIndex);
        
        // Move it to the "Deleted" list.
        pInfo->pNextInfo = m_pInfoDeleted;
        m_pInfoDeleted = pInfo;

        // Remove the string from the list box.
        LBDelete(hWnd, iIndex);

        // Select next item if possible, else the previous
        if (iIndex == LBNumItems(hWnd)) {
            iIndex--;
        }
        LBSetSelection( hWnd, iIndex);

        hDC = GetDC ( hWnd );

        if ( NULL != hDC ) {
            // Clear the max horizontal extent and recalculate
            m_dwMaxHorizListExtent = 0;                
            for ( iIndex = 0; iIndex < (INT)LBNumItems ( hWnd ); iIndex++ ) {
                iTextLen = (INT)LBGetTextLen ( hWnd, iIndex );
                if ( iTextLen >= iCurrentBufLen ) {
                    if ( NULL != szBuffer ) {
                        delete szBuffer;
                        szBuffer = NULL;
                    }
                    iCurrentBufLen = iTextLen + 1;
                    szBuffer = new TCHAR [iCurrentBufLen];
                }
                if ( NULL != szBuffer ) {
                    LBGetText ( hWnd, iIndex, szBuffer );
                    dwItemExtent = (DWORD)TextWidth ( hDC, szBuffer );
                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                    }
                }
            }
            LBSetHorzExtent ( hWnd, m_dwMaxHorizListExtent ); 

            ReleaseDC ( hWnd, hDC );    
        }
        if ( NULL != szBuffer ) {
            delete szBuffer;
        }
        bChanged = TRUE;
        OnLogFileChange();
    }
    return bChanged;
}
 
void
CSourcePropPage::OnLogFileChange ( void )
{
    HWND    hwndLogFileList = NULL;
    INT     iLogFileCnt = 0;
    BOOL    bIsValidDataSource = FALSE;

    m_bLogFileChg = TRUE;
    m_bInitialTimeRangePending = TRUE;

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCnt = LBNumItems(hwndLogFileList);
    }
    bIsValidDataSource = (iLogFileCnt > 0);

    if (m_eDataSourceType == sysmonLogFiles) {
        DialogEnable(m_hDlg, IDC_REMOVEFILE, ( bIsValidDataSource ) );     
    }
    
    SetTimeRangeCtrlState( bIsValidDataSource, FALSE );

}

void
CSourcePropPage::OnSqlDataChange ( void )
{
    BOOL    bIsValidDataSource = FALSE;

    assert ( sysmonSqlLog == m_eDataSourceType );

    m_bInitialTimeRangePending = TRUE;

    bIsValidDataSource = 0 < lstrlen ( m_szSqlDsnName ) && 0 < lstrlen ( m_szSqlLogSetName );
    
    SetTimeRangeCtrlState( bIsValidDataSource, FALSE );
}

void 
CSourcePropPage::DialogItemChange(WORD wID, WORD wMsg)
{
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    HWND    hwndCtrl = NULL;
    BOOL    fChange = FALSE;
    DataSourceTypeConstants eNewDataSourceType;
    HWND    hwndLogFileList = NULL;
    INT     iLogFileCnt = 0;;
    BOOL    bIsValidDataSource;


    switch(wID) {

        case IDC_SRC_REALTIME:
        case IDC_SRC_LOGFILE:
        case IDC_SRC_SQL:

            // Check which button is involved
            eNewDataSourceType = (DataSourceTypeConstants)(wID - IDC_SRC_REALTIME + 1); 

            // If state changed
            if (   wMsg == BN_CLICKED
                && eNewDataSourceType != m_eDataSourceType) {

                // Set change flags and update the radio button
                m_bDataSourceChg = TRUE;
                fChange = TRUE;

                m_eDataSourceType = eNewDataSourceType;

                CheckRadioButton(
                        m_hDlg, IDC_SRC_REALTIME, IDC_SRC_SQL,
                        IDC_SRC_REALTIME + m_eDataSourceType - 1);

                SetSourceControlStates();

                pObj = m_ppISysmon[0];  
                if ( NULL != m_ppISysmon[0] ) {
                    pPrivObj = (CImpISystemMonitor*) pObj;
                }
                if ( NULL != pPrivObj ) {
                    bIsValidDataSource = FALSE;

                    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
                    if ( NULL != hwndLogFileList ) {
                        iLogFileCnt = LBNumItems(hwndLogFileList);
                    }

                    if ( sysmonLogFiles == m_eDataSourceType && iLogFileCnt > 0) {

                        bIsValidDataSource = (iLogFileCnt > 0);

                        if ( bIsValidDataSource ) {
                            SetFocus(GetDlgItem(m_hDlg, IDC_ADDFILE));
                        }

                    } else if ( sysmonSqlLog == m_eDataSourceType ) {

                        bIsValidDataSource = ( 0 < lstrlen ( m_szSqlDsnName ) )
                                            && ( 0 < lstrlen ( m_szSqlLogSetName ) );
                    } // else  current activity, so no valid data source 

                    if ( bIsValidDataSource ) {
                        // Set the start and stop time bars visible in the graph
                        pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );
                    } else {
                        // Set the start and stop time bars invisible in the graph
                        pPrivObj->SetLogViewTempRange( MIN_TIME_VALUE, MAX_TIME_VALUE );
                    }

                }
                m_bDataSourceChg = TRUE;
            }
            break;

        case IDC_REMOVEFILE:
            fChange = RemoveItemFromFileListBox();
            break;

        case IDC_ADDFILE:
        {
            TCHAR   szDefaultFolderBuff[MAX_PATH + 1];
            LPWSTR  szBrowseBuffer = NULL;
            INT     iFolderBufLen;
            PDH_STATUS pdhstat;
            LogItemInfo* pInfo = NULL;
            DWORD   cchLen = 0;
            DWORD   cchBrowseBuffer = 0;

            szDefaultFolderBuff[0] = L'\0';

            iFolderBufLen = MAX_PATH;

            if ( ERROR_SUCCESS != LoadDefaultLogFileFolder(szDefaultFolderBuff, &iFolderBufLen) ) {
                if ( iFolderBufLen > lstrlen ( ResourceString ( IDS_DEFAULT_LOG_FILE_FOLDER ) ) ) {
                    lstrcpy ( szDefaultFolderBuff, ResourceString ( IDS_DEFAULT_LOG_FILE_FOLDER ) );
                }
            }
            //
            // Expand environment strings.
            //
            cchLen = ExpandEnvironmentStrings ( szDefaultFolderBuff, NULL, 0 );

            if ( 0 < cchLen ) {
                //
                // cchLen includes space for null.
                //
                cchBrowseBuffer =  max ( cchLen, MAX_PATH + 1 );
                szBrowseBuffer = new WCHAR [ cchBrowseBuffer ];
                szBrowseBuffer[0] = L'\0';

                if ( NULL != szBrowseBuffer ) {
                    cchLen = ExpandEnvironmentStrings (
                                szDefaultFolderBuff, 
                                szBrowseBuffer,
                                cchBrowseBuffer );

                    if ( 0 < cchLen && cchLen <= cchBrowseBuffer ) {
                        SetCurrentDirectory(szBrowseBuffer);
                    } else {
                    }
                }
            }

            if ( NULL != szBrowseBuffer ) {

                szBrowseBuffer[0] = L'\0';
                pdhstat = PdhSelectDataSource(
                            m_hDlg,
                            PDH_FLAGS_FILE_BROWSER_ONLY,
                            szBrowseBuffer,
                            &cchBrowseBuffer);

                if ( ERROR_SUCCESS != pdhstat || szBrowseBuffer[0] == L'\0' ) {
                    delete [] szBrowseBuffer;
                    szBrowseBuffer = NULL;
                    break;
                }

                // Load file name into edit control
                pInfo = new LogItemInfo;
                if ( NULL != pInfo ) {
                    ZeroMemory ( pInfo, sizeof(LogItemInfo) );
                    //
                    // Make own copy of path name string
                    //
                    pInfo->pszPath = new TCHAR [lstrlen( szBrowseBuffer ) + 1];
                        // TodoLogFiles:  Multi-log file support
                    if ( NULL != pInfo->pszPath ) {
                        INT iIndex = 0;
                        lstrcpy(pInfo->pszPath, szBrowseBuffer);

                        iIndex = AddItemToFileListBox ( pInfo );

                        fChange = ( LB_ERR != iIndex );

                        if (!fChange) {
                            // Todo:  error message
                            delete [] pInfo->pszPath;
                            delete pInfo;
                        }
                    } else {
                        // Todo:  error message
                        delete pInfo;
                    }
                }
                // Todo:  error message
            }

            if ( NULL != szBrowseBuffer ) {
                delete [] szBrowseBuffer;
            }
            break;
        }

/*
        // Doesn't do anything
        case IDC_LIST_LOGFILENAME:
            // If selection changed
            if (wMsg == LBN_SELCHANGE) {

                // TodoLogFiles:  Selection change won't matter when multi-file support
                fChange = TRUE;
                OnLogFileChange();
                
                // Get selected index   
                hwndCtrl = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
                iIndex = LBSelection(hwndCtrl);
            }
            break;        
*/
        case IDC_DSN_COMBO:
            {
                TCHAR       szDsnName[SQL_MAX_DSN_LENGTH + 1];
                INT         iSel;
                HWND        hDsnCombo;

                szDsnName[0] = _T('\0');
                hDsnCombo = GetDlgItem ( m_hDlg, IDC_DSN_COMBO);
                if ( NULL != hDsnCombo ) {
                    iSel = (INT)CBSelection ( hDsnCombo );
                    if ( LB_ERR != iSel ) {
                        CBString( 
                            hDsnCombo,
                            iSel,
                            szDsnName);

                        if ( 0 != lstrcmpi ( m_szSqlDsnName, szDsnName ) ) {

                            lstrcpyn ( 
                                m_szSqlDsnName, 
                                szDsnName, 
                                min ( SQL_MAX_DSN_LENGTH, lstrlen(szDsnName)+1 ) );
                            m_bSqlDsnChg = TRUE;
                            InitSqlLogSetList();
                            OnSqlDataChange();
                            fChange = TRUE;
                        }
                    }
                }
            }
            break;

        case IDC_LOGSET_COMBO:
            {
                TCHAR   szLogSetName[MAX_PATH];
                INT     iSel;
                HWND    hLogSetCombo;

                szLogSetName[0] = _T('\0');
                hLogSetCombo = GetDlgItem ( m_hDlg, IDC_LOGSET_COMBO);
                if ( NULL != hLogSetCombo ) {
                    iSel = (INT)CBSelection ( hLogSetCombo );
                    if ( LB_ERR != iSel ) {

                        CBString (
                            hLogSetCombo,
                            iSel,
                            szLogSetName );

                        if ( ( 0 != lstrcmpi ( m_szSqlLogSetName, szLogSetName ) )
                            && ( 0 != lstrcmpi ( szLogSetName, ResourceString ( IDS_LOGSET_NOT_FOUND ) ) ) ) {
                            lstrcpyn ( 
                                m_szSqlLogSetName, 
                                szLogSetName, 
                                min ( MAX_PATH - 1, lstrlen(szLogSetName)+1 ) );
                            m_bSqlLogSetChg = TRUE;
                            OnSqlDataChange();
                            fChange = TRUE;
                        }
                    }
                }
            }
            break;
        case IDC_TIMESELECTBTN:
            {
                DWORD   dwStatus = ERROR_SUCCESS;
                BOOL    bAttemptedReload = FALSE;
                hwndCtrl = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
                if ( NULL != hwndCtrl ) {
                    { 
                        CWaitCursor cursorWait;
                        dwStatus = OpenLogFile ();
                    }
                    if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == dwStatus ) {
                        TCHAR   szMessage[2*MAX_PATH];
                        BSTR    bstrPath;
                        int iResult;
                    
                        pObj = m_ppISysmon[0];  
                        pObj->get_LogFileName ( &bstrPath );
                        // Todo:  Still use LogfileName from object?  Build log file set?
                        if ( bstrPath ) {
                            if ( bstrPath[0] ) {
                                lstrcpy ( szMessage, ResourceString(IDS_LARGE_LOG_FILE_RELOAD) );

                                iResult = MessageBox(
                                        m_hDlg, 
                                        szMessage, 
                                        ResourceString(IDS_APP_NAME), 
                                        MB_YESNO | MB_ICONEXCLAMATION);

                                if ( IDYES == iResult ) {
                                    CWaitCursor cursorWait;
                                    dwStatus = OpenLogFile ();
                                    bAttemptedReload = TRUE;
                                }
                            }
                            SysFreeString(bstrPath);
                        }
                    }
                    if ( ERROR_SUCCESS == dwStatus ) {
                        m_bInitialTimeRangePending = FALSE;

                        // Show graph log view start/stop time bars               
                        pObj = m_ppISysmon[0];  
                        pPrivObj = (CImpISystemMonitor*)pObj;
                        pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

                        SetTimeRangeCtrlState ( 
                            TRUE,
                            TRUE ); 

                        m_bRangeChg = TRUE;
                        fChange = TRUE;
                    } else {   // OpenLogFile failure
                        if ( ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == dwStatus ) && !bAttemptedReload ) {
                            // Message already displayed, user chose not to continue.
                        } else {

                            LPWSTR  szLogFileList   = NULL;
                            ULONG   ulLogListBufLen = 0;

                            if ( sysmonLogFiles == m_eDataSourceType ) {
                                BuildLogFileList ( 
                                    m_hDlg,
                                    NULL,
                                    &ulLogListBufLen );

                                szLogFileList =  (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
                                if ( NULL != szLogFileList ) {
                                    BuildLogFileList ( 
                                        m_hDlg,
                                        szLogFileList,
                                        &ulLogListBufLen );
                                }
                            }

                            if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                                DisplayDataSourceError (
                                    m_hDlg,
                                    dwStatus,
                                    m_eDataSourceType,
                                    szLogFileList,
                                    m_szSqlDsnName,
                                    m_szSqlLogSetName );

                                if ( NULL != szLogFileList ) {
                                    delete szLogFileList;
                                    szLogFileList = NULL;
                                    ulLogListBufLen = 0;
                                }
                            }
                        }
                    }
                }
            
                break;
            }
        case IDC_TIMERANGE:
            m_llStart = m_pTimeRange->GetStart();
            m_llStop = m_pTimeRange->GetStop();

            // Show graph log view start/stop time bars               
            pObj = m_ppISysmon[0];  
            pPrivObj = (CImpISystemMonitor*)pObj;
            pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );
            fChange = TRUE;
            m_bRangeChg = TRUE;
            break;
        }

    if (fChange)
        SetChange();
}

DWORD 
CSourcePropPage::OpenLogFile (void)
{
    DWORD         dwStatus = ERROR_SUCCESS;
    DWORD         nBufSize;
    DWORD         nLogEntries = 0;
    PDH_TIME_INFO TimeInfo;

    LPTSTR       szLogFileList   = NULL;
    LPTSTR       szCurrentLogFile;
    ULONG        LogFileListSize = 0;
    HWND         hwndLogFileList = NULL;
    INT          iLogFileCount;
    INT          iLogFileIndex;
    PLogItemInfo pInfo;
    BOOLEAN      bSqlLogSet =
                    (BST_CHECKED == IsDlgButtonChecked(m_hDlg,IDC_SRC_SQL));
    TCHAR   szDsnName[SQL_MAX_DSN_LENGTH + 1];
    TCHAR   szLogSetName[SQL_MAX_DSN_LENGTH + 1];
    INT     iSel;
    HWND    hDsnCombo;
    HWND    hLogSetCombo;

    memset (&TimeInfo, 0, sizeof(TimeInfo));

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCount = LBNumItems(hwndLogFileList);
    }

    if (bSqlLogSet) {
        LogFileListSize = 0;
        szDsnName[0] = _T('\0');
        szLogSetName[0] = _T('\0');
        hDsnCombo = GetDlgItem ( m_hDlg, IDC_DSN_COMBO);
        if ( NULL != hDsnCombo ) {
            iSel = (INT)CBSelection ( hDsnCombo );
            if ( LB_ERR != iSel ) {
        
                CBString (
                    hDsnCombo,
                    iSel,
                    szDsnName);
        
                hLogSetCombo = GetDlgItem ( m_hDlg, IDC_LOGSET_COMBO);
                if ( NULL != hLogSetCombo ) {
                    iSel = (INT)CBSelection ( hLogSetCombo );
                    if ( LB_ERR != iSel ) {
                        CBString(
                            hLogSetCombo,
                            iSel,
                            szLogSetName);
                        // Size includes 5 characters "SQL:" "!"and 2 nulls
                        LogFileListSize = lstrlen(szDsnName) + lstrlen(szLogSetName) + 7;
                    }
                }
            }
        }
    } else {
        if ( NULL != hwndLogFileList ) {
            for (iLogFileIndex = 0; iLogFileIndex < iLogFileCount; iLogFileIndex ++) {
                pInfo = (PLogItemInfo) LBData(hwndLogFileList, iLogFileIndex);
                if (pInfo && pInfo->pszPath) {
                    LogFileListSize += (lstrlen(pInfo->pszPath) + 1);
                }
            }
            LogFileListSize ++;
        }
    }
    
    szLogFileList = (LPTSTR) malloc(LogFileListSize * sizeof(TCHAR));
    if (szLogFileList) {
        if (bSqlLogSet) {
            ZeroMemory(szLogFileList, LogFileListSize * sizeof(TCHAR));
            _stprintf(szLogFileList, _T("SQL:%s!%s"), szDsnName, szLogSetName);
        } else {
            if ( NULL != hwndLogFileList ) {
                szCurrentLogFile = szLogFileList;
                for (iLogFileIndex = 0;
                     iLogFileIndex < iLogFileCount;
                     iLogFileIndex ++) {
                    pInfo = (PLogItemInfo) LBData(hwndLogFileList, iLogFileIndex);
                    if (pInfo && pInfo->pszPath) {
                        lstrcpy(szCurrentLogFile, pInfo->pszPath);
                        szCurrentLogFile   += lstrlen(pInfo->pszPath);
                        * szCurrentLogFile  = _T('\0');
                        szCurrentLogFile ++;
                    }
                }
                * szCurrentLogFile = _T('\0');
            }
        }

        if (   m_hDataSource != H_REALTIME_DATASOURCE
            && m_hDataSource != H_WBEM_DATASOURCE) 
        {
            PdhCloseLog(m_hDataSource, 0);
            m_hDataSource = H_REALTIME_DATASOURCE;
        }
        dwStatus = PdhBindInputDataSource(& m_hDataSource, szLogFileList);
        if ( ERROR_SUCCESS == dwStatus ) {
            // Get time and sample count info
            nBufSize = sizeof(TimeInfo);
            dwStatus = PdhGetDataSourceTimeRangeH(
                        m_hDataSource, &nLogEntries, &TimeInfo, & nBufSize);
            PdhCloseLog(m_hDataSource, 0);
            m_hDataSource = H_REALTIME_DATASOURCE;
        }
  
        free(szLogFileList);
        szLogFileList = NULL;

    } else {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (ERROR_NOT_ENOUGH_MEMORY == dwStatus ) {
        dwStatus = SMON_STATUS_LOG_FILE_SIZE_LIMIT;
    }
    
    if ( ERROR_SUCCESS == dwStatus ) {
        // Check that at least 2 samples exist:
        //  If 0 samples, StartTime is 0, EndTime is 0
        //  If 1 sample, StartTime == EndTime
        if ( ( TimeInfo.StartTime < TimeInfo.EndTime )
                && ( 1 < TimeInfo.SampleCount ) ){
            // Load log time range into time range control
            m_llBegin = TimeInfo.StartTime;
            m_llEnd = TimeInfo.EndTime; 

            // Limit view range to actual log file range
            if (m_llStop > m_llEnd ) {
                m_llStop = m_llEnd;
            } else if (m_llStop < m_llBegin ) {
                m_llStop = m_llBegin;    
            }

            if (m_llStart < m_llBegin)
                m_llStart = m_llBegin;

            if (m_llStart > m_llStop) 
                m_llStart = m_llStop;

            m_pTimeRange->SetBeginEnd(m_llBegin, m_llEnd);
            m_pTimeRange->SetStartStop(m_llStart, m_llStop);
        } else {
            dwStatus = SMON_STATUS_TOO_FEW_SAMPLES;
        }
    }
    return dwStatus;    
    
}

void
CSourcePropPage::SetTimeRangeCtrlState ( 
    BOOL bIsValidLogFile, 
    BOOL bIsValidLogFileRange ) 
{
    // Enable time range button if valid log file, even if log data is invalid.
    DialogEnable ( m_hDlg, IDC_TIMESELECTBTN, bIsValidLogFile );

    // Set time range controls visible or not, depending on valid log file and data.
    DialogEnable ( m_hDlg, IDC_TIMERANGE, bIsValidLogFile && bIsValidLogFileRange );
    DialogEnable ( m_hDlg, IDC_STATIC_TOTAL, bIsValidLogFile && bIsValidLogFileRange );
    DialogEnable ( m_hDlg, IDC_STATIC_SELECTED, bIsValidLogFile && bIsValidLogFileRange );
}

void
CSourcePropPage::InitSqlDsnList(void)
{
    HENV             henv;
    RETCODE          retcode;
    INT              DsnCount           = 0;
    HWND             hWnd = NULL;
    TCHAR            szTmpName[SQL_MAX_DSN_LENGTH + 1];

    hWnd = GetDlgItem(m_hDlg, IDC_DSN_COMBO);

    if ( NULL != hWnd ) {
    
        if (SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_ENV, NULL, & henv))) {
            (void) SQLSetEnvAttr(henv,
                                 SQL_ATTR_ODBC_VERSION,
                                 (SQLPOINTER) SQL_OV_ODBC3,
                                 SQL_IS_INTEGER);
            // Todo:  NULL hWnd
            CBReset(hWnd);          
            
            ZeroMemory ( szTmpName, sizeof(szTmpName) );

            retcode = SQLDataSources(henv,
                                     SQL_FETCH_FIRST_SYSTEM,
                                     szTmpName,           
                                     sizeof(szTmpName),
                                     NULL,
                                     NULL, 
                                     0, 
                                     NULL);
            while (SQL_SUCCEEDED(retcode)) {
                CBAdd(hWnd, szTmpName);
                ZeroMemory ( szTmpName, sizeof(szTmpName) );
                retcode = SQLDataSources(henv,
                                         SQL_FETCH_NEXT,
                                         szTmpName,
                                         sizeof(szTmpName),
                                         NULL,
                                         NULL,
                                         0,
                                         NULL);
            }

            DsnCount = CBNumItems(hWnd) - 1;
            if (DsnCount >= 0) {
                if ( m_szSqlDsnName[0] != _T('\0')) {
                    while (DsnCount >= 0) {
                        CBString(hWnd, DsnCount, szTmpName);
                        if (lstrcmpi(m_szSqlDsnName, szTmpName) == 0) {
                            CBSetSelection(hWnd, DsnCount);
                            break;
                        }
                        else {
                            DsnCount --;
                        }
                    }
                    // Todo: Clear m_szSqlDsnName if not in list? 
                }
                else {
                    DsnCount = -1;
                }
            }
            SQLFreeHandle(SQL_HANDLE_ENV, henv);
        }
    }
}

void
CSourcePropPage::InitSqlLogSetList(void)
{
    PDH_STATUS      pdhStatus          = ERROR_SUCCESS;
    INT             iLogSetIndex       = 0;
    LPTSTR          pLogSetList        = NULL;
    DWORD           dwBufferLen        = 0;
    LPTSTR          pLogSetPtr         = NULL;
    HWND            hwndLogSetCombo    = NULL;
    LPTSTR          szTmpName = NULL;
    INT             iBufAllocCount = 0;
    INT             iMaxNameLen = 0;
    INT             iCurrentNameLen = 0;

    if ( _T('\0') == m_szSqlDsnName[0] ) {
        goto Cleanup;
    }

    hwndLogSetCombo = GetDlgItem(m_hDlg, IDC_LOGSET_COMBO);

    if ( NULL == hwndLogSetCombo ) {
        goto Cleanup;
    }

    do {
        pdhStatus = PdhEnumLogSetNames(
                                m_szSqlDsnName, pLogSetList, & dwBufferLen);
        if (pdhStatus == PDH_INSUFFICIENT_BUFFER || pdhStatus == PDH_MORE_DATA)
        {
            iBufAllocCount += 1;
            if (pLogSetList) {
                delete(pLogSetList);
                pLogSetList = NULL;
            }
            pLogSetList = (LPTSTR) new TCHAR[dwBufferLen];
            if (pLogSetList == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    }
    while ( ( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus ) 
                && iBufAllocCount < 10 );

    if (pdhStatus == ERROR_SUCCESS && pLogSetList != NULL) {
        CBReset(hwndLogSetCombo);
        for (  pLogSetPtr  = pLogSetList;
             * pLogSetPtr != _T('\0');
               pLogSetPtr += ( iCurrentNameLen + 1)) 
        {
            CBAdd(hwndLogSetCombo, pLogSetPtr);
            iCurrentNameLen = lstrlen(pLogSetPtr);
            if ( iMaxNameLen < iCurrentNameLen ) {
                iMaxNameLen = iCurrentNameLen;
            }
        }
        iLogSetIndex = CBNumItems(hwndLogSetCombo) - 1;

        if (iLogSetIndex >= 0) {
            if ( m_szSqlLogSetName[0] != _T('\0')) {
                szTmpName = new TCHAR[iMaxNameLen+1];
                if ( NULL != szTmpName ) {
                    while (iLogSetIndex >= 0) {
                        CBString(hwndLogSetCombo, iLogSetIndex, szTmpName);
                        if (lstrcmpi( m_szSqlLogSetName, szTmpName) == 0) {
                            CBSetSelection(hwndLogSetCombo, iLogSetIndex);
                            break;
                        }
                        else {
                            iLogSetIndex --;
                        }
                    }
                } else {
                    iLogSetIndex = -1;
                }
            } else {
                iLogSetIndex = -1;
            }
                // Todo: Clear m_szSqlLogSetName if not in list? 
        } else {
            if ( 0 == CBNumItems(hwndLogSetCombo) ) {
                iMaxNameLen = lstrlen ( ResourceString(IDS_LOGSET_NOT_FOUND) );
                szTmpName = new TCHAR[iMaxNameLen+1];
                if ( NULL != szTmpName ) {
                    lstrcpy(szTmpName, ResourceString(IDS_LOGSET_NOT_FOUND));
                    CBReset(hwndLogSetCombo);
                    iLogSetIndex = (INT)CBAdd(hwndLogSetCombo, szTmpName);
                    CBSetSelection( hwndLogSetCombo, iLogSetIndex);
                }
            }
        }
    } else {
        if ( 0 == CBNumItems(hwndLogSetCombo) ) {
            iMaxNameLen = lstrlen ( ResourceString(IDS_LOGSET_NOT_FOUND) );
            szTmpName = new TCHAR[iMaxNameLen+1];
            if ( NULL != szTmpName ) {
                lstrcpy(szTmpName, ResourceString(IDS_LOGSET_NOT_FOUND));
                CBReset(hwndLogSetCombo);
                iLogSetIndex = (INT)CBAdd(hwndLogSetCombo, szTmpName);
                CBSetSelection( hwndLogSetCombo, iLogSetIndex);
            }
        }
    }

Cleanup:
    if (pLogSetList) {
        delete pLogSetList;
    }

    if ( szTmpName ) {
        delete szTmpName;
    }
    return;
}

HRESULT 
CSourcePropPage::EditPropertyImpl( DISPID dispID )
{
    HRESULT hr = E_NOTIMPL;

    if ( DISPID_SYSMON_DATASOURCETYPE == dispID ) {
        if ( sysmonCurrentActivity == m_eDataSourceType ) {
            m_dwEditControl = IDC_SRC_REALTIME;
        } else if ( sysmonLogFiles == m_eDataSourceType ) {
            m_dwEditControl = IDC_SRC_LOGFILE;
        } else if ( sysmonSqlLog == m_eDataSourceType ) {
            m_dwEditControl = IDC_SRC_SQL;
        }
        hr = S_OK;
    }

    return hr;
}

void 
CSourcePropPage::SetSourceControlStates ( void )
{
    HWND    hwndLogFileList = NULL; 
    INT     iLogFileCnt = 0; 
    BOOL    bIsValidDataSource = FALSE;

    if ( sysmonCurrentActivity == m_eDataSourceType ) { 
        DialogEnable(m_hDlg, IDC_ADDFILE, FALSE);
        DialogEnable(m_hDlg, IDC_REMOVEFILE, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_DSN, FALSE);
        DialogEnable(m_hDlg, IDC_DSN_COMBO, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_LOGSET, FALSE);
        DialogEnable(m_hDlg, IDC_LOGSET_COMBO, FALSE);

        bIsValidDataSource = FALSE;
    
    } else if ( sysmonLogFiles == m_eDataSourceType ) {
        DialogEnable(m_hDlg, IDC_ADDFILE, TRUE);
        DialogEnable(m_hDlg, IDC_STATIC_DSN, FALSE);
        DialogEnable(m_hDlg, IDC_DSN_COMBO, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_LOGSET, FALSE);
        DialogEnable(m_hDlg, IDC_LOGSET_COMBO, FALSE);

        hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
        if ( NULL != hwndLogFileList ) {
            iLogFileCnt = LBNumItems(hwndLogFileList);
        }
        bIsValidDataSource = (iLogFileCnt > 0);

        DialogEnable(m_hDlg, IDC_REMOVEFILE, ( bIsValidDataSource ) );     
        
    } else {
        assert ( sysmonSqlLog == m_eDataSourceType );
        
        DialogEnable(m_hDlg, IDC_ADDFILE, FALSE);
        DialogEnable(m_hDlg, IDC_REMOVEFILE, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_DSN, TRUE);
        DialogEnable(m_hDlg, IDC_DSN_COMBO, TRUE);
        DialogEnable(m_hDlg, IDC_STATIC_LOGSET, TRUE);
        DialogEnable(m_hDlg, IDC_LOGSET_COMBO, TRUE);

        bIsValidDataSource = 0 < lstrlen ( m_szSqlDsnName ) && 0 < lstrlen ( m_szSqlLogSetName );
    }
    m_bInitialTimeRangePending = TRUE;
    SetTimeRangeCtrlState( bIsValidDataSource, FALSE );
}

DWORD
CSourcePropPage::BuildLogFileList ( 
    HWND    /*hwndDlg*/,
    LPWSTR  szLogFileList,
    ULONG*  pulBufLen )
{

    DWORD           dwStatus = ERROR_SUCCESS;
    ULONG           ulListLen;
    HWND            hwndLogFileList = NULL;
    INT             iLogFileCount;
    INT             iLogFileIndex;
    PLogItemInfo    pInfo = NULL;
    LPCWSTR         szThisLogFile = NULL;
    LPWSTR          szLogFileCurrent = NULL;

    WCHAR           cwComma = L',';

    if ( NULL != pulBufLen ) {

        ulListLen = 0;
        hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
        if ( NULL != hwndLogFileList ) {
            iLogFileCount = LBNumItems(hwndLogFileList);
            if ( 0 < iLogFileCount ) {
                for ( iLogFileIndex = 0; iLogFileIndex < iLogFileCount; iLogFileIndex++ ) {
                    pInfo = (PLogItemInfo)LBData(hwndLogFileList,iLogFileIndex);
                    szThisLogFile = pInfo->pszPath;
                    ulListLen += (lstrlen(szThisLogFile) + 1);
                } 
                
                ulListLen ++; // for the single final NULL character.
    
                if ( ulListLen <= *pulBufLen ) {
                    if ( NULL != szLogFileList ) {
                        ZeroMemory(szLogFileList, (ulListLen * sizeof(WCHAR)));
                        szLogFileCurrent = (LPTSTR) szLogFileList;
                        for ( iLogFileIndex = 0; iLogFileIndex < iLogFileCount; iLogFileIndex++ ) {
                            pInfo = (PLogItemInfo)LBData(hwndLogFileList,iLogFileIndex);
                            szThisLogFile = pInfo->pszPath;
                            lstrcpy(szLogFileCurrent, szThisLogFile);
                            szLogFileCurrent  += lstrlen(szThisLogFile);
                            *szLogFileCurrent = L'\0';
                            if ( (iLogFileIndex + 1) < iLogFileCount ) {
                                // If comma delimited, replace the NULL char with a comma
                                *szLogFileCurrent = cwComma;
                            }
                            szLogFileCurrent ++;
                        }
                    }
                } else if ( NULL != szLogFileList ) {
                    dwStatus = ERROR_MORE_DATA;
                } 
            }
        }
        *pulBufLen = ulListLen;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        assert ( FALSE );
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\stepper.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    stepper.cpp

Abstract:

    Implements time keeping and display in the graph window.

--*/

#include "polyline.h"

CStepper::CStepper()
{
    m_iPos = 0;
    m_iStepNum = 0;
    m_iStepCnt = 1;
}

void CStepper::Init(INT iLength, INT iStepCnt)
{
    m_iStepCnt = iStepCnt ? iStepCnt : 1;
    m_iStepSize = iLength / m_iStepCnt;
    m_iRemainder = iLength - m_iStepCnt * m_iStepSize;

    m_iState = m_iStepCnt;
    m_iPos = 0;
    m_iStepNum = 0;
}

void CStepper::Reset()
{
    m_iPos = 0;
    m_iStepNum = 0;
    m_iState = m_iStepCnt;
}

INT CStepper::NextPosition()
{
    m_iPos += m_iStepSize;

    m_iState -= m_iRemainder;

    if (m_iState <= 0)
        {
        m_iState += m_iStepCnt;
        m_iPos++;
        }

    m_iStepNum++;

    return m_iPos;
}


INT CStepper::PrevPosition()
{   
    m_iPos -= m_iStepSize;

    m_iState += m_iRemainder;

    if (m_iState > m_iStepCnt)
    {
        m_iState -= m_iStepCnt;
        m_iPos--;
    }

    m_iStepNum--;

    return m_iPos;
}

    
INT CStepper::StepTo(INT nSteps)
{
    INT iDiff;

    iDiff = (nSteps * m_iRemainder) / m_iStepCnt;
    m_iState = (iDiff + 1) * m_iStepCnt - (nSteps * m_iRemainder);

    m_iPos = (nSteps * m_iStepSize) + iDiff;

    m_iStepNum = nSteps;

    return m_iPos;
}

INT CStepper::PrevStepNum( INT iPosition )
{
    INT iStepNum = -1;
    INT iLength;

    // Floating point conversion to integer truncates,
    // so this method returns the step previous to the position.

    iLength = m_iStepCnt * m_iStepSize + m_iRemainder;

    if ( iPosition <= iLength ) {
        // Calculation is (iPosition/iLength) * m_iStepCnt.
        iStepNum = iPosition * m_iStepCnt;
        iStepNum = iStepNum / iLength;
    }

    return iStepNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\strids.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strids.h

Abstract:

    This file contains constants for all of the resource strings. It must
    parallel file strings.rc which contains the strings themselves.

    Constants of the form IDS_*_BASE are not strings but are base values
    for use in indexing within the string group. The base value must match the
    ID of the first string and the order of the strings must not be changed.

--*/

#ifndef _STRIDS_H_
#define _STRIDS_H_



#define RCSTRING_MIN_ID     128

// Statistics Bar Labels
#define IDS_STAT_BASE       128
#define IDS_LAST            128
#define IDS_AVERAGE         129
#define IDS_MINIMUM         130
#define IDS_MAXIMUM         131
#define IDS_GRAPH_TIME      132 

// Legend Labels
#define IDS_LEGEND_BASE     135
#define IDS_COLOR           135
#define IDS_SCALE           136
#define IDS_COUNTER         137
#define IDS_INSTANCE        138
#define IDS_PARENT          139
#define IDS_OBJECT          140
#define IDS_SYSTEM          141

// OLE Strings
#define IDS_USERTYPE        144
#define IDS_CLOSECAPTION    145
#define IDS_CLOSEPROMPT     146

// Property Page Titles
#define IDS_PROPFRM_TITLE       150
#define IDS_CTR_PROPP_TITLE     151
#define IDS_GEN_PROPP_TITLE     152
#define IDS_GRAPH_PROPP_TITLE   153
#define IDS_SRC_PROPP_TITLE     154
#define IDS_APPEAR_PROPP_TITLE  155

// Error Messages
#define IDS_VERTMIN_ERR         160
#define IDS_VERTMAX_ERR         161
#define IDS_SCALE_ERR           162
#define IDS_DUPL_PATH_ERR       163
#define IDS_NOLOGFILE_ERR       164
#define IDS_INTERVAL_ERR        165
#define IDS_DISPLAY_INT_ERR     166
#define IDS_BADDATASOURCE_ERR   167
#define IDS_NOSYSMONOBJECT_ERR  168
#define IDS_SAVEAS_ERR          169
#define IDS_TOO_FEW_SAMPLES_ERR 170
#define IDS_LARGE_LOG_FILE_RELOAD   171
#define IDS_LOG_FILE_TOO_LARGE_ERR  172
#define IDS_LOGSET_NOT_FOUND    173
#define IDS_READFILE_ERR        174
#define IDS_ADD_COUNTER_ERR     175
#define IDS_ADD_LOG_FILE_ERR    176

// toolbar tooltip strings
#define IDS_TB_BASE             177
#define IDS_TB_TOOLBAR          177
#define IDS_TB_NEW              178
#define IDS_TB_CLEAR            179
#define IDS_TB_REALTIME         180
#define IDS_TB_LOGFILE          181
#define IDS_TB_CHART            182
#define IDS_TB_HISTOGRAM        183
#define IDS_TB_REPORT           184
#define IDS_TB_ADD              185
#define IDS_TB_DELETE           186
#define IDS_TB_HIGHLIGHT        187
#define IDS_TB_COPY             188
#define IDS_TB_PASTE            189
#define IDS_TB_PROPERTIES       190
#define IDS_TB_FREEZE           191
#define IDS_TB_UPDATE           192
#define IDS_TB_HELP             193


// Appearance and BorderStyle

#define IDS_APPEARANCE_FLAT     196
#define IDS_APPEARANCE_3D       197
#define IDS_BORDERSTYLE_NONE    198
#define IDS_BORDERSTYLE_SINGLE  199

// Copy/Paste
#define IDS_HTML_OBJECT_HEADER      200
#define IDS_HTML_OBJECT_FOOTER      201
#define IDS_HTML_PARAM_TAG          202
#define IDS_HTML_VALUE_TAG          203
#define IDS_HTML_VALUE_EOL_TAG      204
#define IDS_HTML_PARAM_SEARCH_TAG   205
#define IDS_HTML_VALUE_SEARCH_TAG   206

// Save As
#define IDS_HTML_FILE               210
#define IDS_HTM_EXTENSION           211
#define IDS_HTML_FILE_HEADER1       212
#define IDS_HTML_FILE_HEADER2       213
#define IDS_HTML_FILE_FOOTER        214
#define IDS_HTML_FILE_OVERWRITE     215
#define IDS_TSV_EXTENSION           216
#define IDS_DEF_EXT                 217
#define IDS_COMPUTER                218
#define IDS_OBJECT_NAME             219
#define IDS_REPORT_HEADER           220
#define IDS_REPORT_INTERVAL         221
#define IDS_REPORT_REAL_TIME        222
#define IDS_REPORT_LOG_START        223
#define IDS_REPORT_LOG_STOP         224
#define IDS_REPORT_DATE_TIME        225
#define IDS_REPORT_START_STOP       226
#define IDS_REPORT_VALUE_TYPE       227
#define IDS_LOG_FILE                228
#define IDS_LOG_FILE_EXTENSION      229
#define IDS_CSV_EXTENSION           230
#define IDS_BLG_EXTENSION           231
#define IDS_SAVE_DATA_CAPTION       232
#define IDS_HTML_EXTENSION          233

// Miscellaneous
#define IDS_APP_NAME                250
#define IDS_DEFAULT                 251
#define IDS_ADDCOUNTERS             252
#define IDS_SAMPLE_DATA_OVERWRITE   253
#define IDS_SAMPLE_DATA_MISSING     254
#define IDS_DEFAULT_LOG_FILE_FOLDER 255

#define IDS_COLORCHOICE_GRAPH       256
#define IDS_COLORCHOICE_CONTROL     257
#define IDS_COLORCHOICE_TEXT        258 
#define IDS_COLORCHOICE_GRID        259
#define IDS_COLORCHOICE_TIMEBAR     260

// Command line arguments
#define IDS_CMDARG_WMI              300
#define IDS_CMDARG_SETTINGS         301

//TraceLog Message
#define IDS_TRACE_LOG_ERR_MSG       350
#define IDS_HTML_LOG_TYPE           351 

// More error messages
#define IDS_NO_SQL_DSN_ERR              400
#define IDS_NO_SQL_LOG_SET_ERR          401
#define IDS_DUPL_LOGFILE_ERR            402
#define IDS_MULTILOG_BIN_TYPE_ADD_ERR   403
#define IDS_MULTILOG_TEXT_TYPE_ADD_ERR  404
#define IDS_MULTILOG_BIN_TYPE_ERR       405
#define IDS_MULTILOG_TEXT_TYPE_ERR      406
#define IDS_MULTILOG_CHECKTYPE_ERR      407
#define IDS_MULTILOG_TIMERANGE_ERR      408

#endif // _STRIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\strnoloc.cpp ===
#include <windows.h>
#include "strnoloc.h"

LPCWSTR CGlobalString::m_cszVersion                   = L"_Version";
LPCWSTR CGlobalString::m_cszLogType                   = L"LogType";
LPCWSTR CGlobalString::m_cszExtentX                   = L"_ExtentX";
LPCWSTR CGlobalString::m_cszExtentY                   = L"_ExtentY";
LPCWSTR CGlobalString::m_cszDisplayType               = L"DisplayType";
LPCWSTR CGlobalString::m_cszReportValueType           = L"ReportValueType";
LPCWSTR CGlobalString::m_cszMaximumScale              = L"MaximumScale";
LPCWSTR CGlobalString::m_cszMinimumScale              = L"MinimumScale";
LPCWSTR CGlobalString::m_cszAppearance                = L"Appearance";
LPCWSTR CGlobalString::m_cszBorderStyle               = L"BorderStyle";
LPCWSTR CGlobalString::m_cszShowLegend                = L"ShowLegend";
LPCWSTR CGlobalString::m_cszShowToolBar               = L"ShowToolbar";
LPCWSTR CGlobalString::m_cszShowValueBar              = L"ShowValueBar";
LPCWSTR CGlobalString::m_cszShowScaleLabels           = L"ShowScaleLabels";
LPCWSTR CGlobalString::m_cszShowHorizontalGrid        = L"ShowHorizontalGrid";
LPCWSTR CGlobalString::m_cszShowVerticalGrid          = L"ShowVerticalGrid";
LPCWSTR CGlobalString::m_cszHighLight                 = L"Highlight";
LPCWSTR CGlobalString::m_cszManualUpdate              = L"ManualUpdate";
LPCWSTR CGlobalString::m_cszReadOnly                  = L"ReadOnly";
LPCWSTR CGlobalString::m_cszMonitorDuplicateInstance  = L"MonitorDuplicateInstances";
LPCWSTR CGlobalString::m_cszUpdateInterval            = L"UpdateInterval";
LPCWSTR CGlobalString::m_cszDisplayFilter             = L"DisplayFilter";
LPCWSTR CGlobalString::m_cszBackColorCtl              = L"BackColorCtl";
LPCWSTR CGlobalString::m_cszBackColor                 = L"BackColor";
LPCWSTR CGlobalString::m_cszForeColor                 = L"ForeColor";
LPCWSTR CGlobalString::m_cszGridColor                 = L"GridColor";
LPCWSTR CGlobalString::m_cszTimeBarColor              = L"TimeBarColor";
LPCWSTR CGlobalString::m_cszGraphTitle                = L"GraphTitle";
LPCWSTR CGlobalString::m_cszYAxisLabel                = L"YAxisLabel";
LPCWSTR CGlobalString::m_cszSqlDsnName                = L"SqlDsnName";
LPCWSTR CGlobalString::m_cszSqlLogSetName             = L"SqlLogSetName";
LPCWSTR CGlobalString::m_cszLogViewStart              = L"LogViewStart";
LPCWSTR CGlobalString::m_cszLogViewStop               = L"LogViewStop";
LPCWSTR CGlobalString::m_cszDataSourceType            = L"DataSourceType";
LPCWSTR CGlobalString::m_cszAmbientFont               = L"AmbientFont";
LPCWSTR CGlobalString::m_cszNextCounterColor          = L"NextCounterColor";
LPCWSTR CGlobalString::m_cszNextCounterWidth          = L"NextCounterWidth";
LPCWSTR CGlobalString::m_cszNextCounterLineStyle      = L"NextCounterLineStyle";
LPCWSTR CGlobalString::m_cszLogFileName               = L"LogFileName";
LPCWSTR CGlobalString::m_cszLogFileCount            = L"LogFileCount";
LPCWSTR CGlobalString::m_cszCounterCount              = L"CounterCount";
LPCWSTR CGlobalString::m_cszMaximumSamples            = L"MaximumSamples";
LPCWSTR CGlobalString::m_cszSampleCount               = L"SampleCount";
LPCWSTR CGlobalString::m_cszSampleIndex               = L"SampleIndex";
LPCWSTR CGlobalString::m_cszStepNumber                = L"StepNumber";
LPCWSTR CGlobalString::m_cszSelected                  = L"Selected";
LPCWSTR CGlobalString::m_cszCounter                 = L"Counter";
LPCWSTR CGlobalString::m_cszLogNameFormat           = L"%s%03d";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\strnoloc.h ===
#ifndef _STR_NO_LOC_H_
#define _STR_NO_LOC_H_

class CGlobalString {
public:
    CGlobalString() {};
    ~CGlobalString() {};

    static LPCWSTR m_cszVersion;
    static LPCWSTR m_cszLogType;
    static LPCWSTR m_cszExtentX;
    static LPCWSTR m_cszExtentY;
    static LPCWSTR m_cszDisplayType;
    static LPCWSTR m_cszReportValueType;
    static LPCWSTR m_cszMaximumScale;
    static LPCWSTR m_cszMinimumScale;
    static LPCWSTR m_cszAppearance;
    static LPCWSTR m_cszBorderStyle;
    static LPCWSTR m_cszShowLegend;
    static LPCWSTR m_cszShowToolBar;
    static LPCWSTR m_cszShowValueBar;
    static LPCWSTR m_cszShowScaleLabels;
    static LPCWSTR m_cszShowHorizontalGrid;
    static LPCWSTR m_cszShowVerticalGrid;
    static LPCWSTR m_cszHighLight;
    static LPCWSTR m_cszManualUpdate;
    static LPCWSTR m_cszReadOnly;
    static LPCWSTR m_cszMonitorDuplicateInstance;
    static LPCWSTR m_cszUpdateInterval;
    static LPCWSTR m_cszDisplayFilter;
    static LPCWSTR m_cszBackColorCtl;
    static LPCWSTR m_cszBackColor;
    static LPCWSTR m_cszForeColor;
    static LPCWSTR m_cszGridColor;
    static LPCWSTR m_cszTimeBarColor;
    static LPCWSTR m_cszGraphTitle;
    static LPCWSTR m_cszYAxisLabel;
    static LPCWSTR m_cszSqlDsnName;
    static LPCWSTR m_cszSqlLogSetName;
    static LPCWSTR m_cszLogViewStart;
    static LPCWSTR m_cszLogViewStop;
    static LPCWSTR m_cszDataSourceType;
    static LPCWSTR m_cszAmbientFont;
    static LPCWSTR m_cszNextCounterColor;
    static LPCWSTR m_cszNextCounterWidth;
    static LPCWSTR m_cszLogFileName;
    static LPCWSTR m_cszLogFileCount;
    static LPCWSTR m_cszCounterCount;
    static LPCWSTR m_cszMaximumSamples;
    static LPCWSTR m_cszSampleCount;
    static LPCWSTR m_cszSampleIndex;
    static LPCWSTR m_cszStepNumber;
    static LPCWSTR m_cszSelected;
    static LPCWSTR m_cszNextCounterLineStyle;
    static LPCWSTR m_cszCounter;
    static LPCWSTR m_cszLogNameFormat;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\timerng.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    timerng.cpp

Abstract:

    <abstract>

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#include <assert.h>
#include <windows.h>
#include "winhelpr.h"
#include "utils.h"
#include "timerng.h"
#include "globals.h"

#define INTRVBAR_RANGE 1000
#define MAX_TIME_CHARS  20
#define MAX_DATE_CHARS  20

TCHAR szTimeRangeClass[] = TEXT("TimeRange");

INT 
CTimeRange::MaxTimeWidth (
    HDC hDC 
    )
/*
   Effect:        Return a reasonable maximum number of pixels to hold
                  expected time and date strings.  

   To Do:         When we use the alleged local-date and local-time display
                  functions, we will modify this routine to use them.
*/
{
   return (max (TextWidth (hDC, TEXT(" 99 XXX 99 ")),
                TextWidth (hDC, TEXT(" 99:99:99.9 PM ")))) ;
}

void 
CTimeRange::DrawBeginEnd (
    HDC hDC
    )
{
   TCHAR         szDate [MAX_TIME_CHARS] ;
   TCHAR         szTime [MAX_DATE_CHARS] ;

   SetTextAlign (hDC, TA_TOP) ;
   SelectFont (hDC, m_hFont) ;
   SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
   SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT));

   // Draw the begin time
   FormatDateTime(m_llBegin, szTime, szDate);
   SetTextAlign (hDC, TA_RIGHT) ;
   TextOut (hDC, m_xBegin, 0, szDate, lstrlen (szDate)) ;
   TextOut (hDC, m_xBegin, m_yFontHeight, szTime, lstrlen (szTime)) ;

   // Draw the end time
   FormatDateTime(m_llEnd, szTime, szDate);
   SetTextAlign (hDC, TA_LEFT) ;
   TextOut (hDC, m_xEnd, 0, szDate, lstrlen (szDate)) ;
   TextOut (hDC, m_xEnd, m_yFontHeight, szTime, lstrlen (szTime)) ;
}



void
CTimeRange::DrawStartStop (
    HDC hDC
    )
/*
   Effect:        Draw the start and stop date/times on the bottom of the
                  timeline. Draw the start date/time right justified at the
                  outer edge of the start point and the stop date/time left
                  justified with the outer edge of the stop point.

                  Erase previous start and stop date/times in the process.
*/
{
   RECT           rectDate ;
   RECT           rectTime ;
   RECT           rectOpaque ;

   TCHAR          szTime [MAX_TIME_CHARS] ;
   TCHAR          szDate [MAX_DATE_CHARS] ;

   INT            xStart ;
   INT            xStop ;

   INT            iStart ;
   INT            iStop ;

   INT            xDateTimeWidth ;


   SelectFont (hDC, m_hFont) ;
   SetTextAlign (hDC, TA_TOP) ;
   SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
   SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT));

   //=============================//
   // Get Start Information       //
   //=============================//

   xStart = m_xBegin + m_pIntrvBar->XStart();

   iStart = m_pIntrvBar->Start() ;
   m_llStart = m_llBegin + ((m_llEnd - m_llBegin) * iStart) / INTRVBAR_RANGE;

   FormatDateTime(m_llStart, szTime, szDate);

   xDateTimeWidth = max (TextWidth (hDC, szDate),
                         TextWidth (hDC, szTime)) ;

   //=============================//
   // Write Start Date            //
   //=============================//

   rectDate.left = xStart - xDateTimeWidth ;
   rectDate.top = m_rectStartDate.top ;
   rectDate.right = xStart ;
   rectDate.bottom = m_rectStartDate.bottom ;
 
   SetTextAlign (hDC, TA_RIGHT) ;
   UnionRect (&rectOpaque, &m_rectStartDate, &rectDate) ;

   ExtTextOut (hDC, 
               rectDate.right, rectDate.top,
               ETO_OPAQUE,
               &rectOpaque,
               szDate, lstrlen (szDate),
               NULL) ;
   m_rectStartDate = rectDate ;

   //=============================//
   // Write Start Time            //
   //=============================//
   
   rectTime.left = rectDate.left ;
   rectTime.top = m_rectStartTime.top ;
   rectTime.right = rectDate.right ;
   rectTime.bottom = m_rectStartTime.bottom ;

   UnionRect (&rectOpaque, &m_rectStartTime, &rectTime) ;

   ExtTextOut (hDC, 
               rectTime.right, rectTime.top,
               ETO_OPAQUE,
               &rectOpaque,
               szTime, lstrlen (szTime),
               NULL) ;
   m_rectStartTime = rectTime ;

   //=============================//
   // Get Stop Information        //
   //=============================//

   xStop = m_xBegin + m_pIntrvBar->XStop() ;

   iStop = m_pIntrvBar->Stop () ;
   m_llStop = m_llBegin + ((m_llEnd - m_llBegin) * iStop) / INTRVBAR_RANGE;

   FormatDateTime(m_llStop, szTime, szDate);

   xDateTimeWidth = max (TextWidth (hDC, szDate),
                         TextWidth (hDC, szTime)) ;

   //=============================//
   // Write Stop Date             //
   //=============================//

   rectDate.left = xStop ;
   rectDate.top = m_rectStopDate.top ;
   rectDate.right = xStop + xDateTimeWidth ;
   rectDate.bottom = m_rectStopDate.bottom ;
 
   SetTextAlign (hDC, TA_LEFT) ;
   UnionRect (&rectOpaque, &m_rectStopDate, &rectDate) ;

   ExtTextOut (hDC, 
               rectDate.left, rectDate.top,
               ETO_OPAQUE,
               &rectOpaque,
               szDate, lstrlen (szDate),
               NULL) ;
   m_rectStopDate = rectDate ;

   //=============================//
   // Write Stop Time             //
   //=============================//
   
   rectTime.left = rectDate.left ;
   rectTime.top = m_rectStopTime.top ;
   rectTime.right = rectDate.right ;
   rectTime.bottom = m_rectStopTime.bottom ;

   UnionRect (&rectOpaque, &m_rectStopTime, &rectTime) ;

   ExtTextOut (hDC, 
               rectTime.left, rectTime.top,
               ETO_OPAQUE,
               &rectOpaque,
               szTime, lstrlen (szTime),
               NULL) ;
   m_rectStopTime = rectTime ;
}



//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


CTimeRange::CTimeRange (
    HWND hWnd )
{

    HDC      hDC ;

    // Caller checks for NULL hwnd before calling this procedure
    assert ( NULL != hWnd );

    m_hWnd = hWnd ;

    SetWindowLongPtr(hWnd, 0, (INT_PTR)this);

    m_hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT) ;

    hDC = GetDC (hWnd) ;
    if (hDC) {
        if ( NULL != m_hFont ) {
            SelectFont (hDC, m_hFont) ;
        }
        m_yFontHeight = FontHeight (hDC, TRUE) ;
        m_xMaxTimeWidth = MaxTimeWidth (hDC) ;

        ReleaseDC (hWnd, hDC) ;
    } else {
        m_yFontHeight = 0;
        m_xMaxTimeWidth = 0;
    }

    m_pIntrvBar = NULL;
}


CTimeRange::~CTimeRange (
    void 
    )
{
    if (m_pIntrvBar != NULL) {
        delete m_pIntrvBar;
        m_pIntrvBar = NULL;
    }
}

BOOL
CTimeRange::Init(
    void
    )
{
    RECT        rc;

    m_pIntrvBar = new CIntervalBar();
    if (m_pIntrvBar != NULL) {
        if (m_pIntrvBar->Init(m_hWnd)) {
            // Size now because we didn't exist when the window 
            // got the initial WM_SIZE message
            GetWindowRect(m_hWnd, &rc);
            OnSize(rc.right - rc.left, rc.bottom - rc.top);
            m_pIntrvBar->SetRange(0, INTRVBAR_RANGE);
        }
        else {
            delete m_pIntrvBar;
            m_pIntrvBar = NULL;
        }
    }

    return ( NULL != m_pIntrvBar );
}

void
CTimeRange::OnSize (
    INT xWidth,
    INT yHeight
    )
/*
   Effect:        Perform all actions needed when the size of the timeline
                  hWnd has changed. In particular, determine the appropriate
                  size for the ILine window and set the rectangles for the
                  top and bottom displays.
*/
{
   INT            yLine ;
   INT            yDate, yTime ;
   INT            xEnd ;

   xEnd = xWidth - m_xMaxTimeWidth ;
   yLine = m_yFontHeight ;
   yDate = yHeight - 2 * yLine ;
   yTime = yHeight - yLine ;


   SetRect (&m_rectStartDate, 0, yDate, 0, yDate + yLine) ;

   SetRect (&m_rectStartTime, 0, yTime, 0, yTime + yLine) ;

   SetRect (&m_rectStopDate, xEnd, yDate, xEnd, yDate + yLine) ;

   SetRect (&m_rectStopTime, xEnd, yTime, xEnd, yTime + yLine) ;

   MoveWindow (m_pIntrvBar->Window(),
               m_xMaxTimeWidth, 2 * m_yFontHeight,
               xWidth - 2 * m_xMaxTimeWidth,
               yHeight - 4 * m_yFontHeight,
               FALSE) ;

   m_xBegin = m_xMaxTimeWidth ;
   m_xEnd = xWidth - m_xMaxTimeWidth ;
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT APIENTRY TimeRangeWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*
   Note:          This function must be declared in the application's
                  linker-definition file, perfmon.def file.
*/
{
   BOOL           bCallDefWindowProc ;
   LRESULT        lrsltReturnValue ;
   PCTimeRange    pTimeRange = (PCTimeRange) GetWindowLongPtr(hWnd, 0);;
   bCallDefWindowProc = FALSE ;
   lrsltReturnValue = 0L ;


    if (pTimeRange) {

       switch ( uiMsg ) {

          case WM_SETFOCUS:
             return 0 ;

          case WM_KILLFOCUS:
             return 0 ;

          case WM_ENABLE:
              WindowInvalidate(hWnd);
              EnableWindow(pTimeRange->m_pIntrvBar->Window(), (BOOL)wParam);
              break;

          case WM_COMMAND:
              { 
                HDC hDC;

                hDC = GetDC (hWnd) ;
                if (hDC) {
                    pTimeRange->DrawStartStop (hDC) ;
                    ReleaseDC (hWnd, hDC) ;
                }
                SendMessage(
                    WindowParent(hWnd),
                    WM_COMMAND, (WPARAM)WindowID(hWnd), (LPARAM)hWnd);
             }
             break ;

          case WM_PAINT:
             {
                HDC          hDC ;
                PAINTSTRUCT  ps ;

                hDC = BeginPaint (hWnd, &ps) ;
                
                if (hDC) {
                    if (IsWindowEnabled(hWnd)) {
                        pTimeRange->DrawBeginEnd (hDC) ;
                        pTimeRange->DrawStartStop (hDC) ;
                    }

                    EndPaint (hWnd, &ps) ;
                }
             }
             break ;

          case WM_SIZE:
             pTimeRange->OnSize (LOWORD (lParam), HIWORD (lParam)) ;
             break ;

          default:
             bCallDefWindowProc = TRUE ;
          }
    }
    else {
        bCallDefWindowProc = TRUE;
    }

    if (bCallDefWindowProc)
        lrsltReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

   return (lrsltReturnValue) ;
}



BOOL RegisterTimeRangeClass (
    void
    )
{

#define dwTimeRangeClassStyle  (CS_HREDRAW | CS_VREDRAW)

    BEGIN_CRITICAL_SECTION

    // Register window class once
    if (pstrRegisteredClasses[TIMERANGE_WNDCLASS] == NULL) {

           WNDCLASS       wc ;

           wc.style =           dwTimeRangeClassStyle ;
           wc.lpfnWndProc =     (WNDPROC)TimeRangeWndProc ;
           wc.cbClsExtra =      0 ;
           wc.cbWndExtra =      sizeof(PCTimeRange);
           wc.hInstance =       g_hInstance ;
           wc.hIcon =           NULL ;
           wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ;
           wc.hbrBackground =   (HBRUSH) (COLOR_3DFACE + 1) ;
           wc.lpszMenuName =    NULL ;
           wc.lpszClassName =   szTimeRangeClass ;

            if (RegisterClass (&wc)) {
                pstrRegisteredClasses[TIMERANGE_WNDCLASS] = szTimeRangeClass;
        }
    }

    END_CRITICAL_SECTION

    return (pstrRegisteredClasses[LEGEND_WNDCLASS] != NULL);
}


void 
CTimeRange::SetBeginEnd ( 
    LONGLONG llBegin, 
    LONGLONG llEnd
    )
{
    HDC hDC;
    m_llBegin = llBegin;
    m_llEnd = llEnd;

    hDC = GetDC (m_hWnd) ;
    
    if (hDC) {
        DrawBeginEnd (hDC) ;
        ReleaseDC (m_hWnd, hDC) ;
    }
}

void 
CTimeRange::SetStartStop (
    LONGLONG    llStart,
    LONGLONG    llStop
    )
{
    INT iStart;
    INT iStop;
    HDC hDC; 
    LONGLONG llBeginToEnd;

    if (llStart < m_llBegin)
        llStart = m_llBegin;

    if (llStop > m_llEnd)
        llStop = m_llEnd;

    m_llStart = llStart;
    m_llStop = llStop;

    llBeginToEnd = m_llEnd - m_llBegin;

    if ( 0 != llBeginToEnd ) {
        iStart = (INT)(((llStart - m_llBegin) * INTRVBAR_RANGE) / llBeginToEnd);
        iStop = (INT)(((llStop - m_llBegin) * INTRVBAR_RANGE) / llBeginToEnd);
    } else {
        iStart = 0;
        iStop = 0;
    }

    m_pIntrvBar->SetStart(iStart);
    m_pIntrvBar->SetStop(iStop);

    hDC = GetDC (m_hWnd) ;
    if (hDC) {
        DrawStartStop (hDC) ;
        ReleaseDC (m_hWnd, hDC) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\strtable.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    strtable.cpp

Abstract:

    Implementation of a string table handler.  The CStringTable
    class hides details of storage from the user.  The strings might
    be cached, or they might be loaded as necessary.  In either case,
    we must know the number of strings so we know whether or not to
    reload strings.

--*/

#include <windows.h>
#include <malloc.h>
#include "polyline.h"
#include "strtable.h"

// Create global instance of table
CStringTable StringTable;

/*
 * CStringTable::CStringTable
 * CStringTable::~CStringTable
 *
 * Constructor Parameters:
 *  hInst           HANDLE to the application instance from which we
 *                  load strings.
 */

CStringTable::CStringTable(void)
{
    m_ppszTable = NULL;
}


CStringTable::~CStringTable(void)
{
    INT i;

    // Free the loaded strings and table
    if (NULL != m_ppszTable)
        {
        for (i=0; i<m_cStrings; i++)
            {
            if (m_ppszTable[i] != NULL)
                free(m_ppszTable[i]);
            }

        free(m_ppszTable);
        }
}


/*
 * CStringTable::Init
 *
 * Purpose:
 *  Initialization function for a StringTable that is prone to
 *  failure.  If this fails then the caller is responsible for
 *  guaranteeing that the destructor is called quickly.
 *
 * Parameters:
 *  idsMin          UINT first identifier in the stringtable
 *  idsMax          UINT last identifier in the stringtable.
 *
 * Return Value:
 *  BOOL            TRUE if the function is successful, FALSE
 *                  otherwise.
 */


BOOL CStringTable::Init(UINT idsMin, UINT idsMax)
{
    UINT        i;

    m_idsMin = idsMin;
    m_idsMax = idsMax;
    m_cStrings = (idsMax - idsMin + 1);

    //Allocate space for the pointer table.
    m_ppszTable = (LPTSTR *)malloc(sizeof(LPTSTR) * m_cStrings);

    if (NULL==m_ppszTable)
        return FALSE;

    // Clear all table entries
    for (i=0; i<m_cStrings; i++)
        m_ppszTable[i] = NULL;

    return TRUE;
}


/*
 * CStringTable::operator[]
 *
 * Purpose:
 *  Returns a pointer to the requested string in the stringtable or
 *  NULL if the specified string does not exist.
 */

LPTSTR CStringTable::operator[] (const UINT uID)
{
    TCHAR   szBuf[CCHSTRINGMAX];
    LPTSTR  psz;
    INT     iLen;
    static  TCHAR szMissing[] = TEXT("????");

    // if string not in range, return NULL
    if (uID < m_idsMin || uID > m_idsMax)
        return szMissing;

    // if already loaded, return it
    if (m_ppszTable[uID - m_idsMin] != NULL)
        return m_ppszTable[uID - m_idsMin];

    BEGIN_CRITICAL_SECTION
    // if selected string not loaded, load it now
    if (m_ppszTable[uID - m_idsMin] == NULL)
        {
        iLen = LoadString(g_hInstance, uID, szBuf, CCHSTRINGMAX - 1);
        if (iLen == 0)
            lstrcpy(szBuf, szMissing);

        psz = (LPTSTR)malloc((iLen + 1) * sizeof(TCHAR));
        if (psz != NULL)
            {
            lstrcpy(psz, szBuf);
            m_ppszTable[uID - m_idsMin] = psz;
            }
        }
    END_CRITICAL_SECTION

    // Now return selected pointer
    return m_ppszTable[uID - m_idsMin];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\toolbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    toolbar.cpp

Abstract:

    <abstract>

--*/

#include "toolbar.h"
#include "globals.h"

// define the toolbar button properties for each toolbar button
// these will be added to the toolbar structure as determined by the bitmap

TBBUTTON SysmonToolbarButtons[] = {
    // include this separator on ALL toolbars
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbNew,              IDM_TB_NEW,        TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbClear,            IDM_TB_CLEAR,      TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbCurrentActivity,  IDM_TB_REALTIME,   TBSTATE_ENABLED, TBSTYLE_CHECK,      0, 0},
    {(int)sysmonTbLogData,          IDM_TB_LOGFILE,    TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbChartDisplay,     IDM_TB_CHART,      TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0},
    {(int)sysmonTbHistogramDisplay, IDM_TB_HISTOGRAM,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0},
    {(int)sysmonTbReportDisplay,    IDM_TB_REPORT,     TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbAdd,              IDM_TB_ADD,        TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbDelete,           IDM_TB_DELETE,     TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbHighlight,        IDM_TB_HIGHLIGHT,  TBSTATE_ENABLED, TBSTYLE_CHECK,      0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbCopy,             IDM_TB_COPY,       TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbPaste,            IDM_TB_PASTE,      TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbProperties,       IDM_TB_PROPERTIES, TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbFreeze,           IDM_TB_FREEZE,     TBSTATE_ENABLED, TBSTYLE_CHECK,      0, 0},
    {(int)sysmonTbUpdate,           IDM_TB_UPDATE,     0,               TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbHelp,             IDM_TB_HELP,       TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0}
};

#define TB_BUTTON_COUNT (DWORD)((DWORD)sysmonTbLastButton + 1)
#define TB_ENTRIES      (sizeof(SysmonToolbarButtons) / sizeof (SysmonToolbarButtons[0]))

CSysmonToolbar::CSysmonToolbar (void)
{
    m_hToolbarWnd       = NULL;
    memset(&m_rectToolbar, 0, sizeof(m_rectToolbar));
    m_pCtrl             = NULL;
    m_dwToolbarFlags    = TBF_DefaultButtons;
    m_bVisible          = TRUE;
}

CSysmonToolbar::~CSysmonToolbar (void)
{
    if (m_hToolbarWnd != NULL) {
        DestroyWindow (m_hToolbarWnd);
        m_hToolbarWnd = NULL;
    }
}

LONG CSysmonToolbar::GetToolbarCmdId (UINT nBtnId)
{
    LONG    lBtnIndex;

    for (lBtnIndex = 0; lBtnIndex <TB_ENTRIES; lBtnIndex++) {
        if (SysmonToolbarButtons[lBtnIndex].iBitmap == (int)nBtnId) break;
    }

    if (SysmonToolbarButtons[lBtnIndex].iBitmap == (int)nBtnId) {
        return SysmonToolbarButtons[lBtnIndex].idCommand ;
    } else {
        return (LONG)-1;
    }
}

BOOL CSysmonToolbar::Init (CSysmonControl *pCtrl, HWND hWnd)
{
    BOOL    bReturn = TRUE;
    UINT    nIndex;
    DWORD   dwBitMask;

    if (m_hToolbarWnd == NULL) {

        if ( NULL != pCtrl && NULL != hWnd ) {

            // save pointer to owner control
            m_pCtrl = pCtrl;

            // create toolbar window
            m_hToolbarWnd = CreateToolbarEx (
                hWnd,
                WS_CHILD | WS_BORDER | WS_VISIBLE | TBSTYLE_TOOLTIPS |
                        TBSTYLE_TRANSPARENT | TBSTYLE_WRAPABLE | TBSTYLE_CUSTOMERASE,
                IDM_TOOLBAR,
                TB_BUTTON_COUNT,
                g_hInstance,
                IDB_TOOLBAR,
                SysmonToolbarButtons,
                TB_ENTRIES,
                SMTB_BM_X,
                SMTB_BM_Y,
                SMTB_BM_X,
                SMTB_BM_Y,
                sizeof (TBBUTTON));

            if (m_hToolbarWnd != NULL) {
                // set/enable the buttons as desired
                dwBitMask = 0;
                for (nIndex = 0; nIndex < TB_BUTTON_COUNT; nIndex++) {
                    dwBitMask = 1 << nIndex;
                    if ((m_dwToolbarFlags & dwBitMask) == 0) {
                        RemoveButton(nIndex);
                    }
                }

                // hide/show toolbar as desired
                ShowToolbar (m_bVisible);

            } else {
                bReturn = FALSE;
            }
        } else {
            bReturn = FALSE;
        }
    }
    return bReturn;
}

BOOL CSysmonToolbar::GetRect  (LPRECT pRect)
{
    BOOL    bReturn;
    if (m_hToolbarWnd) {
        if (m_bVisible) {
            bReturn = GetWindowRect (m_hToolbarWnd, pRect);
        } else {
            memset (pRect, 0, sizeof (RECT));
            bReturn = TRUE;
        }
    } else {
        bReturn = FALSE;
    }

    return bReturn;
}

LONG CSysmonToolbar::Height()
{
    RECT    tbRect;
    LONG    lHeight;

    memset (&tbRect, 0, sizeof(RECT));
    GetRect (&tbRect);
    lHeight = (LONG)(tbRect.bottom - tbRect.top);
    return lHeight;
}

BOOL CSysmonToolbar::RemoveButton (UINT  nBtnId)
{
    int     nBtnIndex;
    BOOL    bReturn = TRUE;

    if (m_hToolbarWnd != NULL) {
        // find matching toolbar in array
        nBtnIndex = (int)GetToolbarCmdId (nBtnId);
        if (nBtnIndex >= 0) {
            bReturn = (BOOL)SendMessage (m_hToolbarWnd, TB_DELETEBUTTON, nBtnIndex, 0L);
        } else {
            //not found
            bReturn = FALSE;
        }
    } else {
        // no toolbar window
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL CSysmonToolbar::SizeComponents (LPRECT pRect)
{
    //stretch toolbar to fit
    RECT    rNewToolbar;
    int     cX, cY;

    rNewToolbar = *pRect;

    cX = rNewToolbar.right - rNewToolbar.left;
    cY = Height();

    if ((cX > 0) &&  (m_bVisible)) {
        SetWindowPos(m_hToolbarWnd, NULL, 0, 0, cX, cY, SWP_NOMOVE);
    } // else do nothing

    return TRUE;
}

BOOL CSysmonToolbar::EnableButton (UINT   nBtnId, BOOL bState)
{
    int     nBtnIndex;
    BOOL    bReturn = TRUE;

    if (m_hToolbarWnd != NULL) {
        // find matching toolbar in array
        nBtnIndex = (int)GetToolbarCmdId (nBtnId);
        if (nBtnIndex >= 0) {
            bReturn = (BOOL)SendMessage (m_hToolbarWnd, TB_ENABLEBUTTON, nBtnIndex, (LONG)bState);
        } else {
            //not found
            bReturn = FALSE;
        }
    } else {
        // no toolbar window
        bReturn = FALSE;
    }

    return bReturn;
}

void 
CSysmonToolbar::PostEnableButton (UINT nBtnId, BOOL bState)
{
    int     nBtnIndex;

    if (m_hToolbarWnd != NULL) {
        // find matching toolbar in array
        nBtnIndex = (int)GetToolbarCmdId (nBtnId);
        if (nBtnIndex >= 0) {
            PostMessage (
                m_hToolbarWnd, 
                TB_ENABLEBUTTON, 
                nBtnIndex, 
                (LPARAM)MAKELONG(bState, 0));
        } 
    }

    return;
}

BOOL CSysmonToolbar::SyncToolbar ()
{
    LONG    lPushBtnId = -1;
    LONG    lUnPushBtnId = -1;
    LONG    lUnPush2BtnId;
    LONG    wpBtnIndex;
    BOOL    bClearBtnState;
    BOOL    bBtnState;
    DWORD   dwNumCounters;
    BOOL    bCanModify;
    INT     iDisplayType;
    BOOL    bContinue = TRUE;

    if ( NULL != m_pCtrl ) {
        if ( NULL == m_pCtrl->m_pObj ) {
            bContinue = FALSE;
        }
    } else {
        bContinue = FALSE;
    }

    if ( bContinue ) {
        // get the count of counters in the control to use later
        dwNumCounters = m_pCtrl->m_pObj->m_Graph.CounterTree.NumCounters();

        // Get the Modify state to use later;
        // Buttons disabled for ReadOnly:
        //      New counter set
        //      Current data vs. log file data source
        //      Add counter
        //      Delete counter
        //      Paste
        //      Properties
        //
    
        bCanModify = !m_pCtrl->IsReadOnly();

        // sync data source
        if ( bCanModify ) {        

            wpBtnIndex = GetToolbarCmdId (sysmonTbCurrentActivity);
            if (wpBtnIndex >= 0) {
                PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(!m_pCtrl->IsLogSource(), 0));           
            }
        }

        // sync display type
        iDisplayType = m_pCtrl->m_pObj->m_Graph.Options.iDisplayType;
        switch ( iDisplayType ) {
            case LINE_GRAPH:
                lPushBtnId = sysmonTbChartDisplay;
                lUnPushBtnId = sysmonTbHistogramDisplay;
                lUnPush2BtnId = sysmonTbReportDisplay;
                bClearBtnState = TRUE;
                break;

            case BAR_GRAPH:
                lUnPushBtnId = sysmonTbChartDisplay;
                lPushBtnId = sysmonTbHistogramDisplay;
                lUnPush2BtnId = sysmonTbReportDisplay;
                bClearBtnState = TRUE;
                break;

            case REPORT_GRAPH:
                lUnPushBtnId = sysmonTbChartDisplay;
                lUnPush2BtnId = sysmonTbHistogramDisplay;
                lPushBtnId = sysmonTbReportDisplay;
                bClearBtnState = FALSE;
                break;

            default:
                lUnPush2BtnId = 0;
                bClearBtnState = TRUE;
                assert (FALSE);
                break;
        }

        wpBtnIndex = GetToolbarCmdId (lUnPushBtnId);
        if (wpBtnIndex >= 0) {
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(FALSE, 0));
        }

        wpBtnIndex = GetToolbarCmdId (lUnPush2BtnId);
        if (wpBtnIndex >= 0) {
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(FALSE, 0));
        }

        wpBtnIndex = GetToolbarCmdId (lPushBtnId);
        if (wpBtnIndex >= 0) {
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(TRUE, 0));
        }

        // sync update status
        wpBtnIndex = GetToolbarCmdId (sysmonTbFreeze);
        if (wpBtnIndex >= 0) {
            // set push state
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,
                (LPARAM)MAKELONG(m_pCtrl->m_pObj->m_Graph.Options.bManualUpdate, 0));
            // set enable state
            bBtnState =  (dwNumCounters > 0);
            PostMessage (m_hToolbarWnd, TB_ENABLEBUTTON, wpBtnIndex,
                (LPARAM)MAKELONG(bBtnState, 0));
        }

        // Manual update button not enabled in design mode.
        bBtnState = m_pCtrl->m_pObj->m_Graph.Options.bManualUpdate 
                        && (dwNumCounters > 0)
                        && m_pCtrl->IsUserMode();
        PostEnableButton ( sysmonTbUpdate, bBtnState );

        // clear display button
        bBtnState = bClearBtnState && (dwNumCounters > 0) && (!m_pCtrl->IsLogSource());
        PostEnableButton ( sysmonTbClear, bBtnState );

        // Help is always enabled
        PostEnableButton ( sysmonTbHelp, TRUE );

        // Add, paste and properties are affected by the ReadOnly state.
        PostEnableButton ( sysmonTbAdd, bCanModify );
        PostEnableButton ( sysmonTbPaste, bCanModify );
        PostEnableButton ( sysmonTbProperties, bCanModify );

        // Data source buttons are affectedby bCanModify;
        PostEnableButton ( sysmonTbLogData, bCanModify );
        PostEnableButton ( sysmonTbCurrentActivity, bCanModify );

        // set the other buttons that are contingent on the presence of counters
        bBtnState = (dwNumCounters > 0);

        // the highlight button is only enabled in line_graph and histogram views

        PostEnableButton ( 
            sysmonTbHighlight, 
            ( bBtnState && ( REPORT_GRAPH != iDisplayType ) ) );
        wpBtnIndex = GetToolbarCmdId (sysmonTbHighlight);
        PostMessage (
            m_hToolbarWnd, 
            TB_CHECKBUTTON, 
            wpBtnIndex,
            (LPARAM)MAKELONG(m_pCtrl->m_pObj->m_Graph.Options.bHighlight, 0));

        // the copy button
        PostEnableButton ( sysmonTbCopy, bBtnState );

        // New/reset and delete are affected by ReadOnly state.

        bBtnState = (dwNumCounters > 0) && bCanModify;
    
        // the new/reset button
        PostEnableButton ( sysmonTbNew, bBtnState );

        // the delete button
        PostEnableButton ( sysmonTbDelete, bBtnState );

        bContinue = TRUE;
    }
    return bContinue;
}

BOOL CSysmonToolbar::ShowToolbar (BOOL   bVisible)
{
    BOOL    bReturn = m_bVisible;

    if ((m_hToolbarWnd != NULL) && (m_bVisible != bVisible)) {
        // only do this is the window is there and the new stat is different
        // from the old state
        ShowWindow (m_hToolbarWnd, (bVisible ? SW_SHOW : SW_HIDE));

        // update local flag
        m_bVisible = bVisible;

        //sync buttons with the control if it's visible
        if (m_pCtrl && m_bVisible) {
            SyncToolbar ();
        }
    } else {
        if (m_hToolbarWnd != NULL) {
            bReturn = FALSE;
        } else {
            // the state is already as requested so that's ok
            bReturn = TRUE;
        }
    }

    return bReturn;
}

BOOL CSysmonToolbar::SetBackgroundColor (COLORREF ocBackClr)
{

    COLORSCHEME csToolbar;
    LRESULT     lResult;
    BOOL        bReturn = TRUE;

    memset (&csToolbar, 0, sizeof(csToolbar));
    csToolbar.dwSize = sizeof(csToolbar);

    // get current scheme
    lResult = SendMessage (m_hToolbarWnd, TB_GETCOLORSCHEME,
        0, (LPARAM)&csToolbar);
    if (lResult) {
        // set color
        csToolbar.clrBtnHighlight = (COLORREF)ocBackClr;
        // leave shadow color alone
        lResult = SendMessage (m_hToolbarWnd, TB_SETCOLORSCHEME,
            0, (LPARAM)&csToolbar);
        if (!lResult) bReturn = FALSE;
    } else {
        bReturn = FALSE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\toolbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    toolbar.h

Abstract:

    <abstract>

--*/

#include <windows.h>
#ifdef _WIN32_IE
#if      _WIN32_IE < 0x0400
#undef     _WIN32_IE
#define    _WIN32_IE 0x0400 // for color scheme info
#endif // < 0x0400
#endif // defined

#include <commctrl.h>
#include <assert.h>
#include "polyline.h"
#include "smonctrl.h"

#ifndef _TOOLBAR_H_
#define _TOOLBAR_H_

#include "resource.h"


// button ID's
// these must correspond to the individual button 
// locations in the toolbar bitmap
enum sysmonTb {
    sysmonTbBlank = -1,
    sysmonTbNew = 0,
    sysmonTbClear,
    sysmonTbCurrentActivity,
    sysmonTbLogData,
    sysmonTbChartDisplay,
    sysmonTbHistogramDisplay,
    sysmonTbReportDisplay,
    sysmonTbAdd,
    sysmonTbDelete,
    sysmonTbHighlight,
    sysmonTbCopy,
    sysmonTbPaste,
    sysmonTbProperties,
    sysmonTbFreeze,
    sysmonTbUpdate,
    sysmonTbHelp, 
    sysmonTbLastButton = sysmonTbHelp
};

// define Toolbar bitmap fields
#define TBF_sysmonTbNew             (DWORD)(0x00000001 << (DWORD)sysmonTbNew)
#define TBF_sysmonTbCurrentActivity (DWORD)(0x00000001 << (DWORD)sysmonTbCurrentActivity)
#define TBF_sysmonTbLogData         (DWORD)(0x00000001 << (DWORD)sysmonTbLogData)
#define TBF_sysmonTbChartDisplay    (DWORD)(0x00000001 << (DWORD)sysmonTbChartDisplay)
#define TBF_sysmonTbHistogramDisplay (DWORD)(0x00000001 << (DWORD)sysmonTbHistogramDisplay)
#define TBF_sysmonTbReportDisplay   (DWORD)(0x00000001 << (DWORD)sysmonTbReportDisplay)
#define TBF_sysmonTbAdd             (DWORD)(0x00000001 << (DWORD)sysmonTbAdd)
#define TBF_sysmonTbDelete          (DWORD)(0x00000001 << (DWORD)sysmonTbDelete)
#define TBF_sysmonTbCopy            (DWORD)(0x00000001 << (DWORD)sysmonTbCopy)
#define TBF_sysmonTbPaste           (DWORD)(0x00000001 << (DWORD)sysmonTbPaste)
#define TBF_sysmonTbProperties      (DWORD)(0x00000001 << (DWORD)sysmonTbProperties)
#define TBF_sysmonTbFreeze          (DWORD)(0x00000001 << (DWORD)sysmonTbFreeze)
#define TBF_sysmonTbUpdate          (DWORD)(0x00000001 << (DWORD)sysmonTbUpdate)
#define TBF_sysmonTbHelp            (DWORD)(0x00000001 << (DWORD)sysmonTbHelp)

// define bitmap & button sizes
#define SMTB_BM_X   16
#define SMTB_BM_Y   15
//#define SMTB_BT_X   20
//#define SMTB_BT_Y   20

// this constant defines the buttons that are defined by default
// it can be edited as desired to alter the default appearance 
// of the bitmap.
#define TBF_DefaultButtons  (DWORD)(\
    TBF_sysmonTbNew             | \
    TBF_sysmonTbCurrentActivity | \
    TBF_sysmonTbLogData         | \
    TBF_sysmonTbChartDisplay    | \
    TBF_sysmonTbHistogramDisplay | \
    TBF_sysmonTbReportDisplay   | \
    TBF_sysmonTbAdd             | \
    TBF_sysmonTbDelete          | \
    TBF_sysmonTbCopy            | \
    TBF_sysmonTbPaste           | \
    TBF_sysmonTbProperties      | \
    TBF_sysmonTbUpdate          | \
    TBF_sysmonTbFreeze          | \
    TBF_sysmonTbHelp            )

class CSysmonControl;

class CSysmonToolbar {
    private:
        LONG    GetToolbarCmdId (UINT nBtnId);
        void    PostEnableButton ( UINT nBtnId, BOOL bState );
        
        HWND            m_hToolbarWnd;
        RECT            m_rectToolbar;
        CSysmonControl  *m_pCtrl;
        DWORD           m_dwToolbarFlags;
        TBBUTTON        *m_pTbArray;
        DWORD           m_dwBtnCnt;
        BOOL            m_bVisible;

    public:
        CSysmonToolbar (void);
        ~CSysmonToolbar (void);

        BOOL    Init            (CSysmonControl *pCtrl, HWND hWnd);
        BOOL    SizeComponents  (LPRECT pRect);
        BOOL    EnableButton    (UINT   nBtnId, BOOL bState);
        BOOL    RemoveButton    (UINT   nBtnId);
        BOOL    ShowToolbar     (BOOL   bVisible);
        BOOL    SyncToolbar     (void);
        BOOL    SetBackgroundColor  (COLORREF   ocBackClr);

        LONG    Height          (void);
        BOOL    GetRect         (LPRECT pRect);     
        
        LRESULT DoCmd           (WPARAM wParam, LPARAM lParam);

};

typedef CSysmonToolbar *PSYSMONTOOLBAR;

#endif //_TOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\strtable.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strtable.h

Abstract:

    <abstract>

--*/

class CStringTable
    {
    protected:
        UINT            m_idsMin;
        UINT            m_idsMax;
        USHORT          m_cStrings;
        LPTSTR         *m_ppszTable;

    public:
        CStringTable(void);
        ~CStringTable(void);

        BOOL Init( UINT idsMin, UINT idsMax );

        //Function to resolve an ID into a string pointer.
        LPTSTR operator []( const UINT );
    };


typedef CStringTable *PCStringTable;

#ifdef  CCHSTRINGMAX
#undef  CCHSTRINGMAX
#endif
#define CCHSTRINGMAX	256		


// Global instance of string table
extern CStringTable StringTable;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\timerng.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    timerng.h

Abstract:

    <abstract>

--*/

#ifndef _TIMERNG_H_
#define _TIMERNG_H_


#include "intrvbar.h"

class CTimeRange
{
    friend LRESULT APIENTRY TimeRangeWndProc (
        HWND hWnd,
        UINT uiMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    private:
       HWND              m_hWnd;
       PCIntervalBar     m_pIntrvBar;
       HFONT             m_hFont ;

       LONGLONG          m_llBegin;     
       LONGLONG          m_llEnd;
       LONGLONG          m_llStart;
       LONGLONG          m_llStop;

       INT               m_yFontHeight ;
       INT               m_xMaxTimeWidth ;
       INT               m_xBegin ;
       INT               m_xEnd ;
   
       RECT              m_rectStartDate ;
       RECT              m_rectStartTime ;
       RECT              m_rectStopDate ;
       RECT              m_rectStopTime ;

       INT               m_iCurrentStartPos ;
       INT               m_iCurrentStopPos ;

       INT MaxTimeWidth ( HDC hDC );
       void DrawBeginEnd ( HDC hDC );
       void DrawStartStop ( HDC hDC );

       void OnSize ( INT xWidth, INT yHeight );

    public:
        CTimeRange ( HWND hWnd );
       ~CTimeRange ( void );
        BOOL Init  ( void );

        void SetBeginEnd (LONGLONG llBegin, LONGLONG llEnd);
        void SetStartStop ( LONGLONG llStart, LONGLONG llStop );
        LONGLONG GetStart ( void ) { return m_llStart; }
        LONGLONG GetStop ( void ) { return m_llStop; }
   };

typedef CTimeRange *PCTimeRange;


BOOL RegisterTimeRangeClass (void) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\unkhlpr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    unkhlpr.h

Abstract:

    <abstract>

--*/

#define IMPLEMENT_CONTAINED_QUERYINTERFACE(IClassName) \
	STDMETHODIMP IClassName::QueryInterface(REFIID riid, PPVOID ppv)	\
    	{	\
    	return m_pUnkOuter->QueryInterface(riid, ppv);	\
    	}

#define IMPLEMENT_CONTAINED_ADDREF(IClassName) \
		STDMETHODIMP_(ULONG) IClassName::AddRef(void) \
    	{	\
    	++m_cRef;	\
    	return m_pUnkOuter->AddRef();	\
    	}

#define IMPLEMENT_CONTAINED_RELEASE(IClassName) \
	STDMETHODIMP_(ULONG) IClassName::Release(void)	\
    	{	\
    	--m_cRef;	\
    	return m_pUnkOuter->Release();	\
    	}

#define IMPLEMENT_CONTAINED_IUNKNOWN(IClassName) \
	IMPLEMENT_CONTAINED_QUERYINTERFACE(IClassName)	\
	IMPLEMENT_CONTAINED_ADDREF(IClassName)	\
	IMPLEMENT_CONTAINED_RELEASE(IClassName)


#define IMPLEMENT_CONTAINED_CONSTRUCTOR(CClassName, IClassName) \
	IClassName::IClassName(CClassName *pObj, LPUNKNOWN pUnkOuter) \
    {	\
    m_cRef = 0;	\
    m_pObj = pObj;	\
    m_pUnkOuter = pUnkOuter;	\
    return;	\
    }

 #define IMPLEMENT_CONTAINED_DESTRUCTOR(IClassName) \
	IClassName::~IClassName( void ) \
	{	\
		return;	\
	}
	
#define IMPLEMENT_CONTAINED_INTERFACE(CClassName, IClassName) \
	IMPLEMENT_CONTAINED_CONSTRUCTOR(CClassName, IClassName) \
	IMPLEMENT_CONTAINED_DESTRUCTOR(IClassName) \
	IMPLEMENT_CONTAINED_IUNKNOWN(IClassName)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\unihelpr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    unihelpr.h

Abstract:

    <abstract>

--*/

#ifndef _UNIHELPR_H_
#define _UNIHELPR_H_

/*
    These macros are based on the MFC macros found in file afxconv.h. They have been modified
    slightly to delete references to the MFC helper functions AfxW2AHelper and AfxA2WHelper
    so that the MFC DLL is not required.
*/

#include <malloc.h>

#define _MbToWide(dst, src, cnt) \
	MultiByteToWideChar(CP_ACP, 0, src, (int)cnt, dst, (int)cnt)

#define _WideToMb(dst, src, cnt) \
	WideCharToMultiByte(CP_ACP, 0, src, (int)cnt, dst, (int)(2 * cnt), NULL, NULL)


#define A2CW(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : ( \
		_convert = (lstrlenA(lpa)+1), \
		_convPtr = alloca(_convert*2), \
		_MbToWide((LPWSTR)_convPtr, lpa, _convert), \
		(LPCWSTR)_convPtr \
	) \
)

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : ( \
		_convert = (lstrlenA(lpa)+1), \
		_convPtr = alloca(_convert*2), \
		_MbToWide((LPWSTR)_convPtr, lpa, _convert),\
		(LPWSTR)_convPtr \
	) \
)

#define W2CA(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : ( \
		_convert = (wcslen(lpw)+1), \
		_convPtr = alloca(_convert*2),  \
		_WideToMb((LPSTR)_convPtr, lpw, _convert), \
		(LPCSTR)_convPtr \
	)\
)

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (wcslen(lpw)+1),\
		_convPtr = alloca(_convert*2), \
		_WideToMb((LPSTR)_convPtr, lpw, _convert), \
		(LPSTR)_convPtr \
	)\
)

#ifndef _DEBUG
#define USES_CONVERSION size_t _convert; void *_convPtr; _convPtr, _convert;
#else
#define USES_CONVERSION int _convert = 0; void *_convPtr = NULL; assert( 0 == _convert ); assert( NULL ==_convPtr );
#endif


#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	#define T2W(x)  (x)
	#define W2T(x)  (x)
#else
	#define T2W A2W
	#define W2T W2A
	#define T2A(x)  (x)
	#define A2T(x)  (x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\visuals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    visuals.h

Abstract:

    <abstract>

--*/

#ifndef _VISUALS_H_
#define _VISUALS_H_

#define NumStandardColorIndices() (16)
#define NumColorIndices() (NumStandardColorIndices()+1)                         
#define NumStyleIndices() (5)
#define NumWidthIndices() (9)                

#define IndexToStandardColor(i) (argbStandardColors[i])
#define IndexToStyle(i) (i)
#define IndexToWidth(i) (i+1)                  

#define WidthToIndex(i) (i-1)
#define StyleToIndex(i) (i)
    
extern COLORREF argbStandardColors[16];

//===========================================================================
// Exported Functions
//===========================================================================

INT ColorToIndex( COLORREF );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\winhelpr.h ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    winhelpr.h

Abstract:

    This file contains macros for more easily dealing with windows
    messages and objects. Think of it as an extension to windows.h.
--*/

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define SetFont(hWnd, hFont)                          \
   (SendMessage ((hWnd), WM_SETFONT, (WPARAM)hFont, (LPARAM)0))

#define GetFont(hWnd) \
    (HFONT)(SendMessage((hWnd), WM_GETFONT, (WPARAM)0, (LPARAM)0))

#define PrintClient(hWnd, hDC, uFlags) \
    (SendMessage((hWnd), WM_PRINTCLIENT, (WPARAM)hDC, (LPARAM)(uFlags)) )

//======================================//
// Object-differentiation routines      //
//======================================//


// Windows APIs deal with all GDI objects the same. There's a SelectObject,
// no SelectBitmap, SelectFont, etc. We use these instead to make the code
// easier to read. Also, you can redefine one of these to check the 
// validity of a particular GDI object type.


#define SelectBitmap(hDC, hBitmap)                    \
   ((HBITMAP)SelectObject (hDC, hBitmap))

#define SelectFont(hDC, hFont)                        \
   ((HFONT)SelectObject (hDC, hFont))

#define SelectBrush(hDC, hBrush)                      \
   ((HBRUSH)SelectObject (hDC, hBrush))

#define DeleteBrush(hBrush)                           \
   (DeleteObject (hBrush))

#define SelectPen(hDC, hPen)                          \
   ((HPEN)SelectObject (hDC, hPen))

#define DeletePen(hPen)                               \
   (DeleteObject (hPen))


//======================================//
//                                      //
//======================================//


#define CBData(hWndCB, iIndex)                        \
   (SendMessage (hWndCB, CB_GETITEMDATA, (WPARAM)iIndex, (LPARAM)0))


#define CBSetData(hWndCB, iIndex, lData)              \
   (SendMessage (hWndCB, CB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)lData))


#define CBAdd(hWndCB, lpszText)                       \
   ((INT)(DWORD)SendMessage((hWndCB), CB_ADDSTRING,   \
    (WPARAM)0, (LPARAM)(LPCTSTR)(lpszText)))

#define CBDelete(hWndCB, iIndex)                        \
   ((INT)(DWORD)SendMessage((hWndCB), CB_DELETESTRING,  \
    (WPARAM)iIndex, (LPARAM)0))

#define CBFind(hWndCB, lpszText)                      \
   (SendMessage (hWndCB, CB_FINDSTRING, (WPARAM)(-1), (LPARAM) lpszText))


#define CBInsert(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_INSERTSTRING, (WPARAM)iIndex, (LPARAM) lpszText))


#define CBNumItems(hWndCB)                            \
   ((INT) SendMessage (hWndCB, CB_GETCOUNT, (WPARAM)0, (LPARAM)0))


#define CBReset(hWndCB)                               \
   ((INT)(DWORD)SendMessage((hWndCB), CB_RESETCONTENT,\
    (WPARAM)0, (LPARAM)0))


#define CBSelection(hWndCB)                           \
   (SendMessage (hWndCB, CB_GETCURSEL, (WPARAM)0, (LPARAM)0))


#define CBSetSelection(hWndCB, iIndex)                \
   (SendMessage (hWndCB, CB_SETCURSEL, (WPARAM)iIndex, (LPARAM)0))


#define CBString(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)lpszText))


#define CBStringLen(hWndCB, iIndex)                   \
   (SendMessage (hWndCB, CB_GETLBTEXTLEN, (WPARAM)iIndex, (LPARAM)0))



//======================================//
// Listbox helpers                      //
//======================================//


#define LBAdd(hWndLB, lpszText)                       \
   (SendMessage (hWndLB, LB_ADDSTRING, (WPARAM)0, (LPARAM)lpszText))


#define LBData(hWndLB, iIndex)                        \
(SendMessage (hWndLB, LB_GETITEMDATA, (WPARAM)iIndex, (LPARAM)0))


#define LBDelete(hWndLB, iIndex)                      \
   (SendMessage (hWndLB, LB_DELETESTRING, (WPARAM)iIndex, (LPARAM)0))


#define LBFind(hWndLB, lpszText)                      \
   (SendMessage (hWndLB, LB_FINDSTRING, (WPARAM)-1, (LPARAM)lpszText))


#define LBFocus(hWndLB)                               \
   (SendMessage (hWndLB, LB_GETCARETINDEX, (WPARAM)0, (LPARAM)0))


#define LBInsert(hWndLB, iIndex, lpszText)            \
   (SendMessage (hWndLB, LB_INSERTSTRING, (WPARAM)iIndex, (LPARAM)lpszText))


#define LBNumItems(hWndLB)                            \
   ((INT) SendMessage (hWndLB, LB_GETCOUNT, (WPARAM)0, (LPARAM)0))


#define LBReset(hWndLB)                               \
   ((INT)(DWORD)SendMessage((hWndLB), LB_RESETCONTENT,\
    (WPARAM)0, (LPARAM)0))


#define LBSelected(hwndLB, index)                     \
   ((INT)(DWORD)SendMessage((hwndLB), LB_GETSEL,      \
    (WPARAM)(INT)(index), (LPARAM)0))


#define LBSelection(hWndLB)                           \
   ((INT)(DWORD)SendMessage (hWndLB, LB_GETCURSEL, (WPARAM)0, (LPARAM)0))


#define LBSetData(hWndLB, iIndex, lData)              \
   (SendMessage (hWndLB, LB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)lData))


#define LBSetSelection(hWndLB, iIndex)                \
   (SendMessage (hWndLB, LB_SETCURSEL, (WPARAM)iIndex, (LPARAM)0))

#define MLBSetSelection(hWndMLB, iIndex, bSet)        \
   (SendMessage (hWndMLB, LB_SETSEL, (WPARAM)bSet, (LPARAM)iIndex))

#define LBSetVisible(hWndLB, iIndex)                  \
   (SendMessage (hWndLB, LB_SETCARETINDEX, (WPARAM)iIndex, (LPARAM)0))

 
#define LBSetRedraw(hWndLB, bDrawOnOff)               \
   (SendMessage (hWndLB, WM_SETREDRAW, (WPARAM)bDrawOnOff, (LPARAM)0))


#define LBSetHorzExtent(hWndLB, wExtent)              \
   (SendMessage (hWndLB, LB_SETHORIZONTALEXTENT, (WPARAM)wExtent, (LPARAM)0))


#define LBSetItemHeight(hWndLB, iHeight)              \
    (SendMessage (hWndLB, LB_SETITEMHEIGHT, (WPARAM)0, (LPARAM)iHeight)) 


#define LBGetTextLen(hWndLB, iIndex)                  \
    (SendMessage (hWndLB, LB_GETTEXTLEN, (WPARAM)iIndex, (LPARAM)0))


#define LBGetText(hWndLB, iIndex, szPath)             \
    (SendMessage (hWndLB, LB_GETTEXT, (WPARAM)iIndex, (LPARAM)szPath))


//======================================//
// Edit helpers                         //
//======================================//


#define EditModified(hWndEdit)                        \
   (SendMessage ((hWndEdit), EM_GETMODIFY, (WPARAM)0, (LPARAM)0))


#define EditSetModified(hWndEdit, bModified)                     \
   (SendMessage ((hWndEdit), EM_SETMODIFY, (WPARAM)bModified, (LPARAM)0))


#define EditSetLimit(hWndEdit, iLimit)                \
   (SendMessage ((hWndEdit), EM_LIMITTEXT, (WPARAM)iLimit, (LPARAM)0))
#define EditSetTextPos(hWnd, idControl, iStartPos, iEndPos)    \
   (SendMessage (GetDlgItem(hWnd, idControl), EM_SETSEL, (WPARAM)iStartPos, (LPARAM)iEndPos))

#define EditSetTextEndPos(hWnd, idControl)    \
   EditSetTextPos(hWnd, idControl, (WPARAM)0, (LPARAM)32767)

//======================================//
// Cursor helpers                       //
//======================================//

#define SetHourglassCursor() \
    (SetCursor(LoadCursor(NULL, IDC_WAIT)))

#define SetArrowCursor() \
    (SetCursor(LoadCursor(NULL, IDC_ARROW)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\configureyourserver.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of IConfigureYourServer
//
// 28 Mar 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "ConfigureYourServer.hpp"
#include "util.hpp"



const size_t NUMBER_OF_AUTOMATION_INTERFACES = 1;


// the max lengths, in bytes, of strings when represented in the UTF-8
// character set.  These are the limits we expose to the user

#define MAX_NAME_LENGTH         64  // see admin\dcpromo\exe\headers.hxx
#define MAX_LABEL_LENGTH        DNS_MAX_LABEL_LENGTH


// // #define REGKEY_NTCV     L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"                            
// // #define REGKEY_SRVWIZ   L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SrvWiz"                    
// // #define REGKEY_TODOLIST L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList"
// // #define REGKEY_WELCOME  L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips"



ConfigureYourServer::ConfigureYourServer()
   :
   refcount(1) // implicit AddRef
{
   LOG_CTOR(ConfigureYourServer);

   m_ppTypeInfo = new ITypeInfo*[NUMBER_OF_AUTOMATION_INTERFACES];

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i] = NULL;
   }

   ITypeLib *ptl = 0;
   HRESULT hr = LoadRegTypeLib(LIBID_ConfigureYourServerLib, 1, 0, 0, &ptl);
   if (SUCCEEDED(hr))
   {
      ptl->GetTypeInfoOfGuid(IID_IConfigureYourServer, &(m_ppTypeInfo[0]));
      ptl->Release();
   }
}



ConfigureYourServer::~ConfigureYourServer()
{
   LOG_DTOR(ConfigureYourServer);
   ASSERT(refcount == 0);

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i]->Release();
   }

   delete[] m_ppTypeInfo;
}



HRESULT __stdcall
ConfigureYourServer::QueryInterface(REFIID riid, void **ppv)
{
   LOG_FUNCTION(ConfigureYourServer::QueryInterface);

   if (riid == IID_IUnknown)
   {
      LOG(L"IUnknown");

      *ppv =
         static_cast<IUnknown*>(static_cast<IConfigureYourServer*>(this));
   }
   else if (riid == IID_IConfigureYourServer)
   {
      LOG(L"IConfigureYourServer");

      *ppv = static_cast<IConfigureYourServer*>(this);
   }
   else if (riid == IID_IDispatch && m_ppTypeInfo[0])
   {
      LOG(L"IDispatch");

      *ppv = static_cast<IDispatch*>(this);
   }
// CODEWORK
//    else if (riid == IID_ISupportErrorInfo)
//    {
//       LOG(L"ISupportErrorInfo");
// 
//       *ppv = static_cast<ISupportErrorInfo*>(this);
//    }
   else
   {
      LOG(L"unknown interface queried");

      return (*ppv = 0), E_NOINTERFACE;
   }

   reinterpret_cast<IUnknown*>(*ppv)->AddRef();
   return S_OK;
}



ULONG __stdcall
ConfigureYourServer::AddRef(void)
{
   LOG_ADDREF(ConfigureYourServer);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
ConfigureYourServer::Release(void)
{
   LOG_RELEASE(ConfigureYourServer);

   if (Win::InterlockedDecrement(refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
ConfigureYourServer::GetTypeInfoCount(UINT *pcti)
{
   LOG_FUNCTION(ConfigureYourServer::GetTypeInfoCount);

    if (pcti == 0)
    {
      return E_POINTER;
    }

    *pcti = 1;
    return S_OK;
}



HRESULT __stdcall
ConfigureYourServer::GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti)
{
   LOG_FUNCTION(ConfigureYourServer::GetTypeInfo);

   if (ppti == 0)
   {
      return E_POINTER;
   }
   if (cti != 0)
   {
      *ppti = 0;
      return DISP_E_BADINDEX;
   }

   (*ppti = m_ppTypeInfo[0])->AddRef();
   return S_OK;
}



HRESULT __stdcall
ConfigureYourServer::GetIDsOfNames(
   REFIID  riid,    
   OLECHAR **prgpsz,
   UINT    cNames,  
   LCID    lcid,    
   DISPID  *prgids) 
{
   LOG_FUNCTION(ConfigureYourServer::GetIDsOfNames);

   HRESULT hr = S_OK;
   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
     hr = (m_ppTypeInfo[i])->GetIDsOfNames(prgpsz, cNames, prgids);
     if (SUCCEEDED(hr) || DISP_E_UNKNOWNNAME != hr)
       break;
   }

   return hr;
}



HRESULT __stdcall
ConfigureYourServer::Invoke(
   DISPID     id,         
   REFIID     riid,       
   LCID       lcid,       
   WORD       wFlags,     
   DISPPARAMS *params,    
   VARIANT    *pVarResult,
   EXCEPINFO  *pei,       
   UINT       *puArgErr) 
{
   LOG_FUNCTION(ConfigureYourServer::Invoke);

   HRESULT    hr = S_OK;
   IDispatch *pDispatch[NUMBER_OF_AUTOMATION_INTERFACES] =
   {
      (IDispatch*)(IConfigureYourServer *)(this),
   };

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      hr =
         (m_ppTypeInfo[i])->Invoke(
            pDispatch[i],
            id,
            wFlags,
            params,
            pVarResult,
            pei,
            puArgErr);

      if (DISP_E_MEMBERNOTFOUND != hr)
        break;
   }

   return hr;
}



// HRESULT __stdcall
// ConfigureYourServer::InterfaceSupportsErrorInfo(const IID& iid)
// {
//    LOG_FUNCTION(ConfigureYourServer::InterfaceSupportsErrorInfo);
// 
//    if (iid == IID_IConfigureYourServer) 
//    {
//       return S_OK;
//    }
// 
//    return S_FALSE;
// }



// if infoLevel = 0, then returns 1 if the machine is a DC, 0 if not.
// if infoLevel = 1, then returns 1 if the machine is in upgrade state, 0 if not.
// if infolevel = 2,
// 
//       then returns 1 if no role change operation is taking place or pending
//       reboot,
//       
//       returns 2 if a role changes is currently taking place (or dcpromo is
//       running)
// 
//       returns 3 if a role change is pending reboot.
// 
//       returns 0 otherwise.

HRESULT __stdcall
ConfigureYourServer::DsRole(int infoLevel, int* result)
{
   LOG_FUNCTION2(
      ConfigureYourServer::DsRole,
      String::format(L"%1!d!", infoLevel));
   ASSERT(infoLevel == 0 or infoLevel == 1 or infoLevel == 2);
   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      // by default, assume the machine is not a DC, and not in the middle
      // of upgrade

      *result = 0;

      switch (infoLevel)
      {
         case 0:
         {
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
            hr = MyDsRoleGetPrimaryDomainInformation(0, info);
            BREAK_ON_FAILED_HRESULT(hr);

            if (  info
               && (  info->MachineRole == DsRole_RolePrimaryDomainController
                  or info->MachineRole == DsRole_RoleBackupDomainController) )
            {
               *result = 1;
            }

            ::DsRoleFreeMemory(info);
            break;
         }
         case 1:
         {
            DSROLE_UPGRADE_STATUS_INFO* info = 0;
            hr = MyDsRoleGetPrimaryDomainInformation(0, info);
            BREAK_ON_FAILED_HRESULT(hr);

            if (info && info->OperationState == DSROLE_UPGRADE_IN_PROGRESS)
            {
               *result = 1;
            }

            ::DsRoleFreeMemory(info);
            break;
         }
         case 2:
         {
            // Check to see if the dcpromo wizard is running.

            if (IsDcpromoRunning())
            {
               *result = 2;
               break;
            }
            else
            {
               // this test is redundant if dcpromo is running, so only
               // perform it when dcpromo is not running.
      
               DSROLE_OPERATION_STATE_INFO* info = 0;
               hr = MyDsRoleGetPrimaryDomainInformation(0, info);
               if (SUCCEEDED(hr) && info)
               {
                  switch (info->OperationState)
                  {
                     case DsRoleOperationIdle:
                     {
                        *result = 1;
                        break;
                     }
                     case DsRoleOperationActive:
                     {
                        // a role change operation is underway

                        *result = 2;
                        break;
                     }
                     case DsRoleOperationNeedReboot:
                     {
                        // a role change has already taken place, need to
                        // reboot before attempting another.
                       
                        *result = 3;
                        break;
                     }
                     default:
                     {
                        ASSERT(false);
                        break;
                     }
                  }
      
                  ::DsRoleFreeMemory(info);
               }
            }
            
            break;
         }
         default:
         {
            ASSERT(false);
            hr = E_INVALIDARG;
            break;
         }
      }
   }
   while (0);

   LOG_HRESULT(hr);
   LOG(result ? String::format(L"result = %1!d!", *result) : L"");

   return hr;
}



extern "C"
{
   BOOL IsDhcpServerAround(VOID);
}



HRESULT __stdcall
ConfigureYourServer::CheckDhcpServer(BOOL *pbRet)
{
   LOG_FUNCTION(ConfigureYourServer::CheckDhcpServer);

   HRESULT hr = S_OK;

   do
   {
      if (!pbRet)
      {
         hr = E_INVALIDARG;
         break;
      }

      *pbRet = TRUE;

      WSADATA WsaData;
      DWORD Error = WSAStartup(MAKEWORD(2,0), &WsaData );
      if( NO_ERROR == Error )
      {
         if( !IsDhcpServerAround() )
         {
            *pbRet = FALSE;
         }

         WSACleanup();
      }
   }
   while (0);

   LOG(pbRet ? String::format(L"exit code = %1!x!", *pbRet) : L"");
   LOG_HRESULT(hr);
    
   return hr;
}



HRESULT __stdcall
ConfigureYourServer::CreateAndWaitForProcess( 
   /* [in] */           BSTR  commandLine,
   /* [out, retval] */  long* retval)
{
   LOG_FUNCTION2(ConfigureYourServer::CreateAndWaitForProcess, commandLine);
   ASSERT(commandLine);
   ASSERT(retval);

   HRESULT hr = S_OK;

   do
   {
      if (!retval || !commandLine)
      {
         hr = E_INVALIDARG;
         break;
      }

      if (!*commandLine)
      {
         // empty string is illegal

         hr = E_INVALIDARG;
         break;
      }

      *retval = 0;
      DWORD exitCode = 0;
      hr = ::CreateAndWaitForProcess(commandLine, exitCode);

      *retval = (long) exitCode;
   }
   while (0);

   LOG(String::format(L"exit code = %1!x!", retval));
   LOG_HRESULT(hr);

   return hr;
}



HRESULT __stdcall
ConfigureYourServer::IsCurrentUserAdministrator(
   /* [out, retval] */  BOOL* retval)
{
   LOG_FUNCTION(ConfigureYourServer::IsCurrentUserAdministrator);
   ASSERT(retval);

   HRESULT hr = S_OK;

   do
   {
      if (!retval)
      {
         hr = E_INVALIDARG;
         break;
      }

      *retval = ::IsCurrentUserAdministrator() ? TRUE : FALSE;
   }
   while (0);

   LOG(retval ? (*retval ? L"TRUE" : L"FALSE") : L"");
   LOG_HRESULT(hr);

   return hr;
}


      
HRESULT
BrowseForFolderHelper(
   HWND           parent,
   const String&  title,
   String&        result)
{
   LOG_FUNCTION(BrowseForFolderHelper);
   ASSERT(Win::IsWindow(parent));

   result.erase();

   HRESULT      hr      = S_OK;
   LPMALLOC     pmalloc = 0;   
   LPITEMIDLIST drives  = 0;   
   LPITEMIDLIST pidl    = 0;   

   do
   {
      // may need to init COM for this thread (prob. not, but better
      // safe than hosed.)

      hr = ::CoInitialize(0);
      if (FAILED(hr))
      {
         break;
      }
            
      hr = Win::SHGetMalloc(pmalloc);
      if (FAILED(hr) or !pmalloc)
      {
         break;
      }

      // get a pidl for the local drives (really My Computer)

      hr = Win::SHGetSpecialFolderLocation(parent, CSIDL_DRIVES, drives);
      BREAK_ON_FAILED_HRESULT(hr);

      BROWSEINFO info;
      ::ZeroMemory(&info, sizeof(info));

      wchar_t buf[MAX_PATH + 1];
      ::ZeroMemory(buf, sizeof(buf));

      info.hwndOwner      = parent;      
      info.pidlRoot       = drives;        
      info.pszDisplayName = buf;        
      info.lpszTitle      = title.c_str();              
      info.ulFlags        =
            BIF_RETURNONLYFSDIRS
         |  BIF_RETURNFSANCESTORS
         |  BIF_NEWDIALOGSTYLE;

      pidl = Win::SHBrowseForFolder(info);

      if (pidl)
      {
         result = Win::SHGetPathFromIDList(pidl);
      }
   }
   while (0);

   if (pmalloc)
   {
      pmalloc->Free(pidl);
      pmalloc->Free(drives);
      pmalloc->Release();
   }

   LOG(result);
   LOG_HRESULT(hr);
            
   return hr;
}



HRESULT __stdcall
ConfigureYourServer::BrowseForFolder(
   /* [in]          */  BSTR  windowTitle,
   /* [out, retval] */  BSTR* folderPath)
{
   LOG_FUNCTION2(
      ConfigureYourServer::BrowseForFolder,
      windowTitle ? windowTitle : L"(null)");
   ASSERT(windowTitle);
   ASSERT(folderPath);

   HRESULT hr = S_OK;

   do
   {
      if (!folderPath || !windowTitle)
      {
         hr = E_INVALIDARG;
         break;
      }

      String result;
      hr =
         BrowseForFolderHelper(
            Win::GetActiveWindow(),
            windowTitle,
            result);

      *folderPath = ::SysAllocString(result.c_str());
   }
   while (0);

   LOG(folderPath ? *folderPath : L"(null)");
   LOG_HRESULT(hr);

   return hr;
}
   

         
HRESULT __stdcall
ConfigureYourServer::GetProductSku(
      /* [out, retval] */  int* retval)
{
   LOG_FUNCTION(ConfigureYourServer::GetProductSku);
   ASSERT(retval);

   HRESULT hr = S_OK;

   do
   {
      if (!retval)
      {
         hr = E_INVALIDARG;
         break;
      }

      OSVERSIONINFOEX info;
      hr = Win::GetVersionEx(info);
      BREAK_ON_FAILED_HRESULT(hr);

      if (info.wSuiteMask & VER_SUITE_DATACENTER)
      {
         // datacenter
         
         *retval = 5;
         break;
      }
      if (info.wSuiteMask & VER_SUITE_ENTERPRISE)
      {
         // advanced server
         
         *retval = 4;
         break;
      }
      if (info.wSuiteMask & VER_SUITE_PERSONAL)
      {
         // personal
         
         *retval = 1;
         break;
      }
      if (info.wProductType == VER_NT_WORKSTATION)
      {
         // profesional
         
         *retval = 2;
      }
      else
      {
         // server
         
         *retval = 3;
      }
   }
   while (0);

   return hr;
}



HRESULT __stdcall
ConfigureYourServer::IsClusteringConfigured(
   /* [out, retval] */  BOOL* retval)
{
   LOG_FUNCTION(ConfigureYourServer::IsClusteringConfigured);
   ASSERT(retval);

   HRESULT hr = S_OK;

   do
   {
      if (!retval)
      {
         hr = E_INVALIDARG;
         break;
      }

      *retval = FALSE;

      DWORD clusterState = 0;
      DWORD err = ::GetNodeClusterState(0, &clusterState);

      if (
            err == ERROR_SUCCESS
         && clusterState != ClusterStateNotConfigured)
      {
         *retval = TRUE;
      }
      
   }
   while (0);

   LOG(retval ? (*retval ? L"TRUE" : L"FALSE") : L"");
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\visuals.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    visuals.cpp

Abstract:

    Miscellaneous visual utility routines.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <windows.h>
#include "visuals.h"

//==========================================================================//
//                                  Exported data structures                //
//==========================================================================//

COLORREF argbStandardColors[] = 
   {
   RGB (0xff, 0x00, 0x00), 
   RGB (0x00, 0x80, 0x00), 
   RGB (0x00, 0x00, 0xff), 
   RGB (0xff, 0xff, 0x00), 
   RGB (0xff, 0x00, 0xff), 
   RGB (0x00, 0xff, 0xff), 
   RGB (0x80, 0x00, 0x00), 
   RGB (0x40, 0x40, 0x40), 
   RGB (0x00, 0x00, 0x80), 
   RGB (0x80, 0x80, 0x00), 
   RGB (0x80, 0x00, 0x80), 
   RGB (0x00, 0x80, 0x80), 
   RGB (0x40, 0x00, 0x00), 
   RGB (0x00, 0x40, 0x00), 
   RGB (0x00, 0x00, 0x40), 
   RGB (0x00, 0x00, 0x00)
   } ;


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

INT ColorToIndex( 
        COLORREF rgbColor )
{
    // Returns NumColorStandardColorIndices() if not found. This index is
    // used to indicate custom color.
    bool bFound = false;
    INT iColorIndex;

    for ( iColorIndex = 0; 
            !bFound && (iColorIndex < NumStandardColorIndices()); 
            iColorIndex++) {
        bFound = ( argbStandardColors[iColorIndex] == rgbColor );
    }

    if ( bFound )
        iColorIndex -= 1;

    return iColorIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\utils.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    <abstract>

--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#include <pdh.h>
#include "wtypes.h"  // for DATE typedef

extern LPCWSTR cszSqlDataSourceFormat;

//===========================================================================
// Macro Definitions
//===========================================================================

//
// General purpose
//
#define PinInclusive(x, lo, hi) \
   max (lo, min (x, hi))

#define PinExclusive(x, lo, hi) \
   max ((lo) + 1, min (x, (hi) - 1))

//
// Text
//
#define ELLIPSES TEXT("...")
#define ELLIPSES_CNT 3

//
// Window
//
#define WindowInvalidate(hWnd) \
   InvalidateRect (hWnd, NULL, TRUE)

#define WindowShow(hWnd, bShow) \
   ShowWindow (hWnd, (bShow) ? SW_SHOW : SW_HIDE)

#define WindowID(hWnd) \
    GetWindowLongPtr(hWnd, GWLP_ID)

#define WindowStyle(hWnd) \
   GetWindowLong (hWnd, GWL_STYLE)

#define WindowSetStyle(hWnd, lStyle) \
   SetWindowLong (hWnd, GWL_STYLE, lStyle)

#define WindowParent(hWnd) \
   ((HWND) GetWindowLongPtr (hWnd, GWLP_HWNDPARENT))


//
// Dialog
//
#define DialogControl(hDlg, wControlID) \
   GetDlgItem (hDlg, wControlID)

#define DialogText(hDlg, wControlID, szText) \
   GetDlgItemText (hDlg, wControlID, szText, sizeof(szText) / sizeof(TCHAR))

#define DialogInt(hDlg, wControlID) \
   GetDlgItemInt (hDlg, wControlID, NULL, TRUE)

//
// GDI
//
#define ClearRect(hDC, lpRect) \
    ExtTextOut (hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL )

//===========================================================================
// Exported Functions
//===========================================================================

//
// Font/Text
//
INT TextWidth (
    HDC hDC, 
    LPCTSTR lpszText
) ;

INT FontHeight (
    HDC hDC, 
    BOOL bIncludeLeading
) ;

BOOL NeedEllipses (  
    IN  HDC hAttribDC,
    IN  LPCTSTR pszText,
    IN  INT nTextLen,
    IN  INT xMaxExtent,
    IN  INT xEllipses,
    OUT INT *pnChars
) ;


VOID FitTextOut (
    IN HDC hDC, 
    IN HDC hAttribDC,
    IN UINT fuOptions,
    IN CONST RECT *lprc,
    IN LPCTSTR lpString, 
    IN INT cbCount,
    IN INT iAlign,
    IN BOOL fVertical
) ;

//
// Dialog
//
void DialogEnable (HWND hDlg, WORD wID, BOOL bEnable) ;
void DialogShow (HWND hDlg, WORD wID, BOOL bShow) ;
FLOAT DialogFloat (HWND hDlg, WORD wControlID, BOOL *pbOK) ;

//
// Graphic
//
void Line (HDC hDC, HPEN hPen, INT x1, INT y1, INT x2, INT y2) ;
void Fill (HDC hDC, COLORREF rgbColor, LPRECT lpRect);
void ScreenRectToClient (HWND hWnd, LPRECT lpRect) ;
void ClientRectToScreen (HWND hWnd, LPRECT lpRect) ;

#ifdef __IEnumFORMATETC_INTERFACE_DEFINED__
HDC  CreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);
#endif

//
// Conversion
//
BOOL TruncateLLTime (LONGLONG llTime, LONGLONG* pllTime);
BOOL LLTimeToVariantDate (LONGLONG llTime, DATE *pDate);
BOOL VariantDateToLLTime (DATE Date, LONGLONG *pllTime);

//
// Stream I/O - only include if user knows about IStream
//
#ifdef __IStream_INTERFACE_DEFINED__
HRESULT StringFromStream (LPSTREAM pIStream, LPTSTR *ppsz, INT nLen);
HRESULT WideStringFromStream (LPSTREAM pIStream, LPTSTR *ppsz, INT nLen);
#endif

//
// Property bag I/O - only include if user knows about IStream
//
#ifdef __IPropertyBag_INTERFACE_DEFINED__
HRESULT 
IntegerToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCTSTR szPropName, 
    INT intData );

HRESULT
OleColorToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    OLE_COLOR& clrData );

HRESULT
ShortToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCTSTR szPropName, 
    SHORT iData );


HRESULT 
BOOLToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCTSTR szPropName, 
    BOOL bData );

HRESULT 
DoubleToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCTSTR szPropName, 
    DOUBLE dblData );

HRESULT
FloatToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    FLOAT fData );

HRESULT 
CyToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCTSTR szPropName, 
    CY& cyData );

HRESULT 
StringToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCTSTR szPropName, 
    LPCTSTR szData );

HRESULT
LLTimeToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    LONGLONG& rllData );

HRESULT 
IntegerFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    INT& rintData );

HRESULT
OleColorFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    OLE_COLOR& rintData );

HRESULT 
ShortFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    SHORT& riData );

HRESULT
BOOLFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    BOOL& rbData );

HRESULT 
DoubleFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    DOUBLE& rdblData );

HRESULT
FloatFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    FLOAT& rfData );

HRESULT
CyFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    CY& rcyData );

HRESULT 
StringFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    LPTSTR szData,
    INT& riBufSize );

HRESULT
LLTimeFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    LONGLONG& rllData );
#endif

//
// Resources
//
LPTSTR ResourceString(UINT uID);

//
// Message format
//

DWORD
FormatSystemMessage (
    DWORD   dwMessageId,
    LPTSTR  pszSystemMessage, 
    DWORD   dwBufSize );

//
// Locale and format
//

#define MAX_TIME_CHARS  20
#define MAX_DATE_CHARS  20

INT
FormatHex (
double  dValue,
LPTSTR  pNumFormatted,
BOOL    bLargeFormat
);

INT
FormatNumber (
double  dValue,
LPTSTR  pNumFormatted,
INT     ccharsFormatted,
UINT    uiMinimumWidth,
UINT    uiPrecision );

INT
FormatScientific (
double  dValue,
LPTSTR  pNumFormatted,
INT     ccharsFormatted,
UINT    uiMinimumWidth,
UINT    uiPrecision );

void 
FormatDateTime (
    LONGLONG    llTime,
    LPTSTR      pszDate,
    LPTSTR      pszTime );

LPTSTR 
GetTimeSeparator ( void );

BOOL    
DisplayThousandsSeparator ( void );

BOOL    
DisplaySingleLogSampleValue ( void );

//
// Hit testing
//

BOOL 
HitTestLine (
    POINT pt0, 
    POINT pt1, 
    POINTS ptMouse, 
    INT nWidth );

#define MPOINT2POINT(mpt, pt)   ((pt).x = (mpt).x, (pt).y = (mpt).y)
#define POINT2MPOINT(pt, mpt)   ((mpt).x = (SHORT)(pt).x, (mpt).y = (SHORT)(pt).y)
#define POINTS2VECTOR2D(pt0, pt1, vect) ((vect).x = (double)((pt1).x - (pt0).x), \
                                         (vect).y = (double)((pt1).y - (pt0).y))
typedef struct tagVECTOR2D  {
        double     x;
        double     y;
} VECTOR2D, *PVECTOR2D, FAR *LPVECTOR2D; 

typedef struct tagPROJECTION  {
        VECTOR2D   ttProjection;
        VECTOR2D   ttPerpProjection;
        double     LenProjection;
        double     LenPerpProjection;
} PROJECTION, *PPROJECTION, FAR *LPPROJECTION; 

typedef struct tagPOINTNORMAL  {
        VECTOR2D   vNormal;
        double     D;
} POINTNORMAL, *PPOINTNORMAL, FAR *LPPOINTNORMAL;

PVECTOR2D   vSubtractVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v);
double      vVectorSquared(PVECTOR2D v0);
double      vVectorMagnitude(PVECTOR2D v0);
double      vDotProduct(PVECTOR2D v, PVECTOR2D v1);
void        vProjectAndResolve(PVECTOR2D v0, PVECTOR2D v1, PPROJECTION ppProj);
double      vDistFromPointToLine(LPPOINT pt0, LPPOINT pt1, LPPOINT ptTest);

BOOL 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead );

BOOL
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite );

LPTSTR 
ExtractFileName (
    LPTSTR pFileSpec );

// Folder path 
DWORD
LoadDefaultLogFileFolder(
    TCHAR   *szFolder,
    INT*    piBufLen );

// Pdh counter paths

BOOL
AreSameCounterPath (
    PPDH_COUNTER_PATH_ELEMENTS pFirst,
    PPDH_COUNTER_PATH_ELEMENTS pSecond );

// SQL data source

DWORD
FormatSqlDataSourceName (
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName,
    LPWSTR  szSqlDataSourceName,
    ULONG*  pulBufLen );

DWORD 
DisplayDataSourceError (
    HWND    hwndOwner,
    DWORD   dwErrorStatus,
    INT     iDataSourceType,
    LPCWSTR szLogFileName,
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName );

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
	CWaitCursor();
	virtual ~CWaitCursor();

private:
    void DoWaitCursor ( INT nCode );
    
    HCURSOR  m_hcurWaitCursorRestore;
};


#endif //_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\utils.cpp ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

	This file contains miscellaneous utiltity routines, mostly 
	low-level windows helpers. These routines are not specific
	to the System Monitor control.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <windows.h>
#include <assert.h>
#include <ole2.h>    // for SystemTimeToVariantTime
#include <stdarg.h>  // For ANSI variable args. Dont use UNIX <varargs.h>
#include <stdio.h>   // for vsprintf.
#include <stdlib.h>  // For itoa
#include <string.h>  // for strtok
#include <olectl.h>  // for VT_COLOR
#include <tchar.h>
#include <math.h>
#include <winperf.h>
#include "utils.h"
#include "unihelpr.h"
#include "globals.h"
#include "winhelpr.h"
#include "polyline.h"   // For eDataSourceType
#include "smonmsg.h"     // For error string IDs.

#define RESOURCE_STRING_BUF_LEN  256
#define NUM_RESOURCE_STRING_BUFFERS     16
#define MISSING_RESOURCE_STRING  TEXT("????")

#define szHexFormat                 TEXT("0x%08lX")
#define szLargeHexFormat            TEXT("0x%08lX%08lX")

LPCWSTR cszSqlDataSourceFormat = L"SQL:%s!%s";

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//



VOID 
ClientRectToScreen (
    IN      HWND    hWnd,
    IN OUT  LPRECT  lpRect
    )
/*
   Effect:        Remaps lpRect from client coordinates to screen
                  coordinates. Analogous to ClientToScreen for rectangles.

   Note:          To convert a rectangle from the client coordinates of
                  Wnd1 to the client coordinates of Wnd2, call:

                        ClientRectToScreen (hWnd1, &rect) ;
                        ScreenRectToClient (hWnd2, &rect) ;

   See Also:      ClientToScreen (windows), ScreenRectToClient.

   Internals:     Since a rectangle is really only two points, let
                  windows do the work with ClientToScreen.
*/
   {  /* ClientRectToScreen */
   POINT    pt1, pt2 ;

   pt1.x = lpRect->left ;
   pt1.y = lpRect->top ;

   pt2.x = lpRect->right ;
   pt2.y = lpRect->bottom ;

   ClientToScreen (hWnd, &pt1) ;
   ClientToScreen (hWnd, &pt2) ;

   lpRect->left = pt1.x ;
   lpRect->top = pt1.y ;

   lpRect->right = pt2.x ;
   lpRect->bottom = pt2.y ;
   }  // ClientRectToScreen


VOID 
ScreenRectToClient (
    IN      HWND    hWnd, 
    IN OUT  LPRECT  lpRect
    )
/*
   Effect:        Remaps lpRect from screen coordinates to client
                  coordinates. Analogous to ScreenToClient for rectangles.

   Note:          To convert a rectangle from the client coordinates of
                  Wnd1 to the client coordinates of Wnd2, call:

                        ClientRectToScreen (hWnd1, &rect) ;
                        ScreenRectToClient (hWnd2, &rect) ;

   See Also:      ScreenToClient (windows), ClientRectToScreen.

   Internals:     Since a rectangle is really only two points, let
                  windows do the work with ScreenToClient.
*/
   {  // ScreenRectToClient
   POINT    pt1, pt2 ;

   pt1.x = lpRect->left ;
   pt1.y = lpRect->top ;

   pt2.x = lpRect->right ;
   pt2.y = lpRect->bottom ;

   ScreenToClient (hWnd, &pt1) ;
   ScreenToClient (hWnd, &pt2) ;

   lpRect->left = pt1.x ;
   lpRect->top = pt1.y ;

   lpRect->right = pt2.x ;
   lpRect->bottom = pt2.y ;
   }  // ScreenRectToClient


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


VOID
Line (
    IN  HDC     hDC,
    IN  HPEN    hPen,
    IN  INT     x1,
    IN  INT     y1,
    IN  INT     x2,
    IN  INT     y2
    )
{
    HPEN hPenPrevious = NULL;

    assert ( NULL != hDC );

    if ( NULL != hDC ) {
        if ( NULL != hPen ) {
            hPenPrevious = (HPEN)SelectObject (hDC, hPen) ;
        }

        MoveToEx (hDC, x1, y1, NULL) ;
        LineTo (hDC, x2, y2) ;

        if ( NULL != hPen ) {
            SelectObject (hDC, hPenPrevious);
        }
    }
}


VOID
Fill (
    IN  HDC     hDC,
    IN  DWORD   rgbColor,
    IN  LPRECT  lpRect
    )
{
    HBRUSH   hBrush = NULL;

    assert ( NULL != hDC && NULL != lpRect );
    
    if ( NULL != hDC && NULL != lpRect ) {

        hBrush = CreateSolidBrush (rgbColor) ;

        if ( NULL != hBrush ) {
            FillRect (hDC, lpRect, hBrush) ;
            DeleteObject (hBrush) ;
        }
    }
}


INT 
TextWidth (
    IN  HDC     hDC, 
    IN  LPCTSTR lpszText
    )
{
    SIZE     size ;
    INT      iReturn;

    iReturn = 0;

    assert ( NULL != hDC && NULL != lpszText );

    if ( NULL != lpszText && NULL != hDC) {
        if ( GetTextExtentPoint (hDC, lpszText, lstrlen (lpszText), &size) ) {
            iReturn = size.cx;
        }
    }
    return iReturn;
}


INT 
FontHeight (
    IN  HDC     hDC, 
    IN  BOOL    bIncludeLeading
    )
{
    TEXTMETRIC   tm ;
    INT  iReturn = 0;

    assert ( NULL != hDC );

    if ( NULL != hDC ) {
        GetTextMetrics (hDC, &tm) ;
        if (bIncludeLeading) {
            iReturn = tm.tmHeight + tm.tmExternalLeading;
        } else {
            iReturn = tm.tmHeight;
        }
    } 
    return iReturn;
}


INT
TextAvgWidth (
    IN  HDC hDC,
    IN  INT iNumChars
    )
{
    TEXTMETRIC   tm ;
    INT          xAvgWidth ;
    INT          iReturn = 0;

    assert ( NULL != hDC );

    if ( NULL != hDC ) {
        GetTextMetrics (hDC, &tm) ;

        xAvgWidth = iNumChars * tm.tmAveCharWidth ;

        // add 10% slop
        iReturn = MulDiv (xAvgWidth, 11, 10);  
    }
    return iReturn;
}


VOID 
DialogEnable (
    IN  HWND hDlg,
    IN  WORD wID,
    IN  BOOL bEnable
    )
/*
   Effect:        Enable or disable (based on bEnable) the control 
                  identified by wID in dialog hDlg.

   See Also:      DialogShow.
*/
{
    HWND       hControl ;

    assert ( NULL != hDlg );

    if ( NULL != hDlg ) {
        hControl = GetDlgItem (hDlg, wID) ;

        if (hControl) {
            EnableWindow (hControl, bEnable) ;
        }
    }
}


VOID
DialogShow (
    IN  HWND hDlg,
    IN  WORD wID,
    IN  BOOL bShow
    )
{
    HWND       hControl ;

    assert ( NULL != hDlg );

    if ( NULL != hDlg ) {

        hControl = GetDlgItem (hDlg, wID) ;

        if (hControl) {
            ShowWindow (hControl, bShow ? SW_SHOW : SW_HIDE) ;
        }
    }
}


LPTSTR 
LongToCommaString (
    IN  LONG    lNumber,
    OUT LPTSTR  lpszText )
{
    BOOL     bNegative ;
    TCHAR    szTemp1 [40] ;
    TCHAR    szTemp2 [40] ;
    LPTSTR   lpsz1 ;
    LPTSTR   lpsz2 ;
    INT      i ;
    INT      iDigit ;
    LPTSTR   pszReturn = NULL;

    assert ( NULL != lpszText );

    if ( NULL != lpszText ) {
        // Convert the number to a reversed string.
        lpsz1 = szTemp1 ;
        bNegative = (lNumber < 0) ;
        lNumber = labs (lNumber) ;

        if (lNumber) {
            while (lNumber) {
                iDigit = (INT) (lNumber % 10L) ;
                lNumber /= 10L ;
                *lpsz1++ = (TCHAR) (TEXT('0') + iDigit) ;
            }
        }
        else
          *lpsz1++ = TEXT('0') ;

        *lpsz1++ = TEXT('\0') ;

        // Reverse the string and add commas
        lpsz1 = szTemp1 + lstrlen (szTemp1) - 1 ;
        lpsz2 = szTemp2 ;

        if (bNegative)
            *lpsz2++ = TEXT('-') ;

        for (i = lstrlen (szTemp1) - 1; i >= 0 ; i--) {

            *lpsz2++ = *lpsz1-- ;

            if (i && !(i % 3))
                *lpsz2++ = TEXT(',') ;
        }

        *lpsz2++ = TEXT('\0') ;

        pszReturn = lstrcpy (lpszText, szTemp2) ;
    }

    return pszReturn;
}
 


FLOAT DialogFloat (
    IN  HWND hDlg, 
    IN  WORD wControlID,
    OUT BOOL *pbOK)
/*
   Effect:        Return a floating point representation of the string
                  value found in the control wControlID of hDlg.

   Internals:     We use sscanf instead of atof becuase atof returns a 
                  double. This may or may not be the right thing to do.
*/
{
   TCHAR          szValue [20] ;
   FLOAT          eValue = 0.0;
   INT            iNumScanned ;

   assert ( NULL != hDlg );

   if ( NULL != hDlg ) {
       DialogText (hDlg, wControlID, szValue) ;
       //ReconvertDecimalPoint (szValue) ;
       iNumScanned = _stscanf (szValue, TEXT("%e"), &eValue) ;

       if (pbOK)
          *pbOK = (iNumScanned == 1) ;

   }
   return (eValue) ;
}


BOOL 
MenuEnableItem (
    IN  HMENU hMenu,
    IN  WORD wID,
    IN  BOOL bEnable
    )
/*
   Effect:        Enable or disable, depending on bEnable, the menu item
                  associated with id wID in the menu hMenu.

                  Any disabled menu items are displayed grayed out.

   See Also:      EnableMenuItem (windows).
*/
{
   return (EnableMenuItem (hMenu, wID,
                           bEnable ? (MF_ENABLED | MF_BYCOMMAND) :
                                     (MF_GRAYED | MF_BYCOMMAND))) ;
}


INT 
WindowHeight (
    IN  HWND hWnd )
{
    RECT rectWindow ;
    INT iReturn = 0;
    
    assert ( NULL != hWnd );

    if ( NULL != hWnd ) {
        GetWindowRect (hWnd, &rectWindow) ;

        iReturn = rectWindow.bottom - rectWindow.top ;
    }
    return iReturn;
}


INT 
WindowWidth (
    IN  HWND hWnd )
{
    RECT    rectWindow ;
    INT     iReturn = 0;

    assert ( NULL != hWnd );

    if ( NULL != hWnd ) {
        GetWindowRect (hWnd, &rectWindow) ;
        iReturn = rectWindow.right - rectWindow.left ;
    }

    return iReturn;
}

VOID 
WindowResize (
    IN  HWND hWnd,
    IN  INT xWidth,
    IN  INT yHeight
    )
/*
   Effect:        Change the size of the window hWnd, leaving the
                  starting position intact.  Redraw the window.

                  If either xWidth or yHeight is NULL, keep the
                  corresponding dimension unchanged.

   Internals:     Since hWnd may be a child of another parent, we need
                  to scale the MoveWindow arguments to be in the client
                  coordinates of the parent.
            
*/
{
    RECT           rectWindow ;
    HWND           hWndParent ;

    assert ( NULL != hWnd );

    if ( NULL != hWnd ) {
        GetWindowRect (hWnd, &rectWindow) ;
        hWndParent = WindowParent (hWnd) ;

        if (hWndParent)
            ScreenRectToClient (hWndParent, &rectWindow) ;

        MoveWindow (
            hWnd,
            rectWindow.left,
            rectWindow.top,
            xWidth ? xWidth : rectWindow.right - rectWindow.left,
            yHeight ? yHeight : rectWindow.bottom - rectWindow.top,
            TRUE) ;
    }
}


VOID 
WindowSetTopmost (
    IN  HWND hWnd, 
    IN  BOOL bTopmost
    )
/*
   Effect:        Set or clear the "topmost" attribute of hWnd. If a window
                  is "topmost", it remains ontop of other windows, even ones
                  that have the focus.
*/
{
   SetWindowPos (hWnd, bTopmost ? HWND_TOPMOST : HWND_NOTOPMOST,
                 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE) ;
}


VOID 
WindowEnableTitle (
    IN  HWND hWnd, 
    IN  BOOL bTitle)
{
    DWORD          dwStyle ;

    assert ( NULL != hWnd );

    if ( NULL != hWnd ) {

        dwStyle = WindowStyle (hWnd) ;

        if (bTitle)
            dwStyle = WS_TILEDWINDOW | dwStyle ;
        else
            dwStyle &= ~(WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX) ;

        if (!bTitle)
            SetMenu (hWnd, NULL) ;

        WindowSetStyle (hWnd, dwStyle) ;
        SetWindowPos (hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE |
                     SWP_NOZORDER | SWP_FRAMECHANGED );
    }
}


BOOL 
DeviceNumColors (
    IN  HDC hDC
    )
{
    BOOL    bReturn = FALSE;
    INT     nPlanes = 0;
    INT     nBitsPixel = 0;

    assert ( NULL != hDC );

    if ( NULL != hDC ) {
        nPlanes = GetDeviceCaps (hDC, PLANES) ;
        nBitsPixel = GetDeviceCaps (hDC, BITSPIXEL) ;

        bReturn = (1 << (nPlanes * nBitsPixel)) ;
    } 
    return bReturn;
}

VOID 
DrawBitmap (
    IN  HDC     hDC,
    IN  HBITMAP hBitmap,
    IN  INT     xPos,
    IN  INT     yPos,
    IN  LONG    lROPCode)
{
    BITMAP   bm;
    HDC      hDCMemory = NULL;
    INT      iByteCount = 0;
    HBITMAP  hBitmapOrig = NULL;

    assert ( NULL != hDC && NULL != hBitmap );

    if ( NULL != hDC && NULL != hBitmap ) {

        hDCMemory = CreateCompatibleDC (hDC) ;
    
        if ( NULL != hDCMemory ) {
            hBitmapOrig = (HBITMAP)SelectObject (hDCMemory, hBitmap) ;

            if ( NULL != hBitmap ) {
                ZeroMemory ( &bm, sizeof ( BITMAP ) );
                iByteCount = GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &bm) ;

                if ( 0 < iByteCount ) {

                    BitBlt (
                        hDC,                     // DC for Destination surface
                        xPos, yPos,              // location in destination surface
                        bm.bmWidth, bm.bmHeight, // dimension of bitmap
                        hDCMemory,               // DC for Source surface
                        0, 0,                    // location in source surface
                        lROPCode) ;              // ROP code
                }
            }
            DeleteDC (hDCMemory) ;
        }
    }
}


INT
MessageBoxResource (
    IN  HWND hWndParent, 
    IN  WORD wTextID, 
    IN  WORD wTitleID,
    IN  UINT uiStyle)
{
   return MessageBox (hWndParent, ResourceString(wTextID),
                         ResourceString(wTitleID), uiStyle);
}

BOOL NeedEllipses (  
    IN  HDC hAttribDC,
    IN  LPCTSTR pszText,
    IN  INT nTextLen,
    IN  INT xMaxExtent,
    IN  INT xEllipses,
    OUT INT *pnChars
   )
{

    SIZE size;

    *pnChars = 0;
    // If no space or no chars, just return
    if (xMaxExtent <= 0 || nTextLen == 0) {
        return FALSE;
    }


    assert ( NULL != hAttribDC 
                && NULL != pszText
                && NULL != pnChars );

    if ( NULL == hAttribDC 
            || NULL == pszText
            || NULL == pnChars ) {
        return FALSE;
    }

    // Find out how many characters will fit
    GetTextExtentExPoint(hAttribDC, pszText, nTextLen, xMaxExtent, pnChars, NULL, &size);

    // If all or none fit, we're done
    if (*pnChars == nTextLen || *pnChars == 0) {
        return FALSE;
    }

    // How many chars will fit with ellipses?
    if (xMaxExtent > xEllipses) {
        GetTextExtentExPoint(hAttribDC, pszText, *pnChars, (xMaxExtent - xEllipses), 
                             pnChars, NULL, &size);
    } else {
        *pnChars = 0;
    }

    // Better to show one char than just ellipses
    if ( 0 == *pnChars ) {
        *pnChars = 1;
        return FALSE;
    }

    return TRUE;
}


VOID FitTextOut (
    IN HDC hDC,
    IN HDC hAttribDC,
    IN UINT fuOptions, 
    IN CONST RECT *lprc, 
    IN LPCTSTR lpString,
    IN INT cbCount,
    IN INT iAlign,
    IN BOOL fVertical
   )
{
    TCHAR   achBuf[MAX_PATH + ELLIPSES_CNT + 1];
    INT     iExtent;
    INT     nOutCnt = 0;
    SIZE    size;
    INT     x,y;

    assert ( NULL != hAttribDC
            && NULL != lprc
            && NULL != lpString );

    if ( NULL != hAttribDC
            && NULL != lprc
            && NULL != lpString ) {

        iExtent = fVertical ? (lprc->bottom - lprc->top) : (lprc->right - lprc->left);

        GetTextExtentPoint (hAttribDC, ELLIPSES, ELLIPSES_CNT, &size) ;

        if (NeedEllipses(hAttribDC, lpString, cbCount, iExtent, size.cx, &nOutCnt)) {

// Todo:  Handle strings > MAX_PATH
            ZeroMemory ( achBuf, sizeof (achBuf) );

            nOutCnt = min(nOutCnt,MAX_PATH);
            cbCount = min(cbCount, MAX_PATH);
            memcpy(achBuf,lpString,cbCount * sizeof(TCHAR));
            lstrcpy(&achBuf[nOutCnt],ELLIPSES);
            nOutCnt += ELLIPSES_CNT;
            lpString = achBuf;
        }

        if (fVertical) {
            switch (iAlign) {

            case TA_CENTER: 
                y = (lprc->top + lprc->bottom) / 2;
                break;

            case TA_RIGHT: 
                y = lprc->top; 
                break;

            default:
                y = lprc->bottom;
                break;
            }

            x = lprc->left;
        } 
        else {
            switch (iAlign) {

            case TA_CENTER: 
                x = (lprc->left + lprc->right) / 2;
                break;

            case TA_RIGHT: 
                x = lprc->right; 
                break;

            default:
                x = lprc->left;
                break;
            }

            y = lprc->top;           
        }

        ExtTextOut(hDC, x, y, fuOptions, lprc, lpString, nOutCnt, NULL);
    }
}

BOOL
TruncateLLTime (
    IN  LONGLONG llTime,
    OUT LONGLONG* pllTime
    )
{
    SYSTEMTIME SystemTime;
    BOOL bReturn = FALSE;

    assert ( NULL != pllTime );
    
    if ( NULL != pllTime ) { 
        if ( FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime) ) {
            SystemTime.wMilliseconds = 0;
            bReturn = SystemTimeToFileTime(&SystemTime, (FILETIME*)pllTime);
        }
    }
    return bReturn;
}


BOOL
LLTimeToVariantDate (
    IN  LONGLONG llTime,
    OUT DATE *pdate
    )
{
    BOOL bReturn = FALSE;
    SYSTEMTIME SystemTime;

    assert ( NULL != pdate );

    if ( NULL != pdate ) {
        if ( FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime) ) {
            bReturn = SystemTimeToVariantTime(&SystemTime, pdate);
        } 
    }
    return bReturn;
}

    
BOOL
VariantDateToLLTime (
    IN  DATE date,
    OUT LONGLONG *pllTime
    )
{
    BOOL bReturn = FALSE;
    SYSTEMTIME SystemTime;


    assert ( NULL != pllTime );

    if ( NULL != pllTime ) {
        if ( VariantTimeToSystemTime(date, &SystemTime) ) {
            bReturn = SystemTimeToFileTime(&SystemTime,(FILETIME*)pllTime);
        }
    }
    return bReturn;
}

HRESULT
StringFromStream (
    LPSTREAM    pIStream,
    LPTSTR      *ppsz,
    INT         nLen
    )
{
    HRESULT     hr = E_INVALIDARG;
    ULONG       bc;
    LPSTR       pszAnsi;
    LPTSTR      pszTemp;

    USES_CONVERSION

    assert ( NULL != pIStream && NULL != ppsz );

    if ( NULL != pIStream
           && NULL != ppsz ) {

        *ppsz = NULL;

        if (nLen == 0) {
            hr = S_OK;
        } else {

            pszAnsi = (LPSTR)alloca(nLen + 1);
            hr = pIStream->Read(pszAnsi, nLen, &bc);

            if ( SUCCEEDED (hr) ) {
                if (bc != (ULONG)nLen) {
                    hr = E_FAIL;
                }
            }

            if ( SUCCEEDED (hr) ) {
    
                // Convert to internal char type
                pszAnsi[nLen] = 0;
                pszTemp = A2T(pszAnsi);

                *ppsz = new TCHAR [lstrlen(pszTemp) + 1];
                if ( NULL != *ppsz ) {
                    lstrcpy(*ppsz, pszTemp);
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    return hr;
}

//
//  WideStringFromStream also supports multi-sz
//
HRESULT
WideStringFromStream (
    LPSTREAM    pIStream,
    LPTSTR      *ppsz,
    INT         nLen
    )
{
    ULONG       bc;
    LPWSTR      pszWide = NULL;
    HRESULT     hr = E_POINTER;

    assert ( NULL != pIStream && NULL != ppsz );

    // This method does not perform conversion from W to T.
    assert ( sizeof(WCHAR) == sizeof(TCHAR) );

    if ( NULL != pIStream
           && NULL != ppsz ) {

        *ppsz = NULL;

        if (nLen == 0) {
            hr = S_OK;
        } else {
            pszWide = (LPWSTR)alloca( (nLen + 1) * sizeof(WCHAR) );
            hr = pIStream->Read(pszWide, nLen*sizeof(WCHAR), &bc);
 
            if (SUCCEEDED(hr)) {
                if (bc != (ULONG)nLen*sizeof(WCHAR)) {
                    hr = E_FAIL;
                }
            }
            if (SUCCEEDED(hr)) {
                // Write ending NULL for non-multisz strings.
                pszWide[nLen] = L'\0';

                *ppsz = new WCHAR [nLen + 1];
                if ( NULL != *ppsz ) {
                    memcpy(*ppsz, pszWide, (nLen+1)*sizeof(WCHAR) );
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    return hr;
}

//
// Property bag I/O - only include if user knows about IStream
//
#ifdef __IPropertyBag_INTERFACE_DEFINED__

HRESULT
IntegerToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    INT intData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I4;
        vValue.lVal = intData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
OleColorToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    OLE_COLOR& clrData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_COLOR;       // VT_COLOR = VT_I4
        vValue.lVal = clrData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
ShortToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    SHORT iData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I2;
        vValue.iVal = iData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
BOOLToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    BOOL bData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_BOOL;
        vValue.boolVal = (SHORT)bData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
DoubleToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    DOUBLE dblData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R8;
        vValue.dblVal = dblData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
FloatToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    FLOAT fData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R4;
        vValue.fltVal = fData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
CyToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    CY& cyData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_CY;
        vValue.cyVal.int64 = cyData.int64;
    
        hr = VariantChangeType ( &vValue, &vValue, NULL, VT_BSTR );

        if ( SUCCEEDED ( hr ) ) 
            hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

typedef struct _HTML_ENTITIES {
    LPTSTR szHTML;
    LPTSTR szEntity;
} HTML_ENTITIES;

HTML_ENTITIES g_htmlentities[] = {
    _T("&"),    _T("&amp;"),
    _T("\""),   _T("&quot;"),
    _T("<"),    _T("&lt;"),
    _T(">"),    _T("&gt;"),
    NULL, NULL
};

HRESULT
StringToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    LPCTSTR szData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;
    LPTSTR  szTrans = NULL;
    BOOL    bAllocated = FALSE;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        vValue.bstrVal = NULL;

        if ( NULL != szData ) {
            int i;
            ULONG lSize = 0;
            LPTSTR szScan;

            for( i=0 ;g_htmlentities[i].szHTML != NULL; i++ ){
                szScan = (LPTSTR)szData;
                while( *szScan != _T('\0') ){
                    if( *szScan == *g_htmlentities[i].szHTML ){
                        lSize += (6*sizeof(TCHAR));
                    }
                    szScan++;
                }
            }
            if( lSize > 0 ){
                szTrans = (LPTSTR)malloc(lSize);
                if( szTrans != NULL ){
                    bAllocated = TRUE;
                    ZeroMemory( szTrans, lSize );
                    szScan = (LPTSTR)szData;
                    while( *szScan != _T('\0') ){
                        BOOL bEntity = FALSE;
                        for( i=0; g_htmlentities[i].szHTML != NULL; i++ ){
                            if( *szScan == *g_htmlentities[i].szHTML ){
                                bEntity = TRUE;
                                _tcscat( szTrans, g_htmlentities[i].szEntity );
                                break;
                            }
                        }
                        if( !bEntity ){
                            _tcsncat( szTrans, szScan, 1 );
                        }
                        szScan++;
                    }
                }
            }else{
                szTrans = (LPTSTR)szData;
            }
            vValue.bstrVal = SysAllocString ( T2W( szTrans ) );

            if ( NULL != vValue.bstrVal ) {
                hr = pIPropBag->Write(szPropName, &vValue );    
                VariantClear ( &vValue );
            } else {
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = pIPropBag->Write(szPropName, &vValue );    
        }
    }
    if( NULL != szTrans && bAllocated ){
        free( szTrans );
    }
    return hr;
}

HRESULT
LLTimeToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCTSTR szPropName, 
    LONGLONG& rllData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;
    BOOL bStatus;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_DATE;

        bStatus = LLTimeToVariantDate ( rllData, &vValue.date );

        if ( bStatus ) {

            hr = pIPropBag->Write(szPropName, &vValue );

            VariantClear ( &vValue );
    
        } else { 
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT
IntegerFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    INT& rintData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I4;
        vValue.lVal = 0;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rintData = vValue.lVal;
        }
    }
    return hr;
}

HRESULT
OleColorFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    OLE_COLOR& rintData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_COLOR;   // VT_COLOR == VT_I4;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rintData = vValue.lVal;
        }
    }
    return hr;
}

HRESULT
BOOLFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    BOOL& rbData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_BOOL;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rbData = vValue.boolVal;
        }
    }
    return hr;
}

HRESULT
DoubleFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    DOUBLE& rdblData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R8;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rdblData = vValue.dblVal;
        }
    }

    return hr;
}

HRESULT
FloatFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    FLOAT& rfData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R4;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rfData = vValue.fltVal;
        }
    }
    return hr;
}

HRESULT
ShortFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    SHORT& riData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I2;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            riData = vValue.iVal;
        }
    }
    return hr;
}

HRESULT
CyFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    CY& rcyData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_CY;
        vValue.cyVal.int64 = 0;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );
    
        if ( SUCCEEDED( hr ) ) {
            hr = VariantChangeType ( &vValue, &vValue, NULL, VT_CY );

            if ( SUCCEEDED ( hr ) ) {
                rcyData.int64 = vValue.cyVal.int64;
            }
        }
    }
    return hr;
}

HRESULT
StringFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    LPTSTR szData,
    INT& riBufSize )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        if ( NULL != szData ) {
            lstrcpy ( szData, _T("") );
        }

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        vValue.bstrVal = NULL;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED(hr) && vValue.bstrVal ) {
            INT iNewBufSize = SysStringLen(vValue.bstrVal) + 2;
            if ( iNewBufSize > 2 ) {
                
                if ( riBufSize >= iNewBufSize && NULL != szData ) {
                    
                    LPTSTR szTrans = (LPTSTR)malloc(iNewBufSize);
                    
                    if( szTrans != NULL ){
                        lstrcpy ( szData, W2T( vValue.bstrVal) );
                        for( int i=0;g_htmlentities[i].szHTML != NULL;i++ ){
                            LPTSTR szScan = NULL;
                            while( szScan = _tcsstr( szData, g_htmlentities[i].szEntity ) ){
                                *szScan = _T('\0');
                                _tcscpy( szTrans, szData );
                                _tcscat( szTrans, g_htmlentities[i].szHTML );
                                szScan += _tcslen( g_htmlentities[i].szEntity);
                                _tcscat( szTrans, szScan );
                                _tcscpy( szData, szTrans );
                            }
                        }
                        free( szTrans );
                    }else{
                        lstrcpy ( szData, W2T( vValue.bstrVal) );
                    }
                }
                riBufSize = iNewBufSize;
            } else {    
                riBufSize = 0;
            }
        }
    }
    return hr;
}

HRESULT
LLTimeFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCTSTR szPropName, 
    LONGLONG& rllData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_DATE;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED(hr) ) {
            if ( !VariantDateToLLTime ( vValue.date, &rllData ) ) {
                hr = E_FAIL;
            }
            VariantClear( &vValue );
        }
    }
    return hr;
}

#endif // Property bag

LPTSTR
ResourceString (
    UINT    uID
    )
{

    static TCHAR aszBuffers[NUM_RESOURCE_STRING_BUFFERS][RESOURCE_STRING_BUF_LEN];
    static INT iBuffIndex = 0;

    // Use next buffer
    if (++iBuffIndex >= NUM_RESOURCE_STRING_BUFFERS)
        iBuffIndex = 0;

    // Load and return string
    if (LoadString(g_hInstance, uID, aszBuffers[iBuffIndex], RESOURCE_STRING_BUF_LEN))
        return aszBuffers[iBuffIndex];
    else
        return MISSING_RESOURCE_STRING;
}

DWORD
FormatSystemMessage (
    DWORD   dwMessageId,
    LPTSTR  pszSystemMessage, 
    DWORD   dwBufSize )
{
    DWORD dwReturn = 0;
    HINSTANCE hPdh = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;

    assert ( NULL != pszSystemMessage );

    if ( NULL != pszSystemMessage ) {
        pszSystemMessage[0] = _T('\0');

        hPdh = LoadLibrary( _T("PDH.DLL") );

        if ( NULL != hPdh ) {
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }

        dwReturn = ::FormatMessage ( 
                         dwFlags,
                         hPdh,
                         dwMessageId,
                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                         pszSystemMessage,
                         dwBufSize,
                         NULL );
    
        if ( NULL != hPdh ) {
            FreeLibrary( hPdh );
        }

        if ( _T('\0') == pszSystemMessage[0] ) {
            _stprintf ( pszSystemMessage, _T("0x%08lX"), dwMessageId );
        }
    }
    return dwReturn;
}

INT
GetNumSeparators  (
    LPTSTR& rpDecimal,
    LPTSTR& rpThousand )
{
#define NUM_BUF_LEN  4
    INT iLength;

    static TCHAR szDecimal[NUM_BUF_LEN];
    static TCHAR szThousand[NUM_BUF_LEN];

    rpDecimal = NULL;
    rpThousand = NULL;

    iLength = GetLocaleInfo (
                    LOCALE_USER_DEFAULT,
                    LOCALE_SDECIMAL,
                    szDecimal,
                    NUM_BUF_LEN );

    if ( 0 != iLength ) {
        iLength  = GetLocaleInfo (
                        LOCALE_USER_DEFAULT,
                        LOCALE_STHOUSAND,
                        szThousand,
                        NUM_BUF_LEN );

    }

    if ( 0 != iLength ) {
        rpDecimal = szDecimal;
        rpThousand = szThousand;
    }

    return iLength;
}

LPTSTR
GetTimeSeparator  ( void )
{
#define TIME_MARK_BUF_LEN  5
    static INT iInitialized;   // Initialized to 0
    static TCHAR szTimeSeparator[TIME_MARK_BUF_LEN];

    if ( 0 == iInitialized ) {
        INT iLength;
        
        iLength = GetLocaleInfo (
                        LOCALE_USER_DEFAULT,
                        LOCALE_STIME,
                        szTimeSeparator,
                        TIME_MARK_BUF_LEN );

        // Default to colon for time separator
        if ( _T('\0') == szTimeSeparator[0] ) {
            lstrcpy (szTimeSeparator, _T(":") );
        }

        iInitialized = 1;
    }

    assert ( _T('\0') != szTimeSeparator[0] );

    return szTimeSeparator;
}
            
BOOL    
DisplayThousandsSeparator ( void )
{
    long nErr;
    HKEY hKey = NULL;
    DWORD dwRegValue;
    DWORD dwDataType;
    DWORD dwDataSize;
    DWORD dwDisposition;

    static INT siInitialized;   // Initialized to 0
    static BOOL sbUseSeparator; // Initialized to 0 ( FALSE )

    // check registry setting to see if thousands separator is enabled
    if ( 0 == siInitialized ) {
        nErr = RegOpenKey( 
                    HKEY_CURRENT_USER,
                    _T("Software\\Microsoft\\SystemMonitor"),
                    &hKey );

        if( ERROR_SUCCESS != nErr ) {
            nErr = RegCreateKeyEx( 
                        HKEY_CURRENT_USER,
                        _T("Software\\Microsoft\\SystemMonitor"),
                        0,
                        _T("REG_DWORD"),
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisposition );
        }

        dwRegValue = 0;
        if ( ERROR_SUCCESS == nErr ) {

            dwDataSize = sizeof(DWORD);
            nErr = RegQueryValueExW (
                        hKey,
                        _T("DisplayThousandsSeparator"),
                        NULL,
                        &dwDataType,
                        (LPBYTE) &dwRegValue,
                        (LPDWORD) &dwDataSize );

            if ( ERROR_SUCCESS == nErr 
                    && REG_DWORD == dwDataType
                    && sizeof(DWORD) == dwDataSize )
            {
                if ( 0 != dwRegValue ) {
                    sbUseSeparator = TRUE;
                }
            }
            siInitialized = 1;
        }

        if ( NULL != hKey ) {        
            nErr = RegCloseKey( hKey );
        }
    }

    return sbUseSeparator;
}

INT
FormatNumberInternal (
    LPTSTR  pNumOrig,
    LPTSTR  pNumFormatted,
    INT     cchars,
    UINT    uiPrecision,
    UINT    uiLeadingZero,
    UINT    uiGrouping,
    UINT    uiNegativeMode )
{
    INT iLength = 0;
    TCHAR* pszSrc;

    static INT siInitialized;   // Initialized to 0
    static NUMBERFMT NumberFormat;

    assert ( NULL != pNumOrig && NULL != pNumFormatted );

    if ( NULL != pNumOrig && NULL != pNumFormatted ) {

        iLength = 2;

        NumberFormat.NumDigits = uiPrecision;
        NumberFormat.LeadingZero = uiLeadingZero; 
        NumberFormat.NegativeOrder = uiNegativeMode;

        if ( DisplayThousandsSeparator() ) {
            NumberFormat.Grouping = uiGrouping;
        } else {
            NumberFormat.Grouping = 0;
        }

        if ( 0 == siInitialized ) {
            iLength = GetNumSeparators ( 
                        NumberFormat.lpDecimalSep,
                        NumberFormat.lpThousandSep );
            siInitialized = 1;
        }

        // GetNumberFormat requires "." for decimal point.
        if ( NumberFormat.lpDecimalSep != NULL) {
            if (0 != lstrcmpi(NumberFormat.lpDecimalSep, _T(".")) ) { 

                for ( pszSrc = pNumOrig; *pszSrc != '\0'; pszSrc++) {
                    if ( *pszSrc == NumberFormat.lpDecimalSep[0] ) {
                        TCHAR szDecimalDot[2];
                        lstrcpy (szDecimalDot, _T("."));
                        *pszSrc = szDecimalDot[0];
                        break;
                    }
                }
            }
        }

        if ( 0 != iLength ) {
            iLength = GetNumberFormat ( 
                        LOCALE_USER_DEFAULT,
                        0,
                        pNumOrig,
                        &NumberFormat,
                        pNumFormatted,
                        cchars );
        }
    }
    // Return 0 on failure, number of chars on success.
    // GetNumberFormat includes the null terminator in the length.
    return iLength;
}

INT
FormatHex (
    double  dValue,
    LPTSTR  pNumFormatted,
    BOOL    bLargeFormat
    )
{
    INT     iLength = 0;
    TCHAR   szPreFormat[24];
    
    assert ( NULL != pNumFormatted );

    if ( NULL != pNumFormatted ) {
        iLength = 8;
        // Localization doesn't handle padding blanks.
        _stprintf (
            szPreFormat, 
            (bLargeFormat ? szLargeHexFormat : szHexFormat ),
            (ULONG)dValue );
        wcscpy(pNumFormatted,szPreFormat);
    }
     
    return iLength;
}

INT
FormatNumber (
    double  dValue,
    LPTSTR  pNumFormatted,
    INT     ccharsFormatted,
    UINT    /* uiMinimumWidth */,
    UINT    uiPrecision )
{
    INT iLength = 0;
    TCHAR   szPreFormat[24];
    INT iLeadingZero = FALSE;

    assert ( NULL != pNumFormatted );
    // This method enforces number format commonality
    if ( NULL != pNumFormatted ) {

        assert ( 8 > uiPrecision );

        // Localization doesn't handle padding blanks.
        _stprintf (
            szPreFormat, 
            TEXT("%0.7f"),   // assumes 7 >= uiPrecision 
            dValue );

        if ( 1 > dValue )
            iLeadingZero = TRUE;

        iLength = FormatNumberInternal ( 
                    szPreFormat, 
                    pNumFormatted,
                    ccharsFormatted,
                    uiPrecision,
                    iLeadingZero,   // Leading 0 
                    3,              // Grouping
                    1 );            // Negative format
    }
    
    // Return 0 on failure, number of chars on success.
    // GetNumberFormat includes the null terminator in the length.
    return iLength;
}

INT
FormatScientific (
    double  dValue,
    LPTSTR  pszNumFormatted,
    INT     ccharsFormatted,
    UINT    /* uiMinimumWidth */,
    UINT    uiPrecision )
{
    INT     iLength = 0;
    TCHAR   szPreFormat[24];
    TCHAR   szPreFormNumber[24];
    TCHAR   *pche;
    INT     iPreLen;
    INT     iPostLen;
    INT     iLeadingZero = FALSE;

    assert ( NULL != pszNumFormatted );
    // This method enforces number format commonality
    if ( NULL != pszNumFormatted ) {

        assert ( 8 > uiPrecision );
        assert ( 32 > ccharsFormatted );

        // Localization doesn't handle padding blanks.
        _stprintf (
            szPreFormat, 
            TEXT("%0.8e"),   // assumes 8 >= uiPrecision 
            dValue );

        pche = _tcsrchr(szPreFormat, _T('e'));
        if (pche != NULL) {
            iPreLen = (INT)((UINT_PTR)pche - (UINT_PTR)szPreFormat);        // Number of bytes
            iPostLen = lstrlen(pche) + 1;

            memcpy(szPreFormNumber, szPreFormat, iPreLen);
    
            iPreLen /= sizeof (TCHAR);  // Number of characters
    
            szPreFormNumber[iPreLen] = 0;

            if ( 1 > dValue ) {
                iLeadingZero = TRUE;
            }

            iLength = FormatNumberInternal ( 
                            szPreFormNumber, 
                            pszNumFormatted,
                            ccharsFormatted,
                            uiPrecision,
                            iLeadingZero,   // Leading 0 
                            0,              // Grouping
                            1 );            // Negative format

            if( ( iLength + iPostLen ) < ccharsFormatted ) {    
                lstrcat( pszNumFormatted, pche );
                iLength += iPostLen;
            }
        }
    }    
    // Return 0 on failure, number of chars on success.
    // GetNumberFormat includes the null terminator in the length.
    return iLength;
}

void
FormatDateTime (
    LONGLONG    llTime,
    LPTSTR      pszDate,
    LPTSTR      pszTime )
{
   SYSTEMTIME SystemTime;

   assert ( NULL != pszDate && NULL != pszTime );
   if ( NULL != pszDate
       && NULL != pszTime ) {

       FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime);
       GetTimeFormat (LOCALE_USER_DEFAULT, 0, &SystemTime, NULL, pszTime, MAX_TIME_CHARS) ;
       GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &SystemTime, NULL, pszDate, MAX_DATE_CHARS) ;
   } 
}

// CreateTargetDC is based on AtlCreateTargetDC.
HDC
CreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd)
{
    USES_CONVERSION

    // cases  hdc, ptd, hdc is metafile, hic
//  NULL,    NULL,  n/a,    Display
//  NULL,   !NULL,  n/a,    ptd
//  !NULL,   NULL,  FALSE,  hdc
//  !NULL,   NULL,  TRUE,   display
//  !NULL,  !NULL,  FALSE,  ptd
//  !NULL,  !NULL,  TRUE,   ptd

    if ( NULL != ptd ) {
        LPDEVMODE lpDevMode;
        LPOLESTR lpszDriverName;
        LPOLESTR lpszDeviceName;
        LPOLESTR lpszPortName;

        if (ptd->tdExtDevmodeOffset == 0)
            lpDevMode = NULL;
        else
            lpDevMode  = (LPDEVMODE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

        lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
        lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
        lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

        return ::CreateDC(W2T(lpszDriverName), W2T(lpszDeviceName),
            W2T(lpszPortName), lpDevMode);
    } else if ( NULL == hdc ) {
        return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
    } else if ( GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE ) {
        return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
    } else
        return hdc;
}

/***********************************************************************

  FUNCTION   : HitTestLine

  PARAMETERS : POINT pt0 - endpoint for line segment
               POINT pt1 - endpoint for line segment
               POINTS ptMouse - mouse coordinates of hit
               INT nWidth - width of pen

  PURPOSE    : test if mouse click occurred on line segment while 
               adjusting for the width of line

  CALLS      : GetDC
               ReleaseDC
               SetGraphicsMode
               SetWorldTransform

  MESSAGES   : none

  RETURNS    : BOOL - TRUE if the point was within the width of the 
                      pen about the line 
                      FALSE if the point lies outside of the width
                      of the pen about the line

  COMMENTS   : uses VECTOR2D.DLL

  HISTORY    : 9/20/93 - created - denniscr

************************************************************************/

BOOL HitTestLine( POINT pt0, POINT pt1, POINTS ptMouse, INT nWidth )
{
    POINT PtM;
    VECTOR2D tt0, tt1;
    double dist;
    INT nHalfWidth;

    nHalfWidth = (nWidth/2 < 1) ? 1 : nWidth/2;

    //
    //convert the line into a vector
    //
    
    POINTS2VECTOR2D(pt0, pt1, tt0);
    //
    //convert the mouse points (short) into POINT (long)
    //
    
    MPOINT2POINT(ptMouse ,PtM);
    POINTS2VECTOR2D(pt0, PtM, tt1);
    
    //
    //if the mouse click is past the endpoints of 
    //a line segment return FALSE
    //
    
    if (pt0.x <= pt1.x)
    {
        if (PtM.x < pt0.x || PtM.x > pt1.x)
            return (FALSE);
    }
    else
    {
        if (PtM.x > pt0.x || PtM.x < pt1.x)
            return (FALSE);
    }
    //
    //this is the call to the function that does the work
    //of obtaining the distance of the point to the line
    //
    dist = vDistFromPointToLine(&pt0, &pt1, &PtM);

    //
    //TRUE if the distance is within the width of the pen about the
    //line otherwise FALSE
    //
    return (dist >= -nHalfWidth && dist <= nHalfWidth);
}

/***********************************************************************

vSubtractVectors 

The vSubtractVectors function subtracts the components of a two 
dimensional vector from another. The resultant vector 
c = (a1 - b1, a2 - b2).

Parameters

v0  A pointer to a VECTOR2D structure containing the components 
    of the first two dimensional vector.
v1  A pointer to a VECTOR2D structure containing the components 
    of the second two dimensional vector.
vt  A pointer to a VECTOR2D structure in which the components 
    of the two dimensional vector obtained from the subtraction of 
    the first two are placed.

Return value

A pointer to a VECTOR2D structure containing the new vector obtained 
from the subtraction of the first two parameters.

HISTORY    : - created - denniscr

************************************************************************/

PVECTOR2D  vSubtractVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v)
{
  if (v0 == NULL || v1 == NULL)
    v = (PVECTOR2D)NULL;
  else
  {
    v->x = v0->x - v1->x;
    v->y = v0->y - v1->y;
  }
  return(v);
}

/***********************************************************************

vVectorSquared

The vVectorSquared function squares each of the components of the 
vector and adds then together to produce the squared value of the 
vector. SquaredValue = a.x * a.x + a.y * a.y.

Parameters

v0  A pointer to a VECTOR2D structure containing the vector upon which 
to determine the squared value.

Return value

A double value which is the squared value of the vector. 

HISTORY    : - created - denniscr

************************************************************************/

double  vVectorSquared(PVECTOR2D v0)
{
  double dSqLen;

  if (v0 == NULL)
    dSqLen = 0.0;
  else
    dSqLen = (double)(v0->x * v0->x) + (double)(v0->y * v0->y);
  return (dSqLen);
}

/***********************************************************************

vVectorMagnitude

The vVectorMagnitude function determines the length of a vector by 
summing the squares of each of the components of the vector. The 
magnitude is equal to a.x * a.x + a.y * a.y.

Parameters

v0  A pointer to a VECTOR2D structure containing the vector upon 
    which to determine the magnitude.

Return value

A double value which is the magnitude of the vector. 

HISTORY    : - created - denniscr

************************************************************************/

double  vVectorMagnitude(PVECTOR2D v0)
{
  double dMagnitude;

  if (v0 == NULL)
    dMagnitude = 0.0;
  else
    dMagnitude = sqrt(vVectorSquared(v0));
  return (dMagnitude);
}


/***********************************************************************

vDotProduct

The function vDotProduct computes the dot product of two vectors. The 
dot product of two vectors is the sum of the products of the components 
of the vectors ie: for the vectors a and b, dotprod = a1 * a2 + b1 * b2.

Parameters

v0  A pointer to a VECTOR2D structure containing the first vector used 
    for obtaining a dot product.
v1  A pointer to a VECTOR2D structure containing the second vector used 
    for obtaining a dot product.

Return value

A double value containing the scalar dot product value.

HISTORY    : - created - denniscr

************************************************************************/

double  vDotProduct(PVECTOR2D v0, PVECTOR2D v1)
{
  return ((v0 == NULL || v1 == NULL) ? 0.0 
                                     : (v0->x * v1->x) + (v0->y * v1->y));
}


/***********************************************************************

vProjectAndResolve

The function vProjectAndResolve resolves a vector into two vector 
components. The first is a vector obtained by projecting vector v0 onto 
v1. The second is a vector that is perpendicular (normal) to the 
projected vector. It extends from the head of the projected vector 
v1 to the head of the original vector v0.

Parameters

v0     A pointer to a VECTOR2D structure containing the first vector 
v1     A pointer to a VECTOR2D structure containing the second vector
ppProj A pointer to a PROJECTION structure containing the resolved 
       vectors and their lengths.

Return value

void.

HISTORY    : - created - denniscr

************************************************************************/

void  vProjectAndResolve(PVECTOR2D v0, PVECTOR2D v1, PPROJECTION ppProj)
{
  VECTOR2D ttProjection, ttOrthogonal;
  double vDotProd;
  double proj1 = 0.0;
  //
  //obtain projection vector
  //
  //c = a * b
  //    ----- b
  //    |b|^2
  //

  ttOrthogonal.x = 0.0;
  ttOrthogonal.y = 0.0;
  vDotProd = vDotProduct(v1, v1);

  if ( 0.0 != vDotProd ) {
    proj1 = vDotProduct(v0, v1)/vDotProd;
  }

  ttProjection.x = v1->x * proj1;
  ttProjection.y = v1->y * proj1;
  //
  //obtain perpendicular projection : e = a - c
  //
  vSubtractVectors(v0, &ttProjection, &ttOrthogonal);
  //
  //fill PROJECTION structure with appropriate values
  //
  ppProj->LenProjection = vVectorMagnitude(&ttProjection);
  ppProj->LenPerpProjection = vVectorMagnitude(&ttOrthogonal);

  ppProj->ttProjection.x = ttProjection.x;
  ppProj->ttProjection.y = ttProjection.y;
  ppProj->ttPerpProjection.x = ttOrthogonal.x;
  ppProj->ttPerpProjection.y = ttOrthogonal.y;
}

/***********************************************************************

vDistFromPointToLine

The function vDistFromPointToLine computes the distance from the point 
ptTest to the line defined by endpoints pt0 and pt1. This is done by 
resolving the the vector from pt0 to ptTest into its components. The 
length of the component vector that is attached to the head of the 
vector from pt0 to ptTest is the distance of ptTest from the line.

Parameters

pt0    A pointer to a POINT structure containing the first endpoint of the 
       line.
pt1    A pointer to a POINT structure containing the second endpoint of the 
       line.
ptTest A pointer to a POINT structure containing the point for which the 
       distance from the line is to be computed.

Return value

A double value that contains the distance of ptTest to the line defined 
  by the endpoints pt0 and pt1.

HISTORY    : - created - denniscr
************************************************************************/

double  vDistFromPointToLine(LPPOINT pt0, LPPOINT pt1, LPPOINT ptTest)
{
  VECTOR2D ttLine, ttTest;
  PROJECTION pProjection;

  POINTS2VECTOR2D(*pt0, *pt1, ttLine);
  POINTS2VECTOR2D(*pt0, *ptTest, ttTest);

  vProjectAndResolve(&ttTest, &ttLine, &pProjection);
 
  return(pProjection.LenPerpProjection);
}


BOOL 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead)
{  
    BOOL           bSuccess = FALSE;
    DWORD          nAmtRead = 0;

    assert ( NULL != hFile );
    assert ( NULL != lpMemory );

    if ( NULL != hFile
            && NULL != lpMemory ) {
        bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
    } 
    return (bSuccess && (nAmtRead == nAmtToRead)) ;
}  // FileRead


BOOL 
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite)
{  
    BOOL           bSuccess = FALSE;
    DWORD          nAmtWritten  = 0;
    DWORD          dwFileSizeLow, dwFileSizeHigh;
    LONGLONG       llResultSize;

    if ( NULL != hFile
            && NULL != lpMemory ) {

        dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
        // limit file size to 2GB

        if (dwFileSizeHigh > 0) {
            SetLastError (ERROR_WRITE_FAULT);
            bSuccess = FALSE;
        } else {
            // note that the error return of this function is 0xFFFFFFFF
            // since that is > the file size limit, this will be interpreted
            // as an error (a size error) so it's accounted for in the following
            // test.
            llResultSize = dwFileSizeLow + nAmtToWrite;
            if (llResultSize >= 0x80000000) {
                SetLastError (ERROR_WRITE_FAULT);
                bSuccess = FALSE;
            } else {
                // write buffer to file
                bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &nAmtWritten, NULL) ;
                if (bSuccess) 
                    bSuccess = (nAmtWritten == nAmtToWrite ? TRUE : FALSE);
                if ( !bSuccess ) {
                    SetLastError (ERROR_WRITE_FAULT);
                }
            }
        }
    } else {
        assert ( FALSE );
        SetLastError (ERROR_INVALID_PARAMETER);
    } 

    return (bSuccess) ;

}  // FileWrite

// This routine extract the filename portion from a given full-path filename
LPTSTR 
ExtractFileName ( LPTSTR pFileSpec )
{
    LPTSTR   pFileName = NULL ;
    TCHAR    DIRECTORY_DELIMITER1 = TEXT('\\') ;
    TCHAR    DIRECTORY_DELIMITER2 = TEXT(':') ;

    assert ( NULL != pFileSpec );
    if ( pFileSpec ) {
        pFileName = pFileSpec + lstrlen (pFileSpec) ;

        while (*pFileName != DIRECTORY_DELIMITER1 &&
            *pFileName != DIRECTORY_DELIMITER2) {
            if (pFileName == pFileSpec) {
                // done when no directory delimiter is found
                break ;
            }
            pFileName-- ;
        }

        if (*pFileName == DIRECTORY_DELIMITER1
            || *pFileName == DIRECTORY_DELIMITER2) {
         
             // directory delimiter found, point the
             // filename right after it
             pFileName++ ;
        }
   }
   return pFileName ;
}  // ExtractFileName

// CWaitCursor class

CWaitCursor::CWaitCursor()
: m_hcurWaitCursorRestore ( NULL )
{ 
    DoWaitCursor(1); 
}

CWaitCursor::~CWaitCursor()
{ 
    DoWaitCursor(-1); 
}

void 
CWaitCursor::DoWaitCursor(INT nCode)
{
    // 1=> begin, -1=> end
    assert(nCode == 1 || nCode == -1);

    if ( 1 == nCode )
    {
        m_hcurWaitCursorRestore = SetHourglassCursor();
    } else {
        if ( NULL != m_hcurWaitCursorRestore ) {
            SetCursor(m_hcurWaitCursorRestore);
        } else {
            SetArrowCursor();
        }
    }
}

DWORD
LoadDefaultLogFileFolder(
    LPTSTR szFolder,
    INT* piBufLen )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DWORD   dwDataType;
    DWORD   dwBufferSize = 0;
    TCHAR*  szNewStringBuffer = NULL;

    assert ( NULL != szFolder );
    assert ( NULL != piBufLen );

    if ( NULL != szFolder 
        && NULL != piBufLen ) {

        dwStatus = RegOpenKey (
                     HKEY_LOCAL_MACHINE,
                     _T("System\\CurrentControlSet\\Services\\SysmonLog"),
                     &hKey );

        if ( ERROR_SUCCESS == dwStatus ) {

            dwDataType = 0;

            // Determine the size of the required buffer.
            dwStatus = RegQueryValueExW (
                hKey,
                _T("DefaultLogFileFolder"),
                NULL,
                &dwDataType,
                NULL,
                &dwBufferSize);

            if (dwStatus == ERROR_SUCCESS) {
                if (dwBufferSize > 0) {

                    szNewStringBuffer = new TCHAR[dwBufferSize / sizeof(WCHAR)];
                    if ( NULL != szNewStringBuffer ) {
                        *szNewStringBuffer = _T ('\0');
                    
                        dwStatus = RegQueryValueEx(
                                     hKey,
                                     _T("DefaultLogFileFolder"),
                                     NULL,
                                     &dwDataType,
                                     (LPBYTE) szNewStringBuffer,
                                     (LPDWORD) &dwBufferSize );
                             
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                } else {
                    dwStatus = ERROR_NO_DATA;
                }
            }
            RegCloseKey(hKey);
        }

        if (dwStatus == ERROR_SUCCESS) {
            if ( *piBufLen >= (INT)(dwBufferSize / sizeof(WCHAR)) ) {
                lstrcpy ( szFolder, szNewStringBuffer );
            } else {
                dwStatus = ERROR_INSUFFICIENT_BUFFER;
            }
            *piBufLen = dwBufferSize / sizeof(WCHAR);
        }
        if ( NULL != szNewStringBuffer ) 
            delete szNewStringBuffer;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    return dwStatus;
}


BOOL
AreSameCounterPath (
    PPDH_COUNTER_PATH_ELEMENTS pFirst,
    PPDH_COUNTER_PATH_ELEMENTS pSecond )
{
    BOOL bSame = FALSE;

    assert ( NULL != pFirst && NULL != pSecond );

    if ( NULL != pFirst && NULL != pSecond ) {

        if ( 0 == lstrcmpi ( pFirst->szMachineName, pSecond->szMachineName ) ) { 
            if ( 0 == lstrcmpi ( pFirst->szObjectName, pSecond->szObjectName ) ) { 
                if ( 0 == lstrcmpi ( pFirst->szInstanceName, pSecond->szInstanceName ) ) { 
                    if ( 0 == lstrcmpi ( pFirst->szParentInstance, pSecond->szParentInstance ) ) { 
                        if ( pFirst->dwInstanceIndex == pSecond->dwInstanceIndex ) { 
                            if ( 0 == lstrcmpi ( pFirst->szCounterName, pSecond->szCounterName ) ) { 
                                bSame = TRUE; 
                            }
                        }
                    }
                }
            }
        }
    }
    return bSame;
};

BOOL    
DisplaySingleLogSampleValue ( void )
{
    long nErr;
    HKEY hKey = NULL;
    DWORD dwRegValue;
    DWORD dwDataType;
    DWORD dwDataSize;
    DWORD dwDisposition;

    static INT siInitialized;   // Initialized to 0
    static BOOL sbSingleValue;  // Initialized to 0 ( FALSE )

    // check registry setting to see if thousands separator is enabled
    if ( 0 == siInitialized ) {
        nErr = RegOpenKey( 
                    HKEY_CURRENT_USER,
                    _T("Software\\Microsoft\\SystemMonitor"),
                    &hKey );

        if( ERROR_SUCCESS != nErr ) {
            nErr = RegCreateKeyEx( 
                        HKEY_CURRENT_USER,
                        _T("Software\\Microsoft\\SystemMonitor"),
                        0,
                        _T("REG_DWORD"),
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisposition );
        }

        dwRegValue = 0;
        if ( ERROR_SUCCESS == nErr ) {

            dwDataSize = sizeof(DWORD);
            nErr = RegQueryValueExW (
                        hKey,
                        _T("DisplaySingleLogSampleValue"),
                        NULL,
                        &dwDataType,
                        (LPBYTE) &dwRegValue,
                        (LPDWORD) &dwDataSize );

            if ( ERROR_SUCCESS == nErr 
                    && REG_DWORD == dwDataType
                    && sizeof(DWORD) == dwDataSize )
            {
                if ( 0 != dwRegValue ) {
                    sbSingleValue = TRUE;
                }
            }
            siInitialized = 1;
        }

        if ( NULL != hKey ) {        
            nErr = RegCloseKey( hKey );
        }
    }

    return sbSingleValue;
}

DWORD
FormatSqlDataSourceName (
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName,
    LPWSTR  szSqlDataSourceName,
    ULONG*  pulBufLen )
{

    DWORD dwStatus = ERROR_SUCCESS;
    ULONG ulNameLen;

    if ( NULL != pulBufLen ) {
        ulNameLen = 
            lstrlen (szSqlDsn) 
            + lstrlen(szSqlLogSetName)
            + 5    // SQL:<DSN>!<LOGSET>
            + 2;   // 2 NULL characters at the end;
    
        if ( ulNameLen <= *pulBufLen ) {
            if ( NULL != szSqlDataSourceName ) {
                ZeroMemory(szSqlDataSourceName, (ulNameLen * sizeof(WCHAR)));
                swprintf ( 
                    szSqlDataSourceName,
                    cszSqlDataSourceFormat,
                    szSqlDsn,
                    szSqlLogSetName );
            }
        } else if ( NULL != szSqlDataSourceName ) {
            dwStatus = ERROR_MORE_DATA;
        }    
        *pulBufLen = ulNameLen;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        assert ( FALSE );
    }
    return dwStatus;
}


DWORD 
DisplayDataSourceError (
    HWND    hwndOwner,
    DWORD   dwErrorStatus,
    INT     iDataSourceType,
    LPCWSTR szLogFileName,
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    LPWSTR  szMessage = NULL;
    LPWSTR  szDataSource = NULL;
    ULONG   ulMsgBufLen = 0;
    TCHAR   szSystemMessage[MAX_PATH];

    // todo:  Alloc message buffers

    if ( sysmonLogFiles == iDataSourceType ) {
        if ( NULL != szLogFileName ) {
            ulMsgBufLen = lstrlen ( szLogFileName ) +1;
            szDataSource = new WCHAR [ulMsgBufLen];
            if ( NULL != szDataSource ) {
                lstrcpy ( szDataSource, szLogFileName );
            } else {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            assert ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else if ( sysmonSqlLog == iDataSourceType ){
        if ( NULL != szSqlDsn && NULL != szSqlLogSetName ) {

            FormatSqlDataSourceName ( 
                        szSqlDsn,
                        szSqlLogSetName,
                        NULL,
                        &ulMsgBufLen );
            szDataSource = new WCHAR [ulMsgBufLen];
            if ( NULL != szDataSource ) {
                FormatSqlDataSourceName ( 
                            szSqlDsn,
                            szSqlLogSetName,
                            (LPWSTR)szDataSource,
                            &ulMsgBufLen );
            
            // todo:  check status
            } else {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            assert ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        ulMsgBufLen += RESOURCE_STRING_BUF_LEN;
        ulMsgBufLen += MAX_PATH;
        szMessage = new WCHAR [ulMsgBufLen];
        if ( NULL != szMessage ) {
            if ( SMON_STATUS_TOO_FEW_SAMPLES == dwErrorStatus ) {
                _stprintf ( szMessage, ResourceString(IDS_TOO_FEW_SAMPLES_ERR), szDataSource );
            } else if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == dwErrorStatus ) {
                _stprintf ( szMessage, ResourceString(IDS_LOG_FILE_TOO_LARGE_ERR), szDataSource );
            } else {
               _stprintf ( szMessage, ResourceString(IDS_BADDATASOURCE_ERR), szDataSource );
                FormatSystemMessage ( dwErrorStatus, szSystemMessage, MAX_PATH - 1 );
                lstrcat ( szMessage, szSystemMessage );
            }

            MessageBox(
                hwndOwner, 
                szMessage, 
                ResourceString(IDS_APP_NAME), 
                MB_OK | MB_ICONEXCLAMATION);
        }
    }
    
    if ( NULL != szDataSource ) {
        delete szDataSource;
    }

    if ( NULL != szMessage ) {
        delete szMessage;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\configureyourserver.hpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// class ConfigureYourServer, which implements IConfigureYourServer
//
// 28 Mar 2000



#ifndef CONFIGUREYOURSERVER_HPP_INCLUDED
#define CONFIGUREYOURSERVER_HPP_INCLUDED



class ConfigureYourServer
   :
   public IConfigureYourServer /* ,
   public ISupportErrorInfo */ // CODEWORK: add support for ErrorInfo
{
   // this is the only entity with access to the ctor of this class

   friend class ClassFactory<ConfigureYourServer>;

	public:

   // IUnknown methods

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& riid, void **ppv);

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

	// IDispatch methods

   virtual 
   HRESULT __stdcall
   GetTypeInfoCount(UINT *pcti);

	virtual 
   HRESULT __stdcall
   GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti);

   virtual 
   HRESULT __stdcall
	GetIDsOfNames(
	   REFIID  riid,    
	   OLECHAR **prgpsz,
	   UINT    cNames,  
	   LCID    lcid,    
	   DISPID  *prgids);

   virtual 
   HRESULT __stdcall
	Invoke(
	   DISPID     id,         
	   REFIID     riid,       
	   LCID       lcid,       
	   WORD       wFlags,     
	   DISPPARAMS *params,    
	   VARIANT    *pVarResult,
	   EXCEPINFO  *pei,       
	   UINT       *puArgErr); 

//    // ISupportErrorInfo methods
// 
//    virtual 
//    HRESULT __stdcall
//    InterfaceSupportsErrorInfo(const IID& iid);
      
   // IConfigureYourServer methods

   virtual 
   HRESULT __stdcall
   ExecuteWizard(
      /* [in] */           BSTR  service,
      /* [out, retval] */  BSTR* resultText);

   HRESULT __stdcall
   DsRole(
      /* [in*/             int  infoLevel,
      /* [out, retval] */  int* result);

   HRESULT __stdcall
   IsServiceInstalled(
      /* [in] */           BSTR bstrService,
      /* [out, retval] */  int* state);

   HRESULT __stdcall
   InstallService(
      /* [in] */           BSTR bstrService,
      /* [in] */           BSTR infFileText,
      /* [in] */           BSTR unattendFileText,
      /* [out, retval] */  BOOL *pbRet);

   HRESULT __stdcall
   ValidateName(
      /* [in] */           BSTR bstrType,
      /* [in] */           BSTR bstrName,
      /* [out, retval] */  int* retval);

   HRESULT __stdcall
   CheckDhcpServer(
      /* [out, retval] */  BOOL *pbRet);

   virtual 
   HRESULT __stdcall
   SetStaticIpAddressAndSubnetMask(
      /* [in] */           BSTR  staticIp,
      /* [in] */           BSTR  subnetMask,
      /* [out, retval] */  BOOL* success);

   virtual
   HRESULT __stdcall
   IsDhcpConfigured(
      /* [out, retval] */  BOOL* retval);

   virtual
   HRESULT __stdcall
   CreateAndWaitForProcess( 
      /* [in] */           BSTR commandLine,
      /* [out, retval] */  long* retval);

   virtual
   HRESULT __stdcall
   IsCurrentUserAdministrator(
      /* [out, retval] */  BOOL* retval);      

   virtual
   HRESULT __stdcall
   BrowseForFolder(
      /* [in]          */  BSTR  windowTitle,
      /* [out, retval] */  BSTR* folderPath);

   // 1 = personal
   // 2 = professional
   // 3 = server
   // 4 = advanced server
   // 5 = data center

   virtual
   HRESULT __stdcall
   GetProductSku(
      /* [out, retval] */  int* retval);

   virtual
   HRESULT __stdcall
   IsClusteringConfigured(
      /* [out, retval] */  BOOL* retval);

	private:

   // only our friend class factory can instantiate us.

   ConfigureYourServer();

   // only Release can cause us to be deleted

   virtual
   ~ConfigureYourServer();

   // not implemented: no copying allowed

   ConfigureYourServer(const ConfigureYourServer&);
   const ConfigureYourServer& operator=(const ConfigureYourServer&);

   ComServerReference dllref;      
   long               refcount;    
   ITypeInfo**        m_ppTypeInfo;
};



#endif   // CONFIGUREYOURSERVER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\executewizard.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of IConfigureYourServer::ExecuteWizard
//
// 30 Mar 2000 sburns



#include "headers.hxx"
#include "ConfigureYourServer.hpp"
#include "util.hpp"
#include "resource.h"



String
LaunchWrapperWizardExe(
   const String& commandLine, 
   unsigned      launchFailureResId,
   unsigned      failureResId,
   unsigned      successResId)
{
   LOG_FUNCTION2(LaunchWrapperWizardExe, commandLine);
   ASSERT(!commandLine.empty());
   ASSERT(launchFailureResId);
   ASSERT(failureResId);
   ASSERT(successResId);

   String result;
   do
   {
      String sysFolder = Win::GetSystemDirectory();

      DWORD exitCode = 0;
      HRESULT hr = CreateAndWaitForProcess(commandLine, exitCode);
      if (FAILED(hr))
      {
         result = String::load(launchFailureResId);
         break;
      }

      // the exit codes from the wrapper wizards are HRESULTs.
      
      if (SUCCEEDED(static_cast<HRESULT>(exitCode)))
      {
         result = String::load(successResId);
         break;
      }

      result = String::load(failureResId);
   }
   while (0);

   LOG(result);

   return result;
}
   

   
String
LaunchPrintWizardExe(
   const String& commandLine, 
   unsigned      launchFailureResId,
   unsigned      failureResId,
   unsigned      successResId)
{
   LOG_FUNCTION2(LaunchPrintWizardExe, commandLine);
   ASSERT(!commandLine.empty());
   ASSERT(launchFailureResId);
   ASSERT(failureResId);
   ASSERT(successResId);

   String result;
   do
   {
      HINSTANCE printui = 0;
      HRESULT hr = Win::LoadLibrary(L"printui.dll", printui);

      if (SUCCEEDED(hr))
      {
         FARPROC proc = 0;
         hr = Win::GetProcAddress(printui, L"PrintUIEntryW", proc);

         if (SUCCEEDED(hr))
         {
            typedef DWORD (*PrintUIEntryW)(HWND, HINSTANCE, PCTSTR, UINT);      
            PrintUIEntryW uiproc = reinterpret_cast<PrintUIEntryW>(proc);

            DWORD err = 
               uiproc(
                  Win::GetActiveWindow(),
                  Win::GetModuleHandle(),
                  commandLine.c_str(),
                  TRUE);
            hr = Win32ToHresult(err);
         }
         else
         {
            LOG(L"unable to locate PrintUIEntryW proc address");
         }

         HRESULT unused = Win::FreeLibrary(printui);

         ASSERT(SUCCEEDED(unused));
      }

      if (SUCCEEDED(hr))
      {
         result = String::load(successResId);
         break;
      }

      result = String::format(failureResId, GetErrorMessage(hr).c_str());
   }
   while (0);

   LOG(result);

   return result;
}



HRESULT __stdcall
ConfigureYourServer::ExecuteWizard(
   /* [in] */           BSTR  service,
   /* [out, retval] */  BSTR* resultText)
{
   LOG_FUNCTION2(
      ConfigureYourServer::ExecuteWizard,
      service ? service : L"(null)");
   ASSERT(service);
   ASSERT(resultText);

   HRESULT hr = S_OK;
   String result;

   do
   {
      if (!service || !resultText)
      {
         hr = E_INVALIDARG;
         break;
      }

      String s(service);

      if (s.icompare(L"DNS") == 0)
      {
         // launch wrapper exe

         result =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_DNS_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               IDS_LAUNCH_DNS_WIZARD_FAILED,
               IDS_DNS_WIZARD_FAILED,
               IDS_DNS_WIZARD_SUCCEEDED);
         break;
      }
      else if (s.icompare(L"DHCP") == 0)
      {
         // launch wrapper exe

         result =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_DHCP_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               IDS_LAUNCH_DHCP_WIZARD_FAILED,
               IDS_DHCP_WIZARD_FAILED,
               IDS_DHCP_WIZARD_SUCCEEDED);
         break;
      }
      else if (s.icompare(L"RRAS") == 0)
      {
         // launch wrapper exe

         result =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_RRAS_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               IDS_LAUNCH_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_SUCCEEDED);
         break;
      }
      else if (s.icompare(L"AddPrinter") == 0)
      {
         result =
            LaunchPrintWizardExe(
               L"/il /Wr",
               IDS_LAUNCH_PRINTER_WIZARD_FAILED,
               IDS_PRINTER_WIZARD_FAILED,
               IDS_PRINTER_WIZARD_SUCCEEDED);
         break;
      }
      else if (s.icompare(L"AddPrinterDriver") == 0)
      {
         result =
            LaunchPrintWizardExe(
               L"/id /Wr",
               IDS_LAUNCH_PRINTER_DRIVER_WIZARD_FAILED,
               IDS_PRINTER_DRIVER_WIZARD_FAILED,
               IDS_PRINTER_DRIVER_WIZARD_SUCCEEDED);
         break;
      }
      else
      {
         hr = E_INVALIDARG;
         break;
      }
   }
   while (0);

   if (resultText)
   {
      *resultText = ::SysAllocString(result.c_str());
   }

   LOG(resultText ? *resultText : L"(null)");
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\installservice.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of IConfigureYourServer::InstallService
//
// 31 Mar 2000 sburns



#include "headers.hxx"
#include "ConfigureYourServer.hpp"
#include "util.hpp"
#include "SelfAuthorizeDhcp.hpp"
#include "resource.h"



HRESULT
CreateTempFile(const String& name, const String& contents)
{
   LOG_FUNCTION2(createTempFile, name);
   ASSERT(!name.empty());
   ASSERT(!contents.empty());

   HRESULT hr = S_OK;
   HANDLE h = INVALID_HANDLE_VALUE;

   do
   {
      hr =
         FS::CreateFile(
            name,
            h,
            GENERIC_WRITE,
            0, 
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL);
      BREAK_ON_FAILED_HRESULT(hr);

      AnsiString ansi;
      contents.convert(ansi);
      ASSERT(!ansi.empty());

      // write to file with end of file character.

      hr = FS::Write(h, ansi + "\032");
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   Win::CloseHandle(h);

   return hr;
}



BOOL
InstallServiceWithOcManager(
   const String& infText,
   const String& unattendText)
{
   LOG_FUNCTION(SpawnInstaller);
   ASSERT(!unattendText.empty());

   // infText may be empty

   BOOL result = FALSE;
   HRESULT hr = S_OK;

   String sysFolder    = Win::GetSystemDirectory();
   String infPath      = sysFolder + L"\\cysinf.000"; 
   String unattendPath = sysFolder + L"\\cysunat.000";

   // create the inf and unattend files for the oc manager

   do
   {
      if (infText.empty())
      {
         // sysoc.inf is in %windir%\inf

         infPath = Win::GetSystemWindowsDirectory() + L"\\inf\\sysoc.inf";
      }
      else
      {
         hr = CreateTempFile(infPath, infText);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      hr = CreateTempFile(unattendPath, unattendText);
      BREAK_ON_FAILED_HRESULT(hr);

      String commandLine =
         String::format(
            IDS_SYSOC_COMMAND_LINE,
            sysFolder.c_str(),
            infPath.c_str(),
            unattendPath.c_str());

      DWORD exitCode = 0;
      HRESULT hr = ::CreateAndWaitForProcess(commandLine, exitCode);
      BREAK_ON_FAILED_HRESULT(hr);

      // @@ might have to wait for the service to become installed as per
      // service manager

      if (exitCode == ERROR_SUCCESS)
      {
         result = TRUE;
         break;
      }
   }
   while (0);

   LOG(result ? L"TRUE" : L"FALSE");
   LOG_HRESULT(hr);

   return result;
}



HRESULT __stdcall
ConfigureYourServer::InstallService(
   BSTR  bstrService,     
   BSTR  infFileText,     
   BSTR  unattendFileText,
   BOOL* result)           
{
   LOG_FUNCTION2(
      ConfigureYourServer::InstallService,
      bstrService ? bstrService : L"(null)");
   ASSERT(bstrService);
   ASSERT(infFileText);
   ASSERT(unattendFileText);
   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!bstrService || !infFileText || !unattendFileText || !result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = FALSE;
      
      if (!StrCmpIW(bstrService, L"DNS"))
      {
         *result =
            InstallServiceWithOcManager(infFileText, unattendFileText);
         break;
      }

      if (!StrCmpIW(bstrService, L"DHCP"))
      {
         *result =
            InstallServiceWithOcManager(infFileText, unattendFileText);
         break;
      }

      if (!StrCmpIW(bstrService, L"DHCPFirstServer"))
      {
         // Don't need the winlogon notification to do the authorization
         // anymore  see NTRAID#NTBUG9-302361-02/06/2001-sburns 
         // RegisterWLNotifyEvent();

         *result =
            InstallServiceWithOcManager(infFileText, unattendFileText);
         break;
      }

      if (!StrCmpIW(bstrService, L"WINS"))
      {
         *result =
            InstallServiceWithOcManager(infFileText, unattendFileText);
         break;
      }

      if (!StrCmpIW(bstrService, L"IIS"))
      {
         *result =
            InstallServiceWithOcManager(infFileText, unattendFileText);
         break;
      }

      if (!StrCmpIW(bstrService, L"StreamingMedia"))
      {
         *result =
            InstallServiceWithOcManager(infFileText, unattendFileText);
         break;
      }

      if (!StrCmpIW(bstrService, L"TerminalServices"))
      {
         *result =
            InstallServiceWithOcManager(infFileText, unattendFileText);
         break;
      }

      // no option recognized

      hr = E_INVALIDARG;
   }
   while (0);

   LOG(
         result
      ?  (*result ? L"TRUE" : L"FALSE")
      :  L"");
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\dllmain.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// DllMain and COM DllXxx functions
//
// 28 Mar 2000


// To test this app: "mshta.exe res://srvwiz.dll/cys.hta"



#include "headers.hxx"
#include "ConfigureYourServer.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"srvwiz";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;

TCHAR   g_szFileName[MAX_PATH];



struct REG_DATA
{
    const wchar_t *keyName;
    const wchar_t *valueName;
    const wchar_t *value;
};



const REG_DATA g_rgEntries[] =
{
   {
      L"CLSID\\" CLSID_STRING,
      0,
      CLASSNAME_STRING
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      0,
      g_szFileName
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      L"ThreadingModel",
      L"Apartment"
   },
   {
      L"CLSID\\" CLSID_STRING L"\\ProgID",
      0,
      PROGID_VERSION_STRING
   },
   {
      L"CLSID\\" CLSID_STRING L"\\VersionIndependentProgID",
      0,
      PROGID_STRING
   },
   {
      PROGID_VERSION_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING L"\\CurVer",
      0,
      PROGID_VERSION_STRING
   },
};



const int g_cEntries = sizeof(g_rgEntries) / sizeof(*g_rgEntries);



static
HRESULT
Unregister(const REG_DATA *rgEntries, int cEntries)
{
   LOG_FUNCTION(Unregister);

   LOG(L"Calling UnRegisterTypeLib");

   HRESULT hr =
      ::UnRegisterTypeLib(LIBID_ConfigureYourServerLib, 1, 0, 0, SYS_WIN32);

   LOG_HRESULT(hr);

   // don't break: continue on attempting to remove as much as possible
   // of our registration

   bool success = SUCCEEDED(hr);
   for (int i = cEntries - 1; i >= 0; i--)
   {
      LONG err = ::RegDeleteKey(HKEY_CLASSES_ROOT, rgEntries[i].keyName);
      if (err != ERROR_SUCCESS)
      {
         success = false;
      }
   }

   return success ? S_OK : S_FALSE;
}



// unregisters the srvwiz from win2k, if applicable

static
void
UnRegisterPriorSrvWiz()
{
   LOG_FUNCTION(UnRegisterPriorSrvWiz);

   static const GUID LIBID_OldSrvWiz = 
   {  /* D857B805-5F40-11D2-B002-00C04FC30936 */
      0xD857B805,
      0x5F40,
      0x11D2,
      {0xB0, 0x02, 0x00, 0xC0, 0x4F, 0xC3, 0x09, 0x36}
   };

   LOG(L"UnRegisterTypeLib");

   HRESULT hr = ::UnRegisterTypeLib(LIBID_OldSrvWiz, 1, 0, 0, SYS_WIN32);

   LOG_HRESULT(hr);

   // the list of subkeys of HKCR to delete

   static const String keys[] =
   {
      L"CLSID\\{D857B813-5F40-11D2-B002-00C04FC30936}",
      L"Interface\\{D857B811-5F40-11D2-B002-00C04FC30936}",
      L"SrvWiz.SrvWiz",
      L"SrvWiz.SrvWiz.1"
   };

   for (int i = 0; i < (sizeof(keys) / sizeof(String)); ++i)
   {
      LOG(keys[i]);

      hr = Win32ToHresult(::SHDeleteKey(HKEY_CLASSES_ROOT, keys[i].c_str()));

      LOG_HRESULT(hr);
   }
}



static
HRESULT
Register(const REG_DATA *rgEntries, int cEntries)
{

   BOOL bSuccess = TRUE;
   HRESULT hr = S_OK;   // 447822 prefix warning
   const REG_DATA *pEntry = rgEntries;

   UnRegisterPriorSrvWiz();

    while (pEntry < rgEntries + cEntries)
    {
        HKEY hkey;
        LONG err = RegCreateKey(HKEY_CLASSES_ROOT,
                                pEntry->keyName,
                               &hkey);
        if (err == ERROR_SUCCESS)
        {
            if (pEntry->value)
                err = RegSetValueEx(hkey, 
                                pEntry->valueName,
                                0, REG_SZ, 
                                (const BYTE*)pEntry->value,
                                (lstrlen(pEntry->value) + 1) * sizeof(TCHAR));
            if (err != ERROR_SUCCESS)
            {
                bSuccess = FALSE;
                Unregister(rgEntries, static_cast<int>(1 + pEntry - rgEntries));
            }
            RegCloseKey(hkey);
        }
        if (err != ERROR_SUCCESS)
        {
            bSuccess = FALSE;
            if (pEntry != rgEntries)
                Unregister(rgEntries, static_cast<int>(pEntry - rgEntries));
        }
        pEntry++;
    };

   if (bSuccess)
	{
      OLECHAR g_wszFileName[MAX_PATH];      
      lstrcpy(g_wszFileName, g_szFileName);     
		ITypeLib *ptl = 0;
		hr = LoadTypeLib(g_wszFileName, &ptl);
		if (SUCCEEDED(hr))
		{
			hr = RegisterTypeLib(ptl, g_wszFileName, 0);
			ptl->Release();
		}

		if (bSuccess)
			hr = S_OK;
		else
			hr = E_FAIL;
	}

    return hr ;//bSuccess ? S_OK : E_FAIL;
}



BOOL
APIENTRY
DllMain(HINSTANCE h, DWORD dwReason, void *)
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = h;

         LOG(L"DLL_PROCESS_ATTACH");

// @@ remove this 
        GetModuleFileName(h, g_szFileName, MAX_PATH);
         ::DisableThreadLibraryCalls(h);


         break;
      }
      case DLL_PROCESS_DETACH:
      {

#ifdef DBG
         LOG(TEXT("DLL_PROCESS_DETACH"));
         if (!ComServerLockState::CanUnloadNow())
         {
            LOG(L"server locks and/or outstanding object instances exit");
         }
         else
         {
            LOG(L"server can unload now.");
         }
#endif

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         // we should never get here

         ASSERT(false);
         break;
      }
   }

   return TRUE;
}



STDAPI
DllRegisterServer()
{
   LOG_FUNCTION(DllRegisterServer);

   // first, attempt to unregister the old srvwiz CLSID and typelib

   // next, register the new CLSID and typelib

   return Register(g_rgEntries, g_cEntries);
}



STDAPI
DllUnregisterServer()
{
   LOG_FUNCTION(DllUnregisterServer);

   return Unregister(g_rgEntries, g_cEntries);
}



STDAPI
DllCanUnloadNow()
{
   LOG_FUNCTION(DllCanUnloadNow);

   if (ComServerLockState::CanUnloadNow())
   {
      return S_OK;
   }

   return S_FALSE;
}



STDAPI
DllGetClassObject(
   const CLSID&   classID,
   const IID&     interfaceID,
   void**         interfaceDesired)
{
   LOG_FUNCTION(DllGetClassObject);

   IClassFactory* factory = 0;

   // The class objects are instances of ClassFactory<>, which are ref-counted
   // in the usual fashion (i.e. they track their ref counts, and
   // self-destruct on final Release).  I could have used static instances of
   // a C++ class that ignored the refcounting (ala Don Box's examples in
   // Essential COM)

   if (classID == CLSID_ConfigureYourServer)
   {
      factory = new ClassFactory<ConfigureYourServer>;
   }
   else
   {
      *interfaceDesired = 0;
      return CLASS_E_CLASSNOTAVAILABLE;
   }

   // the class factory instance starts with a ref count of 1.  If the QI
   // fails, then it self-destructs upon Release.
   HRESULT hr = factory->QueryInterface(interfaceID, interfaceDesired);
   factory->Release();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\ipconfiguration.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of IConfigureYourServer::SetStaticIpAddressAndSubnetMask
//
// 27 Mar 2000 sburns



#include "headers.hxx"
#include "ConfigureYourServer.hpp"
#include "util.hpp"



// get guid name of the first tcp/ip interface we enum

HRESULT
GetTcpIpInterfaceGuidName(String& result)
{
   LOG_FUNCTION(GetTcpIpInterfaceGuidName);

   result.erase();

   GUID guid;
   DWORD dwError;
   TCHAR szGuid[128];
   ULONG ulSize = 0;
   PIP_INTERFACE_INFO pInfo = NULL;

   while ( 1 )
   {
      dwError = ::GetInterfaceInfo( pInfo, &ulSize );
      if ( ERROR_INSUFFICIENT_BUFFER != dwError )
      {
         break;
      }

      if ( NULL != pInfo )
      {
         Win::LocalFree(pInfo);
      }
      if ( 0 == ulSize )
      {
         return E_FAIL;
      }

      pInfo = (PIP_INTERFACE_INFO) ::LocalAlloc(LPTR, ulSize);
      if ( NULL == pInfo )
      {
         return E_OUTOFMEMORY;
      }
   }

   if ( ERROR_SUCCESS != dwError || 0 == pInfo->NumAdapters )
   {
      if ( NULL != pInfo )
      {
         Win::LocalFree(pInfo);
      }
      return E_FAIL;
   }

   
   // Skip the adapter prefix

   result = pInfo->Adapter[0].Name + strlen("\\Device\\Tcpip_"),

// CODEWORK could do this with IIDFromString
// // //    // check whether this is a valid GUID
// // // 
// // //    SHUnicodeToTChar(wszGuidName, szGuid, ARRAYSIZE(szGuid));
// // //    if (!GUIDFromString(szGuid, &guid))
// // //    {
// // //       // we failed to get a valid tcp/ip interface
// // //       *wszGuidName = 0;
// // //       Win::LocalFree(pInfo);
// // //       return E_FAIL;
// // //    }

   LocalFree(pInfo);

   LOG(result);

   return S_OK;
}



// get friendly name of the first tcp/ip interface we enum

String
GetTcpIpInterfaceFriendlyName()
{
   LOG_FUNCTION(GetTcpIpInterfaceFriendlyName);

   DWORD dwRet;
   HANDLE hMprConfig;
   wchar_t wszFriendlyName[128];

   String result;

   String guidName;    
   HRESULT hr = GetTcpIpInterfaceGuidName(guidName);
   if (SUCCEEDED(hr))
   {
      dwRet = MprConfigServerConnect(0, &hMprConfig);
      if (NO_ERROR == dwRet)
      {
         dwRet =
            MprConfigGetFriendlyName(
               hMprConfig,
               const_cast<wchar_t*>(guidName.c_str()), 
               wszFriendlyName,
               sizeof(wchar_t) * 128);
         if (NO_ERROR != dwRet)
         {
            *wszFriendlyName = 0;
         }
      }
      MprConfigServerDisconnect(hMprConfig);
   }

   if (!*wszFriendlyName)
   {
      // we failed to get a friendly name, so use the default one
      // BUGBUG does this need to be localized?

      result = L"Local Area Connection";
   }
   else
   {
      result = wszFriendlyName;
   }

   LOG(result);

   return result;
}



HRESULT __stdcall
ConfigureYourServer::SetStaticIpAddressAndSubnetMask(
   /* [in] */           BSTR  staticIp,
   /* [in] */           BSTR  subnetMask,
   /* [out, retval] */  BOOL* success)
{
   HRESULT hr = S_OK;

   do
   {
      if (
            !staticIp
         || !subnetMask
         || !success)
      {
         hr = E_INVALIDARG;
         break;
      }

      *success = FALSE;

      // invoke netsh and wait for it to terminate

      String friendlyName = GetTcpIpInterfaceFriendlyName();

      // set static IP address and subnet mask

      String commandLine =
         String::format(
            L"netsh interface ip set address "
            L"name=\"%1\" source=static addr=%2 mask=%3 gateway=none",
            friendlyName.c_str(),
            staticIp,
            subnetMask);

      DWORD exitCode1 = 0;
      hr = ::CreateAndWaitForProcess(commandLine, exitCode1);
      if (FAILED(hr))
      {
         break;
      }
         
      ASSERT(SUCCEEDED(hr));

      // set DNS server address to same address as local machine.  netsh
      // does not allow the dns server address to be the loopback address.

      commandLine =
         String::format(
            L"netsh interface ip set dns name=\"%1\" source=static addr=%2",
            friendlyName.c_str(),
            staticIp);

      DWORD exitCode2 = 0;
      hr = ::CreateAndWaitForProcess(commandLine, exitCode2);
      if (FAILED(hr))
      {
         break;
      }

      if (!exitCode1 and !exitCode2)
      {
         *success = TRUE;
      }
   }
   while (0);

   LOG(
         success
      ?  (*success ? L"TRUE" : L"FALSE")
      :  L"");
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\isdhcp.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    isdhcp.c

Abstract:

    test program to see if a DHCP server is around or not.

Environment:

    Win2K+

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dhcpcapi.h>
#include <iprtrmib.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <winsock2.h>

BOOL
IsDhcpServerAround(
    VOID
    )
/*++

Routine Description:

    This routine attempts to check if a dhcp
    server is around by trying to get a dhcp lease.

    If that fails, then it assume that no dhcp server
    is around.

Return Values:

    TRUE -- DHCP server is around
    FALSE -- DHCP server not around

In case of internal failures, it will return FALSE

--*/
{
    PMIB_IPADDRTABLE IpTable;
    DWORD Size, Error, i;
    DHCP_CLIENT_UID DhcpClientUID = {
        "ISDHCP", 6
    };
    DHCP_OPTION_LIST DummyOptList;
    LPDHCP_LEASE_INFO LeaseInfo;
    LPDHCP_OPTION_INFO DummyOptionInfo;
    BOOL fFound;
    
    Size = 0; IpTable = NULL;
    do {

        if( IpTable ) {
            LocalFree(IpTable);
            IpTable = NULL;
        }
        
        if( Size ) {
            IpTable = LocalAlloc( LPTR, Size );
            if( NULL == IpTable ) {
                Error = GetLastError();
                break;
            }
        }
        
        Error = GetIpAddrTable( IpTable, &Size, FALSE );
    } while( ERROR_INSUFFICIENT_BUFFER == Error );

    if( NO_ERROR != Error ) {
#ifdef DBG      
        DbgPrint("ISDHCP: GetIpAddrTable: 0x%lx\n", Error);
#endif
        return FALSE;
    }

    //
    // Now walk through the ip addr table trying to obtain
    // a lease off of it
    //

#ifdef DBG
    DbgPrint("ISDHCP: IpTable has 0x%lx entries\n", IpTable->dwNumEntries );
#endif

    fFound = FALSE;
    for( i = 0; i < IpTable->dwNumEntries ; i ++ ) {
        DWORD Addr = IpTable->table[i].dwAddr;
        
#ifdef DBG
        DbgPrint("ISDHCP: Verifying for IP address: 0x%lx\n", Addr );
#endif
        
        if( Addr == INADDR_ANY ||
            Addr == INADDR_LOOPBACK ||
            Addr == 0x0100007f
            ) {
            //
            // oops.  not a usable address
            //
            continue;
        }

        LeaseInfo = NULL;
        Error = DhcpLeaseIpAddress(
            RtlUlongByteSwap(Addr), &DhcpClientUID, 0, &DummyOptList, 
            &LeaseInfo, &DummyOptionInfo
            );

        if( NO_ERROR != Error ) {
            //
            // lease request failed.
            //

#ifdef DBG
            DbgPrint("ISDHCP: lease request failed 0x%lx\n", Error);
#endif
            if( ERROR_ACCESS_DENIED == Error ) {
                //
                // We only get access denied if the dhcp server
                // is around to NAK it. So we have found a dhcp
                // server
                //
                fFound = TRUE;
                break;
            }
            
            continue;
        }

        if( LeaseInfo->DhcpServerAddress != INADDR_ANY &&
            LeaseInfo->DhcpServerAddress != INADDR_NONE ) {
            //
            // Valid address, so dhcp is there.
            //

#ifdef DBG
            DbgPrint("ISDHCP: DHCP server found: 0x%lx\n", LeaseInfo->DhcpServerAddress);
#endif
            DhcpReleaseIpAddressLease(
                RtlUlongByteSwap(Addr), LeaseInfo
                );

            fFound = TRUE;
            break;
        }
    }

    LocalFree( IpTable);
    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDI_MAIN                                1000
#define IDS_PRINTER_WIZARD_FAILED               1001
#define IDS_PRINTER_WIZARD_SUCCEEDED            1002
#define IDS_PRINTER_DRIVER_WIZARD_FAILED        1003
#define IDS_PRINTER_DRIVER_WIZARD_SUCCEEDED     1004
#define IDS_LAUNCH_PRINTER_WIZARD_FAILED        1005
#define IDS_LAUNCH_PRINTER_DRIVER_WIZARD_FAILED 1006
#define IDS_SYSOC_COMMAND_LINE                  1008
#define IDS_LAUNCH_DHCP_WIZARD_COMMAND_LINE     1009
#define IDS_LAUNCH_DHCP_WIZARD_FAILED           1010
#define IDS_DHCP_WIZARD_FAILED                  1011
#define IDS_DHCP_WIZARD_SUCCEEDED               1012
#define IDS_LAUNCH_DNS_WIZARD_COMMAND_LINE      1016
#define IDS_LAUNCH_DNS_WIZARD_FAILED            1017
#define IDS_DNS_WIZARD_FAILED                   1018
#define IDS_DNS_WIZARD_SUCCEEDED                1019
#define IDS_LAUNCH_RRAS_WIZARD_COMMAND_LINE     1020
#define IDS_LAUNCH_RRAS_WIZARD_FAILED           1021
#define IDS_RRAS_WIZARD_FAILED                  1022
#define IDS_RRAS_WIZARD_SUCCEEDED               1023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\isdhcpconfigured.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of IConfigureYourServer::IsDhcpConfigured
//
// 20 Apr 2000 sburns



#include "headers.hxx"
#include "ConfigureYourServer.hpp"


// make sure the DLLs for all these APIs are present with base install.
// if not, then need to wrap usage in load-lib calls
// 
// DhcpLeaseIpAddress        DHCPCSVC    ok
// DhcpReleaseIpAddressLease DHCPCSVC    ok
// DhcpDsInitDS              DSAUTH      ok
// DhcpAddServerDS           DSAUTH      ok
// DhcpDsCleanupDS           DSAUTH      ok
// DhcpGetAllOptions         DHCPSAPI    ok
// DhcpRpcFreeMemory         DHCPSAPI    ok
// DhcpEnumSubnets           DHCPSAPI    ok
// DhcpEnumMscopes           DHCPSAPI    ok



String
GetIpAddress()
{
   LOG_FUNCTION(GetIpAddress);

   String result;

   HRESULT hr = S_OK;
   BYTE* buf = 0;
   do
   {
      // first, determine the size of the table

      ULONG tableSize = 0;
      DWORD err = ::GetIpAddrTable(0, &tableSize, FALSE);
      if (err != ERROR_INSUFFICIENT_BUFFER)
      {
         LOG(L"GetIpAddrTable for table size failed");
         LOG_HRESULT(Win32ToHresult(err));
         break;
      }

      // allocate space for the table.

      buf = new BYTE[tableSize + 1];
      memset(buf, 0, tableSize + 1);
      PMIB_IPADDRTABLE table = reinterpret_cast<PMIB_IPADDRTABLE>(buf);

      LOG(L"Calling GetIpAddrTable");

      hr =
         Win32ToHresult(
            ::GetIpAddrTable(
               table,
               &tableSize,
               FALSE));
      BREAK_ON_FAILED_HRESULT2(hr, L"GetIpAddrTable failed");

      LOG(String::format(L"dwNumEntries: %1!d!", table->dwNumEntries));

      for (int i = 0; i < table->dwNumEntries; ++i)
      {
         DWORD addr = table->table[i].dwAddr;
         LOG(String::format(L"entry %1!d!", i));
         LOG(String::format(
            L"dwAddr %1!X! (%2!d!.%3!d!.%4!d!.%5!d!)",
            addr,
				((BYTE*)&addr)[0],
				((BYTE*)&addr)[1],
				((BYTE*)&addr)[2],
				((BYTE*)&addr)[3]));

         // skip loopback, etc.

         if (
               INADDR_ANY        == addr
            || INADDR_BROADCAST  == addr
            || INADDR_LOOPBACK   == addr
            || 0x0100007f        == addr )
         {
            LOG(L"is loopback/broadcast -- skipping");

            continue;
         }

         // Exclude MCAST addresses (class D).

         if (
               IN_CLASSA(htonl(addr))
            || IN_CLASSB(htonl(addr))
            || IN_CLASSC(htonl(addr)) )
         {
            LOG(L"is class A/B/C");

            result = 
               String::format(
                  L"%1!d!.%2!d!.%3!d!.%4!d!",
				      ((BYTE*)&addr)[0],
				      ((BYTE*)&addr)[1],
				      ((BYTE*)&addr)[2],
				      ((BYTE*)&addr)[3]);

            break;
         }

         LOG(L"not class A/B/C -- skipping");
      }
   }
   while (0);

   delete[] buf;

   LOG(result);
   LOG_HRESULT(hr);

   return result;
}



bool
AreDhcpOptionsPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpOptionsPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_ALL_OPTIONS options = 0;
   do
   {
      DWORD err =
         ::DhcpGetAllOptions(
            const_cast<wchar_t*>(ipAddress.c_str()),
            0,
            &options);

      if (err != ERROR_SUCCESS)
      {
         LOG(String::format(L"DhcpGetAllOptions failed with 0x%1!08X!", err));
         break;
      }

      if (options)
      {
         // options are set, so some dhcp configuration was done.

         result = true;
         break;
      }
   }
   while (0);

   if (options)
   {
      ::DhcpRpcFreeMemory(options);
   }

   LOG(result ? L"true" : L"false");

   return result;
}



bool
AreDhcpSubnetsPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpSubnetsPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_IP_ARRAY subnets = 0;
   do
   {
      DHCP_RESUME_HANDLE resume    = 0;
      DWORD              unused1   = 0;
      DWORD              unused2   = 0;
      DWORD err =
         ::DhcpEnumSubnets(
            ipAddress.c_str(),
            &resume,
            ~0,
            &subnets,
            &unused1,
            &unused2);

      if (err == ERROR_NO_MORE_ITEMS)
      {
         // no subnets.

         break;
      }

      if (err != NO_ERROR and err != ERROR_MORE_DATA)
      {
         LOG(String::format(L"DhcpEnumSubnets failed with 0x%1!08X!", err));
         break;
      }

      ASSERT(subnets);

      result = true;

      // the resume handle is simply discarded...
   }
   while (0);

   if (subnets)
   {
      ::DhcpRpcFreeMemory(subnets);
   }

   LOG(result ? L"true" : L"false");

   return result;
}



bool
AreDhcpMscopesPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpMscopesPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_MSCOPE_TABLE mscopes = 0;
   do
   {
      DHCP_RESUME_HANDLE resume    = 0;
      DWORD              unused1   = 0;
      DWORD              unused2   = 0;
      DWORD err =
         ::DhcpEnumMScopes(
            ipAddress.c_str(),
            &resume,
            ~0,
            &mscopes,
            &unused1,
            &unused2);

      if (err == ERROR_NO_MORE_ITEMS)
      {
         // no mscopes.

         break;
      }

      if (err != NO_ERROR and err != ERROR_MORE_DATA)
      {
         LOG(String::format(L"DhcpEnumMscopes failed with 0x%1!08X!", err));
         break;
      }

      ASSERT(mscopes);

      result = true;

      // the resume handle is simply discarded...
   }
   while (0);

   if (mscopes)
   {
      ::DhcpRpcFreeMemory(mscopes);
   }

   LOG(result ? L"true" : L"false");

   return result;
}



HRESULT __stdcall
ConfigureYourServer::IsDhcpConfigured(
   /* [out, retval] */  BOOL* retval)
{
   LOG_FUNCTION(ConfigureYourServer::IsDhcpConfigured);
   ASSERT(retval);

   HRESULT hr = S_OK;

   do
   {
      if (!retval)
      {
         hr = E_INVALIDARG;
         break;
      }

      *retval = FALSE;

      // if any of the following return any results, then we consider dhcp to
      // have been configured.
      //    
      // DhcpGetAllOptions retrieves the options configured.
      // DhcpEnumSubnets retrieves the list of subnets configured.
      // DhcpEnumMscopes retrieves the list of mscopes configured.

      String ipAddress = GetIpAddress();
      if (ipAddress.empty())
      {
         LOG(L"no ip address");
         break;
      }

      if (AreDhcpOptionsPresent(ipAddress))
      {
         LOG(L"dchp options found");

         *retval = TRUE;
         break;
      }

      // no options found.  go on to next test

      if (AreDhcpSubnetsPresent(ipAddress))
      {
         LOG(L"dchp subnets found");

         *retval = TRUE;
         break;
      }

      // no subnets found.  go on.

      if (AreDhcpMscopesPresent(ipAddress))
      {
         LOG(L"dchp mscopes found");

         *retval = TRUE;
         break;
      }
   }
   while (0);

   LOG(retval ? (*retval ? L"TRUE" : L"FALSE") : L"");
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\isserviceinstalled.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of IConfigureYourServer::IsServiceInstalled
//
// 27 Mar 2000 sburns



#include "headers.hxx"
#include "ConfigureYourServer.hpp"


// CODEWORK: could these be made const wchar_t*?

#define REGKEY_MSMQ     L"SOFTWARE\\Microsoft\\MSMQ\\Parameters"                       
#define REGKEY_RRAS     L"System\\CurrentControlSet\\Services\\RemoteAccess"           
#define REGKEY_NETSHOW  L"SOFTWARE\\Microsoft\\NetShow"                                



bool
IsServiceInstalledHelper(const wchar_t* serviceName)
{
   LOG_FUNCTION2(IsServiceInstalledHelper, serviceName);
   ASSERT(serviceName);

   // if we can open the service, then it is installed

   bool result = false;

   SC_HANDLE hsc =
      ::OpenSCManager(0, SERVICES_ACTIVE_DATABASE, GENERIC_READ);

   if (hsc)
   {
      SC_HANDLE hs = ::OpenServiceW(hsc, serviceName, GENERIC_READ);

      if (hs)
      {
         ::CloseServiceHandle(hs);
         result = true;
      }

      ::CloseServiceHandle(hsc);
   }

   return result;
}



// For most services:
//     return -1 if the service should not be installed, 
//     return 0 if not installed, 
//     return 1 if installed

HRESULT __stdcall
ConfigureYourServer::IsServiceInstalled(BSTR bstrService, int* state)
{
   LOG_FUNCTION2(ConfigureYourServer::IsServiceInstalled, bstrService);
   ASSERT(bstrService);
   ASSERT(state);

   HRESULT hr = S_OK;

   do
   {
      if (!bstrService || !state)
      {
         hr = E_INVALIDARG;
         break;
      }

      *state = 0;

      if (!StrCmpIW(bstrService, L"DNS"))
      {
         *state = IsServiceInstalledHelper(L"DNS") ? 1 : 0;

         break;
      }

      if (!StrCmpIW(bstrService, L"DHCP"))
      {
         *state = IsServiceInstalledHelper(L"DHCPServer") ? 1 : 0;

         break;
      }

      if (!StrCmpIW(bstrService, L"RRAS"))
      {
         // Routing & Remote Access

         // If HKLM\System\CurrentControlSet\Services\RemoteAccess,
         // ConfigurationFlags(REG_DWORD) == 1, then Ras and Routing is
         // configured.
         // 
         // RRAS is always installed.

         DWORD dwRet;
         DWORD dwCfgFlags;
         DWORD cbSize = sizeof(dwCfgFlags);

         dwRet =
            ::SHGetValue(
               HKEY_LOCAL_MACHINE,
               REGKEY_RRAS,
               L"ConfigurationFlags", 
               NULL,
               (LPVOID) &dwCfgFlags,
               &cbSize);

         if ((NO_ERROR == dwRet) && (1 == dwCfgFlags))
         {
            *state = 1;
         }

         break;
      }

      if (!StrCmpIW(bstrService, L"WINS"))
      {
         *state = IsServiceInstalledHelper(L"WINS") ? 1 : 0;
         break;
      }

      if (!StrCmpIW(bstrService, L"IIS"))
      {
         *state = IsServiceInstalledHelper(L"IISADMIN") ? 1 : 0;

         break;
      }

      if (!StrCmpIW(bstrService, L"StreamingMedia"))
      {
         // If we can find nsadmin.exe, we assume netshow is installed

         DWORD dwRet;
         TCHAR szPath[MAX_PATH];
         DWORD cbSize = sizeof(szPath);

         dwRet =
            ::SHGetValue(
               HKEY_LOCAL_MACHINE,
               REGKEY_NETSHOW,
               L"InstallDir", 
               NULL,
               (LPVOID)szPath,
               &cbSize);

         if ((NO_ERROR == dwRet) && *szPath)
         {
            if (
                  PathAppend(szPath, L"Server\\nsadmin.exe")
               && PathFileExists(szPath) )
            {
               *state = 1;
            }
         }

         break;
      }

      if (!StrCmpIW(bstrService, L"MessageQueue"))
      {

         // If reg value HKLM\Software\Microsoft\MSMQ\Parameters,MaxSysQueue
         // exists, we assume Message Queue is installed.

         DWORD dwRet;
         DWORD dwMaxSysQueue;
         DWORD cbSize = sizeof(dwMaxSysQueue);

         dwRet =
            ::SHGetValue(
               HKEY_LOCAL_MACHINE,
               REGKEY_MSMQ,
               L"MaxSysQueue", 
               NULL,
               (LPVOID) &dwMaxSysQueue,
               &cbSize);

         if (NO_ERROR == dwRet)
         {
            *state = 1;
         }

         break;
      }

      // At this point, the caller has asked for some service we don't
      // recognize

      hr = E_INVALIDARG;
   }
   while (0);

   LOG_HRESULT(hr);
   LOG(String::format(L"state = %1!d!", *state));

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\selfauthorizedhcp.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// DHCP Self-authorization
//
// 27 Mar 2000 sburns



#ifndef DHCPSELF_HPP_INCLUDED
#define DHCPSELF_HPP_INCLUDED



void
RegisterWLNotifyEvent();



#endif   // DHCPSELF_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\setcomerror.hpp ===
// Copyright (C) 1999-2000 Microsoft Corporation
//
// SetComError routines
//
// sburns 5-3-99



void
SetComError(
   const String&  desciption,
   DWORD          helpContext = 0);



void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext = 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\setcomerror.cpp ===
// Copyright (C) 1999-2000 Microsoft Corporation
//
// SetComError routines
//
// sburns 5-3-99



#include "headers.hxx"
#include "common.hpp"



void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext)
{
   SetComError(String::load(descriptionMessageResID), helpContext);
}



void
SetComError(
   const String&  description,
   DWORD          helpContext)
{
   LOG_FUNCTION2(SetComError, description);

   ICreateErrorInfo* cei = 0;
   HRESULT hr = S_OK;

   do
   {
      hr = ::CreateErrorInfo(&cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetGUID(IID_IConfigureYourServer);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetSource(PROGID_VERSION_STRING);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         cei->SetDescription(
            const_cast<String::value_type*>(description.c_str()));
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpFile(L"" /* HELPFILE_NAME */ );
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpContext(helpContext);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IErrorInfo> ei;
      hr = ei.AcquireViaQueryInterface(*cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ::SetErrorInfo(0, ei);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (cei)
   {
      cei->Release();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\selfauthorizedhcp.cpp ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:
    dhcpself.c

Abstract:
    program to authorize self as enabled dhcp server to run on DCs alone.

Environment:
    Win2K NT DCs alone.

Specification:
    \\popcorn\razzle1\src\spec\networks\transports\dhcp\dhcpself.doc

--*/


#include "headers.hxx"

extern "C"
{
#include <dhcpssdk.h>
#include <dhcpds.h>
}


#define REGSTR_PATH_WLNOTIFY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify")

//=============================================================================
//
// Getting user name and domain name of caller.
//
//=============================================================================

ULONG
GetUserAndDomainNames(
    IN OUT WCHAR *UnameBuf,
    IN OUT PULONG UnameBufLen,
    IN OUT WCHAR *DomainBuf,
    IN OUT PULONG DomainBufLen
    )
/*++

Routine Description:
    This routine finds the user and domain
    name for the caller.  If the caller is
    impersonated, the user and domain name
    are the impersonated callers user and domain names.

Arguments:
    UnameBuf - buffer to hold user name.
    UnameBufLen - length of above buffer in wchars
    DomainBuf -- buffer to hold domain name.
    DomainBufLen -- length of above buffer in whcars

Return Values:
    Win32 errors.

    N.B The user name domain name buffers are passed to
    LookupAccountSid which can fail with ERROR_MORE_DATA or
    other errors if the buffers are of insufficient size.
    LookupAccountSid won't fail for lack of space if
    both buffers are atleast 256 WCHARs long.

--*/
{
   LOG_FUNCTION(GetUserAndDomainNames);

    HANDLE Token;
    TOKEN_USER *pTokenUser;
    ULONG Error, Len;
    PSID pSid;
    SID_NAME_USE eUse;

    //
    // Get process token.
    //

    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &Token)) {
        return GetLastError();
    }

    //
    // Query for user info.
    //

    do {
        Len = 0;
        GetTokenInformation(Token, TokenUser, NULL, 0, &Len);
        if( 0 == Len ) {
            Error = GetLastError();
            break;
        }

        pTokenUser = (TOKEN_USER *)LocalAlloc(LPTR, Len);
        if( NULL == pTokenUser ) {
            Error = GetLastError();
            break;
        }

        if(!GetTokenInformation(
            Token, TokenUser, pTokenUser, Len, &Len
            )){
            Error = GetLastError();
            break;
        }

        pSid = pTokenUser->User.Sid;

        Error = NO_ERROR;
        if(!LookupAccountSid(
            NULL, pSid, UnameBuf, UnameBufLen, DomainBuf, DomainBufLen, &eUse
            )) {
            Error = GetLastError();
        }

        LocalFree(pTokenUser);
    } while ( 0 );

    CloseHandle(Token);
    return Error;
}

ULONG
GetUserAndDomainName(
    IN WCHAR Buf[]
    )
/*++

Routine Description:
    This routine finds the caller's user and domain, and if
    the caller is impersonated a client, this gives the
    client's user and domain name.

    If the domain exists, the format is domain\username
    Otherwise it is just "username".

Return Values:
    Win32 errors..

--*/
{
   LOG_FUNCTION(GetUserAndDomainName);

    WCHAR UName[UNLEN+1];
    WCHAR DName[DNLEN+1];
    ULONG USize = UNLEN+1, DSize = DNLEN+1;
    ULONG Error;

    Buf[0] = L'\0';
    Error = GetUserAndDomainNames(UName, &USize, DName, &DSize);
    if( ERROR_SUCCESS != Error ) return Error;

    wcscpy(Buf, DName);
    if( DSize ) Buf[DSize++] = L'\\';
    wcscpy(&Buf[DSize], UName);
    return NO_ERROR;
}

//==============================================================================
//
// Getting the current machine's IP address or Domain name.
//
//==============================================================================

DWORD
GetIpAddressAndMachineDnsName(
    OUT ULONG *IpAddress,
    OUT TCHAR DnsNameBuf[],
    IN ULONG DnsNameBufSize
    )
/*++

Routine Description:
    This routine obtains a non-zero IP address for the machine
    as well as the machine's FQDN host name.

Arguments:
    IpAddress -- pointer to a location to hold the machine's
       IP address.
    DnsNameBuf -- buffer to hold the machine's dns FQDN name.
    DnsNameBufSize -- size of the above in TCHARs.

Return Values:
    NO_ERROR on success and Win32 errors..

--*/
{
   LOG_FUNCTION(GetIpAddressAndMachineDnsName);

    ULONG Error, Size, i;
    DWORD *LocalAddresses;
    PMIB_IPADDRTABLE IpAddrTable;

    //
    // First get the IP address via iphlpapi.
    //
    Size = 0;
    Error = GetIpAddrTable(NULL, &Size, FALSE);
    if( ERROR_INSUFFICIENT_BUFFER != Error ) {
        if( NO_ERROR == Error ) {
            return ERROR_DEV_NOT_EXIST;
        }
        return Error;
    }

    if( 0 == Size ) return ERROR_DEV_NOT_EXIST;

    //
    // Now allocate space for table.
    //
    IpAddrTable = (PMIB_IPADDRTABLE)LocalAlloc(LMEM_FIXED, Size);
    if( NULL == IpAddrTable ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now attempt to get the IP addr table again.
    //
    Error = GetIpAddrTable(IpAddrTable, &Size, FALSE);
    if( NO_ERROR != Error ) {
        LocalFree(IpAddrTable);
        return Error;
    }

    //
    // Now walk through the IP address table to find
    // one IP address that is not 0, -1, or loopback.
    //
    *IpAddress = 0;
    for( i = 0; i < IpAddrTable->dwNumEntries; i ++ ) {
        if( INADDR_ANY == IpAddrTable->table[i].dwAddr
            || INADDR_BROADCAST == IpAddrTable->table[i].dwAddr
            || INADDR_LOOPBACK == IpAddrTable->table[i].dwAddr
            ) {
            //
            // Not applicable.
            //
            continue;
        }

        //
        // Attempt to exclude MCAST addresses (class D).
        //

        if( IN_CLASSA(IpAddrTable->table[i].dwAddr)
            || IN_CLASSB(IpAddrTable->table[i].dwAddr)
            || IN_CLASSC(IpAddrTable->table[i].dwAddr)
            ) {
            *IpAddress = IpAddrTable->table[i].dwAddr;
            break;
        }
    }

    LocalFree( IpAddrTable );

    if( 0 == *IpAddress ) {
        //
        // Still not found anything of interest.
        //
        return ERROR_DEV_NOT_EXIST;
    }

    //
    // Now find the domain name.
    //

    Error = GetComputerNameEx(
        ComputerNameDnsFullyQualified,
        DnsNameBuf,
        &DnsNameBufSize
        );
    if( FALSE == Error ) {
        Error = GetLastError();
    } else {
        Error =  NO_ERROR;
    }

    return Error;
}

//==============================================================================
//
// Logging routines.
//
//================================================================================

ULONG
CalculateTimeStampSize(
    VOID
    )
/*++

Routine Description:
    This routine gives the size of the buffer
    neeed to log timestamp.

Return Values:
    number of bytes required to store time stamp info.

--*/
{
    return sizeof(("mm/dd/yy, hh:mm:ss "));
}

VOID
TimeStampString(
    IN LPSTR Buf
    )
/*++

Routine Description:
    This routine stamps the given string with the
    current local time.

    The format for the time is:
        mm/dd/yy, hh:mm:ss

    It is assumed that Buf is atleast as long as the
    size returned by CalculateTimeStampSize.

--*/
{
    _strdate(Buf);
    Buf += strlen(Buf);
    *Buf++ = (',');
    *Buf++ = (' ');
    _strtime(Buf);
}

VOID
LogError(
    IN HANDLE hLogFile, OPTIONAL
    IN LPCSTR Description,
    IN ULONG ErrorCode
    )
/*++

Routine Description:
    This routine formats a buffer and time-stamps it and
    then logs it onto the file whose handle is provided in
    hLogFile.  This is done atomically.

    The format used is "%s: %ld (0x%lx)\n".

    N.B.  If hLogFile is NULL, then nothing is done.

Arguments:
    hLogFile -- handle to file to use.
    Description -- description to log.
    ErrorCode -- error to log.

--*/
{
   LOG_FUNCTION(LogError);

    CHAR StaticBuf[400];
    LPSTR String, StrEnd;
    ULONG Size, nBytesWritten;

    //
    // Skip everything if no file opened.
    //
    if( NULL == hLogFile ) return;

    //
    // Calculate size required.
    //
    Size = CalculateTimeStampSize();

    Size += sizeof(" " ": " " (0x)\n");
    Size += strlen(Description)*sizeof(String[0]);
    Size += sizeof(ErrorCode)*2;

    Size += 20; // off by one errors.

    //
    // Have space on stack.
    //
    if( Size < sizeof(StaticBuf) ) {
        String = StaticBuf;
    } else {
        String = (char *)LocalAlloc(LMEM_FIXED, Size);
        if( NULL == String ) {
            String = StaticBuf;
            Description = ("Could not log");
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Now format string.
    //
    TimeStampString(String);
    StrEnd = String + strlen(String);
    *StrEnd ++ = (' ');
    wsprintfA(
        StrEnd, ("%hs: %ld(0x%lx)\n"),
        Description, ErrorCode, ErrorCode
        );

   LOG(StrEnd);

    //
    // Now write to file.
    //
    StrEnd = StrEnd + strlen(StrEnd);

    WriteFile(
        hLogFile, (PVOID)String,
        (int)(StrEnd - String)*sizeof(String[0]),
        &nBytesWritten, NULL
        );
#if DBG
    DbgPrint("DHCPSELF: %s", String);
#endif

    if( String != StaticBuf ) {
        LocalFree(String);
    }
}

VOID
LogString(
    IN HANDLE hLogFile,
    IN LPCSTR Description,
    IN LPTSTR Info OPTIONAL
    )
/*++

Routine Description:
    This routine formats a buffer and time-stamps it and
    then logs it onto the file whose handle is provided in
    hLogFile.  This is done atomically.

    The format used is "%hs: %s\n".

    N.B.  If hLogFile is NULL, then nothing is done.

Arguments:
    hLogFile -- handle to file to use.
    Description -- description to log.
    Info -- additional string to log.

--*/
{
   LOG_FUNCTION(LogString);

    CHAR StaticBuf[400];
    LPSTR String, StrEnd;
    ULONG Size, nBytesWritten;

    //
    // Skip everything if no file opened.
    //
    if( NULL == hLogFile ) return;

    //
    // if Info is null, assume empty string.
    //
    if( NULL == Info ) Info = TEXT("");

    //
    // Calculate size required.
    //
    Size = CalculateTimeStampSize();

    Size += sizeof(" " ": " " \n");
    Size += strlen(Description)*sizeof(String[0]);
    Size += lstrlen(Info)*sizeof(String[0]);

    Size += 20; // off by one errors.

    //
    // Have space on stack.
    //
    if( Size < sizeof(StaticBuf) ) {
        String = StaticBuf;
    } else {
        String = (char *)LocalAlloc(LMEM_FIXED, Size);
        if( NULL == String ) {
            String = StaticBuf;
            Description = ("Could not log");
            Info = TEXT("8 (0x8)");
        }
    }

    //
    // Now format string.
    //
    TimeStampString(String);
    StrEnd = String + strlen(String);
    *StrEnd ++ = (' ');
    wsprintfA(
        StrEnd, ("%hs: %ls\n"),
        Description, Info
        );

   LOG(StrEnd);

    //
    // Now write to file.
    //
    StrEnd = StrEnd + strlen(StrEnd);

    WriteFile(
        hLogFile, (PVOID)String,
        (int)(StrEnd - String)*sizeof(String[0]),
        &nBytesWritten, NULL
        );
#if DBG
    DbgPrint("DHCPSELF: %s", String);
#endif

    if( String != StaticBuf ) {
        LocalFree(String);
    }
}

VOID
LogIpAddress(
    IN HANDLE hLogFile,
    IN LPCSTR Description,
    IN ULONG IpAddress
    )
/*++

Routine Description:
    This routine formats a buffer and time-stamps it and
    then logs it onto the file whose handle is provided in
    hLogFile.  This is done atomically.

    The format used is "description: ip-address\n".

    N.B.  If hLogFile is NULL, then nothing is done.

Arguments:
    hLogFile -- handle to file to use.
    Description -- description to log.
    Info -- additional string to log.

--*/
{
   LOG_FUNCTION(LogIpAddress);

    TCHAR StaticBuf[sizeof("xxx.xxx.xxx.xxx.abcdef")];
    ULONG i;
    LPSTR IpAddrString;

    if( NULL == hLogFile ) return;
    IpAddrString = inet_ntoa(*(struct in_addr*)&IpAddress);

    if( NULL == IpAddrString ) {
        LogString(
            hLogFile,
            ("inet_ntoa failed!"), TEXT("")
            );
        return;
    }

    //
    // Now if we are using unicode set, we have to
    // convert to unicode.  But since IP address is
    // same format on unicode or ascii, we will just
    // do a simple copy.
    //
    i = 0;
    while( *IpAddrString  ) {
        StaticBuf[i++] = (TCHAR)*IpAddrString ++;
    }
    StaticBuf[i] = TEXT('\0');

    //
    // Now just log as strings.
    //
    LogString(
        hLogFile,
        Description,
        StaticBuf
        );
}

DWORD
OpenLogFile(
    OUT HANDLE *hLogFile,
    IN LPCTSTR LogFileName,
    IN BOOL fCreateIfNonExistent
    )
/*++

Routine Description:
    This routine attempts to open a log file with the specified name.
    If fCreateIfNonExistent is TRUE, then the file is created if it doesn't
    already exist, otherwise the file is opened only if it already exists.
    If the file already exists, then the file ptr is moved to the end and
    a log is made to indicate that it was opened (with a time stamp).

    Also, if fCreateIfNonExistent is FALSE and the file does not exist,
    then the routine returns successfully with hLogFile set to NULL.

Arguments:
    hLogFile -- output pointer that will hold file handle to log file.
    LogFileName -- name of file to open with.
    fCreateIfNonExistent -- if file doesn't exist and if this is true,
        file will be created.

Return Values:
    Win32 errors.

--*/
{
   LOG_FUNCTION(OpenLogFile);

    ULONG Error, Flags;

    Flags = OPEN_EXISTING;
    if( fCreateIfNonExistent ) Flags = OPEN_ALWAYS;

    //
    // Attempt to create file or open.
    //

    (*hLogFile) = CreateFile(
        LogFileName, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, Flags,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL
        );
    if( INVALID_HANDLE_VALUE == (*hLogFile) ) {

        //
        // Ignore error if FALSE == fCreateIfNonExistent
        // and file or path didn't actually exist.
        //

        (*hLogFile) = NULL;
        Error = GetLastError();
        if( fCreateIfNonExistent ) return Error;

        if( ERROR_FILE_NOT_FOUND == Error ||
            ERROR_PATH_NOT_FOUND == Error ) {
            return NO_ERROR;
        }
        return Error;
    }

    //
    // Opened handle. Go to end of file.
    //
    SetFilePointer((*hLogFile), 0, NULL, FILE_END);

    //
    // Log standard header.
    //
    LogString( (*hLogFile), ("Log started"), TEXT(""));

    return NO_ERROR;
}

VOID
CloseLogFile(
    IN HANDLE hLogFile
    )
{
   LOG_FUNCTION(CloseLogFile);

    if( NULL != hLogFile ) CloseHandle(hLogFile);
}

//==============================================================================
//
// Routines to monitor if the DS has started.
//
//==============================================================================

#define SCQUERYATTEMPTS 240
#define SLEEPTIME (15*1000)

ULONG
WaitForServiceToStart(
    IN LPCTSTR ServiceShortName,
    IN LPCTSTR ServiceLongName OPTIONAL
    )
/*++

Routine Description:
    This routine sleeps for SLEEPTIME milliseconds between
    attempts to check if the required service is up and running
    (this is done by querying the service controller and then
    checking if the service state is RUNNING).  This process
    is attempted SCQUERYATTEMPTS times.

    If repeated attempts failed, then this returns
    ERROR_TIMEOUT.

Arguments:
    ServiceShortName -- short name for the service.
    ServiceLongName -- long name for the service. unused.

Return Values:
    SC Handler error or ERROR_TIMEOUT.  If the service is up
    and running, this returns NO_ERROR.

--*/
{
   LOG_FUNCTION(WaitForServiceToStart);

    SC_HANDLE hScManager, hService;
    ULONG Error, Attempt;
    SERVICE_STATUS ServiceStatus;

    UNREFERENCED_PARAMETER(ServiceLongName);

    //
    // Open SC manager.
    //

    hScManager = OpenSCManager(
        NULL, NULL,
        STANDARD_RIGHTS_READ | SC_MANAGER_ENUMERATE_SERVICE
        );
    if( NULL == hScManager ) return GetLastError();

    Error = NO_ERROR;
    do {
        //
        // Open the required service.
        //
        hService = OpenService(
            hScManager, ServiceShortName,
            SERVICE_QUERY_STATUS
            );

        if( NULL == hService ) {
            Error = GetLastError();
            break;
        }

        //
        // Now do the sleeping thing.
        //

        Attempt = SCQUERYATTEMPTS;
        while (Attempt-- ) {
            //
            // Query service config. On failure bail.
            //
            if( !QueryServiceStatus(hService, &ServiceStatus) ) {
                Error = GetLastError();
                break;
            }

            //
            // Now check if the service has started.
            //
            if( SERVICE_RUNNING == ServiceStatus.dwCurrentState ) {
                Error = ERROR_SUCCESS;
                break;
            }


            //
            // Service is not yet ready. Assert that service
            // is in a nice state.
            //
            ASSERT(
                SERVICE_STOPPED == ServiceStatus.dwCurrentState
                || SERVICE_START_PENDING == ServiceStatus.dwCurrentState
                );
            Error = ERROR_TIMEOUT;

            //
            // if not the last attempt, then sleep for reqd time.
            //
            if( 0 != Attempt ) Sleep(SLEEPTIME);
        }

        //
        // Close service handle for current service.
        //

        CloseServiceHandle(hService);

    } while ( 0 );

    //
    // Close SC manager.
    //

    CloseServiceHandle(hScManager);
    return Error;

}


ULONG
WaitForDCAvailability(
    IN HANDLE hLogFile
    )
/*++

Routine Description:

    This routine attempts to wait for the DC to be available
    so that any further calls to DsGetDcName (via DhcpDsInitDS)
    would work without problems

    It uses a hack (provided by CliffV with severe reservations
    on 06/08/99) to do this -- basically waiting on a registry
    value.

    Code picked off \private\windows\gina\winlogon\wlxutil.c

--*/
{
   LOG_FUNCTION(WaitForDCAvailability);

    ULONG Error, dwResult;
    HKEY hKeyNetLogonParams;
    DWORD dwSysVolReady = 0;
    DWORD dwSize = sizeof( DWORD );
    DWORD dwType = REG_DWORD;
    HANDLE hEvent;

    dwResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\netlogon\\parameters"),
        0,
        KEY_READ,
        &hKeyNetLogonParams
        );

    if ( dwResult != ERROR_SUCCESS ) {
        LogError(hLogFile, ("OpenKey: netlogon\\parameters"), dwResult);
        return dwResult;
    }

    while ( dwSysVolReady == 0 ) {
        //
        // value exists
        //

        dwResult = RegQueryValueEx(
            hKeyNetLogonParams,
            TEXT("SysVolReady"),
            0,
            &dwType,
            (LPBYTE) &dwSysVolReady,
            &dwSize
            );

        if ( dwResult != ERROR_SUCCESS ) {
            //
            // Assume sysvol is ready?
            //
            LogError(hLogFile, ("SysVolReady key absent, assuming sysvol ready"), dwResult);
            RegCloseKey(hKeyNetLogonParams);
            return NO_ERROR;
        }

        //
        // SysVolReady?
        //

        if ( dwSysVolReady != 0 ) {
            LogError(hLogFile, ("SysVolReady!"), dwSysVolReady);
            RegCloseKey(hKeyNetLogonParams);
            return NO_ERROR;
        } else {
            LogString(hLogFile, ("SysVol not yet ready"), NULL);
        }

        //
        // wait for SysVol to become ready
        //

        dwResult = RegNotifyChangeKeyValue(
            hKeyNetLogonParams, FALSE, REG_NOTIFY_CHANGE_LAST_SET, NULL, FALSE
            );

        if ( dwResult != ERROR_SUCCESS ) {
            LogError(hLogFile, ("RegNotifyChangeKeyValue"), dwResult);
            RegCloseKey(hKeyNetLogonParams);
            return dwResult;
        }
    }


    //
    // dead code
    //

    RegCloseKey( hKeyNetLogonParams );
    return NO_ERROR;
}

void
RegisterWLNotifyEvent()
{
   LOG_FUNCTION(RegisterWLNotifyEvent);

    LONG lResult;
    HKEY hkey;
    DWORD dwTemp;

    lResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE, REGSTR_PATH_WLNOTIFY TEXT("\\srvwiz"),
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
        &hkey, &dwTemp
        );

    if ((ERROR_SUCCESS == lResult) && hkey)
    {
        RegSetValueEx(
            hkey, TEXT("DllName"), 0, REG_SZ,
            (LPBYTE)TEXT("srvwiz.dll"),
            (lstrlen(TEXT("srvwiz.dll")) + 1) * sizeof(TCHAR)
            );

        RegSetValueEx(
            hkey, TEXT("Startup"), 0, REG_SZ,
            (LPBYTE)TEXT("AuthorizeDHCPServer"),
            (lstrlen(TEXT("AuthorizeDHCPServer")) + 1) * sizeof(TCHAR)
            );

        dwTemp = 0;
        RegSetValueEx(
            hkey, TEXT("Impersonate"), 0, REG_DWORD,
            (LPBYTE)&dwTemp, sizeof(dwTemp)
            );

        dwTemp = 1;
        RegSetValueEx(
            hkey, TEXT("Asynchronous"), 0, REG_DWORD,
            (LPBYTE)&dwTemp, sizeof(dwTemp)
            );

        RegCloseKey(hkey);
    }

}

void RemoveWLNotifyEvent(void)
{
   LOG_FUNCTION(RemoveWLNotifyEvent);

    LONG lResult;
    HKEY hkey;

    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, REGSTR_PATH_WLNOTIFY, 0,
        MAXIMUM_ALLOWED, &hkey
        );

    if ((ERROR_SUCCESS == lResult) && hkey)
    {
        RegDeleteKey(hkey, TEXT("srvwiz"));

        RegCloseKey(hkey);
    }
}

//==============================================================================
//
// Main program.
//
//==============================================================================


void
AuthorizeDHCPServer(PWLX_NOTIFICATION_INFO pInfo)
{
   LOG_FUNCTION(AuthorizeDHCPServer);

    ULONG Error, IpAddress;
    HANDLE hLogFile;
    WCHAR UNameBuf[UNLEN+DNLEN+10];
    TCHAR DnsNameBuf[500];
    DHCPDS_SERVER CurrentServerInfo;

    //
    // if non-zero arguments passed, then always log info to file.
    //
    Error = OpenLogFile(&hLogFile, TEXT("dhcpself.log"), TRUE);
    if( NO_ERROR != Error ) {
        //
        // Aargh.  This is very annoying.
        //
#if DBG
        (void)DbgPrint("DHCPSELF: OpenLogFile: 0x%lx\n", Error);
#endif

        ASSERT(FALSE);
        return;
    }

    do {
        //
        // First wait for samss to start.
        //

        LogString(hLogFile, ("Waiting for samss service to start"),TEXT(""));

        Error = WaitForServiceToStart(
            TEXT("samss"), TEXT("Security Accounts Manager")
            );
        if( NO_ERROR != Error ) {
            LogError(hLogFile, ("WaitForServiceToStart"), Error);
            break;
        }

        //
        // Now Log current user name.
        //

        Error = GetUserAndDomainName(UNameBuf);
        if( NO_ERROR != Error ) {
            LogError(hLogFile, ("GetUserAndDomainName"), Error);
        } else {
            LogString(hLogFile, ("Caller"), UNameBuf);
        }

        //
        // Wait for DS to be available
        //
        Error = WaitForDCAvailability(hLogFile);
        if( NO_ERROR != Error ) {
            LogError(hLogFile, ("WaitForDCAvailability"), Error);
        }

        //
        // Now attempt to start ds stuff.
        //
        Error = DhcpDsInitDS(0, NULL);
        if( NO_ERROR != Error ) {
            LogError(hLogFile, ("DhcpDsInitDS"), Error);
            break;
        }

        //
        // Now attempt to get own IP address and full DNS name.
        //
        Error = GetIpAddressAndMachineDnsName(
            &IpAddress,
            DnsNameBuf,
            sizeof(DnsNameBuf)/sizeof(WCHAR)
            );
        if( NO_ERROR != Error ) {
            LogError(hLogFile, ("GetIpAddressAndMachineDnsName"), Error);
            break;
        }

        //
        // Log Obtained domain name and ip address.
        //
        LogIpAddress(hLogFile, ("Host Address"), IpAddress);
        LogString(hLogFile, ("DC Dns Name"), DnsNameBuf);

        //
        // Now attempt to authorize self.
        //
        RtlZeroMemory(&CurrentServerInfo, sizeof(CurrentServerInfo));
        CurrentServerInfo.ServerName = DnsNameBuf;
        // CurrentServerInfo.ServerAddress = htonl(IpAddress);
        CurrentServerInfo.ServerAddress = htonl(inet_addr("10.10.1.1"));

        Error = DhcpAddServerDS(
            /* Flags */ 0, /* IdInfo */ NULL,
            &CurrentServerInfo,
            /* CallbackFn */ NULL, /* CallbackData */ NULL
            );
        if( NO_ERROR != Error ) {
            LogError(hLogFile, ("DhcpAddServerDS"), Error);
            break;
        } else {
            LogString(hLogFile, ("DhcpAddServerDS succeeded"), TEXT(""));
        }

        //
        // Done!
        //

        Error = NO_ERROR;

    } while ( 0 );

    //
    // Cleanup.
    //

    DhcpDsCleanupDS();
    CloseLogFile(hLogFile);
    RemoveWLNotifyEvent();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\util.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// utility grab bag
//
// 28 Mar 2000 sburns



#ifndef UTIL_HPP_INCLUDED
#define UTIL_HPP_INCLUDED



HRESULT
CreateAndWaitForProcess(const String& commandLine, DWORD& exitCode);



DWORD
MyWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);



#endif   // UTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\test\makefile.inc ===
.SUFFIXES : .vbt

# a .vbs file is produced from a .vbt file by executing the C preprocessor
# on the .vbt file, which produces a .i file.  then we rename the .i file
# to .vbs

.vbt.vbs:
	-del $@
	$(CC) -nologo -EP -P -Tc$(@B).vbt
	ren $(@B).i $@

all:

clean:
	del *.vbs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\util.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// utility grab bag
//
// 28 Mar 2000 sburns



#include "headers.hxx"
#include "util.hpp"



// Wait for a handle to become signalled, or a timeout to expire, or WM_QUIT
// to appear in the message queue.  Pump the message queue while we wait.
// 
// WARNING: UI should diable itself before calling any function that invokes
// this function, or functions calling this one should guard against
// re-entrance.  Otherwise there will be a re-entrancy problem.
// 
// e.g. command handler gets button clicked message, calls a func that calls
// this wait function, then user clicks the button again, command handler call
// a func that calls this one, and so on.

DWORD
MyWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
   LOG_FUNCTION(MyWaitForSendMessageThread);
   ASSERT(hThread);

    MSG msg;
    DWORD dwRet;
    DWORD dwEnd = GetTickCount() + dwTimeout;
    bool quit = false;

    // We will attempt to wait up to dwTimeout for the thread to
    // terminate

    do 
    {
        dwRet = MsgWaitForMultipleObjects(1, &hThread, FALSE,
                dwTimeout, QS_ALLEVENTS | QS_SENDMESSAGE );

        if (dwRet == (WAIT_OBJECT_0 + 1))
        {
            // empty out the message queue.  We call DispatchMessage to
            // ensure that we still process the WM_PAINT messages.
            // DANGER:  Make sure that the CYS UI is completely disabled
            // or there will be re-entrancy problems here

            while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
               if (msg.message == WM_QUIT)
               {
                  // Need to re-post this so that we know to close CYS

                  ::PostMessage(msg.hwnd, WM_QUIT, 0, 0);
                  quit = true;
                  break;
               }
               ::TranslateMessage(&msg);
               ::DispatchMessage(&msg);
            }

            // Calculate if we have any more time left in the timeout to
            // wait on.

            if (dwTimeout != INFINITE)
            {
                dwTimeout = dwEnd - GetTickCount();
                if ((long)dwTimeout <= 0)
                {
                    // No more time left, fail with WAIT_TIMEOUT
                    dwRet = WAIT_TIMEOUT;
                }
            }
        }

        // dwRet == WAIT_OBJECT_0 || dwRet == WAIT_FAILED
        // The thread must have exited, so we are happy
        //
        // dwRet == WAIT_TIMEOUT
        // The thread is taking too long to finish, so just
        // return and let the caller kill it

    } while (dwRet == (WAIT_OBJECT_0 + 1) && !quit);

    return(dwRet);
}



HRESULT
CreateAndWaitForProcess(const String& commandLine, DWORD& exitCode)
{
   LOG_FUNCTION2(CreateAndWaitForProcess, commandLine);
   ASSERT(!commandLine.empty());

   exitCode = 0;

   HRESULT hr = S_OK;
   do
   {
      PROCESS_INFORMATION procInfo;
      memset(&procInfo, 0, sizeof(procInfo));

      STARTUPINFO startup;
      memset(&startup, 0, sizeof(startup));

      String commandLine2(commandLine);
         
      LOG(L"Calling CreateProcess");
      LOG(commandLine2);

      hr =
         Win::CreateProcess(
            commandLine2,
            0,
            0,
            false,
            0,
            0,
            String(),
            startup,
            procInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(procInfo.hProcess);

      DWORD dwRet = MyWaitForSendMessageThread(procInfo.hProcess, INFINITE);

      ASSERT(dwRet == WAIT_OBJECT_0);

      hr = Win::GetExitCodeProcess(procInfo.hProcess, exitCode);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::CloseHandle(procInfo.hThread);
      Win::CloseHandle(procInfo.hProcess);
   }
   while (0);

   LOG(String::format(L"exit code = %1!d!", exitCode));
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\applicationinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ApplicationInstallationUnit.h
//
// Synopsis:  Declares a ApplicationInstallationUnit
//            This object has the knowledge for installing the
//            Application service portion of Terminal Server
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_APPLICATIONINSTALLATIONUNIT_H
#define __CYS_APPLICATIONINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class ApplicationInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      ApplicationInstallationUnit();

      // Destructor

      virtual
      ~ApplicationInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      virtual
      String
      GetServiceDescription();


      // Terminal Server specific 

      DWORD
      GetServerSize();

      bool
      SetServerSize(DWORD size) const;

      DWORD
      GetServerCache();

      bool
      SetServerCache(DWORD cache) const;

      DWORD
      GetApplicationMode();

      bool
      SetApplicationMode(DWORD mode) const;

      void
      SetInstallTS(bool install);

      bool
      GetInstallTS() const { return installTS; }

   private:

      DWORD serverSize;
      DWORD serverCache;
      DWORD applicationMode;

      bool installTS;
};

#endif // __CYS_APPLICATIONINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\src\validatename.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of IConfigureYourServer::ValidateName
//
// 09 Jun 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "ConfigureYourServer.hpp"
#include "util.hpp"



// see admin\dcpromo\exe\headers.hxx
static const int DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY      = 64; 
static const int DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 = 155;

// possible result values from ICYS::ValidateName

static const int VALIDATE_INPUT_ILLEGAL                       = 0;  
static const int VALIDATE_NAME_TOO_LONG                       = 1;
static const int VALIDATE_NAME_NUMERIC                        = 2;
static const int VALIDATE_BAD_CHARS_IN_NAME                   = 3;
static const int VALIDATE_NAME_MALFORMED                      = 4;
static const int VALIDATE_NAME_IN_USE                         = 5;  
static const int VALIDATE_NAME_AVAILABLE                      = 6;  



int
IsNameInUse(const String& domainName)
{
   LOG_FUNCTION2(IsNameInUse, domainName);

   int result = VALIDATE_NAME_AVAILABLE;

   do
   {
      // see if we can find a domain controller for that name

      DOMAIN_CONTROLLER_INFO* info = 0;      
      HRESULT hr =
         MyDsGetDcName(
            0, 
            domainName,

            // force discovery to ensure that we don't pick up a cached
            // entry for a domain that may no longer exist

            DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_PREFERRED,
            info);
      if (SUCCEEDED(hr))
      {
         // we found a domain with this name, so the name is in use.

         result = VALIDATE_NAME_IN_USE;
         ::NetApiBufferFree(info);

         break;
      }

      // see if the name is in use for anything other than a domain (a
      // machine name, for example)

      hr = MyNetValidateName(domainName, NetSetupNonExistentDomain);
      if (hr == Win32ToHresult(ERROR_DUP_NAME))
      {
         result = VALIDATE_NAME_IN_USE;
         break;
      }
   }
   while (0);

   LOG(String::format(L"result = %1!d!", result));

   return result;
}



HRESULT 
ValidateDomainDnsName(
   const String&  domainDnsName,
   int&           result)
{
   LOG_FUNCTION2(ValidateDomainDnsName, domainDnsName);

   result = VALIDATE_INPUT_ILLEGAL;
   HRESULT hr = S_OK;

   do
   {
      String dnsName(domainDnsName);
      dnsName.strip(String::BOTH);

      if (dnsName.empty())
      {
         hr = E_INVALIDARG;
         break;
      }

      // Check syntax first.

      switch (
         Dns::ValidateDnsNameSyntax(
            dnsName,
            DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
            DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8) )
      {
         case Dns::NON_RFC:
         case Dns::VALID:
         {
            result = IsNameInUse(dnsName);
            break;
         }
         case Dns::TOO_LONG:
         {
            result = VALIDATE_NAME_TOO_LONG;
            break;
         }
         case Dns::NUMERIC:
         {
            result = VALIDATE_NAME_NUMERIC;
            break;
         }
         case Dns::BAD_CHARS:
         {
            result = VALIDATE_BAD_CHARS_IN_NAME;
            break;
         }
         case Dns::INVALID:
         {
            // malformed

            result = VALIDATE_NAME_MALFORMED;
            break;
         }
         default:
         {
            // we should have accounted for all the cases.

            ASSERT(false);

            // do nothing: same as illegal input.

            break;
         }
      }
   }
   while (0);

   LOG(String::format(L"result = %1!d!", result));
   LOG_HRESULT(hr);

   return hr;
}



HRESULT
ValidateDomainNetBiosName(
   const String& domainNetBiosName,
   int&          result)
{
   LOG_FUNCTION2(ValidateDomainNetBiosName, domainNetBiosName);

   result = VALIDATE_INPUT_ILLEGAL;
   HRESULT hr = S_OK;

   do
   {
      String name(domainNetBiosName);
      name.strip(String::BOTH);

      if (name.empty())
      {
         hr = E_INVALIDARG;
         break;
      }

      // no '.'s allowed

      if (name.find(L".") != String::npos)
      {
         result = VALIDATE_BAD_CHARS_IN_NAME;
         break;
      }

      if (name.is_numeric())
      {
         result = VALIDATE_NAME_NUMERIC;
         break;
      }

      HRESULT hr2 = S_OK;
      String s = Dns::HostnameToNetbiosName(name, &hr2);
      if (FAILED(hr2))
      {
         result = VALIDATE_BAD_CHARS_IN_NAME;
         break;
      }

      if (s.length() < name.length())
      {
         // the name was truncated.

         result = VALIDATE_NAME_TOO_LONG;
         break;
      }

      result = IsNameInUse(s);
   }
   while (0);

   LOG(String::format(L"result = %1!d!", result));
   LOG_HRESULT(hr);

   return hr;
}



HRESULT __stdcall
ConfigureYourServer::ValidateName(
   BSTR bstrType,
   BSTR bstrName,
   int* result)
{
   LOG_FUNCTION2(
      ConfigureYourServer::ValidateName,
      bstrName ? bstrName : L"(null)");
   ASSERT(bstrType);
   ASSERT(bstrName);
   ASSERT(result);

   HRESULT hr = S_OK;

   // this is a lengthy operation

   HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = VALIDATE_INPUT_ILLEGAL;

      if (!bstrType || !bstrName)
      {
         hr = E_INVALIDARG;
         break;
      }

      if (!StrCmpIW(bstrType, L"DNS"))
      {
         hr = ValidateDomainDnsName(bstrName, *result);
      }
      else if (!StrCmpIW(bstrType, L"NetBios"))
      {
         hr = ValidateDomainNetBiosName(bstrName, *result);
      }
      else
      {
         hr = E_INVALIDARG;
      }
   }
   while (0);

   SetCursor(hcurOld);

   LOG(result ? String::format(L"result = %1!d!", *result) : L"");
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\applicationinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ApplicationInstallationUnit.cpp
//
// Synopsis:  Defines a ApplicationInstallationUnit
//            This object has the knowledge for installing the
//            Application services portions of Terminal Server
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "ApplicationInstallationUnit.h"
#include "state.h"


// Finish page help 
static PCWSTR CYS_TS_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_application_server.htm";

ApplicationInstallationUnit::ApplicationInstallationUnit() :
   serverSize(static_cast<DWORD>(-1)),
   serverCache(static_cast<DWORD>(-1)),
   applicationMode(static_cast<DWORD>(-1)),
   installTS(false),
   InstallationUnit((State::GetInstance().GetProductSKU() & CYS_SERVER) ?
                        IDS_APPLICATION_SERVER_TYPE_SRV : IDS_APPLICATION_SERVER_TYPE, 
                    IDS_APPLICATION_SERVER_DESCRIPTION,
                    CYS_TS_FINISH_PAGE_HELP,
                    APPLICATIONSERVER_INSTALL)
{
   LOG_CTOR(ApplicationInstallationUnit);
}


ApplicationInstallationUnit::~ApplicationInstallationUnit()
{
   LOG_DTOR(ApplicationInstallationUnit);
}


InstallationReturnType
ApplicationInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(ApplicationInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   bool optimize = false;
   bool install  = false;

   CYS_APPEND_LOG(String::load(IDS_LOG_APP_CONFIGURE));

   if (State::GetInstance().GetProductSKU() & CYS_SERVER)
   {

      // Server SKU - service is installed if the optimizations for applications
      //              have been turned on

      if (GetServerSize() == 3 &&
          GetServerCache() == 0)
      {
         // Server is already optimized - service is installed
         
         // do nothing
         optimize = false;
         install = false;
      }
      else
      {
         // Server has not been optimized - service is not considered installed

         optimize = true;
         install = false;
      }
   }
   else if (State::GetInstance().GetProductSKU() & (CYS_ADVANCED_SERVER | CYS_DATACENTER_SERVER))
   {
      // Datacenter or Advanced Server SKU - service is considered installed if the optimizations
      //              have been turned on and the Terminal Server has been installed

      if (GetServerSize()  == 3 &&
          GetServerCache() == 0 &&
          GetApplicationMode() == 1)
      {
         // Server is already optimized for applications - service is installed

         // do nothing
         optimize = false;
         install = false;
      }
      else if (GetServerSize()  == 3 &&
               GetServerCache() == 0 &&
               GetApplicationMode() != 1)
      {
         // Server is already optimized for application but TS is not installed 
         // - service not installed completely

         optimize = false;
         install = installTS;
      }
      else if ((GetServerSize()  != 3 ||
                GetServerCache() != 0) &&
               GetApplicationMode() != 1)
      {
         // Server is not optimized for applications and TS is not installed
         // - service not installed

         optimize = true;
         install = installTS;
      }
      else if ((GetServerSize()  != 3 ||
                GetServerCache() != 0) &&
                GetApplicationMode() == 1)
      {
         // Server is not optimized for applications but TS is installed
         // - service not installed completely

         optimize = true;
         install = false;
      }
   }
   else
   {
      // No other SKUs are supported

      optimize = false;
      install = false;
   }

   if (optimize)
   {
      // To optimize we set the server size and cache registry keys

      bool resultSize = true;
      bool resultCache = true;

      resultSize = SetServerSize(CYS_SERVER_SIZE_ON);
      resultCache = SetServerCache(CYS_SERVER_CACHE_ON);

      if (resultSize && resultCache)
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_APP_OPTIMIZE_SUCCESS));

         LOG(L"The registry keys for TS optimizations were set successfully");

         if (install)
         {
            result = INSTALL_SUCCESS;
         }
         else
         {
            result = INSTALL_SUCCESS_PROMPT_REBOOT;

            // Set the regkeys for reboot

            bool regkeyResult = 
               State::GetInstance().SetHomeRegkey(CYS_HOME_REGKEY_TERMINAL_SERVER_OPTIMIZED);

            ASSERT(regkeyResult);

            // set the key so CYS has to run again

            regkeyResult = SetRegKeyValue(
                              CYS_HOME_REGKEY, 
                              CYS_HOME_REGKEY_MUST_RUN, 
                              CYS_HOME_RUN_KEY_RUN_AGAIN,
                              HKEY_LOCAL_MACHINE,
                              true);
            ASSERT(regkeyResult);
         }
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_APP_OPTIMIZE_FAILED_WITH_ERROR));
         CYS_APPEND_LOG(String::load(IDS_LOG_APP_OPTIMIZE_FAILED));

         LOG(L"The registry keys for TS optimizations were not set");

         result = INSTALL_FAILURE;
      }
   }

   if (install)
   {
      // OCManager will reboot so prompt the user now

      if (IDOK == Win::MessageBox(
                     hwnd,
                     String::load(IDS_CONFIRM_REBOOT),
                     String::load(IDS_WIZARD_TITLE),
                     MB_OKCANCEL))
      {
         // Setup TS using an unattend file

         String unattendFileText;
         String infFileText;

         unattendFileText += L"[Components]\n";
         unattendFileText += L"TerminalServer=ON";

         // IMPORTANT!!! The OCManager will reboot the machine
         // The log file and registry keys must be written before we launch
         // the OCManager or all will be lost

         String homeKeyValue = CYS_HOME_REGKEY_TERMINAL_SERVER_VALUE;
         State::GetInstance().SetHomeRegkey(homeKeyValue);

         // set the key so CYS has to run again

         bool regkeyResult = SetRegKeyValue(
                                CYS_HOME_REGKEY, 
                                CYS_HOME_REGKEY_MUST_RUN, 
                                CYS_HOME_RUN_KEY_RUN_AGAIN,
                                HKEY_LOCAL_MACHINE,
                                true);
         ASSERT(regkeyResult);

         // The OCManager will reboot after installation so we don't want the finish
         // page to show the log or help

         result = INSTALL_SUCCESS_REBOOT;

         bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
         if (!ocmResult)
         {
            CYS_APPEND_LOG(String::load(IDS_LOG_APP_INSTALL_FAILED));
            result = INSTALL_FAILURE;
         }
      }
      else
      {
         // user aborted the installation

         CYS_APPEND_LOG(String::load(IDS_LOG_APP_ABORTED));

         LOG(L"The installation was cancelled by the user when prompted for reboot.");
         result = INSTALL_FAILURE;
      }
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
ApplicationInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(ApplicationInstallationUnit::IsServiceInstalled);

   bool result = false;

   if (State::GetInstance().GetProductSKU() & CYS_SERVER)
   {

      // Server SKU - service is installed if the optimizations for applications
      //              have been turned on

      if (GetServerSize() == CYS_SERVER_SIZE_ON &&
          GetServerCache() == CYS_SERVER_CACHE_ON)
      {
         // Server is already optimized - service is installed
         
         result = true;
      }
      else
      {
         // Server has not been optimized - service is not considered installed

         result = false;
      }
   }
   else if (State::GetInstance().GetProductSKU() & (CYS_ADVANCED_SERVER | CYS_DATACENTER_SERVER))
   {
      // Datacenter or Advanced Server SKU - service is considered installed if the optimizations
      //              have been turned on and the Terminal Server has been installed

      if (GetServerSize()  == CYS_SERVER_SIZE_ON &&
          GetServerCache() == CYS_SERVER_CACHE_ON &&
          GetApplicationMode() == CYS_APPLICATION_MODE_ON)
      {
         // Server is already optimized for applications - service is installed

         result = true;
      }
      else if (GetServerSize()  == CYS_SERVER_SIZE_ON &&
               GetServerCache() == CYS_SERVER_CACHE_ON &&
               GetApplicationMode() != CYS_APPLICATION_MODE_ON)
      {
         // Server is already optimized for application but TS is not installed 
         // - service not installed completely

         result = false;
      }
      else if ((GetServerSize()  != CYS_SERVER_SIZE_ON ||
                GetServerCache() != CYS_SERVER_CACHE_ON) &&
               GetApplicationMode() != CYS_APPLICATION_MODE_ON)
      {
         // Server is not optimized for applications and TS is not installed
         // - service not installed

         result = false;
      }
      else if ((GetServerSize()  != CYS_SERVER_SIZE_ON ||
                GetServerCache() != CYS_SERVER_CACHE_ON) &&
                GetApplicationMode() == CYS_APPLICATION_MODE_ON)
      {
         // Server is not optimized for applications but TS is installed
         // - service not installed completely

         result = false;
      }
   }
   else
   {
      // No other SKUs are supported

      result = false;
   }

   LOG_BOOL(result);

   return result;
}

bool
ApplicationInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(ApplicationInstallationUnit::GetFinishText);

   bool optimize = false;
   bool install  = false;

   if (State::GetInstance().GetProductSKU() & CYS_SERVER)
   {

      // Server SKU - service is installed if the optimizations for applications
      //              have been turned on

      if (GetServerSize() == CYS_SERVER_SIZE_ON &&
          GetServerCache() == CYS_SERVER_CACHE_ON)
      {
         // Server is already optimized - service is installed
         
         // do nothing
         optimize = false;
         install = false;
      }
      else
      {
         // Server has not been optimized - service is not considered installed

         optimize = true;
         install = false;
      }
   }
   else if (State::GetInstance().GetProductSKU() & (CYS_ADVANCED_SERVER | CYS_DATACENTER_SERVER))
   {
      // Datacenter or Advanced Server SKU - service is considered installed if the optimizations
      //              have been turned on and the Terminal Server has been installed

      if (GetServerSize()  == CYS_SERVER_SIZE_ON &&
          GetServerCache() == CYS_SERVER_CACHE_ON &&
          GetApplicationMode() == CYS_APPLICATION_MODE_ON)
      {
         // Server is already optimized for applications - service is installed

         // do nothing
         optimize = false;
         install = false;
      }
      else if (GetServerSize()  == CYS_SERVER_SIZE_ON &&
               GetServerCache() == CYS_SERVER_CACHE_ON &&
               GetApplicationMode() != CYS_APPLICATION_MODE_ON)
      {
         // Server is already optimized for application but TS is not installed 
         // - service not installed completely

         optimize = false;
         install = GetInstallTS();
      }
      else if ((GetServerSize()  != CYS_SERVER_SIZE_ON ||
                GetServerCache() != CYS_SERVER_CACHE_ON) &&
               GetApplicationMode() != CYS_APPLICATION_MODE_ON)
      {
         // Server is not optimized for applications and TS is not installed
         // - service not installed

         optimize = true;
         install = GetInstallTS();
      }
      else if ((GetServerSize()  != CYS_SERVER_SIZE_ON ||
                GetServerCache() != CYS_SERVER_CACHE_ON) &&
                GetApplicationMode() == CYS_APPLICATION_MODE_ON)
      {
         // Server is not optimized for applications but TS is installed
         // - service not installed completely

         optimize = true;
         install = false;
      }
   }
   else
   {
      // No other SKUs are supported

      optimize = false;
      install = false;
   }

   if (optimize)
   {
      message = String::load(IDS_APPLICATION_FINISH_TEXT);
   }

   if (install)
   {
      message += String::load(IDS_APPLICATION_FINISH_INSTALL_TS);
   }

   if (!optimize && !install)
   {
      message = String::load(IDS_FINISH_NO_CHANGES);
   }

   LOG_BOOL(optimize || install);
   return optimize || install;
}

String
ApplicationInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(ApplicationInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (State::GetInstance().GetProductSKU() & CYS_SERVER)
   {

      // Server SKU - service is installed if the optimizations for applications
      //              have been turned on

      if (GetServerSize() == CYS_SERVER_SIZE_ON &&
          GetServerCache() == CYS_SERVER_CACHE_ON)
      {
         // Server is already optimized - service is installed
         
         resourceID = IDS_APP_SERVER_DESCRIPTION_OPTIMIZED;
      }
      else
      {
         // Server has not been optimized - service is not considered installed

         resourceID = IDS_APP_SERVER_DESCRIPTION_NOT_OPTIMIZED;
      }
   }
   else if (State::GetInstance().GetProductSKU() & (CYS_ADVANCED_SERVER | CYS_DATACENTER_SERVER))
   {
      // Datacenter or Advanced Server SKU - service is considered installed if the optimizations
      //              have been turned on and the Terminal Server has been installed

      if (GetServerSize()  == CYS_SERVER_SIZE_ON &&
          GetServerCache() == CYS_SERVER_CACHE_ON &&
          GetApplicationMode() == CYS_APPLICATION_MODE_ON)
      {
         // Server is already optimized for applications - service is installed

         resourceID = IDS_APP_ADVSERVER_DESCRIPTION_OPTIMIZED_INSTALLED;
      }
      else if (GetServerSize()  == CYS_SERVER_SIZE_ON &&
               GetServerCache() == CYS_SERVER_CACHE_ON &&
               GetApplicationMode() != CYS_APPLICATION_MODE_ON)
      {
         // Server is already optimized for application but TS is not installed 
         // - service not installed completely

         resourceID = IDS_APP_ADVSERVER_DESCRIPTION_OPTIMIZED_NOT_INSTALLED;
      }
      else if ((GetServerSize()  != CYS_SERVER_SIZE_ON ||
                GetServerCache() != CYS_SERVER_CACHE_ON) &&
               GetApplicationMode() != CYS_APPLICATION_MODE_ON)
      {
         // Server is not optimized for applications and TS is not installed
         // - service not installed

         resourceID = IDS_APP_ADVSERVER_DESCRIPTION_NOT_OPTIMIZED_NOT_INSTALLED;
      }
      else if ((GetServerSize()  != CYS_SERVER_SIZE_ON ||
                GetServerCache() != CYS_SERVER_CACHE_ON) &&
                GetApplicationMode() == CYS_APPLICATION_MODE_ON)
      {
         // Server is not optimized for applications but TS is installed
         // - service not installed completely

         resourceID = IDS_APP_ADVSERVER_DESCRIPTION_NOT_OPTIMIZED_INSTALLED;
      }
   }
   else
   {
      // No other SKUs are supported

      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}


DWORD
ApplicationInstallationUnit::GetServerSize()
{
   LOG_FUNCTION(ApplicationInstallationUnit::GetServerSize);

   DWORD result = static_cast<DWORD>(-1);

   if (serverSize == static_cast<DWORD>(-1))
   {
      // Read the server size from the registry

      bool keyResult = GetRegKeyValue(
                          CYS_SERVER_SIZE_REGKEY, 
                          CYS_SERVER_SIZE_VALUE, 
                          result);
      ASSERT(keyResult);

      serverSize = result;
   }

   result = serverSize;

   LOG(String::format(L"Server size = %1!d!", result));

   return result;
}

DWORD
ApplicationInstallationUnit::GetServerCache()
{
   LOG_FUNCTION(ApplicationInstallationUnit::GetServerCache);

   DWORD result = static_cast<DWORD>(-1);

   if (serverCache == static_cast<DWORD>(-1))
   {
      // Read the server cache from the registry

      bool keyResult = GetRegKeyValue(
                          CYS_SERVER_CACHE_REGKEY, 
                          CYS_SERVER_CACHE_VALUE, 
                          result);
      ASSERT(keyResult);

      if (keyResult)
      {
         serverCache = result;
      }
   }

   result = serverCache;

   LOG(String::format(L"Server cache = %1!d!", result));

   return result;
}

DWORD
ApplicationInstallationUnit::GetApplicationMode()
{
   LOG_FUNCTION(ApplicationInstallationUnit::GetApplicationMode);

   DWORD result = static_cast<DWORD>(-1);

   if (applicationMode == static_cast<DWORD>(-1))
   {
      // Read the application mode from the registry

      bool keyResult = GetRegKeyValue(
                          CYS_APPLICATION_MODE_REGKEY, 
                          CYS_APPLICATION_MODE_VALUE, 
                          result);
      ASSERT(keyResult);

      if (keyResult)
      {
         applicationMode = result;
      } 
   }

   result = applicationMode;

   LOG(String::format(L"Application mode = %1!d!", result));

   return result;
}


bool
ApplicationInstallationUnit::SetServerSize(DWORD size) const
{
   LOG_FUNCTION2(
      ApplicationInstallationUnit::SetServerSize,
      String::format(L"%1!d!", size));

   // Write the server size from the registry

   bool result = SetRegKeyValue(
                    CYS_SERVER_SIZE_REGKEY, 
                    CYS_SERVER_SIZE_VALUE, 
                    size);
   ASSERT(result);

   return result;
}

bool
ApplicationInstallationUnit::SetServerCache(DWORD cache) const
{
   LOG_FUNCTION2(
      ApplicationInstallationUnit::SetServerCache,
      String::format(L"%1!d!", cache));

   // Write the server cache to the registry

   bool result = SetRegKeyValue(
                    CYS_SERVER_CACHE_REGKEY, 
                    CYS_SERVER_CACHE_VALUE, 
                    cache);
   ASSERT(result);

   return result;
}

bool
ApplicationInstallationUnit::SetApplicationMode(DWORD mode) const
{
   LOG_FUNCTION2(
      ApplicationInstallationUnit::SetApplicationMode,
      String::format(L"%1!d!", mode));

   bool result = SetRegKeyValue(
                    CYS_APPLICATION_MODE_REGKEY, 
                    CYS_APPLICATION_MODE_VALUE, 
                    mode);
   ASSERT(result);

   return result;
}


void
ApplicationInstallationUnit::SetInstallTS(bool install)
{
   LOG_FUNCTION2(
      ApplicationInstallationUnit::SetInstallTS,
      install ? L"true" : L"false");

   installTS = install;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\adinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ADInstallationUnit.h
//
// Synopsis:  Declares a ADInstallationUnit
//            This object has the knowledge for installing 
//            Active Directory
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_ASINSTALLATIONUNIT_H
#define __CYS_ADINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class ADInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      ADInstallationUnit();

      // Destructor
      virtual
      ~ADInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      String
      GetServiceDescription();

      virtual
      bool
      GetFinishText(String& message);

      InstallationReturnType
      InstallServiceExpressPath(HANDLE logfileHandle, HWND hwnd);

      // Data accessors

      void
      SetExpressPathInstall(bool isExpressPath);

      bool IsExpressPathInstall() const;

      void
      SetNewDomainDNSName(const String& newDomain);

      String
      GetNewDomainDNSName() const { return domain; }

      void
      SetNewDomainNetbiosName(const String& newNetbios);

      String
      GetNewDomainNetbiosName() const { return netbios; }

      void
      SetSafeModeAdminPassword(const String& newPassword);

      String
      GetSafeModeAdminPassword() const { return password; }

   private:

      bool
      CreateAnswerFileForDCPromo(String& answerFilePath);

      bool
      ReadConfigWizardRegkeys(String& configWizardResults) const;

      bool   isExpressPathInstall;
      String domain;
      String netbios;
      String password;
};

#endif // __CYS_ADINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\beforebeginpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      BeforeBeginPage.cpp
//
// Synopsis:  Defines the Before You Begin Page for the CYS
//            Wizard.  Tells the user what they should do
//            before running CYS.
//
// History:   03/14/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "BeforeBeginPage.h"
#include "state.h"


static PCWSTR BEFORE_BEGIN_PAGE_HELP = L"cys.chm::/cys_topnode.htm";
static PCWSTR BEFORE_BEGIN_LINK_HELP = L"cys.chm::/cys_topnode.htm";

BeforeBeginPage::BeforeBeginPage()
   :
   bulletFont(0),
   CYSWizardPage(
      IDD_BEFORE_BEGIN_PAGE, 
      IDS_BEFORE_BEGIN_TITLE, 
      IDS_BEFORE_BEGIN_SUBTITLE, 
      BEFORE_BEGIN_PAGE_HELP)
{
   LOG_CTOR(BeforeBeginPage);
}

   

BeforeBeginPage::~BeforeBeginPage()
{
   LOG_DTOR(BeforeBeginPage);

   if (bulletFont)
   {
      HRESULT hr = Win::DeleteObject(bulletFont);
      ASSERT(SUCCEEDED(hr));
   }
}


void
BeforeBeginPage::OnInit()
{
   LOG_FUNCTION(BeforeBeginPage::OnInit);

   InitializeBulletedList();
}

void
BeforeBeginPage::InitializeBulletedList()
{
   LOG_FUNCTION(BeforeBeginPage::InitializeBulletedList);

   bulletFont = CreateFont(
                   0,
                   0,
                   0,
                   0,
                   FW_NORMAL,
                   0,
                   0,
                   0,
                   SYMBOL_CHARSET,
                   OUT_CHARACTER_PRECIS,
                   CLIP_CHARACTER_PRECIS,
                   PROOF_QUALITY,
                   VARIABLE_PITCH|FF_DONTCARE,
                   L"Marlett");

   if (bulletFont)
   {
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET1), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET2), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET3), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET4), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET5), bulletFont, true);
   }
   else
   {
      LOG(String::format(
             L"Failed to create font for bullet list: hr = %1!x!",
             GetLastError()));
   }

}

bool
BeforeBeginPage::OnSetActive()
{
   LOG_FUNCTION(BeforeBeginPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}

bool
BeforeBeginPage::OnNotify(
   HWND        /*windowFrom*/,
   unsigned    controlIDFrom,
   unsigned    code,
   LPARAM      /*lParam*/)
{
//   LOG_FUNCTION(BeforeBeginPage::OnCommand);
 
   bool result = false;

   if (IDC_LINK == controlIDFrom &&
       (NM_CLICK == code ||
        NM_RETURN == code))
   {
      Win::HtmlHelp(
         hwnd,
         BEFORE_BEGIN_LINK_HELP,
         HH_DISPLAY_TOPIC,
         0);
   }
   return result;
}


int
BeforeBeginPage::Validate()
{
   LOG_FUNCTION(BeforeBeginPage::Validate);

   // Gather the machine network and role information

   State& state = State::GetInstance();

   if (!state.HasStateBeenRetrieved())
   {
      if (!state.RetrieveMachineConfigurationInformation(hwnd))
      {
         ASSERT(false);
         LOG(L"The machine configuration could not be retrieved.");
         return -1;
      }
   }

   int nextPage = IDD_DECISION_PAGE;
/* Just for testing the NIC selection page

   int nextPage = IDD_CUSTOM_SERVER_PAGE;

   // The decision page should be shown only if we are not a DC, not a DHCP server,
   // not a DNS server, have only one or two NICs, and there is only one static 
   // IP address on the interfaces

   if (!(state.IsDC() || state.IsUpgradeState()))
   {
      if (!InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().IsServiceInstalled() &&
          !InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().IsServiceInstalled())
      {
         if (state.GetNICCount() == 1)
         {
            if (!state.IsDHCPAvailableOnNIC(0))
            {
               nextPage = IDD_DECISION_PAGE;
            }
         }
         else if (state.GetNICCount() == 2)
         {
            bool isDHCPAvailableOnNIC1 = state.IsDHCPAvailableOnNIC(0);
            bool isDHCPAvailableOnNIC2 = state.IsDHCPAvailableOnNIC(1);

            if ((!isDHCPAvailableOnNIC1 && isDHCPAvailableOnNIC2) ||
                (isDHCPAvailableOnNIC1 && !isDHCPAvailableOnNIC2))
            {
               // As long as only one of the interfaces has a 
               // dynamically assigned IP address we can go
               // through the Express path

               nextPage = IDD_DECISION_PAGE;
            }
         }
         else
         {
            // If the machine doesn't have a NIC or 
            // has more than 2 NICs then there is either no
            // reason to make this a network server or the
            // user is considered more advanced and should
            // run through the custom part of the wizard
         }
      }
   }
*/
   LOG(String::format(L"nextPage = %1!d!", nextPage));
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\adinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ADInstallationUnit.cpp
//
// Synopsis:  Defines a ADInstallationUnit
//            This object has the knowledge for installing 
//            Active Directory
//
// History:   02/08/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "state.h"


#define CYS_DCPROMO_COMMAND_LINE    L"dcpromo.exe"

// Exit codes borrowed from DCPromo.cpp

enum DCPromoExitCodes
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,

   // the operation succeeded, and the user opted not to have the wizard
   // restart the machine, either manually or by specifying
   // RebootOnSuccess=NoAndNoPromptEither in the answerfile

   EXIT_CODE_SUCCESSFUL_NO_REBOOT = 2,

   // the operation failed, but the machine needs to be rebooted anyway

   EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT = 3
};

// Finish page help 
static PCWSTR CYS_AD_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_domain_controller.htm";

ADInstallationUnit::ADInstallationUnit() :
   isExpressPathInstall(false),
   InstallationUnit(
      IDS_DOMAIN_CONTROLLER_TYPE, 
      IDS_DOMAIN_CONTROLLER_DESCRIPTION, 
      CYS_AD_FINISH_PAGE_HELP,
      DC_INSTALL)
{
   LOG_CTOR(ADInstallationUnit);
}


ADInstallationUnit::~ADInstallationUnit()
{
   LOG_DTOR(ADInstallationUnit);
}


InstallationReturnType 
ADInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(ADInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS_REBOOT;

   do
   {
      // Set the rerun state to false since DCPromo requires a reboot

      State::GetInstance().SetRerunWizard(false);

      if (IsExpressPathInstall())
      {
         result = InstallServiceExpressPath(logfileHandle, hwnd);
         break;
      }

      // Set the home regkey so that we go through post boot operations

      bool regkeyResult = SetRegKeyValue(
                             CYS_HOME_REGKEY, 
                             CYS_HOME_VALUE, 
                             CYS_HOME_REGKEY_DCPROMO_VALUE,
                             HKEY_LOCAL_MACHINE,
                             true);
      ASSERT(regkeyResult);

      // Run dcpromo.exe

      String commandline(CYS_DCPROMO_COMMAND_LINE);
      DWORD exitCode = 0;

      HRESULT hr = CreateAndWaitForProcess(commandline, exitCode);
      if (FAILED(hr) ||
          exitCode == EXIT_CODE_UNSUCCESSFUL ||
          exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT)
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_HEADING));
         CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_INSTALL));
         CYS_APPEND_LOG(String::load(IDS_LOG_WIZARD_CANCELLED));
         result = INSTALL_FAILURE;
         break;
      }

   } while (false);


   LOG_INSTALL_RETURN(result);

   return result;
}

InstallationReturnType 
ADInstallationUnit::InstallServiceExpressPath(HANDLE /*logfileHandle*/, HWND /*hwnd*/)
{
   LOG_FUNCTION(ADInstallationUnit::InstallServiceExpressPath);

   InstallationReturnType result = INSTALL_SUCCESS_REBOOT;

   // All these regkeys need to be set before we launch DCPromo because DCPromo
   // will reboot the machine

   // First set the home regkey to FirstServer so that we finish up the installation
   // after reboot

   bool regkeyResult = SetRegKeyValue(
                          CYS_HOME_REGKEY, 
                          CYS_HOME_VALUE, 
                          CYS_HOME_REGKEY_FIRST_SERVER_VALUE,
                          HKEY_LOCAL_MACHINE,
                          true);
   ASSERT(regkeyResult);

   // Set the the first DC regkey

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY, 
                     CYS_FIRST_DC_VALUE, 
                     CYS_FIRST_DC_VALUE_SET,
                     HKEY_LOCAL_MACHINE,
                     true);
   ASSERT(regkeyResult);

   // Set the key so CYS runs again

   String emptyString;
   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY, 
                     emptyString, 
                     CYS_HOME_RUN_KEY_RUN_AGAIN,
                     HKEY_CURRENT_USER,
                     true);
   ASSERT(regkeyResult);

   // set the key so CYS has to run again

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY, 
                     CYS_HOME_REGKEY_MUST_RUN, 
                     CYS_HOME_RUN_KEY_RUN_AGAIN,
                     HKEY_LOCAL_MACHINE,
                     true);
   ASSERT(regkeyResult);

   // set the key to let the reboot know what the domain DNS name is

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY,
                     CYS_HOME_REGKEY_DOMAINDNS,
                     GetNewDomainDNSName(),
                     HKEY_LOCAL_MACHINE,
                     true);

   ASSERT(regkeyResult);

   // set the key to let the reboot know what the IP address is

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY,
                     CYS_HOME_REGKEY_DOMAINIP,
                     InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetStaticIPAddressString(),
                     HKEY_LOCAL_MACHINE,
                     true);

   ASSERT(regkeyResult);

   do
   {
      // Create answer file for DCPromo

      String answerFilePath;
      bool answerFileResult = CreateAnswerFileForDCPromo(answerFilePath);

      if (!answerFileResult)
      {
         ASSERT(answerFileResult);
         result = INSTALL_FAILURE;
         break;
      }

      String commandline = String::format(
                              L"dcpromo /answer:%1",
                              answerFilePath.c_str());

      DWORD exitCode = 0;
      HRESULT hr = CreateAndWaitForProcess(commandline, exitCode);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to launch DCPromo: hr = %1!x!",
                hr));
         result = INSTALL_FAILURE;
         break;
      }

      // We can't do anything else here because DCPromo will reboot

   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
ADInstallationUnit::CreateAnswerFileForDCPromo(String& answerFilePath)
{
   LOG_FUNCTION(ADInstallationUnit::CreateAnswerFileForDCPromo);

   bool result = true;

   String answerFileText = L"[DCInstall]\r\n";
   answerFileText += L"ReplicaOrNewDomain=Domain\r\n";
   answerFileText += L"TreeOrChild=Tree\r\n";
   answerFileText += L"CreateOrJoin=Create\r\n";
   answerFileText += L"DomainNetbiosName=";
   answerFileText += GetNewDomainNetbiosName();
   answerFileText += L"\r\n";
   answerFileText += L"NewDomainDNSName=";
   answerFileText += GetNewDomainDNSName();
   answerFileText += L"\r\n";
   answerFileText += L"DNSOnNetwork=No\r\n";
   answerFileText += L"DatabasePath=%systemroot%\\tds\r\n";
   answerFileText += L"LogPath=%systemroot%\\tds\r\n";
   answerFileText += L"SYSVOLPath=%systemroot%\\sysvol\r\n";
   answerFileText += L"SiteName=Default-First-Site\r\n";
   answerFileText += L"RebootOnSuccess=Yes\r\n";
   answerFileText += L"AutoConfigDNS=Yes\r\n";
   answerFileText += L"AllowAnonymousAccess=Yes\r\n";
   answerFileText += L"SafeModeAdminPassword=";
   answerFileText += GetSafeModeAdminPassword();
   answerFileText += L"\r\n";

   String sysFolder = Win::GetSystemDirectory();
   answerFilePath = sysFolder + L"\\dcpromo.inf"; 

   // create the answer file for DCPromo

   LOG(String::format(
          L"Creating answer file at: %1",
          answerFilePath.c_str()));

   HRESULT hr = CreateTempFile(answerFilePath, answerFileText);
   if (FAILED(hr))
   {
      LOG(String::format(
             L"Failed to create answer file for DCPromo: hr = %1!x!",
             hr));
      result = false;
   }

   LOG_BOOL(result);
   return result;
}

bool
ADInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(ADInstallationUnit::IsServiceInstalled);

   bool result = State::GetInstance().IsDC();

   LOG_BOOL(result);
   return result;
}

String
ADInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(ADInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (IsServiceInstalled())
   {
      resourceID = IDS_DOMAIN_CONTROLLER_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}

bool
ADInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(ADInstallationUnit::GetFinishText);

   message = String::load(IDS_DC_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

void
ADInstallationUnit::SetExpressPathInstall(bool isExpressPath)
{
   LOG_FUNCTION2(
      ADInstallationUnit::SetExpressPathInstall,
      (isExpressPath) ? L"true" : L"false");

   isExpressPathInstall = isExpressPath;
}


bool
ADInstallationUnit::IsExpressPathInstall() const
{
   LOG_FUNCTION(ADInstallationUnit::IsExpressPathInstall);

   return isExpressPathInstall;
}

void
ADInstallationUnit::SetNewDomainDNSName(const String& newDomain)
{
   LOG_FUNCTION2(
      ADInstallationUnit::SetNewDomainDNSName,
      newDomain);

   domain = newDomain;
}

void
ADInstallationUnit::SetNewDomainNetbiosName(const String& newNetbios)
{
   LOG_FUNCTION2(
      ADInstallationUnit::SetNewDomainNetbiosName,
      newNetbios);

   netbios = newNetbios;
}


void
ADInstallationUnit::SetSafeModeAdminPassword(const String& newPassword)
{
   LOG_FUNCTION(ADInstallationUnit::SetSafeModeAdminPassword);

   password = newPassword;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\beforebeginpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      BeforeBeginPage.h
//
// Synopsis:  Declares the Before You Begin Page for the CYS
//            wizard.  This page tells the user what they need
//            to do before running CYS.
//
// History:   03/14/2001  JeffJon Created

#ifndef __CYS_BEFOREBEGINPAGE_H
#define __CYS_BEFOREBEGINPAGE_H

#include "CYSWizardPage.h"


class BeforeBeginPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      BeforeBeginPage();

      // Destructor

      virtual 
      ~BeforeBeginPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

      // Message handlers
      
      bool
      OnNotify(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code,
         LPARAM      lParam);

   private:

      void
      InitializeBulletedList();

      HFONT bulletFont;

      // not defined: no copying allowed
      BeforeBeginPage(const BeforeBeginPage&);
      const BeforeBeginPage& operator=(const BeforeBeginPage&);

};

#endif // __CYS_BEFOREBEGINPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\capslockballoontip.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen and cleaned up from johnstep's common cred ui
// ds/win32/credui



#include "pch.h"
#include "CapsLockBalloonTip.hpp"
#include "resource.h"



CapsLockBalloonTip::CapsLockBalloonTip()
   :
   title(String::load(IDS_CAPS_LOCK_TIP_TITLE)),
   text(String::load(IDS_CAPS_LOCK_TIP_TEXT)),
   tipWindow(0),
   parentWindow(0),
   visible(false)
{
   LOG_CTOR(CapsLockBalloonTip);
   ASSERT(!title.empty());
   ASSERT(!text.empty());
}



CapsLockBalloonTip::~CapsLockBalloonTip()
{
   LOG_DTOR(CapsLockBalloonTip);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
      tipWindow = 0;
   }
}



HRESULT
CapsLockBalloonTip::Init(HWND parentWindow_)
{
   LOG_FUNCTION(CapsLockBalloonTip::Init);
   ASSERT(Win::IsWindow(parentWindow_));

   // should not call init on the same instance twice
   
   ASSERT(!parentWindow);
   ASSERT(!tipWindow);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
   }

   HRESULT hr = S_OK;

   do
   {
      hr = Win::CreateWindowEx(
         WS_EX_TOPMOST,
         TOOLTIPS_CLASS,
         L"",
         WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         parentWindow_,
         0,
         0,
         tipWindow);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(tipWindow);
               
      parentWindow = parentWindow_;

      TOOLINFO info;
      ::ZeroMemory(&info, sizeof(info));

      // we want to specify the stem position, so we set TTF_TRACK.  We use
      // the HWND of the parent window as the tool id, because that if what
      // v.5 of comctl32 requires (or the balloon never appears).  This is
      // a bug that has been fixed in v.6, but until fusion manifests are
      // working properly, you can't get v.6
      //
      // (when manifests are working, then we could remove TTF_IDISHWND and
      // set uId to be some fixed integer)
      
      info.uFlags   = TTF_IDISHWND | TTF_TRACK;   
      info.hwnd     = parentWindow;
      info.uId      = reinterpret_cast<UINT_PTR>(parentWindow); 
      info.lpszText = const_cast<PWCHAR>(text.c_str());

      Win::ToolTip_AddTool(tipWindow, info);
      Win::ToolTip_SetTitle(tipWindow, TTI_WARNING, title);
   }
   while (0);

   return hr;
}



void
CapsLockBalloonTip::Show(bool notHidden)
{
//   LOG_FUNCTION(CapsLockBalloonTip::Show);

   TOOLINFO info;
   ::ZeroMemory(&info, sizeof info);

   // set these members the same as in the Init method, in order to
   // identify the proper tool.
   
   info.hwnd = parentWindow; 
   info.uId = reinterpret_cast<UINT_PTR>(parentWindow); 
   
   if (notHidden)
   {
      if (!visible && Win::IsWindowEnabled(parentWindow))
      {
         Win::SetFocus(parentWindow);

         RECT rect;
         Win::GetWindowRect(parentWindow, rect);

         Win::ToolTip_TrackPosition(
            tipWindow,

            // put the stem at the point 90% along the x axis
            
            rect.left + 90 * (rect.right - rect.left) / 100,

            // and 76% along the y axis of the edit control
            
            rect.top + 76 * (rect.bottom - rect.top) / 100);

         Win::ToolTip_TrackActivate(tipWindow, true, info);   

         visible = true;
      }
   }
   else
   {
      // hide the tip window
      
      if (visible)
      {
         Win::ToolTip_TrackActivate(tipWindow, false, info);   
         visible = false;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\capslockballoontip.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef CAPSLOCKBALLOONTIP_HPP_INCLUDED
#define CAPSLOCKBALLOONTIP_HPP_INCLUDED



// Class used to show a balloon-style tool tip window that complains to the
// user that caps lock is on.  Used by PasswordEditBox.

class CapsLockBalloonTip
{
   public:



   CapsLockBalloonTip();



   // destroys the tool tip window, if it still exists
      
   ~CapsLockBalloonTip();


   // Initialize the tool tip, but don't show it.
   // 
   // parentWindow - in, the parent window handle of the control to have the
   // tool tip.  (The password edit control window).
   
   HRESULT
   Init(HWND parentWindow);
   


   // Show or hide the tip window.
   //
   // notHidden - in, if true, show the window.  If false, hide it.

   void
   Show(bool notHidden);
   

   
   private:

   // not implemented: no copying allowed

   CapsLockBalloonTip(const CapsLockBalloonTip&);
   const CapsLockBalloonTip& operator=(const CapsLockBalloonTip&);

   String title;
   String text;
   bool   visible;
   HWND   tipWindow;
   HWND   parentWindow;
};



#endif   // CAPSLOCKBALLOONTIP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\clusterinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ClusterInstallationUnit.cpp
//
// Synopsis:  Defines a ClusterInstallationUnit
//            This object has the knowledge for installing the
//            clustering service
//
// History:   02/09/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "ClusterInstallationUnit.h"

#include <clusapi.h>

// Finish page help 
static PCWSTR CYS_CLUSTER_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_cluster_server.htm";


ClusterInstallationUnit::ClusterInstallationUnit() :
   makeNewCluster(true),
   InstallationUnit(
      IDS_CLUSTER_SERVER_TYPE, 
      IDS_CLUSTER_SERVER_DESCRIPTION, 
      CYS_CLUSTER_FINISH_PAGE_HELP,
      CLUSTERSERVER_INSTALL)
{
   LOG_CTOR(ClusterInstallationUnit);
}


ClusterInstallationUnit::~ClusterInstallationUnit()
{
   LOG_DTOR(ClusterInstallationUnit);
}


InstallationReturnType
ClusterInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(ClusterInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Log heading

   CYS_APPEND_LOG(String::load(IDS_LOG_CLUSTER_HEADING));

   String commandLine;

   // Build the command line

   if (MakeNewCluster())
   {
      commandLine = L"cluster /Create /Wizard";
   }
   else
   {
      commandLine = L"cluster /Add /Wizard";
   }

   // Run the wizard

   DWORD exitCode = 0;
   HRESULT hr = CreateAndWaitForProcess(commandLine, exitCode);
   if (FAILED(hr))
   {
      // Failed to launch the wizard

      LOG(String::format(
             L"Failed to launch cluster wizard: hr = 0x%1!x!",
             hr));

      if (MakeNewCluster())
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_LAUNCH_FAILED_NEW_CLUSTER)); 
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_LAUNCH_FAILED_ADD_NODE)); 
      }
      
      result = INSTALL_FAILURE;
   }
   else if (SUCCEEDED(hr) &&
            exitCode == 0)
   {
      // Wizard was launched and completed successfully

      LOG(L"Cluster wizard launched and completed successfully");

      if (MakeNewCluster())
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_SUCCESS_NEW_CLUSTER));
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_SUCCESS_ADD_NODE));
      }

      result = INSTALL_FAILURE;
   }
   else // if (SUCCEEDED(hr) && exitCode == ????<some exit code for cancelled>???
   {
      // Wizard was cancelled by the user

      LOG(L"Cluster wizard cancelled by user");

      if (MakeNewCluster())
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_CANCELLED_NEW_CLUSTER));
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_CANCELLED_ADD_NODE));
      }
      
      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
ClusterInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(ClusterInstallationUnit::IsServiceInstalled);

   bool result = false;

   DWORD clusterState = 0;
   DWORD err = ::GetNodeClusterState(0, &clusterState);
   if (err == ERROR_SUCCESS &&
       clusterState != ClusterStateNotConfigured)
   {
      result = true;
   }
   else
   {
      LOG(String::format(
             L"GetNodeClusterState returned err = %1!x!",
             err));
   }

   LOG_BOOL(result);

   return result;
}

bool
ClusterInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(ClusterInstallationUnit::GetFinishText);

   if (MakeNewCluster())
   {
      message = String::load(IDS_CLUSTER_FINISH_TEXT_NEW_CLUSTER);
   }
   else
   {
      message = String::load(IDS_CLUSTER_FINISH_TEXT_EXISTING_CLUSTER);
   }

   LOG_BOOL(true);
   return true;
}

String
ClusterInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(ClusterInstallationUnit::GetServiceDescription);

   unsigned int descriptionID = IDS_CLUSTER_SERVER_DESCRIPTION;

   if (IsServiceInstalled())
   {
      descriptionID = IDS_CLUSTER_SERVER_DESCRIPTION_INSTALLED;
   }

   return String::load(descriptionID);
}

bool
ClusterInstallationUnit::MakeNewCluster() const
{
   LOG_FUNCTION(ClusterInstallationUnit::MakeNewCluster);
   
   return makeNewCluster;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\clusterpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ClusterPage.h
//
// Synopsis:  Declares the Cluster Page for the CYS
//            wizard.  This page lets the user choose
//            between a new cluster or existing cluster
//
// History:   03/19/2001  JeffJon Created

#ifndef __CYS_CLUSTERPAGE_H
#define __CYS_CLUSTERPAGE_H

#include "CYSWizardPage.h"


class ClusterPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      ClusterPage();

      // Destructor

      virtual 
      ~ClusterPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      ClusterPage(const ClusterPage&);
      const ClusterPage& operator=(const ClusterPage&);

};

#endif // __CYS_CLUSTERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\clusterinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ClusterInstallationUnit.h
//
// Synopsis:  Declares a ClusterInstallationUnit
//            This object has the knowledge for installing the
//            clustering service
//
// History:   02/09/2001  JeffJon Created

#ifndef __CYS_CLUSTERINSTALLATIONUNIT_H
#define __CYS_CLUSTERINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class ClusterInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      ClusterInstallationUnit();

      // Destructor

      virtual
      ~ClusterInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      String
      GetServiceDescription();

      void
      SetNewCluster(bool newCluster) { makeNewCluster = newCluster; }

      bool
      MakeNewCluster() const;

   private:

      bool makeNewCluster;
};

#endif // __CYS_CLUSTERINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\clusterpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ClusterPage.cpp
//
// Synopsis:  Defines the Cluster Page for the CYS
//            wizard.  This page lets the user choose
//            between a new cluster or existing cluster
//
// History:   03/19/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "ClusterPage.h"
#include "state.h"


static PCWSTR CLUSTER_PAGE_HELP = L"cys.chm::/configuring_cluster_server.htm";

ClusterPage::ClusterPage()
   :
   CYSWizardPage(
      IDD_CLUSTER_SERVER_PAGE, 
      IDS_CLUSTER_TITLE, 
      IDS_CLUSTER_SUBTITLE, 
      CLUSTER_PAGE_HELP)
{
   LOG_CTOR(ClusterPage);
}

   

ClusterPage::~ClusterPage()
{
   LOG_DTOR(ClusterPage);
}


void
ClusterPage::OnInit()
{
   LOG_FUNCTION(ClusterPage::OnInit);

   Win::Button_SetCheck(Win::GetDlgItem(hwnd, IDC_YES_RADIO), BST_CHECKED);
}

bool
ClusterPage::OnSetActive()
{
   LOG_FUNCTION(ClusterPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}

int
ClusterPage::Validate()
{
   LOG_FUNCTION(ClusterPage::Validate);

   bool newCluster = 
     Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_YES_RADIO)) == BST_CHECKED; 

   InstallationUnitProvider::GetInstance().GetClusterInstallationUnit().SetNewCluster(newCluster);

   return IDD_FINISH_PAGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\customserverpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      CustomServerPage.h
//
// Synopsis:  Declares the Custom Server Page for the CYS
//            wizard
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_CUSTOMSERVERPAGE_H
#define __CYS_CUSTOMSERVERPAGE_H

#include "CYSWizardPage.h"


class CustomServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      CustomServerPage();

      // Destructor

      virtual 
      ~CustomServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // Message handlers
      
      virtual
      bool
      OnNotify(
         HWND        windowFrom,
         UINT_PTR    controlIDFrom,
         UINT        code,
         LPARAM      lParam);

      // CYSWizardPage overrides

      virtual
      int
      Validate();


      void
      InitializeServerListView();

      void
      FillServerTypeList();

      void
      SetDescriptionForSelection();

   private:

      // not defined: no copying allowed
      CustomServerPage(const CustomServerPage&);
      const CustomServerPage& operator=(const CustomServerPage&);

};

#endif // __CYS_CUSTOMSERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\common.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      common.cpp
//
// Synopsis:  Commonly used functions
//
// History:   02/03/2001  JeffJon Created

#include "pch.h"

#include "resource.h"

#include <ciodm.h>


// Creates the fonts for setLargeFonts().
// 
// hDialog - handle to a dialog to be used to retrieve a device
// context.
// 
// bigBoldFont - receives the handle of the big bold font created.

void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BIG_BOLD_FONT_NAME);

      // ensure null termination 260237

      memset(bigBoldLogFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.length();
      fontName.copy(
         bigBoldLogFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));

      unsigned fontSize = 0;
      String::load(IDS_BIG_BOLD_FONT_SIZE).convert(fontSize);
      ASSERT(fontSize);
 
      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            Win::GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      hr = Win::CreateFontIndirect(bigBoldLogFont, bigBoldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}



void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = Win::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      Win::SetWindowFont(control, font, true);
   }
}



void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}


bool
IsServiceInstalledHelper(const wchar_t* serviceName)
{
   LOG_FUNCTION2(IsServiceInstalledHelper, serviceName);
   ASSERT(serviceName);

   // if we can open the service, then it is installed

   bool result = false;

   SC_HANDLE hsc =
      ::OpenSCManager(0, SERVICES_ACTIVE_DATABASE, GENERIC_READ);

   if (hsc)
   {
      SC_HANDLE hs = ::OpenServiceW(hsc, serviceName, GENERIC_READ);

      if (hs)
      {
         ::CloseServiceHandle(hs);
         result = true;
      }

      ::CloseServiceHandle(hsc);
   }

   return result;
}


// Wait for a handle to become signalled, or a timeout to expire, or WM_QUIT
// to appear in the message queue.  Pump the message queue while we wait.
// 
// WARNING: UI should diable itself before calling any function that invokes
// this function, or functions calling this one should guard against
// re-entrance.  Otherwise there will be a re-entrancy problem.
// 
// e.g. command handler gets button clicked message, calls a func that calls
// this wait function, then user clicks the button again, command handler call
// a func that calls this one, and so on.

DWORD
MyWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
   LOG_FUNCTION(MyWaitForSendMessageThread);
   ASSERT(hThread);

    MSG msg;
    DWORD dwRet;
    DWORD dwEnd = GetTickCount() + dwTimeout;
    bool quit = false;

    // We will attempt to wait up to dwTimeout for the thread to
    // terminate

    do 
    {
        dwRet = MsgWaitForMultipleObjects(1, &hThread, FALSE,
                dwTimeout, QS_ALLEVENTS | QS_SENDMESSAGE );

        if (dwRet == (WAIT_OBJECT_0 + 1))
        {
            // empty out the message queue.  We call DispatchMessage to
            // ensure that we still process the WM_PAINT messages.
            // DANGER:  Make sure that the CYS UI is completely disabled
            // or there will be re-entrancy problems here

            while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
               if (msg.message == WM_QUIT)
               {
                  // Need to re-post this so that we know to close CYS

                  ::PostMessage(msg.hwnd, WM_QUIT, 0, 0);
                  quit = true;
                  break;
               }
               ::TranslateMessage(&msg);
               ::DispatchMessage(&msg);
            }

            // Calculate if we have any more time left in the timeout to
            // wait on.

            if (dwTimeout != INFINITE)
            {
                dwTimeout = dwEnd - GetTickCount();
                if ((long)dwTimeout <= 0)
                {
                    // No more time left, fail with WAIT_TIMEOUT
                    dwRet = WAIT_TIMEOUT;
                }
            }
        }

        // dwRet == WAIT_OBJECT_0 || dwRet == WAIT_FAILED
        // The thread must have exited, so we are happy
        //
        // dwRet == WAIT_TIMEOUT
        // The thread is taking too long to finish, so just
        // return and let the caller kill it

    } while (dwRet == (WAIT_OBJECT_0 + 1) && !quit);

    return(dwRet);
}


HRESULT
CreateAndWaitForProcess(const String& commandLine, DWORD& exitCode)
{
   LOG_FUNCTION2(CreateAndWaitForProcess, commandLine);
   ASSERT(!commandLine.empty());

   exitCode = 0;

   HRESULT hr = S_OK;
   do
   {
      PROCESS_INFORMATION procInfo;
      memset(&procInfo, 0, sizeof(procInfo));

      STARTUPINFO startup;
      memset(&startup, 0, sizeof(startup));

      String commandLine2(commandLine);
         
      LOG(L"Calling CreateProcess");
      LOG(commandLine2);

      hr =
         Win::CreateProcess(
            commandLine2,
            0,
            0,
            false,
            0,
            0,
            String(),
            startup,
            procInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(procInfo.hProcess);

      DWORD dwRet = MyWaitForSendMessageThread(procInfo.hProcess, INFINITE);

      ASSERT(dwRet == WAIT_OBJECT_0);

      hr = Win::GetExitCodeProcess(procInfo.hProcess, exitCode);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::CloseHandle(procInfo.hThread);
      Win::CloseHandle(procInfo.hProcess);
   }
   while (0);

   LOG(String::format(L"exit code = %1!x!", exitCode));
   LOG_HRESULT(hr);

   return hr;
}


HRESULT
MyCreateProcess(const String& commandLine)
{
   LOG_FUNCTION2(MyCreateProcess, commandLine);
   ASSERT(!commandLine.empty());

   HRESULT hr = S_OK;
   do
   {
      PROCESS_INFORMATION procInfo;
      memset(&procInfo, 0, sizeof(procInfo));

      STARTUPINFO startup;
      memset(&startup, 0, sizeof(startup));

      String commandLine2(commandLine);
         
      LOG(L"Calling CreateProcess");
      LOG(commandLine2);

      hr =
         Win::CreateProcess(
            commandLine2,
            0,
            0,
            false,
            0,
            0,
            String(),
            startup,
            procInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(procInfo.hProcess);

      Win::CloseHandle(procInfo.hThread);
      Win::CloseHandle(procInfo.hProcess);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

bool
IsKeyValuePresent(RegistryKey& key, const String& valueKey)
{
   LOG_FUNCTION(IsKeyValuePresent);

   bool result = false;

   do 
   {

      String value;
      HRESULT hr = key.GetValue(valueKey, value);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to read regkey %1 because: hr = %2!x!",
                valueKey,
                hr));
         break;
      }

      if (!value.empty())
      {
         result = true;
         break;
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}


bool
GetRegKeyValue(
   const String& keyName, 
   const String& value, 
   String& resultString,
   HKEY parentKey)
{
   LOG_FUNCTION(GetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      hr = key.Open(parentKey, keyName);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.GetValue(value, resultString);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to read regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

      LOG(String::format(
             L"Value of key: %1",
             resultString.c_str()));

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
GetRegKeyValue(
   const String& keyName, 
   const String& value, 
   DWORD& resultValue,
   HKEY parentKey)
{
   LOG_FUNCTION(GetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      hr = key.Open(parentKey, keyName);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.GetValue(value, resultValue);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to read regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

      LOG(String::format(
             L"Key value: %1!d!",
             resultValue));

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
SetRegKeyValue(
   const String& keyName, 
   const String& value, 
   const String& newString,
   HKEY parentKey,
   bool create
)
{
   LOG_FUNCTION(SetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      if (create)
      {
         hr = key.Create(parentKey, keyName);
      }
      else
      {
         hr = key.Open(parentKey, keyName, KEY_ALL_ACCESS);
      }
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.SetValue(value, newString);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to write regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
SetRegKeyValue(
   const String& keyName, 
   const String& value, 
   DWORD newValue,
   HKEY parentKey,
   bool create)
{
   LOG_FUNCTION(SetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      if (create)
      {
         hr = key.Create(parentKey, keyName);
      }
      else
      {
         hr = key.Open(parentKey, keyName, KEY_WRITE);
      }
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.SetValue(value, newValue);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to write regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
IsIndexingServiceOn()
{
   LOG_FUNCTION(IsIndexingServiceOn);

   bool result = false;

   do
   {
      CLSID clsid;
      HRESULT hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get the CLSID from ProgID: hr = 0x%x",
                hr));
         break;
      }

      SmartInterface<IAdminIndexServer> adminIndexServer;
      hr = adminIndexServer.AcquireViaCreateInstance(
              clsid,
              0,
              CLSCTX_INPROC_SERVER);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to CoCreateInstance of IAdminIndexServer: hr = 0x%x",
                hr));
         break;
      }

      VARIANT_BOOL var;
      hr = adminIndexServer->IsRunning(&var);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get running state: hr = 0x%x",
                hr));
         break;
      }

      result = var ? true : false;

   } while (false);

   LOG_BOOL(result);

   return result;
}

HRESULT
ModifyIndexingService(bool turnOn)
{
   LOG_FUNCTION2(
      ModifyIndexingService,
      turnOn ? L"true" : L"false");

   HRESULT hr = S_OK;

   do
   {
      CLSID clsid;
      hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get the CLSID from ProgID: hr = 0x%x",
                hr));
         break;
      }

      SmartInterface<IAdminIndexServer> adminIndexServer;
      hr = adminIndexServer.AcquireViaCreateInstance(
              clsid,
              0,
              CLSCTX_INPROC_SERVER);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to CoCreateInstance of IAdminIndexServer: hr = 0x%x",
                hr));
         break;
      }

      if (turnOn)
      {
         hr = adminIndexServer->Start();
      }
      else
      {
         hr = adminIndexServer->Stop();
      }

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to start or stop indexing service: hr = 0x%x",
                hr));

         break;
      }

   } while (false);

   LOG(String::format(L"hr = %1!x!", hr));

   return hr;
}

HRESULT
StartIndexingService()
{
   return ModifyIndexingService(true);
}

HRESULT
StopIndexingService()
{
   return ModifyIndexingService(false);
}



// return true if the name is a reserved name, false otherwise.  If true, also
// set message to an error message describing the problem.

bool
IsReservedDnsName(const String& dnsName, String& message)
{
   LOG_FUNCTION2(IsReservedDnsName, dnsName);
   ASSERT(!dnsName.empty());

   message.erase();
   bool result = false;

// We're still trying to decide if we should restrict these names
//
//    // names with these as the last labels are illegal.
// 
//    static const String RESERVED[] =
//    {
//       L"in-addr.arpa",
//       L"ipv6.int",
// 
//       // RFC 2606 documents these:
// 
//       L"test",
//       L"example",
//       L"invalid",
//       L"localhost",
//       L"example.com",
//       L"example.org",
//       L"example.net"
//    };
// 
//    String name(dnsName);
//    name.to_upper();
//    if (name[name.length() - 1] == L'.')
//    {
//       // remove the trailing dot
// 
//       name.resize(name.length() - 1);
//    }
// 
//    for (int i = 0; i < sizeof(RESERVED) / sizeof(String); ++i)
//    {
//       String res = RESERVED[i];
//       res.to_upper();
// 
//       size_t pos = name.rfind(res);
// 
//       if (pos == String::npos)
//       {
//          continue;
//       }
// 
//       if (pos == 0 && name.length() == res.length())
//       {
//          ASSERT(name == res);
// 
//          result = true;
//          message =
//             String::format(
//                IDS_RESERVED_NAME,
//                dnsName.c_str());
//          break;
//       }
// 
//       if ((pos == name.length() - res.length()) && (name[pos - 1] == L'.'))
//       {
//          // the name has reserved as a suffix.
// 
//          result = true;
//          message =
//             String::format(
//                IDS_RESERVED_NAME_SUFFIX,
//                dnsName.c_str(),
//                RESERVED[i].c_str());
//          break;
//       }
//    }

   return result;
}


bool
ValidateDomainDnsNameSyntax(
   HWND  dialog,      
   int   editResID,   
   bool  warnOnNonRFC,
   bool* isNonRFC)    
{
   return
      ValidateDomainDnsNameSyntax(
         dialog,
         String(),
         editResID,
         warnOnNonRFC,
         isNonRFC);
}


bool
ValidateDomainDnsNameSyntax(
   HWND           dialog,
   const String&  domainName,
   int            editResID,
   bool           warnOnNonRFC,
   bool*          isNonRFC)
{
   LOG_FUNCTION(ValidateDomainDnsNameSyntax);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   bool valid = false;
   String message;
   String dnsName =
         domainName.empty()
      ?  Win::GetTrimmedDlgItemText(dialog, editResID)
      :  domainName;
   if (isNonRFC)
   {
      *isNonRFC = false;
   }

   LOG(L"validating " + dnsName);

   switch (
      Dns::ValidateDnsNameSyntax(
         dnsName,
         DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8) )
   {
      case Dns::NON_RFC:
      {
         if (isNonRFC)
         {
            *isNonRFC = true;
         }
         if (warnOnNonRFC)
         {
            // warn about non-rfc names

            String msg = String::format(IDS_NON_RFC_NAME, dnsName.c_str());
            popup.Info(
               dialog,
               msg);

            LOG(msg);
         }

         // fall through
         //lint -e616   allow fall thru
      }
      case Dns::VALID:
      {
         valid = !IsReservedDnsName(dnsName, message);
         break;
      }
      case Dns::TOO_LONG:
      {
         message =
            String::format(
               IDS_DNS_NAME_TOO_LONG,
               dnsName.c_str(),
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
         break;
      }
      case Dns::NUMERIC:
      case Dns::BAD_CHARS:
      case Dns::INVALID:
      default:
      {
         message =
            String::format(
               IDS_BAD_DNS_SYNTAX,
               dnsName.c_str(),
               Dns::MAX_LABEL_LENGTH);
         break;
      }
   }

   if (!valid)
   {
      popup.Gripe(dialog, editResID, message);
   }

   return valid;
}



bool
ConfirmNetbiosLookingNameIsReallyDnsName(HWND parentDialog, int editResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(editResID > 0);

   // check if the name is a single DNS label (a single label with a trailing
   // dot does not count.  If the user is DNS-saavy enough to use an absolute
   // DNS name, then we will pester him no further.)

   String domain = Win::GetTrimmedDlgItemText(parentDialog, editResID);
   if (domain.find(L'.') == String::npos)
   {
      // no dot found: must be a single label

      if (
         popup.MessageBox(
            parentDialog,
            String::format(
               IDS_CONFIRM_NETBIOS_LOOKING_NAME,
               domain.c_str(),
               domain.c_str()),
            MB_YESNO) == IDNO)
      {
         // user goofed.  or we frightened them.

         HWND edit = Win::GetDlgItem(parentDialog, editResID);
         Win::SendMessage(edit, EM_SETSEL, 0, -1);
         Win::SetFocus(edit);
         return false;
      }
   }

   return true;
}



HRESULT
VariantArrayToStringList(VARIANT* variant, StringList& stringList)
{
   LOG_FUNCTION(VariantArrayToStringList);

   ASSERT(variant);
   ASSERT(V_VT(variant) == (VT_ARRAY | VT_BSTR));

   HRESULT hr = S_OK;

   stringList.clear();

   SAFEARRAY* psa = V_ARRAY(variant);

   do
   {
      ASSERT(psa);
      ASSERT(psa != (SAFEARRAY*)-1);

      if (!psa or psa == (SAFEARRAY*)-1)
      {
         LOG(L"variant not safe array");
         break;
      }

      if (::SafeArrayGetDim(psa) != 1)
      {
         LOG(L"safe array: wrong number of dimensions");
         break;
      }

      VARTYPE vt = VT_EMPTY;
      hr = ::SafeArrayGetVartype(psa, &vt);
      if (FAILED(hr) || vt != VT_BSTR)
      {
         LOG(L"safe array: wrong element type");
         break;
      }

      long lower = 0;
      long upper = 0;
     
      hr = ::SafeArrayGetLBound(psa, 1, &lower);
      if (FAILED(hr))
      {
         LOG(L"can't get lower bound");      
         break;
      }

      hr = ::SafeArrayGetUBound(psa, 1, &upper);
      if (FAILED(hr))
      {
         LOG(L"can't get upper bound");      
         break;
      }
      
      for (long i = lower; i <= upper; ++i)
      {
         BSTR item;
         hr = ::SafeArrayGetElement(psa, &i, &item);
         if (FAILED(hr))
         {
            LOG(String::format(L"index %1!d! failed", i));
            continue;
         }

         if (item)
         {
            stringList.push_back(String(item));
         }

         ::SysFreeString(item);
      }
      
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\customserverpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      CustomServerPage.cpp
//
// Synopsis:  Defines Custom Server Page for the CYS
//            Wizard
//
// History:   02/06/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "CustomServerPage.h"
#include "state.h"

typedef struct _CustomInstallationTypes
{
   InstallationUnitType installationType;
   DWORD                productSKUs;
} CustomInstallationType;


// table of items that are available in the server type list box
CustomInstallationType serverTypeTable[] =
{
   {  DNS_INSTALL,                CYS_ALL_SERVER_SKUS                        },
   {  DHCP_INSTALL,               CYS_ALL_SERVER_SKUS                        },
   {  WINS_INSTALL,               CYS_ALL_SERVER_SKUS                        },
   {  RRAS_INSTALL,               CYS_ALL_SERVER_SKUS                        },
   {  APPLICATIONSERVER_INSTALL,  CYS_ALL_SERVER_SKUS                        },
   {  FILESERVER_INSTALL,         CYS_ALL_SERVER_SKUS                        },
   {  PRINTSERVER_INSTALL,        CYS_ALL_SERVER_SKUS                        },
   {  SHAREPOINT_INSTALL,         CYS_SERVER | CYS_ADVANCED_SERVER | CYS_32BIT }, // notice: this excludes 64bit
   {  MEDIASERVER_INSTALL,        CYS_ALL_SKUS_NO_64BIT                      },
   {  WEBSERVER_INSTALL,          CYS_ALL_SERVER_SKUS                        },
   {  DC_INSTALL,                 CYS_ALL_SERVER_SKUS                        },
   {  CLUSTERSERVER_INSTALL,      CYS_ADVANCED_SERVER | CYS_DATACENTER_SERVER | CYS_32BIT }
};

static PCWSTR CUSTOM_PAGE_HELP = L"cys.chm::/cys_configuring_networking_infrastructure.htm";

CustomServerPage::CustomServerPage()
   :
   CYSWizardPage(
      IDD_CUSTOM_SERVER_PAGE, 
      IDS_CUSTOM_SERVER_TITLE, 
      IDS_CUSTOM_SERVER_SUBTITLE, 
      CUSTOM_PAGE_HELP)
{
   LOG_CTOR(CustomServerPage);
}

   

CustomServerPage::~CustomServerPage()
{
   LOG_DTOR(CustomServerPage);
}


void
CustomServerPage::OnInit()
{
   LOG_FUNCTION(CustomServerPage::OnInit);

   InitializeServerListView();
   FillServerTypeList();
}


void
CustomServerPage::InitializeServerListView()
{
   LOG_FUNCTION(CustomServerPage::InitializeServerListView);

   // Prepare a column

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   RECT rect;
   Win::GetClientRect(hwndBox, rect);

   // Get the width of a scroll bar

   int scrollThumbWidth = ::GetSystemMetrics(SM_CXHTHUMB);

   // net width of listview

   int netWidth = rect.right - scrollThumbWidth - ::GetSystemMetrics(SM_CXBORDER);

   // Set full row select

   ListView_SetExtendedListViewStyle(
      hwndBox, 
      LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);

   // Get the size of the listview


   LVCOLUMN column;
   ZeroMemory(&column, sizeof(LVCOLUMN));

   column.mask = LVCF_WIDTH | LVCF_TEXT;

   // Use 80 percent of the width minus the scrollbar for the role and the rest for the status

   column.cx = static_cast<int>(netWidth * 0.8);

   String columnHeader = String::load(IDS_SERVER_ROLE_COLUMN_HEADER);
   column.pszText = const_cast<wchar_t*>(columnHeader.c_str());

   Win::ListView_InsertColumn(
      hwndBox,
      0,
      column);

   // Add the status column

   columnHeader = String::load(IDS_STATUS_COLUMN_HEADER);
   column.pszText = const_cast<wchar_t*>(columnHeader.c_str());

   column.cx = netWidth - column.cx;

   Win::ListView_InsertColumn(
      hwndBox,
      1,
      column);
}

void
CustomServerPage::FillServerTypeList()
{
   LOG_FUNCTION(CustomServerPage::FillServerTypeList);

   // Load the status strings

   String statusCompleted = String::load(IDS_STATUS_COMPLETED);

   // loop throught the table putting all the server 
   // types in the listbox

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   int serverTableSize = 
      sizeof(serverTypeTable) / sizeof(CustomInstallationType);

   for (int index = 0; index < serverTableSize; index++)
   {
      // Special case AD installation so that it is not available if
      // CertServer is installed
      if (serverTypeTable[index].installationType == DC_INSTALL)
      {
         if (NTService(L"CertSvc").IsInstalled())
         {
            continue;
         }
      }

      // Load the string for the type of server and add it to the list
      // Filter out roles by SKU and platform

      LOG(String::format(
             L"Current role SKUs: 0x%1!x!",
             serverTypeTable[index].productSKUs));

      DWORD sku = State::GetInstance().GetProductSKU();

      LOG(String::format(
             L"Verifying against computer sku: 0x%1!x!",
             sku));

      if (sku & serverTypeTable[index].productSKUs)
      {
         DWORD platform = State::GetInstance().GetPlatform();

         LOG(String::format(
                L"Verifying against computer platform: 0x%1!x!",
                platform));

         if (platform & serverTypeTable[index].productSKUs)
         {
            String serverTypeName = 
               InstallationUnitProvider::GetInstance().GetInstallationUnitForType(
                  serverTypeTable[index].installationType).GetServiceName();
            bool isInstalled =
               InstallationUnitProvider::GetInstance().GetInstallationUnitForType(
                  serverTypeTable[index].installationType).IsServiceInstalled();

            LVITEM listItem;
            ZeroMemory(&listItem, sizeof(LVITEM));

            listItem.iItem = index;
            listItem.mask = LVIF_TEXT | LVIF_PARAM;
            listItem.pszText = const_cast<wchar_t*>(serverTypeName.c_str());

            listItem.lParam = serverTypeTable[index].installationType;

            int newItem = Win::ListView_InsertItem(
                             hwndBox, 
                             listItem);

            ASSERT(newItem >= 0);
            LOG(String::format(
                   L"New role inserted: %1 at index %2!d!",
                   serverTypeName.c_str(),
                   newItem));

            // if the service is installed fill the status column

            if (isInstalled)
            {
               Win::ListView_SetItemText(
                  hwndBox,
                  newItem,
                  1,
                  statusCompleted);
            }
         }
         else
         {
            LOG(String::format(
                   L"Role not supported for this platform: 0x%1!x! role: 0x%2!x!",
                   platform,
                   serverTypeTable[index].productSKUs));
         }
      }
      else
      {
         LOG(String::format(
                L"Role does not for this SKU: 0x%1!x! role: 0x%2!x!",
                State::GetInstance().GetProductSKU(),
                serverTypeTable[index].productSKUs));
      }
   }
}


bool
CustomServerPage::OnSetActive()
{
   LOG_FUNCTION(CustomServerPage::OnSetActive);

   // make sure something is selected in the list box
   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);
   if (currentSelection <= 0)
   {
      // Select the first item

      ListView_SetItemState(hwndBox, 0, LVIS_SELECTED, LVIS_SELECTED);
   }

   SetDescriptionForSelection();


   return true;
}

void
CustomServerPage::SetDescriptionForSelection()
{
   LOG_FUNCTION(CustomServerPage::SetDescriptionForSelection);

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);

   ASSERT(currentSelection >= 0);

   // Now that we know the selection, find the installation type

   LVITEM item;
   ZeroMemory(&item, sizeof(item));

   item.iItem = currentSelection;
   item.mask = LVIF_PARAM;

   bool result = Win::ListView_GetItem(hwndBox, item);
   ASSERT(result);

   LPARAM value = item.lParam;

   LOG(String::format(
         L"Selection = %1!d!, type = %2!d!",
         currentSelection,
         value));

   // fill in the description text for the selected item

   HWND hwndDescription = Win::GetDlgItem(hwnd, IDC_TYPE_DESCRIPTION_STATIC);

   int serverTableSize = 
      sizeof(serverTypeTable) / sizeof(CustomInstallationType);

   for (int index = 0; index < serverTableSize; index++)
   {
      if (serverTypeTable[index].installationType == value)
      {
         // Load the description for the type of server and put it in the
         // static control

         String serverTypeDescription = 
            InstallationUnitProvider::GetInstance().GetInstallationUnitForType(
              serverTypeTable[index].installationType).GetServiceDescription();

         Win::SetWindowText(hwndDescription, serverTypeDescription);

         bool isServiceInstalled = 
            InstallationUnitProvider::GetInstance().GetInstallationUnitForType(
               serverTypeTable[index].installationType).IsServiceInstalled();

         // Set the wizard buttons

         Win::PropSheet_SetWizButtons(
            Win::GetParent(hwnd), 
            isServiceInstalled ? PSWIZB_BACK : PSWIZB_NEXT | PSWIZB_BACK);

         break;
      }
   }
}


bool
CustomServerPage::OnNotify(
   HWND        /*windowFrom*/,
   UINT_PTR    controlIDFrom,
   UINT        code,
   LPARAM      lParam)
{
//   LOG_FUNCTION(CustomServerPage::OnCommand);
 
   bool result = false;

   if (IDC_SERVER_TYPE_LIST == controlIDFrom &&
       code == LVN_ITEMCHANGED)
   {
      LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(lParam);
      if (pnmv && pnmv->uNewState & LVNI_SELECTED)
      {
         SetDescriptionForSelection();
         result = true;
      }
   }
   return result;
}


int
CustomServerPage::Validate()
{
   LOG_FUNCTION(CustomServerPage::Validate);

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);

   ASSERT(currentSelection >= 0);

   // Now that we know the selection, find the installation type

   LVITEM item;
   ZeroMemory(&item, sizeof(item));

   item.iItem = currentSelection;
   item.mask = LVIF_PARAM;

   bool result = Win::ListView_GetItem(hwndBox, item);
   ASSERT(result);

   // set the current install to the selected installation unit

   InstallationUnitProvider::GetInstance().SetCurrentInstallationUnit(
      static_cast<InstallationUnitType>(item.lParam));

   int nextPage = -1;

   switch (item.lParam)
   {
      case CLUSTERSERVER_INSTALL:
         nextPage = IDD_CLUSTER_SERVER_PAGE;
         break;

      case PRINTSERVER_INSTALL:
         nextPage = IDD_PRINT_SERVER_PAGE;
         break;

      case SHAREPOINT_INSTALL:
         if (!InstallationUnitProvider::GetInstance().GetWebInstallationUnit().IsServiceInstalled())
         {
            nextPage = IDD_FINISH_PAGE;
         }
         else
         {
            if (InstallationUnitProvider::GetInstance().GetSharePointInstallationUnit().IsThereAPageToReplace())
            {
               LOG(L"There is a page to replace");
               nextPage = IDD_SHARE_POINT_PAGE;
            }
            else
            {
               LOG(L"There is no page to replace");
               nextPage = IDD_FINISH_PAGE;
            }
         }
         break;

      case APPLICATIONSERVER_INSTALL:
         if (State::GetInstance().GetProductSKU() == CYS_SERVER)
         {
            nextPage = IDD_FINISH_PAGE;
         }
         else
         {
            if (InstallationUnitProvider::GetInstance().GetApplicationInstallationUnit().GetApplicationMode() == 1)
            {
               nextPage = IDD_FINISH_PAGE;
            }
            else
            {
               nextPage = IDD_TERMINAL_SERVER_PAGE;
            }
         }
         break;

      case FILESERVER_INSTALL:
         if (State::GetInstance().HasNTFSDrive())
         {
            nextPage = IDD_FILE_SERVER_PAGE;
         }
         else
         {
            if (!InstallationUnitProvider::GetInstance().GetSharePointInstallationUnit().IsServiceInstalled())
            {
               nextPage = IDD_INDEXING_PAGE;
            }
            else
            {
               ASSERT(false && L"Next button should have been disabled!");
            }
         }
         break;

      default:
         nextPage = IDD_FINISH_PAGE;
         break;
   }

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\cyswizardpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      CYSWizardPage.cpp
//
// Synopsis:  Defines the base class for the wizard
//            pages used for CYS.  It is a subclass
//            of WizardPage found in Burnslib
//
// History:   02/03/2001  JeffJon Created


#include "pch.h"

#include "resource.h"

#include "CYSWizardPage.h"
#include "State.h"


CYSWizardPage::CYSWizardPage(
   int    dialogResID,
   int    titleResID,
   int    subtitleResID,   
   PCWSTR pageHelpString,
   bool   hasHelp,
   bool   isInteriorPage)
   :
   WizardPage(dialogResID, titleResID, subtitleResID, isInteriorPage, hasHelp)
{
   LOG_CTOR(CYSWizardPage);

   if (hasHelp)
   {
      ASSERT(pageHelpString);
      if (pageHelpString)
      {
         helpString = pageHelpString;
      }
   }
}

   

CYSWizardPage::~CYSWizardPage()
{
   LOG_DTOR(CYSWizardPage);
}


bool
CYSWizardPage::OnWizNext()
{
   LOG_FUNCTION(CYSWizardPage::OnWizNext);

   GetWizard().SetNextPageID(hwnd, Validate());
   return true;
}

/* NTRAID#NTBUG9-337325-2001/03/15-jeffjon,
   The cancel confirmation has been removed
   due to negative user feedback.
*/
bool
CYSWizardPage::OnQueryCancel()
{
   LOG_FUNCTION(CYSWizardPage::OnQueryCancel);

   bool result = false;

   // set the rerun state to false so the wizard doesn't
   // just restart itself

   State::GetInstance().SetRerunWizard(false);

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
      result ? TRUE : FALSE);

   return true;
}


bool
CYSWizardPage::OnHelp()
{
   LOG_FUNCTION(CYSWizardPage::OnHelp);

   Win::HtmlHelp(
      hwnd,
      GetHelpString(),
      HH_DISPLAY_TOPIC,
      0);

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\cys.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      cys.cpp
//
// Synopsis:  Configure Your Server Wizard main
//
// History:   02/02/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "state.h"
#include "InstallationUnitProvider.h"

// include the wizard pages
#include "WelcomePage.h"
#include "BeforeBeginPage.h"
#include "DecisionPage.h"
#include "NICSelectionPage.h"
#include "DomainPage.h"
#include "NetbiosPage.h"
#include "RestorePasswordPage.h"
#include "ExpressDNSPage.h"
#include "ExpressDHCPPage.h"
#include "CustomServerPage.h"
#include "ClusterPage.h"
#include "NetworkServerPage.h"
#include "PrintServerPage.h"
#include "TerminalServerPage.h"
#include "SharePointPage.h"
#include "FileServerPage.h"
#include "IndexingPage.h"
#include "FinishPage.h"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available


// This is the name of a mutex that is used to see if CYS is running

const wchar_t* RUNTIME_NAME = L"cysui";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER
      |  Log::OUTPUT_RUN_TIME;


// a system modal popup thingy
Popup popup(IDS_WIZARD_TITLE, true);

// this is the mutex that indicates that CYS is running.

HANDLE cysRunningMutex = INVALID_HANDLE_VALUE;

// these are the valid exit codes returned from the cys.exe process

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,

   // other exit codes can be added here...
};


ExitCode
RunWizard()
{
   LOG_FUNCTION(RunWizard);


   ExitCode exitCode = EXIT_CODE_SUCCESSFUL;


   // Create the wizard and add all the pages
   Wizard wiz(
      IDS_WIZARD_TITLE,
      IDB_BANNER16,
      IDB_BANNER256,
      IDB_WATERMARK16,
      IDB_WATERMARK256);

   wiz.AddPage(new WelcomePage());
   wiz.AddPage(new BeforeBeginPage());
   wiz.AddPage(new DecisionPage());
   wiz.AddPage(new NICSelectionPage());
   wiz.AddPage(new ADDomainPage());
   wiz.AddPage(new NetbiosDomainPage());
   wiz.AddPage(new RestorePasswordPage());
   wiz.AddPage(new ExpressDNSPage());
   wiz.AddPage(new ExpressDHCPPage());
   wiz.AddPage(new CustomServerPage());
   wiz.AddPage(new ClusterPage());
   wiz.AddPage(new NetworkServerPage());
   wiz.AddPage(new PrintServerPage());
   wiz.AddPage(new TerminalServerPage());
   wiz.AddPage(new SharePointPage());
   wiz.AddPage(new FileServerPage());
   wiz.AddPage(new IndexingPage());
   wiz.AddPage(new FinishPage());

   // Run the wizard
   switch (wiz.ModalExecute())
   {
      case -1:
      {
/*         popup.Error(
            Win::GetDesktopWindow(),
            E_FAIL,
            IDS_PROP_SHEET_FAILED);
           
*/       
         exitCode = EXIT_CODE_UNSUCCESSFUL;  
         break;
      }
      case ID_PSREBOOTSYSTEM:
      {
         // we can infer that if we are supposed to reboot, then the
         // operation was successful.

         exitCode = EXIT_CODE_SUCCESSFUL;

         break;
      }
      default:
      {
         // do nothing.
         break;
      }
   }


   return exitCode;
}

ExitCode
Start()
{
   LOG_FUNCTION(Start);

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;
   do
   {
      // Put any checks that should stop the wizard from running here...


      // User must be an Administrator

      bool isAdmin = ::IsCurrentUserAdministrator();
      if (!isAdmin)
      {
         LOG(L"Current user is not an Administrator");

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_NOT_ADMIN, 
            MB_OK);

         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // Machine cannot be in the middle of a DC upgrade

      if (State::GetInstance().IsUpgradeState())
      {
         LOG(L"Machine needs to complete DC upgrade");

         String commandline = Win::GetCommandLine();

         // If we were launched from explorer then 
         // don't show the message, just exit silently

         if (commandline.find(EXPLORER_SWITCH) == String::npos)
         {
            popup.MessageBox(
               Win::GetDesktopWindow(),
               IDS_DC_UPGRADE_NOT_COMPLETE, 
               MB_OK);
         }

         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // Machine cannot have DCPROMO running or a reboot pending

      if (State::GetInstance().IsDCPromoRunning())
      {
         LOG(L"DCPROMO is running");

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_DCPROMO_RUNNING, 
            MB_OK);

         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }
      else if (State::GetInstance().IsDCPromoPendingReboot())
      {
         LOG(L"DCPROMO was run, pending reboot");

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_DCPROMO_PENDING_REBOOT, 
            MB_OK);

         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // We can run the wizard.  Yea!!!

      exitCode = RunWizard();
   }
   while (0);

   LOG(String::format(L"exitCode = %1!d!", static_cast<int>(exitCode)));
   
   return exitCode;
}

int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   HRESULT hr = Win::CreateMutex(0, true, RUNTIME_NAME, cysRunningMutex);
   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      popup.MessageBox(
         Win::GetDesktopWindow(), 
         IDS_ALREADY_RUNNING, 
         MB_OK);
   }
   else
   {

      do
      {
         hr = ::CoInitialize(0);
         if (FAILED(hr))
         {
            ASSERT(SUCCEEDED(hr));
            break;
         }

      /* Keep this around.  It may be useful in the future when we are
         determining the network settings

         INITCOMMONCONTROLSEX sex;
         sex.dwSize = sizeof(sex);      
         sex.dwICC  = ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;

         BOOL init = ::InitCommonControlsEx(&sex);
         ASSERT(init);
*/         
         // Register the Link Window class

         LinkWindow_RegisterClass();

         do 
         {
            exitCode = Start();

         } while(State::GetInstance().RerunWizard());

         // Set the regkey to not run again

         String emptyString;

         bool result = SetRegKeyValue(
                          CYS_HOME_REGKEY, 
                          emptyString, 
                          CYS_HOME_RUN_KEY_DONT_RUN,
                          HKEY_CURRENT_USER,
                          true);
         ASSERT(result);

         // Perform cleanup

         InstallationUnitProvider::Destroy();
         State::Destroy();

         // Unregister the Link Window class

         LinkWindow_UnregisterClass(hResourceModuleHandle);

      } while(false);
   }

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\common.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      common.h
//
// Synopsis:  Defines some commonly used functions
//            This is really just a dumping ground for functions
//            that don't really belong to a specific class in
//            this design.  They may be implemented in other
//            files besides common.cpp.
//
// History:   02/03/2001  JeffJon Created

#define DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY       64
#define DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8  155
#define MAX_NETBIOS_NAME_LENGTH                       DNLEN


// Service names used for both the OCManager and launching wizards
#define CYS_DHCP_SERVICE_NAME          L"DHCPServer"
#define CYS_DNS_SERVICE_NAME           L"DNS"
#define CYS_PRINTER_WIZARD_NAME        L"AddPrinter"
#define CYS_PRINTER_DRIVER_WIZARD_NAME L"AddPrinterDriver"
#define CYS_RRAS_SERVICE_NAME          L"RRAS"
#define CYS_WEB_SERVICE_NAME           L"IISAdmin"
#define CYS_WINS_SERVICE_NAME          L"WINS"

// Other needed constants

// Switch provided by explorer.exe when launching CYS
#define EXPLORER_SWITCH                L"explorer"

extern Popup popup;

// Sets the font of a given control in a dialog.
// 
// parentDialog - Dialog containing the control.
// 
// controlID - Res ID of the control for which the font will be
// changed.
// 
// font - handle to the new font for the control.

void
SetControlFont(HWND parentDialog, int controlID, HFONT font);



// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
// 
// dialog - handle to the dialog that is the parent of the control
// 
// bigBoldResID - resource id of the control to change

void
SetLargeFont(HWND dialog, int bigBoldResID);


bool
IsServiceInstalledHelper(const wchar_t* serviceName);

bool
InstallServiceWithOcManager(
   const String& infText,
   const String& unattendText);

DWORD
MyWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);

HRESULT
CreateTempFile(const String& name, const String& contents);

HRESULT
CreateAndWaitForProcess(const String& commandLine, DWORD& exitCode);

HRESULT
MyCreateProcess(const String& commandLine);

bool
IsKeyValuePresent(RegistryKey& key, const String& value);

bool
GetRegKeyValue(
   const String& key, 
   const String& value, 
   String& resultString,
   HKEY parentKey = HKEY_LOCAL_MACHINE);

bool
GetRegKeyValue(
   const String& key, 
   const String& value, 
   DWORD& resultValue,
   HKEY parentKey = HKEY_LOCAL_MACHINE);

bool
SetRegKeyValue(
   const String& key, 
   const String& value, 
   const String& newString,
   HKEY parentKey = HKEY_LOCAL_MACHINE,
   bool create = false);

bool
SetRegKeyValue(
   const String& key, 
   const String& value, 
   DWORD newValue,
   HKEY parentKey = HKEY_LOCAL_MACHINE,
   bool create = false);

bool 
ExecuteWizard(PCWSTR serviceName, String& resultText);


// This really comes from Burnslib but it is not provided in a header
// so I am putting the declaration here and we will link to the 
// Burnslib definition

HANDLE
AppendLogFile(const String& logBaseName, String& logName);


// Macros to help with the log file operations

#define CYS_APPEND_LOG(text) \
   if (logfileHandle)        \
      FS::Write(logfileHandle, text);



bool 
IsDhcpConfigured();

extern "C"
{
   BOOL
   IsDHCPAvailableOnInterface(DWORD ipaddress);
}

bool
IsIndexingServiceOn();

HRESULT
StartIndexingService();

HRESULT
StopIndexingService();


// Validates a dns domain name for proper syntax and length.  If validation
// fails, presents appropriate error messages to the user, and sets the input
// focus to a given control.  Syntactically valid but non-RFC compliant dns
// names cause a warning message to be presented (but validation does not
// fail).  Returns true if the validation succeed, false if not.
// 
// dialog - handle to the dialog containing the edit box that: contains the
// name to be validated and receives focus if the validation fails.
// 
// domainName - the domain name to validate.  If the empty string, then the
// name is taken from the edit control identified by editResID.
// 
// editResID - the resource id of the edit control containing the domain name
// to be validated (if the domainName parameter is empty), also receives input
// focus if validation fails.
//
// warnOnNonRFC - issue a non-fatal warning if the name is not RFC compliant.
//
// isNonRFC - optional pointer to bool to be set to true if the name is
// not a RFC-compliant name.

bool
ValidateDomainDnsNameSyntax(
   HWND           dialog,
   const String&  domainName,
   int            editResID,
   bool           warnOnNonRFC,
   bool*          isNonRFC = 0);


// Overloads ValidateDomainDnsNameSyntax such that the domain name to be
// validated is taken from the edit control specified by editResID.

bool
ValidateDomainDnsNameSyntax(
   HWND     dialog,
   int      editResID,
   bool     warnOnNonRFC,
   bool*    isNonRFC = 0);


// If the new domain name is a single DNS label, then ask the user to confirm
// that name.  If the user rejects the name, set focus to the domain name edit
// box, return false.  Otherwise, return true.
// 
// parentDialog - HWND of the dialog with the edit box control.
// 
// editResID - resource ID of the domain name edit box containing the name to
// be confirmed.
//
// 309670

bool
ConfirmNetbiosLookingNameIsReallyDnsName(HWND parentDialog, int editResID);


// Converts a VARIANT of type VT_ARRAY | VT_BSTR to a list of Strings

HRESULT
VariantArrayToStringList(VARIANT* variant, StringList& stringList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\decisionpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DecisionPage.h
//
// Synopsis:  Declares the Decision Page for the CYS
//            wizard.  This page lets the user choose
//            between the express and custom paths.
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_DECISIONPAGE_H
#define __CYS_DECISIONPAGE_H

#include "CYSWizardPage.h"


class DecisionPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      DecisionPage();

      // Destructor

      virtual 
      ~DecisionPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      DecisionPage(const DecisionPage&);
      const DecisionPage& operator=(const DecisionPage&);

};

#endif // __CYS_DECISIONPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\cyswizardpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      CYSWizardPage.h
//
// Synopsis:  Declares the base class for the wizard
//            pages used for CYS.  It is a subclass
//            of WizardPage found in Burnslib
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_CYSWIZARDPAGE_H
#define __CYS_CYSWIZARDPAGE_H


class CYSWizardPage : public WizardPage
{
   public:
      
      // Constructor
      
      CYSWizardPage(
         int    dialogResID,
         int    titleResID,
         int    subtitleResID,   
         PCWSTR pageHelpString = 0,
         bool   hasHelp = true,
         bool   isInteriorPage = true);

      // Destructor

      virtual ~CYSWizardPage();

      virtual
      bool
      OnWizNext();

      virtual
      bool
      OnQueryCancel();

      virtual
      bool
      OnHelp();

   protected:

      virtual
      int
      Validate() = 0;

      const String
      GetHelpString() const { return helpString; }

   private:

      String helpString;

      // not defined: no copying allowed
      CYSWizardPage(const CYSWizardPage&);
      const CYSWizardPage& operator=(const CYSWizardPage&);
};

#endif // __CYS_CYSWIZARDPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\decisionpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DecisionPage.cpp
//
// Synopsis:  Defines Decision Page for the CYS
//            Wizard.  This page lets the user choose
//            between the custom and express paths
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "DecisionPage.h"
#include "state.h"


static PCWSTR DECISION_PAGE_HELP = L"cys.chm::/cys_topnode.htm";

DecisionPage::DecisionPage()
   :
   CYSWizardPage(IDD_DECISION_PAGE, IDS_DECISION_TITLE, IDS_DECISION_SUBTITLE, DECISION_PAGE_HELP)
{
   LOG_CTOR(DecisionPage);
}

   

DecisionPage::~DecisionPage()
{
   LOG_DTOR(DecisionPage);
}


void
DecisionPage::OnInit()
{
   LOG_FUNCTION(DecisionPage::OnInit);

   String text = String::load(IDS_DECISION_PAGE_TEXT);

   Win::SetWindowText(Win::GetDlgItem(hwnd, IDC_DESC_STATIC), text);

   Win::Button_SetCheck(Win::GetDlgItem(hwnd, IDC_EXPRESS_RADIO), BST_CHECKED);
}

bool
DecisionPage::OnSetActive()
{
   LOG_FUNCTION(DecisionPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}

int
DecisionPage::Validate()
{
   LOG_FUNCTION(DecisionPage::Validate);

   int nextPage = -1;

   if (Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_EXPRESS_RADIO)))
   {
      nextPage = IDD_AD_DOMAIN_NAME_PAGE;

      InstallationUnitProvider::GetInstance().SetCurrentInstallationUnit(EXPRESS_INSTALL);

      // Make sure all the delegated installation units know we are in the
      // express path

      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetExpressPathInstall(true);
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetExpressPathInstall(true);
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetExpressPathInstall(true);
   }
   else if (Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_CUSTOM_RADIO)))
   {
      // Make sure all the delegated installation units know we are no longer
      // in the express path (if we once were)

      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetExpressPathInstall(false);
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetExpressPathInstall(false);
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetExpressPathInstall(false);

      nextPage = IDD_CUSTOM_SERVER_PAGE;
   }
   else
   {
      ASSERT(false);
   }

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\dnsinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DNSInstallationUnit.cpp
//
// Synopsis:  Defines a DNSInstallationUnit
//            This object has the knowledge for installing the
//            DNS service
//
// History:   02/05/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "DNSInstallationUnit.h"




DNSInstallationUnit::DNSInstallationUnit() :
   isExpressPathInstall(false),
   staticIPAddress(0),
   subnetMask(0),
   NetworkServiceInstallationBase(
      IDS_DNS_SERVER_TYPE, 
      IDS_DNS_SERVER_DESCRIPTION, 
      IDS_DNS_SERVER_DESCRIPTION_INSTALLED,
      DNS_INSTALL)
{
   LOG_CTOR(DNSInstallationUnit);
}


DNSInstallationUnit::~DNSInstallationUnit()
{
   LOG_DTOR(DNSInstallationUnit);
}


InstallationReturnType
DNSInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DNSInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   if (IsExpressPathInstall())
   {
      result = ExpressPathInstall(logfileHandle, hwnd);

      LOG_INSTALL_RETURN(result);
      return result;
   }


   // Create the inf and unattend files that are used by the 
   // Optional Component Manager

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_DNS_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_DNS_SERVICE_NAME);

   // Install the service through the Optional Component Manager

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      // Log the successful installation

      LOG(L"DNS was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_INSTALL_START_DNS));


      // Run the DNS Wizard
      
      String resultText;

      if (ExecuteWizard(CYS_DNS_SERVICE_NAME, resultText))
      {
         // Check to be sure the wizard finished completely

         String configWizardResults;

         if (ReadConfigWizardRegkeys(configWizardResults))
         {
            // The Configure DNS Server Wizard completed successfully
            
            LOG(L"The Configure DNS Server Wizard completed successfully");
            CYS_APPEND_LOG(String::load(IDS_LOG_DNS_COMPLETED_SUCCESSFULLY));
         }
         else
         {
            // The Configure DNS Server Wizard did not finish successfully

            if (!configWizardResults.empty())
            {
               // An error was returned via the regkey

               LOG(String::format(
                  L"The Configure DNS Server Wizard returned the error: %1", 
                  configWizardResults.c_str()));

               String formatString = String::load(IDS_LOG_DNS_WIZARD_ERROR);
               CYS_APPEND_LOG(String::format(formatString, configWizardResults.c_str()));

            }
            else
            {
               // The Configure DNS Server Wizard was cancelled by the user

               LOG(L"The Configure DNS Server Wizard was cancelled by the user");

               CYS_APPEND_LOG(String::load(IDS_LOG_DNS_WIZARD_CANCELLED));
            }
         }
      }
      else
      {
         // Show an error

         LOG(L"DNS could not be installed.");

         if (!resultText.empty())
         {
            CYS_APPEND_LOG(resultText);
         }
      }
   }
   else
   {
      // Log the failure

      LOG(L"DNS failed to install");

      CYS_APPEND_LOG(String::load(IDS_LOG_DNS_INSTALL_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

InstallationReturnType
DNSInstallationUnit::ExpressPathInstall(HANDLE /*logfileHandle*/, HWND /*hwnd*/)
{
   LOG_FUNCTION(DNSInstallationUnit::ExpressPathInstall);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Set the static IP address and the subnet mask

   // invoke netsh and wait for it to terminate

   String friendlyName = GetTcpIpInterfaceFriendlyName();

   do
   {
      // set static IP address and subnet mask

      String commandLine =
         String::format(
            L"netsh interface ip set address "
            L"name=\"%1\" source=static addr=%2 mask=%3 gateway=none",
            friendlyName.c_str(),
            GetStaticIPAddressString().c_str(),
            GetSubnetMaskString().c_str());

      DWORD exitCode1 = 0;
      HRESULT hr = ::CreateAndWaitForProcess(commandLine, exitCode1);
      if (FAILED(hr) || exitCode1)
      {
         LOG(String::format(
                L"Failed to set the static IP address and subnet mask: exitCode = %1!x!",
                exitCode1));
         result = INSTALL_FAILURE;
         break;
      }
   
      ASSERT(SUCCEEDED(hr));

      // set DNS server address to same address as local machine.  netsh
      // does not allow the dns server address to be the loopback address.

      commandLine =
         String::format(
            L"netsh interface ip set dns name=\"%1\" source=static addr=%2",
            friendlyName.c_str(),
            GetStaticIPAddressString().c_str());

      DWORD exitCode2 = 0;
      hr = ::CreateAndWaitForProcess(commandLine, exitCode2);
      if (FAILED(hr) || exitCode2)
      {
         LOG(String::format(
                L"Failed to set the preferred DNS server IP address: exitCode = %1!x!",
                exitCode2));
         result = INSTALL_FAILURE;
         break;
      }

   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}


// get guid name of the first tcp/ip interface we enum

HRESULT
DNSInstallationUnit::GetTcpIpInterfaceGuidName(String& result)
{
   LOG_FUNCTION(DNSInstallationUnit::GetTcpIpInterfaceGuidName);

   result.erase();

   DWORD dwError = 0;
   ULONG ulSize = 0;
   PIP_INTERFACE_INFO pInfo = NULL;
   HRESULT hr = S_OK;

   while ( 1 )
   {
      dwError = ::GetInterfaceInfo( pInfo, &ulSize );
      if ( ERROR_INSUFFICIENT_BUFFER != dwError )
      {
         break;
      }

      if ( NULL != pInfo )
      {
         Win::LocalFree(pInfo);
      }
      if ( 0 == ulSize )
      {
         hr = E_FAIL;
         LOG_HRESULT(hr);
         return hr;
      }

      pInfo = (PIP_INTERFACE_INFO) ::LocalAlloc(LPTR, ulSize);
      if ( NULL == pInfo )
      {
         hr = E_OUTOFMEMORY;
         LOG_HRESULT(hr);
         return hr;
      }
   }

   if ( ERROR_SUCCESS != dwError || 0 == pInfo->NumAdapters )
   {
      if ( NULL != pInfo )
      {
         Win::LocalFree(pInfo);
      }
      hr = E_FAIL;
      LOG_HRESULT(hr);
      return hr;
   }

   
   // Skip the adapter prefix

   result = pInfo->Adapter[0].Name + strlen("\\Device\\Tcpip_"),

// CODEWORK could do this with IIDFromString
// // //    // check whether this is a valid GUID
// // // 
// // //    SHUnicodeToTChar(wszGuidName, szGuid, ARRAYSIZE(szGuid));
// // //    if (!GUIDFromString(szGuid, &guid))
// // //    {
// // //       // we failed to get a valid tcp/ip interface
// // //       *wszGuidName = 0;
// // //       Win::LocalFree(pInfo);
// // //       return E_FAIL;
// // //    }

   LocalFree(pInfo);

   LOG(result);

   return S_OK;
}

// get friendly name of the first tcp/ip interface we enum

String
DNSInstallationUnit::GetTcpIpInterfaceFriendlyName()
{
   LOG_FUNCTION(DNSInstallationUnit::GetTcpIpInterfaceFriendlyName);

   DWORD dwRet = 0;
   HANDLE hMprConfig = 0;

   static const unsigned friendlyNameLength = 128;
   wchar_t wszFriendlyName[friendlyNameLength];
   ZeroMemory(wszFriendlyName, sizeof(wchar_t) * friendlyNameLength);

   String result;

   String guidName;    
   HRESULT hr = GetTcpIpInterfaceGuidName(guidName);
   if (SUCCEEDED(hr))
   {
      dwRet = MprConfigServerConnect(0, &hMprConfig);
      if (NO_ERROR == dwRet)
      {
         dwRet =
            MprConfigGetFriendlyName(
               hMprConfig,
               const_cast<wchar_t*>(guidName.c_str()), 
               wszFriendlyName,
               sizeof(wchar_t) * friendlyNameLength);
         if (NO_ERROR != dwRet)
         {
            LOG(String::format(
                   L"MprConfigGetFriendlyName() failed: error = %1!x!",
                   dwRet));
            *wszFriendlyName = 0;
         }
      }
      else
      {
         LOG(String::format(
                L"MprConfigServerConnect() failed: error = %1!x!",
                dwRet));
      }

      MprConfigServerDisconnect(hMprConfig);
   }

   if (!*wszFriendlyName)
   {
      // we failed to get a friendly name, so use the default one
      // BUGBUG does this need to be localized?

      result = L"Local Area Connection";
   }
   else
   {
      result = wszFriendlyName;
   }

   LOG(result);

   return result;
}

bool
DNSInstallationUnit::ReadConfigWizardRegkeys(String& configWizardResults) const
{
   LOG_FUNCTION(DNSInstallationUnit::ReadConfigWizardRegkeys);

   bool result = true;

   do 
   {
      DWORD value = 0;
      result = GetRegKeyValue(
                  DNS_WIZARD_CONFIG_REGKEY, 
                  DNS_WIZARD_CONFIG_VALUE, 
                  value);

      if (result &&
          value != 0)
      {
         // The Configure DNS Server Wizard succeeded

         result = true;
         break;
      }

      // Since there was a failure (or the wizard was cancelled)
      // get the display string to log

      result = GetRegKeyValue(
                  DNS_WIZARD_RESULT_REGKEY, 
                  DNS_WIZARD_RESULT_VALUE, 
                  configWizardResults);

   } while (false);

   LOG_BOOL(result);

   return result;
}


bool
DNSInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(DNSInstallationUnit::IsServiceInstalled);

   bool result = IsServiceInstalledHelper(CYS_DNS_SERVICE_NAME);

   LOG_BOOL(result);
   return result;
}

bool
DNSInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(DNSInstallationUnit::GetFinishText);

   message = String::load(IDS_DNS_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

void
DNSInstallationUnit::SetExpressPathInstall(bool isExpressPath)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::SetExpressPathInstall,
      (isExpressPath) ? L"true" : L"false");

   isExpressPathInstall = isExpressPath;
}


bool
DNSInstallationUnit::IsExpressPathInstall() const
{
   LOG_FUNCTION(DNSInstallationUnit::IsExpressPathInstall);

   return isExpressPathInstall;
}


void
DNSInstallationUnit::SetStaticIPAddress(DWORD ipaddress)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::SetStaticIPAddress,
      String::format(
         L"%1!d!.%2!d!.%3!d!.%4!d!", 
         FIRST_IPADDRESS(ipaddress),
         SECOND_IPADDRESS(ipaddress),
         THIRD_IPADDRESS(ipaddress),
         FOURTH_IPADDRESS(ipaddress)));

   staticIPAddress = ipaddress;
}

void
DNSInstallationUnit::SetSubnetMask(DWORD mask)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::SetSubnetMask,
      String::format(
         L"%1!d!.%2!d!.%3!d!.%4!d!", 
         FIRST_IPADDRESS(mask),
         SECOND_IPADDRESS(mask),
         THIRD_IPADDRESS(mask),
         FOURTH_IPADDRESS(mask)));

   subnetMask = mask;
}

String
DNSInstallationUnit::GetStaticIPAddressString() const
{
   LOG_FUNCTION(DNSInstallationUnit::GetStaticIPAddressString);

   String result = String::format(
                      L"%1!d!.%2!d!.%3!d!.%4!d!", 
                      FIRST_IPADDRESS(staticIPAddress),
                      SECOND_IPADDRESS(staticIPAddress),
                      THIRD_IPADDRESS(staticIPAddress),
                      FOURTH_IPADDRESS(staticIPAddress));

   LOG(result);
   return result;
}


String
DNSInstallationUnit::GetSubnetMaskString() const
{
   LOG_FUNCTION(DNSInstallationUnit::GetSubnetMaskString);

   String result = String::format(
                      L"%1!d!.%2!d!.%3!d!.%4!d!", 
                      FIRST_IPADDRESS(subnetMask),
                      SECOND_IPADDRESS(subnetMask),
                      THIRD_IPADDRESS(subnetMask),
                      FOURTH_IPADDRESS(subnetMask));

   LOG(result);
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\dialogs.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      Dialogs.h
//
// Synopsis:  Declares some helpful dialogs that are
//            used throughout the wizard
//
// History:   05/02/2001  JeffJon Created

#ifndef __CYS_DIALOGS_H
#define __CYS_DIALOGS_H


class FinishDialog : public Dialog
{
   public:

      // constructor 

      FinishDialog(
         String logFile,
         String helpStringURL);

      // Accessors

      bool
      ShowHelpList() { return showHelpList; }

      bool
      ShowLogFile() { return showLogFile; }

      void
      OpenLogFile();

   protected:

      virtual
      void
      OnInit();

      virtual
      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIdFrom,
         unsigned    code);

   private:

      bool
      OnHelp();

      String logFileName;
      String helpString;

      bool showHelpList;
      bool showLogFile;

      // not defined: no copying allowed
      FinishDialog(const FinishDialog&);
      const FinishDialog& operator=(const FinishDialog&);
};



#endif // __CYS_DIALOGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\dnsinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DNSInstallationUnit.h
//
// Synopsis:  Declares a DNSInstallationUnit
//            This object has the knowledge for installing the
//            DNS service
//
// History:   02/05/2001  JeffJon Created

#ifndef __CYS_DNSINSTALLATIONUNIT_H
#define __CYS_DNSINSTALLATIONUNIT_H

#include "NetworkServiceInstallationBase.h"

class DNSInstallationUnit : public NetworkServiceInstallationBase
{
   public:
      
      // Constructor

      DNSInstallationUnit();

      // Destructor
      virtual
      ~DNSInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);


      // Data accessors

      void
      SetExpressPathInstall(bool isExpressPath);

      bool IsExpressPathInstall() const;

      void
      SetStaticIPAddress(DWORD ipaddress);

      DWORD
      GetStaticIPAddress() const { return staticIPAddress; }

      String
      GetStaticIPAddressString() const;

      void
      SetSubnetMask(DWORD mask);

      DWORD
      GetSubnetMask() const { return subnetMask; }

      String
      GetSubnetMaskString() const;

   protected:

      InstallationReturnType
      ExpressPathInstall(HANDLE /*logfileHandle*/, HWND /*hwnd*/);

   private:

      HRESULT
      GetTcpIpInterfaceGuidName(String& result);

      String
      GetTcpIpInterfaceFriendlyName();
      
      bool
      ReadConfigWizardRegkeys(String& configWizardResults) const;

      bool  isExpressPathInstall;

      // Express path members

      DWORD staticIPAddress;
      DWORD subnetMask;
};

#endif // __CYS_DNSINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\dhcpinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DHCPInstallationUnit.h
//
// Synopsis:  Declares a DHCPInstallationUnit
//            This object has the knowledge for installing the
//            DHCP service
//
// History:   02/05/2001  JeffJon Created

#ifndef __CYS_DHCPINSTALLATIONUNIT_H
#define __CYS_DHCPINSTALLATIONUNIT_H

#include "NetworkServiceInstallationBase.h"

class DHCPInstallationUnit : public NetworkServiceInstallationBase
{
   public:
      
      // Constructor

      DHCPInstallationUnit();

      // Destructor
      virtual
      ~DHCPInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      bool
      IsConfigured();

      InstallationReturnType
      ExpressPathInstall(HANDLE logfileHandle, HWND hwnd);


      // Other accessibly functions

      bool
      AuthorizeDHCPScope(const String& dnsName) const;

      // Data accessors

      void
      SetExpressPathInstall(bool isExpressPath);

      bool IsExpressPathInstall() const;

      void
      SetStartIPAddress(DWORD ipaddress);

      DWORD
      GetStartIPAddress() const { return startIPAddress; }

      void
      SetEndIPAddress(DWORD ipaddress);

      DWORD
      GetEndIPAddress() const { return endIPAddress; }

      String
      GetStartIPAddressString() const;

      String
      GetEndIPAddressString() const;

   protected:

      void
      CreateUnattendFileTextForExpressPath(String& unattendFileText);

   private:


      bool  isExpressPathInstall;

      DWORD startIPAddress;
      DWORD endIPAddress;
};

#endif // __CYS_DHCPINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\domainpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DomainPage.h
//
// Synopsis:  Declares the new domain name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_DOMAINPAGE_H
#define __CYS_DOMAINPAGE_H

#include "CYSWizardPage.h"


class ADDomainPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      ADDomainPage();

      // Destructor

      virtual 
      ~ADDomainPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      ADDomainPage::OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      ADDomainPage(const ADDomainPage&);
      const ADDomainPage& operator=(const ADDomainPage&);

};

#endif // __CYS_DOMAINPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\domainpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DomainPage.cpp
//
// Synopsis:  Defines the new domain name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "DomainPage.h"
#include "state.h"

static PCWSTR DOMAIN_PAGE_HELP = L"cys.chm::/cys_configuring_first_server.htm";

ADDomainPage::ADDomainPage()
   :
   CYSWizardPage(
      IDD_AD_DOMAIN_NAME_PAGE, 
      IDS_AD_DOMAIN_TITLE, 
      IDS_AD_DOMAIN_SUBTITLE,
      DOMAIN_PAGE_HELP)
{
   LOG_CTOR(ADDomainPage);
}

   

ADDomainPage::~ADDomainPage()
{
   LOG_DTOR(ADDomainPage);
}


void
ADDomainPage::OnInit()
{
   LOG_FUNCTION(ADDomainPage::OnInit);

}

static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_DOMAIN).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}

bool
ADDomainPage::OnSetActive()
{
   LOG_FUNCTION(ADDomainPage::OnSetActive);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   enable(hwnd);
   return true;
}


bool
ADDomainPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ForestPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
ForestValidateDomainDoesNotExist(
   HWND dialog,   
   int  editResID)
{
   LOG_FUNCTION(ForestValidateDomainDoesNotExist);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   // this can take awhile.

   Win::WaitCursor cursor;

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);

   // The invoking code should verify this condition, but we will handle
   // it just in case.

   ASSERT(!name.empty());

   bool valid = true;
   String message;
   do
   {
      if (name.empty())
      {
         message = String::load(IDS_MUST_ENTER_DOMAIN);
         valid = false;
         break;
      }
      if (IsDomainReachable(name))
      {
         message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
         valid = false;
         break;
      }

      HRESULT hr = MyNetValidateName(name, ::NetSetupNonExistentDomain);

      if (hr == Win32ToHresult(ERROR_DUP_NAME))
      {
         message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
         valid = false;
         break;
      }

      if (hr == Win32ToHresult(ERROR_NETWORK_UNREACHABLE))
      {
         // 25968

         if (
            popup.MessageBox(
               dialog,
               String::format(
                  IDS_NET_NOT_REACHABLE,
                  name.c_str()),
               MB_YESNO | MB_ICONWARNING) != IDYES)
         {
            message.erase();
            valid = false;

            HWND edit = Win::GetDlgItem(dialog, editResID);
            Win::SendMessage(edit, EM_SETSEL, 0, -1);
            Win::SetFocus(edit);
         }
      }

      // otherwise the domain does not exist
   }
   while (0);

   if (!valid && !message.empty())
   {
      popup.Gripe(dialog, editResID, message);
   }

   return valid;
}


int
ADDomainPage::Validate()
{
   LOG_FUNCTION(ADDomainPage::Validate);

   int nextPage = -1;

   String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
   if (domain.empty())
   {
      popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_DOMAIN);
      return -1;
   }

   if (
         !ValidateDomainDnsNameSyntax(hwnd, IDC_DOMAIN, true)
      || !ConfirmNetbiosLookingNameIsReallyDnsName(hwnd, IDC_DOMAIN)

      // do this test last, as it is expensive

      || !ForestValidateDomainDoesNotExist(hwnd, IDC_DOMAIN))
   {
      nextPage = -1;
   }
   else
   {
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetNewDomainDNSName(domain);
      nextPage = IDD_NETBIOS_NAME;
   }
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\dhcpinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      DHCPInstallationUnit.cpp
//
// Synopsis:  Defines a DHCPInstallationUnit
//            This object has the knowledge for installing the
//            DHCP service
//
// History:   02/05/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "DHCPInstallationUnit.h"
#include "InstallationUnitProvider.h"

DHCPInstallationUnit::DHCPInstallationUnit() :
   isExpressPathInstall(false),
   startIPAddress(0),
   endIPAddress(0),
   NetworkServiceInstallationBase(
      IDS_DHCP_SERVER_TYPE, 
      IDS_DHCP_SERVER_DESCRIPTION, 
      IDS_DHCP_SERVER_DESCRIPTION_INSTALLED,
      DHCP_INSTALL)
{
   LOG_CTOR(DHCPInstallationUnit);
}


DHCPInstallationUnit::~DHCPInstallationUnit()
{
   LOG_DTOR(DHCPInstallationUnit);
}


InstallationReturnType
DHCPInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DHCPInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   if (IsExpressPathInstall())
   {
      // This is an express path install.  It must be done special

      result = ExpressPathInstall(logfileHandle, hwnd);

      LOG_INSTALL_RETURN(result);
      return result;
   }


   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_DHCP_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_DHCP_SERVICE_NAME);

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      // Log the successful installation

      LOG(L"DHCP was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_INSTALL_START_DHCP));


      // Run the DHCP Wizard
      
      String resultText;

      if (ExecuteWizard(CYS_DHCP_SERVICE_NAME, resultText))
      {
         // Check to be sure the wizard finished completely

         String configWizardResults;

         if (IsDhcpConfigured())
         {
            // The New Scope Wizard completed successfully
            
            LOG(L"DHCP installed and the New Scope Wizard completed successfully");
            CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_COMPLETED_SUCCESSFULLY));
         }
         else
         {
            // The New Scope Wizard did not finish successfully


            LOG(L"DHCP installed successfully, but a problem occurred during the New Scope Wizard");

            CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_WIZARD_ERROR));
         }
      }
      else
      {
         // Log an error

         LOG(L"DHCP could not be installed.");

         if (!resultText.empty())
         {
            CYS_APPEND_LOG(resultText);
         }
      }
   }
   else
   {
      // Log the failure

      LOG(L"DHCP failed to install");

      CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_INSTALL_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}


InstallationReturnType
DHCPInstallationUnit::ExpressPathInstall(HANDLE /*logfileHandle*/, HWND /*hwnd*/)
{
   LOG_FUNCTION(DHCPInstallationUnit::ExpressPathInstall);

   InstallationReturnType result = INSTALL_SUCCESS;

   String infFileText;
   String unattendFileText;
   String commandline;

   CreateInfFileText(infFileText, IDS_DHCP_INF_WINDOW_TITLE);
   CreateUnattendFileTextForExpressPath(unattendFileText);

   do
   {
      bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
      if (ocmResult &&
          !IsServiceInstalled())
      {
         result = INSTALL_FAILURE;

         LOG(L"DHCP installation failed");
         break;
      }
      else
      {
         HRESULT hr = S_OK;
         DWORD exitCode = 0;
         String ipaddressString = 
            InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetStaticIPAddressString();

         String subnetMaskString =
            InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetSubnetMaskString();

         do
         {
            commandline = L"netsh dhcp server add optiondef 6 \"DNS Servers\" IPADDRESS 1";
            hr = CreateAndWaitForProcess(commandline, exitCode);
            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to run DHCP options: hr = %1!x!",
                      hr));
               break;
            }

            if (exitCode != 1)
            {
               LOG(String::format(
                      L"Failed to run DHCP options: exitCode = %1!x!",
                      exitCode));
               break;
            }

            commandline.format(
               L"netsh dhcp server set optionvalue 6 IPADDRESS %1",
               ipaddressString);

            exitCode = 0;
            hr = CreateAndWaitForProcess(commandline, exitCode);
            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to run DHCP server IP address: hr = %1!x!",
                      hr));
               break;
            }

            if (exitCode != 1)
            {
               LOG(String::format(
                      L"Failed to run DHCP server IP address: exitCode = %1!x!",
                      exitCode));
               break;
            }

         } while (false);


         // Set the subnet mask

         DWORD staticipaddress = 
            InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetStaticIPAddress();

         DWORD subnetMask = 
            InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetSubnetMask();

         DWORD subnet = staticipaddress & subnetMask;

         String subnetString = String::format(
                                  L"%1!d!.%2!d!.%3!d!.%4!d!",
                                  FIRST_IPADDRESS(subnet),
                                  SECOND_IPADDRESS(subnet),
                                  THIRD_IPADDRESS(subnet),
                                  FOURTH_IPADDRESS(subnet));

         commandline.format(
            L"netsh dhcp server 127.0.0.1 add scope %1 %2 Scope1",
            subnetString.c_str(),
            subnetMaskString.c_str());

         exitCode = 0;
         hr = CreateAndWaitForProcess(commandline, exitCode);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP address and subnet: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to set DHCP address and subnet: exitCode = %1!x!",
                   exitCode));
            break;
         }

         // Set the DHCP scopes

         commandline.format(
            L"netsh dhcp server 127.0.0.1 add scope %1 add iprange %2 %3 both",
            subnetString.c_str(),
            GetStartIPAddressString().c_str(),
            GetEndIPAddressString().c_str());

         exitCode = 0;
         hr = CreateAndWaitForProcess(commandline, exitCode);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP scopes: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to set DHCP scopes: exitCode = %1!x!",
                   exitCode));
            break;
         }

         // Set the DHCP scope lease time

         commandline = L"netsh dhcp server 127.0.0.1 add optiondef 51 LeaseTime DWORD";

         exitCode = 0;
         hr = CreateAndWaitForProcess(commandline, exitCode);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time: exitCode = %1!x!",
                   exitCode));
            break;
         }

         // Set the DHCP scope lease time value

         commandline.format(
            L"netsh dhcp server 127.0.0.1 scope %1 set optionvalue 51 dword 874800",
            subnetString.c_str());

         exitCode = 0;
         hr = CreateAndWaitForProcess(commandline, exitCode);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time value: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time value: exitCode = %1!x!",
                   exitCode));
            break;
         }
      }
   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}


void
DHCPInstallationUnit::CreateUnattendFileTextForExpressPath(
   String& unattendFileText)
{
   LOG_FUNCTION(DHCPInstallationUnit::CreateUnattendFileText);

   unattendFileText =  L"[NetOptionalComponents]\n";
   unattendFileText += L"DHCPServer=1\n";
   unattendFileText += L"[dhcpserver]\n";
   unattendFileText += L"Subnets=192.168.16.2\n";

   // Add the DHCP scope

   unattendFileText += L"StartIP=";
   unattendFileText += GetStartIPAddressString();
   unattendFileText += L"EndIp=";
   unattendFileText += GetEndIPAddressString();

   // Add subnet mask

   unattendFileText += L"SubnetMask=255.255.255.0\n";
   unattendFileText += L"LeaseDuration=874800\n";

   // The DNS server IP

   String dnsIPString = InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetStaticIPAddressString();

   unattendFileText += String::format(
                          L"DnsServer=%1",
                          dnsIPString.c_str());

   // The domain name

   unattendFileText += String::format(
                          L"DomainName=%1\n",
                          InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainDNSName());

}


bool
DHCPInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(DHCPInstallationUnit::IsServiceInstalled);

   bool result = IsServiceInstalledHelper(CYS_DHCP_SERVICE_NAME);

   LOG_BOOL(result);
   return result;
}


bool
DHCPInstallationUnit::IsConfigured()
{
   LOG_FUNCTION(DHCPInstallationUnit::IsConfigured);

   return IsDhcpConfigured();
}

bool
DHCPInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(DHCPInstallationUnit::GetFinishText);

   if (IsExpressPathInstall())
   {

   }
   else
   {
      message = String::load(IDS_DHCP_FINISH_TEXT);
   }

   LOG_BOOL(true);
   return true;
}


bool
DHCPInstallationUnit::AuthorizeDHCPScope(const String& dnsName) const
{
   LOG_FUNCTION(DHCPInstallationUnit::AuthorizeDHCPScope);

   bool result = true;

   do
   {

      String domainDNSIP;
      result = GetRegKeyValue(
         CYS_DHCP_DOMAIN_IP_REGKEY, 
         CYS_DHCP_DOMAIN_IP_VALUE, 
         domainDNSIP);

      if (!result)
      {
         LOG(L"Failed to read domain DNS IP from registry");
         break;
      }

      // Authorize the DHCP scope

      String commandline;
      commandline = L"netsh dhcp add server ";
      commandline += dnsName;
      commandline += L" ";
      commandline += domainDNSIP;

      DWORD exitCode = 0;
      HRESULT hr = CreateAndWaitForProcess(commandline, exitCode);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to run DHCP authorization: hr = %1!x!",
                hr));
         result = false;
         break;
      }

      if (exitCode != 1)
      {
         result = false;
         break;
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}



void
DHCPInstallationUnit::SetExpressPathInstall(bool isExpressPath)
{
   LOG_FUNCTION2(
      DHCPInstallationUnit::SetExpressPathInstall,
      (isExpressPath) ? L"true" : L"false");

   isExpressPathInstall = isExpressPath;
}


bool
DHCPInstallationUnit::IsExpressPathInstall() const
{
   LOG_FUNCTION(DHCPInstallationUnit::IsExpressPathInstall);

   return isExpressPathInstall;
}


void
DHCPInstallationUnit::SetStartIPAddress(DWORD ipaddress)
{
   LOG_FUNCTION2(
      DHCPInstallationUnit::SetStartIPAddress,
      String::format(L"0x%1!x!", ipaddress));

   startIPAddress = ipaddress;
}

void
DHCPInstallationUnit::SetEndIPAddress(DWORD ipaddress)
{
   LOG_FUNCTION2(
      DHCPInstallationUnit::SetEndIPAddress,
      String::format(L"0x%1!x!", ipaddress));

   endIPAddress = ipaddress;
}

String
DHCPInstallationUnit::GetStartIPAddressString() const
{
   LOG_FUNCTION(DHCPInstallationUnit::GetStartIPAddressString);

   String result = String::format(
                      L"%1!d!.%2!d!.%3!d!.%4!d!",
                      FIRST_IPADDRESS(startIPAddress),
                      SECOND_IPADDRESS(startIPAddress),
                      THIRD_IPADDRESS(startIPAddress),
                      FOURTH_IPADDRESS(startIPAddress));

   LOG(result);
   return result;
}

String
DHCPInstallationUnit::GetEndIPAddressString() const
{
   LOG_FUNCTION(DHCPInstallationUnit::GetEndIPAddressString);

   String result = String::format(
                      L"%1!d!.%2!d!.%3!d!.%4!d!",
                      FIRST_IPADDRESS(endIPAddress),
                      SECOND_IPADDRESS(endIPAddress),
                      THIRD_IPADDRESS(endIPAddress),
                      FOURTH_IPADDRESS(endIPAddress));

   LOG(result);
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\dialogs.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      Dialogs.cpp
//
// Synopsis:  Defines some helpful dialogs that are
//            used throughout the wizard
//
// History:   05/02/2001  JeffJon Created


#include "pch.h"

#include "resource.h"
#include "Dialogs.h"

DWORD finishDialogHelpMap[] =
{
   0, 0
};

FinishDialog::FinishDialog(
   String logFile,
   String helpStringURL)
   : logFileName(logFile),
     helpString(helpStringURL),
     showHelpList(true),
     showLogFile(false),
     Dialog(IDD_SUCCESS_DIALOG, finishDialogHelpMap)
{
   LOG_CTOR(FinishDialog);
}


void
FinishDialog::OnInit()
{
   LOG_FUNCTION(FinishDialog::OnInit);

   // load the log file format string 

   String logCheckTextFormat = String::load(IDS_OPEN_LOG_FORMAT_STRING);

   String logCheckText = String::format(
                            logCheckTextFormat,
                            logFileName.c_str());

   Win::SetWindowText(
      Win::GetDlgItem(hwnd, IDC_LOG_FILE_CHECK), logCheckText);


   // set the checkboxes to the defaults

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_HELP_LIST_CHECK),
      showHelpList ? BST_CHECKED : BST_UNCHECKED);

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_LOG_FILE_CHECK),
      showLogFile ? BST_CHECKED : BST_UNCHECKED);
}

bool
FinishDialog::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(FinishDialog::OnCommand);

   bool result = false;

   if (IDOK == controlIdFrom &&
       BN_CLICKED == code)
   {
      showHelpList = Win::Button_GetCheck(
                          Win::GetDlgItem(hwnd, IDC_HELP_LIST_CHECK));

      showLogFile = Win::Button_GetCheck(
                          Win::GetDlgItem(hwnd, IDC_LOG_FILE_CHECK));

      if (showLogFile)
      {
         OpenLogFile();
      }

      if (showHelpList)
      {
         OnHelp();
      }

      Win::EndDialog(hwnd, IDOK);

      result = true;
   }
   else if (IDCANCEL == controlIdFrom &&
            BN_CLICKED == code)
   {
      Win::EndDialog(hwnd, IDCANCEL);

      result = true;
   }

   return result;
}

void
FinishDialog::OpenLogFile()
{
   LOG_FUNCTION(FinishDialog::OpenLogFile);

   String commandLine = L"notepad.exe ";
   commandLine += logFileName;

   DWORD exitCode = 0;
   HRESULT hr = CreateAndWaitForProcess(commandLine, exitCode);
   ASSERT(SUCCEEDED(hr));
}

bool
FinishDialog::OnHelp()
{
   LOG_FUNCTION(FinishDialog::OnHelp);

   // NOTE: I am not using Win::HtmlHelp here so that the help
   //       is actually running in a different process.  This
   //       allows us to close down CYS without losing the help
   //       window.

   String commandline = L"hh.exe " + helpString;
   HRESULT hr = MyCreateProcess(commandline);
   if (FAILED(hr))
   {
      LOG(String::format(
             L"Failed to open help: hr = 0x%1!x!",
             hr));
   }
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\executewizard.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of ExecuteWizard
//
// 30 Mar 2000 sburns
// 05 Fed 2001 jeffjon  copied and modified to work with 
//                      a Win32 version of CYS



#include "pch.h"
#include "resource.h"



String
LaunchWrapperWizardExe(
   const String& commandLine, 
   unsigned      launchFailureResId,
   unsigned      failureResId,
   unsigned      successResId)
{
   LOG_FUNCTION2(LaunchWrapperWizardExe, commandLine);
   ASSERT(!commandLine.empty());
   ASSERT(launchFailureResId);
   ASSERT(failureResId);
   ASSERT(successResId);

   String result;
   do
   {
      DWORD exitCode = 0;
      HRESULT hr = CreateAndWaitForProcess(commandLine, exitCode);
      if (FAILED(hr))
      {
         result = String::load(launchFailureResId);
         break;
      }

      // the exit codes from the wrapper wizards are HRESULTs.
      
      if (SUCCEEDED(static_cast<HRESULT>(exitCode)))
      {
         result = String::load(successResId);
         break;
      }

      result = String::load(failureResId);
   }
   while (0);

   LOG(result);

   return result;
}
   

   
String
LaunchPrintWizardExe(
   const String& commandLine, 
   unsigned      launchFailureResId,
   unsigned      failureResId,
   unsigned      successResId)
{
   LOG_FUNCTION2(LaunchPrintWizardExe, commandLine);
   ASSERT(!commandLine.empty());
   ASSERT(launchFailureResId);
   ASSERT(failureResId);
   ASSERT(successResId);

   String result;
   do
   {
      HINSTANCE printui = 0;
      HRESULT hr = Win::LoadLibrary(L"printui.dll", printui);

      if (SUCCEEDED(hr))
      {
         FARPROC proc = 0;
         hr = Win::GetProcAddress(printui, L"PrintUIEntryW", proc);

         if (SUCCEEDED(hr))
         {
            typedef DWORD (*PrintUIEntryW)(HWND, HINSTANCE, PCTSTR, UINT);      
            PrintUIEntryW uiproc = reinterpret_cast<PrintUIEntryW>(proc);

            DWORD err = 
               uiproc(
                  Win::GetActiveWindow(),
                  Win::GetModuleHandle(),
                  commandLine.c_str(),
                  TRUE);
            hr = Win32ToHresult(err);
         }
         else
         {
            LOG(L"unable to locate PrintUIEntryW proc address");
         }

         HRESULT unused = Win::FreeLibrary(printui);

         ASSERT(SUCCEEDED(unused));
      }

      if (SUCCEEDED(hr))
      {
         result = String::load(successResId);
         break;
      }

      result = String::format(failureResId, GetErrorMessage(hr).c_str());
   }
   while (0);

   LOG(result);

   return result;
}



bool ExecuteWizard(
   PCWSTR serviceName,
   String& resultText)
{
   LOG_FUNCTION2(
      ExecuteWizard,
      serviceName ? serviceName : L"(empty)");

   bool result = true;

   do
   {
      if (!serviceName)
      {
         ASSERT(serviceName);
         break;
      }

      String service(serviceName);

      if (service.icompare(CYS_DNS_SERVICE_NAME) == 0)
      {
         // launch wrapper exe

         resultText =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_DNS_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               IDS_LAUNCH_DNS_WIZARD_FAILED,
               IDS_DNS_WIZARD_FAILED,
               IDS_DNS_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_DHCP_SERVICE_NAME) == 0)
      {
         // launch wrapper exe

         resultText =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_DHCP_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               IDS_LAUNCH_DHCP_WIZARD_FAILED,
               IDS_DHCP_WIZARD_FAILED,
               IDS_DHCP_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_RRAS_SERVICE_NAME) == 0)
      {
         // launch wrapper exe

         resultText =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_RRAS_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               IDS_LAUNCH_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_PRINTER_WIZARD_NAME) == 0)
      {
         resultText =
            LaunchPrintWizardExe(
               L"/il /Wr",
               IDS_LAUNCH_PRINTER_WIZARD_FAILED,
               IDS_PRINTER_WIZARD_FAILED,
               IDS_PRINTER_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_PRINTER_DRIVER_WIZARD_NAME) == 0)
      {
         resultText =
            LaunchPrintWizardExe(
               L"/id /Wr",
               IDS_LAUNCH_PRINTER_DRIVER_WIZARD_FAILED,
               IDS_PRINTER_DRIVER_WIZARD_FAILED,
               IDS_PRINTER_DRIVER_WIZARD_SUCCEEDED);
      }
      else
      {
         LOG(String::format(
                L"Unknown wizard name: %1",
                service.c_str()));
         ASSERT(FALSE);
         result = false;
      }
   } while (false);

   LOG(resultText);
   LOG_BOOL(result);
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expresspages.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expressdhcppage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ExpressDHCPPage.h
//
// Synopsis:  Declares the express DHCP page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_EXPRESSDHCPPAGE_H
#define __CYS_EXPRESSDHCPPAGE_H

#include "CYSWizardPage.h"

class ExpressDHCPPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      ExpressDHCPPage();

      // Destructor

      virtual 
      ~ExpressDHCPPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      ExpressDHCPPage(const ExpressDHCPPage&);
      const ExpressDHCPPage& operator=(const ExpressDHCPPage&);

};

#endif // __CYS_EXPRESSDHCPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expressinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ExpressInstallationUnit.h
//
// Synopsis:  Declares a ExpressInstallationUnit
//            This object has the knowledge for installing the
//            services for the express path: AD, DNS, and DHCP
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_EXPRESSINSTALLATIONUNIT_H
#define __CYS_EXPRESSINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class ExpressInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      ExpressInstallationUnit();

      // Destructor
      virtual
      ~ExpressInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      HRESULT
      DoTapiConfig(const String& dnsName);

};

#endif // __CYS_EXPRESSINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expressinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ExpressInstallationUnit.cpp
//
// Synopsis:  Defines a ExpressInstallationUnit
//            This object has the knowledge for installing the
//            services for the express path.  AD, DNS, and DHCP
//
// History:   02/08/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "ExpressInstallationUnit.h"
#include "InstallationUnitProvider.h"

#define CYS_TAPI_CONFIG_COMMAND_FORMAT L"tapicfg.exe Install /Directory:%1 /ForceDefault"

// Finish page help 
static PCWSTR CYS_EXPRESS_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_first_server.htm";

ExpressInstallationUnit::ExpressInstallationUnit() :
   InstallationUnit(
      IDS_EXPRESS_PATH_TYPE, 
      IDS_EXPRESS_PATH_DESCRIPTION, 
      CYS_EXPRESS_FINISH_PAGE_HELP,
      EXPRESS_INSTALL)
{
   LOG_CTOR(ExpressInstallationUnit);
}


ExpressInstallationUnit::~ExpressInstallationUnit()
{
   LOG_DTOR(ExpressInstallationUnit);
}


InstallationReturnType
ExpressInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(ExpressInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   do
   {
      // Warn the user of a reboot during installation

      if (IDOK == Win::MessageBox(
                     hwnd,
                     String::load(IDS_CONFIRM_REBOOT),
                     String::load(IDS_WIZARD_TITLE),
                     MB_OKCANCEL))
      {

         // Call the DNS installation unit to set the static IP address and subnet mask

         result = InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().InstallService(logfileHandle, hwnd);
         if (result != INSTALL_SUCCESS)
         {
            LOG(L"Failed to install static IP address and subnet mask");
            break;
         }

         // Install DHCP

         result = InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().InstallService(logfileHandle, hwnd);
         if (result != INSTALL_SUCCESS)
         {
            LOG(L"Failed to install DCHP");
            break;
         }

         result = InstallationUnitProvider::GetInstance().GetADInstallationUnit().InstallService(logfileHandle, hwnd);
      }
      else
      {
         result = INSTALL_FAILURE;
      }
   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}


bool
ExpressInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(ExpressInstallationUnit:IsServiceInstalled);

   bool result = false;

   if (InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().IsServiceInstalled() ||
       InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().IsServiceInstalled() ||
       InstallationUnitProvider::GetInstance().GetADInstallationUnit().IsServiceInstalled())
   {
      result = true;
   }

   LOG_BOOL(result);

   return result;
}

bool
ExpressInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(ExpressInstallationUnit::GetFinishText);

//   ADInstallationUnit& adInstallationUnit =
//      InstallationUnitProvider::GetInstance().GetADInstallationUnit();

   DNSInstallationUnit& dnsInstallationUnit =
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit();

   DHCPInstallationUnit& dhcpInstallationUnit =
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit();

   // Add the standard install message

   message  = String::load(IDS_EXPRESS_FINISH_TEXT);

   // Add the create domain message

   message += String::format(
                 String::load(IDS_EXPRESS_FINISH_DOMAIN_NAME),
                 InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainDNSName().c_str());

   // Get the static IP address so that it is easy to format

   DWORD staticIP = dnsInstallationUnit.GetStaticIPAddress();

   // Add the static IP message

   message += String::format(
                 String::load(IDS_EXPRESS_FINISH_STATIC_IP),
                 FIRST_IPADDRESS(staticIP),
                 SECOND_IPADDRESS(staticIP),
                 THIRD_IPADDRESS(staticIP),
                 FOURTH_IPADDRESS(staticIP));

   // Get the DHCP starting and ending scope IP addresses so that it is easy to format

   DWORD startIP = dhcpInstallationUnit.GetStartIPAddress();
   DWORD endIP = dhcpInstallationUnit.GetEndIPAddress();

   // Add the DHCP scope message

   message += String::format(
                 String::load(IDS_EXPRESS_FINISH_DHCP_SCOPE),
                 FIRST_IPADDRESS(startIP),
                 SECOND_IPADDRESS(startIP),
                 THIRD_IPADDRESS(startIP),
                 FOURTH_IPADDRESS(startIP),
                 FIRST_IPADDRESS(endIP),
                 SECOND_IPADDRESS(endIP),
                 THIRD_IPADDRESS(endIP),
                 FOURTH_IPADDRESS(endIP));

   // Add the TAPI message

   message += String::load(IDS_EXPRESS_FINISH_TAPI);

   LOG_BOOL(true);
   return true;
}


HRESULT
ExpressInstallationUnit::DoTapiConfig(const String& dnsName)
{
   LOG_FUNCTION2(
      ExpressInstallationUnit::DoTapiConfig,
      dnsName);

   // Comments below taken from old HTA CYS

	/*
	// The TAPICFG is a straight command line utility where all the required parameters can be at once supplied 
	// in the command line arguments and there are no sub-menus to traverse. The /Directory switch takes the DNS
	// name of the NC to be created and the optional /Server switch takes the name of the domain controller on 
	// which the NC is to be created. If the /server switch is not specified, then the command assumes it is 
	// running on a DC and tries to create the NC locally.
	// NDNC (non-domain naming context) is a partition that is created on Active Directory and serves as a dynamic 
	// directory, where its used for temporary storage (depending on TTL) of objects pre-defined in the AD schema. 
	// Here in TAPI we use NDNC to store user and conference information dynamically on the server.
	*/

   HRESULT hr = S_OK;

   String commandLine = String::format(CYS_TAPI_CONFIG_COMMAND_FORMAT, dnsName.c_str());

   DWORD exitCode = 0;
   hr = CreateAndWaitForProcess(commandLine, exitCode);
   
   if (SUCCEEDED(hr) &&
       exitCode != 0)
   {
      LOG(String::format(L"Exit code = %1!x!", exitCode));
      hr = E_FAIL;
   }

   LOG(String::format(L"hr = %1!x!", hr));

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expressdhcppage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ExpressDHCPPage.cpp
//
// Synopsis:  Defines the express DHCP page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "ExpressDHCPPage.h"
#include "state.h"


static PCWSTR EXPRESSDHCP_PAGE_HELP = L"cys.chm::/cys_configuring_first_server.htm";

ExpressDHCPPage::ExpressDHCPPage()
   :
   CYSWizardPage(
      IDD_EXPRESS_DHCP_PAGE, 
      IDS_EXPRESS_DHCP_TITLE, 
      IDS_EXPRESS_DHCP_SUBTITLE,
      EXPRESSDHCP_PAGE_HELP)
{
   LOG_CTOR(ExpressDHCPPage);
}

   

ExpressDHCPPage::~ExpressDHCPPage()
{
   LOG_DTOR(ExpressDHCPPage);
}


void
ExpressDHCPPage::OnInit()
{
   LOG_FUNCTION(ExpressDHCPPage::OnInit);
}


bool
ExpressDHCPPage::OnSetActive()
{
   LOG_FUNCTION(ExpressDHCPPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
ExpressDHCPPage::Validate()
{
   LOG_FUNCTION(ExpressDHCPPage::Validate);

   int nextPage = -1;

   DWORD startAddress = 0;
   LRESULT startResult = Win::SendMessage(
                            Win::GetDlgItem(hwnd, IDC_START_IPADDRESS),
                            IPM_GETADDRESS,
                            0,
                            (LPARAM)&startAddress);

   DWORD endAddress = 0;
   LRESULT endResult = Win::SendMessage(
                          Win::GetDlgItem(hwnd, IDC_END_IPADDRESS),
                          IPM_GETADDRESS,
                          0,
                          (LPARAM)&endAddress);

   if (!startResult || !endResult)
   {
      String message = String::load(IDS_BOTH_IPADDRESS_REQUIRED);
      popup.Gripe(hwnd, IDC_START_IPADDRESS, message);
      nextPage = -1;
   }
   else
   {
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetStartIPAddress(startAddress);
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetEndIPAddress(endAddress);

      nextPage = IDD_FINISH_PAGE;
   }
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expressdnspage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ExpressDNSPage.cpp
//
// Synopsis:  Defines the express DNS page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "ExpressDNSPage.h"
#include "state.h"

static PCWSTR EXPRESSDNS_PAGE_HELP = L"cys.chm::/cys_configuring_first_server.htm";

ExpressDNSPage::ExpressDNSPage()
   :
   CYSWizardPage(
      IDD_EXPRESS_DNS_PAGE, 
      IDS_EXPRESS_DNS_TITLE, 
      IDS_EXPRESS_DNS_SUBTITLE,
      EXPRESSDNS_PAGE_HELP)
{
   LOG_CTOR(ExpressDNSPage);
}

   

ExpressDNSPage::~ExpressDNSPage()
{
   LOG_DTOR(ExpressDNSPage);
}


void
ExpressDNSPage::OnInit()
{
   LOG_FUNCTION(ExpressDNSPage::OnInit);


}


bool
ExpressDNSPage::OnSetActive()
{
   LOG_FUNCTION(ExpressDNSPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   // Initialize the static IP address to 192.168.16.2

   
   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_STATIC_IPADDRESS),
      IPM_SETADDRESS,
      0,
      MAKEIPADDRESS(192, 168, 16, 2));

   // Initialize the subnet mask to 255.255.255.0

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_MASK_IPADDRESS),
      IPM_SETADDRESS,
      0,
      MAKEIPADDRESS(255, 255, 255, 0));

   return true;
}


int
ExpressDNSPage::Validate()
{
   LOG_FUNCTION(ExpressDNSPage::Validate);

   int nextPage = -1;

   do
   {
      DWORD ipaddress = 0;
      LRESULT ipValidFields = Win::SendMessage(
                               Win::GetDlgItem(hwnd, IDC_STATIC_IPADDRESS),
                               IPM_GETADDRESS,
                               0,
                               (LPARAM)&ipaddress);

      if (ipValidFields <= 0)
      {
         String message = String::load(IDS_IPADDRESS_REQUIRED);
         popup.Gripe(hwnd, IDC_STATIC_IPADDRESS, message);
         nextPage = -1;
         break;
      }

      DWORD mask = 0;
      LRESULT maskValidFields = Win::SendMessage(
                                   Win::GetDlgItem(hwnd, IDC_MASK_IPADDRESS),
                                   IPM_GETADDRESS,
                                   0,
                                   (LPARAM)&mask);
      if (maskValidFields <= 0)
      {
         String message = String::load(IDS_MASK_REQUIRED);
         popup.Gripe(hwnd, IDC_MASK_IPADDRESS, message);
         nextPage = -1;
         break;
      }

      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetStaticIPAddress(ipaddress);
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetSubnetMask(mask);

      nextPage = IDD_EXPRESS_DHCP_PAGE;

   } while (false);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expressdnspage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      ExpressDNSPage.h
//
// Synopsis:  Declares the express DNS page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_EXPRESSDNSPAGE_H
#define __CYS_EXPRESSDNSPAGE_H

#include "CYSWizardPage.h"

class ExpressDNSPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      ExpressDNSPage();

      // Destructor

      virtual 
      ~ExpressDNSPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      ExpressDNSPage(const ExpressDNSPage&);
      const ExpressDNSPage& operator=(const ExpressDNSPage&);

};

#endif // __CYS_EXPRESSDNSPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\expresspages.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\fileserverpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      FileServerPage.h
//
// Synopsis:  Declares the File Server page
//            for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_FILESERVERPAGE_H
#define __CYS_FILESERVERPAGE_H

#include "CYSWizardPage.h"


class FileServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      FileServerPage();

      // Destructor

      virtual 
      ~FileServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


      void
      SetControlState();

   private:

      void
      UpdateQuotaControls(
         unsigned controlIDFrom,
         unsigned editboxID);

      // not defined: no copying allowed
      FileServerPage(const FileServerPage&);
      const FileServerPage& operator=(const FileServerPage&);

};


#endif // __CYS_FILESERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\finishpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      FinishPage.h
//
// Synopsis:  Declares the Finish Page for the CYS
//            wizard
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_FINISHPAGE_H
#define __CYS_FINISHPAGE_H


class FinishPage : public WizardPage
{
   public:
      
      // Constructor
      
      FinishPage();

      // Destructor

      virtual 
      ~FinishPage();


   protected:

      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnWizFinish();

      virtual
      bool
      OnHelp();

      virtual
      bool
      OnQueryCancel();

   private:

      void
      OpenLogFile(const String& logName);

      // not defined: no copying allowed
      FinishPage(const FinishPage&);
      const FinishPage& operator=(const FinishPage&);

};

#endif // __CYS_FINISHPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\fileinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      FileInstallationUnit.h
//
// Synopsis:  Declares a FileInstallationUnit
//            This object has the knowledge for installing the
//            disk quotas and such
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_FILEINSTALLATIONUNIT_H
#define __CYS_FILEINSTALLATIONUNIT_H

#include "InstallationUnit.h"

typedef enum
{
   QUOTA_SIZE_KB,
   QUOTA_SIZE_MB,
   QUOTA_SIZE_GB
} QuotaSizeType;

class FileInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      FileInstallationUnit();

      // Destructor

      virtual
      ~FileInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      virtual
      String
      GetServiceDescription();

      void
      SetSpaceQuotaSize(QuotaSizeType size);

      QuotaSizeType
      GetSpaceQuotaSize() const { return spaceQuotaSize; }

      void
      SetLevelQuotaSize(QuotaSizeType size);

      QuotaSizeType
      GetLevelQuotaSize() const { return levelQuotaSize; }

      void
      SetSpaceQuotaValue(LONGLONG value);

      LONGLONG
      GetSpaceQuotaValue() const { return spaceQuotaValue; }

      void
      SetLevelQuotaValue(LONGLONG value);

      LONGLONG
      GetLevelQuotaValue() const { return levelQuotaValue; }

      void
      SetDefaultQuotas(bool value);

      bool
      GetDefaultQuotas() const { return setDefaultQuotas; }

      void
      SetDenyUsersOverQuota(bool value);

      bool
      GetDenyUsersOverQuota() const { return denyUsersOverQuota; }

      void
      SetEventDiskSpaceLimit(bool value);

      bool
      GetEventDiskSpaceLimit() const { return eventDiskSpaceLimit;  }

      void
      SetEventWarningLevel(bool value);

      bool
      GetEventWarningLevel() const { return eventWarningLevel; }

      void
      SetInstallIndexingService(bool value);

      bool
      GetInstallIndexingService() const { return installIndexingService; }

   private:

      void
      WriteDiskQuotas(HANDLE logfileHandle);

      void
      ConvertValueBySizeType(
         LONGLONG value,
         QuotaSizeType sizeType,
         LONGLONG& newValue);


      QuotaSizeType  spaceQuotaSize;
      QuotaSizeType  levelQuotaSize;
      LONGLONG       spaceQuotaValue;
      LONGLONG       levelQuotaValue;
      bool           setDefaultQuotas;
      bool           denyUsersOverQuota;
      bool           eventDiskSpaceLimit;
      bool           eventWarningLevel;
      bool           installIndexingService;
};

#endif // __CYS_FILEINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\finishpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      FinishPage.cpp
//
// Synopsis:  Defines the Finish Page for the CYS
//            wizard
//
// History:   02/03/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "FinishPage.h"
#include "state.h"
#include "Dialogs.h"

FinishPage::FinishPage()
   :
   WizardPage(IDD_FINISH_PAGE, IDS_FINISH_TITLE, IDS_FINISH_SUBTITLE, false, true)
{
   LOG_CTOR(FinishPage);
}

   

FinishPage::~FinishPage()
{
   LOG_DTOR(FinishPage);
}


void
FinishPage::OnInit()
{
   LOG_FUNCTION(FinishPage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

}


bool
FinishPage::OnSetActive()
{
   LOG_FUNCTION(FinishPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_FINISH | PSWIZB_BACK);

   // Get the finish text from the installation unit and put it in the finish box

   String message;

   bool changes =
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit().GetFinishText(message);

   Win::SetDlgItemText(hwnd, IDC_FINISH_MESSAGE, message);

   // set the rerun check box state

   if (InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit().GetInstallationUnitType() 
       == DC_INSTALL ||
       InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit().GetInstallationUnitType()
       == EXPRESS_INSTALL)
   {
      // the wizard must be rerun when we are installing a DC

      Win::ShowWindow(
         Win::GetDlgItem(hwnd, IDC_RERUN_CHECK),
         SW_HIDE);

      Win::Button_SetCheck(
         Win::GetDlgItem(hwnd, IDC_RERUN_CHECK),
         BST_CHECKED);

      Win::EnableWindow(
         Win::GetDlgItem(hwnd, IDC_RERUN_CHECK),
         false);
   }
   else
   {
      Win::ShowWindow(
         Win::GetDlgItem(hwnd, IDC_RERUN_CHECK),
         SW_SHOW);

      Win::Button_SetCheck(
         Win::GetDlgItem(hwnd, IDC_RERUN_CHECK),
         State::GetInstance().RerunWizard() ? BST_CHECKED : BST_UNCHECKED);

      Win::EnableWindow(
         Win::GetDlgItem(hwnd, IDC_RERUN_CHECK),
         true);
   }

   if (!changes)
   {
      popup.MessageBox(
         hwnd,
         IDS_NO_CHANGES_MESSAGEBOX_TEXT,
         MB_OK | MB_ICONWARNING);
   }
   return true;
}

bool
FinishPage::OnHelp()
{
   LOG_FUNCTION(FinishPage::OnHelp);

   // NOTE: I am not using Win::HtmlHelp here so that the help
   //       is actually running in a different process.  This
   //       allows us to close down CYS without closing the help
   //       window.

   String commandline = 
      L"hh.exe \"" + 
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit().GetFinishHelp() +
      L"\"";

   HRESULT hr = MyCreateProcess(commandline);
   if (FAILED(hr))
   {
      LOG(String::format(
             L"Failed to open help: hr = 0x%1!x!",
             hr));
   }
   return true;
}

bool
FinishPage::OnWizFinish()
{
   LOG_FUNCTION(FinishPage::OnWizFinish);

   Win::WaitCursor wait;
   bool result = false;

   // Get the rerun state

   bool rerunWizard = Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_RERUN_CHECK));

   State::GetInstance().SetRerunWizard(rerunWizard);


   // Open the log file and pass the handle to the installation unit

   // Create the log file

   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
   }

   // Install the current Installation Unit.  This may be one or more services depending on the
   // path that was taken through the wizard

   InstallationUnit& installationUnit = 
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit();

   InstallationReturnType installResult =
      installationUnit.InstallService(logfileHandle, hwnd);

   FinishDialog dialog(logName, installationUnit.GetFinishHelp());

   if (INSTALL_SUCCESS == installResult)
   {
      LOG(L"Service installed successfully");

      // Bring up finish dialog that allows the user to select to
      // show help and/or the log file

      dialog.ModalExecute(hwnd);
   }
   else if (INSTALL_NO_CHANGES == installResult ||
            INSTALL_SUCCESS_REBOOT == installResult)
   {
      LOG(L"Service installed successfully");
      LOG(L"Not logging results because reboot was initiated");
   }
   else if (INSTALL_SUCCESS_PROMPT_REBOOT == installResult)
   {
      LOG(L"Service installed successfully");
      LOG(L"Prompting user to reboot");

      if (-1 == SetupPromptReboot(
                   0,
                   hwnd,
                   FALSE))
      {
         LOG(String::format(
                L"Failed to reboot: hr = %1!x!",
                GetLastError()));
      }

      // At this point the system should be shutting down
      // so don't do anything else
   }
   else
   {
      LOG(L"Service failed to install");

      if (IDYES == popup.MessageBox(
                      hwnd,
                      String::load(IDS_FAILED_INSTALL),
                      MB_YESNO | MB_ICONWARNING))
      {
         dialog.OpenLogFile();
         Win::SetForegroundWindow(hwnd);
      }

      result = true;
   }

   // Add an additional line at the end of the log file
   // only if we are not rebooting.  All the reboot
   // scenarios require additional logging to the same
   // entry.

   if (installResult != INSTALL_SUCCESS_REBOOT)
   {
      CYS_APPEND_LOG(L"\r\n");
   }

   LOG_BOOL(result);
   Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result ? TRUE : FALSE);

   if (!result)
   {
      // clean up the InstallationUnits so that all the data must be re-read if
      // if CYS automatically restarts

      InstallationUnitProvider::GetInstance().Destroy();
   }

   return true;
}

bool
FinishPage::OnQueryCancel()
{
   LOG_FUNCTION(FinishPage::OnQueryCancel);

   bool result = false;

   // set the rerun state to false so the wizard doesn't
   // just restart itself

   State::GetInstance().SetRerunWizard(false);

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
      result ? TRUE : FALSE);

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\fileinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      FileInstallationUnit.cpp
//
// Synopsis:  Defines a FileInstallationUnit
//            This object has the knowledge for installing the
//            quotas on disk usage and such
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "FileInstallationUnit.h"
#include "state.h"
#include "InstallationUnitProvider.h"

#define INITGUIDS  // This has to be present so the the GUIDs defined
                   // in dskquota.h can be linked
#include <dskquota.h>


// REVIEW_JEFFJON : are there equivalents that could just be included???
#define CYS_KB    1024
#define CYS_MB    1048576
#define CYS_GB    1073741824


// Finish page help 
static PCWSTR CYS_FILE_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_file_server.htm";


FileInstallationUnit::FileInstallationUnit() :
   spaceQuotaSize(QUOTA_SIZE_KB),
   levelQuotaSize(QUOTA_SIZE_KB),
   spaceQuotaValue(1),
   levelQuotaValue(1),
   setDefaultQuotas(false),
   denyUsersOverQuota(false),
   eventDiskSpaceLimit(false),
   eventWarningLevel(false),
   InstallationUnit(
      IDS_FILE_SERVER_TYPE, 
      IDS_FILE_SERVER_DESCRIPTION, 
      CYS_FILE_FINISH_PAGE_HELP,
      FILESERVER_INSTALL)
{
   LOG_CTOR(FileInstallationUnit);
}


FileInstallationUnit::~FileInstallationUnit()
{
   LOG_DTOR(FileInstallationUnit);
}


InstallationReturnType
FileInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(FileInstallationUnit::InstallService);

   CYS_APPEND_LOG(String::load(IDS_LOG_FILE_SERVER));

   InstallationReturnType result = INSTALL_SUCCESS;

   bool bChangeMade = false;

   // Set the default disk quotas if chosen by the user

   if (setDefaultQuotas)
   {
      LOG(L"Setting default disk quotas");

      CYS_APPEND_LOG(String::load(IDS_LOG_FILE_SERVER_SET_QUOTAS));

      WriteDiskQuotas(logfileHandle);
      bChangeMade = true;
   }

   // Turn on or off the indexing service as chosen by the user

   HRESULT indexingResult = S_OK;

   if (IsIndexingServiceOn() &&
       !GetInstallIndexingService())
   {
      indexingResult = StopIndexingService();
      if (SUCCEEDED(indexingResult))
      {
         LOG(L"Stop indexing service succeeded");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_STOP_SUCCEEDED));
      }
      else
      {
         LOG(L"Stop indexing server failed");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_STOP_FAILED));

         // REVIEW_JEFFJON : need to log error values
      }
      bChangeMade = true;
   }
   else if (!IsIndexingServiceOn() &&
            GetInstallIndexingService())
   {
      indexingResult = StartIndexingService();
      if (SUCCEEDED(indexingResult))
      {
         LOG(L"Start indexing service succeeded");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_START_SUCCEEDED));
      }
      else
      {
         LOG(L"Start indexing server failed");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_START_FAILED));

         // REVIEW_JEFFJON : need to log error values
      }
      bChangeMade = true;
   }

   if (!bChangeMade)
   {
      result = INSTALL_NO_CHANGES;
   }
   else
   {
      if (FAILED(indexingResult))
      {
         result = INSTALL_FAILURE;
      }
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
FileInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(FileInstallationUnit::IsServiceInstalled);

   bool result = false;

   if (!State::GetInstance().HasNTFSDrive() &&
       InstallationUnitProvider::GetInstance().GetSharePointInstallationUnit().IsServiceInstalled())
   {
      // There are no NTFS partitions and SharePoint is installed 
      // so we can't set disk quotas or turn off the indexing service

      result = true;
   }

   LOG_BOOL(result);

   return result;
}

bool
FileInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(FileInstallationUnit::GetFinishText);

   bool result = true;

   bool quotasTextSet = false;
   if (GetDefaultQuotas())
   {
      message += String::load(IDS_FILE_FINISH_DISK_QUOTAS);
      quotasTextSet = true;
   }

   bool indexingTextSet = false;
   if (IsIndexingServiceOn() &&
       !GetInstallIndexingService())
   {
      message += String::load(IDS_FILE_FINISH_INDEXING_OFF);
      indexingTextSet = true;
   }
   else if (!IsIndexingServiceOn() &&
            GetInstallIndexingService())
   {
      message += String::load(IDS_FILE_FINISH_INDEXING_ON);
      indexingTextSet = true;
   }
   else
   {
      // nothing needs to be done since they are leaving it in the same state

      indexingTextSet = false;
   }

   if (!quotasTextSet &&
       !indexingTextSet)
   {
      message += String::load(IDS_FINISH_NO_CHANGES);
      result = false;
   }

   LOG_BOOL(result);
   return result;
}

String
FileInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(FileInstallationUnit::GetServiceDescription);

   // Dynamically determine the string based on the availability
   // of services

   bool isSharePointInstalled = 
      InstallationUnitProvider::GetInstance().GetSharePointInstallationUnit().IsServiceInstalled();

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (State::GetInstance().HasNTFSDrive())
   {
      if (isSharePointInstalled)
      {
         resourceID = IDS_FILESERVER_QUOTAS_SHAREPOINT;
      }
      else
      {
         resourceID = IDS_FILESERVER_QUOTAS_NO_SHAREPOINT;
      }
   }
   else
   {
      if (isSharePointInstalled)
      {
         resourceID = IDS_FILESERVER_NO_QUOTAS_SHAREPOINT;
      }
      else
      {
         resourceID = IDS_FILESERVER_NO_QUOTAS_NO_SHAREPOINT;
      }
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   description = String::load(resourceID);

   return description;
}


void
FileInstallationUnit::SetSpaceQuotaSize(QuotaSizeType size)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetSpaceQuotaSize,
      String::format(L"%1!d!", size));

   spaceQuotaSize = size;
}

void
FileInstallationUnit::SetLevelQuotaSize(QuotaSizeType size)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetLevelQuotaSize,
      String::format(L"%1!d!", size));

   levelQuotaSize = size;
}


void
FileInstallationUnit::SetSpaceQuotaValue(LONGLONG value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetSpaceQuotaValue,
      String::format(L"%1!I64d!", value));

   spaceQuotaValue = value;
}


void
FileInstallationUnit::SetLevelQuotaValue(LONGLONG value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetLevelQuotaValue,
      String::format(L"%1!I64d!", value));

   levelQuotaValue = value;
}


void
FileInstallationUnit::SetDefaultQuotas(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetDefaultQuotas,
      value ? L"true" : L"false");

   setDefaultQuotas = value;
}


void
FileInstallationUnit::SetDenyUsersOverQuota(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetDenyUsersOverQuota,
      value ? L"true" : L"false");

   denyUsersOverQuota = value;
}


void
FileInstallationUnit::SetEventDiskSpaceLimit(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetEventDiskSpaceLimit,
      value ? L"true" : L"false");

   eventDiskSpaceLimit = value;
}


void
FileInstallationUnit::SetEventWarningLevel(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetEventWarningLevel,
      value ? L"true" : L"false");

   eventWarningLevel = value;
}

void
FileInstallationUnit::SetInstallIndexingService(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetInstallIndexingService,
      value ? L"true" : L"false");

   installIndexingService = value;
}


void
FileInstallationUnit::WriteDiskQuotas(HANDLE logfileHandle)
{
   LOG_FUNCTION(FileInstallationUnit::WriteDiskQuotas);

   HRESULT hr = S_OK;

   bool wasSomethingSet = false;

   do
   {

      // Calculate the new values

      LONGLONG newSpaceQuota = 0;
      ConvertValueBySizeType(spaceQuotaValue, spaceQuotaSize, newSpaceQuota);

      LONGLONG newLevelQuota = 0;
      ConvertValueBySizeType(levelQuotaValue, levelQuotaSize, newLevelQuota);

      DWORD logFlags = 0;
      logFlags |= eventDiskSpaceLimit ? DISKQUOTA_LOGFLAG_USER_LIMIT : 0;
      logFlags |= eventWarningLevel ? DISKQUOTA_LOGFLAG_USER_THRESHOLD : 0;

      DWORD quotaState = denyUsersOverQuota ? DISKQUOTA_STATE_ENFORCE : DISKQUOTA_STATE_TRACK;


      // Get a list of the valid drives

      StringVector dl;
      hr = FS::GetValidDrives(std::back_inserter(dl));
      if (FAILED(hr))
      {
         LOG(String::format(L"Failed to GetValidDrives: hr = %1!x!", hr));
         break;
      }

      // Loop through the list

      ASSERT(dl.size());
      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         // For each drive that supports disk quotas set the new values

         // Create a Disk Quota Control
         // Multiple initializations of this object are not allowed so
         // I have to create a new instance each time through the loop

         SmartInterface<IDiskQuotaControl> diskQuotaControl;
         hr = diskQuotaControl.AcquireViaCreateInstance(
                 CLSID_DiskQuotaControl,
                 0,
                 CLSCTX_INPROC_SERVER,
                 IID_IDiskQuotaControl);

         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to create a disk quota control: hr = %1!x!",
                   hr));
            break;
         }

         hr = diskQuotaControl->Initialize(
                 i->c_str(),
                 TRUE);
         if (FAILED(hr))
         {
            continue;
         }

         LOG(String::format(
                L"Setting quotas on drive %1",
                i->c_str()));

         // Turn on the disk quotas

         hr = diskQuotaControl->SetQuotaState(quotaState);
         if (SUCCEEDED(hr))
         {
            LOG(String::format(
                   L"Disk quota set on drive %1",
                   i->c_str()));

            CYS_APPEND_LOG(
               String::format(
                  String::load(IDS_LOG_DISK_QUOTA_DRIVE_FORMAT),
                  i->c_str()));

            if(denyUsersOverQuota)
            {
               LOG(L"Disk space denied to users exceeding limit");

               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_DISK_QUOTA_DENY_FORMAT),
                     newSpaceQuota));
            }
            else
            {
               LOG(L"Disk space is not denied to users exceeding limit");

               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_DISK_QUOTA_NOT_DENY_FORMAT),
                     newSpaceQuota));
            }
            wasSomethingSet = true;
         }

         // Set the default quota limit

         hr = diskQuotaControl->SetDefaultQuotaLimit(newSpaceQuota);
         if (SUCCEEDED(hr))
         {
            LOG(String::format(
                   L"Disk space limited to %1!I64d!",
                   newSpaceQuota));

            CYS_APPEND_LOG(
               String::format(
                  String::load(IDS_LOG_DISK_QUOTA_LIMIT_FORMAT),
                  newSpaceQuota));

            wasSomethingSet = true;
         }

         // Set the warning level threshold

         hr = diskQuotaControl->SetDefaultQuotaThreshold(newLevelQuota);
         if (SUCCEEDED(hr))
         {
            LOG(String::format(
                   L"Disk threshold set to %1!I64d!",
                   newLevelQuota));

            CYS_APPEND_LOG(
               String::format(
                  String::load(IDS_LOG_DISK_QUOTA_THRESHOLD_FORMAT),
                  newLevelQuota));

            wasSomethingSet = true;
         }

         // Set the event flags

         hr = diskQuotaControl->SetQuotaLogFlags(logFlags);
         if (SUCCEEDED(hr))
         {
            if (eventDiskSpaceLimit)
            {
               LOG(L"An event is logged when a user exceeds disk space limit");

               CYS_APPEND_LOG(
                     String::load(IDS_LOG_DISK_QUOTA_LOG_LIMIT));
            }

            if (eventWarningLevel)
            {
            
               LOG(L"An event is logged when a user exceeds the warning limit");

               CYS_APPEND_LOG(
                     String::load(IDS_LOG_DISK_QUOTA_LOG_WARNING));
            }
            wasSomethingSet = true;
         }
      }
   } while (false);

   if (FAILED(hr) && !wasSomethingSet)
   {
      CYS_APPEND_LOG(
         String::format(
            String::load(IDS_LOG_DISK_QUOTA_FAILED),
            hr));
   }

   LOG(String::format(
          L"hr = %1!x!",
          hr));

}


void
FileInstallationUnit::ConvertValueBySizeType(
   LONGLONG value,
   QuotaSizeType sizeType,
   LONGLONG& newValue)
{
   int multiplier = 0;
   switch (sizeType)
   {
      case QUOTA_SIZE_KB :
         multiplier = CYS_KB;
         break;

      case QUOTA_SIZE_MB :
         multiplier = CYS_MB;
         break;
         
      case QUOTA_SIZE_GB :
         multiplier = CYS_GB;
         break;

      default :
         ASSERT(false);
         break;
   }
          
   newValue = value * multiplier;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\fpcyscom.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed May 02 22:13:55 2001
 */
/* Compiler settings for fpcyscom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fpcyscom_h__
#define __fpcyscom_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISpCys_FWD_DEFINED__
#define __ISpCys_FWD_DEFINED__
typedef interface ISpCys ISpCys;
#endif 	/* __ISpCys_FWD_DEFINED__ */


#ifndef __SpCys_FWD_DEFINED__
#define __SpCys_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpCys SpCys;
#else
typedef struct SpCys SpCys;
#endif /* __cplusplus */

#endif 	/* __SpCys_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISpCys_INTERFACE_DEFINED__
#define __ISpCys_INTERFACE_DEFINED__

/* interface ISpCys */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISpCys;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("389C9713-9775-4206-A047-A2F749F8039D")
    ISpCys : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SPAlreadyInstalled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SPAskReplace( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbNeedToAsk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SPNonDefaultHomePage( 
            /* [retval][out] */ BSTR __RPC_FAR *pszHomePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SPInstall( 
            /* [in] */ VARIANT_BOOL bReplaceHomePage,
            /* [in] */ BSTR szDiskName,
            /* [retval][out] */ BSTR __RPC_FAR *pszErrorString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SPGetMessageIDs( 
            /* [out][in] */ DWORD __RPC_FAR *pcArray,
            /* [retval][out] */ DWORD __RPC_FAR *pArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpCysVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISpCys __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISpCys __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISpCys __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISpCys __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISpCys __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISpCys __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISpCys __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SPAlreadyInstalled )( 
            ISpCys __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbInstalled);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SPAskReplace )( 
            ISpCys __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbNeedToAsk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SPNonDefaultHomePage )( 
            ISpCys __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pszHomePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SPInstall )( 
            ISpCys __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bReplaceHomePage,
            /* [in] */ BSTR szDiskName,
            /* [retval][out] */ BSTR __RPC_FAR *pszErrorString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SPGetMessageIDs )( 
            ISpCys __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pcArray,
            /* [retval][out] */ DWORD __RPC_FAR *pArray);
        
        END_INTERFACE
    } ISpCysVtbl;

    interface ISpCys
    {
        CONST_VTBL struct ISpCysVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpCys_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpCys_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpCys_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpCys_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISpCys_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISpCys_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISpCys_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISpCys_SPAlreadyInstalled(This,pbInstalled)	\
    (This)->lpVtbl -> SPAlreadyInstalled(This,pbInstalled)

#define ISpCys_SPAskReplace(This,pbNeedToAsk)	\
    (This)->lpVtbl -> SPAskReplace(This,pbNeedToAsk)

#define ISpCys_SPNonDefaultHomePage(This,pszHomePage)	\
    (This)->lpVtbl -> SPNonDefaultHomePage(This,pszHomePage)

#define ISpCys_SPInstall(This,bReplaceHomePage,szDiskName,pszErrorString)	\
    (This)->lpVtbl -> SPInstall(This,bReplaceHomePage,szDiskName,pszErrorString)

#define ISpCys_SPGetMessageIDs(This,pcArray,pArray)	\
    (This)->lpVtbl -> SPGetMessageIDs(This,pcArray,pArray)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpCys_SPAlreadyInstalled_Proxy( 
    ISpCys __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbInstalled);


void __RPC_STUB ISpCys_SPAlreadyInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpCys_SPAskReplace_Proxy( 
    ISpCys __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbNeedToAsk);


void __RPC_STUB ISpCys_SPAskReplace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpCys_SPNonDefaultHomePage_Proxy( 
    ISpCys __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pszHomePage);


void __RPC_STUB ISpCys_SPNonDefaultHomePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpCys_SPInstall_Proxy( 
    ISpCys __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bReplaceHomePage,
    /* [in] */ BSTR szDiskName,
    /* [retval][out] */ BSTR __RPC_FAR *pszErrorString);


void __RPC_STUB ISpCys_SPInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpCys_SPGetMessageIDs_Proxy( 
    ISpCys __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pcArray,
    /* [retval][out] */ DWORD __RPC_FAR *pArray);


void __RPC_STUB ISpCys_SPGetMessageIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpCys_INTERFACE_DEFINED__ */



#ifndef __SPCYSCOMLib_LIBRARY_DEFINED__
#define __SPCYSCOMLib_LIBRARY_DEFINED__

/* library SPCYSCOMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SPCYSCOMLib;

EXTERN_C const CLSID CLSID_SpCys;

#ifdef __cplusplus

class DECLSPEC_UUID("252EF1C7-6625-4D44-AB9D-1D80E61384F9")
SpCys;
#endif
#endif /* __SPCYSCOMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\fileserverpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      FileServerPage.cpp
//
// Synopsis:  Defines the File server page of the CYS wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "FileServerPage.h"
#include "state.h"



#define DISK_QUOTAS_LIMIT_TEXT 10

static PCWSTR FILESERVER_PAGE_HELP = L"cys.chm::/cys_configuring_file_server.htm";

FileServerPage::FileServerPage()
   :
   CYSWizardPage(
      IDD_FILE_SERVER_PAGE, 
      IDS_FILE_SERVER_TITLE, 
      IDS_FILE_SERVER_SUBTITLE,
      FILESERVER_PAGE_HELP)
{
   LOG_CTOR(FileServerPage);
}

   

FileServerPage::~FileServerPage()
{
   LOG_DTOR(FileServerPage);
}


void
FileServerPage::OnInit()
{
   LOG_FUNCTION(FileServerPage::OnInit);

   // Load the size labels into the combo boxes

   StringList combolabels;
   String kb = String::load(IDS_KB);
   push_back_unique(combolabels, kb);
   push_back_unique(combolabels, String::load(IDS_MB));
   push_back_unique(combolabels, String::load(IDS_GB));

   // Add the size labels to the space combo box

   HWND spacecombo = Win::GetDlgItem(hwnd, IDC_SPACE_COMBO);

   int lastIndex = Win::ComboBox_AddStrings(
                      spacecombo, 
                      combolabels.begin(), 
                      combolabels.end());

   ASSERT(lastIndex != CB_ERR);

   // select the first entry in the combo box

   Win::ComboBox_SelectString(spacecombo, kb);

   // Add the size labels to the warning level combo box

   HWND levelcombo = Win::GetDlgItem(hwnd, IDC_LEVEL_COMBO);

   lastIndex = Win::ComboBox_AddStrings(
                  levelcombo, 
                  combolabels.begin(), 
                  combolabels.end());

   ASSERT(lastIndex != CB_ERR);

   Win::ComboBox_SelectString(levelcombo, kb);


   // unselect the "Set up default disk quotas" as the default

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_DEFAULT_QUOTAS_CHECK),
      BST_UNCHECKED);

   // Set a limit of 10 characters for both the edit boxes

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_SPACE_EDIT),
      DISK_QUOTAS_LIMIT_TEXT);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_LEVEL_EDIT),
      DISK_QUOTAS_LIMIT_TEXT);

   SetControlState();
}


bool
FileServerPage::OnSetActive()
{
   LOG_FUNCTION(FileServerPage::OnSetActive);

   // Disable the controls based on the UI state

   SetControlState();

   return true;
}

bool
FileServerPage::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(FileServerPage::OnCommand);

   bool result = false;

   if (controlIDFrom == IDC_DEFAULT_QUOTAS_CHECK ||
       controlIDFrom == IDC_SPACE_EDIT ||
       controlIDFrom == IDC_SPACE_COMBO ||
       controlIDFrom == IDC_LEVEL_EDIT ||
       controlIDFrom == IDC_LEVEL_COMBO)
   {
      if (code == CBN_SELCHANGE)
      {
         unsigned editboxID = (IDC_SPACE_COMBO == controlIDFrom) 
                                 ? IDC_SPACE_EDIT : IDC_LEVEL_EDIT;
         UpdateQuotaControls(controlIDFrom, editboxID);
      }
      SetControlState();
   }

   return result;
}

void
FileServerPage::UpdateQuotaControls(
    unsigned controlIDFrom,
    unsigned editboxID)
{
   LOG_FUNCTION(FileServerPage::UpdateQuotaControls);

   // On any change in the combobox clear the edit field

   Win::SetDlgItemText(hwnd, editboxID, L"");

   // Figure out which storage size is selected in the combo box

   String currentText = Win::ComboBox_GetCurText(
                           Win::GetDlgItem(hwnd, controlIDFrom));

   String kb = String::load(IDS_KB);
   String mb = String::load(IDS_MB);
   String gb = String::load(IDS_GB);

   if (currentText.icompare(kb) == 0)
   {
      Win::Edit_LimitText(
         Win::GetDlgItem(hwnd, editboxID),
         DISK_QUOTAS_LIMIT_TEXT);
   }
   else if (currentText.icompare(mb) == 0)
   {
      Win::Edit_LimitText(
         Win::GetDlgItem(hwnd, editboxID),
         DISK_QUOTAS_LIMIT_TEXT);
   }
   else if (currentText.icompare(gb) == 0)
   {
      // Need to reduce the amount of allowed text so that
      // we don't get overrun when we convert to bytes

      Win::Edit_LimitText(
         Win::GetDlgItem(hwnd, editboxID),
         DISK_QUOTAS_LIMIT_TEXT - 1);
   }
   else
   {
      ASSERT(false && L"Unknown size type found in combobox");
   }
}

void
FileServerPage::SetControlState()
{
   LOG_FUNCTION(FileServerPage::SetControlState);

   bool settingQuotas = 
      Win::Button_GetCheck(
         Win::GetDlgItem(hwnd, IDC_DEFAULT_QUOTAS_CHECK));

   // enable or disable all the controls based on the Set up default quotas checkbox

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_SPACE_STATIC),        settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_SPACE_EDIT),          settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_SPACE_COMBO),         settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_LEVEL_STATIC),        settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_LEVEL_EDIT),          settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_LEVEL_COMBO),         settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_DENY_DISK_CHECK),     settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_EVENT_STATIC),        settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_DISK_SPACE_CHECK),    settingQuotas);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_WARNING_LEVEL_CHECK), settingQuotas);

   // if both edit boxes contain a value and a size label has been chosen,
   // then enable the next button

   bool spaceEditFilled = !Win::GetWindowText(
                              Win::GetDlgItem(hwnd, IDC_SPACE_EDIT)).empty();
   bool spaceComboSelected = Win::ComboBox_GetCurSel(
                                Win::GetDlgItem(hwnd, IDC_SPACE_COMBO)) != CB_ERR;
   bool levelEditFilled = !Win::GetWindowText(
                              Win::GetDlgItem(hwnd, IDC_LEVEL_EDIT)).empty();
   bool levelComboSelected = Win::ComboBox_GetCurSel(
                                Win::GetDlgItem(hwnd, IDC_LEVEL_COMBO)) != CB_ERR;

   bool enableNext = (settingQuotas && 
                      spaceEditFilled && 
                      spaceComboSelected &&
                      levelEditFilled &&
                      levelComboSelected) ||
                     !settingQuotas;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      enableNext ? PSWIZB_NEXT | PSWIZB_BACK : PSWIZB_BACK);
}


int
FileServerPage::Validate()
{
   LOG_FUNCTION(FileServerPage::Validate);

   int nextPage = -1;


   // Gather the UI data and set it in the installation unit

   FileInstallationUnit& fileInstallationUnit = 
      InstallationUnitProvider::GetInstance().GetFileInstallationUnit();

   if (Win::Button_GetCheck(
          Win::GetDlgItem(hwnd, IDC_DEFAULT_QUOTAS_CHECK)))
   {
      // We are setting the defaults

      fileInstallationUnit.SetDefaultQuotas(true);

      fileInstallationUnit.SetDenyUsersOverQuota(
         Win::Button_GetCheck(
            Win::GetDlgItem(hwnd, IDC_DENY_DISK_CHECK)));

      fileInstallationUnit.SetEventDiskSpaceLimit(
         Win::Button_GetCheck(
            Win::GetDlgItem(hwnd, IDC_DISK_SPACE_CHECK)));

      fileInstallationUnit.SetEventWarningLevel(
         Win::Button_GetCheck(
            Win::GetDlgItem(hwnd, IDC_WARNING_LEVEL_CHECK)));

      // Get the value from the edit control as text
      // and convert to unsigned long

      String spaceStringValue = Win::GetDlgItemText(
                                   hwnd,
                                   IDC_SPACE_EDIT);

      LARGE_INTEGER spaceValue;
      spaceValue.QuadPart = 0;
      String::ConvertResult convertResult = spaceStringValue.convert(spaceValue);
      ASSERT(convertResult == String::CONVERT_SUCCESSFUL);

      fileInstallationUnit.SetSpaceQuotaValue(spaceValue.QuadPart);

      String levelStringValue = Win::GetDlgItemText(
                                   hwnd,
                                   IDC_LEVEL_EDIT);

      LARGE_INTEGER levelValue;
      levelValue.QuadPart = 0;
      convertResult = levelStringValue.convert(levelValue);
      ASSERT(convertResult == String::CONVERT_SUCCESSFUL);

      fileInstallationUnit.SetLevelQuotaValue(levelValue.QuadPart);


      String kb = String::load(IDS_KB);
      String mb = String::load(IDS_MB);
      String gb = String::load(IDS_GB);

      String currentText = Win::ComboBox_GetCurText(Win::GetDlgItem(hwnd, IDC_SPACE_COMBO));
      if (currentText.icompare(kb) == 0)
      {
         fileInstallationUnit.SetSpaceQuotaSize(QUOTA_SIZE_KB);
      }
      else if (currentText.icompare(mb) == 0)
      {
         fileInstallationUnit.SetSpaceQuotaSize(QUOTA_SIZE_MB);
      }
      else if (currentText.icompare(gb) == 0)
      {
         fileInstallationUnit.SetSpaceQuotaSize(QUOTA_SIZE_GB);
      }
      else
      {
         ASSERT(false && L"Unknown size type found in combobox");
      }

      currentText = Win::ComboBox_GetCurText(Win::GetDlgItem(hwnd, IDC_LEVEL_COMBO));
      if (currentText.icompare(kb) == 0)
      {
         fileInstallationUnit.SetLevelQuotaSize(QUOTA_SIZE_KB);
      }
      else if (currentText.icompare(mb) == 0)
      {
         fileInstallationUnit.SetLevelQuotaSize(QUOTA_SIZE_MB);
      }
      else if (currentText.icompare(gb) == 0)
      {
         fileInstallationUnit.SetLevelQuotaSize(QUOTA_SIZE_GB);
      }
      else
      {
         ASSERT(false && L"Unknown size type found in combobox");
      }

   }
   else
   {

      // The defaults will not be set

      fileInstallationUnit.SetDefaultQuotas(false);
   }

   if (InstallationUnitProvider::GetInstance().GetSharePointInstallationUnit().IsServiceInstalled())
   {
      nextPage = IDD_FINISH_PAGE;
   }
   else
   {
      nextPage = IDD_INDEXING_PAGE;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\indexingpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      IndexingPage.h
//
// Synopsis:  Declares the Indexing page
//            for the CYS Wizard
//
// History:   02/09/2001  JeffJon Created

#ifndef __CYS_INDEXINGPAGE_H
#define __CYS_INDEXINGPAGE_H

#include "CYSWizardPage.h"


class IndexingPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      IndexingPage();

      // Destructor

      virtual 
      ~IndexingPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      IndexingPage(const IndexingPage&);
      const IndexingPage& operator=(const IndexingPage&);

};


#endif // __CYS_INDEXINGPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\installationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      InstallationUnit.cpp
//
// Synopsis:  Defines an InstallationUnit
//            An InstallationUnit represents a single
//            entity that can be installed. (i.e. DHCP, IIS, etc.)
//
// History:   02/03/2001  JeffJon Created

#include "pch.h"

#include "InstallationUnit.h"

// It should match the values in the InstallationReturnType
// The values of the enum are used to index this array

extern String installReturnTypeStrings[] =
{
   String(L"INSTALL_SUCCESS"),
   String(L"INSTALL_FAILURE"),
   String(L"INSTALL_SUCCESS_REBOOT"),
   String(L"INSTALL_NO_CHANGES")
};

// Finish page help string

static PCWSTR FINISH_PAGE_HELP = L"cys.chm::/cys_topnode.htm";

InstallationUnit::InstallationUnit(unsigned int serviceNameID,
                                   unsigned int serviceDescriptionID,
                                   const String finishPageHelpString,
                                   InstallationUnitType newInstallType) :
   nameID(serviceNameID),
   descriptionID(serviceDescriptionID),
   finishHelp(finishPageHelpString),
   installationUnitType(newInstallType),
   name(),
   description()
{
}

String
InstallationUnit::GetServiceName()
{
   LOG_FUNCTION(InstallationUnit::GetServiceName);

   if (name.empty())
   {
      name = String::load(nameID);
   }

   return name;
}

String
InstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(InstallationUnit::GetServiceDescription);

   if (description.empty())
   {
      description = String::load(descriptionID);
   }

   return description;
}


String
InstallationUnit::GetFinishHelp()
{
   LOG_FUNCTION(InstallationUnit::GetFinishHelp);

   String result = finishHelp;

   LOG(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\installationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      InstallationUnit.h
//
// Synopsis:  Declares an InstallationUnit
//            An InstallationUnit represents a single
//            entity that can be installed. (i.e. DHCP, IIS, etc.)
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_INSTALLATIONUNIT_H
#define __CYS_INSTALLATIONUNIT_H

#include "pch.h"


// These are the values that can be returned from
// InstallationUnit::InstallService()

typedef enum
{
   INSTALL_SUCCESS,
   INSTALL_FAILURE,

   // this means that there should be no 
   // logging and reboot is handled by DCPromo
   // or Terminal Services installation
   
   INSTALL_SUCCESS_REBOOT, 
   
   // this means that the finish page should
   // prompt the user to reboot

   INSTALL_SUCCESS_PROMPT_REBOOT,

   // No changes were selected while going
   // through the wizard

   INSTALL_NO_CHANGES,

   // Installation was cancelled

   INSTALL_CANCELLED

} InstallationReturnType;

// This array of strings if for the UI log debugging only
// It should match the values in the InstallationReturnType
// above.  The values of the enum are used to index this array

extern String installReturnTypeStrings[];

// This macro is used to make it easier to log the return value from
// the InstallService() methods.  It takes a InstallationReturnType
// and uses that to index into the installReturnTypeStrings to get
// a string that is then logged to the the UI debug logfile

#define LOG_INSTALL_RETURN(returnType) LOG(installReturnTypeStrings[returnType]);

// This enum defines the installation unit types.  It is used as the key to
// the map in the InstallationUnitProvider to get the InstallationUnit
// associated with the type

typedef enum
{
   DNS_INSTALL,
   DHCP_INSTALL,
   WINS_INSTALL,
   RRAS_INSTALL,
   NETWORKSERVER_INSTALL,
   APPLICATIONSERVER_INSTALL,
   FILESERVER_INSTALL,
   PRINTSERVER_INSTALL,
   SHAREPOINT_INSTALL,
   MEDIASERVER_INSTALL,
   WEBSERVER_INSTALL,
   EXPRESS_INSTALL,
   DC_INSTALL,
   CLUSTERSERVER_INSTALL,
   NO_INSTALL
} InstallationUnitType;


class InstallationUnit
{
   public:

      // Constructor

      InstallationUnit(
         unsigned int serviceNameID,
         unsigned int serviceDescriptionID,
         const String finishPageHelpString,
         InstallationUnitType newInstallType = NO_INSTALL);

      // Destructor

      virtual
      ~InstallationUnit() {}


      // Installation virtual method

      virtual 
      InstallationReturnType 
      InstallService(HANDLE logfileHandle, HWND hwnd) = 0;

      virtual
      bool
      IsServiceInstalled() { return false; }


      // Return true if the installation unit will make some
      // changes during InstallService.  Return false if 
      // if it will not

      virtual
      bool
      GetFinishText(String& message) = 0;

      // Data accessors

      virtual
      String 
      GetServiceName(); 

      virtual
      String
      GetServiceDescription();

      virtual
      String
      GetFinishHelp();

      InstallationUnitType
      GetInstallationUnitType() { return installationUnitType; }

   protected:

      String name;
      String description;
      String finishHelp;

      unsigned int nameID;
      unsigned int descriptionID;

   private:

      InstallationUnitType installationUnitType;
};


#endif // __CYS_INSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\indexingpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      IndexingPage.cpp
//
// Synopsis:  Defines the Indexing page of the CYS wizard
//
// History:   02/09/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "IndexingPage.h"
#include "state.h"

static PCWSTR INDEXING_PAGE_HELP = L"cys.chm::/cys_configuring_file_server.htm";

IndexingPage::IndexingPage()
   :
   CYSWizardPage(
      IDD_INDEXING_PAGE, 
      IDS_INDEXING_TITLE, 
      IDS_INDEXING_SUBTITLE,
      INDEXING_PAGE_HELP)
{
   LOG_CTOR(IndexingPage);
}

   

IndexingPage::~IndexingPage()
{
   LOG_DTOR(IndexingPage);
}


void
IndexingPage::OnInit()
{
   LOG_FUNCTION(IndexingPage::OnInit);

   String staticText   = String::load(IDS_INDEX_PAGE_STATIC_INSTALLED);

   if (!IsIndexingServiceOn())
   {

      // The text is changed if the indexing service is off

      String yesRadioText = String::load(IDS_INDEXING_SERVICE_OFF_YES_RADIO);
      String noRadioText  = String::load(IDS_INDEXING_SERVICE_OFF_NO_RADIO);

      staticText = String::load(IDS_INDEX_PAGE_STATIC_NOT_INSTALLED);

      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_YES_RADIO),
         yesRadioText);

      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_NO_RADIO),
         noRadioText);
   }

   Win::SetWindowText(
      Win::GetDlgItem(hwnd, IDC_INDEX_STATIC),
      staticText);

   // No is always the default button

   Win::Button_SetCheck(GetDlgItem(hwnd, IDC_NO_RADIO), BST_CHECKED);
}


bool
IndexingPage::OnSetActive()
{
   LOG_FUNCTION(IndexingPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
IndexingPage::Validate()
{
   LOG_FUNCTION(IndexingPage::Validate);

   int nextPage = -1;

   InstallationUnitProvider::GetInstance().GetFileInstallationUnit().SetInstallIndexingService(
      Win::Button_GetCheck(
         Win::GetDlgItem(hwnd, IDC_YES_RADIO)));

   nextPage = IDD_FINISH_PAGE;

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\installationunitprovider.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      InstallationUnitProvider.h
//
// Synopsis:  Declares an InstallationUnitProvider
//            An InstallationUnitProvider manages the global
//            InstallationUnits for each service that can be
//            installed.
//
// History:   02/05/2001  JeffJon Created

#ifndef __CYS_INSTALLATIONUNITPROVIDER_H
#define __CYS_INSTALLATIONUNITPROVIDER_H

#include "InstallationUnit.h"
#include "DHCPInstallationUnit.h"
#include "DNSInstallationUnit.h"
#include "WINSInstallationUnit.h"
#include "RRASInstallationUnit.h"
#include "NetworkServerInstallationUnit.h"
#include "ApplicationInstallationUnit.h"
#include "FileInstallationUnit.h"
#include "PrintInstallationUnit.h"
#include "SharePointInstallationUnit.h"
#include "MediaInstallationUnit.h"
#include "WebInstallationUnit.h"
#include "ExpressInstallationUnit.h"
#include "ADInstallationUnit.h"
#include "ClusterInstallationUnit.h"

typedef std::map<InstallationUnitType, InstallationUnit*> InstallationUnitContainerType;

class InstallationUnitProvider
{
   public:
      
      static
      InstallationUnitProvider&
      GetInstance();

      static
      void
      Destroy();

      InstallationUnit&
      GetCurrentInstallationUnit();

      void
      SetCurrentInstallationUnit(InstallationUnitType installationUnitType);

      InstallationUnit&
      GetInstallationUnitForType(InstallationUnitType installationUnitType);

      DHCPInstallationUnit&
      GetDHCPInstallationUnit();

      DNSInstallationUnit&
      GetDNSInstallationUnit();

      WINSInstallationUnit&
      GetWINSInstallationUnit();

      RRASInstallationUnit&
      GetRRASInstallationUnit();

      NetworkServerInstallationUnit&
      GetNetworkServerInstallationUnit();

      ApplicationInstallationUnit&
      GetApplicationInstallationUnit();

      FileInstallationUnit&
      GetFileInstallationUnit();

      PrintInstallationUnit&
      GetPrintInstallationUnit();

      SharePointInstallationUnit&
      GetSharePointInstallationUnit();

      MediaInstallationUnit&
      GetMediaInstallationUnit();

      WebInstallationUnit&
      GetWebInstallationUnit();

      ExpressInstallationUnit&
      GetExpressInstallationUnit();

      ADInstallationUnit&
      GetADInstallationUnit();

      ClusterInstallationUnit&
      GetClusterInstallationUnit();

   private:

      // Constructor

      InstallationUnitProvider();

      // Destructor

      ~InstallationUnitProvider();

      void
      Init();

      // The current installation unit

      InstallationUnit* currentInstallationUnit;

      // Container for installation units.  The map is keyed
      // by the InstallationUnitType enum

      InstallationUnitContainerType installationUnitContainer;
      
      bool initialized;

      // not defined: no copying allowed
      InstallationUnitProvider(const InstallationUnitProvider&);
      const InstallationUnitProvider& operator=(const InstallationUnitProvider&);

};


#endif // __CYS_INSTALLATIONUNITPROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\isdhcp.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    isdhcp.c

Abstract:

    test program to see if a DHCP server is around or not.

Environment:

    Win2K+

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dhcpcapi.h>
#include <iprtrmib.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <winsock2.h>

BOOL
IsDHCPAvailableOnInterface(DWORD ipaddress)
/*++

Routine Description:

    This routine attempts to check if a dhcp
    server is around by trying to get a dhcp lease.

    If that fails, then it assume that no dhcp server
    is around.

Return Values:

    TRUE -- DHCP server is around
    FALSE -- DHCP server not around

In case of internal failures, it will return FALSE

--*/
{
   DWORD Error = 0;
   DHCP_CLIENT_UID DhcpClientUID = 
   {
      (BYTE*)"ISDHCP", 
      6
   };
   DHCP_OPTION_LIST DummyOptList;
   LPDHCP_LEASE_INFO LeaseInfo = 0;
   LPDHCP_OPTION_INFO DummyOptionInfo = 0;
   BOOL found = FALSE;
    
   if( ipaddress == INADDR_ANY ||
       ipaddress == INADDR_LOOPBACK ||
       ipaddress == 0x0100007f) 
   {
      //
      // oops.  not a usable address
      //
      return FALSE;
   }

   LeaseInfo = NULL;
   Error = DhcpLeaseIpAddress(
              RtlUlongByteSwap(ipaddress), 
              &DhcpClientUID, 
              0, 
              &DummyOptList, 
              &LeaseInfo, 
              &DummyOptionInfo);

   if( NO_ERROR != Error ) 
   {
      //
      // lease request failed.
      //

      if( ERROR_ACCESS_DENIED == Error ) 
      {
         //
         // We only get access denied if the dhcp server
         // is around to NAK it. So we have found a dhcp
         // server
         //
         found = TRUE;
      }
      return found;
   }

   if( LeaseInfo->DhcpServerAddress != INADDR_ANY &&
       LeaseInfo->DhcpServerAddress != INADDR_NONE ) 
   {
      //
      // Valid address, so dhcp is there.
      //

      DhcpReleaseIpAddressLease(
         RtlUlongByteSwap(ipaddress), 
         LeaseInfo);

      found = TRUE;
   }

   return found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\installationunitprovider.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      InstallationUnitProvider.cpp
//
// Synopsis:  Defines an InstallationUnitProvider
//            An InstallationUnitProvider manages the global
//            InstallationUnits for each service that can be
//            installed.
//
// History:   02/05/2001  JeffJon Created

#include "pch.h"

#include "InstallationUnitProvider.h"

static InstallationUnitProvider* installationUnitProvider = 0;

InstallationUnitProvider&
InstallationUnitProvider::GetInstance()
{
   if (!installationUnitProvider)
   {
      installationUnitProvider = new InstallationUnitProvider();

      installationUnitProvider->Init();
   }

   ASSERT(installationUnitProvider);

   return *installationUnitProvider;
}


InstallationUnitProvider::InstallationUnitProvider() :
   currentInstallationUnit(0),
   initialized(false)
{
   LOG_CTOR(InstallationUnitProvider);
}

InstallationUnitProvider::~InstallationUnitProvider()
{
   LOG_DTOR(InstallationUnitProvider);

   // Delete all the installation units

   for(
      InstallationUnitContainerType::iterator itr = 
         installationUnitContainer.begin();
      itr != installationUnitContainer.end();
      ++itr)
   {
      if ((*itr).second)
      {
         delete (*itr).second;
      }
   }

   installationUnitContainer.clear();
}
       
void
InstallationUnitProvider::Init()
{
   LOG_FUNCTION(InstallationUnitProvider::Init);

   if (!initialized)
   {
      // Create one of each type of installation unit

      installationUnitContainer.insert(
         std::make_pair(DHCP_INSTALL, new DHCPInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(DNS_INSTALL, new DNSInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(WINS_INSTALL, new WINSInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(RRAS_INSTALL, new RRASInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(NETWORKSERVER_INSTALL, new NetworkServerInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(APPLICATIONSERVER_INSTALL, new ApplicationInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(FILESERVER_INSTALL, new FileInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(PRINTSERVER_INSTALL, new PrintInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(SHAREPOINT_INSTALL, new SharePointInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(MEDIASERVER_INSTALL, new MediaInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(WEBSERVER_INSTALL, new WebInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(EXPRESS_INSTALL, new ExpressInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(DC_INSTALL, new ADInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(CLUSTERSERVER_INSTALL, new ClusterInstallationUnit()));


      // Mark as initialized

      initialized = true;
   }

}


void
InstallationUnitProvider::Destroy()
{
   LOG_FUNCTION(InstallationUnitProvider::Destroy);

   if (installationUnitProvider)
   {
      delete installationUnitProvider;
      installationUnitProvider = 0;
   }
}

void
InstallationUnitProvider::SetCurrentInstallationUnit(
   InstallationUnitType installationUnitType)
{
   LOG_FUNCTION(InstallationUnitProvider::SetCurrentInstallationUnit);

   currentInstallationUnit = (*(installationUnitContainer.find(installationUnitType))).second;
}


InstallationUnit&
InstallationUnitProvider::GetCurrentInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetCurrentInstallationUnit);

   ASSERT(currentInstallationUnit);

   return *currentInstallationUnit;
}

InstallationUnit&
InstallationUnitProvider::GetInstallationUnitForType(
   InstallationUnitType installationUnitType)
{
   LOG_FUNCTION(InstallationUnitProvider::GetInstallationUnitForType);

   InstallationUnit* result = (*(installationUnitContainer.find(installationUnitType))).second;

   ASSERT(result);
   return *result;
}

DHCPInstallationUnit&
InstallationUnitProvider::GetDHCPInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetDHCPInstallationUnit);

   DHCPInstallationUnit* dhcpInstallationUnit =
      dynamic_cast<DHCPInstallationUnit*>((*(installationUnitContainer.find(DHCP_INSTALL))).second);

   ASSERT(dhcpInstallationUnit);

   return *dhcpInstallationUnit;
}

DNSInstallationUnit&
InstallationUnitProvider::GetDNSInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetDNSInstallationUnit);

   DNSInstallationUnit* dnsInstallationUnit =
      dynamic_cast<DNSInstallationUnit*>((*(installationUnitContainer.find(DNS_INSTALL))).second);

   ASSERT(dnsInstallationUnit);

   return *dnsInstallationUnit;
}

WINSInstallationUnit&
InstallationUnitProvider::GetWINSInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetWINSInstallationUnit);

   WINSInstallationUnit* winsInstallationUnit =
      dynamic_cast<WINSInstallationUnit*>((*(installationUnitContainer.find(WINS_INSTALL))).second);

   ASSERT(winsInstallationUnit);

   return *winsInstallationUnit;
}

RRASInstallationUnit&
InstallationUnitProvider::GetRRASInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetRRASInstallationUnit);

   RRASInstallationUnit* rrasInstallationUnit =
      dynamic_cast<RRASInstallationUnit*>((*(installationUnitContainer.find(RRAS_INSTALL))).second);

   ASSERT(rrasInstallationUnit);

   return *rrasInstallationUnit;
}

NetworkServerInstallationUnit&
InstallationUnitProvider::GetNetworkServerInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetNetworkServerInstallationUnit);

   NetworkServerInstallationUnit* networkServerInstallationUnit =
      dynamic_cast<NetworkServerInstallationUnit*>(
         (*(installationUnitContainer.find(NETWORKSERVER_INSTALL))).second);

   ASSERT(networkServerInstallationUnit);

   return *networkServerInstallationUnit;
}

ApplicationInstallationUnit&
InstallationUnitProvider::GetApplicationInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetApplicationInstallationUnit);

   ApplicationInstallationUnit* applicationInstallationUnit =
      dynamic_cast<ApplicationInstallationUnit*>(
         (*(installationUnitContainer.find(APPLICATIONSERVER_INSTALL))).second);

   ASSERT(applicationInstallationUnit);

   return *applicationInstallationUnit;
}

FileInstallationUnit&
InstallationUnitProvider::GetFileInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetFileInstallationUnit);

   FileInstallationUnit* fileInstallationUnit =
      dynamic_cast<FileInstallationUnit*>(
         (*(installationUnitContainer.find(FILESERVER_INSTALL))).second);

   ASSERT(fileInstallationUnit);

   return *fileInstallationUnit;
}

PrintInstallationUnit&
InstallationUnitProvider::GetPrintInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetPrintInstallationUnit);

   PrintInstallationUnit* printInstallationUnit =
      dynamic_cast<PrintInstallationUnit*>(
         (*(installationUnitContainer.find(PRINTSERVER_INSTALL))).second);

   ASSERT(printInstallationUnit);

   return *printInstallationUnit;
}

SharePointInstallationUnit&
InstallationUnitProvider::GetSharePointInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetSharePointInstallationUnit);

   SharePointInstallationUnit* sharePointInstallationUnit =
      dynamic_cast<SharePointInstallationUnit*>(
         (*(installationUnitContainer.find(SHAREPOINT_INSTALL))).second);

   ASSERT(sharePointInstallationUnit);

   return *sharePointInstallationUnit;
}

MediaInstallationUnit&
InstallationUnitProvider::GetMediaInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetMediaInstallationUnit);

   MediaInstallationUnit* mediaInstallationUnit = 
      dynamic_cast<MediaInstallationUnit*>(
         (*(installationUnitContainer.find(MEDIASERVER_INSTALL))).second);

   ASSERT(mediaInstallationUnit);

   return *mediaInstallationUnit;
}

WebInstallationUnit&
InstallationUnitProvider::GetWebInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetWebInstallationUnit);

   WebInstallationUnit* webInstallationUnit =
      dynamic_cast<WebInstallationUnit*>(
         (*(installationUnitContainer.find(WEBSERVER_INSTALL))).second);

   ASSERT(webInstallationUnit);

   return *webInstallationUnit;
}

ExpressInstallationUnit&
InstallationUnitProvider::GetExpressInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetExpressInstallationUnit);

   ExpressInstallationUnit* expressInstallationUnit =
      dynamic_cast<ExpressInstallationUnit*>(
         (*(installationUnitContainer.find(EXPRESS_INSTALL))).second);

   ASSERT(expressInstallationUnit);

   return *expressInstallationUnit;
}


ADInstallationUnit&
InstallationUnitProvider::GetADInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetADInstallationUnit);

   ADInstallationUnit* adInstallationUnit = 
      dynamic_cast<ADInstallationUnit*>(
         (*(installationUnitContainer.find(DC_INSTALL))).second);

   ASSERT(adInstallationUnit);

   return *adInstallationUnit;
}


ClusterInstallationUnit&
InstallationUnitProvider::GetClusterInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetClusterInstallationUnit);

   ClusterInstallationUnit* clusterInstallationUnit =
      dynamic_cast<ClusterInstallationUnit*>(
         (*(installationUnitContainer.find(CLUSTERSERVER_INSTALL))).second);

   ASSERT(clusterInstallationUnit);

   return *clusterInstallationUnit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\installservice.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of IConfigureYourServer::InstallService
//
// 31 Mar 2000 sburns
// 05 Feb 2001 jeffjon  Copied and modified for use with a Win32 version of CYS



#include "pch.h"
#include "resource.h"


HRESULT
CreateTempFile(const String& name, const String& contents)
{
   LOG_FUNCTION2(createTempFile, name);
   ASSERT(!name.empty());
   ASSERT(!contents.empty());

   HRESULT hr = S_OK;
   HANDLE h = INVALID_HANDLE_VALUE;

   do
   {
      hr =
         FS::CreateFile(
            name,
            h,
            GENERIC_WRITE,
            0, 
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL);
      BREAK_ON_FAILED_HRESULT(hr);

      AnsiString ansi;
      contents.convert(ansi);
      ASSERT(!ansi.empty());

      // write to file with end of file character.

      hr = FS::Write(h, ansi + "\032");
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   Win::CloseHandle(h);

   return hr;
}



bool
InstallServiceWithOcManager(
   const String& infText,
   const String& unattendText)
{
   LOG_FUNCTION(SpawnInstaller);
   ASSERT(!unattendText.empty());

   // infText may be empty

   bool result = false;
   HRESULT hr = S_OK;

   String sysFolder    = Win::GetSystemDirectory();
   String infPath      = sysFolder + L"\\cysinf.000"; 
   String unattendPath = sysFolder + L"\\cysunat.000";

   // create the inf and unattend files for the oc manager

   do
   {
      if (infText.empty())
      {
         // sysoc.inf is in %windir%\inf

         infPath = Win::GetSystemWindowsDirectory() + L"\\inf\\sysoc.inf";
      }
      else
      {
         hr = CreateTempFile(infPath, infText);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      hr = CreateTempFile(unattendPath, unattendText);
      BREAK_ON_FAILED_HRESULT(hr);

      String commandLine =
         String::format(
            IDS_SYSOC_COMMAND_LINE,
            sysFolder.c_str(),
            infPath.c_str(),
            unattendPath.c_str());

      DWORD exitCode = 0;
      hr = ::CreateAndWaitForProcess(commandLine, exitCode);
      BREAK_ON_FAILED_HRESULT(hr);

      // @@ might have to wait for the service to become installed as per
      // service manager

      if (exitCode == ERROR_SUCCESS)
      {
         result = true;
         break;
      }
   }
   while (0);

   LOG_BOOL(result);
   LOG_HRESULT(hr);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\mediainstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      MediaInstallationUnit.h
//
// Synopsis:  Declares a MediaInstallationUnit
//            This object has the knowledge for installing the
//            Streaming media service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_MEDIAINSTALLATIONUNIT_H
#define __CYS_MEDIAINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class MediaInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      MediaInstallationUnit();

      // Destructor

      virtual
      ~MediaInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      virtual
      String
      GetServiceDescription();
};

#endif // __CYS_MEDIAINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkadapterconfig.cpp ===
// File:      NetworkAdapterConfig.h
//
// Synopsis:  Defines a NetworkAdapterConfig
//            This object has the knowledge for installing 
//            using WMI to retrieve network adapter information
//
// History:   02/16/2001  JeffJon Created


#include "pch.h"

#include "NetworkAdapterConfig.h"
#include "NetworkInterface.h"

      
#define  CYS_WBEM_NETWORK_ADAPTER_CLASS   L"Win32_NetworkAdapterConfiguration"
#define  CYS_WBEM_ADAPTER_QUERY  \
   L"Select * from Win32_NetworkAdapterConfiguration where IPEnabled=TRUE"

NetworkAdapterConfig::NetworkAdapterConfig() :
   initialized(false),
   nicCount(0)
{
   LOG_CTOR(NetworkAdapterConfig);
}


NetworkAdapterConfig::~NetworkAdapterConfig()
{
   LOG_DTOR(NetworkAdapterConfig);

   // Free all the NIC info from the vector and reset the count

   networkInterfaceVector.erase(
      networkInterfaceVector.begin(),
      networkInterfaceVector.end());

   nicCount = 0;
}


HRESULT
NetworkAdapterConfig::Initialize()
{
   LOG_FUNCTION(NetworkAdapterConfig::Initialize);

   HRESULT hr = S_OK;

   do
   {
      // Execute the query to retrieve the Adapter information

      SmartInterface<IEnumWbemClassObject> adapterEnum;
      
      hr = ExecQuery(
              CYS_WBEM_NETWORK_ADAPTER_CLASS,
              adapterEnum);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to run query: hr = %1!x!",
                hr));
         break;
      }

      // Loop through all the adapters retrieving data

      ULONG itemsReturned = 0;

      do
      {
         itemsReturned = 0;

         // Get the next adapter from the query

         IWbemClassObject* tempAdapterObject = 0;
         SmartInterface<IWbemClassObject> adapterObject;

         hr = adapterEnum->Next(
                 WBEM_INFINITE,
                 1,
                 &tempAdapterObject,
                 &itemsReturned);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to get the next adapter: hr = %1!x!",
                   hr));
            break;
         }

         adapterObject.Acquire(tempAdapterObject);

         if (hr == S_FALSE ||
             itemsReturned == 0)
         {
            // No more items

            break;
         }

         // Create a new network interface based on the query results

         NetworkInterface* newInterface = new NetworkInterface();
         if (!newInterface)
         {
            LOG(
             L"Failed to create new interface object from WMI adapter object");
            
            continue;
         }

         hr  = newInterface->Initialize(adapterObject);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to initialize network interface: hr = 0x%1!x!",
                   hr));

            delete newInterface;

            continue;
         }

         // Add the new interface to the embedded container
         
         AddInterface(newInterface);

      } while (itemsReturned > 0);

   } while (false);

   if (SUCCEEDED(hr))
   {
      initialized = true;
   }

   LOG_HRESULT(hr);

   return hr;
}


void
NetworkAdapterConfig::AddInterface(NetworkInterface* newInterface)
{
   LOG_FUNCTION(NetworkAdapterConfig::AddInterface);

   do
   {
      // verify parameters

      if (!newInterface)
      {
         ASSERT(newInterface);
         break;
      }

      // Add the new NIC to the vector and increment the count

      networkInterfaceVector.push_back(newInterface);
      ++nicCount;

   } while (false);
}


unsigned int
NetworkAdapterConfig::GetNICCount() const
{
   LOG_FUNCTION(NetworkAdapterConfig::GetNICCount);

   ASSERT(IsInitialized());

   LOG(String::format(
          L"nicCount = %1!d!",
          nicCount));

   return nicCount;
}

NetworkInterface
NetworkAdapterConfig::GetNIC(unsigned int nicIndex)
{
   LOG_FUNCTION2(
      NetworkAdapterConfig::GetNIC,
      String::format(
         L"%1!d!",
         nicIndex));

   ASSERT(IsInitialized());
   ASSERT(nicIndex < GetNICCount());

   NetworkInterface* nic = networkInterfaceVector[nicIndex];

   ASSERT(nic);

   return *nic;
}

HRESULT
NetworkAdapterConfig::ExecQuery(
   const String& classType,
   SmartInterface<IEnumWbemClassObject>& enumClassObject)
{
   LOG_FUNCTION2(
      NetworkAdapterConfig::ExecQuery,
      classType);

   HRESULT hr = S_OK;

   do
   {
      // Run the query and get the enumerator

      SmartInterface<IWbemServices> spWbemServices;
      hr = GetWbemServices(spWbemServices);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get WMI COM object: hr = 0x%1!x!",
                hr));
         break;
      }

      IEnumWbemClassObject* tempEnumClassObject = 0;
      hr = spWbemServices->ExecQuery(
              AutoBstr(L"WQL"),
              AutoBstr(CYS_WBEM_ADAPTER_QUERY),
              WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
              0,
              &tempEnumClassObject);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to run query: hr = %1!x!",
                hr));

         break;
      }

      enumClassObject.Acquire(tempEnumClassObject);

   } while(false);

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
NetworkAdapterConfig::GetWbemServices(SmartInterface<IWbemServices>& spWbemServices)
{
   LOG_FUNCTION(NetworkAdapterConfig::GetWbemServices);

   HRESULT hr = S_OK;

   if (!wbemService)
   {
      do
      {
         // First we have to initialize the security (this may be
         // a bug in WMI but we will do it anyway just to be safe)

         CoInitializeSecurity(
            0,
            -1,
            0,
            0,
            RPC_C_AUTHN_LEVEL_DEFAULT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            0,
            0,
            0);

         SmartInterface<IWbemLocator> wbemLocator;
         
         hr = wbemLocator.AcquireViaCreateInstance(
                 CLSID_WbemLocator,
                 0,
                 CLSCTX_INPROC_SERVER);

         if (FAILED(hr))
         {
            ASSERT(SUCCEEDED(hr));
            LOG(String::format(
                   L"Failed to CoCreate the Wbem Locator: hr = %1!x!",
                   hr));

            break;
         }

         IWbemServices* tempWbemServices = 0;

         hr = wbemLocator->ConnectServer(
                 L"root\\CIMV2",
                 0,                 // user name
                 0,                 // password
                 0,                 // locale
                 0,                 // security flags, must be zero
                 0,                 // authority
                 0,                 // wbem context
                 &tempWbemServices);
         
         if (FAILED(hr))
         {
            ASSERT(SUCCEEDED(hr));
            LOG(String::format(
                L"Failed to connect to server to get wbemService: hr = %1!x!",
                hr));
            break;
         }

         wbemService.Acquire(tempWbemServices);

         ASSERT(wbemService);
      } while(false);
   }

   spWbemServices = wbemService;

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\mediainstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      MediaInstallationUnit.cpp
//
// Synopsis:  Defines a MediaInstallationUnit
//            This object has the knowledge for installing the
//            Streaming media service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "MediaInstallationUnit.h"


// Finish page help 
static PCWSTR CYS_MEDIA_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_streaming_media_server.htm";

MediaInstallationUnit::MediaInstallationUnit() :
   InstallationUnit(
      IDS_MEDIA_SERVER_TYPE, 
      IDS_MEDIA_SERVER_DESCRIPTION, 
      CYS_MEDIA_FINISH_PAGE_HELP,
      MEDIASERVER_INSTALL)
{
   LOG_CTOR(MediaInstallationUnit);
}


MediaInstallationUnit::~MediaInstallationUnit()
{
   LOG_DTOR(MediaInstallationUnit);
}


InstallationReturnType
MediaInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(MediaInstallationUnit::InstallService);

   // Log heading
   CYS_APPEND_LOG(String::load(IDS_LOG_MEDIA_HEADING));

   String unattendFileText;
   String infFileText;

   unattendFileText += L"[Components]\n";
   unattendFileText += L"WMS=ON\n";
   unattendFileText += L"WMS_admin_mmc=ON\n";
   unattendFileText += L"WMS_Admin_asp=ON\n";
   unattendFileText += L"WMS_SERVER=ON\n";

   InstallationReturnType result = INSTALL_SUCCESS;

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      LOG(L"WMS was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_INSTALL_WMS_SUCCESS));
   }
   else
   {
      LOG(L"WMS was failed to install");
      CYS_APPEND_LOG(String::load(IDS_LOG_INSTALL_WMS_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
MediaInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(MediaInstallationUnit::IsServiceInstalled);

   bool result = false;

   // If we can find wmsserver.dll, we assume netshow is installed

   String wmsServerPath = Win::GetSystemDirectory() + L"\\Windows Media\\Server\\WMSServer.dll";

   LOG(String::format(
          L"Path to WMS server: %1",
          wmsServerPath.c_str()));

   if (!wmsServerPath.empty())
   {
      if (FS::FileExists(wmsServerPath))
      {
         result = true;
      }
      else
      {
         LOG(L"Path does not exist");
      }
   }
   else
   {
      LOG(L"Failed to append path");
   }

   LOG_BOOL(result);
   return result;
}

bool
MediaInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(MediaInstallationUnit::GetFinishText);

   message = String::load(IDS_MEDIA_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

String
MediaInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(MediaInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);
   if (IsServiceInstalled())
   {
      resourceID = IDS_MEDIA_SERVER_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\netbiospage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetbiosPage.h
//
// Synopsis:  Declares the new netbios name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_NEBIOSPAGE_H
#define __CYS_NEBIOSPAGE_H

#include "CYSWizardPage.h"

class NetbiosDomainPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      NetbiosDomainPage();

      // Destructor

      virtual 
      ~NetbiosDomainPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      bool
      NetbiosDomainPage::OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      NetbiosDomainPage(const NetbiosDomainPage&);
      const NetbiosDomainPage& operator=(const NetbiosDomainPage&);

};




#endif // __CYS_NEBIOSPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\isdhcpconfigured.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Implementation of IConfigureYourServer::IsDhcpConfigured
//
// 20 Apr 2000 sburns
// 06 Feb 2001 jeffjon Copied from CYS HTA sources for use with CYS win32 sources



#include "pch.h"

// make sure the DLLs for all these APIs are present with base install.
// if not, then need to wrap usage in load-lib calls
// 
// DhcpLeaseIpAddress        DHCPCSVC    ok
// DhcpReleaseIpAddressLease DHCPCSVC    ok
// DhcpDsInitDS              DSAUTH      ok
// DhcpAddServerDS           DSAUTH      ok
// DhcpDsCleanupDS           DSAUTH      ok
// DhcpGetAllOptions         DHCPSAPI    ok
// DhcpRpcFreeMemory         DHCPSAPI    ok
// DhcpEnumSubnets           DHCPSAPI    ok
// DhcpEnumMscopes           DHCPSAPI    ok



String
GetIpAddress()
{
   LOG_FUNCTION(GetIpAddress);

   String result;

   HRESULT hr = S_OK;
   BYTE* buf = 0;
   do
   {
      // first, determine the size of the table

      ULONG tableSize = 0;
      DWORD err = ::GetIpAddrTable(0, &tableSize, FALSE);
      if (err != ERROR_INSUFFICIENT_BUFFER)
      {
         LOG(L"GetIpAddrTable for table size failed");
         LOG_HRESULT(Win32ToHresult(err));
         break;
      }

      // allocate space for the table.

      buf = new BYTE[tableSize + 1];
      memset(buf, 0, tableSize + 1);
      PMIB_IPADDRTABLE table = reinterpret_cast<PMIB_IPADDRTABLE>(buf);

      LOG(L"Calling GetIpAddrTable");

      hr =
         Win32ToHresult(
            ::GetIpAddrTable(
               table,
               &tableSize,
               FALSE));
      BREAK_ON_FAILED_HRESULT2(hr, L"GetIpAddrTable failed");

      LOG(String::format(L"dwNumEntries: %1!d!", table->dwNumEntries));

      for (int i = 0; i < table->dwNumEntries; ++i)
      {
         DWORD addr = table->table[i].dwAddr;
         LOG(String::format(L"entry %1!d!", i));
         LOG(String::format(
            L"dwAddr %1!X! (%2!d!.%3!d!.%4!d!.%5!d!)",
            addr,
				((BYTE*)&addr)[0],
				((BYTE*)&addr)[1],
				((BYTE*)&addr)[2],
				((BYTE*)&addr)[3]));

         // skip loopback, etc.

         if (
               INADDR_ANY        == addr
            || INADDR_BROADCAST  == addr
            || INADDR_LOOPBACK   == addr
            || 0x0100007f        == addr )
         {
            LOG(L"is loopback/broadcast -- skipping");

            continue;
         }

         // Exclude MCAST addresses (class D).

         if (
               IN_CLASSA(htonl(addr))
            || IN_CLASSB(htonl(addr))
            || IN_CLASSC(htonl(addr)) )
         {
            LOG(L"is class A/B/C");

            result = 
               String::format(
                  L"%1!d!.%2!d!.%3!d!.%4!d!",
				      ((BYTE*)&addr)[0],
				      ((BYTE*)&addr)[1],
				      ((BYTE*)&addr)[2],
				      ((BYTE*)&addr)[3]);

            break;
         }

         LOG(L"not class A/B/C -- skipping");
      }
   }
   while (0);

   delete[] buf;

   LOG(result);
   LOG_HRESULT(hr);

   return result;
}



bool
AreDhcpOptionsPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpOptionsPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_ALL_OPTIONS options = 0;
   do
   {
      DWORD err =
         ::DhcpGetAllOptions(
            const_cast<wchar_t*>(ipAddress.c_str()),
            0,
            &options);

      if (err != ERROR_SUCCESS)
      {
         LOG(String::format(L"DhcpGetAllOptions failed with 0x%1!08X!", err));
         break;
      }

      if (options)
      {
         // options are set, so some dhcp configuration was done.

         result = true;
         break;
      }
   }
   while (0);

   if (options)
   {
      ::DhcpRpcFreeMemory(options);
   }

   LOG_BOOL(result);

   return result;
}



bool
AreDhcpSubnetsPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpSubnetsPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_IP_ARRAY subnets = 0;
   do
   {
      DHCP_RESUME_HANDLE resume    = 0;
      DWORD              unused1   = 0;
      DWORD              unused2   = 0;
      DWORD err =
         ::DhcpEnumSubnets(
            ipAddress.c_str(),
            &resume,
            ~(static_cast<DWORD>(0)),
            &subnets,
            &unused1,
            &unused2);

      if (err == ERROR_NO_MORE_ITEMS)
      {
         // no subnets.

         break;
      }

      if (err != NO_ERROR and err != ERROR_MORE_DATA)
      {
         LOG(String::format(L"DhcpEnumSubnets failed with 0x%1!08X!", err));
         break;
      }

      ASSERT(subnets);

      result = true;

      // the resume handle is simply discarded...
   }
   while (0);

   if (subnets)
   {
      ::DhcpRpcFreeMemory(subnets);
   }

   LOG_BOOL(result);

   return result;
}



bool
AreDhcpMscopesPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpMscopesPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_MSCOPE_TABLE mscopes = 0;
   do
   {
      DHCP_RESUME_HANDLE resume    = 0;
      DWORD              unused1   = 0;
      DWORD              unused2   = 0;
      DWORD err =
         ::DhcpEnumMScopes(
            ipAddress.c_str(),
            &resume,
            ~(static_cast<DWORD>(0)),
            &mscopes,
            &unused1,
            &unused2);

      if (err == ERROR_NO_MORE_ITEMS)
      {
         // no mscopes.

         break;
      }

      if (err != NO_ERROR and err != ERROR_MORE_DATA)
      {
         LOG(String::format(L"DhcpEnumMscopes failed with 0x%1!08X!", err));
         break;
      }

      ASSERT(mscopes);

      result = true;

      // the resume handle is simply discarded...
   }
   while (0);

   if (mscopes)
   {
      ::DhcpRpcFreeMemory(mscopes);
   }

   LOG_BOOL(result);

   return result;
}


bool 
IsDhcpConfigured()
{
   LOG_FUNCTION(IsDhcpConfigured);

   bool result = false;
   do
   {

      // if any of the following return any results, then we consider dhcp to
      // have been configured.
      //    
      // DhcpGetAllOptions retrieves the options configured.
      // DhcpEnumSubnets retrieves the list of subnets configured.
      // DhcpEnumMscopes retrieves the list of mscopes configured.

      String ipAddress = GetIpAddress();
      if (ipAddress.empty())
      {
         LOG(L"no ip address");
         break;
      }

      if (AreDhcpOptionsPresent(ipAddress))
      {
         LOG(L"dchp options found");

         result = true;
         break;
      }

      // no options found.  go on to next test

      if (AreDhcpSubnetsPresent(ipAddress))
      {
         LOG(L"dchp subnets found");

         result = true;
         break;
      }

      // no subnets found.  go on.

      if (AreDhcpMscopesPresent(ipAddress))
      {
         LOG(L"dchp mscopes found");

         result = true;
         break;
      }
   }
   while (0);

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkadapterconfig.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkAdapterConfig.h
//
// Synopsis:  Declares a NetworkAdapterConfig
//            This object has the knowledge for installing 
//            using WMI to retrieve network adapter information
//
// History:   02/16/2001  JeffJon Created

#ifndef __CYS_NETWORKADAPTERCONFIG_H
#define __CYS_NETWORKADAPTERCONFIG_H

#include "NetworkInterface.h"

class NetworkAdapterConfig
{
   public:
      
      // Constructor

      NetworkAdapterConfig();

      // Destructor

      ~NetworkAdapterConfig();

      // Initializer
      
      HRESULT
      Initialize();

      // Pulic methods

      unsigned int
      GetNICCount() const;

      NetworkInterface
      GetNIC(unsigned int nicIndex);

      bool
      IsInitialized() const { return initialized; }

   protected:

      HRESULT 
      GetWbemServices(SmartInterface<IWbemServices>& spWbemService);

      HRESULT
      ExecQuery(
         const String& classType,
         SmartInterface<IEnumWbemClassObject>& enumClassObject);

      void
      AddInterface(NetworkInterface* newInterface);

   private:

      bool  initialized;
      unsigned int nicCount;
      std::vector<NetworkInterface*> networkInterfaceVector;

      SmartInterface<IWbemServices> wbemService;
};


#endif // __CYS_NETWORKADAPTERCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\netbiospage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetbiosPage.cpp
//
// Synopsis:  Defines the new netbios name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "NetbiosPage.h"
#include "state.h"

static PCWSTR NETBIOS_PAGE_HELP = L"cys.chm::/cys_configuring_first_server.htm";

NetbiosDomainPage::NetbiosDomainPage()
   :
   CYSWizardPage(
      IDD_NETBIOS_NAME, 
      IDS_NETBIOS_NAME_TITLE, 
      IDS_NETBIOS_NAME_SUBTITLE,
      NETBIOS_PAGE_HELP)
{
   LOG_CTOR(NetbiosDomainPage);
}

   

NetbiosDomainPage::~NetbiosDomainPage()
{
   LOG_DTOR(NetbiosDomainPage);
}


void
NetbiosDomainPage::OnInit()
{
   LOG_FUNCTION(NetbiosDomainPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_NETBIOS),
      MAX_NETBIOS_NAME_LENGTH);
}

static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_NETBIOS).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}


HRESULT
MyDsRoleDnsNameToFlatName(
   const String&  domainDNSName,
   String&        result,
   bool&          nameWasTweaked)
{
   LOG_FUNCTION(MyDsRoleDnsNameToFlatName);
   ASSERT(!domainDNSName.empty());

   nameWasTweaked = false;
   result.erase();

   LOG(L"Calling DsRoleDnsNameToFlatName");
   LOG(               L"lpServer  : (null)");
   LOG(String::format(L"lpDnsName : %1", domainDNSName.c_str()));

   PWSTR flatName = 0;
   ULONG flags = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsRoleDnsNameToFlatName(
            0, // this server
            domainDNSName.c_str(),
            &flatName,
            &flags));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr) && flatName)
   {
      LOG(String::format(L"lpFlatName   : %1", flatName));
      LOG(String::format(L"lpStatusFlag : %1!X!", flags));

      result = flatName;
      if (result.length() > DNLEN)
      {
         result.resize(DNLEN);
      }
      ::DsRoleFreeMemory(flatName);

      // the name was tweaked if it is not the default.  338443

      nameWasTweaked = !(flags & DSROLE_FLATNAME_DEFAULT);
   }

   return hr;
}



// return true if the name generated has already been validated, false
// if not.

bool
GenerateDefaultNetbiosName(HWND parent)
{
   LOG_FUNCTION(GenerateDefaultNetbiosName);
   ASSERT(Win::IsWindow(parent));

   Win::CursorSetting cursor(IDC_WAIT);

   bool result = false;

   String dnsDomainName = 
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainDNSName();

   bool nameWasTweaked = false;
   String generatedName;
   HRESULT hr = 
      MyDsRoleDnsNameToFlatName(
         dnsDomainName,
         generatedName,
         nameWasTweaked);
   if (FAILED(hr))
   {
      // if the api call failed, the name could not have been validated.

      result = false;

      // fall back to just the first 15 characters of the first label

      generatedName =
         dnsDomainName.substr(0, min(DNLEN, dnsDomainName.find(L'.')));

      LOG(String::format(L"falling back to %1", generatedName.c_str()));
   }
   else
   {
      // the api validated the name for us.

      result = true;
   }

   generatedName.to_upper();

   if (generatedName.is_numeric())
   {
      // the generated name is all-numeric.  This is not allowed.  So we
      // toss it out.   368777 bis

      generatedName.erase();
      nameWasTweaked = false;
   }

   Win::SetDlgItemText(
      parent,
      IDC_NETBIOS,
      generatedName);

   // inform the user that the default NetBIOS name was adjusted due
   // to name collision on the network

   if (nameWasTweaked)
   {
      popup.Info(
         parent,
         String::format(
            IDS_GENERATED_NAME_WAS_TWEAKED,
            generatedName.c_str()));
   }

   return result;
}


bool
NetbiosDomainPage::OnSetActive()
{
   LOG_FUNCTION(NetbiosDomainPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   // do this here instead of in init to regenerate a default name if the
   // user has not annointed one already.

   if (InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainNetbiosName().empty())
   {
      GenerateDefaultNetbiosName(hwnd);
   }
      
   enable(hwnd);

   return true;
}

bool
NetbiosDomainPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NetbiosDomainPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_NETBIOS:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}


bool
ValidateDomainNetbiosName(HWND dialog, int editResID)
{
   LOG_FUNCTION(ValidateDomainNetbiosName);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   Win::CursorSetting cursor(IDC_WAIT);

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);
   if (name.empty())
   {
      return false;
   }

   if (name.find(L".") != String::npos)
   {
      popup.Gripe(
         dialog,
         editResID,
         IDS_NO_DOTS_IN_NETBIOS_NAME);
      return false;
   }

   // Check that the name is not a number.  368777
   if (name.is_numeric())
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(IDS_NUMERIC_NETBIOS_NAME, name.c_str()));
      return false;
   }

   // we pretend that the candidate name is a hostname, and attempt to
   // generate a netbios name from it.  If that can't be done, then the
   // candidate name can't be a legal netbios name.

   HRESULT hr = S_OK;
   String s = Dns::HostnameToNetbiosName(name, &hr);
   if (FAILED(hr))
   {
      popup.Gripe(
         dialog,
         editResID,
         hr,
         String::format(IDS_BAD_NETBIOS_NAME, name.c_str()));
      return false;
   }
   if (s.length() < name.length())
   {
      // the name was truncated.
      popup.Gripe(
         dialog,
         editResID,
         String::format(
            IDS_NETBIOS_NAME_TOO_LONG,
            name.c_str(),
            MAX_NETBIOS_NAME_LENGTH));
      return false;
   }
   if (ValidateNetbiosDomainName(s) != VALID_NAME)
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(
            IDS_BAD_NETBIOS_CHARACTERS,
            s.c_str()));
      return false;
   }

   hr = MyNetValidateName(name, ::NetSetupNonExistentDomain);

   if (hr == Win32ToHresult(ERROR_DUP_NAME))
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(IDS_FLATNAME_IN_USE, name.c_str()));
      return false;
   }

   if (hr == Win32ToHresult(ERROR_NETWORK_UNREACHABLE))
   {
      // 25968

      if (
         popup.MessageBox(
            dialog,
            String::format(
               IDS_NET_NOT_REACHABLE,
               name.c_str()),
            MB_YESNO | MB_ICONWARNING) != IDYES)
      {
         HWND edit = Win::GetDlgItem(dialog, editResID);
         Win::SendMessage(edit, EM_SETSEL, 0, -1);
         Win::SetFocus(edit);
         
         return false;
      }
   }

   return true;
}



int
NetbiosDomainPage::Validate()
{
   LOG_FUNCTION(NetbiosDomainPage::Validate);

   int nextPage = -1;

   if (!ValidateDomainNetbiosName(hwnd, IDC_NETBIOS))
   {
      nextPage = -1;
   }
   else
   {
      String netbiosName = Win::GetTrimmedDlgItemText(hwnd, IDC_NETBIOS);
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetNewDomainNetbiosName(netbiosName);
      nextPage = IDD_RESTORE_PASSWORD_PAGE;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkinterface.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkInterface.h
//
// Synopsis:  Declares a NetworkInterface
//            This object has the knowledge of an
//            IP enabled network connection including 
//            IP address, DHCP information, etc.
//
// History:   03/01/2001  JeffJon Created

#ifndef __CYS_NETWORKINTERFACE_H
#define __CYS_NETWORKINTERFACE_H



class NetworkInterface
{
   public:

      // Constructor

      NetworkInterface();

      // Desctructor

      ~NetworkInterface();

      // Copy constructor and assignment operator

      NetworkInterface(const NetworkInterface& nic);
      NetworkInterface& operator=(const NetworkInterface& rhs);

      // Initializer

      HRESULT
      Initialize(SmartInterface<IWbemClassObject>& adapterObject);


      // Pulic accessor methods

      DWORD
      GetIPAddress(DWORD addressIndex) const;

      bool
      IsDHCPEnabled() const { return dhcpEnabled; }

      bool
      RenewDHCPLease();

      String
      GetDescription() const;

      String
      GetStringIPAddress() const;

   private:

      HRESULT
      GetIPAddressFromWMI();

      HRESULT
      SetIPAddresses(const StringList& ipList);

      HRESULT
      GetDHCPEnabledFromWMI();

      bool     initialized;

      String   ipaddressString;
      DWORD    ipaddrCount;
      std::vector<DWORD> ipaddresses;

      bool     dhcpEnabled;

      SmartInterface<IWbemClassObject> wmiAdapterObject;
};

#endif // __CYS_NETWORKINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkinterface.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkInterface.h
//
// Synopsis:  Defines a NetworkInterface
//            This object has the knowledge of an
//            IP enabled network connection including 
//            IP address, DHCP information, etc.
//
// History:   03/01/2001  JeffJon Created

#include "pch.h"

#include "NetworkInterface.h"


#define  CYS_WMIPROP_IPADDRESS      L"IPAddress"
#define  CYS_WMIPROP_DHCPENABLED    L"DHCPEnabled"
#define  CYS_WMIPROP_DESCRIPTION    L"Description"


NetworkInterface::NetworkInterface()
   : initialized(false),
     ipaddrCount(0),
     dhcpEnabled(false)
{
   LOG_CTOR(NetworkInterface);

}


NetworkInterface::~NetworkInterface()
{
   LOG_DTOR(NetworkInterface);

   if (!ipaddresses.empty())
   {
      ipaddresses.clear();
   }

   ipaddrCount = 0;
}

NetworkInterface::NetworkInterface(const NetworkInterface &nic)
{
   LOG_CTOR2(NetworkInterface, L"Copy constructor");

   if (this == &nic)
   {
      return;
   }

   initialized = nic.initialized;
   ipaddrCount = nic.ipaddrCount;
   dhcpEnabled = nic.dhcpEnabled;
   wmiAdapterObject = nic.wmiAdapterObject;

   ipaddressString = nic.ipaddressString;

   // Make a copy of the ipaddress array

   ipaddresses = nic.ipaddresses;
}

NetworkInterface&
NetworkInterface::operator=(const NetworkInterface& rhs)
{
   LOG_FUNCTION(NetworkInterface::operator=);

   if (this == &rhs)
   {
      return *this;
   }

   initialized = rhs.initialized;
   ipaddrCount = rhs.ipaddrCount;
   dhcpEnabled = rhs.dhcpEnabled;
   wmiAdapterObject = rhs.wmiAdapterObject;

   ipaddressString = rhs.ipaddressString;

   // Make a copy of the ipaddress array

   ipaddresses = rhs.ipaddresses;

   return *this;
}

HRESULT
NetworkInterface::Initialize(SmartInterface<IWbemClassObject>& adapterObject)
{
   LOG_FUNCTION(NetworkInterface::Initialize);

   HRESULT hr = S_OK;

   if (initialized)
   {
      ASSERT(!initialized);
      hr = E_UNEXPECTED;
   }
   else
   {
      // Store the adapter interface pointer for later use

      wmiAdapterObject = adapterObject;

      // Get the needed info from the WMI object

      hr = GetIPAddressFromWMI();
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to retrieve IP Addresses: hr = 0x%1!x!",
                hr));
      }


      hr = GetDHCPEnabledFromWMI();
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to retrieve dhcpEnabled state: hr = 0x%1!x!",
                hr));
      }
   } 

   // If we succeeded in retrieving the data we need,
   // mark the object initialized

   if (SUCCEEDED(hr))
   {
      initialized = true;
   }

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
NetworkInterface::GetIPAddressFromWMI()
{
   LOG_FUNCTION(NetworkInterface::GetIPAddressFromWMI);

   HRESULT hr = S_OK;

   do
   {
      _variant_t var;

      hr = wmiAdapterObject->Get(
              CYS_WMIPROP_IPADDRESS,
              0,                       // flags, reserved, must be zero
              &var,
              0,                       // CIMTYPE
              0);                      // origin of the property

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Unable to retrieve the IPAddress property: hr = 0x%1!x!",
                hr));

         break;
      }

      // The IP addresses come as a SAFEARRAY of BSTRs.  Convert that to a
      // StringList

      StringList iplist;

      hr = VariantArrayToStringList(&var, iplist);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Unable to convert variant to string list: hr = 0x%1!x!",
                hr));
         break;
      }

      hr = SetIPAddresses(iplist);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to convert IP addresses from string: hr = 0x%1!x!",
                hr));
         break;
      }
   } while (false);

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
NetworkInterface::SetIPAddresses(const StringList& ipList)
{
   LOG_FUNCTION(NetworkInterface::SetIPAddresses);

   HRESULT hr = S_OK;

   // if the list already contains some entries, delete them and start over

   ipaddressString.erase();

   if (!ipaddresses.empty())
   {
      ipaddresses.erase(ipaddresses.begin());
   }

   // Loop through the string list converting all string IP addresses
   // to DWORD IP addresses and add them to the ipaddresses array

   int addressesAdded = 0;

   for (
      StringList::iterator itr = ipList.begin();
      itr != ipList.end();
      ++itr)
   {
      String entry = *itr;

      // Add the ipaddress to the semicolon delimited string

      if (addressesAdded > 0)
      {
         ipaddressString += L";";
      }
      ipaddressString += entry;

      // Convert the string to ansi so that we can use inet_addr 
      // to convert to an IP address DWORD

      AnsiString ansi;
      
      String::ConvertResult convertResult = entry.convert(ansi);

      if (String::CONVERT_SUCCESSFUL == convertResult)
      {
         // Convert and add the new address to the array

         DWORD newAddress = inet_addr(ansi.c_str());
         ASSERT(newAddress != INADDR_NONE);

         ipaddresses.push_back(newAddress);

         ++addressesAdded;
      }
      else
      {
         LOG(String::format(
                L"Failed to convert address: %1: hr = 0x%2!x!",
                entry.c_str(),
                hr));
         continue;
      }

   }

   ipaddrCount = addressesAdded;

   ASSERT(ipaddrCount <= ipList.size());

   LOG_HRESULT(hr);

   return hr;
}

DWORD
NetworkInterface::GetIPAddress(DWORD addressIndex) const
{
   LOG_FUNCTION2(
      NetworkInterface::GetIPAddress,
      String::format(
         L"%1!d!",
         addressIndex));

   ASSERT(initialized);
   ASSERT(addressIndex <= ipaddrCount);

   return ipaddresses[addressIndex];
}

String
NetworkInterface::GetStringIPAddress() const
{
   LOG_FUNCTION(NetworkInterface::GetStringIPAddress);

   return ipaddressString;
}

HRESULT
NetworkInterface::GetDHCPEnabledFromWMI()
{
   LOG_FUNCTION(NetworkInterface::GetDHCPEnabledFromWMI);

   HRESULT hr = S_OK;

   do
   {
      _variant_t var;

      hr = wmiAdapterObject->Get(
              CYS_WMIPROP_DHCPENABLED,
              0,                       // flags, reserved, must be zero
              &var,
              0,                       // CIMTYPE
              0);                      // origin of the property

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Unable to retrieve the IPAddress property: hr = 0x%1!x!",
                hr));

         break;
      }

      ASSERT(V_VT(&var) == (VT_BOOL));

      dhcpEnabled = (V_BOOL(&var) != 0);

   } while(false);

   LOG_HRESULT(hr);

   return hr;
}

bool
NetworkInterface::RenewDHCPLease() 
{
   LOG_FUNCTION(NetworkInterface::RenewDHCPLease);

   bool found = false;

   do
   {
      for(DWORD i = 0; i < ipaddrCount; ++i) 
      {
         found = (IsDHCPAvailableOnInterface(ipaddresses[i]) != 0);
         if (found)
         {
            LOG(String::format(
                   L"Found DHCP server on: %1!x!",
                   ipaddresses[i]));

            // Then we have to reload the IP addresses because they
            // may have been altered by renewing the lease
            // return value is ignored

            GetIPAddressFromWMI();

            break;
         }
      }
   } while(false);

   LOG(found ? L"true" : L"false");

   return found;
}

String
NetworkInterface::GetDescription() const
{
   LOG_FUNCTION(NetworkInterface::GetDescription);

   ASSERT(initialized);

   String description;

   do
   {
      _variant_t var;

      HRESULT hr = wmiAdapterObject->Get(
                      CYS_WMIPROP_DESCRIPTION,
                      0,                       // flags, reserved, must be zero
                      &var,
                      0,                       // CIMTYPE
                      0);                      // origin of the property

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Unable to retrieve the Description property: hr = 0x%1!x!",
                hr));

         break;
      }

      ASSERT(V_VT(&var) == (VT_BSTR));

      description = V_BSTR(&var);

   } while (false);

   LOG(description);

   return description;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkserverinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkServerInstallationUnit.h
//
// Synopsis:  Declares a NetworkServerInstallationUnit
//            This object has the knowledge for installing the
//            various network services including
//            RRAS, DNS, WINS, and DHCP
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_NETWORKSERVERINSTALLATIONUNIT_H
#define __CYS_NETWORKSERVERINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class NetworkServerInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      NetworkServerInstallationUnit();

      // Destructor

      virtual
      ~NetworkServerInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      String
      GetServiceDescription();

      virtual
      bool
      GetFinishText(String& message);

      // Data accessors

      void
      SetDHCPInstall(bool newInstallDHCP);

      bool
      GetDHCPInstall() const;

      void
      SetDNSInstall(bool newInstallDNS);

      bool
      GetDNSInstall() const;

      void
      SetWINSInstall(bool newInstallWINS);

      bool
      GetWINSInstall() const;

      void
      SetRRASInstall(bool newInstallRRAS);

      bool
      GetRRASInstall() const;

   private:
      
      bool     installDHCP;
      bool     installDNS;
      bool     installWINS;
      bool     installRRAS;
};

#endif // __CYS_NETWORKSERVERINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkserverpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkServerPage.h
//
// Synopsis:  Declares the Network Server Page for the CYS
//            wizard
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_NETWORKSERVERPAGE_H
#define __CYS_NETWORKSERVERPAGE_H

#include "CYSWizardPage.h"


class NetworkServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      NetworkServerPage();

      // Destructor

      virtual 
      ~NetworkServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // Message handlers
      
      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

      // CYSWizardPage overrides

      virtual
      int
      Validate();


      void
      SetWizardButtons();

   private:

      // not defined: no copying allowed
      NetworkServerPage(const NetworkServerPage&);
      const NetworkServerPage& operator=(const NetworkServerPage&);

};

#endif // __CYS_NETWORKSERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkserviceinstallationbase.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkServiceInstallationBase.h
//
// Synopsis:  Declares a NetworkServiceInstallationBase
//            Contains the common methods for the network 
//            service installations including
//            DNS, WINS, and DHCP
//
// History:   03/26/2001  JeffJon Created

#ifndef __CYS_NETWORKSERVICEINSTALLATIONBASE_H
#define __CYS_NETWORKSERVICEINSTALLATIONBASE_H

#include "InstallationUnit.h"

class NetworkServiceInstallationBase : public InstallationUnit
{
   public:
      
      // Constructor

      NetworkServiceInstallationBase(
         unsigned int serviceNameID,
         unsigned int serviceDescriptionID,
         unsigned int serviceDescriptionInstalledID,
         InstallationUnitType newInstallType);

      // Base class overrides

      virtual
      String
      GetServiceDescription();

   protected:

      void
      CreateInfFileText(
         String& infFileText, 
         unsigned int windowTitleResourceID);

      void
      CreateUnattendFileText(
         String& unattendFileText, 
         PCWSTR serviceName);
  
      unsigned int installedDescriptionID;
};

#endif // __CYS_NETWORKSERVICEINSTALLATIONBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\nicselectionpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NICSelectionPage.cpp
//
// Synopsis:  Defines the NIC selection Page for the CYS
//            Wizard.  This page lets the user choose
//            between the NIC that is on the public network
//
// History:   03/13/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "NICSelectionPage.h"
#include "state.h"


static PCWSTR NIC_SELECTION_PAGE_HELP = L"cys.chm::/sag_ADserverRoles.htm";

NICSelectionPage::NICSelectionPage()
   :
   CYSWizardPage(
      IDD_NIC_SELECTION_PAGE, 
      IDS_NIC_SELECTION_TITLE, 
      IDS_NIC_SELECTION_SUBTITLE, 
      NIC_SELECTION_PAGE_HELP)
{
   LOG_CTOR(NICSelectionPage);
}

   

NICSelectionPage::~NICSelectionPage()
{
   LOG_DTOR(NICSelectionPage);
}


void
NICSelectionPage::OnInit()
{
   LOG_FUNCTION(NICSelectionPage::OnInit);

   InitializeNICListView();

   FillNICListView();

}

void
NICSelectionPage::InitializeNICListView()
{
   LOG_FUNCTION(NICSelectionPage::InitializeNICListView);

   // Add the columns to the list view

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_NIC_LIST);
   
   // Get the width of the list view so we can set the column widths

   RECT rect;
   ::ZeroMemory(&rect, sizeof(RECT));

   HRESULT hr = Win::GetClientRect(
                   hwndBox,
                   rect);

   ASSERT(SUCCEEDED(hr));

   long width = rect.right - rect.left;


   LVCOLUMN column;
   ZeroMemory(&column, sizeof(LVCOLUMN));

   // Load the column names
   String networkCardColumn = String::load(IDS_NIC_COLUMN);
   String statusColumn = String::load(IDS_STATUS_COLUMN);
   String addressColumn = String::load(IDS_ADDRESS_COLUMN);

   column.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_ORDER;

   // Insert the NIC column using 40% of the width

   column.iOrder = 0;
   column.cx = static_cast<int>((float)width * 0.4);
   column.pszText = const_cast<wchar_t*>(networkCardColumn.c_str());

   Win::ListView_InsertColumn(
      hwndBox,
      0,
      column);

   // Insert the Status column using 30% of the width

   column.iOrder = 1;
   column.cx = static_cast<int>((float)width * 0.3);
   column.pszText = const_cast<wchar_t*>(statusColumn.c_str());

   Win::ListView_InsertColumn(
      hwndBox,
      1,
      column);

   // Insert the IP Address column using 30% of the width

   column.iOrder = 2;
   column.cx = static_cast<int>((float)width * 0.3);
   column.pszText = const_cast<wchar_t*>(addressColumn.c_str());

   Win::ListView_InsertColumn(
      hwndBox,
      2,
      column);

}

void
NICSelectionPage::FillNICListView()
{
   LOG_FUNCTION(NICSelectionPage::FillNICListView);

   // Add the NICs to the list view

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_NIC_LIST);

   State& state = State::GetInstance();

   for(
      unsigned int nicIndex = 0;
      nicIndex < state.GetNICCount();
      ++nicIndex)
   {
      // Add the nic to the list
      // NOTE: the index in the list view directly cooresponds
      //       to the index into the NIC list held in the state
      //       object

      NetworkInterface nic = state.GetNIC(nicIndex);

      LVITEM listItem;
      ZeroMemory(&listItem, sizeof(LVITEM));

      listItem.iSubItem = 0;
      listItem.mask = LVIF_TEXT;
      listItem.pszText = const_cast<wchar_t*>(nic.GetDescription().c_str());

/*      listItem.mask |= LVIF_IMAGE;
      if (isInstalled)
      {
         listItem.iImage = 0;
      }
      else
      {
         listItem.iImage = 1;
      }
*/
      int newItem = Win::ListView_InsertItem(
                       hwndBox, 
                       listItem);

      ASSERT(newItem >= 0);
      ASSERT(newItem == (int)nicIndex);

      if (newItem >= 0)
      {
         // Add the status and the ipaddress

         listItem.iItem = newItem;
         listItem.iSubItem = 2;
         listItem.pszText = const_cast<wchar_t*>(nic.GetStringIPAddress().c_str());

         Win::ListView_SetItem(
            hwndBox,
            listItem);
      }
   }
}

bool
NICSelectionPage::OnSetActive()
{
   LOG_FUNCTION(NICSelectionPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}

int
NICSelectionPage::Validate()
{
   LOG_FUNCTION(NICSelectionPage::Validate);

   int nextPage = IDD_AD_DOMAIN_NAME_PAGE;

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkserverpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkServerPage.cpp
//
// Synopsis:  Defines Network Server Page for the CYS
//            Wizard
//
// History:   02/06/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "NetworkServerPage.h"
#include "state.h"

static PCWSTR NETWORKSERVER_PAGE_HELP = L"cys.chm::/sag_ADserverRoles.htm";

NetworkServerPage::NetworkServerPage()
   :
   CYSWizardPage(
      IDD_NETWORK_SERVER_PAGE, 
      IDS_NETWORK_SERVER_TITLE, 
      IDS_NETWORK_SERVER_SUBTITLE,
      NETWORKSERVER_PAGE_HELP)
{
   LOG_CTOR(NetworkServerPage);
}

   

NetworkServerPage::~NetworkServerPage()
{
   LOG_DTOR(NetworkServerPage);
}


void
NetworkServerPage::OnInit()
{
   LOG_FUNCTION(NetworkServerPage::OnInit);

   // Check and disable the checkboxes for services that are already installed
   // and configured

   bool isDHCPInstalled = 
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().IsServiceInstalled();

   bool isDHCPConfigured =
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().IsConfigured();

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_DHCP_CHECK), 
      (isDHCPInstalled && isDHCPConfigured) ? BST_CHECKED : BST_UNCHECKED);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DHCP_CHECK),
      !isDHCPInstalled && !isDHCPConfigured);

   bool isDNSInstalled = 
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().IsServiceInstalled();

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_DNS_CHECK), 
      isDNSInstalled ? BST_CHECKED : BST_UNCHECKED);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DNS_CHECK),
      !isDNSInstalled);

   bool isWINSInstalled = 
      InstallationUnitProvider::GetInstance().GetWINSInstallationUnit().IsServiceInstalled();

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_WINS_CHECK), 
      isWINSInstalled ? BST_CHECKED : BST_UNCHECKED);
   
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_WINS_CHECK),
      !isWINSInstalled);

   bool isRRASInstalled = 
      InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().IsServiceInstalled();

   bool isRRASConfigured = 
      InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().IsConfigured();

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_RRAS_CHECK), 
      (isRRASInstalled && isRRASConfigured) ? BST_CHECKED : BST_UNCHECKED);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_RRAS_CHECK),
      !isRRASInstalled || !isRRASConfigured);
}

bool
NetworkServerPage::OnSetActive()
{
   LOG_FUNCTION(NetworkServerPage::OnSetActive);

   // Set the wizard buttons according to the state of the UI

   SetWizardButtons();

   return true;
}


bool
NetworkServerPage::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NetworkServerPage::OnCommand);
 
   bool result = false;

   if (IDC_DHCP_CHECK == controlIDFrom ||
       IDC_DNS_CHECK  == controlIDFrom ||
       IDC_WINS_CHECK == controlIDFrom ||
       IDC_RRAS_CHECK == controlIDFrom)
   {
      // If at least one checkbox is checked then allow the next button to be enabled
      // NOTE: this does not take into account whether the service is already installed or not

      if (BN_CLICKED == code &&
          IDC_DHCP_CHECK == controlIDFrom)
      {
         bool ischecked = Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_DHCP_CHECK));

         if (!InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().IsServiceInstalled())
         {
            InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().SetDHCPInstall(ischecked);
         }
      }

      if (BN_CLICKED == code &&
          IDC_DNS_CHECK == controlIDFrom)
      {
         bool ischecked = Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_DNS_CHECK));

         if (!InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().IsServiceInstalled())
         {
            InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().SetDNSInstall(ischecked);
         }
      }

      if (BN_CLICKED == code &&
          IDC_WINS_CHECK == controlIDFrom)
      {
         bool ischecked = Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_WINS_CHECK));

         if (!InstallationUnitProvider::GetInstance().GetWINSInstallationUnit().IsServiceInstalled())
         {
            InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().SetWINSInstall(ischecked);
         }
      }

      if (BN_CLICKED == code &&
          IDC_RRAS_CHECK == controlIDFrom)
      {
         bool ischecked = Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_RRAS_CHECK));

         if (!InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().IsServiceInstalled())
         {
            InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().SetRRASInstall(ischecked);
         }
      }

      SetWizardButtons();
   }

   return result;
}

void
NetworkServerPage::SetWizardButtons()
{
//   LOG_FUNCTION(NetworkServerPage::SetWizardButtons);

   // Enable the Next button only if one of the checkboxes have been checked

   bool enableNext = InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().GetDHCPInstall() 
                  || InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().GetDNSInstall()
                  || InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().GetWINSInstall()
                  || InstallationUnitProvider::GetInstance().GetNetworkServerInstallationUnit().GetRRASInstall();

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      enableNext ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK);
}


int
NetworkServerPage::Validate()
{
   LOG_FUNCTION(NetworkServerPage::Validate);


   return IDD_FINISH_PAGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkserverinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkServerInstallationUnit.cpp
//
// Synopsis:  Declares a NetworkServerInstallationUnit
//            This object has the knowledge for installing the
//            various network services including
//            RRAS, DNS, WINS, and DHCP
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "NetworkServerInstallationUnit.h"

// Finish page help 
static PCWSTR CYS_NETWORKING_SERVER_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_networking_infrastructure.htm";

NetworkServerInstallationUnit::NetworkServerInstallationUnit() :
   installDHCP(false),
   installDNS(false),
   installWINS(false),
   installRRAS(false),
   InstallationUnit(
      IDS_NETWORK_SERVER_TYPE, 
      IDS_NETWORK_SERVER_DESCRIPTION, 
      CYS_NETWORKING_SERVER_FINISH_PAGE_HELP,
      NETWORKSERVER_INSTALL)
{
   LOG_CTOR(NetworkServerInstallationUnit);
}


NetworkServerInstallationUnit::~NetworkServerInstallationUnit()
{
   LOG_DTOR(NetworkServerInstallationUnit);
}


InstallationReturnType
NetworkServerInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(NetworkServerInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;
   InstallationReturnType err = INSTALL_SUCCESS;

   if (GetDHCPInstall())
   {
      result = InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().InstallService(logfileHandle, hwnd);

      if (INSTALL_FAILURE == result)
      {
         err = result;
      }
   }

   if (GetDNSInstall())
   {
      result = InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().InstallService(logfileHandle, hwnd);

      if (INSTALL_FAILURE == result)
      {
         err = result;
      }
   }

   if (GetWINSInstall())
   {
      result = InstallationUnitProvider::GetInstance().GetWINSInstallationUnit().InstallService(logfileHandle, hwnd);

      if (INSTALL_FAILURE == result)
      {
         err = result;
      }
   }

   if (GetRRASInstall())
   {
      result = InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().InstallService(logfileHandle, hwnd);

      if (INSTALL_FAILURE == result)
      {
         err = result;
      }
   }

   LOG_INSTALL_RETURN(err);

   return err;
}

bool
NetworkServerInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(NetworkServerInstallationUnit::IsServiceInstalled);

   bool isDNSInstalled =
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().IsServiceInstalled();
   bool isDHCPInstalled =
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().IsServiceInstalled();
   bool isWINSInstalled =
      InstallationUnitProvider::GetInstance().GetWINSInstallationUnit().IsServiceInstalled();
   bool isRRASInstalled =
      InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().IsServiceInstalled();

   bool result = (isDNSInstalled && isDHCPInstalled && isWINSInstalled && isRRASInstalled);

   LOG_BOOL(result);
   return result;
}

String
NetworkServerInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(NetworkServerInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (IsServiceInstalled())
   {
      resourceID = IDS_NETWORK_SERVER_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}

bool
NetworkServerInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(NetworkServerInstallationUnit::GetFinishText);

   bool result = true;

   // Get the finish text from each of the sub-installation units

   String unitMessage;
   String intermediateMessage;

   if (GetDNSInstall())
   {
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetFinishText(unitMessage);
      intermediateMessage += unitMessage;
   }

   if (GetDHCPInstall())
   {
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().GetFinishText(unitMessage);
      intermediateMessage += unitMessage;
   }

   if (GetWINSInstall())
   {
      InstallationUnitProvider::GetInstance().GetWINSInstallationUnit().GetFinishText(unitMessage);
      intermediateMessage += unitMessage;
   }

   if (GetRRASInstall())
   {
      InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().GetFinishText(unitMessage);
      intermediateMessage += unitMessage;
   }

   if (intermediateMessage.empty())
   {
      intermediateMessage += String::load(IDS_FINISH_NO_CHANGES);
      result = false;
   }

   message += intermediateMessage;

   LOG_BOOL(result);
   return result;
}

void
NetworkServerInstallationUnit::SetDHCPInstall(bool newInstallDHCP)
{
   LOG_FUNCTION2(
      NetworkServerInstallationUnit::SetDHCPInstall,
      newInstallDHCP ? L"true" : L"false");

   installDHCP = newInstallDHCP;
}

bool
NetworkServerInstallationUnit::GetDHCPInstall() const
{
   LOG_FUNCTION(NetworkServerInstallationUnit::GetDHCPInstall);

   return installDHCP;
}

void
NetworkServerInstallationUnit::SetDNSInstall(bool newInstallDNS)
{
   LOG_FUNCTION2(
      NetworkServerInstallationUnit::SetDNSInstall,
      newInstallDNS ? L"true" : L"false");

   installDNS = newInstallDNS;
}

bool
NetworkServerInstallationUnit::GetDNSInstall() const
{
   LOG_FUNCTION(NetworkServerInstallationUnit::GetDNSInstall);

   return installDNS;
}

void
NetworkServerInstallationUnit::SetWINSInstall(bool newInstallWINS)
{
   LOG_FUNCTION2(
      NetworkServerInstallationUnit::SetWINSInstall,
      newInstallWINS ? L"true" : L"false");

   installWINS = newInstallWINS;
}

bool
NetworkServerInstallationUnit::GetWINSInstall() const
{
   LOG_FUNCTION(NetworkServerInstallationUnit::GetWINSInstall);

   return installWINS;
}

void
NetworkServerInstallationUnit::SetRRASInstall(bool newInstallRRAS)
{
   LOG_FUNCTION2(
      NetworkServerInstallationUnit::SetRRASInstall,
      newInstallRRAS ? L"true" : L"false");

   installRRAS = newInstallRRAS;
}

bool
NetworkServerInstallationUnit::GetRRASInstall() const
{
   LOG_FUNCTION(NetworkServerInstallationUnit::GetRRASInstall);

   return installRRAS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\nicselectionpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NICSelectionPage.h
//
// Synopsis:  Declares the NIC selection Page for the CYS
//            wizard.  This page lets the user choose
//            between the express and custom paths.
//
// History:   03/13/2001  JeffJon Created

#ifndef __CYS_NICSELECTIONPAGE_H
#define __CYS_NICSELECTIONPAGE_H

#include "CYSWizardPage.h"


class NICSelectionPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      NICSelectionPage();

      // Destructor

      virtual 
      ~NICSelectionPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      void
      InitializeNICListView();

      void
      FillNICListView();

      // not defined: no copying allowed
      NICSelectionPage(const NICSelectionPage&);
      const NICSelectionPage& operator=(const NICSelectionPage&);

};

#endif // __CYS_NICSELECTIONPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\networkserviceinstallationbase.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      NetworkServiceInstallationBase.h
//
// Synopsis:  Defines a NetworkServiceInstallationBase
//            Contains the common methods for the network 
//            service installations including
//            DNS, WINS, and DHCP
//
// History:   03/26/2001  JeffJon Created


#include "pch.h"

#include "NetworkServiceInstallationBase.h"


// Finish page help 
static PCWSTR CYS_NETWORKING_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_networking_infrastructure.htm";


NetworkServiceInstallationBase::NetworkServiceInstallationBase(
   unsigned int serviceNameID,
   unsigned int serviceDescriptionID,
   unsigned int serviceDescriptionInstalledID,
   InstallationUnitType newInstallType) 
   :
   installedDescriptionID(serviceDescriptionInstalledID),
   InstallationUnit(
      serviceNameID, 
      serviceDescriptionID, 
      CYS_NETWORKING_FINISH_PAGE_HELP,
      newInstallType)
{
   LOG_CTOR(NetworkServiceInstallationBase);
}

String
NetworkServiceInstallationBase::GetServiceDescription()
{
   LOG_FUNCTION(NetworkServiceInstallationBase::GetServiceDescription);

   String result;

   unsigned int resultID = descriptionID;

   if (IsServiceInstalled())
   {
      resultID = installedDescriptionID;
   }

   result = String::load(resultID);

   ASSERT(!result.empty());

   return result;
}

void
NetworkServiceInstallationBase::CreateInfFileText(
   String& infFileText, 
   unsigned int windowTitleResourceID)
{
   LOG_FUNCTION(NetworkServiceInstallationBase::CreateInfFileText);

   infFileText =  L"[Version]\n";
   infFileText += L"Signature =  \"$Windows NT$\"\n";
   infFileText += L"[Components]\n";
   infFileText += L"NetOC=netoc.dll,NetOcSetupProc,netoc.inf\n";
   infFileText += L"[Global]\n";
   infFileText += L"WindowTitle=";
   infFileText += String::load(windowTitleResourceID, hResourceModuleHandle);
   infFileText += L"\n";
   infFileText += L"[Strings]\n";
   infFileText += L";(empty)";
  
}


void
NetworkServiceInstallationBase::CreateUnattendFileText(
   String& unattendFileText, 
   PCWSTR serviceName)
{
   LOG_FUNCTION(NetworkServiceInstallationBase::CreateUnattendFileText);

   ASSERT(serviceName);

   unattendFileText =  L"[NetOptionalComponents]\n";
   unattendFileText += serviceName;
   unattendFileText += L"=1";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\pch.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      pch.h
//
// Synopsis:  precompiled header for the 
//            Configure Your Server Wizard project
//
// History:   02/02/2001  JeffJon Created

#ifndef __CYS_PCH_H
#define __CYS_PCH_H


// Stuff from burnslib

#include <burnslib.hpp>


#include <iphlpapi.h>
#include <shlwapi.h>
#include <dsrolep.h>
#include <comdef.h>

extern "C"
{
   #include <dhcpapi.h>
   #include <mdhcsapi.h>
}

// WMI
#include <wbemidl.h>

#include <shlobjp.h>

// Setup API - SetupPromptReboot

#include <setupapi.h>


#include "regkeys.h"
#include "common.h"

#endif // __CYS_PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\passwordeditbox.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen from johnstep's common cred ui
// ds/win32/credui



#include "pch.h"
#include "PasswordEditBox.hpp"



PasswordEditBox::PasswordEditBox()
{
   LOG_CTOR(PasswordEditBox);
}



PasswordEditBox::~PasswordEditBox()
{
   LOG_DTOR(PasswordEditBox);
}



HRESULT
PasswordEditBox::Init(HWND editControl)
{
   LOG_FUNCTION(PasswordEditBox::Init);
   ASSERT(Win::GetClassName(editControl) == L"Edit");

//    By commenting out this code, we disable the subclassing and therefore
//    the caps lock warning bubble.  We do this because it appears that the
//    edit box common control now offers that same functionality.
//    NTRAID#NTBUG9-255537-2000/12/12-sburns to disable the code
//    NTRAID#NTBUG9-255568-2000/12/12-sburns to remove the code from the source
//    tree entirely.
//    
//    HRESULT hr = ControlSubclasser::Init(editControl);
//    if (SUCCEEDED(hr))
//    {
//       // set the options on the edit control
//       
//       Win::Edit_LimitText(hwnd, DS::MAX_PASSWORD_LENGTH);
// 
//       // (could also set the password style bit here, if we wanted.)
// 
//       balloonTip.Init(hwnd);
//    }
// 
//    return hr;

   return S_OK;
}



bool
IsCapsLockOn()
{
//   LOG_FUNCTION(IsCapsLockOn);

   return (::GetKeyState(VK_CAPITAL) & 1) ? true : false;
}



LRESULT
PasswordEditBox::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // LOG_FUNCTION(PasswordEditBox::OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {

		  if (wparam == VK_CAPITAL)
         {
            // user pressed caps lock key

            balloonTip.Show(IsCapsLockOn());
         }
         else
         {
            // they hit some other key, so get rid of the tool tip
            
            balloonTip.Show(false);
         }

         break;
      }
      case WM_SETFOCUS:
      {
        // Make sure no one can steal the focus while a user is entering their
        // password

        ::LockSetForegroundWindow(LSFW_LOCK);

        balloonTip.Show(IsCapsLockOn());
       
        break;
      }
      case WM_PASTE:
      {
         balloonTip.Show(false);
         break;
      }
      case WM_KILLFOCUS:
      {
         balloonTip.Show(false);
         
        // Make sure other processes can set foreground window once again.

        ::LockSetForegroundWindow(LSFW_UNLOCK);

        break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\passwordeditbox.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef PASSWORDEDITBOX_HPP_INCLUDED
#define PASSWORDEDITBOX_HPP_INCLUDED



#include "CapsLockBalloonTip.hpp"
#include "ControlSubclasser.hpp"



// Class for hooking the window proc of an edit control to add a balloon
// tooltip that is shown when the caps lock key is pressed.

class PasswordEditBox : public ControlSubclasser
{
   public:

   PasswordEditBox();

   virtual 
   ~PasswordEditBox();



   // subclasses the edit control, inits the balloon tip, and sets the text
   // limit appropriately.
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we fire an assertion.
   
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.
   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);
   


   private:

   // not implemented: no copying allowed

   PasswordEditBox(const PasswordEditBox&);
   const PasswordEditBox& operator=(const PasswordEditBox&);

   CapsLockBalloonTip balloonTip;        
};



#endif   // PASSWORDEDITBOX_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\printinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      PrintInstallationUnit.h
//
// Synopsis:  Declares a PrintInstallationUnit
//            This object has the knowledge for installing the
//            shared printers
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_PRINTINSTALLATIONUNIT_H
#define __CYS_PRINTINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class PrintInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      PrintInstallationUnit();

      // Destructor

      virtual
      ~PrintInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);


      void
      SetClients(bool allclients);

      bool
      ForAllClients() const { return forAllClients; }

   private:

      bool  forAllClients;
};

#endif // __CYS_PRINTINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\printserverpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      PrintServerPage.cpp
//
// Synopsis:  Defines the Printer page of the CYS wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "PrintServerPage.h"
#include "state.h"

static PCWSTR PRINTSERVER_PAGE_HELP = L"cys.chm::/cys_configuring_print_server.htm";

PrintServerPage::PrintServerPage()
   :
   CYSWizardPage(
      IDD_PRINT_SERVER_PAGE, 
      IDS_PRINT_SERVER_TITLE, 
      IDS_PRINT_SERVER_SUBTITLE,
      PRINTSERVER_PAGE_HELP)
{
   LOG_CTOR(PrintServerPage);
}

   

PrintServerPage::~PrintServerPage()
{
   LOG_DTOR(PrintServerPage);
}


void
PrintServerPage::OnInit()
{
   LOG_FUNCTION(PrintServerPage::OnInit);

   Win::Button_SetCheck(GetDlgItem(hwnd, IDC_W2K_RADIO), BST_CHECKED);
}


bool
PrintServerPage::OnSetActive()
{
   LOG_FUNCTION(PrintServerPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
PrintServerPage::Validate()
{
   LOG_FUNCTION(PrintServerPage::Validate);

   int nextPage = -1;

   InstallationUnitProvider::GetInstance().GetPrintInstallationUnit().SetClients(
      Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_ALL_RADIO)));

   nextPage = IDD_FINISH_PAGE;

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\printserverpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      PrintServerPage.h
//
// Synopsis:  Declares the Print Server page
//            for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_PRINTSERVERPAGE_H
#define __CYS_PRINTSERVERPAGE_H

#include "CYSWizardPage.h"


class PrintServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      PrintServerPage();

      // Destructor

      virtual 
      ~PrintServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      PrintServerPage(const PrintServerPage&);
      const PrintServerPage& operator=(const PrintServerPage&);

};


#endif // __CYS_PRINTSERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\printinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      PrintInstallationUnit.cpp
//
// Synopsis:  Defines a PrintInstallationUnit
//            This object has the knowledge for installing the
//            printer services
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "PrintInstallationUnit.h"


// Finish page help 
static PCWSTR CYS_PRINT_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_print_server.htm";

PrintInstallationUnit::PrintInstallationUnit() :
   forAllClients(false),
   InstallationUnit(
      IDS_PRINT_SERVER_TYPE, 
      IDS_PRINT_SERVER_DESCRIPTION, 
      CYS_PRINT_FINISH_PAGE_HELP,
      PRINTSERVER_INSTALL)
{
   LOG_CTOR(PrintInstallationUnit);
}


PrintInstallationUnit::~PrintInstallationUnit()
{
   LOG_DTOR(PrintInstallationUnit);
}


InstallationReturnType
PrintInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(PrintInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   String resultText;

   // Always execute the Add Printer Wizard

   CYS_APPEND_LOG(String::load(IDS_PRINTER_WIZARD_CONFIG_LOG_TEXT));

   if (ExecuteWizard(CYS_PRINTER_WIZARD_NAME, resultText))
   {
      LOG(L"Add Printer Wizard succeeded");
   }
   else
   {
      LOG(L"Add Printer Wizard failed");

      result = INSTALL_FAILURE;
   }

   if (!resultText.empty())
   {
      CYS_APPEND_LOG(resultText);
   }
   
   if (forAllClients)
   {
      // Now execute the Add Printer Driver Wizard

      if (ExecuteWizard(CYS_PRINTER_DRIVER_WIZARD_NAME, resultText))
      {
         LOG(L"Add Printer Driver Wizard succeeded");
      }
      else
      {
         LOG(L"Add Printer Driver Wizard failed");
         result = INSTALL_FAILURE;
      }

      if (!resultText.empty())
      {
         CYS_APPEND_LOG(resultText);
      }
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
PrintInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(PrintInstallationUnit::IsServiceInstalled);

   // It is always possible to start the print wizards so
   // we just say that it is never installed.

   LOG_BOOL(false);
   return false;
}

bool
PrintInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(PrintInstallationUnit::GetFinishText);

   if (forAllClients)
   {
      message += String::load(IDS_PRINT_FINISH_ALL_CLIENTS);
   }
   else
   {
      message += String::load(IDS_PRINT_FINISH_W2K_CLIENTS);
   }

   LOG_BOOL(true);
   return true;
}


void
PrintInstallationUnit::SetClients(bool allclients)
{
   LOG_FUNCTION2(
      PrintInstallationUnit::SetClients,
      allclients ? L"true" : L"false");

   forAllClients = allclients;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\regkeys.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      regkeys.h
//
// Synopsis:  Declares all the registry keys used throughout CYS
//
// History:   02/13/2001  JeffJon Created


#ifndef __CYS_REGKEYS_H
#define __CYS_REGKEYS_H


// Terminal Server

#define CYS_SERVER_SIZE_REGKEY      L"SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters"
#define CYS_SERVER_SIZE_VALUE       L"Size"
#define CYS_SERVER_CACHE_REGKEY     L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define CYS_SERVER_CACHE_VALUE      L"LargeSystemCache"
#define CYS_APPLICATION_MODE_REGKEY L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server"
#define CYS_APPLICATION_MODE_VALUE  L"TSAppCompat"
#define CYS_APPLICATION_MODE_ON     1
#define CYS_SERVER_SIZE_ON          3
#define CYS_SERVER_CACHE_ON         0

// DHCP

#define CYS_DHCP_DOMAIN_IP_REGKEY   L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define CYS_DHCP_DOMAIN_IP_VALUE    L"DomainDNSIP"

// DNS

#define DNS_WIZARD_RESULT_REGKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define DNS_WIZARD_RESULT_VALUE     L"DnsWizResult"
#define DNS_WIZARD_CONFIG_REGKEY    L"System\\CurrentControlSet\\Services\\DNS\\Parameters"
#define DNS_WIZARD_CONFIG_VALUE     L"AdminConfigured"

// Media Services

#define REGKEY_NETSHOW  L"SOFTWARE\\Microsoft\\NetShow"                                

// RRAS

#define CYS_RRAS_CONFIGURED_REGKEY      L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess"
#define CYS_RRAS_CONFIGURED_VALUE       L"ConfigurationFlags"

// Express Setup

#define CYS_FIRST_DC_REGKEY   L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define CYS_FIRST_DC_VALUE    L"FirstDC"
#define CYS_FIRST_DC_VALUE_SET 1
#define CYS_FIRST_DC_VALUE_UNSET 0

// CYS general

#define CYS_HOME_REGKEY                         L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define CYS_HOME_VALUE                          L"home"
#define CYS_HOME_REGKEY_TERMINAL_SERVER_VALUE   L"terminalServer"
#define CYS_HOME_REGKEY_TERMINAL_SERVER_OPTIMIZED L"terminalServerOptimize"
#define CYS_HOME_REGKEY_DCPROMO_VALUE           L"DCPROMO"
#define CYS_HOME_REGKEY_FIRST_SERVER_VALUE      L"FirstServer"
#define CYS_HOME_REGKEY_DEFAULT_VALUE           L"home"
#define CYS_HOME_REGKEY_MUST_RUN                L"CYSMustRun"
#define CYS_HOME_RUN_KEY_DONT_RUN               0
#define CYS_HOME_RUN_KEY_RUN_AGAIN              1
#define CYS_HOME_REGKEY_DOMAINDNS               L"DomainDNSName"
#define CYS_HOME_REGKEY_DOMAINIP                L"DomainDNSIP"

// This isn't a regkey but this was a good place to put it

#define CYS_LOGFILE_NAME   L"cys"

#endif // __CYS_REGKEYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\rrasinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      RRASInstallationUnit.cpp
//
// Synopsis:  Defines a RRASInstallationUnit
//            This object has the knowledge for installing the
//            RRAS service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "RRASInstallationUnit.h"



RRASInstallationUnit::RRASInstallationUnit() :
   NetworkServiceInstallationBase(
      IDS_RRAS_SERVER_TYPE, 
      IDS_RRAS_SERVER_DESCRIPTION2, 
      IDS_RRAS_SERVER_DESCRIPTION_INSTALLED,
      RRAS_INSTALL)
{
   LOG_CTOR(RRASInstallationUnit);
}


RRASInstallationUnit::~RRASInstallationUnit()
{
   LOG_DTOR(RRASInstallationUnit);
}


InstallationReturnType
RRASInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(RRASInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Run the RRAS Wizard
   
   do
   {
      String resultText;

      if (!ExecuteWizard(CYS_RRAS_SERVICE_NAME, resultText))
      {
         if (!resultText.empty())
         {
            CYS_APPEND_LOG(resultText);
         }

         result = INSTALL_FAILURE;
         break;
      }

      if (IsServiceInstalled())
      {
         // The Configure DNS Server Wizard completed successfully
      
         LOG(L"RRAS server wizard completed successfully");
         CYS_APPEND_LOG(String::load(IDS_LOG_RRAS_COMPLETED_SUCCESSFULLY));
      }
      else
      {
         // The Configure DHCP Server Wizard did not finish successfully


         LOG(L"The RRAS wizard failed to run");

         CYS_APPEND_LOG(String::load(IDS_LOG_RRAS_WIZARD_ERROR));

         result = INSTALL_FAILURE;
      }
   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
RRASInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(RRASInstallationUnit::IsServiceInstalled);

   // The service is always installed so we really just
   // need to check to see if it is configured

   bool result = IsConfigured();

   LOG_BOOL(result);
   return result;
}

bool
RRASInstallationUnit::IsConfigured()
{
   LOG_FUNCTION(RRASInstallationUnit::IsConfigured);


   DWORD resultValue = 0;
   bool result = GetRegKeyValue(
                    CYS_RRAS_CONFIGURED_REGKEY,
                    CYS_RRAS_CONFIGURED_VALUE,
                    resultValue);

   if (result)
   {
      result = (resultValue != 0);
   }

   LOG_BOOL(result);

   return result;
}

bool
RRASInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(RRASInstallationUnit::GetFinishText);

   message = String::load(IDS_RRAS_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\rrasinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      RRASInstallationUnit.h
//
// Synopsis:  Declares a RRASInstallationUnit
//            This object has the knowledge for installing the
//            RRAS service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_RRASINSTALLATIONUNIT_H
#define __CYS_RRASINSTALLATIONUNIT_H

#include "NetworkServiceInstallationBase.h"

class RRASInstallationUnit : public NetworkServiceInstallationBase
{
   public:
      
      // Constructor

      RRASInstallationUnit();

      // Destructor

      virtual
      ~RRASInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      virtual
      bool
      IsConfigured();
};

#endif // __CYS_RRASINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\restorepasswordpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      RestorePasswordPage.cpp
//
// Synopsis:  Defines the restore password page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "RestorePasswordPage.h"
#include "state.h"

static PCWSTR RESTOREPWD_PAGE_HELP = L"cys.chm::/cys_configuring_first_server.htm";

RestorePasswordPage::RestorePasswordPage()
   :
   CYSWizardPage(
      IDD_RESTORE_PASSWORD_PAGE, 
      IDS_RESTORE_PASSWORD_TITLE, 
      IDS_RESTORE_PASSWORD_SUBTITLE,
      RESTOREPWD_PAGE_HELP)
{
   LOG_CTOR(RestorePasswordPage);
}

   

RestorePasswordPage::~RestorePasswordPage()
{
   LOG_DTOR(RestorePasswordPage);
}


void
RestorePasswordPage::OnInit()
{
   LOG_FUNCTION(RestorePasswordPage::OnInit);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   password.Init(Win::GetDlgItem(hwnd, IDC_PASSWORD));
   confirm.Init(Win::GetDlgItem(hwnd, IDC_CONFIRM));
}


bool
RestorePasswordPage::OnSetActive()
{
   LOG_FUNCTION(RestorePasswordPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}


int
RestorePasswordPage::Validate()
{
   LOG_FUNCTION(RestorePasswordPage::Validate);

   int nextPage = -1;

   String password = Win::GetTrimmedDlgItemText(hwnd, IDC_PASSWORD);
   String confirm = Win::GetTrimmedDlgItemText(hwnd, IDC_CONFIRM);

   if (password != confirm)
   {
      String blank;
      Win::SetDlgItemText(hwnd, IDC_PASSWORD, blank);
      Win::SetDlgItemText(hwnd, IDC_CONFIRM, blank);
      popup.Gripe(
         hwnd,
         IDC_PASSWORD,
         IDS_PASSWORD_MISMATCH);
      return -1;
   }

   InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetSafeModeAdminPassword(password);

   nextPage = IDD_EXPRESS_DNS_PAGE;

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\restorepasswordpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      RestorePasswordPage.h
//
// Synopsis:  Declares the restore password page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_RESTOREPASSWORDPAGE_H
#define __CYS_RESTOREPASSWORDPAGE_H

#include "CYSWizardPage.h"
#include "PasswordEditBox.hpp"

class RestorePasswordPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      RestorePasswordPage();

      // Destructor

      virtual 
      ~RestorePasswordPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
      PasswordEditBox password;
      PasswordEditBox confirm;

      // not defined: no copying allowed
      RestorePasswordPage(const RestorePasswordPage&);
      const RestorePasswordPage& operator=(const RestorePasswordPage&);

};

#endif // __CYS_RESTOREPASSWORDPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cys.rc
//
#define IDS_WIZARD_TITLE                1
#define IDS_ALREADY_RUNNING             2
#define IDS_BIG_BOLD_FONT_NAME          3
#define IDS_BIG_BOLD_FONT_SIZE          4
#define IDS_CONFIRM_CANCEL              5
#define IDS_INDEXING_SERVICE_OFF_YES_RADIO 6
#define IDS_INDEXING_SERVICE_OFF_NO_RADIO 7
#define IDS_CONFIRM_REBOOT              8
#define IDS_NOT_ADMIN                   9
#define IDS_DC_UPGRADE_NOT_COMPLETE     10
#define IDS_DCPROMO_RUNNING             11
#define IDS_DCPROMO_PENDING_REBOOT      12
#define IDS_ADVANCED_SETUP_INCOMPLETE   13
#define IDS_SERVER_CD                   14
#define IDS_ADVANCED_SERVER_CD          15
#define IDS_DATACENTER_SERVER_CD        16
#define IDS_WINDOWS_CD                  17
#define IDS_MUST_ENTER_DOMAIN           18
#define IDS_DOMAIN_NAME_IN_USE          19
#define IDS_NET_NOT_REACHABLE           20
#define IDS_NON_RFC_NAME                21
#define IDS_DNS_NAME_TOO_LONG           22
#define IDS_BAD_DNS_SYNTAX              23
#define IDS_CONFIRM_NETBIOS_LOOKING_NAME 24
#define IDS_GENERATED_NAME_WAS_TWEAKED  25
#define IDS_PASSWORD_MISMATCH           26
#define IDS_IPADDRESS_REQUIRED          27
#define IDS_CAPS_LOCK_TIP_TITLE         28
#define IDS_CAPS_LOCK_TIP_TEXT          29
#define IDS_SYSOC_COMMAND_LINE          30
#define IDS_BOTH_IPADDRESS_REQUIRED     31
#define IDS_NO_DOTS_IN_NETBIOS_NAME     32
#define IDS_NUMERIC_NETBIOS_NAME        33
#define IDS_BAD_NETBIOS_NAME            34
#define IDS_NETBIOS_NAME_TOO_LONG       35
#define IDS_BAD_NETBIOS_CHARACTERS      36
#define IDS_FLATNAME_IN_USE             37
#define IDS_MASK_REQUIRED               38
#define IDS_FAILED_INSTALL              39
#define IDS_NO_CHANGES_MESSAGEBOX_TEXT  40
#define IDS_NETWORK_SERVER_TYPE         50
#define IDS_NETWORK_SERVER_DESCRIPTION  51
#define IDS_APPLICATION_SERVER_TYPE     52
#define IDS_APPLICATION_SERVER_DESCRIPTION 53
#define IDS_FILE_SERVER_TYPE            54
#define IDS_FILE_SERVER_DESCRIPTION     55
#define IDS_PRINT_SERVER_TYPE           56
#define IDS_PRINT_SERVER_DESCRIPTION    57
#define IDS_SHARE_POINT_TYPE            58
#define IDS_SHARE_POINT_DESCRIPTION     59
#define IDS_SHAREPOINT_DESCRIPTION_BASE 59
#define IDS_MEDIA_SERVER_TYPE           60
#define IDS_MEDIA_SERVER_DESCRIPTION    61
#define IDS_WEB_SERVER_TYPE             62
#define IDS_WEB_SERVER_DESCRIPTION      63
#define IDS_DHCP_SERVER_TYPE            64
#define IDS_DHCP_SERVER_DESCRIPTION     65
#define IDS_DNS_SERVER_TYPE             66
#define IDS_DNS_SERVER_DESCRIPTION      67
#define IDS_WINS_SERVER_TYPE            68
#define IDS_WINS_SERVER_DESCRIPTION     69
#define IDS_RRAS_SERVER_TYPE            70
#define IDS_RRAS_SERVER_DESCRIPTION     71
#define IDS_APPLICATION_SERVER_TYPE_SRV 71
#define IDS_EXPRESS_PATH_TYPE           72
#define IDS_EXPRESS_PATH_DESCRIPTION    73
#define IDS_DOMAIN_CONTROLLER_TYPE      74
#define IDS_DOMAIN_CONTROLLER_DESCRIPTION 75
#define IDS_CLUSTER_SERVER_TYPE         76
#define IDS_CLUSTER_SERVER_DESCRIPTION  77
#define IDS_WEB_DESCRIPTION_INSTALLED   78
#define IDS_MEDIA_SERVER_DESCRIPTION_INSTALLED 79
#define IDS_APP_SERVER_DESCRIPTION_OPTIMIZED 80
#define IDS_APP_SERVER_DESCRIPTION_NOT_OPTIMIZED 81
#define IDS_APP_ADVSERVER_DESCRIPTION_OPTIMIZED_INSTALLED 82
#define IDS_APP_ADVSERVER_DESCRIPTION_OPTIMIZED_NOT_INSTALLED 83
#define IDS_APP_ADVSERVER_DESCRIPTION_NOT_OPTIMIZED_NOT_INSTALLED 84
#define IDS_APP_ADVSERVER_DESCRIPTION_NOT_OPTIMIZED_INSTALLED 85
#define IDS_SHAREPOINT_DESCRIPTION_SPONLY 86
#define IDS_SHAREPOINT_DESCRIPTION_INSTALLED 87
#define IDS_SHAREPOINT_DESCRIPTION_SP_AND_INDEXING 88
#define IDS_SHAREPOINT_DESCRIPTION_SP_AND_IIS 89
#define IDS_SHAREPOINT_DESCRIPTION_SP_INDEXING_IIS 90
#define IDS_DOMAIN_CONTROLLER_DESCRIPTION_INSTALLED 91
#define IDS_NETWORK_SERVER_DESCRIPTION_INSTALLED 92
#define IDS_CLUSTER_SERVER_DESCRIPTION_INSTALLED 93
#define IDS_DNS_SERVER_DESCRIPTION_INSTALLED 94
#define IDS_DHCP_SERVER_DESCRIPTION_INSTALLED 95
#define IDS_WINS_SERVER_DESCRIPTION_INSTALLED 96
#define IDS_RRAS_SERVER_DESCRIPTION_INSTALLED 97
#define IDS_RRAS_SERVER_DESCRIPTION2    98
#define IDS_WELCOME_TITLE               100
#define IDS_WELCOME_SUBTITLE            101
#define IDB_BANNER16                    101
#define IDS_FINISH_TITLE                102
#define IDB_WATERMARK16                 103
#define IDS_FINISH_SUBTITLE             103
#define IDB_WATERMARK256                104
#define IDS_CUSTOM_SERVER_TITLE         104
#define IDB_BANNER256                   105
#define IDS_CUSTOM_SERVER_SUBTITLE      105
#define IDD_WELCOME_PAGE                106
#define IDS_NETWORK_SERVER_TITLE        106
#define IDD_FINISH_PAGE                 107
#define IDS_NETWORK_SERVER_SUBTITLE     107
#define IDD_CUSTOM_SERVER_PAGE          108
#define IDS_DECISION_TITLE              108
#define IDD_NETWORK_SERVER_PAGE         109
#define IDS_DECISION_SUBTITLE           109
#define IDS_AD_DOMAIN_TITLE             110
#define IDS_AD_DOMAIN_SUBTITLE          111
#define IDB_CHECK                       112
#define IDS_NETBIOS_NAME_TITLE          112
#define IDS_NETBIOS_NAME_SUBTITLE       113
#define IDS_EXPRESS_DNS_TITLE           114
#define IDS_EXPRESS_DNS_SUBTITLE        115
#define IDD_DECISION_PAGE               116
#define IDS_EXPRESS_DHCP_TITLE          116
#define IDD_AD_DOMAIN_NAME_PAGE         117
#define IDS_EXPRESS_DHCP_SUBTITLE       117
#define IDD_NETBIOS_NAME                118
#define IDS_RESTORE_PASSWORD_TITLE      118
#define IDC_NETBIOS                     119
#define IDS_RESTORE_PASSWORD_SUBTITLE   119
#define IDD_EXPRESS_DNS_PAGE            120
#define IDS_PRINT_SERVER_TITLE          120
#define IDD_EXPRESS_DHCP_PAGE           121
#define IDS_PRINT_SERVER_SUBTITLE       121
#define IDD_RESTORE_PASSWORD_PAGE       122
#define IDS_TERMINAL_SERVER_TITLE       122
#define IDC_MESSAGE                     123
#define IDS_TERMINAL_SERVER_SUBTITLE    123
#define IDC_PASSWORD                    124
#define IDS_SHARE_POINT_TITLE           124
#define IDC_CONFIRM                     125
#define IDS_SHARE_POINT_SUBTITLE        125
#define IDD_PRINT_SERVER_PAGE           126
#define IDS_FILE_SERVER_TITLE           126
#define IDD_TERMINAL_SERVER_PAGE        127
#define IDS_FILE_SERVER_SUBTITLE        127
#define IDD_SHARE_POINT_PAGE            128
#define IDS_INDEXING_TITLE              128
#define IDD_FILE_SERVER_PAGE            129
#define IDS_INDEXING_SUBTITLE           129
#define IDD_INDEXING_PAGE               130
#define IDS_FILE_FINISH_DISK_QUOTAS     130
#define IDS_FILE_FINISH_INDEXING_ON     131
#define IDD_NIC_SELECTION_PAGE          131
#define IDS_FILE_FINISH_INDEXING_OFF    132
#define IDD_BEFORE_BEGIN_PAGE           132
#define IDS_FINISH_NO_CHANGES           133
#define IDD_FINISH_DIALOG               133
#define IDD_SUCCESS_DIALOG              133
#define IDS_PRINT_FINISH_ALL_CLIENTS    134
#define IDD_CLUSTER_SERVER_PAGE         134
#define IDS_PRINT_FINISH_W2K_CLIENTS    135
#define IDI_CYS_ICON                    135
#define IDS_NIC_SELECTION_TITLE         136
#define IDS_NIC_SELECTION_SUBTITLE      137
#define IDI_SMALL_WARNING               137
#define IDS_BEFORE_BEGIN_TITLE          138
#define IDS_BEFORE_BEGIN_SUBTITLE       139
#define IDS_CLUSTER_TITLE               140
#define IDS_CLUSTER_SUBTITLE            141
#define IDS_INDEX_PAGE_STATIC_INSTALLED 142
#define IDS_INDEX_PAGE_STATIC_NOT_INSTALLED 143
#define IDS_SERVER_ROLE_COLUMN_HEADER   144
#define IDS_STATUS_COLUMN_HEADER        145
#define IDS_STATUS_COMPLETED            146
#define IDC_BIG_BOLD_TITLE              200
#define IDS_DHCP_INF_WINDOW_TITLE       200
#define IDC_FINISH_MESSAGE              201
#define IDS_LAUNCH_DHCP_WIZARD_COMMAND_LINE 201
#define IDS_LAUNCH_DHCP_WIZARD_FAILED   202
#define IDS_DHCP_WIZARD_FAILED          203
#define IDS_DHCP_WIZARD_SUCCEEDED       204
#define IDS_LOG_DHCP_COMPLETED_SUCCESSFULLY 205
#define IDS_LOG_DHCP_WIZARD_ERROR       206
#define IDS_LOG_DHCP_INSTALL_FAILED     207
#define IDS_LOG_INSTALL_START_DHCP      208
#define IDS_LOG_APP_OPTIMIZE_SUCCESS    209
#define IDS_LOG_APP_OPTIMIZE_FAILED     210
#define IDS_LOG_APP_OPTIMIZE_FAILED_WITH_ERROR 211
#define IDS_LOG_APP_CONFIGURE           212
#define IDS_LOG_APP_ABORTED             213
#define IDS_LOG_APP_INSTALL_FAILED      214
#define IDS_LOG_APP_REBOOT_SUCCESS      215
#define IDS_LOG_APP_REBOOT_FAILED       216
#define IDS_LOG_DCPROMO_REBOOT_FAILED   217
#define IDS_LOG_DHCP_AUTHORIZATION_SUCCEEDED 218
#define IDS_LOG_DHCP_AUTHORIZATION_FAILED 219
#define IDS_LOG_TAPI_CONFIG_SUCCEEDED   220
#define IDS_LOG_TAPI_CONFIG_SUCCEEDED_FORMAT 221
#define IDS_LOG_TAPI_CONFIG_FAILED_FORMAT 222
#define IDS_LOG_FILE_SERVER             223
#define IDS_LOG_FILE_SERVER_SET_QUOTAS  224
#define IDS_LOG_INDEXING_STOP_SUCCEEDED 225
#define IDS_LOG_INDEXING_STOP_FAILED    226
#define IDS_LOG_INDEXING_START_SUCCEEDED 227
#define IDS_LOG_INDEXING_START_FAILED   228
#define IDS_LOG_DISK_QUOTA_FAILED       229
#define IDS_LOG_DISK_QUOTA_DRIVE_FORMAT 230
#define IDS_LOG_DISK_QUOTA_LIMIT_FORMAT 231
#define IDS_LOG_DISK_QUOTA_THRESHOLD_FORMAT 232
#define IDS_LOG_DISK_QUOTA_DENY_FORMAT  233
#define IDS_LOG_DISK_QUOTA_NOT_DENY_FORMAT 234
#define IDS_LOG_DISK_QUOTA_LOG_LIMIT    235
#define IDS_LOG_DISK_QUOTA_LOG_WARNING  236
#define IDS_LOG_SHAREPOINT              237
#define IDS_LOG_SHAREPOINT_NO_IIS       238
#define IDS_LOG_SHAREPOINT_INSTALL_SUCCESS 239
#define IDS_LOG_SHAREPOINT_INSTALL_FAILED 240
#define IDS_LOG_SHAREPOINT_INSTALL_ERROR 241
#define IDS_LOG_SHAREPOINT_REPLACEMENT_URL 242
#define IDS_LOG_SHAREPOINT_STARTMENU    243
#define IDS_LOG_SHAREPOINT_NEW_URL      244
#define IDS_LOG_SHAREPOINT_INDEXING_ON  245
#define IDS_DECISION_PAGE_TEXT          246
#define IDS_OPEN_LOG_FORMAT_STRING      247
#define IDS_LOG_SHAREPOINT_DEFAULT_URL  248
#define IDS_DNS_INF_WINDOW_TITLE        300
#define IDS_LAUNCH_DNS_WIZARD_COMMAND_LINE 301
#define IDS_LAUNCH_DNS_WIZARD_FAILED    302
#define IDS_DNS_WIZARD_FAILED           303
#define IDS_DNS_WIZARD_SUCCEEDED        304
#define IDS_LOG_INSTALL_START_DNS       305
#define IDS_LOG_DNS_COMPLETED_SUCCESSFULLY 306
#define IDS_LOG_DNS_WIZARD_ERROR        307
#define IDS_LOG_DNS_WIZARD_CANCELLED    308
#define IDS_LOG_WIZARD_CANCELLED        308
#define IDS_LOG_DNS_INSTALL_FAILED      309
#define IDS_LOG_INSTALL_WMS_SUCCESS     310
#define IDS_LOG_INSTALL_WMS_FAILED      311
#define IDS_LAUNCH_RRAS_WIZARD_COMMAND_LINE 401
#define IDS_LAUNCH_RRAS_WIZARD_FAILED   402
#define IDS_RRAS_WIZARD_FAILED          403
#define IDS_RRAS_WIZARD_SUCCEEDED       404
#define IDS_LOG_RRAS_COMPLETED_SUCCESSFULLY 405
#define IDS_LOG_RRAS_WIZARD_ERROR       406
#define IDS_LOG_INSTALL_IIS_SUCCESS     407
#define IDS_LOG_INSTALL_IIS_FAILED      408
#define IDS_PRINTER_WIZARD_CONFIG_LOG_TEXT 500
#define IDS_LAUNCH_PRINTER_WIZARD_FAILED 501
#define IDS_PRINTER_WIZARD_FAILED       502
#define IDS_PRINTER_WIZARD_SUCCEEDED    503
#define IDS_PRINTER_DRIVER_WIZARD_FAILED 601
#define IDS_LAUNCH_PRINTER_DRIVER_WIZARD_FAILED 602
#define IDS_PRINTER_DRIVER_WIZARD_SUCCEEDED 603
#define IDS_WINS_INF_WINDOW_TITLE       700
#define IDS_LOG_INSTALL_WINS_SUCCESS    701
#define IDS_LOG_WINS_INSTALL_FAILED     702
#define IDS_LAUNCH_DCPROMO_WIZARD_FAILED 703
#define IDS_DCPROMO_FAILED              704
#define IDS_DCPROMO_SUCCEEDED_NO_REBOOT 705
#define IDS_CLUSTER_LOG_LAUNCH_FAILED   706
#define IDS_CLUSTER_LOG_LAUNCH_FAILED_NEW_CLUSTER 706
#define IDS_CLUSTER_LOG_SUCCESS         707
#define IDS_CLUSTER_LOG_SUCCESS_NEW_CLUSTER 707
#define IDS_CLUSTER_LOG_CANCELLED       708
#define IDS_CLUSTER_LOG_CANCELLED_NEW_CLUSTER 708
#define IDS_LOG_WEB_HEADING             709
#define IDS_LOG_CLUSTER_HEADING         710
#define IDS_CLUSTER_LOG_SUCCESS_ADD_NODE 711
#define IDS_CLUSTER_LOG_CANCELLED_ADD_NODE 712
#define IDS_CLUSTER_LOG_LAUNCH_FAILED_ADD_NODE 713
#define IDS_LOG_MEDIA_HEADING           714
#define IDS_LOG_DOMAIN_CONTROLLER_HEADING 715
#define IDS_LOG_DOMAIN_CONTROLLER_INSTALL 716
#define IDS_LOG_DOMAIN_CONTROLLER_SUCCESS 717
#define IDS_LOG_DOMAIN_CONTROLLER_FAILED 718
#define IDS_APPLICATION_FINISH_TEXT     800
#define IDS_DHCP_FINISH_TEXT            801
#define IDS_DNS_FINISH_TEXT             802
#define IDS_FILE_FINISH_TEXT            803
#define IDS_MEDIA_FINISH_TEXT           804
#define IDS_PRINT_FINISH_TEXT           805
#define IDS_RRAS_FINISH_TEXT            806
#define IDS_SHARE_POINT_FINISH_TEXT     807
#define IDS_SHAREPOINT_FINISH_TEXT      807
#define IDS_WEB_FINISH_TEXT             808
#define IDS_WINS_FINISH_TEXT            809
#define IDS_DC_FINISH_TEXT              810
#define IDS_CLUSTER_FINISH_TEXT         811
#define IDS_SHAREPOINT_FINISH_ADD_ADMIN 812
#define IDS_SHAREPOINT_FINISH_WEBPAGE_FORMAT 813
#define IDS_SHAREPOINT_FINISH_CREATE_FORMAT 814
#define IDS_SHAREPOINT_FINISH_INDEXING  815
#define IDS_APPLICATION_FINISH_INSTALL_TS 816
#define IDS_EXPRESS_FINISH_TEXT         817
#define IDS_EXPRESS_FINISH_DOMAIN_NAME  818
#define IDS_EXPRESS_FINISH_STATIC_IP    819
#define IDS_EXPRESS_FINISH_DHCP_SCOPE   820
#define IDS_EXPRESS_FINISH_TAPI         821
#define IDS_FILESERVER_QUOTAS_SHAREPOINT 900
#define IDS_FILESERVER_QUOTAS_NO_SHAREPOINT 901
#define IDS_FILESERVER_NO_QUOTAS_SHAREPOINT 902
#define IDS_FILESERVER_NO_QUOTAS_NO_SHAREPOINT 903
#define IDS_CLUSTER_FINISH_TEXT_NEW_CLUSTER 904
#define IDS_CLUSTER_FINISH_TEXT_EXISTING_CLUSTER 905
#define IDC_SERVER_TYPE_LIST            1000
#define IDS_KB                          1000
#define IDC_TYPE_DESCRIPTION_STATIC     1001
#define IDS_MB                          1001
#define IDC_DHCP_CHECK                  1002
#define IDS_GB                          1002
#define IDC_DNS_CHECK                   1003
#define IDC_WINS_CHECK                  1004
#define IDC_RRAS_CHECK                  1005
#define IDC_EXPRESS_RADIO               1007
#define IDC_CUSTOM_RADIO                1008
#define IDC_DOMAIN                      1009
#define IDC_STATIC_IPADDRESS            1010
#define IDC_START_IPADDRESS             1011
#define IDC_END_IPADDRESS               1012
#define IDC_W2K_RADIO                   1013
#define IDC_ALL_RADIO                   1014
#define IDC_NO_RADIO                    1016
#define IDC_YES_RADIO                   1017
#define IDC_RERUN_CHECK                 1019
#define IDC_DEFAULT_QUOTAS_CHECK        1020
#define IDC_SPACE_EDIT                  1021
#define IDC_SPACE_COMBO                 1022
#define IDC_LEVEL_EDIT                  1023
#define IDC_LEVEL_COMBO                 1024
#define IDC_DENY_DISK_CHECK             1025
#define IDC_DISK_SPACE_CHECK            1026
#define IDC_WARNING_LEVEL_CHECK         1027
#define IDC_SPACE_STATIC                1030
#define IDC_LEVEL_STATIC                1031
#define IDC_EVENT_STATIC                1032
#define IDC_MASK_IPADDRESS              1033
#define IDC_NIC_LIST                    1034
#define IDC_BULLET1                     1035
#define IDC_BULLET2                     1036
#define IDC_BULLET3                     1037
#define IDC_BULLET4                     1038
#define IDC_BULLET5                     1039
#define IDC_LINK                        1040
#define IDC_DESC_STATIC                 1042
#define IDC_HELP_LIST_CHECK             1044
#define IDC_LOG_FILE_CHECK              1045
#define IDC_INDEX_STATIC                1048
#define IDS_NIC_COLUMN                  1100
#define IDS_STATUS_COLUMN               1101
#define IDS_ADDRESS_COLUMN              1102
#define IDS_START_MENU_TOOLTIP          5000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1050
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\sharepointinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      SharePointInstallationUnit.cpp
//
// Synopsis:  Defines a SharePointInstallationUnit
//            This object has the knowledge for installing the
//            SharePoint server
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "SharePointInstallationUnit.h"
#include "InstallationUnitProvider.h"
#include "state.h"


// Define the GUIDs used by the SharePoint COM object

#include <initguid.h>
DEFINE_GUID(CLSID_SpCys,0x252EF1C7,0x6625,0x4D44,0xAB,0x9D,0x1D,0x80,0xE6,0x13,0x84,0xF9);
DEFINE_GUID(IID_ISpCys,0x389C9713,0x9775,0x4206,0xA0,0x47,0xA2,0xF7,0x49,0xF8,0x03,0x9D);


// Finish page help 
static PCWSTR CYS_SHAREPOINT_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_sharepoint_server.htm";

SharePointInstallationUnit::SharePointInstallationUnit() :
   replaceHomepage(false),
   InstallationUnit(
      IDS_SHARE_POINT_TYPE, 
      IDS_SHARE_POINT_DESCRIPTION, 
      CYS_SHAREPOINT_FINISH_PAGE_HELP,
      SHAREPOINT_INSTALL)
{
   LOG_CTOR(SharePointInstallationUnit);
}


SharePointInstallationUnit::~SharePointInstallationUnit()
{
   LOG_DTOR(SharePointInstallationUnit);
}


InstallationReturnType
SharePointInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(SharePointInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   ASSERT(!IsServiceInstalled());

   CYS_APPEND_LOG(String::load(IDS_LOG_SHAREPOINT));

   do
   {
      // We should never get here on 64bit
      if (State::GetInstance().GetPlatform() & CYS_64BIT)
      {
         ASSERT(!(State::GetInstance().GetPlatform() & CYS_64BIT));
         LOG(L"SharePoint cannot be installed on 64bit!!!");

         result = INSTALL_FAILURE;
         break;
      }


      bool wasIndexingOn = IsIndexingServiceOn();

      if (!InstallationUnitProvider::GetInstance().GetWebInstallationUnit().IsServiceInstalled())
      {
         result = 
            InstallationUnitProvider::GetInstance().GetWebInstallationUnit().InstallService(logfileHandle, hwnd);

         if (INSTALL_FAILURE == result)
         {
            break;
         }
      }


      if (InstallationUnitProvider::GetInstance().GetWebInstallationUnit().IsServiceInstalled())
      {
         // Get the name of the source location of the install files

         String installLocation;
         DWORD productSKU = State::GetInstance().GetProductSKU();
         
         if (productSKU & CYS_SERVER)
         {
            installLocation = String::load(IDS_SERVER_CD);
         }
         else if (productSKU & CYS_ADVANCED_SERVER)
         {
            installLocation = String::load(IDS_ADVANCED_SERVER_CD);
         }
         else if (productSKU & CYS_DATACENTER_SERVER)
         {
            installLocation = String::load(IDS_DATACENTER_SERVER_CD);
         }
         else
         {
            installLocation = String::load(IDS_WINDOWS_CD);
         }

         // Comments from the old HTA CYS
			// The SPInstall method of spcyscom starts the installation of OWS. 
         // This method it will look in
			// "HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\" for 
         // SourcePath key and it will add 
			// "valueadd\ms\sharepoint\setupse.exe" to it; 
         // the method will call the command "setupse.exe /q /wait". 
			// If errors are returned, is returning any error strings that
         // resulted from the install of SharePoint.

         BSTR errorMessage;
         HRESULT hr = GetSharePointObject()->SPInstall(
                         ReplaceHomePage(),
                         const_cast<WCHAR*>(installLocation.c_str()),
                         &errorMessage);

         String message;
         if (errorMessage)
         {
            message = errorMessage;
            ::SysFreeString(errorMessage);
         }

         if (SUCCEEDED(hr) && message.empty())
         {
            // Log the successful install

            CYS_APPEND_LOG(String::load(IDS_LOG_SHAREPOINT_INSTALL_SUCCESS));

            BSTR nonDefaultHomePage;
            hr = GetSharePointObject()->SPNonDefaultHomePage(&nonDefaultHomePage);
            
            // ignore the return value and continue with a blank nonDefaultHomePage

            if (nonDefaultHomePage)
            {
               nonDefaultHP = nonDefaultHomePage;
               ::SysFreeString(nonDefaultHomePage);
            }

            // Log that the admin tool was added to the start menu

            CYS_APPEND_LOG(String::load(IDS_LOG_SHAREPOINT_STARTMENU));

            if (nonDefaultHP.empty())
            {
               // Created as the default

               CYS_APPEND_LOG(
                  String::format(
                     IDS_LOG_SHAREPOINT_DEFAULT_URL,
                     State::GetInstance().GetComputerName()));
            }
            else
            {
               if (ReplaceHomePage())
               {
                  // log the replacement URL
                  
                  CYS_APPEND_LOG(
                     String::format(
                        String::load(IDS_LOG_SHAREPOINT_REPLACEMENT_URL),
                        nonDefaultHP.c_str()));
               }
               else
               {
                  // log the URL

                  CYS_APPEND_LOG(
                     String::format(
                        String::load(IDS_LOG_SHAREPOINT_NEW_URL),
                        nonDefaultHP.c_str()));
               }
            }

            // Check to see if there has been a change in the indexing services
            bool isIndexingOn = IsIndexingServiceOn();

            if (isIndexingOn && !wasIndexingOn)
            {
               // log that the indexing service was turned on
               CYS_APPEND_LOG(String::load(IDS_LOG_SHAREPOINT_INDEXING_ON));
            }
         }
         else if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND ||
                  HRESULT_CODE(hr) == ERROR_INSTALL_USEREXIT)
         {
            // Operation was cancelled by the user
            // We get ERROR_FILE_NOT_FOUND when the installation
            // source dialog is cancelled by the user

            LOG(String::format(
                   L"The install was cancelled: hr = 0x%1!x!",
                   hr));

            CYS_APPEND_LOG(String::load(IDS_LOG_WIZARD_CANCELLED));

            result = INSTALL_FAILURE;
         }
         else
         {
            // Log the failure

            static const maxMessageIDCount = 5;
            DWORD count = maxMessageIDCount;
            DWORD ids[maxMessageIDCount];
            ZeroMemory(ids, maxMessageIDCount * sizeof(ids));

            // Try to get the message IDs from the SharePoint COM object

            hr = GetSharePointObject()->SPGetMessageIDs(
                    &count,
                    ids);

            if (SUCCEEDED(hr))
            {
               // Write out a message for each of the IDs returned

               for (DWORD idx = 0; idx < count; ++idx)
               {
                  if (ids[idx] != 0)
                  {
                     CYS_APPEND_LOG(String::load(static_cast<unsigned>(ids[idx])));
                  }
               }
            }
            else
            {
               // Since we couldn't get a message from the COM object
               // write out a generic message

               CYS_APPEND_LOG(String::load(IDS_LOG_SHAREPOINT_INSTALL_FAILED));
               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_SHAREPOINT_INSTALL_ERROR),
                     message.c_str()));
            }

            result = INSTALL_FAILURE;
         }
      }
      else
      {
         LOG(L"IIS is not installed! Aborting SharePoint installation.");

         CYS_APPEND_LOG(String::load(IDS_LOG_SHAREPOINT_NO_IIS));
         result = INSTALL_FAILURE;
         break;
      }

   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
SharePointInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(SharePointInstallationUnit::IsServiceInstalled);

   bool result = false;

   do
   {
      // We should never get here on 64bit
      if (State::GetInstance().GetPlatform() & CYS_64BIT)
      {
         LOG(L"SharePoint cannot be installed on 64bit");

         result = false;
         break;
      }

      VARIANT_BOOL spInstalled;

      HRESULT hr = GetSharePointObject()->SPAlreadyInstalled(&spInstalled);
      if (SUCCEEDED(hr) && spInstalled)
      {
         result = true;
      }
      else if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to retrieve SPAlreadyInstalled: hr = %1!x!",
                hr));
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
SharePointInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(SharePointInstallationUnit::GetFinishText);

   bool installIIS = !InstallationUnitProvider::GetInstance().GetWebInstallationUnit().IsServiceInstalled();
   bool installSP = true;

   String installIISText = String::load(IDS_WEB_FINISH_TEXT);
   String installSPText = String::load(IDS_SHAREPOINT_FINISH_TEXT);
   String installSPAdminText = String::load(IDS_SHAREPOINT_FINISH_ADD_ADMIN);

   if (installIIS && installSP)
   {
      message += installIISText;
      message += installSPText;
      message += installSPAdminText;
   }
   else if (installSP && !installIIS)
   {
      message += installSPText;
      if (!ReplaceHomePage())
      {
         message += String::format(
                       String::load(IDS_SHAREPOINT_FINISH_WEBPAGE_FORMAT),
                       GetReplacementHomePage().c_str());
      }
      else
      {
         message += String::format(
                      String::load(IDS_SHAREPOINT_FINISH_CREATE_FORMAT),
                      GetReplacementHomePage().c_str());
      }

      message += installSPAdminText;
   }

   if (!IsIndexingServiceOn())
   {
      message += String::load(IDS_SHAREPOINT_FINISH_INDEXING);
   }

   LOG_BOOL(installSP);
   return installSP;
}

String
SharePointInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(SharePointInstallationUnit::GetServiceDescription);

   String result;

   result = String::load(IDS_SHAREPOINT_DESCRIPTION_BASE);

   if (IsServiceInstalled())
   {
      result += String::load(IDS_SHAREPOINT_DESCRIPTION_INSTALLED);
   }
   else
   {
      if (InstallationUnitProvider::GetInstance().GetWebInstallationUnit().IsServiceInstalled())
      {
         if (IsIndexingServiceOn())
         {
            result += String::load(IDS_SHAREPOINT_DESCRIPTION_SPONLY);
         }
         else
         {
            result += String::load(IDS_SHAREPOINT_DESCRIPTION_SP_AND_INDEXING);
         }
      }
      else
      {
         if (IsIndexingServiceOn())
         {
            result += String::load(IDS_SHAREPOINT_DESCRIPTION_SP_AND_IIS);
         }
         else
         {
            result += String::load(IDS_SHAREPOINT_DESCRIPTION_SP_INDEXING_IIS);
         }
      }
   }
   ASSERT(!result.empty());

   return result;
}


SmartInterface<ISpCys>&
SharePointInstallationUnit::GetSharePointObject()
{
   LOG_FUNCTION(SharePointInstallationUnit::GetSharePointObject);

   if (!sharePointObject)
   {
      HRESULT hr = sharePointObject.AcquireViaCreateInstance(
                      CLSID_SpCys,
                      0,
                      CLSCTX_INPROC_SERVER);

      ASSERT(SUCCEEDED(hr));
   }

   ASSERT(sharePointObject);

   return sharePointObject;
}

void
SharePointInstallationUnit::SetReplaceHomePage(bool replace)
{
   LOG_FUNCTION2(
      SharePointInstallationUnit::SetReplaceHomePage,
      replace ? L"true" : L"false");

   replaceHomepage = replace;
}

bool
SharePointInstallationUnit::IsThereAPageToReplace()
{
   LOG_FUNCTION(SharePointInstallationUnit::IsThereAPageToReplace);

   bool result = false;

   VARIANT_BOOL replace;
   HRESULT hr = GetSharePointObject()->SPAskReplace(&replace);
   if (SUCCEEDED(hr) && replace)
   {
      result = true;
   }

   LOG_BOOL(result);

   return result;
}

String
SharePointInstallationUnit::GetReplacementHomePage()
{
   LOG_FUNCTION(SharePointInstallationUnit::GetReplacementHomePage);

   if (nonDefaultHP.empty())
   {
      BSTR nonDefaultHomePage;
      HRESULT hr = GetSharePointObject()->SPNonDefaultHomePage(&nonDefaultHomePage);
   
      LOG(String::format(L"hr = %1!x!", hr));

      // ignore the return value and continue with a blank nonDefaultHomePage

      nonDefaultHP = nonDefaultHomePage;
      if (nonDefaultHomePage)
      {
         ::SysFreeString(nonDefaultHomePage);
      }
   }

   return nonDefaultHP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\sharepointinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      SharePointInstallationUnit.h
//
// Synopsis:  Declares a SharePointInstallationUnit
//            This object has the knowledge for installing the
//            SharePoint server
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_SHAREPOINTINSTALLATIONUNIT_H
#define __CYS_SHAREPOINTINSTALLATIONUNIT_H

#include "InstallationUnit.h"
#include "fpcyscom.h"

class SharePointInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      SharePointInstallationUnit();

      // Destructor

      virtual
      ~SharePointInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      virtual
      String
      GetServiceDescription();

      
      // Data accessors

      void
      SetReplaceHomePage(bool replace);

      bool
      ReplaceHomePage() { return replaceHomepage; }


      String
      GetReplacementHomePage();

      bool
      IsThereAPageToReplace();

   private:

      SmartInterface<ISpCys>&
      GetSharePointObject();

      SmartInterface<ISpCys> sharePointObject;

      bool replaceHomepage;
      String nonDefaultHP;
};

#endif // __CYS_SHAREPOINTINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\sharepointpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      SharePointPage.cpp
//
// Synopsis:  Defines the SharePoint page of the CYS wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "SharePointPage.h"
#include "state.h"

static PCWSTR SHAREPOINT_PAGE_HELP = L"cys.chm::/cys_configuring_sharepoint_server.htm";

SharePointPage::SharePointPage()
   :
   CYSWizardPage(
      IDD_SHARE_POINT_PAGE, 
      IDS_SHARE_POINT_TITLE, 
      IDS_SHARE_POINT_SUBTITLE,
      SHAREPOINT_PAGE_HELP)
{
   LOG_CTOR(SharePointPage);
}

   

SharePointPage::~SharePointPage()
{
   LOG_DTOR(SharePointPage);
}


void
SharePointPage::OnInit()
{
   LOG_FUNCTION(SharePointPage::OnInit);

   Win::Button_SetCheck(GetDlgItem(hwnd, IDC_YES_RADIO), BST_CHECKED);
}


bool
SharePointPage::OnSetActive()
{
   LOG_FUNCTION(SharePointPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
SharePointPage::Validate()
{
   LOG_FUNCTION(SharePointPage::Validate);

   int nextPage = -1;

   InstallationUnitProvider::GetInstance().GetSharePointInstallationUnit().SetReplaceHomePage(
      Win::Button_GetCheck(GetDlgItem(hwnd, IDC_YES_RADIO)));

   nextPage = IDD_FINISH_PAGE;

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\sharepointpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      SharePointPage.h
//
// Synopsis:  Declares the SharePoint page
//            for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_SHAREPOINTPAGE_H
#define __CYS_SHAREPOINTPAGE_H

#include "CYSWizardPage.h"


class SharePointPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      SharePointPage();

      // Destructor

      virtual 
      ~SharePointPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      SharePointPage(const SharePointPage&);
      const SharePointPage& operator=(const SharePointPage&);

};


#endif // __CYS_SHAREPOINTPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\spresource.h ===
// These resources define the values that will be returned from the SharePoint installation COM object
// These represent strings in resource.rc that are error messages specific to SharePoint installation
// Since these values are passed back to us we CANNOT CHANGE THESE VALUES or else we will be broken


// DO NOT CHANGE!!!!

#define IDS_SHAREPOINT_ERROR1           2000
#define IDS_SHAREPOINT_ERROR2           2001

// DO NOT CHANGE!!!!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\state.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      state.h
//
// Synopsis:  Declares the state object that is global
//            to CYS.  It holds the network and OS/SKU info
//
// History:   02/02/2001  JeffJon Created

#ifndef __CYS_STATE_H
#define __CYS_STATE_H


#include "NetworkAdapterConfig.h"



#define CYS_DATACENTER_SERVER     0x00000001
#define CYS_ADVANCED_SERVER       0x00000002
#define CYS_SERVER                0x00000004
#define CYS_PERSONAL              0x00000008
#define CYS_PROFESSIONAL          0x00000010
#define CYS_64BIT                 0x80000000
#define CYS_32BIT                 0x40000000

#define CYS_ALL_SERVER_SKUS       (CYS_DATACENTER_SERVER |  \
                                   CYS_ADVANCED_SERVER   |  \
                                   CYS_SERVER            |  \
                                   CYS_64BIT             |  \
                                   CYS_32BIT)

#define CYS_ALL_SKUS_NO_64BIT     (CYS_DATACENTER_SERVER |  \
                                   CYS_ADVANCED_SERVER   |  \
                                   CYS_SERVER            |  \
                                   CYS_32BIT)

class State
{
   public:

      // Called from WinMain to delete the global instance of the state object

      static
      void
      Destroy();

      // Retrieves a reference to the global instance of the state object

      static
      State&
      GetInstance();

      // Does the work to determine the state of the machine

      bool
      RetrieveMachineConfigurationInformation(HWND hwndParent);


      // Data accessors

      int 
      GetNICCount() const;

      NetworkInterface
      GetNIC(unsigned int nicIndex);


      bool
      IsDC() const;

      bool
      IsDCPromoRunning() const;

      bool
      IsDCPromoPendingReboot() const;

      bool
      IsUpgradeState() const;

      bool
      IsFirstDC() const;

      bool
      IsDHCPServerAvailable() const { return dhcpServerAvailable; }

      bool 
      HasStateBeenRetrieved() const { return hasStateBeenRetrieved; }

      bool 
      RerunWizard() const { return rerunWizard; }

      void 
      SetRerunWizard(bool rerun);

      DWORD 
      GetProductSKU() const { return productSKU; }

      DWORD
      GetPlatform() const { return platform; }

      bool 
      HasNTFSDrive() const;


      bool 
      SetHomeRegkey(const String& newKeyValue);

      bool
      GetHomeRegkey(String& newKeyValue) const;

      String
      GetComputerName();

   private:

      // Determines if there is a DHCP server on the network

      void
      CheckDhcpServer();

      HRESULT
      RetrieveNICInformation();

      void
      RetrieveProductSKU();

      void
      RetrievePlatform();

      void
      RetrieveDriveInformation();

      bool     hasStateBeenRetrieved;
      bool     dhcpAvailabilityRetrieved;

      bool     dhcpServerAvailable;
      bool     rerunWizard;
      bool     hasNTFSDrive;
      DWORD    productSKU;
      DWORD    platform;

      String   computerName;

      NetworkAdapterConfig adapterConfiguration;

      // Constructor

      State();

      // not defined: no copying allowed
      State(const State&);
      const State& operator=(const State&);
      
};
#endif // __CYS_STATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\terminalserverpage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      TerminalServerPage.cpp
//
// Synopsis:  Defines the Terminal server page of the CYS wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "TerminalServerPage.h"
#include "state.h"

static PCWSTR TERMINALSERVER_PAGE_HELP = L"cys.chm::/cys_configuring_application_server.htm";

TerminalServerPage::TerminalServerPage()
   :
   CYSWizardPage(
      IDD_TERMINAL_SERVER_PAGE, 
      IDS_TERMINAL_SERVER_TITLE, 
      IDS_TERMINAL_SERVER_SUBTITLE,
      TERMINALSERVER_PAGE_HELP)
{
   LOG_CTOR(TerminalServerPage);
}

   

TerminalServerPage::~TerminalServerPage()
{
   LOG_DTOR(TerminalServerPage);
}


void
TerminalServerPage::OnInit()
{
   LOG_FUNCTION(TerminalServerPage::OnInit);

   Win::Button_SetCheck(GetDlgItem(hwnd, IDC_NO_RADIO), BST_CHECKED);
}


bool
TerminalServerPage::OnSetActive()
{
   LOG_FUNCTION(TerminalServerPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
TerminalServerPage::Validate()
{
   LOG_FUNCTION(TerminalServerPage::Validate);

   int nextPage = -1;

   InstallationUnitProvider::GetInstance().GetApplicationInstallationUnit().SetInstallTS(
      Win::Button_GetCheck(GetDlgItem(hwnd, IDC_YES_RADIO)));

   nextPage = IDD_FINISH_PAGE;

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\terminalserverpage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      TerminalServerPage.h
//
// Synopsis:  Declares the Terminal Server page
//            for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_TERMINALSERVERPAGE_H
#define __CYS_TERMINALSERVERPAGE_H

#include "CYSWizardPage.h"


class TerminalServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      TerminalServerPage();

      // Destructor

      virtual 
      ~TerminalServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      TerminalServerPage(const TerminalServerPage&);
      const TerminalServerPage& operator=(const TerminalServerPage&);

};


#endif // __CYS_TERMINALSERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\welcomepage.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      WelcomePage.h
//
// Synopsis:  Declares the Welcome Page for the CYS
//            wizard
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_WELCOMEPAGE_H
#define __CYS_WELCOMEPAGE_H

#include "CYSWizardPage.h"


class WelcomePage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      WelcomePage();

      // Destructor

      virtual 
      ~WelcomePage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      virtual
      int
      Validate();


      void
      TerminalServerPostBoot(bool installed = true);

      void
      FirstServerPostBoot();

      void
      DCPromoPostBoot();

   private:

      // not defined: no copying allowed
      WelcomePage(const WelcomePage&);
      const WelcomePage& operator=(const WelcomePage&);

};

#endif // __CYS_WELCOMEPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\webinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      WebInstallationUnit.h
//
// Synopsis:  Declares a WebInstallationUnit
//            This object has the knowledge for installing the
//            IIS service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_WEBINSTALLATIONUNIT_H
#define __CYS_WEBINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class WebInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      WebInstallationUnit();

      // Destructor

      virtual
      ~WebInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

      virtual
      String
      GetServiceDescription();
};

#endif // __CYS_WEBINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\welcomepage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      WelcomePage.cpp
//
// Synopsis:  Defines Welcome Page for the CYS
//            Wizard
//
// History:   02/03/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "WelcomePage.h"
#include "state.h"
#include "Dialogs.h"

static PCWSTR WELCOME_PAGE_HELP = L"cys.chm::/cys_topnode.htm";

WelcomePage::WelcomePage()
   :
   CYSWizardPage(
      IDD_WELCOME_PAGE, 
      IDS_WELCOME_TITLE, 
      IDS_WELCOME_SUBTITLE, 
      WELCOME_PAGE_HELP, 
      true, 
      false)
{
   LOG_CTOR(WelcomePage);
}

   

WelcomePage::~WelcomePage()
{
   LOG_DTOR(WelcomePage);
}


void
WelcomePage::OnInit()
{
   LOG_FUNCTION(WelcomePage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),     
      0,
      String::load(IDS_WIZARD_TITLE));

   // Check to see if we are in a reboot scenario

   String homeKeyValue;
   if (State::GetInstance().GetHomeRegkey(homeKeyValue))
   {
      if (homeKeyValue.icompare(CYS_HOME_REGKEY_TERMINAL_SERVER_VALUE) == 0)
      {
         TerminalServerPostBoot();
      }
      else if (homeKeyValue.icompare(CYS_HOME_REGKEY_TERMINAL_SERVER_OPTIMIZED) == 0)
      {
         TerminalServerPostBoot(false);
      }
      else if (homeKeyValue.icompare(CYS_HOME_REGKEY_FIRST_SERVER_VALUE) == 0)
      {
         FirstServerPostBoot();
      }
      else if (homeKeyValue.icompare(CYS_HOME_REGKEY_DCPROMO_VALUE) == 0)
      {
         DCPromoPostBoot();
      }

      // Now set the home regkey back to "home" so that we won't run
      // through these again

      if (homeKeyValue.icompare(CYS_HOME_REGKEY_DEFAULT_VALUE) != 0)
      {
         bool result = 
            State::GetInstance().SetHomeRegkey(CYS_HOME_REGKEY_DEFAULT_VALUE);

         ASSERT(result);
      }

      // Reset the must run key now that we have done the reboot stuff

      bool regkeyResult = SetRegKeyValue(
                             CYS_HOME_REGKEY, 
                             CYS_HOME_REGKEY_MUST_RUN, 
                             CYS_HOME_RUN_KEY_DONT_RUN,
                             HKEY_LOCAL_MACHINE,
                             true);
      ASSERT(regkeyResult);
   }

}


void
WelcomePage::TerminalServerPostBoot(bool installed)
{
   LOG_FUNCTION(WelcomePage::TerminalServerPostBoot);

   // Create the log file

   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
   }

   // Prepare the finish dialog

   FinishDialog dialog(
      logName,
      InstallationUnitProvider::GetInstance().GetApplicationInstallationUnit().GetFinishHelp());

   if (installed)
   {
      if (InstallationUnitProvider::GetInstance().GetApplicationInstallationUnit().GetApplicationMode() == 1)
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_APP_REBOOT_SUCCESS));

         // Prompt the user to show help or log file

         dialog.ModalExecute(hwnd);
      }
      else
      {
         // Failed to install TS

         CYS_APPEND_LOG(String::load(IDS_LOG_APP_REBOOT_FAILED));

         dialog.OpenLogFile();
      }
   }
   else
   {
      // Since all we did is optimize we should always be successful on reboot

      dialog.ModalExecute(hwnd);
   }
}


void
WelcomePage::FirstServerPostBoot()
{
   LOG_FUNCTION(WelcomePage::FirstServerPostBoot);

   // Create the log file

   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
   }

   // Verify the machine is a DC

   do
   {
      if (State::GetInstance().IsDC())
      {
         // Authorize the new DHCP scope
         String dnsName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

         if (InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().AuthorizeDHCPScope(dnsName))
         {
            LOG(L"DHCP scope successfully authorized");

            CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_AUTHORIZATION_SUCCEEDED));
         }
         else
         {
            LOG(L"DHCP scope authorization failed");

            String failureMessage = String::load(IDS_LOG_DHCP_AUTHORIZATION_FAILED);
            CYS_APPEND_LOG(failureMessage);

            Win::MessageBox(
               hwnd,
               failureMessage,
               String::load(IDS_WIZARD_TITLE),
               MB_OK);
         }


         // Do TAPI config 

         if (State::GetInstance().IsFirstDC())
         {
      
            HRESULT hr = 
               InstallationUnitProvider::GetInstance().GetExpressInstallationUnit().DoTapiConfig(dnsName);
            if (SUCCEEDED(hr))
            {
               LOG(L"TAPI config succeeded");

               CYS_APPEND_LOG(String::load(IDS_LOG_TAPI_CONFIG_SUCCEEDED));
               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_TAPI_CONFIG_SUCCEEDED_FORMAT),
                     dnsName.c_str()));
            }
            else
            {
               LOG(L"TAPI config failed");

               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_TAPI_CONFIG_FAILED_FORMAT),
                     hr));
            }
         }

         // Show dialog that lets the user open help or the log file
      }
      else
      {
         LOG(L"DCPromo failed on reboot");

         CYS_APPEND_LOG(String::load(IDS_LOG_DCPROMO_REBOOT_FAILED));
         break;
      }
   } while (false);
}

void
WelcomePage::DCPromoPostBoot()
{
   LOG_FUNCTION(WelcomePage::DCPromoPostBoot);

   // Create the log file

   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
      ASSERT(false);
   }

   // Prepare the finish dialog

   FinishDialog dialog(
      logName,
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetFinishHelp());


   CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_HEADING));
   CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_INSTALL));

   if (State::GetInstance().IsDC())
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_SUCCESS));

      // Show the log/help dialog

      dialog.ModalExecute(hwnd);
   }
   else
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_FAILED));

      // just open the log

      dialog.OpenLogFile();
   }
}

bool
WelcomePage::OnSetActive()
{
   LOG_FUNCTION(WelcomePage::OnSetActive);

   // Only Next and Cancel are available from the Welcome page

   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_NEXT);

   return true;
}


int
WelcomePage::Validate()
{
   LOG_FUNCTION(WelcomePage::Validate);

   // For now, just initialize the state object and then
   // go directly to the custom server page.  Eventually
   // we will figure out what we want express path to do
   // and then we will have to delay retrieving machine
   // info and go to the BeforeBeginPage.

   // Gather the machine network and role information

   State& state = State::GetInstance();

   if (!state.HasStateBeenRetrieved())
   {
      if (!state.RetrieveMachineConfigurationInformation(hwnd))
      {
         ASSERT(false);
         LOG(L"The machine configuration could not be retrieved.");
         return -1;
      }
   }

   int nextPage = IDD_CUSTOM_SERVER_PAGE;
   
   do 
   {
      if (state.GetNICCount() != 1)
      {
         LOG(String::format(
                L"GetNICCount() = %1!d!",
                state.GetNICCount()));
         break;
      }

      if (state.IsDC())
      {
         LOG(L"Computer is DC");
         break;
      }

      if (InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().IsServiceInstalled())
      {
         LOG(L"Computer is DNS server");
         break;
      }

      if (InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().IsServiceInstalled())
      {
         LOG(L"Computer is DHCP server");
         break;
      }

      if (state.IsDHCPServerAvailable())
      {
         LOG(L"DHCP server found on the network");
         break;
      }

      nextPage = IDD_DECISION_PAGE;

   } while (false);

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\state.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      state.cpp
//
// Synopsis:  Defines the state object that is global
//            to CYS.  It holds the network and OS/SKU info
//
// History:   02/02/2001  JeffJon Created

#include "pch.h"

#include "state.h"


static State* stateInstance = 0;


State::State() :
   dhcpServerAvailable(false),
   dhcpAvailabilityRetrieved(false),
   hasStateBeenRetrieved(false),
   rerunWizard(true),
   productSKU(CYS_SERVER),
   hasNTFSDrive(false),
   computerName()
{
   LOG_CTOR(State);
}


void
State::Destroy()
{
   LOG_FUNCTION(State::Destroy);

   if (stateInstance)
   {
      delete stateInstance;
      stateInstance = 0;
   }
}


State&
State::GetInstance()
{
   if (!stateInstance)
   {
      stateInstance = new State();
   }

   ASSERT(stateInstance);

   return *stateInstance;
}

bool
State::IsDC() const
{
   LOG_FUNCTION(State::IsDC);

   bool result = false;

   do
   {
      DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
      HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
      if(FAILED(hr))
      {
         LOG(String::format(
                L"Failed MyDsRoleGetPrimaryDomainInformation(0): hr = 0x%1!x!",
                hr));

         break;
      }

      if (info && 
          (info->MachineRole == DsRole_RolePrimaryDomainController ||
           info->MachineRole == DsRole_RoleBackupDomainController) )
      {
         result = true;
      }

      ::DsRoleFreeMemory(info);
   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
State::IsDCPromoRunning() const
{
   LOG_FUNCTION(State::IsDCPromoRunning);

   // Uses the IsDcpromoRunning from Burnslib

   bool result = IsDcpromoRunning();

   LOG_BOOL(result);

   return result;
}

bool
State::IsDCPromoPendingReboot() const
{
   LOG_FUNCTION(State::IsDCPromoPendingReboot);

   bool result = false;

   do
   {
      // Uses the IsDcpromoRunning from Burnslib

      if (!IsDcpromoRunning())
      {
         // this test is redundant if dcpromo is running, so only
         // perform it when dcpromo is not running.

         DSROLE_OPERATION_STATE_INFO* info = 0;
         HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
         if (SUCCEEDED(hr) && info)
         {
            if (info->OperationState == DsRoleOperationNeedReboot)
            {
               result = true;
            }

            ::DsRoleFreeMemory(info);
         }
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
State::IsUpgradeState() const
{
   LOG_FUNCTION(State::IsUpgradeState);

   bool result = false;

   do
   {
      DSROLE_UPGRADE_STATUS_INFO* info = 0;
      HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"MyDsRoleGetPrimaryDomainInformation(0): hr = 0x%1!x!",
                hr));

         break;
      }

      if (info && info->OperationState == DSROLE_UPGRADE_IN_PROGRESS)
      {
         result = true;
      }

      ::DsRoleFreeMemory(info);
   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
State::IsFirstDC() const
{
   LOG_FUNCTION(State::IsFirstDC);

   DWORD value = 0;
   bool result = GetRegKeyValue(CYS_FIRST_DC_REGKEY, CYS_FIRST_DC_VALUE, value);
   
   if (value != 1)
   {
      result = false;
   }

   LOG_BOOL(result);

   return result;
}

int 
State::GetNICCount() const 
{ 
   return adapterConfiguration.GetNICCount(); 
}

NetworkInterface
State::GetNIC(unsigned int nicIndex)
{
   LOG_FUNCTION2(
      State::GetNIC,
      String::format(
         L"%1!d!",
         nicIndex));

   return adapterConfiguration.GetNIC(nicIndex);
}

bool
State::RetrieveMachineConfigurationInformation(HWND /*hwndParent*/)
{
   LOG_FUNCTION(State::RetrieveMachineConfigurationInformation);

   ASSERT(!hasStateBeenRetrieved);

   // For now I will make this a synchronous action.  
   // We should have some sort of fancy UI that lets 
   // the user know we are progressing
   Win::WaitCursor cursor;

   // This is used to get the minimal information needed to 
   // determine if we should enable the express path
   // This should probably just be changed to gather the 
   // information and let the page decide what to do

   HRESULT hr = RetrieveNICInformation();
   if (SUCCEEDED(hr))
   {

      // Only bother to check for a DHCP server on the network if we are not
      // a DC and only have one NIC.  Right now we only use this info
      // for determining whether or not to show the Express path option

      if (!(IsDC() || IsUpgradeState()) &&
          (GetNICCount() == 1))
      {
         CheckDhcpServer();
      }
   }

   RetrieveProductSKU();
   RetrievePlatform();

   // Retrieve the drive information (quotas enabled, partition types, etc.)

   RetrieveDriveInformation();

   hasStateBeenRetrieved = true;
   return true;
}

void
State::RetrieveProductSKU()
{
   LOG_FUNCTION(State::RetrieveProductSKU);

   // I am making the assumption that we are on a 
   // Server SKU if GetVersionEx fails

   productSKU = CYS_SERVER;

   OSVERSIONINFOEX info;
   HRESULT hr = Win::GetVersionEx(info);
   if (SUCCEEDED(hr))
   {
      do
      {
         if (info.wSuiteMask & VER_SUITE_DATACENTER)
         {
            // datacenter
      
            productSKU = CYS_DATACENTER_SERVER;
            break;
         }
         if (info.wSuiteMask & VER_SUITE_ENTERPRISE)
         {
            // advanced server
      
            productSKU = CYS_ADVANCED_SERVER;
            break;
         }
         if (info.wSuiteMask & VER_SUITE_PERSONAL)
         {
            // personal
      
            productSKU = CYS_PERSONAL;
            break;
         }
         if (info.wProductType == VER_NT_WORKSTATION)
         {
            // profesional
      
            productSKU = CYS_PROFESSIONAL;
         }
         else
         {
            // server
      
            productSKU = CYS_SERVER;
         }
      } while (false);
   }
   LOG(String::format(L"Product SKU = 0x%1!x!", productSKU ));

   return;
}

void
State::RetrievePlatform()
{
   LOG_FUNCTION(State::RetrievePlatform);

   // I am making the assumption that we are not on a 
   // 64bit machine if GetSystemInfo fails

   SYSTEM_INFO info;
   Win::GetSystemInfo(info);

   switch (info.wProcessorArchitecture)
   {
      case PROCESSOR_ARCHITECTURE_IA64:
      case PROCESSOR_ARCHITECTURE_ALPHA64:
      case PROCESSOR_ARCHITECTURE_AMD64:
         platform = CYS_64BIT;
         break;

      default:
         platform = CYS_32BIT;
         break;
   }

   LOG(String::format(L"Platform = 0x%1!x!", platform));

   return;
}

HRESULT
State::RetrieveNICInformation()
{
   ASSERT(!hasStateBeenRetrieved);

   HRESULT hr = S_OK;

   if (!adapterConfiguration.IsInitialized())
   {
      hr = adapterConfiguration.Initialize();
   }

   LOG_HRESULT(hr);

   return hr;
}

void
State::CheckDhcpServer()
{
   LOG_FUNCTION(State::CheckDhcpServer);

   // This should loop through all network interfaces
   // seeing if we can obtain a lease on any of them


   if (GetNICCount() > 0)
   {
      DWORD nicIPAddress = GetNIC(0).GetIPAddress(0);

      // force to bool
      dhcpServerAvailable = (IsDHCPAvailableOnInterface(nicIPAddress) != 0);
   }
   dhcpAvailabilityRetrieved = true;

   LOG_BOOL(dhcpServerAvailable);
}


bool
State::HasNTFSDrive() const
{
   LOG_FUNCTION(State::HasNTFSDrive);

   return hasNTFSDrive;
}

void
State::RetrieveDriveInformation()
{
   LOG_FUNCTION(State::RetrieveDriveInformation);

   do
   {
      // Get a list of the valid drives

      StringVector dl;
      HRESULT hr = FS::GetValidDrives(std::back_inserter(dl));
      if (FAILED(hr))
      {
         LOG(String::format(L"Failed to GetValidDrives: hr = %1!x!", hr));
         break;
      }

      // Loop through the list

      ASSERT(dl.size());
      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         // look for the NTFS partition

         FS::FSType fsType = FS::GetFileSystemType(*i);
         if (fsType == FS::NTFS5 ||
             fsType == FS::NTFS4)
         {
            // found one.  good to go

            LOG(String::format(L"%1 is NTFS", i->c_str()));

            hasNTFSDrive = true;
            break;
         }
      }
   } while (false);

   LOG_BOOL(hasNTFSDrive);

   return;
}


void
State::SetRerunWizard(bool rerun)
{
   LOG_FUNCTION2(
      State::SetRerunWizard,
      rerun ? L"true" : L"false");

   rerunWizard = rerun;
}


bool
State::SetHomeRegkey(const String& newKeyValue)
{
   LOG_FUNCTION2(
      State::SetHomeRegkey,
      newKeyValue);

   bool result = SetRegKeyValue(
                    CYS_HOME_REGKEY,
                    CYS_HOME_VALUE,
                    newKeyValue,
                    HKEY_LOCAL_MACHINE,
                    true);
   ASSERT(result);

   LOG_BOOL(result);

   return result;
}

bool
State::GetHomeRegkey(String& keyValue) const
{
   LOG_FUNCTION(State::GetHomeRegkey);

   bool result = GetRegKeyValue(
                    CYS_HOME_REGKEY,
                    CYS_HOME_VALUE,
                    keyValue);

   LOG_BOOL(result);

   return result;
}

String
State::GetComputerName()
{
   LOG_FUNCTION(State::GetComputerName);

   if (computerName.empty())
   {
      computerName = Win::GetComputerNameEx(ComputerNameDnsHostname);
   }

   LOG(computerName);
   return computerName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\webinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      WebInstallationUnit.cpp
//
// Synopsis:  Defines a WebInstallationUnit
//            This object has the knowledge for installing the
//            IIS service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "WebInstallationUnit.h"

// Finish page help 
static PCWSTR CYS_WEB_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_streaming_media_server.htm";


WebInstallationUnit::WebInstallationUnit() :
   InstallationUnit(
      IDS_WEB_SERVER_TYPE, 
      IDS_WEB_SERVER_DESCRIPTION, 
      CYS_WEB_FINISH_PAGE_HELP,
      WEBSERVER_INSTALL)
{
   LOG_CTOR(WebInstallationUnit);
}


WebInstallationUnit::~WebInstallationUnit()
{
   LOG_DTOR(WebInstallationUnit);
}


InstallationReturnType
WebInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(WebInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Log heading
   CYS_APPEND_LOG(String::load(IDS_LOG_WEB_HEADING));

   String unattendFileText;
   String infFileText;

   unattendFileText += L"[Components]\n";
   unattendFileText += L"iis_common=ON\n";
   unattendFileText += L"iis_inetmgr=ON\n";
   unattendFileText += L"iis_www=ON\n";
   unattendFileText += L"iis_doc=ON\n";
   unattendFileText += L"iis_htmla=ON\n";
   unattendFileText += L"iis_www_vdir_msadc=ON\n";
   unattendFileText += L"iis_www_vdir_scripts=ON\n";
   unattendFileText += L"iis_www_vdir_printers=ON\n";
   unattendFileText += L"iis_smtp=ON\n";
   unattendFileText += L"iis_smtp_docs=ON\n";
   unattendFileText += L"fp_extensions=ON\n";

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      LOG(L"IIS was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_INSTALL_IIS_SUCCESS));
   }
   else
   {
      LOG(L"IIS was failed to install");
      CYS_APPEND_LOG(String::load(IDS_LOG_INSTALL_IIS_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
WebInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(WebInstallationUnit::IsServiceInstalled);

   bool result = IsServiceInstalledHelper(CYS_WEB_SERVICE_NAME);
   LOG_BOOL(result);

   return result;
}

bool
WebInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(WebInstallationUnit::GetFinishText);

   message = String::load(IDS_WEB_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}


String
WebInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(WebInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (IsServiceInstalled())
   {
      resourceID = IDS_WEB_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\winsinstallationunit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      WINSInstallationUnit.h
//
// Synopsis:  Declares a WINSInstallationUnit
//            This object has the knowledge for installing the
//            WINS service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_WINSINSTALLATIONUNIT_H
#define __CYS_WINSINSTALLATIONUNIT_H

#include "NetworkServiceInstallationBase.h"

class WINSInstallationUnit : public NetworkServiceInstallationBase
{
   public:
      
      // Constructor

      WINSInstallationUnit();

      // Destructor

      virtual
      ~WINSInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetFinishText(String& message);

};

#endif // __CYS_WINSINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dhcp\dhcpwiz.cpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// launches dhcp wizard from the dhcp snapin using mmc automation



#include "headers.hxx"
#include "resource.h"
#include "smartptr.hpp"
#include "misc.hpp"



HINSTANCE hResourceModuleHandle = 0;



HRESULT
getContextMenu(const SmartInterface<View>& view, ContextMenu** dumbMenu)
{
   HRESULT hr = S_OK;

   _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
   hr = view->get_ScopeNodeContextMenu(missingParam2, dumbMenu);

   return hr;
}



HRESULT
doIt()
{
   HRESULT hr = S_OK;

   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr, L"CoInitialize failed.");

      SmartInterface<_Application> app(0);
      hr =
         app.AcquireViaCreateInstance(
            CLSID_Application,
            0,

            // we expect the object is out-of-proc, local server, but
            // we really don't care, so we'll take any implementation
            // available.

            CLSCTX_ALL);
      BREAK_ON_FAILED_HRESULT(hr, L"CoCreateInstance failed.");

      SmartInterface<Document> doc(0);
      Document* dumbDoc = 0;
      hr = app->get_Document(&dumbDoc);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Document failed.");
      doc.Acquire(dumbDoc);

      SmartInterface<SnapIns> snapIns(0);
      SnapIns* dumbSnapIns = 0;
      hr = doc->get_SnapIns(&dumbSnapIns);
      BREAK_ON_FAILED_HRESULT(hr, L"get_SnapIns failed.");
      snapIns.Acquire(dumbSnapIns);

      static const wchar_t* DHCP_SNAPIN_CLSID =
         L"{90901AF6-7A31-11D0-97E0-00C04FC3357A}";

      SmartInterface<SnapIn> snapIn(0);
      SnapIn* dumbSnapIn = 0;
      _variant_t missingParam(DISP_E_PARAMNOTFOUND, VT_ERROR);
      _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
      hr =
         snapIns->Add(AutoBstr(DHCP_SNAPIN_CLSID), missingParam, missingParam2, &dumbSnapIn);
      BREAK_ON_FAILED_HRESULT(hr, L"SnapIns::Add failed.  Is DHCP installed?");
      snapIn.Acquire(dumbSnapIn);

      SmartInterface<Views> views(0);
      Views* dumbViews = 0;
      hr = doc->get_Views(&dumbViews);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Views failed.");
      views.Acquire(dumbViews);

      SmartInterface<View> view(0);
      View* dumbView = 0;
      hr = views->Item(1, &dumbView);
      BREAK_ON_FAILED_HRESULT(hr, L"Views::Item failed.");
      view.Acquire(dumbView);

      SmartInterface<ScopeNamespace> sn(0);
      ScopeNamespace* dumbSn = 0;
      hr = doc->get_ScopeNamespace(&dumbSn);
      BREAK_ON_FAILED_HRESULT(hr, L"get_ScopeNamespace failed.");
      sn.Acquire(dumbSn);

      SmartInterface<Node> rootnode(0);
      Node* dumbNode = 0;
      hr = sn->GetRoot(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetRoot failed.");
      rootnode.Acquire(dumbNode);

      SmartInterface<Node> child1(0);
      hr = sn->GetChild(rootnode, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child1.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child1);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child1 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> child2(0);
      hr = sn->GetChild(child1, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child2.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child2);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // excute new scope wizard menu item
      _variant_t missingParam3(DISP_E_PARAMNOTFOUND, VT_ERROR);

      hr = view->ExecuteScopeNodeMenuItem((BSTR)AutoBstr(L"_CREATE_NEW_SCOPE"), missingParam3);
      BREAK_ON_FAILED_HRESULT(hr, L"ExecuteScopeNodeMenuItem _CREATE_NEW_SCOPE failed");

      hr = doc->Close(FALSE);
      BREAK_ON_FAILED_HRESULT(hr, L"Close failed.");
   }
   while (0);

   return hr;
}



int WINAPI
WinMain(
   HINSTANCE   hInstance, 
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR       /* lpszCmdLine */ ,
   int         /* nCmdShow */ )
{
   hResourceModuleHandle = hInstance;

   int exitCode = static_cast<int>(doIt());

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\win32\winsinstallationunit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation
//
// File:      WINSInstallationUnit.cpp
//
// Synopsis:  Defines a WINSInstallationUnit
//            This object has the knowledge for installing the
//            WINS service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "WINSInstallationUnit.h"



WINSInstallationUnit::WINSInstallationUnit() :
   NetworkServiceInstallationBase(
      IDS_WINS_SERVER_TYPE, 
      IDS_WINS_SERVER_DESCRIPTION, 
      IDS_WINS_SERVER_DESCRIPTION_INSTALLED,
      WINS_INSTALL)
{
   LOG_CTOR(WINSInstallationUnit);
}


WINSInstallationUnit::~WINSInstallationUnit()
{
   LOG_DTOR(WINSInstallationUnit);
}


InstallationReturnType
WINSInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(WINSInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Create the inf and unattend files that are used by the 
   // Optional Component Manager

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_WINS_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_WINS_SERVICE_NAME);

   // Install the service through the Optional Component Manager

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      // Log the successful installation

      LOG(L"WINS was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_INSTALL_WINS_SUCCESS));

   }
   else
   {
      // Log the failure

      LOG(L"WINS failed to install");

      CYS_APPEND_LOG(String::load(IDS_LOG_WINS_INSTALL_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
WINSInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(WINSInstallationUnit::IsServiceInstalled);

   bool result = IsServiceInstalledHelper(CYS_WINS_SERVICE_NAME);

   LOG_BOOL(result);
   return result;
}

bool
WINSInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(WINSInstallationUnit::GetFinishText);

   message = String::load(IDS_WINS_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dhcp\misc.hpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// random other stuff



#ifndef MISC_HPP_INCLUDED
#define MISC_HPP_INCLUDED



void
logMessage(const wchar_t* msg)
{
   if (msg)
   {
      ::OutputDebugString(L"dhcpwiz: ");
      ::OutputDebugString(msg);
      ::OutputDebugString(L"\n");
   }
}



void
logHresult(HRESULT hr)
{                                                              
   wchar_t buf[1024];                                          
   wsprintf(buf, L"HRESULT = 0x%08X\n", (hr));                 
   logMessage(buf);                               
}                                                              



#ifdef DBG

#define LOG_HRESULT(hr)    logHresult(hr)
#define LOG_MESSAGE(msg)   logMessage(msg)

#else

#define LOG_HRESULT(hr)
#define LOG_MESSAGE(msg)

#endif DBG



#define BREAK_ON_FAILED_HRESULT(hr,msg)                           \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_MESSAGE(msg);                                           \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};


#endif   // MISC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dhcp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dns\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\rras\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dns\misc.hpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// random other stuff



#ifndef MISC_HPP_INCLUDED
#define MISC_HPP_INCLUDED



void
logMessage(const wchar_t* msg)
{
   if (msg)
   {
      ::OutputDebugString(L"dnswiz: ");
      ::OutputDebugString(msg);
      ::OutputDebugString(L"\n");
   }
}



void
logHresult(HRESULT hr)
{                                                              
   wchar_t buf[1024];                                          
   wsprintf(buf, L"HRESULT = 0x%08X\n", (hr));                 
   logMessage(buf);                               
}                                                              



#ifdef DBG

#define LOG_HRESULT(hr)    logHresult(hr)
#define LOG_MESSAGE(msg)   logMessage(msg)

#else

#define LOG_HRESULT(hr)
#define LOG_MESSAGE(msg)

#endif DBG



#define BREAK_ON_FAILED_HRESULT(hr,msg)                           \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_MESSAGE(msg);                                           \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};


#endif   // MISC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dhcp\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// copied from admin\burnslib\inc\smartptr.hpp



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface() : ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)
   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      ASSERT(SUCCEEDED(hr));

      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



   private:

   T* ptr;
};



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dns\dnswiz.cpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// launches dns wizard from the dhcp snapin using mmc automation



#include "headers.hxx"
#include "resource.h"
#include "smartptr.hpp"
#include "misc.hpp"

//
// This is the language independent menu ID of the Configure a DNS Wizard
//
#define DNS_CONFIGE_WIZARD_MENU_ID L"_DNS_CONFIGURETOP"

HINSTANCE hResourceModuleHandle = 0;



HRESULT
getContextMenu(const SmartInterface<View>& view, ContextMenu** dumbMenu)
{
   HRESULT hr = S_OK;

   _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
   hr = view->get_ScopeNodeContextMenu(missingParam2, dumbMenu);

   return hr;
}


HRESULT
doIt()
{
   HRESULT hr = S_OK;

   SmartInterface<Document> doc(0);
   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr, L"CoInitialize failed.");

      SmartInterface<_Application> app(0);
      hr =
         app.AcquireViaCreateInstance(
            CLSID_Application,
            0,

            // we expect the object is out-of-proc, local server, but
            // we really don't care, so we'll take any implementation
            // available.

            CLSCTX_ALL);
      BREAK_ON_FAILED_HRESULT(hr, L"CoCreateInstance failed.");

      Document* dumbDoc = 0;
      hr = app->get_Document(&dumbDoc);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Document failed.");
      doc.Acquire(dumbDoc);

      SmartInterface<SnapIns> snapIns(0);
      SnapIns* dumbSnapIns = 0;
      hr = doc->get_SnapIns(&dumbSnapIns);
      BREAK_ON_FAILED_HRESULT(hr, L"get_SnapIns failed.");
      snapIns.Acquire(dumbSnapIns);

      static const wchar_t* DNS_SNAPIN_CLSID =
         L"{2FAEBFA2-3F1A-11D0-8C65-00C04FD8FECB}";

      SmartInterface<SnapIn> snapIn(0);
      SnapIn* dumbSnapIn = 0;
      _variant_t missingParam(DISP_E_PARAMNOTFOUND, VT_ERROR);
      _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
      hr =
         snapIns->Add(AutoBstr(DNS_SNAPIN_CLSID), missingParam, missingParam2, &dumbSnapIn);
      BREAK_ON_FAILED_HRESULT(hr, L"SnapIns::Add failed.  Is DNS installed?");
      snapIn.Acquire(dumbSnapIn);

      SmartInterface<Views> views(0);
      Views* dumbViews = 0;
      hr = doc->get_Views(&dumbViews);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Views failed.");
      views.Acquire(dumbViews);

      SmartInterface<View> view(0);
      View* dumbView = 0;
      hr = views->Item(1, &dumbView);
      BREAK_ON_FAILED_HRESULT(hr, L"Views::Item failed.");
      view.Acquire(dumbView);

      // navigate thru the scope node namespace to find the node
      // for the computer

      SmartInterface<ScopeNamespace> sn(0);
      ScopeNamespace* dumbSn = 0;
      hr = doc->get_ScopeNamespace(&dumbSn);
      BREAK_ON_FAILED_HRESULT(hr, L"get_ScopeNamespace failed.");
      sn.Acquire(dumbSn);

      SmartInterface<Node> rootnode(0);
      Node* dumbNode = 0;
      hr = sn->GetRoot(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetRoot failed.");
      rootnode.Acquire(dumbNode);

      SmartInterface<Node> child1(0);
      hr = sn->GetChild(rootnode, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child1.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child1);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child1 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> child2(0);
      hr = sn->GetChild(child1, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child2.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child2);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      _variant_t missingParam3(DISP_E_PARAMNOTFOUND, VT_ERROR);
      hr =
         view->ExecuteScopeNodeMenuItem(
            AutoBstr(DNS_CONFIGE_WIZARD_MENU_ID),
            missingParam3);
      BREAK_ON_FAILED_HRESULT(
         hr,
         L"ExecuteScopeNodeMenuItem " DNS_CONFIGE_WIZARD_MENU_ID L" failed");
   }
   while (0);

   // don't save the console file.
   if (doc)
   {
      doc->Close(FALSE);
   }

   return hr;
}



int WINAPI
WinMain(
   HINSTANCE   hInstance, 
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR       /* lpszCmdLine */ ,
   int         /* nCmdShow */ )
{
   hResourceModuleHandle = hInstance;

   int exitCode = static_cast<int>(doIt());

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\make.inc ===
TESTDB_IDT=$(MSI_DATA_DIR)\testdb.idt
TESTCAB_IDT=$(MSI_DATA_DIR)\testcab.idt
TESTCAB_SRC=$(MSI_DATA_DIR)\testcab
TMPLDB_IDT=$(MSI_DATA_DIR)\template.idt
SIMPLE_IDT=$(MSI_DATA_DIR)\simple.idt
SCHEMA_MSM_IDT=$(MSI_DATA_DIR)\schemaMsm.idt
UISAMPLE_IDT=$(MSI_DATA_DIR)\uisample.idt
SEQUENCE_IDT=$(MSI_DATA_DIR)\sequence.idt
MINIMUM_IDT=$(MSI_DATA_DIR)\minimum.idt
MSISDK_IDT=$(MSI_DATA_DIR)\sdk.idt
TESTDB_IDT_BINARY=$(TESTDB_IDT)\Binary
WSHTOOLS=$(MSI_DIR)\src\msitools\scripts

BIN_DIR=$(MSI_DIR)\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\rras\rraswiz.cpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// launches dns wizard from the dhcp snapin using mmc automation



#include "headers.hxx"
#include "resource.h"
#include "smartptr.hpp"
#include "misc.hpp"



HINSTANCE hResourceModuleHandle = 0;



HRESULT
getContextMenu(const SmartInterface<View>& view, ContextMenu** dumbMenu)
{
   HRESULT hr = S_OK;

   _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
   hr = view->get_ScopeNodeContextMenu(missingParam2, dumbMenu);

   return hr;
}



inline
void
SafeStrncat(wchar_t* dest, const wchar_t* src, size_t bufmax)
{
   ASSERT(dest && src);

   if (dest && src)
   {
      wcsncat(dest, src, bufmax - wcslen(dest) - 1);
   }
}



HRESULT
doIt()
{
   HRESULT hr = S_OK;

   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr, L"CoInitialize failed.");

      SmartInterface<_Application> app(0);
      hr =
         app.AcquireViaCreateInstance(
            CLSID_Application,
            0,

            // we expect the object is out-of-proc, local server, but
            // we really don't care, so we'll take any implementation
            // available.

            CLSCTX_ALL);
      BREAK_ON_FAILED_HRESULT(hr, L"CoCreateInstance failed.");

      wchar_t buf[MAX_PATH + 1];
      memset(buf, 0, (MAX_PATH + 1) * sizeof(wchar_t));

      UINT result = ::GetSystemDirectory(buf, MAX_PATH);
      ASSERT(result != 0 && result <= MAX_PATH);

      wchar_t mscPath[MAX_PATH + 1] = L"";
      SafeStrncat(mscPath, buf, MAX_PATH);
      SafeStrncat(mscPath, L"\\rrasmgmt.msc", MAX_PATH);

      hr = app->Load(AutoBstr(mscPath));
      BREAK_ON_FAILED_HRESULT(hr, L"Load failed.");

      SmartInterface<Document> doc(0);
      Document* dumbDoc = 0;
      hr = app->get_Document(&dumbDoc);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Document failed.");
      doc.Acquire(dumbDoc);

      SmartInterface<Views> views(0);
      Views* dumbViews = 0;
      hr = doc->get_Views(&dumbViews);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Views failed.");
      views.Acquire(dumbViews);

      SmartInterface<View> view(0);
      View* dumbView = 0;
      hr = views->Item(1, &dumbView);
      BREAK_ON_FAILED_HRESULT(hr, L"Views::Item failed.");
      view.Acquire(dumbView);

      SmartInterface<ScopeNamespace> sn(0);
      ScopeNamespace* dumbSn = 0;
      hr = doc->get_ScopeNamespace(&dumbSn);
      BREAK_ON_FAILED_HRESULT(hr, L"get_ScopeNamespace failed.");
      sn.Acquire(dumbSn);

      SmartInterface<Node> rootnode(0);
      Node* dumbNode = 0;
      hr = sn->GetRoot(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetRoot failed.");
      rootnode.Acquire(dumbNode);

      SmartInterface<Node> child1(0);
      hr = sn->GetChild(rootnode, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child1.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child1);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child1 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> child2(0);
      hr = sn->GetChild(child1, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child2.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child2);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child2 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> next(0);
      hr = sn->GetNext(child2, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetNext failed.");
      next.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(next);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // excute configure server wizard menu item
      _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);

      hr = view->ExecuteScopeNodeMenuItem((BSTR)AutoBstr(L"_CONFIGURE_RRAS_WIZARD_"), missingParam2);
      BREAK_ON_FAILED_HRESULT(hr, L"ExecuteScopeNodeMenuItem FIGURE_RRAS_WIZARD_ failed");

      hr = doc->Close(FALSE);
      BREAK_ON_FAILED_HRESULT(hr, L"Close failed.");
   }
   while (0);

   return hr;
}



int WINAPI
WinMain(
   HINSTANCE   hInstance, 
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR       /* lpszCmdLine */ ,
   int         /* nCmdShow */ )
{
   hResourceModuleHandle = hInstance;

   int exitCode = static_cast<int>(doIt());

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\rras\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// copied from admin\burnslib\inc\smartptr.hpp



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface() : ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)
   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      ASSERT(SUCCEEDED(hr));

      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



   private:

   T* ptr;
};



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\dns\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// copied from admin\burnslib\inc\smartptr.hpp



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface() : ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)
   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      ASSERT(SUCCEEDED(hr));

      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



   private:

   T* ptr;
};



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cys\wrappers\rras\misc.hpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// random other stuff



#ifndef MISC_HPP_INCLUDED
#define MISC_HPP_INCLUDED



void
logMessage(const wchar_t* msg)
{
   if (msg)
   {
      ::OutputDebugString(L"rraswiz: ");
      ::OutputDebugString(msg);
      ::OutputDebugString(L"\n");
   }
}



void
logHresult(HRESULT hr)
{                                                              
   wchar_t buf[1024];                                          
   wsprintf(buf, L"HRESULT = 0x%08X\n", (hr));                 
   logMessage(buf);                               
}                                                              



#ifdef DBG

#define LOG_HRESULT(hr)    logHresult(hr)
#define LOG_MESSAGE(msg)   logMessage(msg)

#else

#define LOG_HRESULT(hr)
#define LOG_MESSAGE(msg)

#endif DBG



#define BREAK_ON_FAILED_HRESULT(hr,msg)                           \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_MESSAGE(msg);                                           \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};


#endif   // MISC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\appcompat\makefile.inc ===
ALT_PROJECT_TARGET=MsiShims
!if $(FREEBUILD)
MSI_APPCOMPAT_DIR=fre
!else
MSI_APPCOMPAT_DIR=chk
!endif
MSI_APPCOMPAT_COMMON_DIR=common
MSI_APPCOMPAT_FILES=\
    $(O)\msimain.sdb \
    $(O)\sdbapi.dll \
    $(O)\sdbapiu.dll

AppCompat: preprocess $(MSI_APPCOMPAT_FILES)
!if "$(PASS0ONLY)"==""
    @del /F /Q $(O)\* > nul
!endif

preprocess:
!if "$(PASS0ONLY)"=="1"
    @touch /F $(MSI_APPCOMPAT_DIR)\* > nul
    @touch /F $(MSI_APPCOMPAT_COMMON_DIR)\* > nul
    @copy /Y $(MSI_APPCOMPAT_DIR)\*.pdb $(O) > nul
!endif

$(O)\msimain.sdb: $(MSI_APPCOMPAT_COMMON_DIR)\$(@F)
    @copy /Y $(MSI_APPCOMPAT_COMMON_DIR)\$(@F) $(O) > nul
    $(BINPLACE_CMD)

$(O)\sdbapi.dll: $(MSI_APPCOMPAT_DIR)\$(@F)
    @copy /Y $(MSI_APPCOMPAT_DIR)\$(@F) $(O) > nul
    $(BINPLACE_CMD)

$(O)\sdbapiu.dll: $(MSI_APPCOMPAT_DIR)\$(@F)
    @copy /Y $(MSI_APPCOMPAT_DIR)\$(@F) $(O) > nul
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\instmsi\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\instmsi\sources.inc ===
!INCLUDE ..\..\..\Src\MsiMake.inc
TARGETNAME=
TARGETTYPE=DYNLINK

!ifndef MAKEDLL
NTTARGETFILE0=InstMsi
!endif

SOURCES=
BINPLACE_PLACEFILE=..\placefil.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\evalmsm.idt\makefile.inc ===
EVALMSM_IDT=$(MSI_DATA_DIR)\evalmsm.idt\$(TARGET_DIRECTORY)

EvalcomMSM: \
	$(BUILD_PACKAGEDIR)\evalcom.msm \
	$(O)\evalcab.ddf

#-----------------------------------------------------------------------------

$(O)\evalcab.ddf: $(EVALMSM_IDT)\cab.ddf
        copy /y $(EVALMSM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\evalsig.idt: $(EVALMSM_IDT)\modulesi.tpl
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(EVALMSM_IDT)\modulesi.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\evalcom.tmp: $(EVALMSM_IDT)\*.idt $(O)\evalsig.idt
	msidb.exe -i -c -f$(EVALMSM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\evalmsm.idt\$(O) -d$@ evalsig.idt

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\evalcom.msm: $(BUILD_PACKAGEDIR)\evalcom.tmp $(EVALMSM_IDT)\external\*.idt
	copy /y $(BUILD_PACKAGEDIR)\evalcom.tmp $@
	msidb.exe -i -f$(EVALMSM_IDT)\external -d$@ *.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\basebld\makefile.inc ===
!include ..\make.inc

ALT_PROJECT_TARGET=instmsi\msitools

BaseAll: \
        $(BUILD_PACKAGEDIR)\simple.msi \
	$(BUILD_PACKAGEDIR)\testcab.msi \
	$(BUILD_PACKAGEDIR)\sequence.msi \
	$(BUILD_PACKAGEDIR)\minimum.msi \
	$(BUILD_PACKAGEDIR)\schema.msi \
        $(BUILD_PACKAGEDIR)\schema.msm

        
#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR):
	md $(BUILD_PACKAGEDIR)
        
$(O)\error.idt: $(MSI_INTLDATA_DIR)\error.enu
	copy $(MSI_INTLDATA_DIR)\error.enu $(O)\error.idt
        
$(O)\actionte.idt: $(MSI_INTLDATA_DIR)\actionte.enu
        copy $(MSI_INTLDATA_DIR)\actionte.enu $(O)\actionte.idt


#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\template.msi: $(BUILD_PACKAGEDIR)\schema.msi $(TMPLDB_IDT)\*.idt $(O)\error.idt $(O)\actionte.idt
	msidb.exe -i -f$(TMPLDB_IDT) -m$(BUILD_PACKAGEDIR)\schema.msi -c -d$@ *.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt actionte.idt


#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\schema.msi: $(BUILD_PACKAGEDIR) $(SCHEMA_IDT)\*.idt
	msidb.exe -f$(SCHEMA_IDT) -c -d$@ *.idt

$(BUILD_PACKAGEDIR)\schema.msm: $(SCHEMA_MSM_IDT)\*.idt
	msidb.exe -f$(SCHEMA_MSM_IDT) -c -d$@ *.idt


#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\simple.msi: $(SIMPLE_IDT)\*.idt $(O)\error.idt $(O)\actionte.idt
	msidb.exe -f$(SIMPLE_IDT) -c -d$@ *.idt
	msidb.exe -f$(TMPLDB_IDT) -i -d$@ binary.idt
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ listbox.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt actionte.idt


#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\testcab.msi: $(BUILD_PACKAGEDIR)\template.msi $(TESTCAB_IDT)\*.idt $(O)\error.idt
	msidb.exe -i -f$(TESTCAB_IDT) -m$(BUILD_PACKAGEDIR)\template.msi -c -d$@ *.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt
	msidb.exe -i -f$(TESTCAB_IDT)\validate -d$@ _validat.idt
	msidb.exe -d$@ -a$(TESTCAB_SRC)\msproj1.cab
	copy $(TESTCAB_SRC)\*.* $(BUILD_PACKAGEDIR)

#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\sequence.msi: $(SEQUENCE_IDT)\*.idt
	msidb.exe -i -f$(SEQUENCE_IDT) -c -d$@ *.idt


#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\minimum.msi: $(MINIMUM_IDT)\*.idt $(O)\error.idt $(SCHEMA_IDT)\_validat.idt
	msidb.exe -f$(MINIMUM_IDT) -c -d$@ *.idt
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ _validat.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\instmsi\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\mergemsm.idt\makefile.inc ===
MMMSM_IDT=$(MSI_DATA_DIR)\mergemsm.idt\$(TARGET_DIRECTORY)

MergeModMSM: \
	$(BUILD_PACKAGEDIR)\mergemod.msm \
	$(O)\mergecab.ddf

#-----------------------------------------------------------------------------


$(O)\mergecab.ddf: $(MMMSM_IDT)\cab.ddf
        copy /y $(MMMSM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\mmsig.idt: $(MMMSM_IDT)\modulesi.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc$(MMMSM_IDT)\modulesi.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(BUILD_PACKAGEDIR)\mergemod.tmp: $(MMMSM_IDT)\*.idt $(O)\mmsig.idt
	msidb.exe -i -c -f$(MMMSM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\mergemsm.idt\$(O) -d$@ mmsig.idt

$(BUILD_PACKAGEDIR)\mergemod.msm: $(BUILD_PACKAGEDIR)\mergemod.tmp $(MMMSM_IDT)\external\*.idt
        copy /y $(BUILD_PACKAGEDIR)\mergemod.tmp $@
	msidb.exe -i -f$(MMMSM_IDT)\external -d$@ *.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\instmsi\make.inc ===
!include ..\..\..\src\makever.inc

BIN_DIR=$(MSI_DIR)\bin\$(TARGET_DIRECTORY)
INSTMSI_DIR=$(MSI_DIR)\data\instmsi
IDT_DIR=$(INSTMSI_DIR)\$(MSI_SUBDIR)\$(O)


MSI_ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)

!if "$(MSI_BUILD_UNICODE)"=="1"
# the double slashes are needed to let SED do its trick without mis-interpreting the slashes as escaped characters
MSI_ALT_TARGET=
ALT_PROJECT_TARGET=InstMsi\unicode
!else
# the double slashes are needed to let SED do its trick without mis-interpreting the slashes as escaped characters
MSI_ALT_TARGET=\msiwin9x
ALT_PROJECT_TARGET=InstMsi\ansi
!endif

MSI_BASE_TREE=_NTPOSTBLD\$(MSI_ALT_TARGET)
MSI_REGSIP_DIR=$(MSI_ALT_TARGET)\dump

MAKEFILE=..\make.inc

!if $(FREEBUILD)
VERSION=SHIP
!else
VERSION=DEBUG
!endif

InstMsi: $(MAKEFILE) $(O)\InstMsi.sed exception support $(O)\instmsi.mak $(O)\binary.idt  $(O)\instmsi.msi 
exception: $(O)\msi.cdf $(O)\msi.inf 
support: $(O)\cabinet.dll $(O)\imagehlp.dll $(O)\mspatcha.dll $(O)\riched20.dll $(O)\usp10.dll $(O)\msls31.dll $(O)\shfolder.dll $(O)\jdate2.exe

$(O)\instmsi.mak: $(INSTMSI_DIR)\$(@F)
	echo <<$@ >>NUL
MSI_BUILD_NUMBER=$(MSIRMJ).$(MSIRMM).$(MSIRUP).$(MSIRIN)
TARGET=$(ALT_PROJECT_TARGET)
REGSIP_DIR=$(MSI_REGSIP_DIR)
MSI_ALT_TARGET=$(MSI_ALT_TARGET)
MSI_BUILD_UNICODE=$(MSI_BUILD_UNICODE)
<<KEEP
	type $(INSTMSI_DIR)\$(@F) >> $@
	$(BINPLACE_CMD)

#UNICODE only support files
$(O)\msi.cdf $(O)\msi.inf : $(INSTMSI_DIR)\msi.cdf $(INSTMSI_DIR)\msi.inf
!if "$(MSI_BUILD_UNICODE)"=="1"
	copy $(INSTMSI_DIR)\$(@F) $@
	$(BINPLACE_CMD)
!endif

$(O)\binary.idt : $(INSTMSI_DIR)\binary.idt
	copy $(INSTMSI_DIR)\$(@F) $@
	$(BINPLACE_CMD)

$(O)\cabinet.dll $(O)\mspatcha.dll $(O)\usp10.dll $(O)\msls31.dll $(O)\shfolder.dll $(O)\riched20.dll:
	copy $(BIN_DIR)\$(@F) $@
	copy $(BIN_DIR)\$(@B).pdb $(O)\$(@B).pdb
	$(BINPLACE_CMD)

$(O)\imagehlp.dll:
	copy $(BIN_DIR)\$(@F) $@
	copy $(BIN_DIR)\imagehlp.pdb $(O)\$(@B).pdb
	$(BINPLACE_CMD)

$(O)\copymsi.msi: $(MAKEFILE) $(MSI_DATA_DIR)\msimsi\*.idt ..\intl\inst*.msi ..\instmsi.pl $(MSI_INTLDATA_DIR)\error.enu $(MSI_INTLDATA_DIR)\actionte.enu
	msidb.exe -c -f$(MSI_DATA_DIR)\msimsi -d$@ *.idt
!if "$(MSI_BUILD_UNICODE)"=="1"
	msidb.exe -f$(MSI_DATA_DIR)\msimsi\unicode -i -d$@ *.idt
!else
	msidb.exe -f$(MSI_DATA_DIR)\msimsi\ansi -i -d$@ *.idt
!endif
	copy $(MSI_INTLDATA_DIR)\error.enu $(O)\error.idt
	copy $(MSI_INTLDATA_DIR)\actionte.enu $(O)\actionte.idt
	msidb.exe -f$(IDT_DIR) -i -d$@ error.idt actionte.idt
	copy $@ $(O)\inst1033.msi  
	perl ..\instmsi.pl $@ Alpha,Intel ..\intl $(O)

$(O)\instmsi.msi: $(O)\copymsi.msi
	copy $(O)\copymsi.msi $@
	$(BINPLACE_CMD)

$(O)\jdate2.exe:
	copy $(INSTMSI_DIR)\jdate2.exe $@
	$(BINPLACE_CMD)

$(O)\InstMsi1.sed : $(MAKEFILE)
	echo <<$(O)\InstMsi1.sed >>NUL
[Version]
Class=IEXPRESS
SEDVersion=3
[SourceFiles]
MsiSourceFiles=$(MSI_BASE_TREE)
CommonFiles=_NTPOSTBLD
MsiSourceFilesDump=$(MSI_BASE_TREE)\Dump
InstmsiSourceFiles=_NTPOSTBLD\$(ALT_PROJECT_TARGET)
InstmsiSourceFilesDump=_NTPOSTBLD\$(ALT_PROJECT_TARGET)\Dump
ShimDllSourceFiles=_NTPOSTBLD\idw

<<KEEP

$(O)\InstMsi2.sed : $(MAKEFILE) 
	echo <<$(O)\InstMsi2.sed >>NUL
[Options]
CheckAdminRights=0
PackagePurpose=InstallApp
ShowInstallProgramWindow=0
HideExtractAnimation=1
UseLongFileName=0
InsideCompressed=0
CAB_FixedSize=0
CAB_ResvCodeSigning=0
RebootMode=N
InstallPrompt=
DisplayLicense=
PostInstallCmd=<None>
SourceFiles=SourceFiles
VersionInfo=VersionSection
AlwaysPropogateCmdExitCode=1
<<KEEP

$(O)\instmsi3.sed : $(MAKEFILE)
	echo <<$(O)\InstMsi3.sed >>NUL
[MsiSourceFiles]
!if "$(MSI_BUILD_UNICODE)"=="0"
msi.dll=
!endif
msiexec.exe=
msihnd.dll=
msisip.dll=

[CommonFiles]
msimsg.dll=
msimain.sdb=

[MsiSourceFilesDump]
msiinst.exe=

[InstmsiSourceFiles]
!if "$(MSI_BUILD_UNICODE)"=="1"
msi.dll=
msi.cat=
msi.inf=
!endif
riched20.dll=
usp10.dll=
msls31.dll=
shfolder.dll=
instmsi.msi=
imagehlp.dll=

[InstmsiSourceFilesDump]
cabinet.dll=
mspatcha.dll=

[ShimDllSourceFiles]
!if "$(MSI_BUILD_UNICODE)"=="0"
sdbapi.dll=
!else
sdbapiU.dll=
!endif

[VersionSection]
FromFile=msiexec.exe
OriginalFilename=Msi.dll,MsiHnd.dll,MsiExec.exe
InternalName=InstMsi.exe
FileDescription=Installer for the Windows Installer
#These come msiexec.exe now.
LegalCopyright=Copyright (c) Microsoft Corp. 2000
!if "$(MSI_BUILD_UNICODE)"=="1"
ProductName=Windows Installer - Unicode
!else
ProductName=Windows Installer
!endif
!if $(FREEBUILD)
FileFlags=0
!else
FileFlags=1
!endif
ProductVersion=$(MSIRMJ).$(MSIRMM).$(MSIRUP).$(MSIRIN)
FileVersion=$(MSIRMJ).$(MSIRMM).$(MSIRUP).$(MSIRIN)
<<KEEP

$(O)\instmsi.sed: $(O)\instmsi1.sed $(O)\instmsi2.sed $(O)\instmsi3.sed
	type $(O)\instmsi1.sed > $@
	type $(O)\instmsi3.sed >> $@
	type $(O)\instmsi2.sed >>$@
	echo FriendlyName=Installation of System Software Installer $(VERSION) >>$@
	echo TargetName=_NTPOSTBLD\$(ALT_PROJECT_TARGET)\InstMsi.exe >>$@
	echo AdminQuietInstCmd=msiinst.exe /i instmsi.msi REBOOT=REALLYSUPRESS MSIEXECREG=1 /m /q >>$@
	echo UserQuietInstCmd=msiinst.exe /i instmsi.msi REBOOT=REALLYSUPRESS MSIEXECREG=1 /m /q >>$@
	echo AppLaunched=msiinst.exe /i instmsi.msi MSIEXECREG=1 /m /qb+! >>$@
	$(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\msispy.idt\makefile.inc ===
SCHEMA_MSM_IDT=$(MSI_DATA_DIR)\schemaMsm.idt
SPYMSI_IDT=$(MSI_DATA_DIR)\msispy.idt
SPYMSI_PLATFORM_IDT=$(SPYMSI_IDT)\$(TARGET_DIRECTORY)

SpyMsi: \
	$(BUILD_PACKAGEDIR)\msispy.msi \
	$(O)\spycab.ddf

#-----------------------------------------------------------------------------

$(O)\spyprop.idt: $(SPYMSI_PLATFORM_IDT)\property.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(SPYMSI_PLATFORM_IDT)\property.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(O)\spyupgr.idt: $(SPYMSI_PLATFORM_IDT)\upgrade.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(SPYMSI_PLATFORM_IDT)\upgrade.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\msispy.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(SPYMSI_IDT)\*.idt \
		$(SPYMSI_IDT)\addlegal.mst $(O)\spyprop.idt $(SPYMSI_PLATFORM_IDT)\*.idt \
		$(O)\spyupgr.idt
	msidb.exe -d$@ -c -f$(SPYMSI_PLATFORM_IDT) -i *.idt
	msidb.exe -d$@ -f$(SPYMSI_IDT)\$(O) -i spyprop.idt
	msidb.exe -d$@ -f$(SPYMSI_IDT)\$(O) -i spyupgr.idt
	msidb.exe -d$@ -f$(SPYMSI_IDT) -i *.idt
	msidb.exe -d$@ -m $(BUILD_PACKAGEDIR)\uisample.msi 
	msitran.exe -a $(SPYMSI_IDT)\addlegal.mst $@

#-----------------------------------------------------------------------------

$(O)\spycab.ddf: $(SPYMSI_PLATFORM_IDT)\spycab.ddf
	copy /Y $(SPYMSI_PLATFORM_IDT)\spycab.ddf $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\msival2.idt\makefile.inc ===
!include ..\make.inc

MSIVAL2_IDT=$(MSI_DATA_DIR)\msival2.idt
MSIVAL2_PLATFORM_IDT=$(MSIVAL2_IDT)\$(TARGET_DIRECTORY)
EVALMSM_IDT=$(MSI_DATA_DIR)\evalmsm.idt\$(TARGET_DIRECTORY)

MsiVal2Msi: \
	$(BUILD_PACKAGEDIR)\msival2.msi \
	$(O)\msivlcab.ddf


$(O)\msivlcab.ddf: $(MSIVAL2_PLATFORM_IDT)\cab.ddf
	copy /y $(MSIVAL2_PLATFORM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\evalcom.msm: $(EVALMSM_IDT)\internal\*.idt $(BUILD_PACKAGEDIR)\evalcom.msm
	copy /y $(BUILD_PACKAGEDIR)\evalcom.msm $@
	msidb.exe -i -f$(EVALMSM_IDT)\internal -d$@ *.idt

#-----------------------------------------------------------------------------

$(O)\val2prop.idt: $(SDK_INC_PATH)\ntverp.h $(MSIVAL2_PLATFORM_IDT)\property.tpl
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(MSIVAL2_PLATFORM_IDT)\property.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(O)\val2upgr.idt: $(SDK_INC_PATH)\ntverp.h $(MSIVAL2_PLATFORM_IDT)\upgrade.tpl
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(MSIVAL2_PLATFORM_IDT)\upgrade.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@


#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\msival2.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(O)\evalcom.msm  \
		$(MSIVAL2_IDT)\*.idt $(MSIVAL2_PLATFORM_IDT)\*.idt $(O)\val2prop.idt \
		$(O)\val2upgr.idt
 	msidb.exe -i -c -f$(MSIVAL2_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSIVAL2_PLATFORM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\msival2.idt\$(O) -d $@ val2prop.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\msival2.idt\$(O) -d $@ val2upgr.idt
	msidb.exe -m$(BUILD_PACKAGEDIR)\uisample.msi -d$@
	msidb.exe -m$(O)\evalcom.msm -d$@
	msitran.exe -a $(MSIVAL2_IDT)\addlegal.mst $@
	CScript $(WSHTOOLS)\wisuminf.vbs $@ 11=Date 12=Date
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "UPDATE `Property` SET `Value`=0 WHERE `Property`='ShowUserRegistrationDlg'"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\orca.idt\makefile.inc ===
!include ..\make.inc

SCHEMA_MSM_IDT=$(MSI_DATA_DIR)\schemaMsm.idt

MMMSM_IDT=$(MSI_DATA_DIR)\mergemsm.idt\$(TARGET_DIRECTORY)
EVALMSM_IDT=$(MSI_DATA_DIR)\evalmsm.idt\$(TARGET_DIRECTORY)

ORCA_IDT=$(MSI_DATA_DIR)\orca.idt
ORCA_PLATFORM_IDT=$(ORCA_IDT)\$(TARGET_DIRECTORY)
ORCA_IDT_ICON=$(ORCA_IDT)\icon


OrcaMsi: $(BUILD_PACKAGEDIR)\orca.msi \
	 $(BUILD_PACKAGEDIR)\orca.dat \
	 $(O)\orcacab.ddf

#-----------------------------------------------------------------------------

$(O)\evalcom.msm: $(EVALMSM_IDT)\internal\*.idt $(BUILD_PACKAGEDIR)\evalcom.tmp
	copy /y $(BUILD_PACKAGEDIR)\evalcom.tmp $@
	msidb.exe -i -f$(EVALMSM_IDT)\internal -d$@ *.idt

#-----------------------------------------------------------------------------

$(O)\mergemod.msm: $(MMMSM_IDT)\internal\*.idt $(BUILD_PACKAGEDIR)\mergemod.tmp
	copy /y $(BUILD_PACKAGEDIR)\mergemod.tmp $@
	msidb.exe -i -f$(MMMSM_IDT)\internal -d$@ *.idt

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\orca.dat: $(SCHEMA_IDT)\*.idt $(SCHEMA_MSM_IDT)\*.idt
	msidb.exe -c -i -f$(SCHEMA_IDT) -d$@ *.idt
	msidb.exe -c -i -f$(SCHEMA_IDT) -d$(O)\schema.msm *.idt
	msidb.exe -m $(O)\schema.msm -d $@

#-----------------------------------------------------------------------------

$(O)\orcacab.ddf: $(ORCA_PLATFORM_IDT)\cab.ddf
	copy /y $(ORCA_PLATFORM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\orcaprop.idt: $(ORCA_PLATFORM_IDT)\property.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(ORCA_PLATFORM_IDT)\property.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(O)\orcaupgr.idt: $(ORCA_PLATFORM_IDT)\upgrade.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(ORCA_PLATFORM_IDT)\upgrade.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\orca.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(O)\mergemod.msm $(O)\evalcom.msm \
		$(ORCA_IDT)\*.idt $(ORCA_PLATFORM_IDT)\*.idt $(ORCA_IDT_ICON)\*.* $(O)\orcaprop.idt \
		$(O)\orcaupgr.idt
 	msidb.exe -i -c -f$(ORCA_IDT) -d$@ *.idt
	msidb.exe -i -f$(ORCA_PLATFORM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\orca.idt\$(O) -d $@ orcaprop.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\orca.idt\$(O) -d $@ orcaupgr.idt
	msidb.exe -m $(BUILD_PACKAGEDIR)\uisample.msi -d$@
	msidb.exe -m $(O)\evalcom.msm -d$@
	msidb.exe -m $(O)\mergemod.msm -d$@
	msitran.exe -a $(ORCA_IDT)\addlegal.mst $@
	CScript $(WSHTOOLS)\wisuminf.vbs $@ 11=Date 12=Date
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "UPDATE `Property` SET `Value`=0 WHERE `Property`='ShowUserRegistrationDlg'"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\sdk\layout.inc ===
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
# --------- DO NOT EDIT --- see layout.txt --- DO NOT EDIT -------------------
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
$(O)\sdkmake.inc : sdkmake.inc
	copy sdkmake.inc $@
	$(BINPLACE_CMD)
$(O)\sdkpost.mak : sdkpost.mak
	copy sdkpost.mak $@
	$(BINPLACE_CMD)
$(O)\msisdk.msi : $(BUILD_PACKAGEDIR)\msisdk.msi
	copy $(BUILD_PACKAGEDIR)\msisdk.msi $@
	$(BINPLACE_CMD)
$(O)\ReadMe.txt : $(SDXROOT)\admin\darwin\src\sdk\ReadMe.txt
	copy $(SDXROOT)\admin\darwin\src\sdk\ReadMe.txt $@
	$(BINPLACE_CMD)
$(O)\Redist.txt : $(SDXROOT)\admin\darwin\src\sdk\Redist.txt
	copy $(SDXROOT)\admin\darwin\src\sdk\Redist.txt $@
	$(BINPLACE_CMD)
$(O)\License.rtf : $(SDXROOT)\admin\darwin\src\sdk\License.rtf
	copy $(SDXROOT)\admin\darwin\src\sdk\License.rtf $@
	$(BINPLACE_CMD)
$(O)\INSTLR1.ADM : $(SDXROOT)\admin\darwin\src\sdk\INSTLR1.ADM
	copy $(SDXROOT)\admin\darwin\src\sdk\INSTLR1.ADM $@
	$(BINPLACE_CMD)
$(O)\instlr11.adm : $(SDXROOT)\admin\darwin\src\sdk\instlr11.adm
	copy $(SDXROOT)\admin\darwin\src\sdk\instlr11.adm $@
	$(BINPLACE_CMD)
$(O)\msi.h : $(SDXROOT)\public\sdk\inc\msi.h
	copy $(SDXROOT)\public\sdk\inc\msi.h $@
	$(BINPLACE_CMD)
$(O)\msiquery.h : $(SDXROOT)\public\sdk\inc\msiquery.h
	copy $(SDXROOT)\public\sdk\inc\msiquery.h $@
	$(BINPLACE_CMD)
$(O)\msidefs.h : $(SDXROOT)\public\sdk\inc\msidefs.h
	copy $(SDXROOT)\public\sdk\inc\msidefs.h $@
	$(BINPLACE_CMD)
$(O)\patchwiz.h : $(SDXROOT)\admin\darwin\src\msitools\patchwiz\patchwiz.h
	copy $(SDXROOT)\admin\darwin\src\msitools\patchwiz\patchwiz.h $@
	$(BINPLACE_CMD)
$(O)\patchapi.h : $(SDXROOT)\public\sdk\inc\patchapi.h
	copy $(SDXROOT)\public\sdk\inc\patchapi.h $@
	$(BINPLACE_CMD)
$(O)\Mergemod.h : $(SDXROOT)\admin\darwin\build\common\obj\i386\Mergemod.h
	copy $(SDXROOT)\admin\darwin\build\common\obj\i386\Mergemod.h $@
	$(BINPLACE_CMD)
$(O)\msi.lib : $(SDXROOT)\public\sdk\lib\i386\msi.lib
	copy $(SDXROOT)\public\sdk\lib\i386\msi.lib $@
	$(BINPLACE_CMD)
$(O)\mspatchc.lib : $(SDXROOT)\public\sdk\lib\i386\mspatchc.lib
	copy $(SDXROOT)\public\sdk\lib\i386\mspatchc.lib $@
	$(BINPLACE_CMD)
$(O)\msi.chm : $(SDXROOT)\admin\darwin\doc\msi.chm
	copy $(SDXROOT)\admin\darwin\doc\msi.chm $@
	$(BINPLACE_CMD)
$(O)\msi.chi : $(SDXROOT)\admin\darwin\doc\msi.chi
	copy $(SDXROOT)\admin\darwin\doc\msi.chi $@
	$(BINPLACE_CMD)
$(O)\msitool.mak : $(SDXROOT)\admin\darwin\src\msitools\msitool.mak
	copy $(SDXROOT)\admin\darwin\src\msitools\msitool.mak $@
	$(BINPLACE_CMD)
$(O)\darice.cub : $(SDXROOT)\admin\darwin\data\archive\cubes\110\darice.cub
	copy $(SDXROOT)\admin\darwin\data\archive\cubes\110\darice.cub $@
	$(BINPLACE_CMD)
$(O)\logo.cub : $(SDXROOT)\admin\darwin\data\archive\cubes\110\logo.cub
	copy $(SDXROOT)\admin\darwin\data\archive\cubes\110\logo.cub $@
	$(BINPLACE_CMD)
$(O)\mergemod.cub : $(SDXROOT)\admin\darwin\data\archive\cubes\110\mergemod.cub
	copy $(SDXROOT)\admin\darwin\data\archive\cubes\110\mergemod.cub $@
	$(BINPLACE_CMD)
$(O)\darice.cub1 : $(SDXROOT)\admin\darwin\data\archive\cubes\120\darice.cub
	copy $(SDXROOT)\admin\darwin\data\archive\cubes\120\darice.cub $@
	$(BINPLACE_CMD)
$(O)\logo.cub1 : $(SDXROOT)\admin\darwin\data\archive\cubes\120\logo.cub
	copy $(SDXROOT)\admin\darwin\data\archive\cubes\120\logo.cub $@
	$(BINPLACE_CMD)
$(O)\mergemod.cub1 : $(SDXROOT)\admin\darwin\data\archive\cubes\120\mergemod.cub
	copy $(SDXROOT)\admin\darwin\data\archive\cubes\120\mergemod.cub $@
	$(BINPLACE_CMD)
$(O)\preadme.txt : $(SDXROOT)\admin\darwin\src\sdk\preadme.txt
	copy $(SDXROOT)\admin\darwin\src\sdk\preadme.txt $@
	$(BINPLACE_CMD)
$(O)\makecab.exe : $(SDXROOT)\admin\darwin\bin\i386\makecab.exe
	copy $(SDXROOT)\admin\darwin\bin\i386\makecab.exe $@
	$(BINPLACE_CMD)
$(O)\mpatch.exe : $(SDXROOT)\admin\darwin\bin\i386\mpatch.exe
	copy $(SDXROOT)\admin\darwin\bin\i386\mpatch.exe $@
	$(BINPLACE_CMD)
$(O)\apatch.exe : $(SDXROOT)\admin\darwin\bin\i386\apatch.exe
	copy $(SDXROOT)\admin\darwin\bin\i386\apatch.exe $@
	$(BINPLACE_CMD)
$(O)\mspatchc.dll : $(SDXROOT)\admin\darwin\bin\i386\mspatchc.dll
	copy $(SDXROOT)\admin\darwin\bin\i386\mspatchc.dll $@
	$(BINPLACE_CMD)
$(O)\TEMPLATE.PCP : $(SDXROOT)\admin\darwin\src\msitools\PatchWiz\TEMPLATE.PCP
	copy $(SDXROOT)\admin\darwin\src\msitools\PatchWiz\TEMPLATE.PCP $@
	$(BINPLACE_CMD)
$(O)\EXAMPLE.PCP : $(SDXROOT)\admin\darwin\src\msitools\PatchWiz\EXAMPLE.PCP
	copy $(SDXROOT)\admin\darwin\src\msitools\PatchWiz\EXAMPLE.PCP $@
	$(BINPLACE_CMD)
$(O)\WiReadMe.txt : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiReadMe.txt
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiReadMe.txt $@
	$(BINPLACE_CMD)
$(O)\WiCompon.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiCompon.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiCompon.vbs $@
	$(BINPLACE_CMD)
$(O)\WiDialog.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiDialog.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiDialog.vbs $@
	$(BINPLACE_CMD)
$(O)\WiDiffDb.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiDiffDb.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiDiffDb.vbs $@
	$(BINPLACE_CMD)
$(O)\WiExport.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiExport.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiExport.vbs $@
	$(BINPLACE_CMD)
$(O)\WiFilVer.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiFilVer.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiFilVer.vbs $@
	$(BINPLACE_CMD)
$(O)\WiFeatur.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiFeatur.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiFeatur.vbs $@
	$(BINPLACE_CMD)
$(O)\WiGenXfm.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiGenXfm.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiGenXfm.vbs $@
	$(BINPLACE_CMD)
$(O)\WiImport.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiImport.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiImport.vbs $@
	$(BINPLACE_CMD)
$(O)\WiLangId.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLangId.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLangId.vbs $@
	$(BINPLACE_CMD)
$(O)\WiLstPrd.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstPrd.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstPrd.vbs $@
	$(BINPLACE_CMD)
$(O)\WiLstScr.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstScr.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstScr.vbs $@
	$(BINPLACE_CMD)
$(O)\WiLstXfm.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstXfm.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstXfm.vbs $@
	$(BINPLACE_CMD)
$(O)\WiMakCab.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiMakCab.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiMakCab.vbs $@
	$(BINPLACE_CMD)
$(O)\WiMerge.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiMerge.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiMerge.vbs $@
	$(BINPLACE_CMD)
$(O)\WiPolicy.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiPolicy.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiPolicy.vbs $@
	$(BINPLACE_CMD)
$(O)\WiRunSQL.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiRunSQL.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiRunSQL.vbs $@
	$(BINPLACE_CMD)
$(O)\WiStream.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiStream.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiStream.vbs $@
	$(BINPLACE_CMD)
$(O)\WiSubStg.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiSubStg.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiSubStg.vbs $@
	$(BINPLACE_CMD)
$(O)\WiSumInf.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiSumInf.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiSumInf.vbs $@
	$(BINPLACE_CMD)
$(O)\WiTextIn.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiTextIn.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiTextIn.vbs $@
	$(BINPLACE_CMD)
$(O)\WiToAnsi.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiToAnsi.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiToAnsi.vbs $@
	$(BINPLACE_CMD)
$(O)\WiUseXfm.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiUseXfm.vbs
	copy $(SDXROOT)\admin\darwin\src\msitools\scripts\WiUseXfm.vbs $@
	$(BINPLACE_CMD)
$(O)\custact1.cpp : $(SDXROOT)\admin\darwin\src\samples\custdll\custact1.cpp
	copy $(SDXROOT)\admin\darwin\src\samples\custdll\custact1.cpp $@
	$(BINPLACE_CMD)
$(O)\custexe1.cpp : $(SDXROOT)\admin\darwin\src\samples\custexe\custexe1.cpp
	copy $(SDXROOT)\admin\darwin\src\samples\custexe\custexe1.cpp $@
	$(BINPLACE_CMD)
$(O)\tutorial.cpp : $(SDXROOT)\admin\darwin\src\samples\tutorial.dll\tutorial.cpp
	copy $(SDXROOT)\admin\darwin\src\samples\tutorial.dll\tutorial.cpp $@
	$(BINPLACE_CMD)
$(O)\process.cpp : $(SDXROOT)\admin\darwin\src\samples\process.dll\process.cpp
	copy $(SDXROOT)\admin\darwin\src\samples\process.dll\process.cpp $@
	$(BINPLACE_CMD)
$(O)\remove.cpp : $(SDXROOT)\admin\darwin\src\samples\remove.dll\remove.cpp
	copy $(SDXROOT)\admin\darwin\src\samples\remove.dll\remove.cpp $@
	$(BINPLACE_CMD)
$(O)\create.cpp : $(SDXROOT)\admin\darwin\src\samples\create.dll\create.cpp
	copy $(SDXROOT)\admin\darwin\src\samples\create.dll\create.cpp $@
	$(BINPLACE_CMD)
$(O)\msiloc.cpp : $(SDXROOT)\admin\darwin\src\msitools\msiloc\msiloc.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\msiloc\msiloc.cpp $@
	$(BINPLACE_CMD)
$(O)\msiloc.txt : $(SDXROOT)\admin\darwin\src\msitools\msiloc\msiloc.txt
	copy $(SDXROOT)\admin\darwin\src\msitools\msiloc\msiloc.txt $@
	$(BINPLACE_CMD)
$(O)\msitran.cpp : $(SDXROOT)\admin\darwin\src\msitools\msitran\msitran.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\msitran\msitran.cpp $@
	$(BINPLACE_CMD)
$(O)\msimerg.cpp : $(SDXROOT)\admin\darwin\src\msitools\msimerg\msimerg.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\msimerg\msimerg.cpp $@
	$(BINPLACE_CMD)
$(O)\setup.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.cpp $@
	$(BINPLACE_CMD)
$(O)\setupui.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setupui.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setupui.cpp $@
	$(BINPLACE_CMD)
$(O)\upgrdmsi.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\upgrdmsi.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\upgrdmsi.cpp $@
	$(BINPLACE_CMD)
$(O)\utils.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\utils.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\utils.cpp $@
	$(BINPLACE_CMD)
$(O)\vertrust.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\vertrust.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\vertrust.cpp $@
	$(BINPLACE_CMD)
$(O)\common.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\common.h
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\common.h $@
	$(BINPLACE_CMD)
$(O)\resource.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\resource.h
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\resource.h $@
	$(BINPLACE_CMD)
$(O)\setup.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.h
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.h $@
	$(BINPLACE_CMD)
$(O)\setupui.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setupui.h
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setupui.h $@
	$(BINPLACE_CMD)
$(O)\setup.rc : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.rc
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.rc $@
	$(BINPLACE_CMD)
$(O)\setup.ico : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.ico
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.ico $@
	$(BINPLACE_CMD)
$(O)\msistuff.cpp : $(SDXROOT)\admin\darwin\src\msitools\msistuff\msistuff.cpp
	copy $(SDXROOT)\admin\darwin\src\msitools\msistuff\msistuff.cpp $@
	$(BINPLACE_CMD)
$(O)\msistuff.rc : $(SDXROOT)\admin\darwin\src\msitools\msistuff\msistuff.rc
	copy $(SDXROOT)\admin\darwin\src\msitools\msistuff\msistuff.rc $@
	$(BINPLACE_CMD)
$(O)\Makefile1 : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\SDKFiles\Makefile
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\SDKFiles\Makefile $@
	$(BINPLACE_CMD)
$(O)\ReadMe.htm1 : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\SDKFiles\ReadMe.htm
	copy $(SDXROOT)\admin\darwin\src\msitools\setup.exe\SDKFiles\ReadMe.htm $@
	$(BINPLACE_CMD)
$(O)\Makefile2 : $(SDXROOT)\admin\darwin\src\msitools\msistuff\SDKFiles\Makefile
	copy $(SDXROOT)\admin\darwin\src\msitools\msistuff\SDKFiles\Makefile $@
	$(BINPLACE_CMD)
$(O)\ReadMe.htm2 : $(SDXROOT)\admin\darwin\src\msitools\msistuff\SDKFiles\ReadMe.htm
	copy $(SDXROOT)\admin\darwin\src\msitools\msistuff\SDKFiles\ReadMe.htm $@
	$(BINPLACE_CMD)
$(O)\dbreadme.txt : $(SDXROOT)\admin\darwin\src\sdk\dbreadme.txt
	copy $(SDXROOT)\admin\darwin\src\sdk\dbreadme.txt $@
	$(BINPLACE_CMD)
$(O)\schema.msi : $(SDXROOT)\admin\darwin\build\packages\obj\i386\schema.msi
	copy $(SDXROOT)\admin\darwin\build\packages\obj\i386\schema.msi $@
	$(BINPLACE_CMD)
$(O)\schema.msi1 : $(SDXROOT)\admin\darwin\data\archive\packages\100\schema.msi
	copy $(SDXROOT)\admin\darwin\data\archive\packages\100\schema.msi $@
	$(BINPLACE_CMD)
$(O)\schema.msi2 : $(SDXROOT)\admin\darwin\data\archive\packages\110\schema.msi
	copy $(SDXROOT)\admin\darwin\data\archive\packages\110\schema.msi $@
	$(BINPLACE_CMD)
$(O)\schema.msi3 : $(SDXROOT)\admin\darwin\data\archive\packages\120\schema.msi
	copy $(SDXROOT)\admin\darwin\data\archive\packages\120\schema.msi $@
	$(BINPLACE_CMD)
$(O)\sequence.msi : $(SDXROOT)\admin\darwin\build\packages\obj\i386\sequence.msi
	copy $(SDXROOT)\admin\darwin\build\packages\obj\i386\sequence.msi $@
	$(BINPLACE_CMD)
$(O)\sequence.msi1 : $(SDXROOT)\admin\darwin\data\archive\packages\100\sequence.msi
	copy $(SDXROOT)\admin\darwin\data\archive\packages\100\sequence.msi $@
	$(BINPLACE_CMD)
$(O)\sequence.msi2 : $(SDXROOT)\admin\darwin\data\archive\packages\110\sequence.msi
	copy $(SDXROOT)\admin\darwin\data\archive\packages\110\sequence.msi $@
	$(BINPLACE_CMD)
$(O)\sequence.msi3 : $(SDXROOT)\admin\darwin\data\archive\packages\120\sequence.msi
	copy $(SDXROOT)\admin\darwin\data\archive\packages\120\sequence.msi $@
	$(BINPLACE_CMD)
$(O)\schema.msm : $(SDXROOT)\admin\darwin\build\packages\obj\i386\schema.msm
	copy $(SDXROOT)\admin\darwin\build\packages\obj\i386\schema.msm $@
	$(BINPLACE_CMD)
$(O)\schema.msm1 : $(SDXROOT)\admin\darwin\data\archive\packages\110\schema.msm
	copy $(SDXROOT)\admin\darwin\data\archive\packages\110\schema.msm $@
	$(BINPLACE_CMD)
$(O)\schema.msm2 : $(SDXROOT)\admin\darwin\data\archive\packages\120\schema.msm
	copy $(SDXROOT)\admin\darwin\data\archive\packages\120\schema.msm $@
	$(BINPLACE_CMD)
$(O)\uisample.msi : $(SDXROOT)\admin\darwin\build\packages\obj\i386\uisample.msi
	copy $(SDXROOT)\admin\darwin\build\packages\obj\i386\uisample.msi $@
	$(BINPLACE_CMD)
$(O)\error.ara : $(SDXROOT)\admin\darwin\data\intl\error.ara
	copy $(SDXROOT)\admin\darwin\data\intl\error.ara $@
	$(BINPLACE_CMD)
$(O)\error.cat : $(SDXROOT)\admin\darwin\data\intl\error.cat
	copy $(SDXROOT)\admin\darwin\data\intl\error.cat $@
	$(BINPLACE_CMD)
$(O)\error.chs : $(SDXROOT)\admin\darwin\data\intl\error.chs
	copy $(SDXROOT)\admin\darwin\data\intl\error.chs $@
	$(BINPLACE_CMD)
$(O)\error.cht : $(SDXROOT)\admin\darwin\data\intl\error.cht
	copy $(SDXROOT)\admin\darwin\data\intl\error.cht $@
	$(BINPLACE_CMD)
$(O)\error.csy : $(SDXROOT)\admin\darwin\data\intl\error.csy
	copy $(SDXROOT)\admin\darwin\data\intl\error.csy $@
	$(BINPLACE_CMD)
$(O)\error.dan : $(SDXROOT)\admin\darwin\data\intl\error.dan
	copy $(SDXROOT)\admin\darwin\data\intl\error.dan $@
	$(BINPLACE_CMD)
$(O)\error.deu : $(SDXROOT)\admin\darwin\data\intl\error.deu
	copy $(SDXROOT)\admin\darwin\data\intl\error.deu $@
	$(BINPLACE_CMD)
$(O)\error.ell : $(SDXROOT)\admin\darwin\data\intl\error.ell
	copy $(SDXROOT)\admin\darwin\data\intl\error.ell $@
	$(BINPLACE_CMD)
$(O)\error.enu : $(SDXROOT)\admin\darwin\data\intl\error.enu
	copy $(SDXROOT)\admin\darwin\data\intl\error.enu $@
	$(BINPLACE_CMD)
$(O)\error.esn : $(SDXROOT)\admin\darwin\data\intl\error.esn
	copy $(SDXROOT)\admin\darwin\data\intl\error.esn $@
	$(BINPLACE_CMD)
$(O)\Error.eti : $(SDXROOT)\admin\darwin\data\intl\Error.eti
	copy $(SDXROOT)\admin\darwin\data\intl\Error.eti $@
	$(BINPLACE_CMD)
$(O)\error.euq : $(SDXROOT)\admin\darwin\data\intl\error.euq
	copy $(SDXROOT)\admin\darwin\data\intl\error.euq $@
	$(BINPLACE_CMD)
$(O)\error.fin : $(SDXROOT)\admin\darwin\data\intl\error.fin
	copy $(SDXROOT)\admin\darwin\data\intl\error.fin $@
	$(BINPLACE_CMD)
$(O)\error.fra : $(SDXROOT)\admin\darwin\data\intl\error.fra
	copy $(SDXROOT)\admin\darwin\data\intl\error.fra $@
	$(BINPLACE_CMD)
$(O)\error.heb : $(SDXROOT)\admin\darwin\data\intl\error.heb
	copy $(SDXROOT)\admin\darwin\data\intl\error.heb $@
	$(BINPLACE_CMD)
$(O)\error.hrv : $(SDXROOT)\admin\darwin\data\intl\error.hrv
	copy $(SDXROOT)\admin\darwin\data\intl\error.hrv $@
	$(BINPLACE_CMD)
$(O)\error.hun : $(SDXROOT)\admin\darwin\data\intl\error.hun
	copy $(SDXROOT)\admin\darwin\data\intl\error.hun $@
	$(BINPLACE_CMD)
$(O)\error.idt : $(SDXROOT)\admin\darwin\data\intl\error.idt
	copy $(SDXROOT)\admin\darwin\data\intl\error.idt $@
	$(BINPLACE_CMD)
$(O)\error.ita : $(SDXROOT)\admin\darwin\data\intl\error.ita
	copy $(SDXROOT)\admin\darwin\data\intl\error.ita $@
	$(BINPLACE_CMD)
$(O)\error.jpn : $(SDXROOT)\admin\darwin\data\intl\error.jpn
	copy $(SDXROOT)\admin\darwin\data\intl\error.jpn $@
	$(BINPLACE_CMD)
$(O)\error.kor : $(SDXROOT)\admin\darwin\data\intl\error.kor
	copy $(SDXROOT)\admin\darwin\data\intl\error.kor $@
	$(BINPLACE_CMD)
$(O)\Error.lth : $(SDXROOT)\admin\darwin\data\intl\Error.lth
	copy $(SDXROOT)\admin\darwin\data\intl\Error.lth $@
	$(BINPLACE_CMD)
$(O)\Error.lvi : $(SDXROOT)\admin\darwin\data\intl\Error.lvi
	copy $(SDXROOT)\admin\darwin\data\intl\Error.lvi $@
	$(BINPLACE_CMD)
$(O)\error.nld : $(SDXROOT)\admin\darwin\data\intl\error.nld
	copy $(SDXROOT)\admin\darwin\data\intl\error.nld $@
	$(BINPLACE_CMD)
$(O)\error.nor : $(SDXROOT)\admin\darwin\data\intl\error.nor
	copy $(SDXROOT)\admin\darwin\data\intl\error.nor $@
	$(BINPLACE_CMD)
$(O)\error.plk : $(SDXROOT)\admin\darwin\data\intl\error.plk
	copy $(SDXROOT)\admin\darwin\data\intl\error.plk $@
	$(BINPLACE_CMD)
$(O)\error.ptb : $(SDXROOT)\admin\darwin\data\intl\error.ptb
	copy $(SDXROOT)\admin\darwin\data\intl\error.ptb $@
	$(BINPLACE_CMD)
$(O)\error.ptg : $(SDXROOT)\admin\darwin\data\intl\error.ptg
	copy $(SDXROOT)\admin\darwin\data\intl\error.ptg $@
	$(BINPLACE_CMD)
$(O)\error.rom : $(SDXROOT)\admin\darwin\data\intl\error.rom
	copy $(SDXROOT)\admin\darwin\data\intl\error.rom $@
	$(BINPLACE_CMD)
$(O)\error.rus : $(SDXROOT)\admin\darwin\data\intl\error.rus
	copy $(SDXROOT)\admin\darwin\data\intl\error.rus $@
	$(BINPLACE_CMD)
$(O)\error.sky : $(SDXROOT)\admin\darwin\data\intl\error.sky
	copy $(SDXROOT)\admin\darwin\data\intl\error.sky $@
	$(BINPLACE_CMD)
$(O)\error.slv : $(SDXROOT)\admin\darwin\data\intl\error.slv
	copy $(SDXROOT)\admin\darwin\data\intl\error.slv $@
	$(BINPLACE_CMD)
$(O)\error.sve : $(SDXROOT)\admin\darwin\data\intl\error.sve
	copy $(SDXROOT)\admin\darwin\data\intl\error.sve $@
	$(BINPLACE_CMD)
$(O)\error.tha : $(SDXROOT)\admin\darwin\data\intl\error.tha
	copy $(SDXROOT)\admin\darwin\data\intl\error.tha $@
	$(BINPLACE_CMD)
$(O)\error.trk : $(SDXROOT)\admin\darwin\data\intl\error.trk
	copy $(SDXROOT)\admin\darwin\data\intl\error.trk $@
	$(BINPLACE_CMD)
$(O)\error.vit : $(SDXROOT)\admin\darwin\data\intl\error.vit
	copy $(SDXROOT)\admin\darwin\data\intl\error.vit $@
	$(BINPLACE_CMD)
$(O)\actionte.ara : $(SDXROOT)\admin\darwin\data\intl\actionte.ara
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.ara $@
	$(BINPLACE_CMD)
$(O)\actionte.cat : $(SDXROOT)\admin\darwin\data\intl\actionte.cat
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.cat $@
	$(BINPLACE_CMD)
$(O)\actionte.chs : $(SDXROOT)\admin\darwin\data\intl\actionte.chs
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.chs $@
	$(BINPLACE_CMD)
$(O)\actionte.cht : $(SDXROOT)\admin\darwin\data\intl\actionte.cht
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.cht $@
	$(BINPLACE_CMD)
$(O)\actionte.csy : $(SDXROOT)\admin\darwin\data\intl\actionte.csy
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.csy $@
	$(BINPLACE_CMD)
$(O)\actionte.dan : $(SDXROOT)\admin\darwin\data\intl\actionte.dan
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.dan $@
	$(BINPLACE_CMD)
$(O)\actionte.deu : $(SDXROOT)\admin\darwin\data\intl\actionte.deu
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.deu $@
	$(BINPLACE_CMD)
$(O)\actionte.ell : $(SDXROOT)\admin\darwin\data\intl\actionte.ell
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.ell $@
	$(BINPLACE_CMD)
$(O)\actionte.enu : $(SDXROOT)\admin\darwin\data\intl\actionte.enu
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.enu $@
	$(BINPLACE_CMD)
$(O)\actionte.esn : $(SDXROOT)\admin\darwin\data\intl\actionte.esn
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.esn $@
	$(BINPLACE_CMD)
$(O)\ActionTe.eti : $(SDXROOT)\admin\darwin\data\intl\ActionTe.eti
	copy $(SDXROOT)\admin\darwin\data\intl\ActionTe.eti $@
	$(BINPLACE_CMD)
$(O)\actionte.euq : $(SDXROOT)\admin\darwin\data\intl\actionte.euq
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.euq $@
	$(BINPLACE_CMD)
$(O)\actionte.fin : $(SDXROOT)\admin\darwin\data\intl\actionte.fin
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.fin $@
	$(BINPLACE_CMD)
$(O)\actionte.fra : $(SDXROOT)\admin\darwin\data\intl\actionte.fra
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.fra $@
	$(BINPLACE_CMD)
$(O)\actionte.heb : $(SDXROOT)\admin\darwin\data\intl\actionte.heb
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.heb $@
	$(BINPLACE_CMD)
$(O)\actionte.hrv : $(SDXROOT)\admin\darwin\data\intl\actionte.hrv
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.hrv $@
	$(BINPLACE_CMD)
$(O)\actionte.hun : $(SDXROOT)\admin\darwin\data\intl\actionte.hun
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.hun $@
	$(BINPLACE_CMD)
$(O)\actionte.idt : $(SDXROOT)\admin\darwin\data\intl\actionte.idt
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.idt $@
	$(BINPLACE_CMD)
$(O)\actionte.ita : $(SDXROOT)\admin\darwin\data\intl\actionte.ita
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.ita $@
	$(BINPLACE_CMD)
$(O)\actionte.jpn : $(SDXROOT)\admin\darwin\data\intl\actionte.jpn
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.jpn $@
	$(BINPLACE_CMD)
$(O)\actionte.kor : $(SDXROOT)\admin\darwin\data\intl\actionte.kor
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.kor $@
	$(BINPLACE_CMD)
$(O)\ActionTe.lth : $(SDXROOT)\admin\darwin\data\intl\ActionTe.lth
	copy $(SDXROOT)\admin\darwin\data\intl\ActionTe.lth $@
	$(BINPLACE_CMD)
$(O)\ActionTe.lvi : $(SDXROOT)\admin\darwin\data\intl\ActionTe.lvi
	copy $(SDXROOT)\admin\darwin\data\intl\ActionTe.lvi $@
	$(BINPLACE_CMD)
$(O)\actionte.nld : $(SDXROOT)\admin\darwin\data\intl\actionte.nld
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.nld $@
	$(BINPLACE_CMD)
$(O)\actionte.nor : $(SDXROOT)\admin\darwin\data\intl\actionte.nor
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.nor $@
	$(BINPLACE_CMD)
$(O)\actionte.plk : $(SDXROOT)\admin\darwin\data\intl\actionte.plk
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.plk $@
	$(BINPLACE_CMD)
$(O)\actionte.ptb : $(SDXROOT)\admin\darwin\data\intl\actionte.ptb
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.ptb $@
	$(BINPLACE_CMD)
$(O)\actionte.ptg : $(SDXROOT)\admin\darwin\data\intl\actionte.ptg
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.ptg $@
	$(BINPLACE_CMD)
$(O)\actionte.rom : $(SDXROOT)\admin\darwin\data\intl\actionte.rom
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.rom $@
	$(BINPLACE_CMD)
$(O)\actionte.rus : $(SDXROOT)\admin\darwin\data\intl\actionte.rus
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.rus $@
	$(BINPLACE_CMD)
$(O)\actionte.sky : $(SDXROOT)\admin\darwin\data\intl\actionte.sky
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.sky $@
	$(BINPLACE_CMD)
$(O)\actionte.slv : $(SDXROOT)\admin\darwin\data\intl\actionte.slv
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.slv $@
	$(BINPLACE_CMD)
$(O)\actionte.sve : $(SDXROOT)\admin\darwin\data\intl\actionte.sve
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.sve $@
	$(BINPLACE_CMD)
$(O)\actionte.tha : $(SDXROOT)\admin\darwin\data\intl\actionte.tha
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.tha $@
	$(BINPLACE_CMD)
$(O)\actionte.trk : $(SDXROOT)\admin\darwin\data\intl\actionte.trk
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.trk $@
	$(BINPLACE_CMD)
$(O)\actionte.vit : $(SDXROOT)\admin\darwin\data\intl\actionte.vit
	copy $(SDXROOT)\admin\darwin\data\intl\actionte.vit $@
	$(BINPLACE_CMD)
$(O)\schema.log : $(SDXROOT)\admin\darwin\data\schema.idt\schema.log
	copy $(SDXROOT)\admin\darwin\data\schema.idt\schema.log $@
	$(BINPLACE_CMD)
layout :  $(O)\sdkmake.inc $(O)\sdkpost.mak $(O)\msisdk.msi $(O)\ReadMe.txt $(O)\Redist.txt $(O)\License.rtf $(O)\INSTLR1.ADM $(O)\instlr11.adm $(O)\msi.h $(O)\msiquery.h $(O)\msidefs.h $(O)\patchwiz.h $(O)\patchapi.h $(O)\Mergemod.h $(O)\msi.lib $(O)\mspatchc.lib $(O)\msi.chm $(O)\msi.chi $(O)\msitool.mak $(O)\darice.cub $(O)\logo.cub $(O)\mergemod.cub $(O)\darice.cub1 $(O)\logo.cub1 $(O)\mergemod.cub1 $(O)\preadme.txt $(O)\makecab.exe $(O)\mpatch.exe $(O)\apatch.exe $(O)\mspatchc.dll $(O)\TEMPLATE.PCP $(O)\EXAMPLE.PCP $(O)\WiReadMe.txt $(O)\WiCompon.vbs $(O)\WiDialog.vbs $(O)\WiDiffDb.vbs $(O)\WiExport.vbs $(O)\WiFilVer.vbs $(O)\WiFeatur.vbs $(O)\WiGenXfm.vbs $(O)\WiImport.vbs $(O)\WiLangId.vbs $(O)\WiLstPrd.vbs $(O)\WiLstScr.vbs $(O)\WiLstXfm.vbs $(O)\WiMakCab.vbs $(O)\WiMerge.vbs $(O)\WiPolicy.vbs $(O)\WiRunSQL.vbs $(O)\WiStream.vbs $(O)\WiSubStg.vbs $(O)\WiSumInf.vbs $(O)\WiTextIn.vbs $(O)\WiToAnsi.vbs $(O)\WiUseXfm.vbs $(O)\custact1.cpp $(O)\custexe1.cpp $(O)\tutorial.cpp $(O)\process.cpp $(O)\remove.cpp $(O)\create.cpp $(O)\msiloc.cpp $(O)\msiloc.txt $(O)\msitran.cpp $(O)\msimerg.cpp $(O)\setup.cpp $(O)\setupui.cpp $(O)\upgrdmsi.cpp $(O)\utils.cpp $(O)\vertrust.cpp $(O)\common.h $(O)\resource.h $(O)\setup.h $(O)\setupui.h $(O)\setup.rc $(O)\setup.ico $(O)\msistuff.cpp $(O)\msistuff.rc $(O)\Makefile1 $(O)\ReadMe.htm1 $(O)\Makefile2 $(O)\ReadMe.htm2 $(O)\dbreadme.txt $(O)\schema.msi $(O)\schema.msi1 $(O)\schema.msi2 $(O)\schema.msi3 $(O)\sequence.msi $(O)\sequence.msi1 $(O)\sequence.msi2 $(O)\sequence.msi3 $(O)\schema.msm $(O)\schema.msm1 $(O)\schema.msm2 $(O)\uisample.msi $(O)\error.ara $(O)\error.cat $(O)\error.chs $(O)\error.cht $(O)\error.csy $(O)\error.dan $(O)\error.deu $(O)\error.ell $(O)\error.enu $(O)\error.esn $(O)\Error.eti $(O)\error.euq $(O)\error.fin $(O)\error.fra $(O)\error.heb $(O)\error.hrv $(O)\error.hun $(O)\error.idt $(O)\error.ita $(O)\error.jpn $(O)\error.kor $(O)\Error.lth $(O)\Error.lvi $(O)\error.nld $(O)\error.nor $(O)\error.plk $(O)\error.ptb $(O)\error.ptg $(O)\error.rom $(O)\error.rus $(O)\error.sky $(O)\error.slv $(O)\error.sve $(O)\error.tha $(O)\error.trk $(O)\error.vit $(O)\actionte.ara $(O)\actionte.cat $(O)\actionte.chs $(O)\actionte.cht $(O)\actionte.csy $(O)\actionte.dan $(O)\actionte.deu $(O)\actionte.ell $(O)\actionte.enu $(O)\actionte.esn $(O)\ActionTe.eti $(O)\actionte.euq $(O)\actionte.fin $(O)\actionte.fra $(O)\actionte.heb $(O)\actionte.hrv $(O)\actionte.hun $(O)\actionte.idt $(O)\actionte.ita $(O)\actionte.jpn $(O)\actionte.kor $(O)\ActionTe.lth $(O)\ActionTe.lvi $(O)\actionte.nld $(O)\actionte.nor $(O)\actionte.plk $(O)\actionte.ptb $(O)\actionte.ptg $(O)\actionte.rom $(O)\actionte.rus $(O)\actionte.sky $(O)\actionte.slv $(O)\actionte.sve $(O)\actionte.tha $(O)\actionte.trk $(O)\actionte.vit $(O)\schema.log
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\sdk\makefile.inc ===
!include ..\make.inc

ALT_PROJECT_TARGET=instmsi\msitools

BaseAll: \
	$(BUILD_PACKAGEDIR)\msisdk.msi \
	layout \
	$(O)\sdkmake.inc
        
#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\msisdk.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(MSISDK_IDT)\*.idt
	echo BUILD_PACKAGEDIR=$(BUILD_PACKAGEDIR)
	msidb.exe -i -f$(MSISDK_IDT) -c -d$@ *.idt
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `InstallExecuteSequence`"
	CScript $(WSHTOOLS)\wimerge.vbs $@ $(BUILD_PACKAGEDIR)\uisample.msi
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `InstallExecuteSequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `AdminUISequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `AdminExecuteSequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `AdvtExecuteSequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "UPDATE `Property` SET `Value`=0 WHERE `Property`='ShowUserRegistrationDlg'"
	CScript $(WSHTOOLS)\wiimport.vbs $@ $(MSISDK_IDT) installe.idt
	CScript $(WSHTOOLS)\witextin.vbs $@ Control LicenseAgreementDlg:AgreementText Text $(MSI_DIR)\src\sdk\license.rtf
	CScript $(WSHTOOLS)\wisuminf.vbs $@ 11=Date 12=Date


#-----------------------------------------------------------------------------
# the raw files must be binplaced into the _NTTREE.  Postbuild can't see the source tree
# and we're not supposed to copy thing directly into _NTTREE.
!INCLUDE "layout.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\sdk\sdkmake.inc ===
sdk\LIB\patchwiz.lib : 
	if not exist sdk\LIB md sdk\LIB
	copy $(_NTPOSTBLD)\msiwin9x\dump\patchwiz.lib $@
sdk\WEB\MsiStuff.exe : 
	if not exist sdk\WEB md sdk\WEB
	copy $(_NTPOSTBLD)\dump\MsiStuff.exe $@
sdk\WEB\Setup.exe : 
	if not exist sdk\WEB md sdk\WEB
	copy $(_NTPOSTBLD)\msiwin9x\Setup.exe $@
sdk\TOOLS\mergemod.dll : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\dump\mergemod.dll $@
sdk\TOOLS\MsiMig.dll : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\MsiMig.dll $@
sdk\TOOLS\MsiMig.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\MsiMig.exe $@
sdk\TOOLS\orca.msi : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\instmsi\msitools\temp\orca.msi $@
sdk\TOOLS\msival2.msi : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\instmsi\msitools\temp\msival2.msi $@
sdk\TOOLS\MsiCert.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\MsiCert.exe $@
sdk\TOOLS\msidb.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9X\mstools\msidb.exe $@
sdk\TOOLS\msifiler.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\mstools\msifiler.exe $@
sdk\TOOLS\MsiInfo.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\MsiInfo.exe $@
sdk\TOOLS\MsiMerg.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\MsiMerg.exe $@
sdk\TOOLS\msitran.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\msitran.exe $@
sdk\TOOLS\MsiZap.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\MsiZap.exe $@
sdk\TOOLS\wilogutl.exe : 
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $(_NTPOSTBLD)\msiwin9x\dump\wilogutl.exe $@
sdk\TOOLS\120\darice.cub : 1sdk\TOOLS\120\darice.cub1
	if not exist sdk\TOOLS\120 md sdk\TOOLS\120
	copy 1sdk\TOOLS\120\darice.cub1 $@
sdk\TOOLS\120\logo.cub : 1sdk\TOOLS\120\logo.cub1
	if not exist sdk\TOOLS\120 md sdk\TOOLS\120
	copy 1sdk\TOOLS\120\logo.cub1 $@
sdk\TOOLS\120\mergemod.cub : 1sdk\TOOLS\120\mergemod.cub1
	if not exist sdk\TOOLS\120 md sdk\TOOLS\120
	copy 1sdk\TOOLS\120\mergemod.cub1 $@
sdk\PATCHING\patchwiz.dll : 
	if not exist sdk\PATCHING md sdk\PATCHING
	copy $(_NTPOSTBLD)\msiwin9x\dump\patchwiz.dll $@
sdk\PATCHING\MsiMsp.exe : 
	if not exist sdk\PATCHING md sdk\PATCHING
	copy $(_NTPOSTBLD)\msiwin9x\dump\MsiMsp.exe $@
sdk\SAMPLES\setup.exe\Makefile : 1sdk\SAMPLES\setup.exe\Makefile1
	if not exist sdk\SAMPLES\setup.exe md sdk\SAMPLES\setup.exe
	copy 1sdk\SAMPLES\setup.exe\Makefile1 $@
sdk\SAMPLES\setup.exe\ReadMe.htm : 1sdk\SAMPLES\setup.exe\ReadMe.htm1
	if not exist sdk\SAMPLES\setup.exe md sdk\SAMPLES\setup.exe
	copy 1sdk\SAMPLES\setup.exe\ReadMe.htm1 $@
sdk\SAMPLES\MsiStuff\Makefile : 2sdk\SAMPLES\MsiStuff\Makefile2
	if not exist sdk\SAMPLES\MsiStuff md sdk\SAMPLES\MsiStuff
	copy 2sdk\SAMPLES\MsiStuff\Makefile2 $@
sdk\SAMPLES\MsiStuff\ReadMe.htm : 2sdk\SAMPLES\MsiStuff\ReadMe.htm2
	if not exist sdk\SAMPLES\MsiStuff md sdk\SAMPLES\MsiStuff
	copy 2sdk\SAMPLES\MsiStuff\ReadMe.htm2 $@
sdk\DATABASE\100\schema.msi : 1sdk\DATABASE\100\schema.msi1
	if not exist sdk\DATABASE\100 md sdk\DATABASE\100
	copy 1sdk\DATABASE\100\schema.msi1 $@
sdk\DATABASE\110\schema.msi : 2sdk\DATABASE\110\schema.msi2
	if not exist sdk\DATABASE\110 md sdk\DATABASE\110
	copy 2sdk\DATABASE\110\schema.msi2 $@
sdk\DATABASE\120\schema.msi : 3sdk\DATABASE\120\schema.msi3
	if not exist sdk\DATABASE\120 md sdk\DATABASE\120
	copy 3sdk\DATABASE\120\schema.msi3 $@
sdk\DATABASE\100\sequence.msi : 1sdk\DATABASE\100\sequence.msi1
	if not exist sdk\DATABASE\100 md sdk\DATABASE\100
	copy 1sdk\DATABASE\100\sequence.msi1 $@
sdk\DATABASE\110\sequence.msi : 2sdk\DATABASE\110\sequence.msi2
	if not exist sdk\DATABASE\110 md sdk\DATABASE\110
	copy 2sdk\DATABASE\110\sequence.msi2 $@
sdk\DATABASE\120\sequence.msi : 3sdk\DATABASE\120\sequence.msi3
	if not exist sdk\DATABASE\120 md sdk\DATABASE\120
	copy 3sdk\DATABASE\120\sequence.msi3 $@
sdk\DATABASE\110\schema.msm : 1sdk\DATABASE\110\schema.msm1
	if not exist sdk\DATABASE\110 md sdk\DATABASE\110
	copy 1sdk\DATABASE\110\schema.msm1 $@
sdk\DATABASE\120\schema.msm : 2sdk\DATABASE\120\schema.msm2
	if not exist sdk\DATABASE\120 md sdk\DATABASE\120
	copy 2sdk\DATABASE\120\schema.msm2 $@
sdk\REDIST\WIN9X\InstMsi.exe : 
	if not exist sdk\REDIST\WIN9X md sdk\REDIST\WIN9X
	copy $(_NTPOSTBLD)\instmsi\ansi\InstMsi.exe $@
sdk\REDIST\WINNT\InstMsi.exe : 
	if not exist sdk\REDIST\WINNT md sdk\REDIST\WINNT
	copy $(_NTPOSTBLD)\instmsi\unicode\InstMsi.exe $@
sdklayout :  sdk\LIB\patchwiz.lib sdk\WEB\MsiStuff.exe sdk\WEB\Setup.exe sdk\TOOLS\mergemod.dll sdk\TOOLS\MsiMig.dll sdk\TOOLS\MsiMig.exe sdk\TOOLS\orca.msi sdk\TOOLS\msival2.msi sdk\TOOLS\MsiCert.exe sdk\TOOLS\msidb.exe sdk\TOOLS\msifiler.exe sdk\TOOLS\MsiInfo.exe sdk\TOOLS\MsiMerg.exe sdk\TOOLS\msitran.exe sdk\TOOLS\MsiZap.exe sdk\TOOLS\wilogutl.exe sdk\TOOLS\120\darice.cub sdk\TOOLS\120\logo.cub sdk\TOOLS\120\mergemod.cub sdk\PATCHING\patchwiz.dll sdk\PATCHING\MsiMsp.exe sdk\SAMPLES\setup.exe\Makefile sdk\SAMPLES\setup.exe\ReadMe.htm sdk\SAMPLES\MsiStuff\Makefile sdk\SAMPLES\MsiStuff\ReadMe.htm sdk\DATABASE\100\schema.msi sdk\DATABASE\110\schema.msi sdk\DATABASE\120\schema.msi sdk\DATABASE\100\sequence.msi sdk\DATABASE\110\sequence.msi sdk\DATABASE\120\sequence.msi sdk\DATABASE\110\schema.msm sdk\DATABASE\120\schema.msm sdk\REDIST\WIN9X\InstMsi.exe sdk\REDIST\WINNT\InstMsi.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\testdb.idt\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\testdb.idt\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\testdb.idt\sources.inc ===
!INCLUDE ..\..\..\Src\MsiMake.inc
TARGETNAME=
TARGETTYPE=DYNLINK

!if "$(MAKEDLL)"=="1"
NTTARGETFILE0=testdb
!endif

SOURCES=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\testdb.idt\make.inc ===
!include ..\..\make.inc

testdb: \
        $(BUILD_PACKAGEDIR)\testdb.msi  \
        $(BUILD_PACKAGEDIR)\uitestdb.msi 

#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\testdb.msi: $(TESTDB_IDT)\*.idt $(BUILD_PACKAGEDIR)\template.msi $(BUILD_PACKAGEDIR)\simple.msi
	if not exist $(BUILD_PACKAGEDIR) md $(BUILD_PACKAGEDIR)
	msidb.exe -d$@ -f$(TESTDB_IDT) -m$(BUILD_PACKAGEDIR)\template.msi -c -i *.idt
	msidb.exe -d$@ -f$(TESTDB_IDT) -r$(BUILD_PACKAGEDIR)\simple.msi 
!if "$(PLATFORM)" == "MERCED"
	echo $(TOOLBUILDDIR)\msiinfo.exe $@ /p "IA64;1033"
	$(TOOLBUILDDIR)\msiinfo.exe $@ /p "IA64;1033"
!endif

$(BUILD_PACKAGEDIR)\uitestdb.msi: $(TESTDB_IDT)\*.idt $(UISAMPLE_IDT)\*.idt $(SCHEMA_IDT)\_validat.idt $(BUILD_PACKAGEDIR)\uisample.msi $(BUILD_PACKAGEDIR)\simple.msi
	if not exist $(BUILD_PACKAGEDIR) md $(BUILD_PACKAGEDIR)
	msidb.exe -d$@ -f$(TESTDB_IDT) -m$(BUILD_PACKAGEDIR)\uisample.msi -c -i *.idt
	msidb.exe -d$@ -f$(TESTDB_IDT) -r$(BUILD_PACKAGEDIR)\simple.msi 
	msidb.exe -d$@ -f$(UISAMPLE_IDT) -i a*.idt bbcontro.idt billboar.idt c*.idt d*.idt e*.idt installu.idt l*.idt r*.idt t*.idt
	msidb.exe -i -f$(SCHEMA_IDT) -d$@ _validat.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\data\uisample.idt\makefile.inc ===
UISAMPLE_IDT=$(MSI_DATA_DIR)\uisample.idt
SCHEMA_IDT=$(MSI_DATA_DIR)\schema.idt
MSI_INTLDATA_DIR=$(MSI_DATA_DIR)\intl

UISample: $(BUILD_PACKAGEDIR)\uisample.msi

$(O)\error.idt: $(MSI_INTLDATA_DIR)\error.enu
	copy $(MSI_INTLDATA_DIR)\error.enu $(O)\error.idt
        
$(O)\actionte.idt: $(MSI_INTLDATA_DIR)\actionte.enu
        copy $(MSI_INTLDATA_DIR)\actionte.enu $(O)\actionte.idt

$(BUILD_PACKAGEDIR)\uisample.msi: $(UISAMPLE_IDT)\*.idt $(SCHEMA_IDT)\_validat.idt $(O)\error.idt $(O)\actionte.idt
	if not exist $(BUILD_PACKAGEDIR) md $(BUILD_PACKAGEDIR)
	msidb.exe -i -f$(UISAMPLE_IDT) -c -d$@ *.idt
	msidb.exe -i -f$(SCHEMA_IDT) -d$@ _validat.idt
	msidb.exe -f $(UISAMPLE_IDT)\$(O) -i -d$@ error.idt actionte.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\auto\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\auto\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msimake.inc ===
MSI_C_DEFINES=-DSTRICT -D"_WIN32_MSI=200" -D_WIN32_DCOM

!if !$(FREEBUILD)
MSI_C_DEFINES=$(MSI_C_DEFINES) -DDEBUG
USE_RTTI=1
# MSI_BROWSER_INFO=1
!endif

!if "$(MSI_BUILD_UNICODE)"=="1"
MSI_C_DEFINES=$(MSI_C_DEFINES) -DUNICODE -D_UNICODE
MSI_SUBDIR=unicode
!if "$(MSI_BUILD_LEGACY)"=="1"
MSI_LEGACY_SUBDIR=legacy
!endif
MSI_WINENTRY=wwinmain
MSI_ENTRY=wmain
!else
MSI_SUBDIR=ansi
ALT_PROJECT_TARGET=msiwin9x
MSI_WINENTRY=winmain
MSI_ENTRY=main
NO_NTDLL=1
!endif

386_STDCALL=0

DARWIN_ROOT=$(PROJECT_ROOT)\Darwin
BUILD_ROOT=Build
MSI_DIR=$(DARWIN_ROOT)

!if "$(MSI_BUILD_LEGACY)"=="1"
MSI_TARGETPATH=$(MSI_DIR)\$(BUILD_ROOT)\$(MSI_LEGACY_SUBDIR)
MSI_UNICODE_TARGETPATH=$(MSI_DIR)\$(BUILD_ROOT)\$(MSI_SUBDIR)
!else
MSI_TARGETPATH=$(MSI_DIR)\$(BUILD_ROOT)\$(MSI_SUBDIR)
!endif

MSI_BUILD_TARGET=$(MSI_TARGETPATH)\$(_OBJ_DIR)
!if "$(MSI_BUILD_LEGACY)"=="1"
MSI_UNICODE_BUILD_TARGET=$(MSI_UNICODE_TARGETPATH)\$(_OBJ_DIR)
!endif

TARGETPATH=$(MSI_BUILD_TARGET)

SRC_DIR=$(MSI_DIR)\src
INC_DIR=$(SRC_DIR)\inc
ENGINE_DIR=$(SRC_DIR)\Engine

MSI_LIB_PATH=$(MSI_DIR)\lib\$(TARGET_DIRECTORY)

IDL_DIR=$(SRC_DIR)\Idl
!if "$(MSI_BUILD_LEGACY)"=="1"
IDL_OBJDIR=$(IDL_DIR)\$(MSI_LEGACY_SUBDIR)\$(O)
!else
IDL_OBJDIR=$(IDL_DIR)\$(MSI_SUBDIR)\$(O)
!endif

RES_DIR=$(SRC_DIR)\Res
RES_OBJDIR=$(RES_DIR)\$(MSI_SUBDIR)\$(O)

AUTO_DIR=$(SRC_DIR)\Auto
AUTO_OBJDIR=$(AUTO_DIR)\$(MSI_SUBDIR)\$(O)

BUILD_DIR=$(MSI_TARGETPATH)\$(O)
COMMON_DIR=$(MSI_DIR)\$(BUILD_ROOT)\Common
TARGETPATH_COMMON=$(COMMON_DIR)\$(_OBJ_DIR)
BUILD_COMMONDIR=$(COMMON_DIR)\$(O)
BUILD_COMMONTOOLSDIR=$(BUILD_COMMONDIR)
BUILD_PACKAGEROOT=$(MSI_DIR)\$(BUILD_ROOT)\Packages
BUILD_PACKAGEDIR=$(BUILD_PACKAGEROOT)\$(O)
HELP_DIR=$(SRC_DIR)\Help

TOOLS_DIR=$(MSI_DIR)\Tools
TOOLS_INC_DIR=$(TOOLS_DIR)\inc
MSI_TOOLS_DIR=$(SRC_DIR)\MsiTools
MSI_BUILDTOOLS_DIR=$(SRC_DIR)\BuildTools
MSI_DATA_DIR=$(MSI_DIR)\Data
MSI_INTLDATA_DIR=$(MSI_DATA_DIR)\intl
SCHEMA_IDT=$(MSI_DATA_DIR)\schema.idt
MSI_BIN_PATH=$(MSI_DIR)\Bin

ICESRC=$(MSI_TOOLS_DIR)\iceman\ices

MSI_SPYDIR=$(MSI_TOOLS_DIR)\MsiSpy
MSI_SPYRES_DIR=$(MSI_SPYDIR)\SpyRes
MSI_SPYINC_DIR=$(MSI_SPYDIR)\SpyInc

MSI_CMDPARSE_DIR=$(MSI_TOOLS_DIR)\cmdparse

C_DEFINES=$(MSI_C_DEFINES)
USER_C_FLAGS=-J

INCLUDES=$(INCLUDES);$(COM_INC_PATH);$(WINDOWS_INC_PATH);$(TERMSRV_INC_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\auto\sources.inc ===
!INCLUDE ..\..\MsiMake.inc
TARGETNAME=msiauto
TARGETTYPE=DYNLINK

NTTARGETFILE0=AutoRes

USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msiauto.def

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(AUTO_OBJDIR)\auto.res

INCLUDES=\
	$(INCLUDES);\
	$(INC_DIR);\
	$(IDL_OBJDIR);\
	$(HELP_DIR);\
	$(TOOLS_INC_DIR);\
	$(RES_OBJDIR);\
	$(ADMIN_INC_PATH)

SOURCES=..\autocom.cpp \
	..\autosrv.cpp \
	..\script.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\auto\autosrv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       autosrv.cpp
//
//--------------------------------------------------------------------------

//
// File: autosrv.cpp
// Purpose: Automation wrappers for services classes
//____________________________________________________________________________
#include "common.h"    // must be first for precompiled headers to work
#include "autocom.h"   // automation server defines and implemetation
#include "msidspid.h"  // MSI dispatch IDs
#include "msiauto.hh"  // help context ID definitions
#include "engine.h"

#ifdef CONFIGDB // until moved into msidspid.h and msiauto.hh
#include "configdb.h"
#define DISPID_MsiConfigurationDatabase_InsertFile            1
#define DISPID_MsiConfigurationDatabase_RemoveFile            2
#define DISPID_MsiConfigurationDatabase_LookupFile            3
#define DISPID_MsiConfigurationDatabase_EnumClient            4
#define DISPID_MsiConfigurationDatabase_Commit                5
#define MsiConfigurationDatabase_Object                    3300
#define MsiConfigurationDatabase_InsertFile                3301
#define MsiConfigurationDatabase_RemoveFile                3302
#define MsiConfigurationDatabase_LookupFile                3303
#define MsiConfigurationDatabase_EnumClient                3304
#define MsiConfigurationDatabase_Commit                    3305
const GUID IID_IMsiConfigurationDatabase = GUID_IID_IMsiConfigurationDatabase;
#endif // CONFIGDB

extern const GUID IID_IMsiEngine;    // defined in autocom.cpp
extern const GUID IID_IMsiHandler;   // defined in autocom.cpp
extern const GUID IID_IMsiMessage;   // defined in autocom.cpp
extern const GUID IID_IMsiConfigurationManager;

int g_cServicesUsers = 0;

const GUID IID_IMsiString     = GUID_IID_IMsiString;
const GUID IID_IMsiRecord     = GUID_IID_IMsiRecord;
const GUID IID_IEnumMsiRecord = GUID_IID_IEnumMsiRecord;
const GUID IID_IMsiView       = GUID_IID_IMsiView;
const GUID IID_IMsiVolume     = GUID_IID_IMsiVolume;
const GUID IID_IEnumMsiVolume = GUID_IID_IEnumMsiVolume;
const GUID IID_IMsiPath       = GUID_IID_IMsiPath;
const GUID IID_IMsiFileCopy   = GUID_IID_IMsiFileCopy;
const GUID IID_IMsiDatabase   = GUID_IID_IMsiDatabase;
const GUID IID_IMsiRegKey     = GUID_IID_IMsiRegKey;
const GUID IID_IMsiTable      = GUID_IID_IMsiTable;
const GUID IID_IMsiCursor     = GUID_IID_IMsiCursor;
const GUID IID_IMsiStorage    = GUID_IID_IMsiStorage;
const GUID IID_IMsiStream     = GUID_IID_IMsiStream;
const GUID IID_IMsiMemoryStream = GUID_IID_IMsiStream;
const GUID IID_IMsiMalloc     = GUID_IID_IMsiMalloc;
const GUID IID_IMsiDebugMalloc= GUID_IID_IMsiDebugMalloc;
const GUID IID_IMsiSelectionManager = GUID_IID_IMsiSelectionManager;
const GUID IID_IMsiDirectoryManager = GUID_IID_IMsiDirectoryManager;
const GUID IID_IMsiDialogHandler = GUID_IID_IMsiDialogHandler;
const GUID IID_IMsiDialog     = GUID_IID_IMsiDialog;
const GUID IID_IMsiEvent      = GUID_IID_IMsiEvent;
const GUID IID_IMsiControl    = GUID_IID_IMsiControl;
const GUID IID_IMsiMessage    = GUID_IID_IMsiMessage;

//____________________________________________________________________________
//
// Automation wrapper class definitions
//____________________________________________________________________________

class CAutoServices : public CAutoBase
{
 public:
	CAutoServices(IMsiServices& riServices);
	~CAutoServices();
	IUnknown& GetInterface();
	void CreateString              (CAutoArgs& args);
	void CreateRecord              (CAutoArgs& args);
	void Property                  (CAutoArgs& args);
	void SetPlatformProperties     (CAutoArgs& args);
	void GetShellFolderPath        (CAutoArgs& args);
	void GetUserProfilePath        (CAutoArgs& args);
	void ExtractFileName           (CAutoArgs& args);
	void ValidateFileName          (CAutoArgs& args);
	void CreateLog                 (CAutoArgs& args);
	void WriteLog                  (CAutoArgs& args);
	void LoggingEnabled            (CAutoArgs& args);
	void CreateDatabase            (CAutoArgs& args);
	void CreateDatabaseFromStorage (CAutoArgs& args);
	void CreatePath                (CAutoArgs& args);
	void CreateVolume              (CAutoArgs& args);
	void CreateVolumeFromLabel     (CAutoArgs& args);
	void CreateCopier              (CAutoArgs& args);
	void CreatePatcher             (CAutoArgs& args);
	void ClearAllCaches            (CAutoArgs& args);
	void EnumDriveType             (CAutoArgs& args);
	void GetModuleUsage            (CAutoArgs& args);
	void CreateRegKey              (CAutoArgs& args);
	void RegisterFont              (CAutoArgs& args);
	void UnRegisterFont            (CAutoArgs& args);
	void WriteIniFile              (CAutoArgs& args);
	void ReadIniFile               (CAutoArgs& args);
	void GetLocalPath              (CAutoArgs& args);
	void GetAllocator              (CAutoArgs& args);
	void GetLangNamesFromLangIDString(CAutoArgs& args);
	void CreateStorage             (CAutoArgs& args);
	void GetUnhandledError         (CAutoArgs& args);
	void SupportLanguageId         (CAutoArgs& args);
	void CreateShortcut            (CAutoArgs& args);
	void RemoveShortcut            (CAutoArgs& args);
	void CreateFileStream          (CAutoArgs& args);
	void CreateMemoryStream        (CAutoArgs& args);
	void RegisterTypeLibrary       (CAutoArgs& args);
	void UnregisterTypeLibrary     (CAutoArgs& args);
	void CreateFilePath            (CAutoArgs& args);
	void RipFileNameFromPath       (CAutoArgs& args);
	void TestEmbeddedNullsInStrings(CAutoArgs& args);
 private:
	IMsiServices& m_riServices;
	IMsiDatabase* m_riDefaultDatabase; //!! not needed
 private: // eliminate warning
	void operator =(CAutoServices&){}
};

class CAutoData : public CAutoBase
{
 public:
	CAutoData(const IMsiData* piData);
	~CAutoData();
	IUnknown& GetInterface();
	void StringValue   (CAutoArgs& args);
	void IntegerValue  (CAutoArgs& args);
 private:
	const IMsiData* m_piData;
};

class CAutoString : public CAutoBase
{
 public:
	CAutoString(const IMsiString& riString);
	~CAutoString();
	IUnknown& GetInterface();
	void Value         (CAutoArgs& args);
	void IntegerValue  (CAutoArgs& args);
	void TextSize      (CAutoArgs& args);
	void CharacterCount(CAutoArgs& args);
	void IsDBCS        (CAutoArgs& args);
	void Compare       (CAutoArgs& args);
	void Append        (CAutoArgs& args);
	void Add           (CAutoArgs& args);
	void Extract       (CAutoArgs& args);
	void Remove        (CAutoArgs& args);
	void UpperCase     (CAutoArgs& args);
	void LowerCase     (CAutoArgs& args);
 private:
	const IMsiString* m_piString;
};

class CAutoRecord : public CAutoBase
{
 public:
	CAutoRecord(IMsiRecord& riRecord);
	~CAutoRecord();
	IUnknown& GetInterface();
	void Data       (CAutoArgs& args);
	void StringData (CAutoArgs& args);
	void IntegerData(CAutoArgs& args);
	void ObjectData (CAutoArgs& args);
	void FieldCount (CAutoArgs& args);
	void IsInteger  (CAutoArgs& args);
	void IsNull     (CAutoArgs& args);
	void IsChanged  (CAutoArgs& args);
	void TextSize   (CAutoArgs& args);
	void FormatText (CAutoArgs& args);
	void ClearData  (CAutoArgs& args);
	void ClearUpdate(CAutoArgs& args);
 private:
	IMsiRecord& m_riRecord;
 private: // suppress warning
	void operator =(CAutoRecord&){}
};

class CAutoVolume : public CAutoBase
{
 public:
	CAutoVolume(IMsiVolume& riVolume);
	~CAutoVolume();
	IUnknown& GetInterface();
	void Path          (CAutoArgs& args);
	void VolumeID      (CAutoArgs& args);
	void DriveType     (CAutoArgs& args);
	void SupportsLFN   (CAutoArgs& args);
	void FreeSpace     (CAutoArgs& args);
	void TotalSpace    (CAutoArgs& args);
	void ClusterSize   (CAutoArgs& args);
	void FileSystem    (CAutoArgs& args);
	void FileSystemFlags(CAutoArgs& args);
	void VolumeLabel   (CAutoArgs& args);
	void UNCServer     (CAutoArgs& args);
	void SerialNum     (CAutoArgs& args);
	void DiskNotInDrive(CAutoArgs& args);
 private:
	IMsiVolume& m_riVolume;
 private: // suppress warning
	void operator =(CAutoVolume&){}
};

class CAutoPath : public CAutoBase
{
 public:
	~CAutoPath();
	CAutoPath(IMsiPath& riPath);
	IUnknown& GetInterface();
	void Path            (CAutoArgs& args);
	void RelativePath    (CAutoArgs& args);
	void Volume          (CAutoArgs& args);
	void AppendPiece     (CAutoArgs& args);
	void ChopPiece       (CAutoArgs& args);
	void FileExists      (CAutoArgs& args);
	void GetFullFilePath (CAutoArgs& args);
	void GetFileAttribute(CAutoArgs& args);
	void SetFileAttribute(CAutoArgs& args);
	void Exists          (CAutoArgs& args);
	void FileSize        (CAutoArgs& args);
	void FileDate        (CAutoArgs& args);
	void RemoveFile      (CAutoArgs& args);
	void Create          (CAutoArgs& args);
	void Remove          (CAutoArgs& args);
	void Writable        (CAutoArgs& args);
	void FileWritable    (CAutoArgs& args);
	void FileInUse              (CAutoArgs& args);
	void ClusteredFileSize      (CAutoArgs& args);
	void GetFileVersionString   (CAutoArgs& args); 
	void CheckFileVersion       (CAutoArgs& args);
	void GetLangIDStringFromFile(CAutoArgs& args);
	void CheckLanguageIDs       (CAutoArgs& args);
	void Compare                (CAutoArgs& args);
	void Child                  (CAutoArgs& args);
	void TempFileName           (CAutoArgs& args);
	void EnsureExists           (CAutoArgs& args);
	void FindFile				(CAutoArgs& args);
	void SubFolders      		(CAutoArgs& args);
	void EndSubPath				(CAutoArgs& args);
	void GetImportModulesEnum   (CAutoArgs& args);
	void SetVolume              (CAutoArgs& args);
	void ComputeFileChecksum    (CAutoArgs& args);
	void GetFileOriginalChecksum(CAutoArgs& args);
	void BindImage              (CAutoArgs& args);
	void SupportsLFN            (CAutoArgs& args);
	void GetFullUNCFilePath     (CAutoArgs& args);
	void RipFileNameFromPath    (CAutoArgs& args);
	void GetSelfRelativeSD      (CAutoArgs& args);
 private:
	IMsiPath& m_riPath;
 private: // suppress warning
	void operator =(CAutoPath&){}
};

class CAutoFileCopy : public CAutoBase
{
 public:
	CAutoFileCopy(IMsiFileCopy& riFileCopy);
	~CAutoFileCopy();
	IUnknown& GetInterface();
	void CopyTo(CAutoArgs& args);
	void ChangeMedia(CAutoArgs& args);
 private:
	IMsiFileCopy& m_riFileCopy;
 private: // suppress warning
	void operator =(CAutoFileCopy&){}
};

class CAutoFilePatch : public CAutoBase
{
 public:
	CAutoFilePatch(IMsiFilePatch& riFilePatch);
	~CAutoFilePatch();
	IUnknown& GetInterface();
	void ApplyPatch(CAutoArgs& args);
	void ContinuePatch(CAutoArgs& args);
	void CancelPatch(CAutoArgs& args);
	void CanPatchFile(CAutoArgs& args);
 private:
	IMsiFilePatch& m_riFilePatch;
 private: // suppress warning
	void operator =(CAutoFilePatch&){}
};

class CAutoStorage : public CAutoBase
{
 public:
	CAutoStorage(IMsiStorage& riStorage);
	~CAutoStorage();
	IUnknown& GetInterface();
	void Class              (CAutoArgs& args);
	void OpenStream         (CAutoArgs& args);
	void OpenStorage        (CAutoArgs& args);
	void Streams            (CAutoArgs& args);
	void Storages           (CAutoArgs& args);
	void RemoveElement      (CAutoArgs& args);
	void RenameElement      (CAutoArgs& args);
	void Commit             (CAutoArgs& args);
	void Rollback           (CAutoArgs& args);
	void DeleteOnRelease    (CAutoArgs& args);
	void CreateSummaryInfo  (CAutoArgs& args);
	void CopyTo             (CAutoArgs& args);
	void Name               (CAutoArgs& args);
 private:
	IMsiStorage& m_riStorage;
 private: // suppress warning
	void operator =(CAutoStorage&){}
};

class CAutoStream : public CAutoBase
{
 public:
	CAutoStream(IMsiStream& riStream);
	~CAutoStream();
	IUnknown& GetInterface();
	void Length   (CAutoArgs& args);
	void Remaining(CAutoArgs& args);
	void Error    (CAutoArgs& args);
	void GetData  (CAutoArgs& args);
	void PutData  (CAutoArgs& args);
	void GetInt16 (CAutoArgs& args);
	void GetInt32 (CAutoArgs& args);
	void PutInt16 (CAutoArgs& args);
	void PutInt32 (CAutoArgs& args);
	void Reset    (CAutoArgs& args);
	void Seek     (CAutoArgs& args);
	void Clone    (CAutoArgs& args);
 private:
	IMsiStream& m_riStream;
 private: // suppress warning
	void operator =(CAutoStream&){}
};

class CAutoSummaryInfo : public CAutoBase
{
 public:
	CAutoSummaryInfo(IMsiSummaryInfo& riSummaryInfo);
	~CAutoSummaryInfo();
	IUnknown& GetInterface();
	void Property           (CAutoArgs& args);
	void PropertyCount      (CAutoArgs& args);
	void PropertyType       (CAutoArgs& args);
	void WritePropertyStream(CAutoArgs& args);
 private:
	IMsiSummaryInfo& m_riSummary;
 private: // suppress warning
	void operator =(CAutoSummaryInfo&){}
};

class CAutoDatabase : public CAutoBase
{
 public:
	CAutoDatabase(IMsiDatabase& riDatabase);
	~CAutoDatabase();
	IUnknown& GetInterface();
	void UpdateState         (CAutoArgs& args);
	void Storage             (CAutoArgs& args);
	void OpenView            (CAutoArgs& args);
	void GetPrimaryKeys      (CAutoArgs& args);
	void ImportTable         (CAutoArgs& args);
	void ExportTable         (CAutoArgs& args);
	void DropTable           (CAutoArgs& args);
	void FindTable           (CAutoArgs& args);
	void LoadTable           (CAutoArgs& args);
	void CreateTable         (CAutoArgs& args);
	void LockTable           (CAutoArgs& args);
	void GetCatalogTable     (CAutoArgs& args);
	void DecodeString        (CAutoArgs& args);
	void EncodeString        (CAutoArgs& args);
	void CreateTempTableName (CAutoArgs& args);
	void Commit              (CAutoArgs& args);
	void CreateOutputDatabase(CAutoArgs& args);
	void GenerateTransform   (CAutoArgs& args);
	void SetTransform        (CAutoArgs& args);
	void MergeDatabase       (CAutoArgs& args);
	void TableState          (CAutoArgs& args);
	void ANSICodePage        (CAutoArgs& args);
 private:
	IMsiDatabase& m_riDatabase;
 private: // suppress warning
	void operator =(CAutoDatabase&){}
};

class CAutoView : public CAutoBase
{
 public:
	CAutoView(IMsiView& riView);
	~CAutoView();
	IUnknown& GetInterface();
	void Execute       (CAutoArgs& args);
	void FieldCount    (CAutoArgs& args);
	void GetColumnNames(CAutoArgs& args);
	void GetColumnTypes(CAutoArgs& args);
	void Fetch         (CAutoArgs& args);
	void Modify        (CAutoArgs& args);
	void RowCount      (CAutoArgs& args);
	void Close         (CAutoArgs& args);
	void GetError      (CAutoArgs& args);
	void State         (CAutoArgs& args);
 private:
	IMsiView& m_riView;
 private: // suppress warning
	void operator =(CAutoView&){}
};

class CAutoTable : public CAutoBase
{
 public:
	CAutoTable(IMsiTable& riTable);
	~CAutoTable();
	IUnknown& GetInterface();
	void Database        (CAutoArgs& args);
	void RowCount        (CAutoArgs& args);
	void ColumnCount     (CAutoArgs& args);
	void PrimaryKeyCount (CAutoArgs& args);
	void ReadOnly        (CAutoArgs& args);
	void ColumnName      (CAutoArgs& args);
	void ColumnType      (CAutoArgs& args);
	void GetColumnIndex  (CAutoArgs& args);
	void CreateColumn    (CAutoArgs& args);
	void CreateCursor    (CAutoArgs& args);
	void LinkTree        (CAutoArgs& args);
 private:
	IMsiTable& m_riTable;
 private: // suppress warning
	void operator =(CAutoTable&){}
};

class CAutoCursor : public CAutoBase
{
 public:
	CAutoCursor(IMsiCursor& riCursor);
	~CAutoCursor();
	IUnknown& GetInterface();
	void Table          (CAutoArgs& args);
	void Filter         (CAutoArgs& args);
	void IntegerData    (CAutoArgs& args);
	void DateData       (CAutoArgs& args);
	void StringData     (CAutoArgs& args);
	void ObjectData     (CAutoArgs& args);
	void StreamData     (CAutoArgs& args);
	void PutNull        (CAutoArgs& args);
	void Reset          (CAutoArgs& args);
	void Next           (CAutoArgs& args);
	void Update         (CAutoArgs& args);
	void Insert         (CAutoArgs& args);
	void InsertTemporary(CAutoArgs& args);
	void Assign         (CAutoArgs& args);
	void Replace        (CAutoArgs& args);
	void Merge          (CAutoArgs& args);
	void Refresh        (CAutoArgs& args);
	void Delete         (CAutoArgs& args);
	void Seek           (CAutoArgs& args);
	void RowState       (CAutoArgs& args);
	void Validate       (CAutoArgs& args);
	void Moniker        (CAutoArgs& args);
 private:
	IMsiCursor& m_riCursor;
 private: // suppress warning
	void operator =(CAutoCursor&){}
};

class CAutoSelectionManager : public CAutoBase
{
 public:
	CAutoSelectionManager(IMsiSelectionManager& riSelectionManager);
	~CAutoSelectionManager();
	IUnknown& GetInterface();
	void LoadSelectionTables   (CAutoArgs& args);
	void ProcessConditionTable (CAutoArgs& args);
	void FeatureTable          (CAutoArgs& args);
	void ComponentTable        (CAutoArgs& args);
	void FreeSelectionTables   (CAutoArgs& args);
	void SetFeatureHandle      (CAutoArgs& args);
	void SetComponent          (CAutoArgs& args);
	void InitializeComponents  (CAutoArgs& args);
	void SetInstallLevel       (CAutoArgs& args);
	void GetVolumeCostTable    (CAutoArgs& args);
	void RecostDirectory       (CAutoArgs& args);
	void ConfigureFeature      (CAutoArgs& args);
	void GetFeatureCost        (CAutoArgs& args);
	void GetDescendentFeatureCost (CAutoArgs& args);
	void GetAncestryFeatureCost(CAutoArgs& args);
	void GetFeatureValidStates (CAutoArgs& args);
 private:
	IMsiSelectionManager& m_riSelectionManager;
 private: // suppress warning
	void operator =(CAutoSelectionManager&){}
};

class CAutoDirectoryManager : public CAutoBase
{
 public:
	CAutoDirectoryManager(IMsiDirectoryManager& riDirectoryManager);
	~CAutoDirectoryManager();
	IUnknown& GetInterface();
	void LoadDirectoryTable    (CAutoArgs& args);
	void DirectoryTable        (CAutoArgs& args);
	void FreeDirectoryTable    (CAutoArgs& args);
	void CreateTargetPaths     (CAutoArgs& args);
	void CreateSourcePaths     (CAutoArgs& args);
	void GetTargetPath         (CAutoArgs& args);
	void SetTargetPath         (CAutoArgs& args);
	void GetSourcePath         (CAutoArgs& args);
 private:
	IMsiDirectoryManager& m_riDirectoryManager;
 private: // suppress warning
	void operator =(CAutoDirectoryManager&){}
};

class CAutoServer : public CAutoBase
{
 public:
	CAutoServer(IMsiServer& riServer);
	CAutoServer(IMsiServer& riServer, DispatchEntry<CAutoBase>* pTable, int cDispId);
	~CAutoServer();
	IUnknown& GetInterface();
	void InstallFinalize     (CAutoArgs& args);
	void DoInstall           (CAutoArgs& args);
	void SetLastUsedSource   (CAutoArgs& args);
 private:
	IMsiServer& m_riServer;
 private: // suppress warning
	void operator =(CAutoServer&){}
};

class CAutoConfigurationManager : public CAutoServer
{
 public:
	CAutoConfigurationManager(IMsiConfigurationManager& riConfigurationManager);
	~CAutoConfigurationManager();
	IUnknown& GetInterface();
	void Services                    (CAutoArgs& args);
	void RegisterComponent           (CAutoArgs& args);
	void UnregisterComponent         (CAutoArgs& args);
	void RegisterFolder              (CAutoArgs& args);
	void IsFolderRemovable           (CAutoArgs& args);
	void UnregisterFolder            (CAutoArgs& args);
	void RegisterRollbackScript      (CAutoArgs& args);
	void UnregisterRollbackScript    (CAutoArgs& args);
	void RollbackScripts             (CAutoArgs& args);
	void RunScript                   (CAutoArgs& args);
 private:
	IMsiConfigurationManager& m_riConfigurationManager;
 private: // suppress warning
	void operator =(CAutoConfigurationManager&){}
};

class CAutoExecute : public CAutoBase
{
 public:
	CAutoExecute(IMsiExecute& riExecute);
	~CAutoExecute();
	IUnknown& GetInterface();
	void ExecuteRecord        (CAutoArgs& args);
	void RunScript            (CAutoArgs& args);
	void RemoveRollbackFiles  (CAutoArgs& args);
	void Rollback             (CAutoArgs& args);
	void RollbackFinalize     (CAutoArgs& args);
	void CreateScript         (CAutoArgs& args);
	void WriteScriptRecord    (CAutoArgs& args);
	void CloseScript          (CAutoArgs& args);
 private:
	IMsiExecute& m_riExecute;
	CScriptGenerate* m_pScript;
 private: // suppress warning
	void operator =(CAutoExecute&){}
};

class CAutoEngine : public CAutoBase
{
 public:
	CAutoEngine(IMsiEngine& riEngine);
	~CAutoEngine();
	IUnknown& GetInterface();
	void Services             (CAutoArgs& args);
	void ConfigurationServer  (CAutoArgs& args);
	void Handler              (CAutoArgs& args);
	void Database             (CAutoArgs& args);
	void Property             (CAutoArgs& args);
	void SelectionManager     (CAutoArgs& args);
	void DirectoryManager     (CAutoArgs& args);
	void Initialize           (CAutoArgs& args);
	void Terminate            (CAutoArgs& args);
	void DoAction             (CAutoArgs& args);
	void Sequence             (CAutoArgs& args);
	void Message              (CAutoArgs& args);
	void SelectLanguage       (CAutoArgs& args);
	void OpenView             (CAutoArgs& args);
	void ResolveFolderProperty(CAutoArgs& args);
	void FormatText           (CAutoArgs& args);
	void EvaluateCondition    (CAutoArgs& args);
	void SetMode              (CAutoArgs& args);
	void GetMode              (CAutoArgs& args);
	void ExecuteRecord        (CAutoArgs& args);
	void ValidateProductID    (CAutoArgs& args);
private:
	IMsiEngine& m_riEngine;
 private: // suppress warning
	void operator =(CAutoEngine&){}
};

class CAutoRegKey : public CAutoBase
{
 public:
	CAutoRegKey(IMsiRegKey& riRegKey);
	~CAutoRegKey();
	IUnknown& GetInterface();
	void RemoveValue  (CAutoArgs& args);
	void RemoveSubTree(CAutoArgs& args);
	void Value        (CAutoArgs& args);
	void Values       (CAutoArgs& args);
	void SubKeys      (CAutoArgs& args);
	void Exists       (CAutoArgs& args);
	void CreateChild  (CAutoArgs& args);
	void Key          (CAutoArgs& args);
	void ValueExists  (CAutoArgs& args);
	void GetSelfRelativeSD(CAutoArgs& args);
 private:
	IMsiRegKey& m_riRegKey;
 private: // suppress warning
	void operator =(CAutoRegKey&){}
};

class CAutoHandler : public CAutoBase
{
 public:
	CAutoHandler(IMsiHandler& riHandler);
	~CAutoHandler();
	IUnknown& GetInterface();
	void Message(CAutoArgs& args);
	void DoAction(CAutoArgs& args);
	void Break(CAutoArgs& args);
	void DialogHandler(CAutoArgs& args);
 private:
	IMsiHandler& m_riHandler;
 private: // suppress warning
	void operator =(CAutoHandler&){}
};

class CAutoDialogHandler : public CAutoBase
{
public:
	CAutoDialogHandler(IMsiDialogHandler& riHandler);
	~CAutoDialogHandler();
	IUnknown& GetInterface();
	void DialogCreate(CAutoArgs& args);
	void Dialog(CAutoArgs& args);
	void DialogFromWindow(CAutoArgs& args);
	void AddDialog(CAutoArgs& args);
	void RemoveDialog(CAutoArgs& args);
private:
	IMsiDialogHandler& m_riDialogHandler;
 private: // suppress warning
	void operator =(CAutoDialogHandler&){}
};


class CAutoDialog : public CAutoBase
{
 public:
	CAutoDialog(IMsiDialog& riDialog);
	~CAutoDialog();
	IUnknown& GetInterface();
	void StringValue(CAutoArgs& args);
	void IntegerValue(CAutoArgs& args);
	void Visible(CAutoArgs& args);
	void ControlCreate(CAutoArgs& args);
	void Attribute(CAutoArgs& args);
	void Control(CAutoArgs& args);
	void AddControl(CAutoArgs& args);
	void RemoveControl(CAutoArgs& args);
	void Execute(CAutoArgs& args);
	void Reset(CAutoArgs& args);
 	void EventAction(CAutoArgs& args);
	void Handler(CAutoArgs& args);
	void PropertyChanged(CAutoArgs& args);
	void FinishCreate(CAutoArgs& args);
	void HandleEvent(CAutoArgs& args);
 private:
	IMsiDialog& m_riDialog;
 private: // suppress warning
	void operator =(CAutoDialog&){}
};

class CAutoEvent : public CAutoBase
{
 public:
	CAutoEvent(IMsiEvent& riEvent);
	~CAutoEvent();
	IUnknown& GetInterface();
	void StringValue(CAutoArgs& args);
	void IntegerValue(CAutoArgs& args);
	void PropertyChanged(CAutoArgs& args);
	void ControlActivated(CAutoArgs& args);
	void RegisterControlEvent(CAutoArgs& args);
	void Handler(CAutoArgs& args);
	void PublishEvent(CAutoArgs& args);
	void Control(CAutoArgs& args);
	void Attribute(CAutoArgs& args);
	void EventAction(CAutoArgs& args);
	void SetFocus(CAutoArgs& args);
	void HandleEvent(CAutoArgs& args);
	void Engine(CAutoArgs& args);
	void Escape(CAutoArgs& args);
 private:
	IMsiEvent& m_riEvent;
 private: // suppress warning
	void operator =(CAutoEvent&){}
};

class CAutoControl : public CAutoBase
{
 public:
	CAutoControl(IMsiControl& riControl);
	~CAutoControl();
	IUnknown& GetInterface();
	void StringValue(CAutoArgs& args);
	void IntegerValue(CAutoArgs& args);
	void Attribute(CAutoArgs& args);
	void CanTakeFocus(CAutoArgs& args);
	void HandleEvent(CAutoArgs& args);
	void Undo(CAutoArgs& args);
	void SetPropertyInDatabase(CAutoArgs& args);
	void GetPropertyFromDatabase(CAutoArgs& args);
	void GetIndirectPropertyFromDatabase(CAutoArgs& args);
	void SetFocus(CAutoArgs& args);
	void Dialog(CAutoArgs& args);
	void WindowMessage(CAutoArgs& args);
 private:
	IMsiControl& m_riControl;
 private: // suppress warning
	void operator =(CAutoControl&){}
};

class CAutoMalloc : public CAutoBase
{
 public:
	CAutoMalloc(IMsiMalloc& riMalloc);
	~CAutoMalloc();
	IUnknown& GetInterface();
	void Alloc(CAutoArgs& args);
	void Realloc(CAutoArgs& args);
	void Free(CAutoArgs& args);
	void SetDebugFlags(CAutoArgs& args);
	void GetDebugFlags(CAutoArgs& args);
	void CheckAllBlocks(CAutoArgs& args);
	void FCheckBlock(CAutoArgs& args);
	void GetSizeOfBlock(CAutoArgs& args);
 private:
	IMsiMalloc& m_riMalloc;
 private: // suppress warning
	void operator =(CAutoMalloc&){}
};

class CAutoMessage : public CAutoBase
{
 public:
	CAutoMessage(IMsiMessage& riMessage);
	~CAutoMessage();
	IUnknown& GetInterface();
	void Message(CAutoArgs& args);
 private:
	IMsiMessage& m_riMessage;
 private: // suppress warning
	void operator =(CAutoMessage&){}
};

#ifdef CONFIGDB
class CAutoConfigurationDatabase : public CAutoBase
{
 public:
	CAutoConfigurationDatabase(IMsiConfigurationDatabase& riConfigurationDatabase);
	~CAutoConfigurationDatabase();
	IUnknown& GetInterface();
	void InsertFile(CAutoArgs& args);
	void RemoveFile(CAutoArgs& args);
	void LookupFile(CAutoArgs& args);
	void EnumClient(CAutoArgs& args);
	void Commit(CAutoArgs& args);
 private:
	IMsiConfigurationDatabase& m_riConfigurationDatabase;
 private: // suppress warning
	void operator =(CAutoConfigurationDatabase&){}
};
#endif //CONFIGDB
//____________________________________________________________________________
//
// Automation wrapper factory for this module, used by CAutoBase::GetInterface
//____________________________________________________________________________

IDispatch* CreateAutoObject(IUnknown& riUnknown, long iidLow)
{
	riUnknown.AddRef(); // constructors assume refcnt transferred
	switch (iidLow)
	{
	case iidMsiData    : return new CAutoData    ((const IMsiData   *)&riUnknown);
	case iidMsiString  : return new CAutoString  ((const IMsiString  &)riUnknown);
	case iidMsiRecord  : return new CAutoRecord  ((IMsiRecord  &)riUnknown);
	case iidMsiVolume  : return new CAutoVolume  ((IMsiVolume  &)riUnknown);
	case iidMsiPath    : return new CAutoPath    ((IMsiPath    &)riUnknown);
	case iidMsiFileCopy: return new CAutoFileCopy((IMsiFileCopy&)riUnknown);
	case iidMsiFilePatch: return new CAutoFilePatch((IMsiFilePatch&)riUnknown);
	case iidMsiRegKey  : return new CAutoRegKey  ((IMsiRegKey  &)riUnknown);
	case iidMsiTable   : return new CAutoTable   ((IMsiTable   &)riUnknown);
	case iidMsiCursor  : return new CAutoCursor  ((IMsiCursor  &)riUnknown);
	case iidMsiServices: return new CAutoServices((IMsiServices&)riUnknown);
	case iidMsiView    : return new CAutoView    ((IMsiView    &)riUnknown);
	case iidMsiDatabase: return new CAutoDatabase((IMsiDatabase&)riUnknown);
	case iidMsiEngine  : return new CAutoEngine  ((IMsiEngine  &)riUnknown);
	case iidMsiExecute : return new CAutoExecute ((IMsiExecute &)riUnknown);
	case iidMsiHandler : return new CAutoHandler ((IMsiHandler &)riUnknown);
	case iidMsiDialogHandler : return new CAutoDialogHandler ((IMsiDialogHandler &)riUnknown);
	case iidMsiDialog  : return new CAutoDialog  ((IMsiDialog  &)riUnknown);
	case iidMsiEvent   : return new CAutoEvent   ((IMsiEvent   &)riUnknown);
	case iidMsiControl : return new CAutoControl ((IMsiControl &)riUnknown);
	case iidMsiStorage : return new CAutoStorage ((IMsiStorage &)riUnknown);
	case iidMsiStream  : return new CAutoStream  ((IMsiStream  &)riUnknown);
	case iidMsiConfigurationManager: return new CAutoConfigurationManager((IMsiConfigurationManager&)riUnknown);
	case iidMsiDirectoryManager    : return new CAutoDirectoryManager    ((IMsiDirectoryManager    &)riUnknown);
	case iidMsiSelectionManager    : return new CAutoSelectionManager    ((IMsiSelectionManager    &)riUnknown);
	case iidMsiMessage : return new CAutoMessage((IMsiMessage &)riUnknown);
#ifdef CONFIGDB
	case iidMsiConfigurationDatabase : return new CAutoConfigurationDatabase((IMsiConfigurationDatabase&)riUnknown);
#endif
	default:   riUnknown.Release(); return 0;
	};
}

//____________________________________________________________________________
//
// Common methods and properties automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C1040-0000-0000-C000-000000000046),  // IID_IMsiAutoBase
		helpcontext(MsiBase_Object),helpstring("Methods and properties common to all objects.")
	]
	dispinterface MsiBase
	{
		properties:
		methods:
			[id(1),propget,helpcontext(MsiBase_HasInterface),helpstring("True if object has interface.")]
				boolean HasInterface([in] long iid);
			[id(2),propget,helpcontext(MsiBase_RefCount),helpstring("Reference count of object.")]
				int RefCount();
			[id(3),propget,helpcontext(MsiBase_GetInterface),helpstring("Returns object containing requested interface.")]
				IDispatch* GetInterface([in] long iid);
	};
*/

//____________________________________________________________________________
//
// MsiServices automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C104B-0000-0000-C000-000000000046),  // IID_IMsiAutoServices
		helpcontext(MsiServices_Object),helpstring("Services object.")
	]
	dispinterface MsiServices
	{
		properties:
		methods:
			[id(1), helpcontext(MsiServices_GetAllocator),helpstring("Returns the system MsiMalloc object.")]
				MsiMalloc*  GetAllocator();
			[id(2), helpcontext(MsiServices_CreateString),helpstring("Create an MsiString object containing an empty string.")]
				MsiRecord*  CreateString();
			[id(3), helpcontext(MsiServices_CreateRecord),helpstring("Create a MsiRecord object with a specified number of fields.")]
				MsiRecord*  CreateRecord([in] long Count);
			[id(4), helpcontext(MsiServices_SetPlatformProperties),helpstring("Set hardware and operating system properties.")]
				void SetPlatformProperties([in] MsiTable* table, [in] boolean allUsers);
			[id(5), helpcontext(MsiServices_CreateLog),helpstring("Opens the log file.")]
				void CreateLog([in] BSTR path, [in] boolean append);
			[id(6), helpcontext(MsiServices_WriteLog),helpstring("Writes a line to the log file.")]
				void WriteLog([in] BSTR text);
			[id(7), helpcontext(MsiServices_LoggingEnabled),helpstring("True if the log file is open.")]
				boolean LoggingEnabled();
			[id(8), helpcontext(MsiServices_CreateDatabase),helpstring("Opens a named database of specified kind.")]
				MsiDatabase* CreateDatabase([in] BSTR name, [in] long openMode);
			[id(9), helpcontext(MsiServices_CreateDatabaseFromStorage),helpstring("Opens an MSI database from an MsiStorage object.")]
				MsiDatabase* CreateDatabaseFromStorage([in] MsiStorage* storage, [in] boolean readOnly);
			[id(10), helpcontext(MsiServices_CreatePath),helpstring("Creates an MsiPath object based on the given path string.")]
				MsiPath* CreatePath([in] BSTR path);
			[id(11), helpcontext(MsiServices_CreateVolume),helpstring("Creates an MsiVolume object based on the given path string.")]
				MsiVolume* CreateVolume([in] BSTR path);
			[id(12), helpcontext(MsiServices_CreateCopier),helpstring("Creates an MsiFileCopy object for use in copying a file.")]
				MsiFileCopy* CreateCopier([in] long copierType,MsiStorage* storage);
			[id(13), helpcontext(MsiServices_ClearAllCaches),helpstring("Clears the list of cached volume objects and record objects from the services.")]
				void ClearAllCaches();
			[id(14), helpcontext(MsiServices_EnumDriveType),helpstring("Creates an EnumMsiVolume object, for use in enumerating volumes of a specified volume type.")]
				IEnumVARIANT* EnumDriveType([in]long driveType);
			[id(15), helpcontext(MsiServices_GetModuleUsage),helpstring("Enumerates the processes that use a file of the given name")]
				IEnumVARIANT* GetModuleUsage([in] BSTR fileName);
			[id(16), helpcontext(MsiServices_GetLocalPath),helpstring("Returns a string representing the full path of the installer's launch directory (Win) or the MsiService DLL's directory (Mac).")]
				BSTR GetLocalPath([in] BSTR file);
			[id(17), helpcontext(MsiServices_CreateRegKey), helpstring("Creates an MsiRegKey object")] 
				MsiRegKey*  CreateRegKey([in] BSTR value,[in] BSTR subKey);
			[id(18), helpcontext(MsiServices_RegisterFont),helpstring(".")]
				void RegisterFont([in] BSTR fontTitle, [in] BSTR fontFile, [in] MsiPath* path);
			[id(19), helpcontext(MsiServices_UnRegisterFont),helpstring(".")]
				void UnRegisterFont([in] BSTR fontTitle);                      
			[id(20), helpcontext(MsiServices_WriteIniFile), helpstring("Writes an entry to a .INI file")] 
				void WriteIniFile([in] MsiPath* path, [in] BSTR file,[in] BSTR section,[in] BSTR key,[in] BSTR value, long action);
			[id(21), helpcontext(MsiServices_ReadIniFile), helpstring("Reads an entry from a .INI file")] 
				BSTR ReadIniFile([in] MsiPath* path, [in] BSTR file,[in] BSTR section,[in] BSTR key, [in] long Field);
			[id(22), helpcontext(MsiServices_GetLangNamesFromLangIDString),helpstring("Given a string containing a comma-separated list of language identifiers, GetLangNamesFromLangIDString returns the full localized name of each specified language.")]
				int GetLangNamesFromLangIDString([in] BSTR langIDs, [in] MsiRecord* riLangRec, [in] int iFieldStart);
			[id(23), helpcontext(MsiServices_CreateStorage),helpstring("Creates an MsiStorage object from a file path.")]
				MsiStorage* CreateStorage(BSTR path, long openMode);
			[id(24), helpcontext(MsiServices_GetUnhandledError),helpstring("Returns any unhandled error as an MsiRecord object, clears unhandled error.")]
				MsiRecord* GetUnhandledError();
			[id(25), helpcontext(MsiServices_SupportLanguageId),helpstring("Compares a language ID against the current system or user language ID")]
				long SupportLanguageId([in] long languageId, [in] boolean systemDefault);
			[id(27), helpcontext(MsiServices_CreateVolumeFromLabel),helpstring("Creates an MsiVolume object based on the given volume label.")]
				MsiVolume* CreateVolumeFromLabel([in] BSTR label, [in] int driveType);
			[id(28), helpcontext(MsiServices_CreateShortcut),helpstring("Creates a shortcut to an existing file or path")]
				void CreateShortcut([in] MsiPath* shortcutPath, [in] BSTR shortcutName, [in] MsiPath* targetPath, [in] BSTR targetName, [in] MsiRecord* shortcutInfo);
			[id(29), helpcontext(MsiServices_RemoveShortcut),helpstring("Deletes a shortcut to a file or path")]
				void RemoveShortcut([in] MsiPath* shortcutPath, [in] BSTR shortcutName, [in] MsiPath* targetPath, [in] BSTR targetName);
			[id(34), helpcontext(MsiServices_ExtractFileName),helpstring("Extracts the appropriate file name from a short|long pair.")]
				BSTR ExtractFileName([in] BSTR namePair, [in] boolean longName);
			[id(35), helpcontext(MsiServices_ValidateFileName),helpstring("Validates a short or long file name.")]
				void ValidateFileName([in] BSTR fileName, [in] boolean longName);
			[id(36), helpcontext(MsiServices_CreateFileStream),helpstring("Creates a stream object on a given file.")]
				MsiStream* CreateFileStream([in] BSTR filepath, [in] boolean write);
			[id(37), helpcontext(MsiServices_CreateMemoryStream),helpstring("Creates a stream object on allocated memory.")]
				MsiStream* CreateMemoryStream([in] BSTR data);
			[id(38), helpcontext(MsiServices_RegisterTypeLibrary),helpstring("Registers a type library.")]
                void RegisterTypeLibrary([in] BSTR libId,[in] int locale,[in] BSTR path, [in] BSTR helpPath);
			[id(39), helpcontext(MsiServices_UnregisterTypeLibrary),helpstring("Unregisters a type library.")]
                void UnregisterTypeLibrary([in] BSTR libId,[in] int locale,[in] BSTR path);
			[id(40), helpcontext(MsiServices_GetShellFolderPath),helpstring("Returns the path of a shell folder.")]
				BSTR GetShellFolderPath([in] long folderId, [in] BSTR regValue);
			[id(41), helpcontext(MsiServices_GetUserProfilePath),helpstring("Returns the path of the user's profile folder.")]
				BSTR GetUserProfilePath(void);
			[id(42), helpcontext(MsiServices_CreateFilePath),helpstring("Creates an MsiPath object based on the given full path to a file.")]
				MsiPath* CreateFilePath([in] BSTR path);
			[id(43), helpcontext(MsiServices_RipFileNameFromPath),helpstring("Given a full path to a file, returns the filename.")]
				MsiPath* RipFileNameFromPath([in] BSTR path);
			[id(44), helpcontext(MsiServices_CreatePatcher),helpstring("Creates an MsiFilePatch object for use in patching a file.")]
				MsiFilePatch* CreatePatcher(void);
			[id(45)]
				Boolean TestEmbeddedNullsInStrings(void);
	};
*/

DispatchEntry<CAutoServices> AutoServicesTable[] = {
   1, aafMethod, CAutoServices::GetAllocator,   TEXT("GetAllocator"),
   2, aafMethod, CAutoServices::CreateString,   TEXT("CreateString"),
   3, aafMethod, CAutoServices::CreateRecord,   TEXT("CreateRecord,count"),
   4, aafMethod, CAutoServices::SetPlatformProperties,TEXT("SetPlatformProperties,table,allUsers"),
   5, aafMethod, CAutoServices::CreateLog,      TEXT("CreateLog,path,append"),
   6, aafMethod, CAutoServices::WriteLog,       TEXT("WriteLog,text"),
   7, aafPropRO, CAutoServices::LoggingEnabled, TEXT("LoggingEnabled"),
   8, aafMethod, CAutoServices::CreateDatabase, TEXT("CreateDatabase,name,openMode,tempArgForCompatibility"),
   9, aafMethod, CAutoServices::CreateDatabaseFromStorage, TEXT("CreateDatabaseFromStorage,storage,readOnly"),
  10, aafMethod, CAutoServices::CreatePath,     TEXT("CreatePath,path"),
  11, aafMethod, CAutoServices::CreateVolume,   TEXT("CreateVolume,path"),
  12, aafMethod, CAutoServices::CreateCopier,    TEXT("CreateCopier,copierType,storage"),
  13, aafMethod, CAutoServices::ClearAllCaches, TEXT("ClearAllCaches"),
  14, aafMethod, CAutoServices::EnumDriveType,  TEXT("EnumDriveType,driveType"),
  15, aafMethod, CAutoServices::GetModuleUsage, TEXT("GetModuleUsage,fileName"),
  16, aafMethod, CAutoServices::GetLocalPath,   TEXT("GetLocalPath,file"),
  17, aafMethod, CAutoServices::CreateRegKey,   TEXT("CreateRegKey,key,subkey"),
  18, aafMethod, CAutoServices::RegisterFont,   TEXT("RegisterFont,fontTitle,fontFile,path"),
  19, aafMethod, CAutoServices::UnRegisterFont, TEXT("UnRegisterFont,fontTitle"),
  20, aafMethod, CAutoServices::WriteIniFile, TEXT("WriteIniFile,path,file,section,key,value,action"),
  21, aafMethod, CAutoServices::ReadIniFile, TEXT("ReadIniFile,path,file,section,key,field"),
  22, aafMethod, CAutoServices::GetLangNamesFromLangIDString, TEXT("GetLangNamesFromLangIDString,langIDs,riLangRec,iFieldStart"),
  23, aafMethod, CAutoServices::CreateStorage, TEXT("CreateStorage,path,openMode"),
  24, aafMethod, CAutoServices::GetUnhandledError,TEXT("GetUnhandledError"),
  25, aafMethod, CAutoServices::SupportLanguageId,TEXT("SupportLanguageId,languageId,systemDefault"),
  27, aafMethod, CAutoServices::CreateVolumeFromLabel,   TEXT("CreateVolumeFromLabel,label,driveType"),
  28, aafMethod, CAutoServices::CreateShortcut, TEXT("CreateShortcut,shortcutPath,shortcutName,targetPath,targetName,shortcutInfo"),
  29, aafMethod, CAutoServices::RemoveShortcut, TEXT("RemoveShortcut,shortcutPath,shortcutName,targetPath,targetName"),
  34, aafMethod, CAutoServices::ExtractFileName, TEXT("ExtractFileName,namePair,longName"),
  35, aafMethod, CAutoServices::ValidateFileName, TEXT("ValidateFileName,fileName,longName"),
  36, aafMethod, CAutoServices::CreateFileStream, TEXT("CreateFileStream,filePath,write"),
  37, aafMethod, CAutoServices::CreateMemoryStream, TEXT("CreateMemoryStream,data"),
  38, aafMethod, CAutoServices::RegisterTypeLibrary, TEXT("RegisterTypeLibrary,libId,locale,path,helpPath"),
  39, aafMethod, CAutoServices::UnregisterTypeLibrary, TEXT("UnregisterTypeLibrary,libId,locale,path"),
  40, aafMethod, CAutoServices::GetShellFolderPath, TEXT("GetShellFolderPath,folderId,regValue"),
  41, aafMethod, CAutoServices::GetUserProfilePath, TEXT("GetUserProfilePath"),
  42, aafMethod, CAutoServices::CreateFilePath,     TEXT("CreateFilePath,path"),
  43, aafMethod, CAutoServices::RipFileNameFromPath,     TEXT("RipFileNameFromPath,path"),
  44, aafMethod, CAutoServices::CreatePatcher, TEXT("CreatePatcher"),
  45, aafMethod, CAutoServices::TestEmbeddedNullsInStrings, TEXT("TestEmbeddedNullsInStrings"),
};
const int AutoServicesCount = sizeof(AutoServicesTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiServices automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoServices(IMsiServices& riServices)
{
	return new CAutoServices(riServices);
}

CAutoServices::CAutoServices(IMsiServices& riServices)
 : CAutoBase(*AutoServicesTable, AutoServicesCount), m_riServices(riServices)
{

	if (g_cServicesUsers == 0)
	{
		g_piStringNull = &riServices.GetNullString();
		// Caller did an addref for the m_riServices member of CAutoServices
		// but here we are adding to the static and must do an extra increment
		s_piServices = &riServices;
		s_piServices->AddRef();
		MsiString::InitializeClass(riServices.GetNullString());
	}

	g_cServicesUsers++;
}

CAutoServices::~CAutoServices()
{
	if (--g_cServicesUsers == 0)
	{
		s_piServices->Release();
		s_piServices = 0;
	}
	m_riServices.Release();
}

IUnknown& CAutoServices::GetInterface()
{
	return m_riServices;
}

void CAutoServices::CreateString(CAutoArgs& args)
{
	args = new CAutoString(*g_piStringNull);
}

void CAutoServices::CreateRecord(CAutoArgs& args)
{
	args = new CAutoRecord(m_riServices.CreateRecord(args[1]));
}

void CAutoServices::SetPlatformProperties(CAutoArgs& args)
{
	if (!m_riServices.SetPlatformProperties((IMsiTable&)args[1].Object(IID_IMsiTable), (Bool)args[2], /* isppArchitecture = */ isppDefault, /* piFolderCacheTable = */ NULL))
		throw MsiServices_SetPlatformProperties;
}

void CAutoServices::CreateLog(CAutoArgs& args)
{
	if (!m_riServices.CreateLog(args[1], args[2]))
		throw MsiServices_CreateLog;
}

void CAutoServices::WriteLog(CAutoArgs& args)
{
	if (!m_riServices.WriteLog(args[1]))
		throw MsiServices_WriteLog;
}

void CAutoServices::LoggingEnabled(CAutoArgs& args)
{
	args = m_riServices.LoggingEnabled();
}

void CAutoServices::CreateDatabase(CAutoArgs& args)
{
	IMsiDatabase* piDatabase;
	idoEnum idoMode = (idoEnum)(int)args[2];
   IMsiRecord* piError = m_riServices.CreateDatabase(args[1], idoMode, piDatabase);
	if (piError)
		throw piError;
	args = new CAutoDatabase(*piDatabase);
}

void CAutoServices::CreateDatabaseFromStorage(CAutoArgs& args)
{
	IMsiDatabase* piDatabase;
	IMsiStorage& riStorage = (IMsiStorage&)args[1].Object(IID_IMsiStorage);
   IMsiRecord* piError = m_riServices.CreateDatabaseFromStorage(riStorage, args[2],
							   									piDatabase);
	if (piError)
		throw piError;
	args = new CAutoDatabase(*piDatabase);
}

void CAutoServices::CreatePath(CAutoArgs& args)
{
	IMsiPath* piPath;
	IMsiRecord* piRec = m_riServices.CreatePath(args[1], piPath);
	if (piRec)
		throw piRec;
	args = new CAutoPath(*piPath);
}

void CAutoServices::CreateFilePath(CAutoArgs& args)
{
	MsiString strFileName;
	IMsiPath* piPath;
	IMsiRecord* piRec = m_riServices.CreateFilePath(args[1], piPath, *&strFileName);
	if (piRec)
		throw piRec;
	args = new CAutoPath(*piPath);
}

void CAutoServices::RipFileNameFromPath(CAutoArgs& args)
{
	const IMsiString *piStr;
	PMsiPath pPath(0);
	IMsiRecord* piRec = m_riServices.CreateFilePath(args[1], *&pPath, piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

Bool Compare(const IMsiString& riString, const ICHAR* szString2, unsigned int cchString2)
{
	if (riString.TextSize() != (cchString2-1) || 0 != memcmp(riString.GetString(), szString2, cchString2*sizeof(ICHAR)))
		return fFalse;
	else
		return fTrue;
}

void CAutoServices::TestEmbeddedNullsInStrings(CAutoArgs& args)
{
	PMsiRecord pRec = &m_riServices.CreateRecord(4);
	const IMsiString* piStr = g_piStringNull;

	const ICHAR szText1[] = TEXT("String1\0String2\0");
	const ICHAR szText2[] = TEXT("\0String2\0");
	const ICHAR szText3[] = TEXT("String2\0");
	const ICHAR szText4[] = TEXT("String1\0String2");
	const ICHAR szText5[] = TEXT("String1");
	const ICHAR szText6[] = TEXT("String1\0");
	const ICHAR szText7[] = TEXT("\0");
	const ICHAR szText8[] = TEXT("");

	ICHAR* pch = piStr->AllocateString(sizeof(szText1)/sizeof(ICHAR) - 1, fFalse, piStr);
	memcpy(pch, szText1, sizeof(szText1));
	MsiString strNulls = *piStr;

	MsiString strTest;

	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseUpto, 0);
	if (!Compare(*strTest, szText2, sizeof(szText2)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseIncluding, 0);
	if (!Compare(*strTest, szText3, sizeof(szText3)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseFrom, 0);
	if (!Compare(*strTest, szText4, sizeof(szText4)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseAfter, 0);
	if (!Compare(*strTest, szText1, sizeof(szText1)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseUpto, 0);
	if (!Compare(*strTest, szText5, sizeof(szText5)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseIncluding, 0);
	if (!Compare(*strTest, szText6, sizeof(szText6)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseFrom, 0);
	if (!Compare(*strTest, szText7, sizeof(szText7)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseAfter, 0);
	if (!Compare(*strTest, szText8, sizeof(szText8)/sizeof(ICHAR)))
		goto FAILURE;

	args = fTrue;
	return;

FAILURE:
	args = fFalse;
	return;
}

void CAutoServices::CreateVolume(CAutoArgs& args)
{
	IMsiVolume* piVol;
	IMsiRecord* piRec = m_riServices.CreateVolume(args[1], piVol);
	if (piRec)
		throw piRec;
	args = new CAutoVolume(*piVol);
}

void CAutoServices::CreateVolumeFromLabel(CAutoArgs& args)
{
	IMsiVolume* piVol;
	if (!m_riServices.CreateVolumeFromLabel(args[1], (idtEnum) (int) args[2], piVol))
		throw MsiServices_CreateVolumeFromLabel;
	args = new CAutoVolume(*piVol);
}

void CAutoServices::CreateCopier(CAutoArgs& args)
{
	IMsiStorage* piStorage = 0;
	if (args.Present(2))
		piStorage = (IMsiStorage*)args[2].ObjectPtr(IID_IMsiStorage);
	IMsiFileCopy* piFileCopy;
	IMsiRecord* piRec = m_riServices.CreateCopier((ictEnum)(int) args[1], piStorage, piFileCopy);
	if (piRec)
		throw piRec;
	args = new CAutoFileCopy(*piFileCopy);
}

void CAutoServices::CreatePatcher(CAutoArgs& args)
{
	IMsiFilePatch* piFilePatch;
	IMsiRecord* piRec = m_riServices.CreatePatcher(piFilePatch);
	if (piRec)
		throw piRec;
	args = new CAutoFilePatch(*piFilePatch);
}

void CAutoServices::EnumDriveType(CAutoArgs& args)
{
	args = m_riServices.EnumDriveType((idtEnum)(int)args[1]);
}

void CAutoServices::ClearAllCaches(CAutoArgs& /*args*/)
{
	m_riServices.ClearAllCaches();
}

void CAutoServices::GetModuleUsage(CAutoArgs& args)
{
	IEnumMsiRecord* piEnumRecord;
	IMsiRecord* piRec = m_riServices.GetModuleUsage(*MsiString(args[1].GetMsiString()), piEnumRecord);
	if (piRec)
		throw piRec;
	args = *piEnumRecord;
}

void CAutoServices::CreateRegKey(CAutoArgs& args)
{
	rrkEnum erRoot;

	if(!IStrCompI(args[1], TEXT("HKEY_CLASSES_ROOT")))
	{
		erRoot =  rrkClassesRoot;                      
	}
	else if(!IStrCompI(args[1], TEXT("HKEY_CURRENT_USER")))
	{
		erRoot =  rrkCurrentUser;                      
	}

	else if(!IStrCompI(args[1], TEXT("HKEY_LOCAL_MACHINE")))
	{
		erRoot =  rrkLocalMachine;                     
	}

	else if(!IStrCompI(args[1], TEXT("HKEY_USERS")))
	{
		erRoot = rrkUsers;                     
	}               
	else
	{
		// error
		IMsiRecord* piError = &m_riServices.CreateRecord(3);
		piError->SetInteger(1, imsgCreateKeyFailed);
		piError->SetString(2, args[1]);
		piError->SetInteger(3, 0);
		throw piError;
	}
	IMsiRegKey& riaRegKeyTmp = m_riServices.GetRootKey(erRoot);
	IMsiRegKey& riRegKey = riaRegKeyTmp.CreateChild(args[2]);
	args = new CAutoRegKey(riRegKey);
	riaRegKeyTmp.Release();
}

void CAutoServices::RegisterFont(CAutoArgs& args)
{
	IMsiPath* piPath = 0;
	if(args.Present(3))
		piPath = (IMsiPath*)args[3].ObjectPtr(IID_IMsiPath);
	IMsiRecord* piRec = m_riServices.RegisterFont(args[1], args[2], piPath, false);
	if (piRec)
		throw piRec;
}

void CAutoServices::UnRegisterFont(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riServices.UnRegisterFont(args[1]);      
	if (piRec)
		throw piRec;
}

void CAutoServices::WriteIniFile(CAutoArgs& args)
{
	IMsiRecord* piRec;
	IMsiPath* piPath = 0;
	
	if(args.Present(1))
	{
		CVariant& var = args[1];
		if (var.GetType() != VT_EMPTY)
			piPath =  (IMsiPath*)args[1].ObjectPtr(IID_IMsiPath);
	}


	if(args.Present(5))
	{
		piRec = m_riServices.WriteIniFile(  piPath,args[2],args[3],
											args[4],args[5],(iifIniMode)(int)args[6]);
	}
	else
	{
		piRec = m_riServices.WriteIniFile(  piPath,args[2],args[3],
											args[4], 0,(iifIniMode)(int)args[6]);
	}
	if (piRec)
		throw piRec;
}

void CAutoServices::ReadIniFile(CAutoArgs& args)
{
	const IMsiString* pValue;
	IMsiRecord* piRec;
	IMsiPath* piPath = 0;
	if(args.Present(1))
	{
		CVariant& var = args[1];
		if (var.GetType() != VT_EMPTY)
			piPath = (IMsiPath*)args[1].ObjectPtr(IID_IMsiPath);
	}
	unsigned int iField = ((args.Present(5)) ? args[5] : 0);
	piRec = m_riServices.ReadIniFile(piPath,args[2],args[3], args[4], iField, pValue);
	if (piRec)
		throw piRec;
	args = *pValue;
}

void CAutoServices::GetLocalPath(CAutoArgs& args)
{
	args = m_riServices.GetLocalPath(args.Present(1) ? args[1] : (const ICHAR*) 0);
}

void CAutoServices::GetAllocator(CAutoArgs& args)
{
	args = new CAutoMalloc(m_riServices.GetAllocator());
}

void CAutoServices::GetLangNamesFromLangIDString(CAutoArgs& args)
{
	//IMsiRecord* piRecord = &(IMsiRecord&)args[2].Object(IID_IMsiRecord);
	IMsiRecord& riRecord = (IMsiRecord&) args[2].Object(IID_IMsiRecord);
	args = m_riServices.GetLangNamesFromLangIDString(args[1],riRecord,args[3]);
}

void CAutoServices::CreateStorage(CAutoArgs& args)
{
	IMsiStorage* piStorage;
	IMsiRecord* piError = m_riServices.CreateStorage(args[1], (ismEnum)(int)args[2], piStorage);
	if (piError)
		throw piError;
	args = new CAutoStorage(*piStorage);
}

void CAutoServices::GetUnhandledError(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riServices.GetUnhandledError();      
	if (piRec)
		args = new CAutoRecord(*piRec);
	else
		args = (IDispatch*)0;
}

void CAutoServices::SupportLanguageId(CAutoArgs& args)
{
	args = (int)m_riServices.SupportLanguageId(args[1], args[2]);
}

void CAutoServices::CreateShortcut(CAutoArgs& args)
{
	IMsiRecord* pirecShortcutInfo = 0;
	if(args.Present(5))
	{
		CVariant& var = args[5];
		if (var.GetType() != VT_EMPTY)
			pirecShortcutInfo = (IMsiRecord*)args[5].ObjectPtr(IID_IMsiRecord);
	}
	IMsiPath* piTargetPath = 0;
	CVariant& var = args[3];
	if (var.GetType() != VT_EMPTY)
		piTargetPath = (IMsiPath*)args[3].ObjectPtr(IID_IMsiPath);

	const ICHAR* pszTargetName=0;
	if(args.Present(4))
		pszTargetName = args[4];
	IMsiRecord* piError = m_riServices.CreateShortcut((IMsiPath&) args[1].Object(IID_IMsiPath), 
								*MsiString(args[2].GetMsiString()), piTargetPath,
								pszTargetName,pirecShortcutInfo, 0);
	if (piError)
		throw piError;
}

void CAutoServices::RemoveShortcut(CAutoArgs& args)
{
	IMsiPath* piTargetPath = 0;
	if(args.Present(3))
	{
		CVariant& var = args[3];
		if (var.GetType() != VT_EMPTY)
			piTargetPath = (IMsiPath*)args[3].ObjectPtr(IID_IMsiPath);
	}
	const ICHAR* pszTargetName=0;
	if(args.Present(4))
		pszTargetName = args[4];
	IMsiRecord* piError = m_riServices.RemoveShortcut((IMsiPath&)args[1].Object(IID_IMsiPath), 
								*MsiString(args[2].GetMsiString()), piTargetPath,pszTargetName);
	if (piError)
		throw piError;
}

void CAutoServices::GetShellFolderPath(CAutoArgs& args)
{
	const ICHAR* szRegValue = 0;
	if(args.Present(2))
		szRegValue = args[2];
	const IMsiString* pistr;
	IMsiRecord* piError = m_riServices.GetShellFolderPath(args[1],szRegValue,pistr);
	if(piError)
		throw piError;
	args = pistr;
}

void CAutoServices::GetUserProfilePath(CAutoArgs& args)
{
	args = m_riServices.GetUserProfilePath();
}

void CAutoServices::ExtractFileName(CAutoArgs& args)
{
	const IMsiString* pistr;
	IMsiRecord* piError = m_riServices.ExtractFileName(args[1],args[2],pistr);
	if(piError)
		throw piError;
	args = pistr;
}

void CAutoServices::ValidateFileName(CAutoArgs& args)
{
	IMsiRecord* piError = m_riServices.ValidateFileName(args[1],args[2]);
	if(piError)
		throw piError;
}

void CAutoServices::CreateFileStream(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riServices.CreateFileStream(args[1],args[2],piStream);
	if(piError)
		throw piError;
	args = new CAutoStream(*piStream);
}

void CAutoServices::CreateMemoryStream(CAutoArgs& args)
{
	BSTR bstr;
	CVariant& var = args[1];
	if (var.GetType() == VT_BSTR)
		bstr = var.bstrVal;
	else if (var.GetType() == (VT_BYREF | VT_BSTR))
		bstr = *var.pbstrVal;
	else
		throw axInvalidType;

	int cchWide = OLE::SysStringLen(bstr);
	IMsiStream* piStream;
	char* pch = m_riServices.AllocateMemoryStream(cchWide * 2, piStream);
	if (pch == 0)
		throw MsiServices_CreateMemoryStream;   
	memcpy(pch, bstr, cchWide * 2);
	args = new CAutoStream(*piStream);
}

void CAutoServices::RegisterTypeLibrary(CAutoArgs& args)
{
	const ICHAR* szHelpPath = 0;
	if(args.Present(4))
		szHelpPath = args[4];
	IMsiRecord* piError = m_riServices.RegisterTypeLibrary(args[1],(int)args[2],args[3],
																			 szHelpPath,
																			 (ibtBinaryType)(int)args[5]);
	if(piError)
		throw piError;
}

void CAutoServices::UnregisterTypeLibrary(CAutoArgs& args)
{
	IMsiRecord* piError = m_riServices.UnregisterTypeLibrary(args[1],(int)args[2],args[3],
																				(ibtBinaryType)(int)args[4]);
	if(piError)
		throw piError;
}

//____________________________________________________________________________
//
// MsiRecord automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1043-0000-0000-C000-000000000046),  // IID_IMsiAutoRecord
		helpcontext(MsiRecord_Object),helpstring("Record object.")
	]
	dispinterface MsiRecord
	{
		properties:
		methods:
			[id(DISPID_MsiRecord_Data), propget, helpcontext(MsiRecord_Data), helpstring("The Variant value of the indexed field")]
				variant Data([in] unsigned long field);
			[id(DISPID_MsiRecord_Data), propput]
				void Data([in] unsigned long field, [in] variant value);
			[id(DISPID_MsiRecord_StringData), propget, helpcontext(MsiRecord_Data), helpstring("The string value of the indexed field")]
				BSTR StringData([in] unsigned long field);
			[id(DISPID_MsiRecord_StringData), propput]
				void StringData([in] unsigned long field, [in] BSTR value);
			[id(DISPID_MsiRecord_IntegerData), propget, helpcontext(MsiRecord_IntegerData), helpstring("The integer value of the indexed field")]
				long IntegerData([in] unsigned long field);
			[id(DISPID_MsiRecord_IntegerData), propput]
				void IntegerData([in] unsigned long field, [in] long value);
			[id(DISPID_MsiRecord_ObjectData), propget, helpcontext(MsiRecord_ObjectData), helpstring("The object contained in the indexed field")]
				MsiData* ObjectData([in] unsigned long field);
			[id(DISPID_MsiRecord_ObjectData), propput]
				void ObjectData([in] unsigned long field, [in] MsiData* value);
			[id(DISPID_MsiRecord_FieldCount), propget, helpcontext(MsiRecord_FieldCount), helpstring("Number of fields in record")]
				long FieldCount();
			[id(DISPID_MsiRecord_IsInteger), propget, helpcontext(MsiRecord_IsInteger), helpstring("True if indexed field contains integer type")]
				boolean IsInteger([in] unsigned long field);
			[id(DISPID_MsiRecord_IsNull), propget, helpcontext(MsiRecord_IsNull), helpstring("True if indexed field contains a null value")]
				boolean IsNull([in] unsigned long field);
			[id(DISPID_MsiRecord_IsChanged), propget, helpcontext(MsiRecord_IsChanged), helpstring("True if value of indexed field has be set")]
				boolean IsChanged([in] unsigned long field);
			[id(DISPID_MsiRecord_TextSize), propget, helpcontext(MsiRecord_TextSize), helpstring("Size of indexed field obtained as text")]
				BSTR TextSize([in] unsigned long field);
			[id(DISPID_MsiRecord_FormatText), helpcontext(MsiRecord_FormatText), helpstring("Format fields according to template in field 0")]
				BSTR FormatText([in] boolean showComments);
			[id(DISPID_MsiRecord_ClearData), helpcontext(MsiRecord_ClearData), helpstring("Clears all fields in record")]
				void ClearData();
			[id(DISPID_MsiRecord_ClearUpdate), helpcontext(MsiRecord_ClearUpdate), helpstring("Clears changed flags in record")]
				void ClearUpdate();
	};
*/

DispatchEntry<CAutoRecord> AutoRecordTable[] = {
  DISPID_MsiRecord_Data       , aafPropRW, CAutoRecord::Data,       TEXT("Data,field"),
  DISPID_MsiRecord_StringData , aafPropRW, CAutoRecord::StringData, TEXT("StringData,field"),
  DISPID_MsiRecord_IntegerData, aafPropRW, CAutoRecord::IntegerData,TEXT("IntegerData,field"),
  DISPID_MsiRecord_ObjectData , aafPropRW, CAutoRecord::ObjectData, TEXT("ObjectData,field"),
  DISPID_MsiRecord_FieldCount , aafPropRO, CAutoRecord::FieldCount, TEXT("FieldCount"),
  DISPID_MsiRecord_IsInteger  , aafPropRO, CAutoRecord::IsInteger,  TEXT("IsInteger,field"),
  DISPID_MsiRecord_IsNull     , aafPropRO, CAutoRecord::IsNull,     TEXT("IsNull,field"),
  DISPID_MsiRecord_IsChanged  , aafPropRO, CAutoRecord::IsChanged,  TEXT("IsChanged,field"),
  DISPID_MsiRecord_TextSize   , aafPropRO, CAutoRecord::TextSize,   TEXT("TextSize,field"),
  DISPID_MsiRecord_FormatText , aafMethod, CAutoRecord::FormatText, TEXT("FormatText,comments"),
  DISPID_MsiRecord_ClearData  , aafMethod, CAutoRecord::ClearData,  TEXT("ClearData"),
  DISPID_MsiRecord_ClearUpdate, aafMethod, CAutoRecord::ClearUpdate,TEXT("ClearUpdate"),
};
const int AutoRecordCount = sizeof(AutoRecordTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiRecord automation implementation
//____________________________________________________________________________

CAutoRecord::CAutoRecord(IMsiRecord& riRecord)
 : CAutoBase(*AutoRecordTable, AutoRecordCount), m_riRecord(riRecord)
{
	// s_piServices should be set -- you need an engine or services object to create a record
	g_cServicesUsers++;
}

CAutoRecord::~CAutoRecord()
{

	m_riRecord.Release();

	ReleaseStaticServices();

}

IUnknown& CAutoRecord::GetInterface()
{
	return m_riRecord;
}

void CAutoRecord::Data(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (var.GetType() == VT_EMPTY)
			m_riRecord.SetNull(iField);
		else if (var.GetType() == VT_BSTR)
			m_riRecord.SetMsiString(iField, *MsiString(var.GetMsiString()));
//		else if (var.GetType() == VT_DATE || var.GetType() == VT_R8)
//			m_riRecord.SetTimeProperty(iField, var);
		else
			m_riRecord.SetInteger(iField, var);
	}
	else
	{
		if (m_riRecord.IsNull(iField))
			args = (varVoid)0;
		else if (m_riRecord.IsInteger(iField))
			args = m_riRecord.GetInteger(iField);
		else
		{
			const IMsiData* piData = m_riRecord.GetMsiData(iField);
			const IMsiString* piString;
			if (piData && piData->QueryInterface(IID_IMsiString, (void**)&piString) == NOERROR)
			{
				piData->Release();
				args = piString;
			}
			else
				args = new CAutoData(piData);
		}
	}
}

void CAutoRecord::StringData(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (!args.PropertySet())
		args = m_riRecord.GetMsiString(iField);
	else
	{
		CVariant& var = args[0];
		if (!(var.GetType() == VT_EMPTY ? m_riRecord.SetNull(iField)
													: m_riRecord.SetString(iField, var)))
			throw MsiRecord_StringData;
	}
}

void CAutoRecord::IntegerData(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (!args.PropertySet())
		args = m_riRecord.GetInteger(iField);
	else if (!m_riRecord.SetInteger(iField, args[0]))
		throw MsiRecord_IntegerData;
}

void CAutoRecord::ObjectData(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (!args.PropertySet())
		args = new CAutoData(m_riRecord.GetMsiData(iField));
	else
	{
		CVariant& var = args[0];
		if (!(var.GetType() == VT_EMPTY ? m_riRecord.SetNull(iField)
			: m_riRecord.SetMsiData(iField, (const IMsiData*)var.ObjectPtr(IID_IMsiData))))
			throw MsiRecord_ObjectData;
	}
}

void CAutoRecord::FieldCount(CAutoArgs& args)
{
	args = m_riRecord.GetFieldCount();
}

void CAutoRecord::IsInteger(CAutoArgs& args)
{
	args = m_riRecord.IsInteger(args[1]);
}

void CAutoRecord::IsNull(CAutoArgs& args)
{
	args = m_riRecord.IsNull(args[1]);
}

void CAutoRecord::IsChanged(CAutoArgs& args)
{
	args = m_riRecord.IsChanged(args[1]);
}

void CAutoRecord::TextSize(CAutoArgs& args)
{
	args = m_riRecord.GetTextSize(args[1]);
}

void CAutoRecord::FormatText(CAutoArgs& args)
{
	Bool fComments = args.Present(1) ? args[1] : fFalse;
	args = m_riRecord.FormatText(fComments);
}

void CAutoRecord::ClearData(CAutoArgs& /*args*/)
{
	m_riRecord.ClearData();
}

void CAutoRecord::ClearUpdate(CAutoArgs& /*args*/)
{
	m_riRecord.ClearUpdate();
}

//____________________________________________________________________________
//
// MsiStorage automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1054-0000-0000-C000-000000000046),  // IID_IMsiAutoStorage
		helpcontext(MsiStorage_Object),helpstring("Structured storage object.")
	]
	dispinterface MsiStorage
	{
		properties:
			[id(DISPID_MsiStorage_Class), helpcontext(MsiStorage_Class), helpstring("The CLSID associated with this storage")]
				BSTR Class;
			[id(DISPID_MsiStorage_Name),helpcontext(MsiStorage_Name),helpstring("The name of the storage")]
				BSTR Name;
		methods:
			[id(DISPID_MsiStorage_OpenStream),helpcontext(MsiStorage_OpenStream),helpstring("Opens a named stream within the storage.")]
					MsiStream* OpenStream(BSTR name, boolean fWrite);
			[id(DISPID_MsiStorage_OpenStorage),helpcontext(MsiStorage_OpenStorage),helpstring("Opens a child storage within the storage.")]
					MsiStorage* OpenStorage(BSTR name, long openMode);
			[id(DISPID_MsiStorage_Streams),helpcontext(MsiStorage_Streams),helpstring("Enumerates the names of all streams the storage.")]
					IEnumVARIANT* Streams();
			[id(DISPID_MsiStorage_Storages),helpcontext(MsiStorage_Storages),helpstring("Enumerates the names of all child storages.")]
					IEnumVARIANT* Storages();
			[id(DISPID_MsiStorage_RemoveElement),helpcontext(MsiStorage_RemoveElement),helpstring("Deletes a stream or child storage.")]
					void RemoveElement(BSTR name, boolean fStorage);
			[id(DISPID_MsiStorage_RenameElement),helpcontext(MsiStorage_RemoveElement),helpstring("Renames a stream or child storage.")]
					void RenameElement(BSTR oldName, BSTR newName, boolean fStorage);
			[id(DISPID_MsiStorage_Commit),helpcontext(MsiStorage_Commit),helpstring("Commits updates to persistent storage.")]
					void Commit();
			[id(DISPID_MsiStorage_Rollback),helpcontext(MsiStorage_Rollback),helpstring("Backs out updates to persistent storage.")]
					void Rollback();
			[id(DISPID_MsiStorage_DeleteOnRelease),helpcontext(MsiStorage_DeleteOnRelease),helpstring("Removes a file or substorage when object is destructed.")]
					boolean DeleteOnRelease();
			[id(DISPID_MsiStorage_CreateSummaryInfo),helpcontext(MsiStorage_CreateSummaryInfo),helpstring("Returns an MsiSummaryInfo object to read/write standard document properties.")]
					MsiSummaryInfo* CreateSummaryInfo(long maxProperties);
			[id(DISPID_MsiStorage_CopyTo),helpcontext(MsiStorage_CopyTo),helpstring("Copys a storage to the destination storage, optionally excluding elements")]
					void CopyTo(MsiStorage* destStorage, MsiRecord* excludedElements);
	};              
*/

DispatchEntry<CAutoStorage> AutoStorageTable[] = {
	DISPID_MsiStorage_Class            , aafPropRW, CAutoStorage::Class,              TEXT("Class"),
	DISPID_MsiStorage_OpenStream       , aafMethod, CAutoStorage::OpenStream,         TEXT("OpenStream,name,fWrite"),
	DISPID_MsiStorage_OpenStorage      , aafMethod, CAutoStorage::OpenStorage,        TEXT("OpenStorage,name,openMode"),
	DISPID_MsiStorage_Streams          , aafMethod, CAutoStorage::Streams,            TEXT("Streams"),
	DISPID_MsiStorage_Storages         , aafMethod, CAutoStorage::Storages,           TEXT("Storages"),
	DISPID_MsiStorage_RemoveElement    , aafMethod, CAutoStorage::RemoveElement,      TEXT("RemoveElement,name,fStorage"),
	DISPID_MsiStorage_RenameElement    , aafMethod, CAutoStorage::RenameElement,      TEXT("RenameElement,oldName,newName,fStorage"),
	DISPID_MsiStorage_Commit           , aafMethod, CAutoStorage::Commit,             TEXT("Commit"),
	DISPID_MsiStorage_Rollback         , aafMethod, CAutoStorage::Rollback,           TEXT("Rollback"),
	DISPID_MsiStorage_DeleteOnRelease  , aafMethod, CAutoStorage::DeleteOnRelease,    TEXT("DeleteOnRelease"),
	DISPID_MsiStorage_CreateSummaryInfo, aafMethod, CAutoStorage::CreateSummaryInfo,  TEXT("CreateSummaryInfo,maxProperties"),
	DISPID_MsiStorage_CopyTo           , aafMethod, CAutoStorage::CopyTo,             TEXT("CopyTo,destStorage,excludedElements"),
	DISPID_MsiStorage_Name             , aafPropRO, CAutoStorage::Name,               TEXT("Name,storage"),
};
const int AutoStorageCount = sizeof(AutoStorageTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiStorage automation implementation
//____________________________________________________________________________

CAutoStorage::CAutoStorage(IMsiStorage& riStorage)
 : CAutoBase(*AutoStorageTable, AutoStorageCount), m_riStorage(riStorage)
{
}

CAutoStorage::~CAutoStorage()
{
	m_riStorage.Release();
}

IUnknown& CAutoStorage::GetInterface()
{
	return m_riStorage;
}

void CAutoStorage::Class(CAutoArgs& args)
{
	GUID guid;
	OLECHAR rgwchGuid[40];
	if (!args.PropertySet())
	{
		if (!m_riStorage.GetClass(&guid))
			args = (varVoid)0;
		else
		{
			OLE::StringFromGUID2(guid, rgwchGuid, 40);
			args = rgwchGuid;
		}
	}
	else
	{
		if (OLE::IIDFromString((wchar_t*)(const wchar_t*)args[0], &guid) != NOERROR)
			throw MsiStorage_Class;
		IMsiRecord* piError = m_riStorage.SetClass(guid);
		if (piError)
			throw piError;
	}
}

void CAutoStorage::Name(CAutoArgs& args)
{
	IMsiRecord* piError = 0;
	const IMsiString* piName;

	if ((piError = m_riStorage.GetName(piName)) == 0)
	{
		args = piName->GetString();
		piName->Release();
	}
	else
	{
		piError->Release();
		args = (varVoid)0;
	}
}

void CAutoStorage::OpenStream(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riStorage.OpenStream(args[1], args[2], piStream);
	if (piError)
		throw piError;
	args = new CAutoStream(*piStream);
}

void CAutoStorage::OpenStorage(CAutoArgs& args)
{
	IMsiStorage* piStorage;
	IMsiRecord* piError = m_riStorage.OpenStorage(args[1], (ismEnum)(int)args[2], piStorage);
	if (piError)
		throw piError;
	args = new CAutoStorage(*piStorage);
}

void CAutoStorage::Streams(CAutoArgs& args)
{
	IEnumMsiString* piEnum = m_riStorage.GetStreamEnumerator();
	if (!piEnum)
		throw MsiStorage_Streams;
	args = *piEnum;
}

void CAutoStorage::Storages(CAutoArgs& args)
{
	IEnumMsiString* piEnum = m_riStorage.GetStorageEnumerator();
	if (!piEnum)
		throw MsiStorage_Storages;
	args = *piEnum;
}

void CAutoStorage::RemoveElement(CAutoArgs& args)
{
	Bool fStorage = fFalse;
	if (args.Present(2))
		fStorage = args[2];
	IMsiRecord* piError = m_riStorage.RemoveElement(args[1], fStorage);
	if (piError)
		throw piError;
}

void CAutoStorage::RenameElement(CAutoArgs& args)
{
	Bool fStorage = fFalse;
	if (args.Present(3))
		fStorage = args[3];
	IMsiRecord* piError = m_riStorage.RenameElement(args[1], args[2], fStorage);
	if (piError)
		throw piError;
}

void CAutoStorage::Commit(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riStorage.Commit();
	if (piError)
		throw piError;
}

void CAutoStorage::Rollback(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riStorage.Rollback();
	if (piError)
		throw piError;
}

void CAutoStorage::DeleteOnRelease(CAutoArgs& args)
{
	args = m_riStorage.DeleteOnRelease(false);
}

void CAutoStorage::CreateSummaryInfo(CAutoArgs& args)
{
	IMsiSummaryInfo* piSummary;
	IMsiRecord* piError = m_riStorage.CreateSummaryInfo(args[1], piSummary);
	if (piError)
		throw piError;
	args =  new CAutoSummaryInfo(*piSummary);
}

void CAutoStorage::CopyTo(CAutoArgs& args)
{
	IMsiRecord* piExcluded = 0;

	if (args.Present(2))
		piExcluded = &(IMsiRecord&)args[2].Object(IID_IMsiRecord);

	IMsiRecord* piError = m_riStorage.CopyTo(
		(IMsiStorage&)args[1].Object(IID_IMsiStorage),
		piExcluded);

	if (piError)
		throw piError;
}

//____________________________________________________________________________
//
// MsiStream automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1055-0000-0000-C000-000000000046),  // IID_IMsiAutoStream
		helpcontext(MsiStream_Object),helpstring("Database view object.")
	]
	dispinterface MsiStream
	{
		properties:
		methods:
			[id(1) ,propget,helpcontext(MsiStream_Length),helpstring("Returns the size of the stream in bytes.")]
					long Length();
			[id(2) ,propget,helpcontext(MsiStream_Remaining),helpstring("Returns the number of bytes remaining in the stream.")]
					long Remaining();
			[id(3) ,propget,helpcontext(MsiStream_Error),helpstring("Returns a boolean indicating if a transfer error occurred.")]
					boolean Error();
			[id(4),helpcontext(MsiStream_GetData),helpstring("Copies the next count bytes into a string of that size and returns that string.")]
					BSTR GetData(long count);
			[id(5),helpcontext(MsiStream_PutData),helpstring("Copies all bytes from the string into the stream.")]
					void PutData(BSTR buffer);
			[id(6),helpcontext(MsiStream_GetInt16),helpstring("Returns the next 2 bytes as a short integer.")]
					short GetInt16();
			[id(7),helpcontext(MsiStream_GetInt32),helpstring("Returns the next 4 bytes as a long integer.")]
					long GetInt32();
			[id(8),helpcontext(MsiStream_PutInt16),helpstring("Writes the short integer into the next 2 bytes in the stream.")]
					void PutInt16(short value);
			[id(9),helpcontext(MsiStream_PutInt32),helpstring("Writes the long integer into the next 4 bytes in the stream.")]
					void PutInt32(long value);
			[id(10),helpcontext(MsiStream_Reset),helpstring("Resets the stream pointer to the start of stream.")]
					void Reset();
			[id(11),helpcontext(MsiStream_Seek),helpstring("Sets the stream pointer to a new location.")]
					void Seek(long position);
			[id(12),helpcontext(MsiStream_Clone),helpstring("Creates a clone of the stream object.")]
					MsiStream* Clone();
	};
*/

DispatchEntry<CAutoStream> AutoStreamTable[] = {
	1, aafPropRO, CAutoStream::Length,        TEXT("Length"),
	2, aafPropRO, CAutoStream::Remaining,     TEXT("Remaining"),
	3, aafPropRO, CAutoStream::Error,         TEXT("Error"),
	4, aafMethod, CAutoStream::GetData,       TEXT("GetData,count"),
	5, aafMethod, CAutoStream::PutData,       TEXT("PutData,buffer"),
	6, aafMethod, CAutoStream::GetInt16,      TEXT("GetInt16"),
	7, aafMethod, CAutoStream::GetInt32,      TEXT("GetInt32"),
	8, aafMethod, CAutoStream::PutInt16,      TEXT("PutInt16,value"),
	9, aafMethod, CAutoStream::PutInt32,      TEXT("PutInt32,value"),
	10, aafMethod, CAutoStream::Reset,        TEXT("Reset"),
	11, aafMethod, CAutoStream::Seek,         TEXT("Seek,position"),
	12, aafMethod, CAutoStream::Clone,        TEXT("Clone"),
};
const int AutoStreamCount = sizeof(AutoStreamTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiStream automation implementation
//____________________________________________________________________________

CAutoStream::CAutoStream(IMsiStream& riStream)
 : CAutoBase(*AutoStreamTable, AutoStreamCount), m_riStream(riStream)
{
}

CAutoStream::~CAutoStream()
{
	m_riStream.Release();
}

IUnknown& CAutoStream::GetInterface()
{
	return m_riStream;
}

void CAutoStream::Length(CAutoArgs& args)
{
	args = m_riStream.GetIntegerValue();
}

void CAutoStream::Remaining(CAutoArgs& args)
{
	args = (int)m_riStream.Remaining();
}

void CAutoStream::Error(CAutoArgs& args)
{
	args = m_riStream.Error();
}

void CAutoStream::GetData(CAutoArgs& args)
{
	int cb = args[1];
	if (cb > m_riStream.Remaining())
		cb = m_riStream.Remaining();
	const IMsiString* piStr = g_piStringNull;
#ifdef UNICODE
	CTempBuffer<char, 1024> rgchBuf;
	rgchBuf.SetSize(cb);
	int cbRead = (int)m_riStream.GetData(rgchBuf, cb);
	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, cb, 0, 0); //!! should use m_iCodepage from database, but how?
	ICHAR* pch = piStr->AllocateString(cch, fFalse, piStr);
	WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, cb, pch, cch);
#else
	ICHAR* pch = piStr->AllocateString(cb, fFalse, piStr);
	int cbRead = (int)m_riStream.GetData(pch, cb);
#endif
	args = piStr;
}

void CAutoStream::PutData(CAutoArgs& args)
{
	const IMsiString& riData = args[1].GetMsiString();
#ifdef UNICODE
	int cch = riData.TextSize();
	CTempBuffer<char, 1024> rgchBuf;
	unsigned int cb = WIN::WideCharToMultiByte(CP_ACP, 0, riData.GetString(), cch, 0, 0, 0, 0);
	rgchBuf.SetSize(cb);
	WIN::WideCharToMultiByte(CP_ACP, 0, riData.GetString(), cch, rgchBuf, cb, 0, 0);
	m_riStream.PutData(rgchBuf, cb);
	riData.Release();
#else
	m_riStream.PutData((const ICHAR*)MsiString(riData), riData.TextSize());
#endif
}

void CAutoStream::GetInt16(CAutoArgs& args)
{
	args = m_riStream.GetInt16();
}

void CAutoStream::GetInt32(CAutoArgs& args)
{
	args = m_riStream.GetInt32();
}

void CAutoStream::PutInt16(CAutoArgs& args)
{
	m_riStream.PutInt16(args[1]);
}

void CAutoStream::PutInt32(CAutoArgs& args)
{
	m_riStream.PutInt32(args[1]);
}

void CAutoStream::Reset(CAutoArgs& /*args*/)
{
	m_riStream.Reset();
}

void CAutoStream::Seek(CAutoArgs& args)
{
	m_riStream.Seek(args[1]);
}

void CAutoStream::Clone(CAutoArgs& args)
{
	IMsiStream* piStream = m_riStream.Clone();
	if (piStream == 0)
		throw MsiStream_Clone;
	args = new CAutoStream(*piStream);
}

//____________________________________________________________________________
//
// MsiSummaryInfo automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1056-0000-0000-C000-000000000046),  // IID_IMsiAutoSummaryInfo
		helpcontext(MsiSummaryInfo_Object),helpstring("SummaryInformation stream property management.")
	]
	dispinterface MsiSummaryInfo
	{
		properties:
		methods:
			[id(0),propget, helpcontext(MsiSummaryInfo_Property),helpstring("Reads, writes, or deletes a specifed property from the stream.")]
				variant Property([in] long pid);
			[id(0),propput]
				void Property([in] long pid, [in] variant value);
			[id(1),propget,helpcontext(MsiSummaryInfo_PropertyCount),helpstring("The number of old and new properties currently in the object.")]
					long PropertyCount();
			[id(2),propget,helpcontext(MsiSummaryInfo_PropertyType),helpstring("The type of the property with the specified ID.")]
					long PropertyType([in] long pid);
			[id(3),helpcontext(MsiSummaryInfo_WritePropertyStream),helpstring("Generates the summary stream from the specified properties.")]
					void WritePropertyStream();
	};              
*/

DispatchEntry<CAutoSummaryInfo> AutoSummaryInfoTable[] = {
	0, aafPropRW, CAutoSummaryInfo::Property,           TEXT("Property,pid"),
	1, aafPropRO, CAutoSummaryInfo::PropertyCount,      TEXT("PropertyCount"),
	2, aafPropRO, CAutoSummaryInfo::PropertyType,       TEXT("PropertyType,pid"),
   3, aafMethod, CAutoSummaryInfo::WritePropertyStream,TEXT("WritePropertyStream"),
};
const int AutoSummaryInfoCount = sizeof(AutoSummaryInfoTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// MsiSummaryInfo automation implementation
//____________________________________________________________________________

CAutoSummaryInfo::CAutoSummaryInfo(IMsiSummaryInfo& riSummaryInfo)
 : CAutoBase(*AutoSummaryInfoTable, AutoSummaryInfoCount), m_riSummary(riSummaryInfo)
{
	// s_piServices should be set -- you need a services object to create an autosummary
	g_cServicesUsers++;
}

CAutoSummaryInfo::~CAutoSummaryInfo()
{
	m_riSummary.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoSummaryInfo::GetInterface()
{
	return m_riSummary;
}

void CAutoSummaryInfo::Property(CAutoArgs& args)
{
	int iPID = args[1];
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (var.GetType() == VT_EMPTY)
			m_riSummary.RemoveProperty(iPID);
		else if (var.GetType() == VT_BSTR)
			m_riSummary.SetStringProperty(iPID, *MsiString(var.GetMsiString()));
		else if (var.GetType() == VT_DATE || var.GetType() == VT_R8)
			m_riSummary.SetTimeProperty(iPID, var);
		else
			m_riSummary.SetIntegerProperty(iPID, var);
	}
	else
	{
		int iType = m_riSummary.GetPropertyType(iPID);
		int i;
		MsiDate iDateTime;
		switch (iType)
		{
			case VT_EMPTY:
				args = (varVoid)0;
				break;
			case VT_I2:
				m_riSummary.GetIntegerProperty(iPID, i);
				args = short(i);
				break;
			case VT_I4:
				m_riSummary.GetIntegerProperty(iPID, i);
				args = i;
				break;
			case VT_LPSTR:
				args = m_riSummary.GetStringProperty(iPID);
				break;
			case VT_FILETIME:
				m_riSummary.GetTimeProperty(iPID, iDateTime);
				args = iDateTime;
				break;
			default:
				args = TEXT("[Unhandled property type]");
		};
	}
}

void CAutoSummaryInfo::PropertyCount(CAutoArgs& args)
{
	args = m_riSummary.GetPropertyCount();
}

void CAutoSummaryInfo::PropertyType(CAutoArgs& args)
{
	args = m_riSummary.GetPropertyType(args[1]);
}

void CAutoSummaryInfo::WritePropertyStream(CAutoArgs& /*args*/)
{
	if (!m_riSummary.WritePropertyStream())
		throw MsiSummaryInfo_WritePropertyStream;
}

//____________________________________________________________________________
//
// MsiDatabase automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C104D-0000-0000-C000-000000000046),  // IID_IMsiAutoDatabase
		helpcontext(MsiDatabase_Object),helpstring("Database object.")
	]
	dispinterface MsiDatabase
	{
		properties:
		methods:
			[id(1),propget, helpcontext(MsiDatabase_UpdateState),helpstring("The persistent state of the database, idsEnum")]
					long UpdateState();
			[id(2),propget, helpcontext(MsiDatabase_Storage),helpstring("The selected MsiStorage object, if present")]
					MsiStorage* Storage(long index);
			[id(3),helpcontext(MsiDatabase_OpenView),helpstring("Opens a view using an SQL query string")]
					MsiView* OpenView(BSTR sql, long intent);
			[id(4),helpcontext(MsiDatabase_GetPrimaryKeys),helpstring("Returns a record containing the table name and each primary key column name")]
					MsiRecord* GetPrimaryKeys(BSTR table);
			[id(5),helpcontext(MsiDatabase_ImportTable),helpstring("Imports an IDT format text file to the database, dropping any existing table")]
					void ImportTable(MsiPath* path, BSTR file);
			[id(6),helpcontext(MsiDatabase_ExportTable),helpstring("Exports the specified table to an IDT format text file")]
					void ExportTable(BSTR table, MsiPath* path, BSTR file);
			[id(7),helpcontext(MsiDatabase_DropTable),helpstring("Drops the specified table from the database")]
					void DropTable(BSTR table);
			[id(8),helpcontext(MsiDatabase_FindTable),helpstring("Returns the status for a table in the database")]
					long FindTable(BSTR table);
			[id(9),helpcontext(MsiDatabase_LoadTable),helpstring("Loads an existing table into memory")]
					MsiTable* LoadTable(BSTR table, long addColumns);
			[id(10),helpcontext(MsiDatabase_CreateTable),helpstring("Creates a temporary table in memory")]
					MsiTable* CreateTable(BSTR table, long initRows);
			[id(11),helpcontext(MsiDatabase_LockTable),helpstring("Hint to keep table loaded")]
					boolean LockTable(BSTR table, boolean lock);
			[id(12),helpcontext(MsiDatabase_GetCatalogTable),helpstring("Returns the database table catalog object")]
					MsiTable* GetCatalogTable(long table);
			[id(13),helpcontext(MsiDatabase_DecodeString),helpstring("Converts a string index to the actual string")]
					BSTR DecodeString(long index);
			[id(14),helpcontext(MsiDatabase_EncodeString),helpstring("Converts a string to its string index")]
					long EncodeString(BSTR text);
			[id(15),helpcontext(MsiDatabase_CreateTempTableName),helpstring("Creates a unique name for temporary table")]
					BSTR CreateTempTableName();
			[id(16),helpcontext(MsiDatabase_Commit),helpstring("Commits persistent updates to storage")]
					void Commit();
			[id(17),helpcontext(MsiDatabase_CreateOutputDatabase),helpstring("Establishes separate output database")]
					void CreateOutputDatabase(BSTR file, boolean saveTempRows);
			[id(18),helpcontext(MsiDatabase_GenerateTransform),helpstring("Generates a transform file")]
					void GenerateTransform(MsiDatabase* reference, MsiStorage* transform, long errorConditions, long validation);
			[id(19),helpcontext(MsiDatabase_SetTransform),helpstring("Sets a transform file")]
					void SetTransform(MsiStorage* transform, long errorConditions );
			[id(20),helpcontext(MsiDatabase_MergeDatabase),helpstring("Merges two databases into base database")]
					void MergeDatabase(MsiDatabase* reference, MsiTable* errorTable);
			[id(21),propget, helpcontext(MsiDatabase_TableState),helpstring("Returns an attribute for a table in the database")]
					boolean TableState(BSTR table, long state);
			[id(22),propget, helpcontext(MsiDatabase_ANSICodePage),helpstring("Returns the codepage of the database, 0 if neutral")]
					long ANSICodePage();
	};
*/

DispatchEntry<CAutoDatabase> AutoDatabaseTable[] = {
	1, aafPropRO, CAutoDatabase::UpdateState,    TEXT("UpdateState"),
	2, aafPropRO, CAutoDatabase::Storage,        TEXT("Storage,index"),
	3, aafMethod, CAutoDatabase::OpenView,       TEXT("OpenView,sql,intent"),
	4, aafMethod, CAutoDatabase::GetPrimaryKeys, TEXT("GetPrimaryKeys,table"),
	5, aafMethod, CAutoDatabase::ImportTable,    TEXT("ImportTable,path,file"),
	6, aafMethod, CAutoDatabase::ExportTable,    TEXT("ExportTable,table,path,file"),
	7, aafMethod, CAutoDatabase::DropTable,      TEXT("DropTable,table"),
	8, aafMethod, CAutoDatabase::FindTable,      TEXT("FindTable,table"),
	9, aafMethod, CAutoDatabase::LoadTable,      TEXT("LoadTable,table,addColumns"),
	10,aafMethod, CAutoDatabase::CreateTable,    TEXT("CreateTable,table,initRows"),
	11,aafMethod, CAutoDatabase::LockTable,      TEXT("LockTable,table,lock"),   
	12,aafMethod, CAutoDatabase::GetCatalogTable,TEXT("GetCatalogTable,table"),
	13,aafMethod, CAutoDatabase::DecodeString,   TEXT("DecodeString,index"),
	14,aafMethod, CAutoDatabase::EncodeString,   TEXT("EncodeString,text"),
	15,aafMethod, CAutoDatabase::CreateTempTableName, TEXT("CreateTempTableName"),
	16,aafMethod, CAutoDatabase::Commit,         TEXT("Commit"),
	17,aafMethod, CAutoDatabase::CreateOutputDatabase,TEXT("CreateOutputDatabase,file,saveTempRows"),
	18,aafMethod, CAutoDatabase::GenerateTransform,TEXT("GenerateTransform,reference,transform,errorConditions,validation"),
	19,aafMethod, CAutoDatabase::SetTransform,   TEXT("SetTransform,storage,errorConditions"),
	20,aafMethod, CAutoDatabase::MergeDatabase, TEXT("MergeDatabase,reference,errorTable"),
	21,aafPropRO, CAutoDatabase::TableState,    TEXT("TableState,table,state"),
	22,aafPropRO, CAutoDatabase::ANSICodePage,  TEXT("ANSICodePage"),
};
const int AutoDatabaseCount = sizeof(AutoDatabaseTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoDatabase automation implementation
//____________________________________________________________________________

CAutoDatabase::CAutoDatabase(IMsiDatabase& riDatabase)
 : CAutoBase(*AutoDatabaseTable, AutoDatabaseCount),
	m_riDatabase(riDatabase)
{
}

CAutoDatabase::~CAutoDatabase()
{
	m_riDatabase.Release();
}

IUnknown& CAutoDatabase::GetInterface()
{
	return m_riDatabase;
}

void CAutoDatabase::UpdateState(CAutoArgs& args)
{
	args = (int)m_riDatabase.GetUpdateState();
}

void CAutoDatabase::Storage(CAutoArgs& args)
{
	IMsiStorage* piStorage = m_riDatabase.GetStorage(args[1]);
	if (piStorage)
		args = new CAutoStorage(*piStorage);
	else
		args = (IDispatch*)0;
}

void CAutoDatabase::OpenView(CAutoArgs& args)
{
	IMsiView* piView;
	IMsiRecord* piError = m_riDatabase.OpenView(args[1], (ivcEnum)(int)args[2], piView);
	if (piError)
		throw piError;
	args = new CAutoView(*piView);
}

void CAutoDatabase::GetPrimaryKeys(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riDatabase.GetPrimaryKeys(args[1]);
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoDatabase::ExportTable(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDatabase.ExportTable(args[1], (IMsiPath&)args[2].Object(IID_IMsiPath), args[3]);
	if (piError)
		throw piError;
}

void CAutoDatabase::ImportTable(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDatabase.ImportTable((IMsiPath&)args[1].Object(IID_IMsiPath), args[2]);
	if (piError)
		throw piError;
}

void CAutoDatabase::DropTable(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDatabase.DropTable(args[1]);
	if (piError)
		throw piError;
}

void CAutoDatabase::FindTable(CAutoArgs& args)
{
	args = (int)m_riDatabase.FindTable(*MsiString(args[1].GetMsiString()));
}

void CAutoDatabase::TableState(CAutoArgs& args)
{
	args = (Bool)m_riDatabase.GetTableState((const ICHAR * )args[1],
													(itsEnum)(int)args[2]);
}

void CAutoDatabase::ANSICodePage(CAutoArgs& args)
{
	args = m_riDatabase.GetANSICodePage();
}

void CAutoDatabase::LoadTable(CAutoArgs& args)
{
	unsigned int cAddColumns = 0;
	if(args.Present(2))
		cAddColumns = args[2];
	IMsiTable* piTable;
	IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(args[1].GetMsiString()),
																cAddColumns, piTable);
	if (piError)
		throw piError;
	args = new CAutoTable(*piTable);
}

void CAutoDatabase::CreateTable(CAutoArgs& args)
{
	unsigned int cInitRows = 0;
	if(args.Present(2))
		cInitRows = args[2];
	IMsiTable* piTable;
	IMsiRecord* piError = m_riDatabase.CreateTable(*MsiString(args[1].GetMsiString()),
																  cInitRows, piTable);
	if (piError)
		throw piError;
	args = new CAutoTable(*piTable);
}

void CAutoDatabase::LockTable(CAutoArgs& args)
{
	args = m_riDatabase.LockTable(*MsiString(args[1].GetMsiString()), args[2]);
}

void CAutoDatabase::GetCatalogTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riDatabase.GetCatalogTable(args[1]);
	if (!piTable)
		throw MsiDatabase_GetCatalogTable;
	args = new CAutoTable(*piTable);
}

void CAutoDatabase::DecodeString(CAutoArgs& args)
{
	args = m_riDatabase.DecodeString(args[1]);
}

void CAutoDatabase::EncodeString(CAutoArgs& args)
{
	args = (int)m_riDatabase.EncodeString(*MsiString(args[1].GetMsiString()));
}

void CAutoDatabase::CreateTempTableName(CAutoArgs& args)
{
	args = m_riDatabase.CreateTempTableName();
}

void CAutoDatabase::Commit(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDatabase.Commit();
	if (piError)
		throw piError;
}

void CAutoDatabase::CreateOutputDatabase(CAutoArgs& args)
{
	Bool fSaveTempRows = args.Present(2) ? args[2] : fFalse;
	IMsiRecord* piError = m_riDatabase.CreateOutputDatabase(args[1], fSaveTempRows);
	if (piError)
		throw piError;
}

void CAutoDatabase::GenerateTransform(CAutoArgs& args)
{
	CVariant& var = args[2];

	IMsiRecord* piError = m_riDatabase.GenerateTransform(
		(IMsiDatabase&)args[1].Object(IID_IMsiDatabase), 
		var.GetType() == VT_EMPTY ? 0 : (IMsiStorage*)var.ObjectPtr(IID_IMsiStorage),
   	args[3],
		args[4]);

	if (piError)
		throw piError;
}

void CAutoDatabase::SetTransform(CAutoArgs& args)
{
	IMsiRecord* piError = 
       m_riDatabase.SetTransform((IMsiStorage&)args[1].Object(IID_IMsiStorage),
                                 args[2]);
	if (piError)
		throw piError;
}

void CAutoDatabase::MergeDatabase(CAutoArgs& args)
{
	IMsiTable* piTable = NULL;
	if (args.Present(2))
		piTable = &(IMsiTable&)args[2].Object(IID_IMsiTable);
	IMsiRecord* piError =
		m_riDatabase.MergeDatabase((IMsiDatabase&)args[1].Object(IID_IMsiDatabase),
								   piTable);
	if (piError)
		throw piError;
}



//____________________________________________________________________________
//
// MsiView automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C104C-0000-0000-C000-000000000046),  // IID_IMsiAutoView
		helpcontext(MsiView_Object),helpstring("Database view object.")
	]
	dispinterface MsiView
	{
		properties:
		methods:
			[id(1),helpcontext(MsiView_Execute),helpstring("Accepts query parameters and executes the database query.")]
					void Execute(MsiRecord* record);
			[id(2) ,propget,helpcontext(MsiView_FieldCount),helpstring("Returns the number of columns fetched into MsiRecord fields.")]
					long FieldCount();
			[id(3),helpcontext(MsiView_Fetch),helpstring("Returns an MsiRecord object containing the requested column data if more rows are available.")]
					MsiRecord* Fetch();
			[id(4),helpcontext(MsiView_GetColumnNames),helpstring("Returns an MsiRecord object containing the columns names corresponding to the fetched record fields.")]
					MsiRecord* GetColumnNames();
			[id(5),helpcontext(MsiView_GetColumnTypes),helpstring("Returns an MsiRecord objects with text fields containing the data types of the columns.")]
					MsiRecord* GetColumnTypes();
			[id(6),helpcontext(MsiView_Modify),helpstring("Performs specified action on a MsiRecord object corresponding to a Database row.")]
					void Modify(MsiRecord* record, long action);
			[id(7),propget,helpcontext(MsiView_RowCount),helpstring("Returns the number of rows affected by MsiView.Execute.")]
					long RowCount();
			[id(8),helpcontext(MsiView_Close),helpstring("Terminates query execution and releases database resources.")]
					void Close();
			[id(9),helpcontext(MsiView_GetError),helpstring("Returns column name and error that occured")]
					BSTR GetError();
			[id(10),helpcontext(MsiView_State),helpstring("Returns the current cursor state of the view object")]
					long State();
	};              
*/

DispatchEntry<CAutoView> AutoViewTable[] = {
	1, aafMethod, CAutoView::Execute,       TEXT("Execute,record"),
	2, aafPropRO, CAutoView::FieldCount,    TEXT("FieldCount"),
	3, aafMethod, CAutoView::Fetch,         TEXT("Fetch"),
	4, aafMethod, CAutoView::GetColumnNames,TEXT("GetColumnNames"),
	5, aafMethod, CAutoView::GetColumnTypes,TEXT("GetColumnTypes"),
	6, aafMethod, CAutoView::Modify,        TEXT("Modify,record,action"),
	7, aafPropRO, CAutoView::RowCount,      TEXT("RowCount"),
	8, aafMethod, CAutoView::Close,         TEXT("Close"),
	9, aafMethod, CAutoView::GetError,		TEXT("GetError"),
	10,aafPropRO, CAutoView::State,         TEXT("State"),
};
const int AutoViewCount = sizeof(AutoViewTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiView automation implementation
//____________________________________________________________________________

CAutoView::CAutoView(IMsiView& riView)
 : CAutoBase(*AutoViewTable, AutoViewCount), m_riView(riView)
{
}

CAutoView::~CAutoView()
{
	m_riView.Release();
}

IUnknown& CAutoView::GetInterface()
{
	return m_riView;
}

void CAutoView::Execute(CAutoArgs& args)
{
	IMsiRecord* piRecord= args.Present(1) ? &(IMsiRecord&)args[1].Object(IID_IMsiRecord) : 0;
	IMsiRecord* piError = m_riView.Execute(piRecord);
	if (piError)
		throw piError;
	return;
}

void CAutoView::FieldCount(CAutoArgs& args)
{
	args = (int)m_riView.GetFieldCount();
}

void CAutoView::GetColumnNames(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riView.GetColumnNames();
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoView::GetColumnTypes(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riView.GetColumnTypes();
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoView::Fetch(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riView.Fetch();
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoView::Modify(CAutoArgs& args)
{
	IMsiRecord* piError = m_riView.Modify((IMsiRecord&)args[1].Object(IID_IMsiRecord), (irmEnum)(int)args[2]);
	if (piError)
		throw piError;
}

void CAutoView::Close(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riView.Close();
	if (piError)
		throw piError;
}

void CAutoView::GetError(CAutoArgs& args)
{
	MsiString strCol;
	iveEnum iveReturn = m_riView.GetError(*&strCol);
	strCol += MsiChar(',');
	strCol += MsiChar(int(iveReturn));
	args = (const ICHAR*)strCol;
}

void CAutoView::RowCount(CAutoArgs& args)
{
	long lRowCount;
	IMsiRecord* piError = m_riView.GetRowCount(lRowCount);
	if (piError)
		throw piError;
	args = lRowCount;
}

void CAutoView::State(CAutoArgs& args)
{
	args = (int)m_riView.GetState();
}

//____________________________________________________________________________
//
// MsiData automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1041-0000-0000-C000-000000000046),  // IID_IMsiAutoData
		helpcontext(MsiData_Object),helpstring("Data value base object.")
	]
	dispinterface MsiData
	{
		properties:
			[id(0), helpcontext(MsiData_StringValue), helpstring("String value of the object")]
				BSTR StringValue;
		methods:
			[id(1), propget, helpcontext(MsiData_IntegerValue), helpstring("Integer value for object")]
				long IntegerValue();
	};
*/
  
DispatchEntry<CAutoData> AutoDataTable[] = {
	0, aafPropRO, CAutoData::StringValue,   TEXT("StringValue"),
	1, aafPropRO, CAutoData::IntegerValue,  TEXT("IntegerValue"),
};
const int AutoDataCount = sizeof(AutoDataTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoData automation implementation
//____________________________________________________________________________

CAutoData::CAutoData(const IMsiData* piData)
 : CAutoBase(*AutoDataTable, AutoDataCount), m_piData(piData)
{
}

CAutoData::~CAutoData()
{
	if (m_piData)
		m_piData->Release();
}

IUnknown& CAutoData::GetInterface()
{
	if (m_piData)
		return *(IUnknown*)m_piData;
	else
		return g_NullInterface;
}

void CAutoData::StringValue(CAutoArgs& args)
{
	if (m_piData)
		args = m_piData->GetMsiStringValue();
	else
		args = (BSTR)0;
}

void CAutoData::IntegerValue(CAutoArgs& args)
{
	args = m_piData ? m_piData->GetIntegerValue() : iMsiNullInteger;
}

//____________________________________________________________________________
//
// MsiTable automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1048-0000-0000-C000-000000000046),  // IID_IMsiAutoDatabase
		helpcontext(MsiTable_Object),helpstring("Database low-level table object.")
	]
	dispinterface MsiTable
	{
		properties:
		methods:
			[id(1),propget,helpcontext(MsiTable_Database),helpstring("The MsiDatabase object that owns this table.")]
					MsiDatabase* Database();
			[id(2),propget,helpcontext(MsiTable_RowCount),helpstring("The number of rows of data currently in the table.")]
					long RowCount();
			[id(3),propget,helpcontext(MsiTable_ColumnCount),helpstring("The number of columns in the table.")]
					long ColumnCount();
			[id(4),propget,helpcontext(MsiTable_PrimaryKeyCount),helpstring("Returns the number of columns in the primary key.")]
					long PrimaryKeyCount();
			[id(5),propget,helpcontext(MsiTable_ReadOnly),helpstring("Returns True if the table is not updatable.")]
					boolean ReadOnly();
			[id(6),propget,helpcontext(MsiTable_ColumnName),helpstring("Returns the name string index of a column the table.")]
					long ColumnName(long column);
			[id(7),propget,helpcontext(MsiTable_ColumnType),helpstring("Returns the column definition of a column the table.")]
					long ColumnType(long column);
			[id(8),helpcontext(MsiTable_GetColumnIndex),helpstring("Returns the column index given a column name string index.")]
					long GetColumnIndex(long nameIndex);
			[id(9),helpcontext(MsiTable_CreateColumn),helpstring("Adds a column to a loaded or temporary table.")]
					long CreateColumn(long columnDef, BSTR name);
			[id(10),helpcontext(MsiTable_CreateCursor),helpstring("Returns an MsiCursor object in the reset state.")]
					MsiCursor* CreateCursor(boolean tree);
			[id(11),helpcontext(MsiTable_LinkTree),helpstring("Links the table in tree-traversal order.")]
					long LinkTree(long parentColumn);
	};
*/

DispatchEntry<CAutoTable> AutoTableTable[] = {
	1, aafPropRO, CAutoTable::Database,       TEXT("Database"),
	2, aafPropRO, CAutoTable::RowCount,       TEXT("RowCount"),
	3, aafPropRO, CAutoTable::ColumnCount,    TEXT("ColumnCount"),
	4, aafPropRO, CAutoTable::PrimaryKeyCount,TEXT("PrimaryKeyCount"),
	5, aafPropRO, CAutoTable::ReadOnly,       TEXT("ReadOnly"),
	6, aafPropRO, CAutoTable::ColumnName,     TEXT("ColumnName,column"),
	7, aafPropRO, CAutoTable::ColumnType,     TEXT("ColumnType,column"),
	8, aafMethod, CAutoTable::GetColumnIndex, TEXT("GetColumnIndex,nameIndex"),
	9, aafMethod, CAutoTable::CreateColumn,   TEXT("CreateColumn,columnDef,name"),
	10,aafMethod, CAutoTable::CreateCursor,   TEXT("CreateCursor,tree"),
	11,aafMethod, CAutoTable::LinkTree,       TEXT("LinkTree,parentColumn"),
};
const int AutoTableCount = sizeof(AutoTableTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiTable automation implementation
//____________________________________________________________________________

CAutoTable::CAutoTable(IMsiTable& riTable)
 : CAutoBase(*AutoTableTable, AutoTableCount), m_riTable(riTable)
{
}

CAutoTable::~CAutoTable()
{
	m_riTable.Release();
}

IUnknown& CAutoTable::GetInterface()
{
	return m_riTable;
}

void CAutoTable::Database(CAutoArgs& args)
{
	args = new CAutoDatabase(m_riTable.GetDatabase());
}

void CAutoTable::RowCount(CAutoArgs& args)
{
	args = (int)m_riTable.GetRowCount();
}

void CAutoTable::ColumnCount(CAutoArgs& args)
{
	args = (int)m_riTable.GetColumnCount();
}

void CAutoTable::PrimaryKeyCount(CAutoArgs& args)
{
	args = (int)m_riTable.GetPrimaryKeyCount();
}

void CAutoTable::ReadOnly(CAutoArgs& args)
{
	args = m_riTable.IsReadOnly();
}

void CAutoTable::ColumnName(CAutoArgs& args)
{
	args = (int)m_riTable.GetColumnName(args[1]);
}

void CAutoTable::ColumnType(CAutoArgs& args)
{
	int i = m_riTable.GetColumnType(args[1]);
	if (i == -1)
		throw MsiTable_ColumnType;
	args = i;
}

void CAutoTable::GetColumnIndex(CAutoArgs& args)
{
	args = (int)m_riTable.GetColumnIndex(args[1]);
}

void CAutoTable::CreateColumn(CAutoArgs& args)
{
	MsiString istrName;
	if(args.Present(2))
		istrName = args[2].GetMsiString();
	int iColumn = m_riTable.CreateColumn(args[1], *istrName);
	if (iColumn <= 0)
		throw MsiTable_CreateColumn;
	args = iColumn;
}

void CAutoTable::CreateCursor(CAutoArgs& args)
{
	Bool fTree = fFalse;
	if(args.Present(1))
		fTree = args[1];
	IMsiCursor* piCursor = m_riTable.CreateCursor(fTree);
	if (!piCursor)
		throw MsiTable_CreateCursor;
	args = new CAutoCursor(*piCursor);
}

void CAutoTable::LinkTree(CAutoArgs& args)
{
	args = m_riTable.LinkTree(args[1]);
}

//____________________________________________________________________________
//
// MsiCursor automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1049-0000-0000-C000-000000000046),  // IID_IMsiAutoCursor
		helpcontext(MsiCursor_Object),helpstring("Database table cursor object.")
	]
	dispinterface MsiCursor
	{
		properties:
			[id(2),helpcontext(MsiCursor_Filter),helpstring("Column filter bit mask used by Next method.")]
					long Filter;
		methods:
			[id(1),propget,helpcontext(MsiCursor_Table),helpstring("The table that owns this cursor.")]
					MsiTable* Table();
			[id(3),propget,helpcontext(MsiCursor_IntegerData),helpstring("Transfer column data as an integer.")]
					long IntegerData([in] long column);
			[id(3),propput]
					void IntegerData([in] long column, [in] long data);
			[id(4),propget,helpcontext(MsiCursor_StringData),helpstring("Transfer column data as string.")]
					BSTR StringData([in] long column);
			[id(4),propput]
					void StringData([in] long column, [in] BSTR data);
			[id(5),propget,helpcontext(MsiCursor_ObjectData),helpstring("Transfer column data as MsiData object.")]
					MsiData* ObjectData([in] long column);
			[id(5),propput]
					void     ObjectData([in] long column, [in] MsiData* data);
			[id(6),propget,helpcontext(MsiCursor_StreamData),helpstring("Transfer column data as MsiStream object.")]
					MsiData* StreamData([in] long column);
			[id(6),propput]
					void     StreamData([in] long column, [in] MsiData* data);
			[id(7),helpcontext(MsiCursor_PutNull),helpstring("Puts a null column value in the cursor.")]
					void PutNull([in] long column);
			[id(8),helpcontext(MsiCursor_Reset),helpstring("Resets cursor to before first row, clears data.")]
					void Reset();
			[id(9),helpcontext(MsiCursor_Next),helpstring("Advances cursor to next row.")]
					long Next();
			[id(10),helpcontext(MsiCursor_Update),helpstring("Update changed cursor data to table row.")]
					boolean Update();
			[id(11),helpcontext(MsiCursor_Insert),helpstring("Insert cursor data to new table row.")]
					boolean Insert();
			[id(12),helpcontext(MsiCursor_InsertTemporary),helpstring("Insert cursor data to new temporary row.")]
					boolean InsertTemporary();
			[id(13),helpcontext(MsiCursor_Assign),helpstring("Update or insert cursor data to table row.")]
					boolean Assign();
			[id(14),helpcontext(MsiCursor_Merge),helpstring("Inserts a new or matches an identical row.")]
					boolean Merge();
			[id(15),helpcontext(MsiCursor_Refresh),helpstring("Updates the cursor with current values from the table.")]
					boolean Refresh();
			[id(16),helpcontext(MsiCursor_Delete),helpstring("Delete current cursor row from table.")]
					boolean Delete();
			[id(17),helpcontext(MsiCursor_Seek),helpstring("Positions the cursor to the current primary key value.")]
					boolean Seek();
			[id(18),propget,helpcontext(MsiCursor_RowState),helpstring("Sets or gets a row attribute, iraEnum.")]
					boolean RowState([in] long attribute);
			[id(18),propput]
					void RowState([in] long attribute, [in] boolean data);
			[id(19),propget,helpcontext(MsiCursor_DateData),helpstring("Transfer column data as a Date.")]
					DATE DateData([in] long column);
			[id(19),propput]
					void DateData([in] long column, [in] DATE data);
			[id(20),helpcontext(MsiCursor_Validate),helpstring("Validate current cursor row or field.")]
					MsiRecord* Validate([in] MsiTable* table, [in] MsiCursor* cursor, [in] long column);
			[id(21),propget,helpcontext(MsiCursor_Moniker),helpstring("Get unique identifier for current cursor row.")]
					BSTR Moniker();
			[id(22),helpcontext(MsiCursor_Replace),helpstring("Update allowing change to primary key.")]
					boolean Replace();
		};
*/

DispatchEntry<CAutoCursor> AutoCursorTable[] = {
	1, aafPropRO, CAutoCursor::Table,       TEXT("Table"),
	2, aafPropRW, CAutoCursor::Filter,      TEXT("Filter"),
	3, aafPropRW, CAutoCursor::IntegerData, TEXT("IntegerData,column"),
	4, aafPropRW, CAutoCursor::StringData,  TEXT("StringData,column"),
	5, aafPropRW, CAutoCursor::ObjectData,  TEXT("ObjectData,column"),
	6, aafPropRW, CAutoCursor::StreamData,  TEXT("StreamData,column"),
	7, aafMethod, CAutoCursor::PutNull,     TEXT("PutNull"),
	8, aafMethod, CAutoCursor::Reset,       TEXT("Reset"),
	9, aafMethod, CAutoCursor::Next,        TEXT("Next"),
	10,aafMethod, CAutoCursor::Update,      TEXT("Update"),
	11,aafMethod, CAutoCursor::Insert,      TEXT("Insert"),
	12,aafMethod, CAutoCursor::InsertTemporary,TEXT("InsertTemporary"),
	13,aafMethod, CAutoCursor::Assign,      TEXT("Assign"),
	14,aafMethod, CAutoCursor::Merge,       TEXT("Merge"),
	15,aafMethod, CAutoCursor::Refresh,     TEXT("Refresh"),
	16,aafMethod, CAutoCursor::Delete,      TEXT("Delete"),
	17,aafMethod, CAutoCursor::Seek,        TEXT("Seek"),
	18,aafPropRW, CAutoCursor::RowState,    TEXT("RowState,attribute"),
	19,aafPropRW, CAutoCursor::DateData,    TEXT("DateData,column"),
	20,aafMethod, CAutoCursor::Validate,	TEXT("Validate, table, cursor, column"),
	21,aafPropRO, CAutoCursor::Moniker,     TEXT("Moniker"),
	22,aafMethod, CAutoCursor::Replace,     TEXT("Replace"),
};
const int AutoCursorCount = sizeof(AutoCursorTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiCursor automation implementation
//____________________________________________________________________________

CAutoCursor::CAutoCursor(IMsiCursor& riCursor)
 : CAutoBase(*AutoCursorTable, AutoCursorCount), m_riCursor(riCursor)
{
}

CAutoCursor::~CAutoCursor()
{
	m_riCursor.Release();
}

IUnknown& CAutoCursor::GetInterface()
{
	return m_riCursor;
}

void CAutoCursor::IntegerData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		if (!m_riCursor.PutInteger(args[1], args[0]))
			throw MsiCursor_IntegerData;
	}
	else
	{
		args = m_riCursor.GetInteger(args[1]);
	}
}

void CAutoCursor::DateData(CAutoArgs& args)
{
	PMsiTable pTable(&m_riCursor.GetTable()); 
	Bool fIntData = (!(pTable->GetColumnType(args[1]) & icdObject)) ? fTrue : fFalse;
	
	if (args.PropertySet())
	{
		if (fIntData)
		{
			if (!m_riCursor.PutInteger(args[1], int(MsiDate(args[0]))))
				throw MsiCursor_DateData;
		}
		else
		{
			if (!m_riCursor.PutString(args[1], *MsiString(int(MsiDate(args[0])))))
				throw MsiCursor_DateData;
		}
	}
	else
	{
		if (fIntData)
			args = MsiDate(m_riCursor.GetInteger(args[1]));
		else
			args = MsiDate(int(MsiString(m_riCursor.GetString(args[1]))));
	}
}

void CAutoCursor::StringData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		Bool fStat = m_riCursor.PutString(args[1], *MsiString(args[0].GetMsiString()));
		if (fStat == fFalse)
			throw MsiCursor_StringData;
	}
	else
	{
		args = m_riCursor.GetString(args[1]);
	}
}

void CAutoCursor::ObjectData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (!m_riCursor.PutMsiData(args[1], var.GetType() == VT_EMPTY ? 0 : (const IMsiData*)var.ObjectPtr(IID_IMsiData)))
			throw MsiCursor_ObjectData;
	}
	else
	{
		args = new CAutoData(m_riCursor.GetMsiData(args[1]));
	}
}

void CAutoCursor::StreamData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (!m_riCursor.PutStream(args[1], var.GetType() == VT_EMPTY ? 0
										: (IMsiStream*)var.ObjectPtr(IID_IMsiStream)))
			throw MsiCursor_StreamData;
	}
	else
	{
		IMsiStream* piStream = m_riCursor.GetStream(args[1]);
		if (piStream)
			args = new CAutoStream(*piStream);
		else
			args = (IDispatch*)0;
	}
}

void CAutoCursor::PutNull(CAutoArgs& args)
{
	if (!m_riCursor.PutNull(args[1]))
		throw MsiCursor_PutNull;
}

void CAutoCursor::Table(CAutoArgs& args)
{
	args = new CAutoTable(m_riCursor.GetTable());
}

void CAutoCursor::Reset(CAutoArgs& /*args*/)
{
	m_riCursor.Reset();
}

void CAutoCursor::Next(CAutoArgs& args)
{
	args = m_riCursor.Next();
}

void CAutoCursor::Filter(CAutoArgs& args)
{
	if (args.PropertySet())
		m_riCursor.SetFilter(args[0]);
	else
	{
		int iFilter = m_riCursor.SetFilter(0);
		m_riCursor.SetFilter(iFilter);
		args = iFilter;
	}
}

void CAutoCursor::Update(CAutoArgs& args)
{
	args = m_riCursor.Update();
}

void CAutoCursor::Insert(CAutoArgs& args)
{
	args = m_riCursor.Insert();
}

void CAutoCursor::InsertTemporary(CAutoArgs& args)
{
	args = m_riCursor.InsertTemporary();
}

void CAutoCursor::Assign(CAutoArgs& args)
{
	args = m_riCursor.Assign();
}

void CAutoCursor::Replace(CAutoArgs& args)
{
	args = m_riCursor.Replace();
}

void CAutoCursor::Delete(CAutoArgs& args)
{
	args = m_riCursor.Delete();
}

void CAutoCursor::Seek(CAutoArgs& args)
{
	args = m_riCursor.Seek();
}

void CAutoCursor::Merge(CAutoArgs& args)
{
	args = m_riCursor.Merge();
}

void CAutoCursor::Refresh(CAutoArgs& args)
{
	args = m_riCursor.Refresh();
}

void CAutoCursor::RowState(CAutoArgs& args)
{
	if (args.PropertySet())
		m_riCursor.SetRowState((iraEnum)(int)args[1], args[0]);
	else
		args = m_riCursor.GetRowState((iraEnum)(int)args[1]);
}

void CAutoCursor::Validate(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riCursor.Validate((IMsiTable&)args[1].Object(IID_IMsiTable), (IMsiCursor&)args[2].Object(IID_IMsiCursor), args[3]);
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoCursor::Moniker(CAutoArgs& args)
{
	args = m_riCursor.GetMoniker();
}


//____________________________________________________________________________
//
// MsiSelectionManager automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1058-0000-0000-C000-000000000046),  // IID_IMsiAutoSelectionManager
		helpcontext(MsiSelectionManager_Object),helpstring("Selection Manager object.")
	]
	dispinterface MsiSelectionManager
	{
		properties:
		methods:
			[id(1),helpcontext(MsiSelectionManager_LoadSelectionTables),
				helpstring("Loads the Feature and Component tables into memory.")]
				void LoadSelectionTables();
			[id(2),propget,helpcontext(MsiSelectionManager_FeatureTable),
				helpstring("Returns Feature table object.")]
				MsiTable* FeatureTable();
			[id(3),helpcontext(MsiSelectionManager_ProcessConditionTable),
				helpstring("Sets install levels of all Feature table records based on a condition expression.")]
				void ProcessConditionTable();
			[id(4),propget,helpcontext(MsiSelectionManager_ComponentTable),
				helpstring("Returns Component table object.")]
				MsiTable* ComponentTable();
			[id(5),helpcontext(MsiSelectionManager_FreeSelectionTables),
				helpstring("Frees the Feature and Component tables from memory.")]
				boolean FreeSelectionTables();
			[id(6),helpcontext(MsiSelectionManager_SetFeatureHandle),
				helpstring("Sets an external handle into Feature table.")]
				void SetFeatureHandle([in] BSTR feature, [in] long handle);
			[id(7),helpcontext(MsiSelectionManager_SetComponent),
				helpstring("Sets a requested state for an item in the Component table.")]
				void SetComponent([in] BSTR component, [in] long state);
			[id(8),helpcontext(MsiSelectionManager_SetInstallLevel),
				helpstring("Sets the current install level, and updates all Feature table records accordingly.")]
				void SetInstallLevel([in] long iInstallLevel);
			[id(9),helpcontext(MsiSelectionManager_GetVolumeCostTable),
				helpstring("Returns the VolumeCost Table object.")]
				MsiTable* GetVolumeCostTable();
			[id(11),helpcontext(MsiSelectionManager_RecostDirectory),
				helpstring("Recalculates the dynamic cost of every component that references the specified directory.")]
				void RecostDirectory([in] BSTR directoryName, [in] MsiPath* oldPath);
			[id(13),helpcontext(MsiSelectionManager_InitializeComponents),
				helpstring("Initialize all components in the Component table.")]
				void InitializeComponents();
			[id(14),helpcontext(MsiSelectionManager_ConfigureFeature),
				helpstring("Sets the install state for one or all items in the Feature table.")]
				void ConfigureFeature([in] BSTR strFeature, [in] long state);
			[id(15),helpcontext(MsiSelectionManager_GetFeatureCost),
				helpstring("Returns the total amount of disk space required by a feature, NOT including that feature's children.")]
				void GetFeatureCost();
			[id(16),helpcontext(MsiSelectionManager_GetDescendentFeatureCost),
				helpstring("returns the total amount of disk space required by a feature, including that feature's children.")]
				void GetDescendentFeatureCost();
			[id(17),helpcontext(MsiSelectionManager_GetAncestryFeatureCost),
				helpstring("returns the total amount of disk space required by a feature, including that feature's parent feature(s).")]
				void GetAncestryFeatureCost();
			[id(18),helpcontext(MsiSelectionManager_GetFeatureValidStates),
				helpstring("Returns the valid Attributes options for a specified feature.")]
				void GetFeatureValidStates();
	};
*/

DispatchEntry<CAutoSelectionManager> AutoSelectionManagerTable[] = {
	1, aafMethod, CAutoSelectionManager::LoadSelectionTables,TEXT("LoadSelectionTables"),
	2, aafPropRO, CAutoSelectionManager::FeatureTable,TEXT("FeatureTable"),
	3, aafMethod, CAutoSelectionManager::ProcessConditionTable,TEXT("ProcessConditionTable"),
    4, aafPropRO, CAutoSelectionManager::ComponentTable,TEXT("ComponentTable"),
	5, aafMethod, CAutoSelectionManager::FreeSelectionTables,TEXT("FreeSelectionTables"),
	6, aafMethod, CAutoSelectionManager::SetFeatureHandle,TEXT("SetFeatureHandle,feature,handle"),
	7, aafMethod, CAutoSelectionManager::SetComponent,TEXT("SetComponent,component,state"),
	8, aafMethod, CAutoSelectionManager::SetInstallLevel,TEXT("SetInstallLevel,iInstallLevel"),
	9, aafMethod, CAutoSelectionManager::GetVolumeCostTable,TEXT("GetVolumeCostTable"),
   11, aafMethod, CAutoSelectionManager::RecostDirectory,TEXT("RecostDirectory,directoryName,oldPath"),
   13, aafMethod, CAutoSelectionManager::InitializeComponents,TEXT("InitializeComponents"),
   14, aafMethod, CAutoSelectionManager::ConfigureFeature,TEXT("ConfigureFeature"),
   15, aafMethod, CAutoSelectionManager::GetFeatureCost,TEXT("GetFeatureCost"),
   16, aafMethod, CAutoSelectionManager::GetDescendentFeatureCost,TEXT("GetDescendentFeatureCost"),
   17, aafMethod, CAutoSelectionManager::GetAncestryFeatureCost, TEXT("GetAncestryFeatureCost"),
   18, aafMethod, CAutoSelectionManager::GetFeatureValidStates,TEXT("GetFeatureValidStates"),
};
const int AutoSelectionManagerCount = sizeof(AutoSelectionManagerTable)/sizeof(DispatchEntryBase);


//____________________________________________________________________________
//
// CMsiSelectionManager automation implementation
//____________________________________________________________________________

CAutoSelectionManager::CAutoSelectionManager(IMsiSelectionManager& riSelectionManager)
 : CAutoBase(*AutoSelectionManagerTable, AutoSelectionManagerCount),
	m_riSelectionManager(riSelectionManager)
{
}

CAutoSelectionManager::~CAutoSelectionManager()
{
	m_riSelectionManager.Release();
}

IUnknown& CAutoSelectionManager::GetInterface()
{
	return m_riSelectionManager;
}

void CAutoSelectionManager::LoadSelectionTables(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riSelectionManager.LoadSelectionTables();
   if (piError)
      throw piError;
}

void CAutoSelectionManager::FreeSelectionTables(CAutoArgs& args)
{
	args = m_riSelectionManager.FreeSelectionTables();
}

void CAutoSelectionManager::FeatureTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riSelectionManager.GetFeatureTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoSelectionManager::ComponentTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riSelectionManager.GetComponentTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoSelectionManager::ProcessConditionTable(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riSelectionManager.ProcessConditionTable();
	if (piError)
      throw piError;
}


void CAutoSelectionManager::SetFeatureHandle(CAutoArgs& args)
{
	if (!(m_riSelectionManager.SetFeatureHandle(*MsiString(args[1].GetMsiString()), args[2])))
		throw MsiSelectionManager_SetFeatureHandle;
}

void CAutoSelectionManager::SetComponent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.SetComponentSz(args[1],(iisEnum) (int) args[2]);
	if (piError)
		throw piError;
}

void CAutoSelectionManager::InitializeComponents(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riSelectionManager.InitializeComponents();
	if (piError)
		throw piError;
}

void CAutoSelectionManager::SetInstallLevel(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.SetInstallLevel(args[1]);
	if (piError)
		throw piError;
}

void CAutoSelectionManager::GetVolumeCostTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riSelectionManager.GetVolumeCostTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoSelectionManager::RecostDirectory(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.RecostDirectory(*MsiString(args[1].GetMsiString()),
		(IMsiPath&)args[2].Object(IID_IMsiPath));
	if (piError)
		throw piError;
}


void CAutoSelectionManager::ConfigureFeature(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.ConfigureFeature(*MsiString(args[1].GetMsiString()),(iisEnum)(int) args[2]);
	if (piError)
		throw piError;
}

void CAutoSelectionManager::GetFeatureCost(CAutoArgs& args)
{
	int iCost;
	IMsiRecord* piError = m_riSelectionManager.GetFeatureCost(*MsiString(args[1].GetMsiString()),(iisEnum)(int) args[2],iCost);
	if (piError)
		throw piError;
	args = iCost;
}

void CAutoSelectionManager::GetDescendentFeatureCost(CAutoArgs& args)
{
	int iCost;
	IMsiRecord* piError = m_riSelectionManager.GetDescendentFeatureCost(*MsiString(args[1].GetMsiString()),
		(iisEnum)(int) args[2],iCost);
	if (piError)
		throw piError;
	args = iCost;
}

void CAutoSelectionManager::GetAncestryFeatureCost(CAutoArgs& args)
{
	int iCost;
	IMsiRecord* piError = m_riSelectionManager.GetAncestryFeatureCost(*MsiString(args[1].GetMsiString()),
		(iisEnum)(int) args[2],iCost);
	if (piError)
		throw piError;
	args = iCost;
}

void CAutoSelectionManager::GetFeatureValidStates(CAutoArgs& args)
{
	int iValidStates;

	IMsiRecord* piError = m_riSelectionManager.GetFeatureValidStatesSz((const ICHAR *)args[1],iValidStates);
	if (piError)
		throw piError;
	args = iValidStates;
}


//____________________________________________________________________________
//
// MsiDirectoryManager automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1059-0000-0000-C000-000000000046),  // IID_IMsiAutoDirectoryManager
		helpcontext(MsiDirectoryManager_Object),helpstring("Directory Manager object.")
	]
	dispinterface MsiDirectoryManager
	{
		properties:
		methods:
			[id(1),helpcontext(MsiDirectoryManager_LoadDirectoryTable),helpstring("Load directory table into memory.")]
				void LoadDirectoryTable();
			[id(2),propget,helpcontext(MsiDirectoryManager_DirectoryTable),helpstring("Returns directory table object.")]
				MsiTable* DirectoryTable();
			[id(3),helpcontext(MsiDirectoryManager_FreeDirectoryTable),helpstring("Free directory table from memory.")]
				void FreeDirectoryTable();
			[id(4),helpcontext(MsiDirectoryManager_CreateTargetPaths),helpstring("Create target path objects.")]
				void CreateTargetPaths();
			[id(5),helpcontext(MsiDirectoryManager_CreateSourcePaths),helpstring("Create source path objects.")]
				void CreateSourcePaths();
			[id(6),helpcontext(MsiDirectoryManager_GetTargetPath),helpstring("Get a target path object.")]
				MsiPath* GetTargetPath([in] BSTR name);
			[id(7),helpcontext(MsiDirectoryManager_SetTargetPath),helpstring("Set new path for target path object.")]
				void SetTargetPath([in] BSTR name, [in] BSTR path, [in] boolean writecheck);
			[id(8),helpcontext(MsiDirectoryManager_GetSourcePath),helpstring("Get a source path object.")]
				MsiPath* GetSourcePath([in] BSTR name);
	};
*/

DispatchEntry<CAutoDirectoryManager> AutoDirectoryManagerTable[] = {
  1, aafMethod, CAutoDirectoryManager::LoadDirectoryTable,TEXT("LoadDirectoryTable"),
  2, aafPropRO, CAutoDirectoryManager::DirectoryTable,    TEXT("DirectoryTable"),
  3, aafMethod, CAutoDirectoryManager::FreeDirectoryTable,TEXT("FreeDirectoryTable"),
  4, aafMethod, CAutoDirectoryManager::CreateTargetPaths, TEXT("CreateTargetPaths"),
  5, aafMethod, CAutoDirectoryManager::CreateSourcePaths, TEXT("CreateSourcePaths"),
  6, aafMethod, CAutoDirectoryManager::GetTargetPath,     TEXT("GetTargetPath,name"),
  7, aafMethod, CAutoDirectoryManager::SetTargetPath,     TEXT("SetTargetPath,name,path,writecheck"),
  8, aafMethod, CAutoDirectoryManager::GetSourcePath,     TEXT("GetSourcePath,name"),
};
const int AutoDirectoryManagerCount = sizeof(AutoDirectoryManagerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiDirectoryManager automation implementation
//____________________________________________________________________________

CAutoDirectoryManager::CAutoDirectoryManager(IMsiDirectoryManager& riDirectoryManager)
 : CAutoBase(*AutoDirectoryManagerTable, AutoDirectoryManagerCount),
	m_riDirectoryManager(riDirectoryManager)
{
}

CAutoDirectoryManager::~CAutoDirectoryManager()
{
	m_riDirectoryManager.Release();
}

IUnknown& CAutoDirectoryManager::GetInterface()
{
	return m_riDirectoryManager;
}

void CAutoDirectoryManager::LoadDirectoryTable(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDirectoryManager.LoadDirectoryTable(0);
   if (piError)
      throw piError;
}

void CAutoDirectoryManager::DirectoryTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riDirectoryManager.GetDirectoryTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoDirectoryManager::FreeDirectoryTable(CAutoArgs& /*args*/)
{
	m_riDirectoryManager.FreeDirectoryTable();
}

void CAutoDirectoryManager::CreateTargetPaths(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDirectoryManager.CreateTargetPaths();
   if (piError)
      throw piError;
}

void CAutoDirectoryManager::CreateSourcePaths(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDirectoryManager.CreateSourcePaths();
   if (piError)
      throw piError;
}

void CAutoDirectoryManager::GetTargetPath(CAutoArgs& args)
{
	IMsiPath* piPath;
	IMsiRecord* piError = m_riDirectoryManager.GetTargetPath(*MsiString(args[1].GetMsiString()),piPath);
	if (piError)
		throw piError;
	args = piPath ? (IDispatch*)new CAutoPath(*piPath) : (IDispatch*)0;
}

void CAutoDirectoryManager::SetTargetPath(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDirectoryManager.SetTargetPath(*MsiString(args[1].GetMsiString()), 
		args[2], args.Present(3) ? (Bool)args[3] : fTrue);

   if (piError)
      throw piError;
}

void CAutoDirectoryManager::GetSourcePath(CAutoArgs& args)
{
	IMsiPath* piPath = 0;
	IMsiRecord* piError = m_riDirectoryManager.GetSourcePath(*MsiString(args[1].GetMsiString()),piPath);
	if (piError)
		throw piError;
	args = piPath ? (IDispatch*)new CAutoPath(*piPath) : (IDispatch*)0;
}

//____________________________________________________________________________
//
// MsiServer automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105C-0000-0000-C000-000000000046),  // IID_IMsiAutoServer
		helpcontext(MsiServer_Object),helpstring("MsiServer object.")
	]
	dispinterface MsiServer
	{
		properties:
		methods:
			[id(DISPID_MsiConfigurationManager_InstallFinalize),helpcontext(MsiConfigurationManager_InstallFinalize),helpstring("Finalize install on server side, handle rollback")]
				long InstallFinalize([in] long state, [in] MsiMessage* message, [in] boolean userChangedDuringInstall);
			[id(DISPID_MsiConfigurationManager_SetLastUsedSource),helpcontext(MsiConfigurationManager_SetLastUsedSource),helpstring("Sets the last used source for a product")]
				void SetLastUsedSource([in] BSTR productKey, BSTR path, boolean addToList, boolean patch);
		   [id(DISPID_MsiConfigurationManager_DoInstall),helpcontext(MsiConfigurationManager_DoInstall),helpstring("Runs an install")]
				long DoInstall([in] long ireProductSpec, [in] BSTR strProduct, [in] BSTR strAction, [in] BSTR strCommandLine, [in] BSTR strLogFile, [in] long iLogMode, MsiMessage* message, [in] long iioOptions);
  };
*/

DispatchEntry<CAutoServer> AutoServerTable[] = {
  DISPID_MsiConfigurationManager_InstallFinalize    , aafMethod, CAutoServer::InstallFinalize,    TEXT("InstallFinalize,state,messageHandler,userChangedDuringInstall"),
  DISPID_MsiConfigurationManager_SetLastUsedSource, aafMethod, CAutoServer::SetLastUsedSource,  TEXT("SetLastUsedSource,productKey,path,addToList,patch"),
  DISPID_MsiConfigurationManager_DoInstall, aafMethod, CAutoServer::DoInstall,  TEXT("DoInstall,ireProductSpec,product,action,commandline,logfile,logmode,flushEachLine,message,iioOptions"),
};
const int AutoServerCount = sizeof(AutoServerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiServer automation implementation, inherited by CMsiConfigurationManager
//____________________________________________________________________________

CAutoServer::CAutoServer(IMsiServer& riServer, DispatchEntry<CAutoBase>* pTable, int cDispId)
 : CAutoBase(pTable, cDispId)
 , m_riServer(riServer)
{
	riServer.AddRef();
}

CAutoServer::CAutoServer(IMsiServer& riServer)
 : CAutoBase(*AutoServerTable, AutoServerCount)
 , m_riServer(riServer)
{
	riServer.AddRef();
}

CAutoServer::~CAutoServer()
{
	m_riServer.Release();
}

IUnknown& CAutoServer::GetInterface()
{
	return m_riServer;
}

void CAutoServer::InstallFinalize(CAutoArgs& args)
{
	boolean fUserChangedDuringInstall = fFalse;
	
	if(args.Present(3))
		fUserChangedDuringInstall = args[3];

	args = (int)m_riServer.InstallFinalize((iesEnum)(int)args[1],
		(IMsiMessage&)args[2].Object(IID_IMsiMessage), fUserChangedDuringInstall);
}

void CAutoServer::DoInstall(CAutoArgs& args)
{
	args = (int)m_riServer.DoInstall((ireEnum)(int)args[1], args[2], args[3], args[4],args[5],args[6],args[7],
		(IMsiMessage&)args[8].Object(IID_IMsiMessage), (iioEnum)(int)args[9]);
}


void CAutoServer::SetLastUsedSource(CAutoArgs& args)
{
	IMsiRecord* piError = m_riServer.SetLastUsedSource(args[1], args[2], args[3], args[4]);

	if (piError)
		throw piError;
}


//____________________________________________________________________________
//
// MsiConfigurationManager automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105B-0000-0000-C000-000000000046),  // IID_IMsiAutoConfigurationManager
		helpcontext(MsiConfigurationManager_Object),helpstring("Configuration Manager object.")
	]
	dispinterface MsiConfigurationManager
	{
		properties:
		methods:
			[id(DISPID_MsiConfigurationManager_RunScript),helpcontext(MsiConfigurationManager_RunScript),helpstring("Runs a script")]
				long RunScript(BSTR scriptFile, MsiMessage* message, boolean rollbackEnabled, MsiDirectoryManager* dirmgr);
			[id(DISPID_MsiConfigurationManager_InstallFinalize),helpcontext(MsiConfigurationManager_InstallFinalize),helpstring("Finalize install on server side, handle rollback")]
				long InstallFinalize([in] long state, [in] MsiMessage* message, [in] boolean userChangedDuringInstall);
		   [id(DISPID_MsiConfigurationManager_DoInstall),helpcontext(MsiConfigurationManager_DoInstall),helpstring("Run an install")]
				long DoInstall([in] long ireProductSpec, [in] BSTR strProduct, [in] BSTR strAction, [in] BSTR strCommandLine, [in] BSTR strLogFile, [in] long iLogMode, MsiMessage* message, [in] long iioOptions);

			[id(DISPID_MsiConfigurationManager_Services),propget,helpcontext(MsiConfigurationManager_Services),helpstring("The MsiServices object being used.")]
				MsiServices* Services();
			[id(DISPID_MsiConfigurationManager_RegisterComponent),helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("Registers a component")]
				void RegisterComponent(BSTR productCode, BSTR componentCode, long state, BSTR keyPath, long disk, boolean sharedDllRefCount);
		   [id(DISPID_MsiConfigurationManager_UnregisterComponent),helpcontext(MsiConfigurationManager_UnregisterComponent),helpstring("Unregisters a component")]
				void UnregisterComponent(BSTR productCode, BSTR componentCode);
		   [id(DISPID_MsiConfigurationManager_RegisterFolder),helpcontext(MsiConfigurationManager_RegisterFolder),helpstring("Register a folder")]
				void RegisterFolder([in] MsiPath* folder, [in] boolean fExplicit);
		   [id(DISPID_MsiConfigurationManager_IsFolderRemovable),helpcontext(MsiConfigurationManager_IsFolderRemovable),helpstring("Returns true if the folder can be removed; false otherwise")]
				boolean IsFolderRemovable([in] MsiPath* folder, [in] boolean fExplicit);
  		   [id(DISPID_MsiConfigurationManager_UnregisterFolder),helpcontext(MsiConfigurationManager_UnregisterFolder),helpstring("Unregisters a folder")]
				void UnregisterFolder([in] MsiPath* folder);

		   [id(DISPID_MsiConfigurationManager_RegisterRollbackScript),helpcontext(MsiConfigurationManager_RegisterRollbackScript),helpstring("Registers a rollback script")]
				void RegisterRollbackScript([in] BSTR scriptFile);
		   [id(DISPID_MsiConfigurationManager_UnregisterRollbackScript),helpcontext(MsiConfigurationManager_UnregisterRollbackScript),helpstring("Unregisters a rollback script")]
				void UnregisterRollbackScript([in] BSTR scriptFile);
		   [id(DISPID_MsiConfigurationManager_RollbackScripts),helpcontext(MsiConfigurationManager_RollbackScripts),helpstring("Returns a collection of rollback scripts")]
				IEnumVARIANT* RollbackScripts([in] BSTR scriptFile, DATE date, boolean after);
		   [id(DISPID_MsiConfigurationManager_SetLastUsedSource),helpcontext(MsiConfigurationManager_SetLastUsedSource),helpstring("Sets the last used source for a product")]
				void SetLastUsedSource([in] BSTR productKey, BSTR path, boolean addToList, boolean patch);
	};
*/

DispatchEntry<CAutoConfigurationManager> AutoConfigurationManagerTable[] = {
  
  DISPID_MsiConfigurationManager_InstallFinalize    , aafMethod, CAutoServer::InstallFinalize,    TEXT("InstallFinalize,state,messageHandler,userChangedDuringInstall"),  
  DISPID_MsiConfigurationManager_SetLastUsedSource , aafMethod, CAutoServer::SetLastUsedSource,  TEXT("SetLastUsedSource,productKey,path,addToList,patch"),
  DISPID_MsiConfigurationManager_DoInstall         , aafMethod, CAutoServer::DoInstall,  TEXT("DoInstall,ireProductSpec,product,action,commandline,logfile,logmode,message,iioOptions"),
  DISPID_MsiConfigurationManager_Services                    , aafPropRO, CAutoConfigurationManager::Services,                  TEXT("Services"),
  DISPID_MsiConfigurationManager_RegisterComponent           , aafMethod, CAutoConfigurationManager::RegisterComponent,         TEXT("RegisterComponent,productKey,componentCode,state,keyPath,disk,sharedDllRefCount"),
  DISPID_MsiConfigurationManager_UnregisterComponent         , aafMethod, CAutoConfigurationManager::UnregisterComponent,       TEXT("UnregisterComponent,productKey,componentCode"),
  DISPID_MsiConfigurationManager_RegisterFolder              , aafMethod, CAutoConfigurationManager::RegisterFolder,            TEXT("RegisterFolder,folder,fExplicit"),
  DISPID_MsiConfigurationManager_IsFolderRemovable           , aafMethod, CAutoConfigurationManager::IsFolderRemovable,         TEXT("IsFolderRemovable,folder,fExplicit"),
  DISPID_MsiConfigurationManager_UnregisterFolder            , aafMethod, CAutoConfigurationManager::UnregisterFolder,          TEXT("UnregisterFolder,folder"),
  DISPID_MsiConfigurationManager_RegisterRollbackScript      , aafMethod, CAutoConfigurationManager::RegisterRollbackScript,    TEXT("RegisterRollbackScript,scriptfile"),
  DISPID_MsiConfigurationManager_UnregisterRollbackScript    , aafMethod, CAutoConfigurationManager::UnregisterRollbackScript,  TEXT("UnregisterRollbackScript,scriptfile"),
  DISPID_MsiConfigurationManager_RollbackScripts             , aafMethod, CAutoConfigurationManager::RollbackScripts,           TEXT("RollbackScripts,date,after"),
  DISPID_MsiConfigurationManager_RunScript                   , aafMethod, CAutoConfigurationManager::RunScript,          TEXT("RunScript,scriptFile,messageHandler,rollbackEnabled,directoryManager"),
};
const int AutoConfigurationManagerCount = sizeof(AutoConfigurationManagerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiConfigurationManager automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoConfigurationManager(IMsiConfigurationManager& riConfigurationManager)
{
	return new CAutoConfigurationManager(riConfigurationManager);
}

CAutoConfigurationManager::CAutoConfigurationManager(IMsiConfigurationManager& riConfigurationManager)
 : CAutoServer(riConfigurationManager, *AutoConfigurationManagerTable, AutoConfigurationManagerCount)
 , m_riConfigurationManager(riConfigurationManager)
{
	if (g_cServicesUsers == 0)
	{
		s_piServices = &riConfigurationManager.GetServices(); // services was AddRefed
		g_piStringNull = &s_piServices->GetNullString();
		MsiString::InitializeClass(s_piServices->GetNullString());
	}

	g_cServicesUsers++;
}

CAutoConfigurationManager::~CAutoConfigurationManager()
{
	m_riConfigurationManager.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoConfigurationManager::GetInterface()
{
	return m_riConfigurationManager;
}

void CAutoConfigurationManager::Services(CAutoArgs& args)
{
	args = new CAutoServices(m_riConfigurationManager.GetServices());
}


void CAutoConfigurationManager::RegisterFolder(CAutoArgs& args)
{
	MsiString strComponent;

	IMsiRecord* piError = 
		m_riConfigurationManager.RegisterFolder((IMsiPath&)args[1].Object(IID_IMsiPath),
															 (Bool)args[2]);
		
	if (piError)
		throw piError;
}


void CAutoConfigurationManager::IsFolderRemovable(CAutoArgs& args)
{
	Bool fRemovable;

	IMsiRecord* piError = 
		m_riConfigurationManager.IsFolderRemovable((IMsiPath&)args[1].Object(IID_IMsiPath),
																(Bool)args[2],
																fRemovable);
		
	if (piError)
		throw piError;

	args = fRemovable;
}


void CAutoConfigurationManager::UnregisterFolder(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.UnregisterFolder((IMsiPath&)args[1].Object(IID_IMsiPath));
		
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::RunScript(CAutoArgs& args)
{
	IMsiDirectoryManager* piDirMgr = 0;
	if(args.Present(4))
		piDirMgr = (IMsiDirectoryManager*)args[4].ObjectPtr(IID_IMsiDirectoryManager);
	
	args = (int)m_riConfigurationManager.RunScript(MsiString(args[1].GetMsiString()), 
																  (IMsiMessage&)args[2].Object(IID_IMsiMessage),
																  piDirMgr,
																  args[3]);
}

void CAutoConfigurationManager::RegisterComponent(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.RegisterComponent(*MsiString(args[1].GetMsiString()), // product key
													*MsiString(args[2].GetMsiString()), // component key
													(INSTALLSTATE)(int)args[3], // state
													*MsiString(args[4].GetMsiString()), // keypath
													args[5], // disk
													args[6]); // shareddll refcount
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::UnregisterComponent(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.UnregisterComponent(*MsiString(args[1].GetMsiString()),
													*MsiString(args[2].GetMsiString()));
																																
	if (piError)
		throw piError;
}


void CAutoConfigurationManager::RegisterRollbackScript(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.RegisterRollbackScript(MsiString(args[1].GetMsiString()));
	
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::UnregisterRollbackScript(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.UnregisterRollbackScript(MsiString(args[1].GetMsiString()));
	
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::RollbackScripts(CAutoArgs& args)
{
	IEnumMsiString* piEnum;
		
	IMsiRecord* piError = 
		m_riConfigurationManager.GetRollbackScriptEnumerator((MsiDate)args[1],
			(Bool)args[2], piEnum);
	
	if (piError)
		throw piError;
	
	args = *piEnum;
}

//____________________________________________________________________________
//
// MsiExecute automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105E-0000-0000-C000-000000000046),  // IID_IMsiAutoExecute
		helpcontext(MsiExecute_Object),helpstring("Execute object.")
	]
	dispinterface MsiExecute
	{
		properties:
		methods:
			[id(1),helpcontext(MsiExecute_ExecuteRecord),helpstring("Execute an operation")]
				long ExecuteRecord([in] long opCode, [in] MsiRecord* params);
			[id(2),helpcontext(MsiExecute_RunScript),helpstring("Run a script")]
				long RunScript([in] BSTR script);
			[id(4),helpcontext(MsiExecute_RemoveRollbackFiles),helpstring("Remove all rollback files created before a certain time.")]
				void RemoveRollbackFiles([in] long time);
			[id(5),helpcontext(MsiExecute_Rollback),helpstring("Rollback all installations performed after a certain time.")]
				void Rollback([in] long time, [in] boolean userChangedDuringInstall);
			[id(7),helpcontext(MsiExecute_CreateScript),helpstring("Creates a script file")]
				boolean CreateScript([in] MsiStream* stream);
			[id(8),helpcontext(MsiExecute_WriteScriptRecord),helpstring("Writes an operation to the script file")]
				boolean WriteScriptRecord([in] long opCode, [in] MsiRecord* params);
			[id(9),helpcontext(MsiExecute_CloseScript),helpstring("Closes the current script file")]
				void CloseScript();

	};
*/

DispatchEntry<CAutoExecute> AutoExecuteTable[] = {
	1, aafMethod, CAutoExecute::ExecuteRecord,           TEXT("ExecuteRecord,opCode,paramaters"),
	2, aafMethod, CAutoExecute::RunScript,               TEXT("RunScript,script"),
	4, aafMethod, CAutoExecute::RemoveRollbackFiles,     TEXT("RemoveRollbackFiles,time"),
	5, aafMethod, CAutoExecute::Rollback,                TEXT("Rollback,time,userChanged"),
	6, aafMethod, CAutoExecute::RollbackFinalize,        TEXT("RollbackFinalize,state,time,userChanged"),
	7, aafMethod, CAutoExecute::CreateScript,            TEXT("CreateScript,script"),
	8, aafMethod, CAutoExecute::WriteScriptRecord,       TEXT("WriteScriptRecord,opcode,params"),
	9, aafMethod, CAutoExecute::CloseScript,             TEXT("CloseScript"),
};
const int AutoExecuteCount = sizeof(AutoExecuteTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiExecute automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoExecute(IMsiExecute& riExecute)
{
	return new CAutoExecute(riExecute);
}

CAutoExecute::CAutoExecute(IMsiExecute& riExecute)
 : CAutoBase(*AutoExecuteTable, AutoExecuteCount),
	m_riExecute(riExecute), m_pScript(0)
{
	if (g_cServicesUsers == 0)
	{
		s_piServices = &riExecute.GetServices(); // services was AddRefed
		g_piStringNull = &s_piServices->GetNullString();
		MsiString::InitializeClass(s_piServices->GetNullString());
	}

	g_cServicesUsers++;
}

CAutoExecute::~CAutoExecute()
{
	m_riExecute.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoExecute::GetInterface()
{
	return m_riExecute;
}

void CAutoExecute::ExecuteRecord(CAutoArgs& args)
{
	args = (int) m_riExecute.ExecuteRecord((ixoEnum)(int)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord));
}

void CAutoExecute::RunScript(CAutoArgs& args)
{
	args = (int) m_riExecute.RunScript(args[1], false);
}

void CAutoExecute::RemoveRollbackFiles(CAutoArgs& args)
{
	args = (int) m_riExecute.RemoveRollbackFiles((MsiDate)args[1]);
}

void CAutoExecute::Rollback(CAutoArgs& args)
{
	Bool fUserChangedDuringInstall = fFalse;
	if(args.Present(2))
		fUserChangedDuringInstall = args[2];
	args = (int) m_riExecute.Rollback((MsiDate)args[1], fUserChangedDuringInstall ? true : false);
}

void CAutoExecute::RollbackFinalize(CAutoArgs& args)
{
	Bool fUserChangedDuringInstall = fFalse;
	if(args.Present(3))
		fUserChangedDuringInstall = args[3];
	args = (int) m_riExecute.RollbackFinalize((iesEnum)(int)args[1],(MsiDate)args[2], fUserChangedDuringInstall ? true : false);
}

void CAutoExecute::CreateScript(CAutoArgs& args)
{
	if(m_pScript)
	{
		delete m_pScript;
		m_pScript = 0;
	}
	
	PMsiStream pStream(0);
	PMsiRecord pError = s_piServices->CreateFileStream(args[1], fTrue, *&pStream);
		
	if(!pError)
	{
		m_pScript = new CScriptGenerate(*pStream, 0, 0, istInstall, (isaEnum)0, *s_piServices);
	}

#ifdef _ALPHA_
	if(m_pScript && !m_pScript->InitializeScript(PROCESSOR_ARCHITECTURE_ALPHA))
#else // INTEL
	if(m_pScript && !m_pScript->InitializeScript(PROCESSOR_ARCHITECTURE_INTEL))
#endif
	{
		delete m_pScript;
		m_pScript = 0;
	}

	args = m_pScript ? fTrue : fFalse;
}

void CAutoExecute::WriteScriptRecord(CAutoArgs& args)
{
	args = (Bool)(m_pScript ? m_pScript->WriteRecord((ixoEnum)(int)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord), false) : fFalse);
}

void CAutoExecute::CloseScript(CAutoArgs& /*args*/)
{
	if(m_pScript)
		delete m_pScript;
	m_pScript = 0;
}

//____________________________________________________________________________
//
// MsiEngine automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C104E-0000-0000-C000-000000000046),  // IID_IMsiAutoEngine
		helpcontext(MsiEngine_Object),helpstring("Engine object.")
	]
	dispinterface MsiEngine
	{
		properties:
		methods:
			[id(DISPID_MsiEngine_Services),propget,helpcontext(MsiEngine_Services),helpstring("The MsiServices object used by the engine.")]
				MsiServices* Services();
			[id(DISPID_MsiEngine_ConfigurationServer),propget,helpcontext(MsiEngine_ConfigurationServer),helpstring("The MsiServer object used by the engine.")]
				MsiServer* ConfigurationServer();
			[id(DISPID_MsiEngine_Handler),propget,helpcontext(MsiEngine_Handler),helpstring("The MsiHandler object used by the engine.")]
				MsiHandler*  Handler();
			[id(DISPID_MsiEngine_Database),propget,helpcontext(MsiEngine_Database),helpstring("The MsiDatabase object used by the engine.")]
				MsiDatabase* Database();
			[id(DISPID_MsiEngine_Property),propget, helpcontext(MsiEngine_Property),helpstring("Property value indexed by name.")]
				variant Property([in] BSTR name);
			[id(DISPID_MsiEngine_Property),propput]
				void Property([in] BSTR name, [in] variant value);
			[id(DISPID_MsiEngine_SelectionManager),propget,helpcontext(MsiEngine_SelectionManager),helpstring("The Selection Manager used by the engine.")]
				MsiSelectionManager*  SelectionManager();
			[id(DISPID_MsiEngine_DirectoryManager),propget,helpcontext(MsiEngine_DirectoryManager),helpstring("The Directory Manager used by the engine.")]
				MsiDirectoryManager*  DirectoryManager();
			[id(DISPID_MsiEngine_Initialize),helpcontext(MsiEngine_Initialize),helpstring("Initialize engine and properties.")]
				long Initialize([in] BSTR database, [in] long uiLevel, [in] BSTR commandLine);
			[id(DISPID_MsiEngine_Terminate),helpcontext(MsiEngine_Terminate),helpstring("Shut down engine, release references, handler rollback.")]
				long Terminate([in] long state);
			[id(DISPID_MsiEngine_DoAction),helpcontext(MsiEngine_DoAction),helpstring("Execute a named action.")]
				long DoAction([in] BSTR action);
			[id(DISPID_MsiEngine_Sequence),helpcontext(MsiEngine_Sequence),helpstring("Sequence actions from the specified table.")]
				void Sequence([in] BSTR table);
			[id(DISPID_MsiEngine_Message),helpcontext(MsiEngine_Message),helpstring("Defer to MsiHandler object, logging as required.")]
				long Message([in] long kind, [in] MsiRecord* record);
			[id(DISPID_MsiEngine_SelectLanguage), helpcontext(MsiEngine_SelectLanguage),helpstring("Generates a dialog containing buttons for supported languages.")]
				long SelectLanguage([in] BSTR languages, [in] BSTR caption);
			[id(DISPID_MsiEngine_OpenView),helpcontext(MsiEngine_OpenView),helpstring("Defer to current OpenView of MsiDatabase object.")]
				MsiView* OpenView([in] BSTR view, [in] long intent);
			[id(DISPID_MsiEngine_ResolveFolderProperty),helpcontext(MsiEngine_ResolveFolderProperty),helpstring("Force resolution of missing or partial source path.")]
				boolean ResolveFolderProperty([in] BSTR property);
			[id(DISPID_MsiEngine_FormatText), helpcontext(MsiEngine_FormatText),helpstring("Formats a string by resolving property names.")]
				BSTR FormatText([in] BSTR text);
			[id(DISPID_MsiEngine_EvaluateCondition), helpcontext(MsiEngine_EvaluateCondition),helpstring("Evaluates a condition expression.")]
				long EvaluateCondition([in] BSTR condition);
			[id(DISPID_MsiEngine_ExecuteRecord), helpcontext(MsiEngine_ExecuteRecord),helpstring("Executes an operation.")]
				long ExecuteRecord([in] long opCode, [in] MsiRecord* params);
			[id(DISPID_MsiEngine_ValidateProductID), helpcontext(MsiEngine_ValidateProductID),helpstring("Validates the Product ID.")]
				boolean ValidateProductID(boolean force);
			[id(DISPID_MsiEngine_GetMode), helpcontext(MsiEngine_GetMode), helpstring("Returns the engine's mode bits (ief*)")]
				unsigned long GetMode();
			[id(DISPID_MsiEngine_SetMode), helpcontext(MsiEngine_SetMode), helpstring("Sets an engine mode bit (ief*)")]
				void SetMode([in] unsigned long mode, [in] Boolean flag);
	};
*/

DispatchEntry<CAutoEngine> AutoEngineTable[] = {
	DISPID_MsiEngine_Services,              aafPropRO, CAutoEngine::Services,             TEXT("Services"),
	DISPID_MsiEngine_ConfigurationServer,   aafPropRO, CAutoEngine::ConfigurationServer,  TEXT("ConfigurationServer"),
	DISPID_MsiEngine_Handler,               aafPropRO, CAutoEngine::Handler,              TEXT("Handler"),
	DISPID_MsiEngine_Database,              aafPropRO, CAutoEngine::Database,             TEXT("Database"),
	DISPID_MsiEngine_Property,              aafPropRW, CAutoEngine::Property,             TEXT("Property,name"),
	DISPID_MsiEngine_SelectionManager,      aafPropRO, CAutoEngine::SelectionManager,     TEXT("SelectionManager"),
	DISPID_MsiEngine_DirectoryManager,      aafPropRO, CAutoEngine::DirectoryManager,     TEXT("DirectoryManager"),
	DISPID_MsiEngine_Initialize,            aafMethod, CAutoEngine::Initialize,           TEXT("Initialize,database,uiLevel,commandLine"),
	DISPID_MsiEngine_Terminate,             aafMethod, CAutoEngine::Terminate,            TEXT("Terminate,state"),
   DISPID_MsiEngine_DoAction,              aafMethod, CAutoEngine::DoAction,             TEXT("DoAction,action"),
   DISPID_MsiEngine_Sequence,              aafMethod, CAutoEngine::Sequence,             TEXT("Sequence,table"),
   DISPID_MsiEngine_Message,               aafMethod, CAutoEngine::Message,              TEXT("Message,kind,record"),
   DISPID_MsiEngine_SelectLanguage,        aafMethod, CAutoEngine::SelectLanguage,       TEXT("SelectLanguage,languages,caption"),
   DISPID_MsiEngine_OpenView,              aafMethod, CAutoEngine::OpenView,             TEXT("OpenView,view,intent"),
   DISPID_MsiEngine_ResolveFolderProperty, aafMethod, CAutoEngine::ResolveFolderProperty,TEXT("ResolveFolderProperty,property"),
   DISPID_MsiEngine_FormatText,            aafMethod, CAutoEngine::FormatText,           TEXT("FormatText,text"),
   DISPID_MsiEngine_EvaluateCondition,     aafMethod, CAutoEngine::EvaluateCondition,    TEXT("EvaluateCondition,condition"),
   DISPID_MsiEngine_ValidateProductID,     aafMethod, CAutoEngine::ValidateProductID,    TEXT("ValidateProductID,force"),
   DISPID_MsiEngine_ExecuteRecord,         aafMethod, CAutoEngine::ExecuteRecord,        TEXT("ExecuteRecord,opcode,parameters"),
	DISPID_MsiEngine_GetMode,               aafMethod, CAutoEngine::GetMode,              TEXT("GetMode"),
	DISPID_MsiEngine_SetMode,               aafMethod, CAutoEngine::SetMode,              TEXT("SetMode,mode,flag"),
};
const int AutoEngineCount = sizeof(AutoEngineTable)/sizeof(DispatchEntryBase);  

//____________________________________________________________________________
//
// CMsiEngine automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoEngine(IMsiEngine& riEngine)
{
	return new CAutoEngine(riEngine);
}

CAutoEngine::CAutoEngine(IMsiEngine& riEngine)
 : CAutoBase(*AutoEngineTable, AutoEngineCount), m_riEngine(riEngine)
{
	if (g_cServicesUsers == 0)
	{
		s_piServices = riEngine.GetServices(); // services was AddRefed
		g_piStringNull = &s_piServices->GetNullString();
		MsiString::InitializeClass(s_piServices->GetNullString());
	}
	g_cServicesUsers++;
}

CAutoEngine::~CAutoEngine()
{
	m_riEngine.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoEngine::GetInterface()
{
	return m_riEngine;
}

void CAutoEngine::Services(CAutoArgs& args)
{
	args = new CAutoServices(*m_riEngine.GetServices());
}

void CAutoEngine::ConfigurationServer(CAutoArgs& args)
{
    IMsiServer * piServer = m_riEngine.GetConfigurationServer();

    if (!piServer)
        args = (IDispatch*) 0;
    else
        args = new CAutoServer(*piServer);	
}

void CAutoEngine::Handler(CAutoArgs& args)
{
	IMsiHandler* piHandler = m_riEngine.GetHandler();
	if (!piHandler)
		args = (IDispatch*)0;
	else
		args = new CAutoHandler(*piHandler);
}

void CAutoEngine::Database(CAutoArgs& args)
{
	IMsiDatabase* piDatabase = m_riEngine.GetDatabase();
	if (!piDatabase)
		args = (IDispatch*)0;
	else
		args = (IDispatch*)new CAutoDatabase(*piDatabase);
}

void CAutoEngine::Property(CAutoArgs& args)
{
	MsiString istrName(args[1].GetMsiString());
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (var.GetType() == VT_EMPTY)
			m_riEngine.SetProperty(*istrName, *g_piStringNull);
		else if (var.GetType() == VT_BSTR)
			m_riEngine.SetProperty(*istrName, *MsiString(var.GetMsiString()));
		else
			m_riEngine.SetPropertyInt(*istrName, var);
	}
	else
	{
		const IMsiString& riStr = m_riEngine.GetProperty(*istrName);
		if (riStr.TextSize())
			args = riStr;
		else
			riStr.Release();
	}
}

void CAutoEngine::SelectionManager(CAutoArgs& args)
{
	IMsiSelectionManager* piSelectionManager;
	if (m_riEngine.QueryInterface(IID_IMsiSelectionManager, (void**)&piSelectionManager)
			!= NOERROR)
		throw MsiEngine_SelectionManager;
	args = new CAutoSelectionManager(*piSelectionManager);
}

void CAutoEngine::DirectoryManager(CAutoArgs& args)
{
	IMsiDirectoryManager* piDirectoryManager;
	if (m_riEngine.QueryInterface(IID_IMsiDirectoryManager, (void**)&piDirectoryManager)
			!= NOERROR)
		throw MsiEngine_DirectoryManager;
	args = new CAutoDirectoryManager(*piDirectoryManager);
}

void CAutoEngine::Initialize(CAutoArgs& args)
{
	iuiEnum iuiLevel = args.Present(2) ? (iuiEnum)(int)args[2] : iuiBasic;
	const ICHAR* szCommandLine = args.Present(3) ? (const ICHAR*)args[3] : (const ICHAR*)0;
	const ICHAR* szProductCode = args.Present(4) ? (const ICHAR*)args[4] : (const ICHAR*)0;
	args = (int)m_riEngine.Initialize(args[1], iuiLevel, szCommandLine, szProductCode,(iioEnum)0);
}

void CAutoEngine::DoAction(CAutoArgs& args)
{
	args = (int)m_riEngine.DoAction(args[1]);
}

void CAutoEngine::Terminate(CAutoArgs& args)
{
	args = (int)m_riEngine.Terminate((iesEnum)(int)args[1]);
}

void CAutoEngine::Sequence(CAutoArgs& args)
{
	args = (int)m_riEngine.Sequence(args[1]);
}

void CAutoEngine::Message(CAutoArgs& args)
{
	IMsiRecord& riRecord = (IMsiRecord&)args[2].Object(IID_IMsiRecord);
	args = (int)m_riEngine.Message((imtEnum)(int)args[1], riRecord);
}

void CAutoEngine::SelectLanguage(CAutoArgs& args)
{
	const ICHAR* szCaption = args.Present(2) ? (const ICHAR*)args[2] : (const ICHAR*)0;
	args = (int)m_riEngine.SelectLanguage(args[1], szCaption);
}

void CAutoEngine::OpenView(CAutoArgs& args)
{
	IMsiView* piView;
	IMsiRecord* piError = m_riEngine.OpenView(args[1], (ivcEnum)(int)args[2], piView);
   if (piError)
		throw piError;
	args = new CAutoView(*piView);
}

void CAutoEngine::ResolveFolderProperty(CAutoArgs& args)
{
	args = m_riEngine.ResolveFolderProperty(*MsiString(args[1].GetMsiString()));
}

void CAutoEngine::FormatText(CAutoArgs& args)
{
	args = m_riEngine.FormatText(*MsiString(args[1].GetMsiString()));
}

void CAutoEngine::EvaluateCondition(CAutoArgs& args)
{
	args = (int)m_riEngine.EvaluateCondition(args[1]);
}

void CAutoEngine::GetMode(CAutoArgs& args)
{
	args = (int)m_riEngine.GetMode();
}

void CAutoEngine::SetMode(CAutoArgs& args)
{
	m_riEngine.SetMode(args[1], args[2]);
}

void CAutoEngine::ExecuteRecord(CAutoArgs& args)
{
	args = (int)m_riEngine.ExecuteRecord((ixoEnum)(int)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord));
}

void CAutoEngine::ValidateProductID(CAutoArgs& args)
{
	args = m_riEngine.ValidateProductID(((Bool)args[1]) == fTrue);
}


//____________________________________________________________________________
//
// MsiHandler automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C104F-0000-0000-C000-000000000046),  // IID_IMsiAutoHandler
		helpcontext(MsiHandler_Object),helpstring("Message and UI handler object.")
	]
	dispinterface MsiHandler
	{
		properties:
		methods:
			[id(1), helpcontext(MsiHandler_Message),helpstring("Handles error, progress and other messages from the engine.")]
				long Message([in] long kind, [in] MsiRecord* record);
			[id(2), helpcontext(MsiHandler_DoAction),helpstring("Handles actions (starting wizards, custom actions, etc.)")]
				long DoAction([in] BSTR action);
			[id(3), helpcontext(MsiHandler_Break),helpstring("Break out of message loop and allow shut down.")] 
				void Break();

	};
*/

DispatchEntry<CAutoHandler> AutoHandlerTable[] = {
	1, aafMethod, CAutoHandler::Message,        TEXT("Message,kind,record"),
	2, aafMethod, CAutoHandler::DoAction,       TEXT("DoAction,action"),
	3, aafMethod, CAutoHandler::Break,          TEXT("Break"),
};
const int AutoHandlerCount = sizeof(AutoHandlerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiHandler automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoHandler(IMsiHandler& riHandler)
{
	return new CAutoHandler(riHandler);
}

CAutoHandler::CAutoHandler(IMsiHandler& riHandler)
 : CAutoBase(*AutoHandlerTable, AutoHandlerCount), m_riHandler(riHandler)
{
}

CAutoHandler::~CAutoHandler()
{
	m_riHandler.Release();
}

IUnknown& CAutoHandler::GetInterface()
{
	return m_riHandler;
}

void CAutoHandler::Message(CAutoArgs& args)
{
	IMsiRecord& riRecord = (IMsiRecord&)args[2].Object(IID_IMsiRecord);
	args = (int)m_riHandler.Message((imtEnum)(int)args[1], riRecord);
}

void CAutoHandler::DoAction(CAutoArgs& args)
{
	args = (int)m_riHandler.DoAction(args[1]);
}

void CAutoHandler::Break(CAutoArgs& /*args*/)
{
	if(!m_riHandler.Break())
		throw MsiHandler_Break;
}


//____________________________________________________________________________
//
// MsiDialogHandler automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C1053-0000-0000-C000-000000000046),  // IID_IMsiAutoDialogHandler
		helpcontext(MsiDialogHandler_Object),helpstring("Dialog handler object.")
	]
	dispinterface MsiDialogHandler
	{
		properties:
		methods:
			[id(1), helpcontext(MsiDialogHandler_DialogCreate),helpstring("Creates an empty dialog of the specified type.")] 
				MsiDialog* DialogCreate([in] BSTR type);
			[id(2), helpcontext(MsiDialogHandler_Dialog),helpstring("Returns the pointer to the dialog by name.")] 
				MsiDialog* Dialog([in] BSTR name); 
			[id(3), helpcontext(MsiDialogHandler_DialogFromWindow),helpstring("Returns the pointer to the dialog with the given window reference.")] 
				MsiDialog* DialogFromWindow([in] long window); 
			[id(4),helpcontext(MsiDialogHandler_AddDialog),helpstring("Adds a dialog to the list and creates the window using the record.")]
				void AddDialog([in] MsiDialog* dialog, [in] MsiDialog* parent, [in] MsiRecord* record, 
				[in] MsiTable* controleventtable,[in] MsiTable* controlconditiontable, [in] MsiTable* eventmappingtable);
			[id(5),helpcontext(MsiDialogHandler_RemoveDialog),helpstring("Removes a dialog from the list.")]
				void RemoveDialog([in] MsiDialog* dialog);
	};
*/

DispatchEntry<CAutoDialogHandler> AutoDialogHandlerTable[] = {
	1, aafMethod, CAutoDialogHandler::DialogCreate,   TEXT("DialogCreate,type"),
	2, aafPropRO, CAutoDialogHandler::Dialog,         TEXT("Dialog,name"),
	3, aafPropRO, CAutoDialogHandler::DialogFromWindow, TEXT("Dialog,window"),
	4, aafMethod, CAutoDialogHandler::AddDialog,      TEXT("AddDialog,dialog,parent,record,controleventtable,controlconditiontable,eventmappingtable"),
	5, aafMethod, CAutoDialogHandler::RemoveDialog,   TEXT("RemoveDialog,dialog"),
};
const int AutoDialogHandlerCount = sizeof(AutoDialogHandlerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiDialogHandler automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoDialogHandler(IMsiDialogHandler& riHandler)
{
	return new CAutoDialogHandler(riHandler);
}

CAutoDialogHandler::CAutoDialogHandler(IMsiDialogHandler& riHandler)
 : CAutoBase(*AutoDialogHandlerTable, AutoDialogHandlerCount), m_riDialogHandler(riHandler)
{
}

CAutoDialogHandler::~CAutoDialogHandler()
{
	m_riDialogHandler.Release();
}

IUnknown& CAutoDialogHandler::GetInterface()
{
	return m_riDialogHandler;
}


void CAutoDialogHandler::DialogCreate(CAutoArgs& args)
{
	IMsiDialog* piDialog = m_riDialogHandler.DialogCreate(*MsiString(args[1].GetMsiString()));
	if (piDialog)
		args = new CAutoDialog(*piDialog);
	else
		throw MsiDialogHandler_DialogCreate;
}

void CAutoDialogHandler::Dialog(CAutoArgs& args)
{
	IMsiDialog* piDialog = m_riDialogHandler.GetDialog(*MsiString(args[1].GetMsiString()));
	if (piDialog)
		args = new CAutoDialog(*piDialog);
	else
		throw MsiDialogHandler_Dialog;
}

void CAutoDialogHandler::DialogFromWindow(CAutoArgs& args)
{
	IMsiDialog* piDialog = m_riDialogHandler.GetDialogFromWindow((LONG_PTR) args[1]);
	if (piDialog)
		args = new CAutoDialog(*piDialog);
	else
		throw MsiDialogHandler_DialogFromWindow;
}


void CAutoDialogHandler::AddDialog(CAutoArgs& args)
{
	IMsiDialog& riDialog = (IMsiDialog&)args[1].Object(IID_IMsiDialog);
	IMsiDialog* piParent = (IMsiDialog*)args[2].ObjectPtr(IID_IMsiDialog);
	IMsiRecord& riRecord = (IMsiRecord&)args[3].Object(IID_IMsiRecord);
	IMsiTable* riControlEventTable = (IMsiTable*)args[4].ObjectPtr(IID_IMsiTable);
	IMsiTable* riControlCondTable = (IMsiTable*)args[5].ObjectPtr(IID_IMsiTable);
	IMsiTable* riEventMapTable = (IMsiTable*)args[6].ObjectPtr(IID_IMsiTable);
	if (!m_riDialogHandler.AddDialog(riDialog, piParent, riRecord,riControlEventTable,riControlCondTable,riEventMapTable))
		throw MsiDialogHandler_AddDialog;
}

void CAutoDialogHandler::RemoveDialog(CAutoArgs& args)
{
	IMsiDialog*  piDialog = (IMsiDialog*)args[1].ObjectPtr(IID_IMsiDialog);
	if (!m_riDialogHandler.RemoveDialog(piDialog))
		throw MsiDialogHandler_RemoveDialog;
}

//____________________________________________________________________________
//
// MsiDialog automation definitions
//____________________________________________________________________________
/*O

	[	
		uuid(000C1050-0000-0000-C000-000000000046),  // IID_IMsiAutoDialog
		helpcontext(MsiDialog_Object),helpstring("Dialog object, interface towards the handler.")
	]
	dispinterface MsiDialog
	{
		properties:
		methods:
			[id(1), helpcontext(MsiDialog_Visible),helpstring("Turns the dialog window visible.")]
				void Visible([in] boolean show);
			[id(2), helpcontext(MsiDialog_ControlCreate),helpstring("Creates an empty control.")]
				MsiControl* ControlCreate([in] BSTR type);
			[id(3), helpcontext(MsiDialog_Attribute),helpstring("Sets/gets dialog attribute values.")]
				void Attribute([in] boolean	set, [in] BSTR attributename, MsiRecord* record);
			[id(4), helpcontext(MsiDialog_Control),helpstring("Return the pointer to the control by name.")]
				MsiControl* Control([in] BSTR name);
			[id(5), helpcontext(MsiDialog_AddControl),helpstring("Adds a control to the dialog.")]
				void AddControl([in] MsiControl* control, [in] MsiRecord* record);
			[id(6), helpcontext(MsiDialog_Execute),helpstring("Runs a modal dialog.")]
				void Execute();
			[id(7), helpcontext(MsiDialog_Reset), helpstring("Resets the dialog and restores the origianal values.")]
				void Reset();
			[id(8), helpcontext(MsiDialog_EventAction),helpstring("Performs the action on every subscriber of the event.")]
				void EventAction([in] BSTR eventname, [in] BSTR action);
			[id(9), helpcontext(MsiDialog_RemoveControl),helpstring("Removes a control from the dialog.")]
				void RemoveControl([in] MsiControl* control);
			[id(10), helpcontext(MsiDialog_StringValue), helpstring("String value of the dialog")]
				BSTR StringValue();
			[id(11), propget, helpcontext(MsiDialog_IntegerValue), helpstring("Integer value for dialog")]
				long IntegerValue();
			[id(12), helpcontext(MsiDialog_Handler),helpstring("Returns the DialogHandler used by the dialog.")]
				MsiDialogHandler* Handler();
			[id(13), helpcontext(MsiDialog_PropertyChanged),helpstring("Performs the actions in the ControlCondition table.")]
				void PropertyChanged([in] BSTR property, [in] BSTR control);
			[id(14), helpcontext(MsiDialog_FinishCreate),helpstring("Signals that all the controls are added to the dialog.")]
				void FinishCreate();
			[id(15), helpcontext(MsiDialog_HandleEvent),helpstring("Triggers a control event.")]
				void HandleEvent([in] BSTR eventname, [in] BSTR argument);
	};
*/

DispatchEntry<CAutoDialog> AutoDialogTable[] = {
	1, aafPropWO, CAutoDialog::Visible,        TEXT("Visible,show"),
	2, aafMethod, CAutoDialog::ControlCreate,  TEXT("ControlCreate,type"),
	3, aafMethod, CAutoDialog::Attribute,      TEXT("Attribute,set,attributename,record"),
	4, aafPropRO, CAutoDialog::Control,        TEXT("Control,name"),
	5, aafMethod, CAutoDialog::AddControl,     TEXT("AddControl,control,record"),
	6, aafMethod, CAutoDialog::Execute,        TEXT("Execute"),
	7, aafMethod, CAutoDialog::Reset,          TEXT("Reset"),
	8 ,aafMethod, CAutoDialog::EventAction,    TEXT("EventAction,eventname,action"),
	9, aafMethod, CAutoDialog::RemoveControl,  TEXT("RemoveControl,control"),
	10,aafPropRO, CAutoDialog::StringValue,    TEXT("StringValue"),
	11,aafPropRO, CAutoDialog::IntegerValue,   TEXT("IntegerValue"),
	12,aafPropRO, CAutoDialog::Handler,        TEXT("Handler"),
	13,aafMethod, CAutoDialog::PropertyChanged,TEXT("PropertyChanged,property,control"),
	14,aafMethod, CAutoDialog::FinishCreate,   TEXT("FinishCreate"),
	15,aafMethod, CAutoDialog::HandleEvent,    TEXT("HandleEvent, eventname, argument"),
};
const int AutoDialogCount = sizeof(AutoDialogTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiDialog automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoDialog(IMsiDialog& riDialog)
{
	return new CAutoDialog(riDialog);
}

CAutoDialog::CAutoDialog(IMsiDialog& riDialog)
 : CAutoBase(*AutoDialogTable, AutoDialogCount), m_riDialog(riDialog)
{
}

CAutoDialog::~CAutoDialog()
{
	m_riDialog.Release();
}

IUnknown& CAutoDialog::GetInterface()
{
	return m_riDialog;
}

void CAutoDialog::Visible(CAutoArgs& args)
{
	if(args.PropertySet())
	{
		IMsiRecord* piError = m_riDialog.WindowShow((Bool)(int)args[1]);
		if (piError)
			throw piError;
	}
}

void CAutoDialog::ControlCreate(CAutoArgs& args)
{
	IMsiControl* piControl = m_riDialog.ControlCreate(*MsiString(args[1].GetMsiString()));
	if (piControl)
		args = new CAutoControl(*piControl);
	else
		throw MsiDialog_ControlCreate;
}

void CAutoDialog::Attribute(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.Attribute((Bool) (int)args[1], *MsiString(args[2].GetMsiString()),(IMsiRecord &) args[3].Object(IID_IMsiRecord));
	if (piError)
		throw piError;
}

void CAutoDialog::Control(CAutoArgs& args)
{
	IMsiControl* piControl;	
	IMsiRecord* piError =  m_riDialog.GetControl(*MsiString(args[1].GetMsiString()), piControl);
	if (piError)
		throw piError;
	args = new CAutoControl(*piControl);
}

void CAutoDialog::AddControl(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.AddControl((IMsiControl*)args[1].ObjectPtr(IID_IMsiControl), (IMsiRecord&)args[2].Object(IID_IMsiRecord));
	if(piError)
		throw piError;
}

void CAutoDialog::FinishCreate(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDialog.FinishCreate();
	if(piError)
		throw piError;
}

void CAutoDialog::RemoveControl(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.RemoveControl((IMsiControl*)args[1].ObjectPtr(IID_IMsiControl));
	if(piError)
		throw piError;
}

void CAutoDialog::Handler(CAutoArgs& args)
{
	IMsiDialogHandler& riHandler=m_riDialog.GetHandler();
	args = new CAutoDialogHandler(riHandler);
}

void CAutoDialog::Execute(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDialog.WindowShow(fTrue);
	if(piError)
		throw piError;
	piError = m_riDialog.Execute();
	if(piError)
		throw piError;
}

void CAutoDialog::Reset(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDialog.Reset();
	if(piError)
		throw piError;
}

void CAutoDialog::EventAction(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.EventActionSz((const ICHAR *)args[1], *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoDialog::StringValue(CAutoArgs& args)
{
	args = m_riDialog.GetMsiStringValue();
}

void CAutoDialog::IntegerValue(CAutoArgs& args)
{
	args = m_riDialog.GetIntegerValue();
}

void CAutoDialog::PropertyChanged(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.PropertyChanged(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoDialog::HandleEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.HandleEvent(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}


		 

//____________________________________________________________________________
//
// MsiEvent automation definitions
//____________________________________________________________________________
/*O

	[	
		uuid(000C1051-0000-0000-C000-000000000046),  // IID_IMsiAutoEvent
		helpcontext(MsiEvent_Object),helpstring("Event object, the dialog's interface towards the controls.")
	]
	dispinterface MsiEvent
	{
		properties:
		methods:
			[id(1), helpcontext(MsiEvent_PropertyChanged),helpstring("Performs the actions in the ControlCondition table.")]
				void PropertyChanged([in] BSTR property, [in] BSTR control);
			[id(2), helpcontext(MsiEvent_ControlActivated),helpstring("Performs the events in the ControlEvents table.")]
				void ControlActivated([in] BSTR control);
			[id(3), helpcontext(MsiEvent_RegisterControlEvent),helpstring("Registers the publisher of an event.")]
				void RegisterControlEvent([in] BSTR control, [in] boolean toregister, [in] BSTR event);
			[id(4), helpcontext(MsiEvent_Handler),helpstring("Returns the DialogHandler used by the dialog.")]
				MsiDialogHandler* Handler();
			[id(5), helpcontext(MsiEvent_PublishEvent),helpstring("The publisher of an event sends notification to the subscribers.")]
				void PublishEvent([in] BSTR eventname, [in] MsiRecord* argument);
			[id(6), helpcontext(MsiEvent_Control),helpstring("Return the pointer to the control by name.")]
				MsiControl* Control([in] BSTR name);
			[id(7), helpcontext(MsiEvent_Attribute), helpstring("Sets/gets the dialog attribute.")]
				void Attribute([in] boolean set, [in] BSTR attributename, MsiRecord* record);
			[id(8), helpcontext(MsiEvent_EventAction),helpstring("Performs the action on every subscriber of the event.")]
				void EventAction([in] BSTR eventname, [in] BSTR action);
			[id(9), helpcontext(MsiEvent_SetFocus),helpstring("Sets the focus to a control.")]
				void SetFocus([in] BSTR control);
			[id(10), helpcontext(MsiEvent_StringValue), helpstring("String value of the event")]
				BSTR StringValue();
			[id(11), propget, helpcontext(MsiEvent_IntegerValue), helpstring("Integer value for event")]
				long IntegerValue();
			[id(12), helpcontext(MsiEvent_HandleEvent), helpstring("Triggers a control event")]
				void HandleEvent([in] BSTR eventname, [in] BSTR argument);
			[id(13),helpcontext(MsiEvent_Engine),helpstring("The MsiEngine object used by the event.")]
				MsiEngine* Engine();
			[id(14),helpcontext(MsiEvent_Escape),helpstring("Handles hitting the Escape key.")]
				void Escape();
	};
*/

DispatchEntry<CAutoEvent> AutoEventTable[] = {
	1, aafMethod, CAutoEvent::PropertyChanged,      TEXT("PropertyChanged,property,control"),
	2, aafMethod, CAutoEvent::ControlActivated,     TEXT("ControlActivated,control"),
	3, aafMethod, CAutoEvent::RegisterControlEvent, TEXT("RegisterControlEvent,control,toregister,event"),
	4, aafPropRO, CAutoEvent::Handler,              TEXT("Handler"),
	5, aafMethod, CAutoEvent::PublishEvent,         TEXT("PublishEvent,eventname,argument"),
	6, aafPropRO, CAutoEvent::Control,              TEXT("Control,name"),
	7, aafMethod, CAutoEvent::Attribute,            TEXT("Attribute,set,attributename,record"),
	8, aafMethod, CAutoEvent::EventAction,          TEXT("EventAction,eventname,action"),
	9, aafMethod, CAutoEvent::SetFocus,             TEXT("SetFocus, control"),
	10,aafPropRO, CAutoEvent::StringValue,          TEXT("StringValue"),
	11,aafPropRO, CAutoEvent::IntegerValue,         TEXT("IntegerValue"),
	12,aafMethod, CAutoEvent::HandleEvent,          TEXT("HandleEvent, eventname, argument"),
	13,aafPropRO, CAutoEvent::Engine,               TEXT("Engine"),

};
const int AutoEventCount = sizeof(AutoEventTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiEvent automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoEvent(IMsiEvent& riEvent)
{
	return new CAutoEvent(riEvent);
}

CAutoEvent::CAutoEvent(IMsiEvent& riEvent)
 : CAutoBase(*AutoEventTable, AutoEventCount), m_riEvent(riEvent)
{
}

CAutoEvent::~CAutoEvent()
{
	m_riEvent.Release();
}

IUnknown& CAutoEvent::GetInterface()
{
	return m_riEvent;
}

void CAutoEvent::PropertyChanged(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.PropertyChanged(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoEvent::ControlActivated(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.ControlActivated(*MsiString(args[1].GetMsiString()));
	if (piError)
		throw piError;
}

void CAutoEvent::RegisterControlEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.RegisterControlEvent(*MsiString(args[1].GetMsiString()),(Bool)(int)args[2],(const ICHAR *)args[3]);
	if (piError)
		throw piError;
}

void CAutoEvent::Escape(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riEvent.Escape();
	if (piError)
		throw piError;
}

void CAutoEvent::Handler(CAutoArgs& args)
{
	IMsiDialogHandler& riHandler=m_riEvent.GetHandler();
	args = new CAutoDialogHandler(riHandler);
}

void CAutoEvent::PublishEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.PublishEventSz(args[1],(IMsiRecord&)args[2].Object(IID_IMsiRecord));
	if(piError)
		throw piError;
}

void CAutoEvent::Control(CAutoArgs& args)
{
	IMsiControl* piControl;
	IMsiRecord* piError =  m_riEvent.GetControl(*MsiString(args[1].GetMsiString()), piControl);
	if (piError)
		throw piError;
	args = new CAutoControl(*piControl);
}

void CAutoEvent::Attribute(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.Attribute((Bool)(int) args[1], *MsiString(args[2].GetMsiString()),(IMsiRecord &) args[3].Object(IID_IMsiRecord));
	if (piError)
		throw piError;
}

void CAutoEvent::EventAction(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.EventActionSz((const ICHAR *)args[1], *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}	

void CAutoEvent::SetFocus(CAutoArgs& args)
{
	IMsiRecord* piError =  m_riEvent.SetFocus(*MsiString(args[1].GetMsiString()));
	if (piError)
		throw piError;
}

void CAutoEvent::StringValue(CAutoArgs& args)
{
	args = ((IMsiDialog&)m_riEvent).GetMsiStringValue();
}

void CAutoEvent::IntegerValue(CAutoArgs& args)
{
	args = ((IMsiDialog&)m_riEvent).GetIntegerValue();
}

void CAutoEvent::HandleEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.HandleEvent(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoEvent::Engine(CAutoArgs& args)
{
	IMsiEngine& riEngine=m_riEvent.GetEngine();
	args = new CAutoEngine(riEngine);
}




//____________________________________________________________________________
//
// MsiControl automation definitions
//____________________________________________________________________________
/*O

	[	
		uuid(000C1052-0000-0000-C000-000000000046),  // IID_IMsiAutoControl
		helpcontext(MsiControl_Object),helpstring("General interface of the controls.")
	]
	dispinterface MsiControl
	{
		properties:
		methods:
			[id(1), helpcontext(MsiControl_Attribute), helpstring("Sets/gets the control attribute.")]
				void Attribute([in] boolean set, [in] BSTR attributename, MsiRecord* record);
			[id(2), helpcontext(MsiControl_CanTakeFocus),helpstring("Returns a flag wheather the control can take focus.")]
				boolean CanTakeFocus();
			[id(3), helpcontext(MsiControl_HandleEvent),helpstring("Notification to the publisher of an event.")]
				void HandleEvent([in]BSTR eventname, [in] BSTR argument);
			[id(4), helpcontext(MsiControl_Undo),helpstring("Restore the original value of the property.")]
				void Undo();
			[id(5), helpcontext(MsiControl_SetPropertyInDatabase),helpstring("Store the control's property value in the database.")] 
				void SetPropertyInDatabase();
			[id(6), helpcontext(MsiControl_GetPropertyFromDatabase),helpstring("Fetches the property value from the database.")]
				void GetPropertyFromDatabase();
			[id(7), helpcontext(MsiControl_SetFocus),helpstring("Sets the focus on the control.")]
				void SetFocus();
			[id(8), helpcontext(MsiControl_Dialog),helpstring("Returns a pointer to the Event interface.")]
				MsiEvent* Dialog();
			[id(9), helpcontext(MsiControl_WindowMessage),helpstring("Handles the window message.")]
				boolean WindowMessage([in] long message, [in] long wParam, [in] long lParam);
			[id(10), helpcontext(MsiControl_StringValue), helpstring("String value of the control")]
				BSTR StringValue();
			[id(11), propget, helpcontext(MsiControl_IntegerValue), helpstring("Integer value for control")]
				long IntegerValue();
			[id(12), helpcontext(MsiControl_GetIndirectPropertyFromDatabase),helpstring("Fetches the indirect property value from the database.")]
				void GetIndirectPropertyFromDatabase();
	};
*/

DispatchEntry<CAutoControl> AutoControlTable[] = {
	1, aafMethod, CAutoControl::Attribute,     TEXT("Attribute,set,attributename,record"),
	2, aafPropRO, CAutoControl::CanTakeFocus,  TEXT("CanTakeFocus"),
	3, aafMethod, CAutoControl::HandleEvent,   TEXT("HandleEvent,eventname,argument"),
	4, aafMethod, CAutoControl::Undo,          TEXT("Undo"),
	5, aafMethod, CAutoControl::SetPropertyInDatabase,TEXT("SetPropertyInDatabase"),
	6, aafMethod, CAutoControl::GetPropertyFromDatabase,TEXT("GetPropertyFromDatabase"),
	7, aafMethod, CAutoControl::SetFocus,      TEXT("SetFocus"),
	8, aafPropRO, CAutoControl::Dialog,        TEXT("Dialog"),
	9, aafMethod, CAutoControl::WindowMessage, TEXT("WindowMessage,message,wParam,lParam"),
	10,aafPropRO, CAutoControl::StringValue,   TEXT("StringValue"),
	11,aafPropRO, CAutoControl::IntegerValue,  TEXT("IntegerValue"),
	12,aafMethod, CAutoControl::GetIndirectPropertyFromDatabase,TEXT("GetIndirectPropertyFromDatabase"),
};
const int AutoControlCount = sizeof(AutoControlTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiControl automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoControl(IMsiControl& riControl)
{
	return new CAutoControl(riControl);
}

CAutoControl::CAutoControl(IMsiControl& riControl)
 : CAutoBase(*AutoControlTable, AutoControlCount), m_riControl(riControl)
{
}

CAutoControl::~CAutoControl()
{
	m_riControl.Release();
}

IUnknown& CAutoControl::GetInterface()
{
	return m_riControl;
}

void CAutoControl::Attribute(CAutoArgs& args)
{
	IMsiRecord* piError = m_riControl.Attribute((Bool)(int) args[1], *MsiString(args[2].GetMsiString()),(IMsiRecord &) args[3].Object(IID_IMsiRecord));
	if (piError)
		throw piError;
}

void CAutoControl::CanTakeFocus(CAutoArgs& args)
{
	args = m_riControl.CanTakeFocus();
}

void CAutoControl::HandleEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riControl.HandleEvent(*MsiString(args[1].GetMsiString()),*MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoControl::Undo(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.Undo();
	if(piError)
		throw piError;
}

void CAutoControl::SetPropertyInDatabase(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.SetPropertyInDatabase();
	if(piError)
		throw piError;
}

void CAutoControl::GetPropertyFromDatabase(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.GetPropertyFromDatabase();
	if(piError)
		throw piError;
}

void CAutoControl::GetIndirectPropertyFromDatabase(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.GetIndirectPropertyFromDatabase();
	if(piError)
		throw piError;
}

void CAutoControl::SetFocus(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.SetFocus();
	if(piError)
		throw piError;
}

void CAutoControl::Dialog(CAutoArgs& args)
{
	IMsiEvent& riEvent = m_riControl.GetDialog();
	args = new CAutoEvent(riEvent);
}

void CAutoControl::WindowMessage(CAutoArgs& args)
{
	IMsiRecord* piError = m_riControl.WindowMessage((int) args[1], (long) args[2], (long) args[3]);
	if(piError)
		throw piError;
}

void CAutoControl::StringValue(CAutoArgs& args)
{
	args = m_riControl.GetMsiStringValue();
}

void CAutoControl::IntegerValue(CAutoArgs& args)
{
	args = m_riControl.GetIntegerValue();
}


//____________________________________________________________________________
//
// MsiVolume automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1044-0000-0000-C000-000000000046),  // IID_IMsiAutoVolume
		helpcontext(MsiVolume_Object),helpstring("Volume object.")
	]
	dispinterface MsiVolume
	{
		properties:
		methods:
			[id(0), propget,helpcontext(MsiVolume_Path), helpstring("Returns a string representing the path to the volume.")] long Path();
			[id(1), propget,helpcontext(MsiVolume_VolumeID), helpstring("Returns an integer representing the volume ID.")] long VolumeID();
			[id(2), propget,helpcontext(MsiVolume_DriveType), helpstring("Returns an enum value representing the volume's type.")] long DriveType();
			[id(3), propget,helpcontext(MsiVolume_SupportsLFN), helpstring("Returns a boolean indicating whether the volume supports long file names.")] boolean SupportsLFN();
			[id(4), propget,helpcontext(MsiVolume_FreeSpace), helpstring("Returns the amount of free space on the volume, in units of 512 bytes.")] long FreeSpace();
			[id(5), propget,helpcontext(MsiVolume_ClusterSize), helpstring("Returns the assigned size of each disk cluster on the volume.")] long ClusterSize();
			[id(6), propget,helpcontext(MsiVolume_FileSystem), helpstring("Returns a string representing the name of the volume's file system.")] BSTR FileSystem();
			[id(7), propget,helpcontext(MsiVolume_UNCServer), helpstring("Returns a string representing the UNC server name.")] BSTR UNCServer();
			[id(8), propget,helpcontext(MsiVolume_SerialNum), helpstring("Returns an integer representing volume's serial number.")] long SerialNum();
			[id(9), propget,helpcontext(MsiVolume_DiskNotInDrive), helpstring("Returns TRUE if the volume supports removable media, but no disk is in the drive.")] boolean DiskNotInDrive();
			[id(10), propget,helpcontext(MsiVolume_VolumeLabel), helpstring("Returns a string representing the volume's label.")] BSTR VolumeLabel();
			[id(11), propget,helpcontext(MsiVolume_TotalSpace), helpstring("Returns the total amount of space on the volume, in units of 512 bytes.")] long TotalSpace();
	};
*/

DispatchEntry<CAutoVolume> AutoVolumeTable[] = {
	0, aafPropRO, CAutoVolume::Path,           TEXT("Path"),
	1, aafPropRO, CAutoVolume::VolumeID,       TEXT("VolumeID"),
	2, aafPropRO, CAutoVolume::DriveType,      TEXT("DriveType"),
	3, aafPropRO, CAutoVolume::SupportsLFN,    TEXT("SupportsLFN"),
	4, aafPropRO, CAutoVolume::FreeSpace,      TEXT("FreeSpace"),
	5, aafPropRO, CAutoVolume::ClusterSize,    TEXT("ClusterSize"),
	6, aafPropRO, CAutoVolume::FileSystem,     TEXT("FileSystem"),
	7, aafPropRO, CAutoVolume::UNCServer,      TEXT("UNCServer"),
	8, aafPropRO, CAutoVolume::SerialNum,      TEXT("SerialNum"),
	9, aafPropRO, CAutoVolume::DiskNotInDrive, TEXT("DiskNotInDrive"),
	10, aafPropRO, CAutoVolume::VolumeLabel,   TEXT("VolumeLabel"),
	11, aafPropRO, CAutoVolume::TotalSpace,    TEXT("TotalSpace"),
	12, aafPropRO, CAutoVolume::FileSystemFlags, TEXT("FileSystemFlags"),
};
const int AutoVolumeCount = sizeof(AutoVolumeTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiVolume automation implementation
//____________________________________________________________________________

CAutoVolume::CAutoVolume(IMsiVolume& riVolume)
 : CAutoBase(*AutoVolumeTable, AutoVolumeCount), m_riVolume(riVolume)
{
}

CAutoVolume::~CAutoVolume()
{
	m_riVolume.Release();
}

IUnknown& CAutoVolume::GetInterface()
{
	return m_riVolume;
}

void CAutoVolume::DriveType(CAutoArgs& args)
{
	args = (long) m_riVolume.DriveType();
}

void CAutoVolume::Path(CAutoArgs& args)
{
	args = m_riVolume.GetPath();
}

void CAutoVolume::SupportsLFN(CAutoArgs& args)
{
	args = (Bool)m_riVolume.SupportsLFN();
}

void CAutoVolume::FreeSpace(CAutoArgs& args)
{
	args = (long)m_riVolume.FreeSpace();
}

void CAutoVolume::TotalSpace(CAutoArgs& args)
{
	args = (long)m_riVolume.TotalSpace();
}

void CAutoVolume::ClusterSize(CAutoArgs& args)
{
	args = (int)m_riVolume.ClusterSize();
}

void CAutoVolume::VolumeID(CAutoArgs& args)
{
	args = m_riVolume.VolumeID();
}

void CAutoVolume::FileSystem(CAutoArgs& args)
{
	args = m_riVolume.FileSystem();
}

void CAutoVolume::FileSystemFlags(CAutoArgs& args)
{
	args = (int) m_riVolume.FileSystemFlags();
}

void CAutoVolume::VolumeLabel(CAutoArgs& args)
{
	args = m_riVolume.VolumeLabel();
}

void CAutoVolume::UNCServer(CAutoArgs& args)
{
	args = m_riVolume.UNCServer();
}

void CAutoVolume::DiskNotInDrive(CAutoArgs& args)
{
	args = m_riVolume.DiskNotInDrive();
}

void CAutoVolume::SerialNum(CAutoArgs& args)
{
	args = m_riVolume.SerialNum();
}

//____________________________________________________________________________
//
// MsiMessage automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105D-0000-0000-C000-000000000046),  // IID_IMsiAutoMessage
		helpcontext(MsiMessage_Object),helpstring("Message object.")
	]
	dispinterface MsiMessage
	{
		properties:
		methods:
			[id(1), helpcontext(MsiMessage_Message), helpstring("???")] long Message(long imt, MsiRecord* record);
	};
*/

DispatchEntry<CAutoMessage> AutoMessageTable[] = {
	1, aafMethod, CAutoMessage::Message,       TEXT("Message,imt,record"),
};
const int AutoMessageCount = sizeof(AutoMessageTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiMessage automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoMessage(IMsiMessage& riMessage)
{
	return new CAutoMessage(riMessage);
}

CAutoMessage::CAutoMessage(IMsiMessage& riMessage)
 : CAutoBase(*AutoMessageTable, AutoMessageCount), m_riMessage(riMessage)
{
}

CAutoMessage::~CAutoMessage()
{
	m_riMessage.Release();
}

IUnknown& CAutoMessage::GetInterface()
{
	return m_riMessage;
}

void CAutoMessage::Message(CAutoArgs& args)
{
	args = (long)m_riMessage.Message((imtEnum)(long)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord));
}


//____________________________________________________________________________
//
// CAutoEnum<IEnumMsiVolume>, CEnumVARIANT<IEnumMsiVolume> implementation
//____________________________________________________________________________

DispatchEntry< CAutoEnum<IEnumMsiVolume> > AutoEnumMsiVolumeTable[] = {
	DISPID_NEWENUM, aafMethod, CAutoEnum<IEnumMsiVolume>::_NewEnum, TEXT("_NewEnum"),
};
const int AutoEnumMsiVolumeCount = sizeof(AutoEnumMsiVolumeTable)/sizeof(DispatchEntryBase);

void CAutoArgs::operator =(IEnumMsiVolume& riEnum)
{
	operator =(new CAutoEnum<IEnumMsiVolume>(riEnum, *AutoEnumMsiVolumeTable, AutoEnumMsiVolumeCount));
}

HRESULT CEnumVARIANT<IEnumMsiVolume>::Next(unsigned long cItem, VARIANT* rgvarRet,
													unsigned long* pcItemRet)
{
	HRESULT hrStat;
	IMsiVolume* piVol;
	unsigned long cRet;
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	CVariant* pivar = GetCVariantPtr(rgvarRet);
	while (cItem--)
	{
		hrStat = m_riEnum.Next(1, &piVol, &cRet);
		if (cRet == 0)
			return S_FALSE;
		//!! is it necessary to call VariantInit? Why?
		*pivar = new CAutoVolume(*piVol);  // refcnt transferred to variant
		pivar++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CAutoEnum<IEnumMsiRecord>, CEnumVARIANT<IEnumMsiRecord> implementation
//____________________________________________________________________________

DispatchEntry< CAutoEnum<IEnumMsiRecord> > AutoEnumMsiRecordTable[] = {
	DISPID_NEWENUM, aafMethod, CAutoEnum<IEnumMsiRecord>::_NewEnum, TEXT("_NewEnum"),
};
const int AutoEnumMsiRecordCount = sizeof(AutoEnumMsiRecordTable)/sizeof(DispatchEntryBase);

void CAutoArgs::operator =(IEnumMsiRecord& riEnum)
{
	operator =(new CAutoEnum<IEnumMsiRecord>(riEnum, *AutoEnumMsiRecordTable, AutoEnumMsiRecordCount));
}

HRESULT CEnumVARIANT<IEnumMsiRecord>::Next(unsigned long cItem, VARIANT* rgvarRet,
													unsigned long* pcItemRet)
{
	HRESULT hrStat;
	IMsiRecord* piRec;
	unsigned long cRet;
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	CVariant* pivar = GetCVariantPtr(rgvarRet);
	while (cItem--)
	{
		hrStat = m_riEnum.Next(1, &piRec, &cRet);
		if (cRet == 0)
			return S_FALSE;
		//!! is it necessary to call VariantInit? Why?
		*pivar = new CAutoRecord(*piRec);  // refcnt transferred to variant
		pivar++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

//____________________________________________________________________________
//
// MsiPath automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C1045-0000-0000-C000-000000000046),  // IID_IMsiAutoPath
		helpcontext(MsiPath_Object),helpstring("Path object.")
	]
	dispinterface MsiPath
	{
		properties:
		methods:
			[id(0), propget,helpcontext(MsiPath_Path), helpstring("Returns a string representing the full path.")] BSTR Path();
			[id(1), propget,helpcontext(MsiPath_Volume), helpstring("Returns the MsiVolume object representing the root of this path.")] MsiVolume *Volume();
			[id(2),helpcontext(MsiPath_AppendPiece), helpstring("Appends the given string to the existing path.")] void AppendPiece([in] BSTR subDir);
			[id(3),helpcontext(MsiPath_ChopPiece), helpstring("Removes the last path segment of the path.")] void ChopPiece();
			[id(4),helpcontext(MsiPath_FileExists), helpstring("Returns a boolean indicating whether a file of the specified name exists in the directory associated with the path object.")] boolean FileExists([in] BSTR file);
			[id(5),helpcontext(MsiPath_GetFullFilePath), helpstring("Returns a string representing the full path of the specified file.")] BSTR GetFullFilePath([in] BSTR file);
			[id(7),helpcontext(MsiPath_GetFileAttribute), helpstring("Returns the boolean state of a specified file attribute.")] boolean GetFileAttribute([in] BSTR file, [in] long attribute);
			[id(8),helpcontext(MsiPath_SetFileAttribute), helpstring("Sets the boolean state of a specified file attribute.")] void SetFileAttribute([in] BSTR file, [in] long attribute, 
													[in] long state);
			[id(9), propget,helpcontext(MsiPath_Exists), helpstring("Returns a boolean indicating whether the directory tree associated with the path object currently exists on the associated volume.")] boolean Exists();
			[id(10),helpcontext(MsiPath_FileSize), helpstring("Retrieves the size, in bytes, of the specified file.")] long FileSize([in] BSTR file);
			[id(11),helpcontext(MsiPath_FileDate), helpstring("Retrieves the date and time that the specified file was created (Mac) or last written to (Windows).")] date FileDate([in] BSTR file);
			[id(12),helpcontext(MsiPath_RemoveFile), helpstring("Deletes a file existing in the directory associated with the MsiPath object..")] void RemoveFile([in] BSTR file);
			[id(13),helpcontext(MsiPath_EnsureExists), helpstring("Creates the directory tree associated with the path object.")] int EnsureExists();
			[id(14),helpcontext(MsiPath_Remove), helpstring("Attempts to delete the empty directory associated with the path object.")] void Remove();
			[id(15), propget,helpcontext(MsiPath_Writable), helpstring("Returns a boolean indicating whether the directory represented by the path is writable.")] boolean Writable();
			[id(16),helpcontext(MsiPath_FileWritable), helpstring("Returns a boolean indicating whether the specified file exists, AND that file can be opened for write-access.")] boolean FileWritable([in] BSTR file);
			[id(17),helpcontext(MsiPath_FileInUse), helpstring("Returns a boolean indicating whether the speciified file is in use by another process.")] boolean FileInUse([in] BSTR file);
			[id(19),helpcontext(MsiPath_ClusteredFileSize), helpstring("Rounds a file size to a multiple of the volume cluster size.")] long ClusteredFileSize([in] long size);
			[id(20),helpcontext(MsiPath_GetFileVersionString), helpstring("Returns a string representation of a file's version.")] BSTR GetFileVersionString([in] BSTR file);
			[id(21),helpcontext(MsiPath_CheckFileVersion), helpstring("Checks a file against supplied version and language strings.")] long CheckFileVersion([in] BSTR file, [in] BSTR version, [in] BSTR language, [in] MsiRecord* hash);
			[id(22),helpcontext(MsiPath_GetLangIDStringFromFile), helpstring("Returns a string containing a file's language identifiers as decimal numbers.")] BSTR GetLangIDStringFromFile([in] BSTR file);
			[id(23),helpcontext(MsiPath_CheckLanguageIDs), helpstring("Checks a file against a set of language IDs.")] long CheckLanguageIDs([in] BSTR file, [in] BSTR ids);
			[id(24),helpcontext(MsiPath_Compare), helpstring("Compares the object's path against another path object's path, to determine whether a parent/child relationship exists.")] long Compare([in] MsiPath* path);
			[id(25),helpcontext(MsiPath_Child), helpstring("Extracts the 'child' portion of the object's path, relative to the given 'parent' path object.")] BSTR Child([in] MsiPath* path);
			[id(26),helpcontext(MsiPath_TempFileName), helpstring("Creates a temporary file in this object's directory.")] BSTR TempFileName([in] BSTR prefix, [in] BSTR extension, [in] boolean fileNameOnly);
			[id(27),helpcontext(MsiPath_FindFile), helpstring("Searches for a file by the supplied filter in the directory.")] boolean FindFile(MsiRecord* record, [in] long depth);
			[id(28),helpcontext(MsiPath_SubFolders), helpstring("Enumerate the subdirectories in the directory.")] IEnumVARIANT* SubFolders(Boolean excludeHidden);
			[id(29),propget,helpcontext(MsiPath_EndSubPath), helpstring("Returns the last sub-path in the current path.")] BSTR EndSubPath();
			[id(31),helpcontext(MsiPath_GetImportModulesEnum), helpstring("Enumerate the import modules for a given module.")] IEnumVARIANT* GetImportModulesEnum(BSTR filename);
			[id(32),helpcontext(MsiPath_SetVolume), helpstring("Changes the MsiVolume object associated with the MsiPath object.")] void SetVolume([in] MsiVolume* volume);
			[id(33),helpcontext(MsiPath_ComputeFileChecksum), helpstring("Computes and returns the checksum of the specified file.")] void ComputeFileChecksum([in] BSTR filename);
			[id(34),helpcontext(MsiPath_GetFileOriginalChecksum), helpstring("Returns the original checksum of the specified file.")] void GetFileOriginalChecksum([in] BSTR filename);
			[id(35), helpcontext(MsiPath_BindImage),helpstring("Binds the executable IAT to the import functions from DLLS")] void BindImage([in] BSTR file, [in] BSTR dllPath);
			[id(36), propget,helpcontext(MsiPath_SupportsLFN), helpstring("Returns a boolean indicating whether the path supports long file names.")] boolean SupportsLFN();
			[id(37),helpcontext(MsiPath_GetFullUNCFilePath), helpstring("Returns a string representing the full UNC path of the specified file.")] BSTR GetFullUNCFilePath([in] BSTR file);
			[id(38), propget,helpcontext(MsiPath_RelativePath), helpstring("Returns a string representing the path without the volume.")] BSTR RelativePath();
			[id(39), propget,helpcontext(MsiPath_GetSelfRelativeSD), helpstring("Returns a stream representing the security descriptor of the path.")] MsiStream* GetSelfRelativeSD();
	}
*/

DispatchEntry<CAutoPath> AutoPathTable[] = {
	0,  aafPropRO, CAutoPath::Path,            TEXT("Path"),
	1,  aafPropRO, CAutoPath::Volume,          TEXT("Volume"),
	2,  aafMethod, CAutoPath::AppendPiece,     TEXT("AppendPiece,subDir"),
	3,  aafMethod, CAutoPath::ChopPiece,       TEXT("ChopPiece"),
	4,  aafMethod, CAutoPath::FileExists,      TEXT("FileExists,file"),
	5,  aafMethod, CAutoPath::GetFullFilePath, TEXT("GetFullFilePath,file"),
	7,  aafMethod, CAutoPath::GetFileAttribute,TEXT("GetFileAttribute,file,attribute"),
	8,  aafMethod, CAutoPath::SetFileAttribute,TEXT("SetFileAttribute,file,attribute,state"),
	9,  aafPropRO, CAutoPath::Exists,          TEXT("Exists"),
	10, aafMethod, CAutoPath::FileSize,        TEXT("FileSize,file"),
	11, aafMethod, CAutoPath::FileDate,        TEXT("FileDate,file"),
	12, aafMethod, CAutoPath::RemoveFile,      TEXT("RemoveFile,file"),
	13, aafMethod, CAutoPath::EnsureExists,    TEXT("EnsureExists"),
	14, aafMethod, CAutoPath::Remove,          TEXT("Remove"),
	15, aafPropRO, CAutoPath::Writable,        TEXT("Writable"),
	16, aafMethod, CAutoPath::FileWritable,    TEXT("FileWritable,file"),
	17, aafMethod, CAutoPath::FileInUse,       TEXT("FileInUse,file"),
	19, aafMethod, CAutoPath::ClusteredFileSize,      TEXT("ClusteredFileSize,size"),
	20, aafMethod, CAutoPath::GetFileVersionString,   TEXT("GetFileVersionString,file"),
	21, aafMethod, CAutoPath::CheckFileVersion,       TEXT("CheckFileVersion,file,version,language,hash,icfvResult"),
	22, aafMethod, CAutoPath::GetLangIDStringFromFile,TEXT("GetLangIDStringFromFile,file"),
	23, aafMethod, CAutoPath::CheckLanguageIDs,  TEXT("CheckLanguageIDs,file,ids"),
	24, aafMethod, CAutoPath::Compare,           TEXT("Compare,path"),
	25, aafMethod, CAutoPath::Child,             TEXT("Child,parent"),
	26, aafMethod, CAutoPath::TempFileName,      TEXT("TempFileName,prefix,extension,fileNameOnly"),
	27, aafMethod, CAutoPath::FindFile,          TEXT("FindFile,Filter,Depth"),
	28, aafMethod, CAutoPath::SubFolders,        TEXT("SubFolders,ExcludeHidden"),
	29, aafPropRO, CAutoPath::EndSubPath,		 TEXT("EndSubPath"),
	31, aafMethod, CAutoPath::GetImportModulesEnum,     TEXT("GetImportModulesEnum, file"),
	32, aafMethod, CAutoPath::SetVolume, TEXT("SetVolume, volume"),
	33, aafMethod, CAutoPath::ComputeFileChecksum, TEXT("ComputeFileChecksum, filename"),
	34, aafMethod, CAutoPath::GetFileOriginalChecksum, TEXT("GetFileOriginalChecksum, filename"),
	35, aafMethod, CAutoPath::BindImage, TEXT("BindImage, file, dllPath"),
	36, aafPropRO, CAutoPath::SupportsLFN,    TEXT("SupportsLFN"),
	37, aafMethod, CAutoPath::GetFullUNCFilePath, TEXT("GetFullUNCFilePath,file"),
	38, aafMethod, CAutoPath::RelativePath, TEXT("RelativePath"),
	39, aafMethod, CAutoPath::GetSelfRelativeSD, TEXT("GetSelfRelativeSD"),
};
const int AutoPathCount = sizeof(AutoPathTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoPath automation implementation
//____________________________________________________________________________

CAutoPath::CAutoPath(IMsiPath& riPath)
 : CAutoBase(*AutoPathTable, AutoPathCount), m_riPath(riPath)
{
}

CAutoPath::~CAutoPath()
{
	m_riPath.Release();
}

IUnknown& CAutoPath::GetInterface()
{
	return m_riPath;
}

void CAutoPath::Path(CAutoArgs& args)
{
	args = m_riPath.GetPath();
}

void CAutoPath::RelativePath(CAutoArgs& args)
{
	args = m_riPath.GetRelativePath();
}

void CAutoPath::Volume(CAutoArgs& args)
{
	args = new CAutoVolume(m_riPath.GetVolume());
}

void CAutoPath::AppendPiece(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riPath.AppendPiece(*MsiString(args[1].GetMsiString()));
	if (piRec)
		throw piRec;
}

void CAutoPath::ChopPiece(CAutoArgs& /*args*/)
{
	IMsiRecord* piRec = m_riPath.ChopPiece(); 
	if (piRec)
		throw piRec;
}

void CAutoPath::FileExists(CAutoArgs& args)
{
	Bool fExists;
	IMsiRecord* piRec = m_riPath.FileExists(args[1], fExists);
	if (piRec)
		throw piRec;
	args = fExists;
}

void CAutoPath::GetFullFilePath(CAutoArgs& args)
{
	const IMsiString *piStr;
	IMsiRecord* piRec = m_riPath.GetFullFilePath(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::GetFullUNCFilePath(CAutoArgs& args)
{
	const IMsiString *piStr;
	IMsiRecord* piRec = m_riPath.GetFullUNCFilePath(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::GetFileAttribute(CAutoArgs& args)
{
	int iAttrib = args[2];
	ifaEnum ifaAttrib = (ifaEnum) iAttrib;

	Bool fAttrib;
	IMsiRecord* piRec = m_riPath.GetFileAttribute(args[1], ifaAttrib, fAttrib);
	if (piRec)
		throw piRec;
	args = fAttrib;
}

void CAutoPath::SetFileAttribute(CAutoArgs& args)
{
	int iAttrib = args[2];
	ifaEnum ifaAttrib = (ifaEnum) iAttrib;
	IMsiRecord* piRec = m_riPath.SetFileAttribute(args[1], ifaAttrib, args[3]);
	if (piRec)
		throw piRec;
}

void CAutoPath::Exists(CAutoArgs& args)
{
	Bool fExists;
	IMsiRecord* piRec = m_riPath.Exists(fExists);
	if (piRec)
		throw piRec;
	args = fExists;
}

void CAutoPath::FileSize(CAutoArgs& args)
{
	unsigned int uiValue;
	IMsiRecord* piRec = m_riPath.FileSize(args[1], uiValue);
	if (piRec)
		throw piRec;
	args = (int)uiValue; //FIXmsh
}

void CAutoPath::FileDate(CAutoArgs& args)
{
	MsiDate adValue;
	IMsiRecord* piRec = m_riPath.FileDate(args[1], adValue);
	if (piRec)
		throw piRec;
	args = adValue;
}

void CAutoPath::RemoveFile(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riPath.RemoveFile(args[1]);
	if (piRec)
		throw piRec;
}

void CAutoPath::Remove(CAutoArgs& /*args*/)
{
	IMsiRecord* piRec = m_riPath.Remove(0);
	if (piRec)
		throw piRec;
}

void CAutoPath::Writable(CAutoArgs& args)
{
	Bool fWritable;
	IMsiRecord* piRec = m_riPath.Writable(fWritable);
	if (piRec)
		throw piRec;
	args = fWritable;
}

void CAutoPath::FileWritable(CAutoArgs& args)
{
	Bool fWritable;
	IMsiRecord* piRec = m_riPath.FileWritable(args[1], fWritable);
	if (piRec)
		throw piRec;
	args = fWritable;
}

void CAutoPath::FileInUse(CAutoArgs& args)
{
	Bool fInUse;
	IMsiRecord* piRec = m_riPath.FileInUse(args[1], fInUse);
	if (piRec)
		throw piRec;
	args = fInUse;
}

void CAutoPath::ClusteredFileSize(CAutoArgs& args)
{
	unsigned int iSize;
	IMsiRecord* piRec = m_riPath.ClusteredFileSize(args[1], iSize);
	if (piRec)
		throw piRec;
	args = (int)iSize;
}

void CAutoPath::GetFileVersionString(CAutoArgs& args)
{
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.GetFileVersionString(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::CheckFileVersion(CAutoArgs& args)
{
	icfvEnum icfvResult;

	MD5Hash hHash;
	MD5Hash* pHash = 0;
	if(args.Present(4))
	{
		IMsiRecord& riHashRecord = (IMsiRecord&) args[4].Object(IID_IMsiRecord);
		hHash.dwFileSize = riHashRecord.GetInteger(1);
		hHash.dwPart1    = riHashRecord.GetInteger(2);
		hHash.dwPart2    = riHashRecord.GetInteger(3);
		hHash.dwPart3    = riHashRecord.GetInteger(4);
		hHash.dwPart4    = riHashRecord.GetInteger(5);
	}
	
	IMsiRecord* piRec = m_riPath.CheckFileVersion(args[1], args[2], args[3], pHash, icfvResult, NULL);
	if (piRec)
		throw piRec;
	args = (long) icfvResult;
}

void CAutoPath::GetLangIDStringFromFile(CAutoArgs& args)
{
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.GetLangIDStringFromFile(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::CheckLanguageIDs(CAutoArgs& args)
{
	iclEnum riclResult;
	IMsiRecord* piRec = m_riPath.CheckLanguageIDs(args[1], args[2], riclResult);
	if (piRec)
		throw piRec;
	args = (long) riclResult;
}

void CAutoPath::Compare(CAutoArgs& args)
{
	ipcEnum ipc;
	IMsiRecord* piRec = m_riPath.Compare((IMsiPath&)args[1].Object(IID_IMsiPath), ipc);
	if (piRec)
		throw piRec;

	args = (int)ipc;
	
}

void CAutoPath::Child(CAutoArgs& args)
{
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.Child((IMsiPath&)args[1].Object(IID_IMsiPath), piStr);
	if (piRec)
	   throw piRec;
	
	args = piStr;
}

void CAutoPath::TempFileName(CAutoArgs& args)
{
	const ICHAR* szPrefix = ((args.Present(1)) ? args[1] : (const ICHAR*)0);
	const ICHAR* szExtension = ((args.Present(2)) ? args[2] : (const ICHAR*)0);
	Bool fFileNameOnly = ((args.Present(3)) ? (Bool)(int)args[3] : fFalse);
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.TempFileName(szPrefix, szExtension, fFileNameOnly, piStr, 0);
	if (piRec)
	   throw piRec;
	
	args = piStr;
}

void CAutoPath::EnsureExists(CAutoArgs& args)
{
	int cCreatedFolders = 0;
	IMsiRecord* piRec = m_riPath.EnsureExists(&cCreatedFolders);
	if (piRec)
	   throw piRec;
	args = cCreatedFolders;
}

void CAutoPath::FindFile(CAutoArgs& args)
{
	Bool fFound;
	unsigned int iDepth = ((args.Present(2)) ? args[2] : 0);
	IMsiRecord* piRec = m_riPath.FindFile(*((IMsiRecord* )(args[1].ObjectPtr(IID_IMsiRecord))), iDepth, fFound);
	if (piRec)
	   throw piRec;
	args = fFound;
}

void CAutoPath::SubFolders(CAutoArgs& args)
{
	IEnumMsiString* piEnumStr;
	Bool fExcludeHidden = fFalse;
	if(args.Present(1))
		fExcludeHidden = args[1];

	IMsiRecord* piRec = m_riPath.GetSubFolderEnumerator(piEnumStr, fExcludeHidden);
	if (piRec)
	   throw piRec;
	args = *piEnumStr;
}

void CAutoPath::EndSubPath(CAutoArgs& args)
{
	args = m_riPath.GetEndSubPath();
}

void CAutoPath::GetImportModulesEnum(CAutoArgs& args)
{
	MsiString istrName(args[1].GetMsiString());
	IEnumMsiString* piEnumStr;
	IMsiRecord* piRec = m_riPath.GetImportModulesEnum(*istrName, piEnumStr);
	if (piRec)
	   throw piRec;
	args = *piEnumStr;
}

void CAutoPath::SetVolume(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riPath.SetVolume((IMsiVolume&)args[1].Object(IID_IMsiVolume));
	if (piRec)
		throw piRec;
}

void CAutoPath::ComputeFileChecksum(CAutoArgs& args)
{
	DWORD dwHeaderSum,dwComputedSum;
	IMsiRecord* piRec = m_riPath.GetFileChecksum(args[1],&dwHeaderSum,&dwComputedSum);
	if (piRec)
		throw piRec;
	args = (int) dwComputedSum;
}

void CAutoPath::GetFileOriginalChecksum(CAutoArgs& args)
{
	DWORD dwHeaderSum,dwComputedSum;
	IMsiRecord* piRec = m_riPath.GetFileChecksum(args[1],&dwHeaderSum,&dwComputedSum);
	if (piRec)
		throw piRec;
	args = (int) dwHeaderSum;
}

void CAutoPath::BindImage(CAutoArgs& args)
{
	MsiString strDllPath;
	if(args.Present(2))
		strDllPath = (const ICHAR*)args[2];
	IMsiRecord* piError = m_riPath.BindImage(*MsiString(args[1].GetMsiString()), *strDllPath);
	if (piError)
		throw piError;
}

void CAutoPath::SupportsLFN(CAutoArgs& args)
{
	args = (Bool)m_riPath.SupportsLFN();
}

void CAutoPath::GetSelfRelativeSD(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riPath.GetSelfRelativeSD(*&piStream);
	if(piError)
		throw piError;
	args = new CAutoStream(*piStream);
}
//____________________________________________________________________________
//
// MsiFileCopy automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1046-0000-0000-C000-000000000046),  // IID_IMsiAutoFileCopy
		helpcontext(MsiFileCopy_Object),helpstring("File copier object.")
	]
	dispinterface MsiFileCopy
	{
		properties:
		methods:
			[id(1),helpcontext(MsiFileCopy_CopyTo), helpstring("Copies a file from a source path to the supplied target path.")]
				void CopyTo([in] MsiPath* srcPath, [in] MsiPath* destPath, [in] MsiRecord* paramRec);
			[id(2),helpcontext(MsiFileCopy_ChangeMedia), helpstring("Requests a media switch (e.g. from one disk and/or compression cabinet to another).")]
				void ChangeMedia([in] MsiPath* srcPath,[in] BSTR keyFileName,[in] boolean signatureRequired,[in] MsiStream* signatureCert,[in] MsiStream* signatureHash);
	}
*/

DispatchEntry<CAutoFileCopy> AutoCopyTable[] = {
	1, aafMethod, CAutoFileCopy::CopyTo, TEXT("CopyTo,srcPath,destPath,paramRec"),
	2, aafMethod, CAutoFileCopy::ChangeMedia, TEXT("ChangeMedia,srcPath,fileName,signatureRequired,signatureCert,signatureHash"),
};
const int AutoCopyCount = sizeof(AutoCopyTable)/sizeof(DispatchEntryBase);
			
//____________________________________________________________________________
//
// CAutoFileCopy automation implementation
//____________________________________________________________________________

CAutoFileCopy::CAutoFileCopy(IMsiFileCopy& riFileCopy)
 : CAutoBase(*AutoCopyTable, AutoCopyCount), m_riFileCopy(riFileCopy)
{
}

CAutoFileCopy::~CAutoFileCopy()
{
	m_riFileCopy.Release();
}

IUnknown& CAutoFileCopy::GetInterface()
{
	return m_riFileCopy;
}

void CAutoFileCopy::CopyTo(CAutoArgs& args)
{
	IMsiRecord* piErr = m_riFileCopy.CopyTo((IMsiPath&)args[1].Object(IID_IMsiPath),
											(IMsiPath&)args[2].Object(IID_IMsiPath),
											(IMsiRecord&)args[3].Object(IID_IMsiRecord));
	if (piErr)
		throw piErr;
}


void CAutoFileCopy::ChangeMedia(CAutoArgs& args)
{
	Bool fSignatureRequired = fFalse;
	IMsiStream* piSignatureCert = 0;
	IMsiStream* piSignatureHash = 0;
	if (args.Present(3))
	{
		fSignatureRequired = (Bool)args[3];
		if (args.Present(4))
		{
			CVariant& var = args[4];
			piSignatureCert = var.GetType() == VT_EMPTY ? 0 : (IMsiStream*)var.ObjectPtr(IID_IMsiStream);
		}
		if (args.Present(5))
		{
			CVariant& var = args[5];
			piSignatureHash = var.GetType() == VT_EMPTY ? 0 : (IMsiStream*)var.ObjectPtr(IID_IMsiStream);
		}
	}
	IMsiRecord* piErr = m_riFileCopy.ChangeMedia((IMsiPath&)args[1].Object(IID_IMsiPath),args[2],fSignatureRequired, piSignatureCert, piSignatureHash);
	if (piErr)
		throw piErr;
}

//____________________________________________________________________________
//
// MsiFilePatch automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105F-0000-0000-C000-000000000046),  // IID_IMsiAutoFilePatch
		helpcontext(MsiFilePatch_Object),helpstring("File patcher object.")
	]
	dispinterface MsiFilePatch
	{
		properties:
		methods:
			[id(1),helpcontext(MsiFilePatch_ApplyPatch), helpstring("Patches a file.")] void ApplyPatch([in] MsiPath* targetPath, [in] BSTR targetName, [in] MsiPath* patchPath, [in] BSTR patchName, [in] MsiPath* outputPath, [in] BSTR outputName, [in] long perTick);
			[id(2),helpcontext(MsiFilePatch_ContinuePatch), helpstring("Continues patch application started with ApplyPatch.")] void ContinuePatch();
			[id(3),helpcontext(MsiFilePatch_CanPatchFile), helpstring("Checks if a file can be patched.")] long CanPatchFile([in] MsiPath* targetPath, [in] BSTR targetName, [in] MsiPath* patchPath, [in] BSTR patchName);
			[id(4),helpcontext(MsiFilePatch_CancelPatch), helpstring("Cancels patch application started with ApplyPatch.")] void CancelPatch();
};
*/

DispatchEntry<CAutoFilePatch> AutoPatchTable[] = {
	1, aafMethod, CAutoFilePatch::ApplyPatch, TEXT("ApplyPatch,targetPath,targetName,patchPath,patchName,outputPath,outputName,perTick"),
	2, aafMethod, CAutoFilePatch::ContinuePatch, TEXT("ContinuePatch"),
	3, aafMethod, CAutoFilePatch::CanPatchFile, TEXT("CanPatchFile,targetPath,targetName,patchPath,patchName"),
	4, aafMethod, CAutoFilePatch::CancelPatch, TEXT("CancelPatch"),
};
const int AutoPatchCount = sizeof(AutoPatchTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoFilePatch automation implementation
//____________________________________________________________________________

CAutoFilePatch::CAutoFilePatch(IMsiFilePatch& riFilePatch)
 : CAutoBase(*AutoPatchTable, AutoPatchCount), m_riFilePatch(riFilePatch)
{
}

CAutoFilePatch::~CAutoFilePatch()
{
	m_riFilePatch.Release();
}

IUnknown& CAutoFilePatch::GetInterface()
{
	return m_riFilePatch;
}

void CAutoFilePatch::ApplyPatch(CAutoArgs& args)
{
	IMsiRecord* piRecErr = 0;
	unsigned int cbPerTick = args.Present(7) ? (int)args[7] : 0;
	if((piRecErr = m_riFilePatch.ApplyPatch((IMsiPath&)args[1].Object(IID_IMsiPath), args[2],
														 (IMsiPath&)args[3].Object(IID_IMsiPath), args[4],
														 (IMsiPath&)args[5].Object(IID_IMsiPath), args[6],
														 cbPerTick)) != 0)
		throw(piRecErr);
}

void CAutoFilePatch::ContinuePatch(CAutoArgs& /*args*/)
{
	IMsiRecord* piRecErr = m_riFilePatch.ContinuePatch();
	if(piRecErr)
		throw(piRecErr);
}

void CAutoFilePatch::CancelPatch(CAutoArgs& /*args*/)
{
	IMsiRecord* piRecErr = m_riFilePatch.CancelPatch();
	if(piRecErr)
		throw(piRecErr);
}

void CAutoFilePatch::CanPatchFile(CAutoArgs& args)
{
	IMsiRecord* piRecErr = 0;
	icpEnum icp;
	if((piRecErr = m_riFilePatch.CanPatchFile((IMsiPath&)args[1].Object(IID_IMsiPath),args[2],
															(IMsiPath&)args[3].Object(IID_IMsiPath),args[4],
															icp)) != 0)
		throw(piRecErr);

	args = (int)icp;
}


//____________________________________________________________________________
//
// MsiRegKey automation definitions
//____________________________________________________________________________
/*O

	[
			 
		uuid(000C1047-0000-0000-C000-000000000046),  // IID_IMsiAutoRegKey
		helpcontext(MsiRegKey_Object),helpstring("Registry key object.")
	]
	dispinterface MsiRegKey
	{
		properties:
		methods:
			[id(1), helpcontext(MsiRegKey_RemoveValue), helpstring("Removes a named value of a registry key")] 
				void RemoveValue([in] BSTR valueName, [in] BSTR value);
			[id(3), helpcontext(MsiRegKey_RemoveSubTree), helpstring("Removes a subkey of a registry key and all its values and subkeys")] 
				void RemoveSubTree([in] BSTR keyName);
			[id(4), propget, helpcontext(MsiRegKey_Value), helpstring("The named value of a registry key")] 
				BSTR Value([in] BSTR valueName);
			[id(4), propput] 
				void Value([in] BSTR valueName, [in] BSTR value);
			[id(5), helpcontext(MsiRegKey_Values), helpstring("Returns an enumerator object containing all the value names of a registry key")] 
				IEnumVARIANT* Values();
			[id(6), helpcontext(MsiRegKey_SubKeys), helpstring("Returns an enumerator object containing all the subkeys of a registry key")] 
				IEnumVARIANT* SubKeys();
			[id(7), propget, helpcontext(MsiRegKey_Exists), helpstring("Returns registry key exist status, or forces create or delete")] 
				boolean Exists();
			[id(7), propput] 
				void Exists(boolean fFlag);
			[id(8), helpcontext(MsiRegKey_CreateChild), helpstring("Returns a new MsiRegKey object that is a subkey under the parent")] 
				MsiRegKey* CreateChild([in] BSTR subKey);
			[id(9), propget, helpcontext(MsiRegKey_Key), helpstring("The key name")] 
				BSTR Key();
			[id(10), propget, helpcontext(MsiRegKey_ValueExists), helpstring("Returns true if the value exists, false otherwise")] 
				boolean ValueExists(BSTR name);
			[id(11), propget, helpcontext(MsiRegKey_GetSelfRelativeSD), helpstring("Returns a stream object containing a security descriptor in self relative form.")]
				MsiStream* GetSelfRelativeSD();
	};
*/

DispatchEntry<CAutoRegKey> AutoRegKeyTable[] = {
	1, aafMethod, CAutoRegKey::RemoveValue,     TEXT("RemoveValue,valueName,value"),
	3, aafMethod, CAutoRegKey::RemoveSubTree,   TEXT("RemoveSubTree,subKey"),
	4, aafPropRW, CAutoRegKey::Value,           TEXT("Value,valueName"),
	5, aafMethod, CAutoRegKey::Values,          TEXT("Values"),
	6, aafMethod, CAutoRegKey::SubKeys,         TEXT("SubKeys"),
	7, aafPropRW, CAutoRegKey::Exists,          TEXT("Exists"),
	8, aafMethod, CAutoRegKey::CreateChild,     TEXT("CreateChild,SubKey"),
	9, aafPropRO, CAutoRegKey::Key,             TEXT("Key"),
	10, aafPropRO, CAutoRegKey::ValueExists,    TEXT("ValueExists,value"),
	11, aafPropRO, CAutoRegKey::GetSelfRelativeSD, TEXT("GetSelfRelativeSD"),
};        
const int AutoRegKeyCount = sizeof(AutoRegKeyTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiRegKey automation implementation
//____________________________________________________________________________

CAutoRegKey::CAutoRegKey(IMsiRegKey& riRegKey)
 : CAutoBase(*AutoRegKeyTable, AutoRegKeyCount), m_riRegKey(riRegKey)
{
}

CAutoRegKey::~CAutoRegKey()
{
	m_riRegKey.Release();
}

IUnknown& CAutoRegKey::GetInterface()
{
	return m_riRegKey;
}

void CAutoRegKey::RemoveValue(CAutoArgs& args)
{
	IMsiRecord* piRec;
	const ICHAR* pszValueName = 0;
	const IMsiString* pistrValue = 0;
	if(args.Present(1))
		pszValueName = args[1];
	if(args.Present(2))
		pistrValue = &args[2].GetMsiString();
	piRec = m_riRegKey.RemoveValue(pszValueName, pistrValue);
	if(pistrValue)
		pistrValue->Release();
	if (piRec)
		throw piRec;
}

void CAutoRegKey::RemoveSubTree(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riRegKey.RemoveSubTree(args[1]);              
	if (piRec)
		throw piRec;
}

void CAutoRegKey::Value(CAutoArgs& args)
{
	IMsiRecord* piRec;
	if (args.PropertySet())
	{
		MsiString strValue = args[0].GetMsiString();
		if(args.Present(1))
			piRec = m_riRegKey.SetValue(args[1], *strValue);
		else
			piRec = m_riRegKey.SetValue(0, *strValue);
		if (piRec)
			throw piRec;
   }
	else
	{
		const IMsiString* piStr;
		if(args.Present(1))
			piRec = m_riRegKey.GetValue(args[1], piStr);
		else
			piRec = m_riRegKey.GetValue(0, piStr);
		if (piRec)
			throw piRec;
		args = piStr;
	}
}

void CAutoRegKey::Values(CAutoArgs& args)
{
	IEnumMsiString* piEnumStr;
	m_riRegKey.GetValueEnumerator(piEnumStr);
	args = *piEnumStr;

}

void CAutoRegKey::SubKeys(CAutoArgs& args)
{
	IEnumMsiString* piEnumStr;
	m_riRegKey.GetSubKeyEnumerator(piEnumStr);
	args = *piEnumStr;
}

void CAutoRegKey::Exists(CAutoArgs& args)
{
	IMsiRecord* piRec;
	if (args.PropertySet())
	{
		Bool fCreate = args[0];
		if(fCreate == fTrue)
			piRec = m_riRegKey.Create();
		else
			piRec = m_riRegKey.Remove();
		if (piRec)
			throw piRec;
	}
	else
	{
		Bool fExists;
		IMsiRecord* piRec = m_riRegKey.Exists(fExists);
		if (piRec)
			throw piRec;
		args = fExists;
	}
}

void CAutoRegKey::ValueExists(CAutoArgs& args)
{
	Bool fExists;
	IMsiRecord* piRec = m_riRegKey.ValueExists(args[1], fExists);
	if (piRec)
		throw piRec;
	args = fExists;
}

void CAutoRegKey::Key(CAutoArgs& args)
{
	args = m_riRegKey.GetKey();
}

void CAutoRegKey::CreateChild(CAutoArgs& args)
{
	args = new CAutoRegKey(m_riRegKey.CreateChild(args[1]));
}

void CAutoRegKey::GetSelfRelativeSD(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riRegKey.GetSelfRelativeSD(*&piStream);
	if(piError)
		throw piError;
	args = new CAutoStream(*piStream);
}

//____________________________________________________________________________
//
// MsiMalloc automation definitions
//
/*O
	[
			 
		uuid(000C1057-0000-0000-C000-000000000046),  // IID_IMsiAutoMalloc
		helpcontext(MsiMalloc_Object),helpstring("Memory Manager object.")
	]
	dispinterface MsiMalloc
	{
		properties:
		methods:
			[id(1), helpcontext(MsiMalloc_Alloc), helpstring("Allocates a block of memory")] 
			long Alloc([in] long byteCount);
			[id(2), helpcontext(MsiMalloc_Free), helpstring("Frees a block of memory allocated by MsiMalloc.Alloc")] 
			void Free([in] long memoryBlock);
			[id(3), helpcontext(MsiMalloc_SetDebugFlags), helpstring("Sets the MsiMalloc debug flags.")] 
			void SetDebugFlags([in] short grpfDebugFlags);
			[id(4), helpcontext(MsiMalloc_GetDebugFlags), helpstring("Gets the MsiMalloc debug flags.")] 
			short GetDebugFlags( );
			[id(5), helpcontext(MsiMalloc_CheckAllBlocks), helpstring("Checks all memory blocks for corruption.")]
			boolean CheckAllBlocks( );
			[id(6), helpcontext(MsiMalloc_FCheckBlock), helpstring("Checks a single block for corruption.")]
			boolean FCheckBlock( );
			[id(7), helpcontext(MsiMalloc_GetSizeOfBlock), helpstring("Returns the size of the allocated block.")]
			long GetSizeOfBlock( );
			
	};
*/

DispatchEntry<CAutoMalloc> AutoMallocTable[] = {
	1, aafMethod, CAutoMalloc::Alloc,   TEXT("Alloc,byteCount"),
	2, aafMethod, CAutoMalloc::Free,    TEXT("Free,memoryBlock"),
	3, aafMethod, CAutoMalloc::SetDebugFlags, TEXT("SetDebugFlags,grpfDebugFlags"),
	4, aafMethod, CAutoMalloc::GetDebugFlags, TEXT("GetDebugFlags"),
	5, aafMethod, CAutoMalloc::CheckAllBlocks, TEXT("CheckAllBlocks"),
	6, aafMethod, CAutoMalloc::FCheckBlock, TEXT("FCheckBlock,memoryBlock"),
	7, aafMethod, CAutoMalloc::GetSizeOfBlock, TEXT("GetSizeOfBlock,memoryBlock"),
};        
const int AutoMallocCount = sizeof(AutoMallocTable)/sizeof(DispatchEntryBase);

#ifdef CONFIGDB
//____________________________________________________________________________
//
// MsiConfigurationDatabase automation definitions
//____________________________________________________________________________
/*O
#define MsiConfigurationDatabase_Object                    3300
#define MsiConfigurationDatabase_InsertFile                3301
#define MsiConfigurationDatabase_RemoveFile                3302
#define MsiConfigurationDatabase_LookupFile                3303
#define MsiConfigurationDatabase_EnumClient                3304
#define MsiConfigurationDatabase_Commit                    3305
	[
		uuid(000C104A-0000-0000-C000-000000000046),  // IID_IMsiAutoConfigurationDatabase
		helpcontext(MsiConfigurationDatabase_Object),helpstring("Configuration database object.")
	]
	dispinterface MsiConfigurationDatabase
	{
		properties:
		methods:
			[id(1),helpcontext(MsiConfigurationDatabase_InsertFile), helpstring("Registers a file to a client.")]
			boolean InsertFile([in] BSTR folder, [in] BSTR path, [in] BSTR compId);
			[id(2),helpcontext(MsiConfigurationDatabase_RemoveFile), helpstring("Unregisters a file to a client.")]
			boolean RemoveFile([in] BSTR folder, [in] BSTR path, [in] BSTR compId);
			[id(3),helpcontext(MsiConfigurationDatabase_LookupFile), helpstring("Checks if file is registered.")]
			boolean LookupFile([in] BSTR folder, [in] BSTR path, [in] BSTR compId);
			[id(4),helpcontext(MsiConfigurationDatabase_EnumClient), helpstring("Returns a client for a file.")]
			BSTR EnumClient([in] BSTR folder, [in] BSTR path, [in] long index);
			[id(5),helpcontext(MsiConfigurationDatabase_Commit),     helpstring("Commits database updates.")]
			void Commit();
	};
*/

DispatchEntry<CAutoConfigurationDatabase> AutoConfigDatabaseTable[] = {
	1, aafMethod, CAutoConfigurationDatabase::InsertFile, TEXT("InsertFile,folder,file,compId"),
	2, aafMethod, CAutoConfigurationDatabase::RemoveFile, TEXT("RemoveFile,folder,file,compId"),
	3, aafMethod, CAutoConfigurationDatabase::LookupFile, TEXT("LookupFile,folder,file,compId"),
	4, aafMethod, CAutoConfigurationDatabase::EnumClient, TEXT("EnumClient,folder,file,index"),
	5, aafMethod, CAutoConfigurationDatabase::Commit,     TEXT("Commit"),
};
const int AutoConfigDatabaseCount = sizeof(AutoConfigDatabaseTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoConfigurationDatabase automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoConfigurationDatabase(IMsiConfigurationDatabase& riConfigDatabase)
{
	return new CAutoConfigurationDatabase(riConfigDatabase);
}

CAutoConfigurationDatabase::CAutoConfigurationDatabase(IMsiConfigurationDatabase& riConfigurationDatabase)
 : CAutoBase(*AutoConfigDatabaseTable, AutoConfigDatabaseCount), m_riConfigurationDatabase(riConfigurationDatabase)
{
}

CAutoConfigurationDatabase::~CAutoConfigurationDatabase()
{
	m_riConfigurationDatabase.Release();
}

IUnknown& CAutoConfigurationDatabase::GetInterface()
{
	return m_riConfigurationDatabase;
}

void CAutoConfigurationDatabase::InsertFile(CAutoArgs& args)
{
	icdrEnum icdr = m_riConfigurationDatabase.InsertFile(args[1], args[2], args[3]);
	if (icdr == icdrBadPath)
		throw MsiConfigurationDatabase_InsertFile;
	if (icdr == icdrCliented)
		args = fFalse;
	else
		args = fTrue;
}

void CAutoConfigurationDatabase::RemoveFile(CAutoArgs& args)
{
	icdrEnum icdr = m_riConfigurationDatabase.RemoveFile(args[1], args[2], args[3]);
	if (icdr == icdrOk)
		args = fTrue;
	else if (icdr == icdrMore)
		args = fFalse;
	else
		throw MsiConfigurationDatabase_RemoveFile;
}

void CAutoConfigurationDatabase::LookupFile(CAutoArgs& args)
{
	icdrEnum icdr = m_riConfigurationDatabase.LookupFile(args[1], args[2], args[3]);
	if (icdr == icdrOk)
		args = fTrue;
	else if (icdr == icdrNoFile)
		args = fFalse;
	else
		throw MsiConfigurationDatabase_LookupFile;
}

void CAutoConfigurationDatabase::EnumClient(CAutoArgs& args)
{
	ICHAR rgchBuf[100];
	icdrEnum icdr = m_riConfigurationDatabase.EnumClient(args[1], args[2], args[3], rgchBuf);
	if (icdr == icdrOk)
		args = fTrue;
	else if (icdr == icdrNoFile)
		args = fFalse;
	else
		throw MsiConfigurationDatabase_EnumClient;
}

void CAutoConfigurationDatabase::Commit(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riConfigurationDatabase.Commit();
	if(piError)
		throw piError;
}

#endif //CONFIGDB

//____________________________________________________________________________
//
// CMsiMalloc automation implementation
//____________________________________________________________________________

CAutoMalloc::CAutoMalloc(IMsiMalloc& riMalloc)
 : CAutoBase(*AutoMallocTable, AutoMallocCount), m_riMalloc(riMalloc)
{
}

CAutoMalloc::~CAutoMalloc()
{
	m_riMalloc.Release();
}

IUnknown& CAutoMalloc::GetInterface()
{
	return m_riMalloc;
}

void CAutoMalloc::Alloc(CAutoArgs& args)
{
	// We're going to treat the long returned as an opaque data long
	long lcb = args[1];

	args = m_riMalloc.Alloc(lcb);
}

void CAutoMalloc::Free(CAutoArgs& args)
{
	// We're going to treat the long passed in as an opaque data long
	long pv = args[1];

	m_riMalloc.Free((void *)(LONG_PTR)pv);			//!!merced: 4312 long to ptr
}

void CAutoMalloc::SetDebugFlags(CAutoArgs& args)
{
	IMsiDebugMalloc	*piDbgMalloc;
	int grpfDebugFlags = args[1];
	
	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		piDbgMalloc->SetDebugFlags(grpfDebugFlags);
		piDbgMalloc->Release();
	}

}

void CAutoMalloc::GetDebugFlags(CAutoArgs& args)
{
	IMsiDebugMalloc	*piDbgMalloc;
	
	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = piDbgMalloc->GetDebugFlags();
		piDbgMalloc->Release();
	}
	else
		args = 0;

}

void CAutoMalloc::CheckAllBlocks(CAutoArgs& args)
{
	IMsiDebugMalloc	*piDbgMalloc;
	
	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = (Bool)piDbgMalloc->FCheckAllBlocks();
		piDbgMalloc->Release();
	}
	else
		args = fTrue;

}

void CAutoMalloc::FCheckBlock(CAutoArgs& args)
{
	// We're going to treat the long returned as an opaque data long for now
	long pv = args[1];
	IMsiDebugMalloc	*piDbgMalloc;

	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = (Bool)piDbgMalloc->FCheckBlock((void *)(LONG_PTR)pv);			//!!merced: 4312 long to ptr
		piDbgMalloc->Release();
	}
	else
		args = fTrue;
}

void CAutoMalloc::GetSizeOfBlock(CAutoArgs& args)
{
	// We're going to treat the long returned as an opaque data long for now
	long pv = args[1];
	IMsiDebugMalloc	*piDbgMalloc;

	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = (int)piDbgMalloc->GetSizeOfBlock((void *)(LONG_PTR)pv);			//!!merced: 4312 long to ptr
		piDbgMalloc->Release();
	}
	else
		args = 0;
}


//____________________________________________________________________________
//
// MsiString automation definitions
//
/*O
	[
		uuid(000C1042-0000-0000-C000-000000000046),  // IID_IMsiAutoString
		helpcontext(MsiString_Object),helpstring("String object.")
	]
	dispinterface MsiString
	{
		properties:
			[id(0), helpcontext(MsiString_Value), helpstring("String value of object.")]
				BSTR Value;
		methods:
			[id(1), propget, helpcontext(MsiString_IntegerValue), helpstring("Integer value of string object.")]
				long IntegerValue();
			[id(2), propget, helpcontext(MsiString_TextSize), helpstring("Character array size.")]
				long TextSize();
			[id(3), propget, helpcontext(MsiString_CharacterCount), helpstring("Number of displayed characters.")]
				long CharacterCount();
			[id(4), propget, helpcontext(MsiString_IsDBCS), helpstring("String contains double byte characters.")]
				long IsDBCS();
			[id(5), helpcontext(MsiString_Compare), helpstring("Compares string object with another string.")]
				long Compare([in] long mode, [in] BSTR text);
			[id(6), helpcontext(MsiString_Append), helpstring("Appends another string to string object.")]
				void Append([in] BSTR text);
			[id(7), helpcontext(MsiString_Add), helpstring("Adds another string and returns a new string object.")]
				MsiString* Add([in] BSTR text);
			[id(8), helpcontext(MsiString_Extract), helpstring("Extracts a portion of a string to a new string object.")]
				MsiString* Extract([in] long mode, [in] long limit);
			[id(9), helpcontext(MsiString_Remove), helpstring("Removes a portion of a string from the string object.")]
				boolean Remove([in] long mode, [in] long limit);
			[id(10), helpcontext(MsiString_UpperCase), helpstring("Converts characters to upper case.")]
				void UpperCase();
			[id(11), helpcontext(MsiString_LowerCase), helpstring("Converts characters to lower case.")]
				void LowerCase();
	};
*/
  
DispatchEntry<CAutoString> AutoStringTable[] = {
	0, aafPropRW, CAutoString::Value,         TEXT("Value"),
	1, aafPropRO, CAutoString::IntegerValue,  TEXT("IntegerValue"),
	2, aafPropRO, CAutoString::TextSize,      TEXT("TextSize"),
	3, aafPropRO, CAutoString::CharacterCount,TEXT("CharacterCount"),
	4, aafPropRO, CAutoString::IsDBCS,        TEXT("IsDBCS"),
	5, aafMethod, CAutoString::Compare,       TEXT("Compare,mode,text"),
	6, aafMethod, CAutoString::Append,        TEXT("Append,text"),
	7, aafMethod, CAutoString::Add,           TEXT("Add,text"),
	8, aafMethod, CAutoString::Extract,       TEXT("Extract,mode,limit"),
	9, aafMethod, CAutoString::Remove,        TEXT("Remove,mode,limit"),
  10, aafMethod, CAutoString::UpperCase,     TEXT("UpperCase"),
  11, aafMethod, CAutoString::LowerCase,     TEXT("LowerCase"),
};
const int AutoStringCount = sizeof(AutoStringTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoString automation implementation
//____________________________________________________________________________

CAutoString::CAutoString(const IMsiString& riString)
 : CAutoBase(*AutoStringTable, AutoStringCount), m_piString(&riString)
{

	g_cServicesUsers++;
}

CAutoString::~CAutoString()
{
	m_piString->Release();

	ReleaseStaticServices();
}

IUnknown& CAutoString::GetInterface()
{
	return *(IUnknown*)m_piString;
}

void CAutoString::Value(CAutoArgs& args)
{
	if (args.PropertySet())
      m_piString->SetString(args[0], m_piString);
	else
      args = m_piString->GetString();
}

void CAutoString::TextSize(CAutoArgs& args)
{
   args = m_piString->TextSize();
}

void CAutoString::IntegerValue(CAutoArgs& args)
{
   args = m_piString->GetIntegerValue();
}

void CAutoString::CharacterCount(CAutoArgs& args)
{
   args = m_piString->CharacterCount();
}

void CAutoString::IsDBCS(CAutoArgs& args)
{
   args = m_piString->IsDBCS();
}

void CAutoString::Compare(CAutoArgs& args)
{
   args = m_piString->Compare((iscEnum)(int)args[1], args[2]);
}

void CAutoString::Append(CAutoArgs& args)
{
	CVariant& var = args[1];
	if (var.GetType() == VT_EMPTY)
	   return;
	else if ((var.GetType() & ~VT_BYREF) == VT_DISPATCH)
      m_piString->AppendMsiString((const IMsiString&)var.Object(IID_IMsiString), m_piString);
   else
      m_piString->AppendString(var, m_piString);
}

void CAutoString::Add(CAutoArgs& args)
{
	CVariant& var = args[1];
	if (var.GetType() == VT_EMPTY)
   {
      AddRef();
	   args = this;
   }
	else if ((var.GetType() & ~VT_BYREF) == VT_DISPATCH)
      args = new CAutoString(m_piString->AddMsiString((const IMsiString&)var.Object(IID_IMsiString)));
   else
      args = new CAutoString(m_piString->AddString(var));
}

void CAutoString::Extract(CAutoArgs& args)
{
   args = new CAutoString(m_piString->Extract((iseEnum)(int)args[1], args[2]));
}

void CAutoString::Remove(CAutoArgs& args)
{
   args = m_piString->Remove((iseEnum)(int)args[1], args[2], m_piString);
}

void CAutoString::UpperCase(CAutoArgs& /*args*/)
{
   m_piString->UpperCase(m_piString);
}

void CAutoString::LowerCase(CAutoArgs& /*args*/)
{
   m_piString->LowerCase(m_piString);
}


// Handles releasing the static services pointer
void CAutoBase::ReleaseStaticServices()
{
	if (--g_cServicesUsers == 0)
	{
		s_piServices->Release();
		s_piServices = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\auto\script.cpp ===
#include "script.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\buildtools\makeodl\makeodl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       makeodl.cpp
//
//--------------------------------------------------------------------------

#include "common.h"   // to allow use of precompiled headers for windows.h
//#pragma warning(disable : 4201) // unnamed struct/unions, in Win32 headers
//#pragma warning(disable : 4514) // unreferenced inline function has been removed, in Win32 headers
//#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <version.h>
#pragma warning(default: 4201) // unnamed struct/unions, in Win32 headers

BOOL WriteLineToFile(HANDLE hFile, char* szBuffer);
BOOL ReadLineFromFile(HANDLE hFile, char* szBuffer, int cchBufSize, int* iBytesWritten);

const int iMajVer = 0;
const int iMinVer = 1;

int _cdecl main(int argc, char *argv[])
{
	char szInFile[MAX_PATH+1], szOutFile[MAX_PATH+1];

	char *pchInFile = szInFile;
	char *pchOutFile = szOutFile;

	if (argc < 2)
	{
		MessageBox(0, "Syntax: makeodl outfile infile",0,0);
		return 0;
	}
	
	HANDLE hOutFile = CreateFile(argv[1], GENERIC_WRITE, 0, 0, 
 	CREATE_ALWAYS, 0, 0);
	
	if (hOutFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Could not open output file \"%s\"\n", argv[1]);
		return 1;
	}
	
	const int iBufSize = 200;
	char szBuffer[iBufSize + 1];
	wsprintf(szBuffer, "// WARNING: Do not edit this file. It was generated by MAKEODL V%i.%i", iMajVer, iMinVer);
	WriteLineToFile(hOutFile, "//****************************************************************************************");
	WriteLineToFile(hOutFile, szBuffer);
	time_t curTime = time(NULL);
	tm* tmLocalTime = localtime(&curTime);
	strftime(szBuffer, iBufSize, "// Created: %d %b %Y %H:%M:%S", tmLocalTime);
	WriteLineToFile(hOutFile, szBuffer);
	WriteLineToFile(hOutFile, "//****************************************************************************************");
	WriteLineToFile(hOutFile, "#include <msiauto.hh>  // help context ID definitions");
	WriteLineToFile(hOutFile, "#include <msidspid.h>  // MSI dispatch IDs");
	WriteLineToFile(hOutFile, "[");
	WriteLineToFile(hOutFile, "\tuuid(000C107E-0000-0000-C000-000000000046), // LIBID_MsiAuto");
	WriteLineToFile(hOutFile, "\thelpfile(\"MsiAuto.HLP\"),");
	WriteLineToFile(hOutFile, "\thelpstring(\"Microsoft Windows installer 1.0 Internal Test Object Library\"),");
	WriteLineToFile(hOutFile, "\tlcid(0x0409),");
	WriteLineToFile(hOutFile, "\tversion(1.0000),");
	WriteLineToFile(hOutFile, "]");
	WriteLineToFile(hOutFile, "library Installer");
	WriteLineToFile(hOutFile, "{");
	WriteLineToFile(hOutFile, "\timportlib(\"stdole32.tlb\");");
	WriteLineToFile(hOutFile, "\t#define DISPID_NEWENUM -4");	
	

//=== PASS 1 ========================================
//
// Extract all "dispinterface ...." lines and create forward references out of them. 
// Generates some like this:
//
//    dispinterface MyFirstInterface;
//    dispinterface MySecondInterface;
// 	dispinterface MyThirdInterface;
//

	int iBytesRead;
	int cInFile = 2;
	while (cInFile < argc)
	{
		HANDLE hInFile = CreateFile(argv[cInFile], GENERIC_READ, FILE_SHARE_READ, 0, 
	 	OPEN_EXISTING, 0, 0);
	
		if (hInFile == INVALID_HANDLE_VALUE)
		{
			fprintf(stderr, "Could not open input file \"%s\"\n", argv[cInFile]);
			CloseHandle(hOutFile);
			DeleteFile(argv[1]);
			return 1;
		}
	
		const int cchBufSize = 300;
		char szBuffer[cchBufSize+1];	
		while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead))
		{
			if (strstr(szBuffer, "/*O"))
			{
				while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead) && !(strstr(szBuffer,"dispinterface")) &&
				 !(strstr(szBuffer,"*/")))
					;
				if ((iBytesRead!=0) && !(strstr(szBuffer,"*/")))  // !EOF && not end of comment
				{
					lstrcatA(szBuffer,";");
					WriteLineToFile(hOutFile, szBuffer);	
				}
					
			}
	
		}
		CloseHandle(hInFile);
		cInFile++;																				   
	}

//=== PASS 2 ======================================
//
// Extracts all information within ODL comments. 
//

	cInFile = 2;
	while (cInFile < argc)
	{
	
		HANDLE hInFile = CreateFile(argv[cInFile], GENERIC_READ, FILE_SHARE_READ, 0, 
	 	OPEN_EXISTING, 0, 0);
	
		if (hInFile == INVALID_HANDLE_VALUE)
		{
			fprintf(stderr, "Could not open input file \"%s\"\n", argv[cInFile]);
			CloseHandle(hOutFile);
			DeleteFile(argv[1]);
			return 1;
		}
	
		const int cchBufSize = 300;
		char szBuffer[cchBufSize+1];	
		while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead))
		{
			if (strstr(szBuffer, "/*O"))
			{
				while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead) && !(strstr(szBuffer,"*/")))
					WriteLineToFile(hOutFile, szBuffer);
			}
	
		}
		CloseHandle(hInFile);
		cInFile++;
	}
//=========================================

	WriteLineToFile(hOutFile, "}");	
	WriteLineToFile(hOutFile, "//****************************************************************************************");
	WriteLineToFile(hOutFile, "// End of MAKEODL generated file");
	WriteLineToFile(hOutFile, "//****************************************************************************************");

	CloseHandle(hOutFile);	
	return 0;
}


BOOL ReadLineFromFile(HANDLE hFile, char* szBuffer, int cchBufSize, int* iBytesRead)
{
	DWORD dwBytesRead;
	int cch=0;
	char ch;
	
	if (!hFile)
		return FALSE;

	while ( ReadFile(hFile, &ch, sizeof(char), &dwBytesRead, NULL) && dwBytesRead && (cch < cchBufSize))
	{
		*iBytesRead = dwBytesRead;
		if (ch == '\r')
		{
			szBuffer[cch] = '\0';			
			cch=0;
			return TRUE;
		}
		else if (ch == '\n')
		{
		}
		else
		{
			szBuffer[cch] = ch;
			cch++;
		}
	}
	return FALSE;
}

BOOL WriteLineToFile(HANDLE hFile, char* szBuffer)
{
	DWORD cchWritten;
	if (!WriteFile(hFile, szBuffer, lstrlenA(szBuffer), &cchWritten, NULL) || (lstrlenA(szBuffer) != cchWritten))
		return FALSE;
	if (!WriteFile(hFile, "\r\n", 2, &cchWritten, NULL) || (2 != cchWritten))
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\buildtools\mkerrtbl\mkerrtbl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       mkerrtbl.cpp
//
//--------------------------------------------------------------------------

#include "common.h"   // to allow use of precompiled headers for windows.h
//#define WIN32_LEAN_AND_MEAN  // omit stuff we don't need, to make builds fast
//#define INC_OLE2    // IUnknown
//#pragma warning(disable : 4201) // unnamed struct/unions, in Win32 headers
//#pragma warning(disable : 4514) // inline function not used, no possible to fix
//#include <windows.h>

#undef IError
#define IError(a,b,c) { (b), c, #a },  // override normal error definition
#include <msidefs.h>

struct MsiErrorEntry 
{
	int iErr;
	const char* szFmt;
	const char* szName;
};

#define ERRORTABLE  // read only IError(...) lines
MsiErrorEntry rgErrors[] = { {0,0,0},
#include "services.h"  // includes: database.h, path.h, regkey.h
#include "iconfig.h"
#include "engine.h"
#include "handler.h"
};

int cErrors = sizeof(rgErrors)/sizeof(MsiErrorEntry);

char szTxtHeader[] = "Windows installer Error and Debug Messages\r\n\r\n";
char szTxtFormat[] = "%4i %-30s %s\r\n";
char szTxtFooter[] = "";
char szIdtHeader[] = "Error\tMessage\r\n" "i2\tL255\r\n" "Error\tError\r\n";
char szIdtFormat[] = "%i\t%s\r\n";
char szIdtFooter[] = "";
char szRcHeader[]  = "/* Auto-generated error strings, DO NOT EDIT! */\nSTRINGTABLE {\r\n";
char szRcFormat[]  = "\t%i, \"%s\"\r\n";
char szRcFooter[]  = "}\r\n";
char szRHeader[]   = "/* Auto-generated error strings, DO NOT EDIT! */\r\n";
char szRFormat[]   = "resource 'STR ' (%i) {\"%s\"};\r\n";
char szRFooter[]   = "";
char szRtfHeader[] = "{\\rtf1\\ansi {\\fonttbl{\\f0\\fswiss Helv;}"
							"{\\f1\\fmodern Courier New;}} {\\colortbl;} \\fs20\r\n"
							"#{\\footnote Msi_Errors}\r\n${\\footnote Msi Errors}\r\n"
							"\\pard\\f0\\cf1\\sb90{\\li-150\\fi150\\brdrb\\fs24\\b\r\n"
							"Windows installer Errors\r\n\\par}\\li180\r\n"
							"\\trowd\\trgaph108\\trleft108 \\cellx1200\\cellx4400\\cellx9030\r\n"
							"\\intbl{\\b Error #\\cell Constant\\cell Message\\cell }\\row\r\n";
char szRtfFormat[] = "\\intbl %4i \\cell %-30s \\cell %s \\cell \\row\r\n";
char szRtfFooter[] = "\\page}";
char szInfoHeader[] = "PropertyId	Value\r\n" "i2	l255\r\n" "_SummaryInformation	PropertyId\r\n"
"1	1252\r\n"
"2	Debug Error table transform\r\n"
"4	Microsoft Corporation\r\n"
"5	Installer,MSI,Transform\r\n"
"6	Replaces ship messages with debug messages\r\n"
"7	;1033\r\n"
"14	100\r\n" // minimum version - means minimum version of debug error transform will always be 100
"16	49\r\n"
"18	Windows installer\r\n"
"19	2\r\n";

char szError[] = "Must specify a target file name, either *.txt, *.idt, *.rc, *.r, or *.rtf\n";

int _cdecl main(int argc, char *argv[])
{
	char* szExt = "";
	char* szHeader;
	char* szFormat;
	char* szFooter;
	Bool fName = fFalse;
	int iLimit = idbgBase;
	DWORD cbWrite;
	HANDLE hFile;
	if (argc >= 2)
		szExt = argv[1];
	int cbArg = lstrlenA(szExt);
	szExt += cbArg;
	while (cbArg-- && *(--szExt) != '.')
		;
	if (lstrcmpi(szExt, ".txt") == 0)
	{
		fName    = fTrue;
		iLimit   = 9999;
		szHeader = szTxtHeader;
		szFormat = szTxtFormat;
		szFooter = szTxtFooter;
	}
	else if (lstrcmpi(szExt, ".idt") == 0)  // Error.idt
	{
		szHeader = szIdtHeader;
		szFormat = szIdtFormat;
		szFooter = szIdtFooter;
		if ((szExt[-1] | 32) == 'i')         // ErrorSI.idt
		{
			szHeader = szInfoHeader;
			cErrors = 0;
		}
		if ((szExt[-1] | 32) == 'd')         // ErrorD.idt
			iLimit   = 9999;
	}
	else if (lstrcmpi(szExt, ".rc") == 0)
	{
		szHeader = szRcHeader;
		szFormat = szRcFormat;
		szFooter = szRcFooter;
	}
	else if (lstrcmpi(szExt, ".r") == 0)
	{
		szHeader = szRHeader;
		szFormat = szRFormat;
		szFooter = szRFooter;
	}
	else if (lstrcmpi(szExt, ".rtf") == 0)
	{
		fName    = fTrue;
		iLimit   = 9999;
		szHeader = szRtfHeader;
		szFormat = szRtfFormat;
		szFooter = szRtfFooter;
	}
	else
	{
		hFile = ::GetStdHandle(STD_OUTPUT_HANDLE);
		::WriteFile(hFile, szError, sizeof(szError), &cbWrite, 0);
		return 1;
	}
	hFile = ::CreateFile(argv[1], GENERIC_WRITE, FILE_SHARE_READ,
									0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	::WriteFile(hFile, szHeader, lstrlenA(szHeader), &cbWrite, 0);

	for(int iError = 2; iError < cErrors; iError++) // sort by error code
      for (int i = iError; i && rgErrors[i].iErr < rgErrors[i-1].iErr; i--)
      {
         rgErrors[0].iErr     = rgErrors[i].iErr;
         rgErrors[0].szFmt    = rgErrors[i].szFmt;
         rgErrors[0].szName   = rgErrors[i].szName;
         rgErrors[i].iErr     = rgErrors[i-1].iErr;
         rgErrors[i].szFmt    = rgErrors[i-1].szFmt;
         rgErrors[i].szName   = rgErrors[i-1].szName;
         rgErrors[i-1].iErr   = rgErrors[0].iErr;
         rgErrors[i-1].szFmt  = rgErrors[0].szFmt;
         rgErrors[i-1].szName = rgErrors[0].szName;
      }

	for(int c=1; c < cErrors; c++)
	{
		char szBuf[1024];
		int iError = rgErrors[c].iErr;
		if (iError >= iLimit)
			break;
		if (fName)
			cbWrite = wsprintf(szBuf, szFormat, iError, rgErrors[c].szName, rgErrors[c].szFmt);
		else
			cbWrite = wsprintf(szBuf, szFormat, iError, rgErrors[c].szFmt);
		::WriteFile(hFile, szBuf, cbWrite, &cbWrite, 0);
	}
	::WriteFile(hFile, szFooter, lstrlenA(szFooter), &cbWrite, 0);
	::CloseHandle(hFile);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\auto\autocom.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       autocom.cpp
//
//--------------------------------------------------------------------------

/* autocom.cpp

 Common automation implementation for install engine
 This is a separate DLL, not required for normal install
 Uses exception handling, must compile with -GX switch
____________________________________________________________________________*/

#include "common.h"  // must be first for precompiled headers to work

#define AUT  // local automation DLL function                 

#define AUTOMATION_HANDLING  // instantiate IDispatch implementation
#include "autocom.h"
#include "msiauto.hh"  // help context ID definitions

// definitions required for module.h, for entry points and registration
#ifdef DEBUG
# define CLSID_COUNT  2
#else
# define CLSID_COUNT  1
#endif
#define PROFILE_OUTPUT      "msisrvd.mea";
#define MODULE_TERMINATE    FreeLibraries
#define MODULE_CLSIDS       rgCLSID         // array of CLSIDs for module objects
#define MODULE_PROGIDS      rgszProgId      // ProgId array for this module
#define MODULE_DESCRIPTIONS rgszDescription // Registry description of objects
#define MODULE_FACTORIES    rgFactory       // factory functions for each CLSID
#define IDISPATCH_INSTANCE  // can return IDispatch from factory
#define REGISTER_TYPELIB    GUID_LIBID_MsiAuto  // type library to register from resource
#define TYPELIB_MAJOR_VERSION 1
#define TYPELIB_MINOR_VERSION 0
#include "module.h"   // self-reg and assert functions
#include "engine.h"   // to allow release of object pointers

// Asserts are not being used in this module, so we don't #define ASSERT_HANDLING

const GUID IID_IMsiEngine               = GUID_IID_IMsiEngine;
const GUID IID_IMsiHandler              = GUID_IID_IMsiHandler;
const GUID IID_IMsiConfigurationManager = GUID_IID_IMsiConfigurationManager;

#if defined(DEBUG)
const GUID CLSID_IMsiServices             = GUID_IID_IMsiServicesDebug;
const GUID CLSID_IMsiEngine               = GUID_IID_IMsiEngineDebug;
const GUID CLSID_IMsiHandler              = GUID_IID_IMsiHandlerDebug;
const GUID CLSID_IMsiConfigurationManager = GUID_IID_IMsiConfigManagerDebug;
#else // SHIP
const GUID CLSID_IMsiServices             = GUID_IID_IMsiServices;
const GUID CLSID_IMsiEngine               = GUID_IID_IMsiEngine;
const GUID CLSID_IMsiHandler              = GUID_IID_IMsiHandler;
const GUID CLSID_IMsiConfigurationManager = GUID_IID_IMsiConfigurationManager;
#endif
const GUID CLSID_IMsiMessage              = GUID_IID_IMsiMessage;
const GUID CLSID_IMsiExecute              = GUID_IID_IMsiExecute;
#ifdef CONFIGDB
const GUID CLSID_IMsiConfigurationDatabase= GUID_IID_IMsiConfigurationDatabase;
#endif

//____________________________________________________________________________
//
// COM objects produced by this module's class factories
//____________________________________________________________________________

const GUID rgCLSID[CLSID_COUNT] =
{  GUID_IID_IMsiAuto
#ifdef DEBUG
 , GUID_IID_IMsiAutoDebug
#endif
};

const ICHAR* rgszProgId[CLSID_COUNT] =
{  SZ_PROGID_IMsiAuto
#ifdef DEBUG
 , SZ_PROGID_IMsiAutoDebug
#endif
};

const ICHAR* rgszDescription[CLSID_COUNT] =
{  SZ_DESC_IMsiAuto
#ifdef DEBUG
 , SZ_DESC_IMsiAutoDebug
#endif
};

IUnknown* CreateAutomation();

ModuleFactory rgFactory[CLSID_COUNT] = 
{ CreateAutomation
#ifdef DEBUG
 , CreateAutomation
#endif
};

//____________________________________________________________________________
//
// Enumerated constants
//____________________________________________________________________________

/*O

typedef [helpcontext(50),helpstring("Installer enumerations")] enum
{
	// expanded to enumerate all opcodes, must be first definition in this enum
	#define MSIXO(op, type, args) [helpcontext(Operation_ixo##op), helpstring(#op)] ixo##op,
	#include "opcodes.h"

	[helpcontext(MsiData_Object),    helpstring("IMsiData interface")]     iidMsiData     = 0xC1001,
	[helpcontext(MsiString_Object),  helpstring("IMsiString interface")]   iidMsiString   = 0xC1002,
	[helpcontext(MsiRecord_Object),  helpstring("IMsiRecord interface")]   iidMsiRecord   = 0xC1003,
	[helpcontext(MsiVolume_Object),  helpstring("IMsiVolume interface")]   iidMsiVolume   = 0xC1004,
	[helpcontext(MsiPath_Object),    helpstring("IMsiPath interface")]     iidMsiPath     = 0xC1005,
	[helpcontext(MsiFileCopy_Object),helpstring("IMsiFileCopy interface")] iidMsiFileCopy = 0xC1006,
	[helpcontext(MsiRegKey_Object),  helpstring("IMsiRegKey interface")]   iidMsiRegKey   = 0xC1007,
	[helpcontext(MsiTable_Object),   helpstring("IMsiTable interface")]    iidMsiTable    = 0xC1008,
	[helpcontext(MsiCursor_Object),  helpstring("IMsiCursor interface")]   iidMsiCursor   = 0xC1009,
	[helpcontext(MsiAuto_Object),    helpstring("IMsiAuto interface")]     iidMsiAuto     = 0xC100A,
	[helpcontext(MsiServices_Object),helpstring("IMsiServices interface")] iidMsiServices = 0xC100B,
	[helpcontext(MsiView_Object),    helpstring("IMsiView interface")]     iidMsiView     = 0xC100C,
	[helpcontext(MsiDatabase_Object),helpstring("IMsiDatabase interface")] iidMsiDatabase = 0xC100D,
	[helpcontext(MsiEngine_Object),  helpstring("IMsiEngine interface")]   iidMsiEngine   = 0xC100E,
	[helpcontext(MsiHandler_Object), helpstring("IMsiHandler interface")]  iidMsiHandler  = 0xC100F,
	[helpcontext(MsiDialog_Object),  helpstring("IMsiDialog interface")]   iidMsiDialog   = 0xC1010,
	[helpcontext(MsiEvent_Object),   helpstring("IMsiEvent interface")]    iidMsiEvent    = 0xC1011,
	[helpcontext(MsiControl_Object), helpstring("IMsiControl  interface")] iidMsiControl  = 0xC1012,
	[helpcontext(MsiDialogHandler_Object), helpstring("IMsiDialogHandler interface")] iidMsiDialogHandler = 0xC1013,
	[helpcontext(MsiStorage_Object), helpstring("IMsiStorage interface")]  iidMsiStorage  = 0xC1014,
	[helpcontext(MsiStream_Object),  helpstring("IMsiStream interface")]   iidMsiStream   = 0xC1015,
	[helpcontext(MsiSummaryInfo_Object), helpstring("IMsiSummaryInfo interface")] iidMsiSummaryInfo = 0xC1016,
	[helpcontext(MsiMalloc_Object),  helpstring("IMsiMalloc interface")]   iidMsiMalloc   = 0xC1017,
	[helpcontext(MsiSelectionManager_Object),  helpstring("IMsiSelectionManager interface")] iidMsiSelectionManager   = 0xC1018,
	[helpcontext(MsiDirectoryManager_Object),  helpstring("IMsiDirectoryManager interface")] iidMsiDirectoryManager   = 0xC1019,
	[helpcontext(MsiCostAdjuster_Object),  helpstring("IMsiCostAdjuster interface")] iidMsiCostAdjuster = 0xC101A,
	[helpcontext(MsiConfigurationManager_Object),  helpstring("IMsiConfigurationManager interface")] iidMsiConfigurationManager = 0xC101B,
	[helpcontext(MsiServer_Object),  helpstring("IMsiServer Automation interface")]   iidMsiServerAuto   = 0xC103F,
	[helpcontext(MsiMessage_Object), helpstring("IMsiMessage interface")]  iidMsiMessage  = 0xC101D,
	[helpcontext(MsiExecute_Object), helpstring("IMsiExecute interface")]  iidMsiExecute  = 0xC101E,
#ifdef CONFIGDB
	[helpcontext(MsiExecute_Object), helpstring("IMsiExecute interface")]  iidMsiExecute  = 0xC101E,
#endif

	[helpstring("0")]  idtUnknown   = 0,
	[helpstring("1")]  idtAllDrives = 1,
	[helpstring("2")]  idtRemovable = 2,
	[helpstring("3")]  idtFixed     = 3,
	[helpstring("4")]  idtRemote    = 4,
	[helpstring("5")]  idtCDROM     = 5,
	[helpstring("6")]  idtRAMDisk   = 6,
	[helpstring("2")]  idtFloppy   =  2,

	[helpcontext(MsiEngine_EvaluateCondition),helpstring("0, EvaluateCondition: Expression evaluates to False")]
		iecFalse = 0,
	[helpcontext(MsiEngine_EvaluateCondition),helpstring("1, EvaluateCondition: Expression evaluates to True")]
		iecTrue  = 1,
	[helpcontext(MsiEngine_EvaluateCondition),helpstring("2, EvaluateCondition: No expression is given")]
		iecNone  = 2,
	[helpcontext(MsiEngine_EvaluateCondition),helpstring("3, EvaluateCondition: Syntax error in expression")]
		iecError = 3,

	[helpcontext(MsiEngine_SetMode),helpstring("1, Engine Mode: admin mode install, else product install")]
		iefAdmin           = 1,
	[helpcontext(MsiEngine_SetMode),helpstring("2, Engine Mode: advertise mode of install")]
		iefAdvertise       = 2,
	[helpcontext(MsiEngine_SetMode),helpstring("4, Engine Mode: maintenance mode database loaded")]
		iefMaintenance     = 4, 
	[helpcontext(MsiEngine_SetMode),helpstring("8, Engine Mode: rollback is enabled")]	
		iefRollbackEnabled = 8,
	[helpcontext(MsiEngine_SetMode),helpstring("16, Engine Mode: install marked as in-progress and other installs locked out")]
		iefServerLocked    = 16,
	[helpcontext(MsiEngine_SetMode),helpstring("64, Engine Mode: executing or spooling operations")]
		iefOperations      = 64,
	[helpcontext(MsiEngine_SetMode),helpstring("128, Engine Mode: source LongFileNames suppressed via PID_MSISOURCE summary property")]
		iefNoSourceLFN     = 128,
	[helpcontext(MsiEngine_SetMode),helpstring("256, Engine Mode: log file active at start of Install()")]
		iefLogEnabled      = 256,
	[helpcontext(MsiEngine_SetMode),helpstring("512, Engine Mode: reboot is needed")]
		iefReboot          = 512, 
	[helpcontext(MsiEngine_SetMode),helpstring("1024, Engine Mode: target LongFileNames suppressed via SHORTFILENAMES property")]
		iefSuppressLFN     = 1024,
	[helpcontext(MsiEngine_SetMode),helpstring("2048, Engine Mode: installing files from cabinets and files using Media table")]
		iefCabinet         = 2048,
	[helpcontext(MsiEngine_SetMode),helpstring("4096, Engine Mode: add files in use to FilesInUse table")]
		iefCompileFilesInUse = 4096,
	[helpcontext(MsiEngine_SetMode),helpstring("8192, Engine Mode: operating systems is Windows95, not Windows NT")]
	  iefWindows         = 8192,
	[helpcontext(MsiEngine_SetMode),helpstring("16384, Engine Mode: reboot is needed to continue installation")]
		iefRebootNow       = 16384,
	[helpcontext(MsiEngine_SetMode),helpstring("32768, Engine Mode:  operating system supports the new GPT stuff")]
		iefGPTSupport      = 32768,

	[helpcontext(MsiFileCopy_CopyTo),helpstring("1")] ictoSourceName     = 1,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("2")] ictoDestName       = 2,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("3")] ictoAttributes     = 3,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("4")] ictoMacFileType    = 4,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("5")] ictoMacCreator     = 5,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("6")] ictoMacFinderFlags = 6,
  
	[helpcontext(MsiPath_CheckFileVersion),helpstring("0")]  icfvNoExistingFile  = 0,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("1")]  icfvExistingLower   = 1,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("2")]  icfvExistingEqual   = 2,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("3")]  icfvExistingHigher  = 3,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("4")]  icfvVersStringError = 4,

	[helpcontext(MsiPath_Compare),helpstring("0")]  ipcEqual       = 0,
	[helpcontext(MsiPath_Compare),helpstring("1")]  ipcChild       = 1,
	[helpcontext(MsiPath_Compare),helpstring("2")]  ipcParent      = 2,
	[helpcontext(MsiPath_Compare),helpstring("3")]  ipcNoRelation  = 3,

	[helpcontext(MsiPath_GetFileAttribute),helpstring("0")]  ifaArchive    = 0,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("1")]  ifaDirectory  = 1,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("2")]  ifaHidden     = 2,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("3")]  ifaNormal     = 3,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("4")]  ifaReadOnly   = 4,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("5")]  ifaSystem     = 5,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("6")]  ifaTemp       = 6,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("7")]  ifaCompressed = 7,

	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("0")]  iclExistNoFile    = 0,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("1")]  iclExistNoLang    = 1,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("2")]  iclExistSubset    = 2,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("3")]  iclExistEqual     = 3,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("4")]  iclExistIntersect = 4,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("5")]  iclExistSuperset  = 5,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("6")]  iclExistNullSet   = 6,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("7")]  iclExistLangNeutral = 7,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("8")]  iclNewLangNeutral   = 8,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("9")]  iclExistLangSetError = 9,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("10")] iclNewLangSetError   = 10,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("11")] iclLangStringError = 11,

	[helpcontext(MsiServices_CreateCopier),helpstring("0")] ictFileCopier          = 0,
	[helpcontext(MsiServices_CreateCopier),helpstring("1")] ictFileCabinetCopier   = 1,
	[helpcontext(MsiServices_CreateCopier),helpstring("2")] ictStreamCabinetCopier = 2,

	[helpcontext(MsiFilePatch_CanPatchFile),helpstring("0, Can patch file.")]  icpCanPatch       = 0,
	[helpcontext(MsiFilePatch_CanPatchFile),helpstring("1, Cannot patch file.")]  icpCannotPatch    = 1,
	[helpcontext(MsiFilePatch_CanPatchFile),helpstring("2, Patch unecessary, file up to date.")]  icpUpToDate       = 2,

	[helpcontext(MsiString_Extract),helpstring("0, Extract mode: First n characters")]
		iseFirst     = 0,
	[helpcontext(MsiString_Extract),helpstring("2, Extract mode: Up to character n")]
		iseUpto      = 2,
	[helpcontext(MsiString_Extract),helpstring("3, Extract mode: Up to and including character n")]
		iseIncluding = 2+1,
	[helpcontext(MsiString_Extract),helpstring("4, Extract mode: Last n characters")]
		iseLast      = 4,
	[helpcontext(MsiString_Extract),helpstring("6, Extract mode: After last character n")]
		iseAfter     = 2+4,
	[helpcontext(MsiString_Extract),helpstring("7, Extract mode: From last character n")]
		iseFrom      = 2+1+4,
	[helpcontext(MsiString_Extract),helpstring("8, Extract mode: First n characters, trim leading and trailing white space")]
		iseFirstTrim = 0+8,
	[helpcontext(MsiString_Extract),helpstring("10, Extract mode: Up to character n, trim leading and trailing white space")]
		iseUptoTrim  = 2+8,
	[helpcontext(MsiString_Extract),helpstring("11, Extract mode: Up to and including character n, trim leading and trailing white space")]
		iseIncludingTrim  = 2+1+8,
	[helpcontext(MsiString_Extract),helpstring("12, Extract mode: First n characters, trim leading and trailing white space")]
		iseLastTrim  = 4+8,
	[helpcontext(MsiString_Extract),helpstring("14, Extract mode: After character n, trim leading and trailing white space")]
		iseAfterTrim = 2+4+8,
	[helpcontext(MsiString_Extract),helpstring("15, Extract mode: From character n, trim leading and trailing white space")]
		iseFromTrim  = 2+1+4+8,

	[helpcontext(MsiString_Compare),helpstring("0, Compare mode: Entire string, case-sensitive")]
		iscExact  = 0,
	[helpcontext(MsiString_Compare),helpstring("1, Compare mode: Entire string, case-insensitive")]
		iscExactI = 1,
	[helpcontext(MsiString_Compare),helpstring("2, Compare mode: Match at start, case-sensitive")]
		iscStart  = 2,
	[helpcontext(MsiString_Compare),helpstring("3, Compare mode: Match at start, case-insensitive")]
		iscStartI = 3,
	[helpcontext(MsiString_Compare),helpstring("4, Compare mode: Match at end, case-sensitive")]
		iscEnd    = 4,
	[helpcontext(MsiString_Compare),helpstring("5, Compare mode: Match at end, case-insensitive")]
		iscEndI   = 5,
	[helpcontext(MsiString_Compare),helpstring("6, Compare mode: Match within, case-sensitive")]
		iscWithin = 2+4,
	[helpcontext(MsiString_Compare),helpstring("7, Compare mode: Match within, case-insensitive")]
		iscWithinI= 2+4+1,

  	[helpcontext(MsiServices_WriteIniFile),helpstring("0, write .INI file mode: Creates/Updates .INI entry")]
		iifIniAddLine = 0,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("1, write .INI file mode: Creates .INI entry only if absent")]
		iifIniCreateLine = 1,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("2, write .INI file mode: Deletes .INI entry")]
		iifIniRemoveLine = 2,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("3, write .INI file mode: Creates/ Appends a new tag to a .INI entry")]
		iifIniAddTag = 3,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("4, write .INI file mode: Deletes a tag from a .INI entry")]
		iifIniRemoveTag = 4,


	[helpcontext(MsiCursor_IntegerData),helpstring("Null integer value for MsiCursor data")]
		iMsiNullInteger  = 0x80000000,
	[helpcontext(MsiCursor_StringData),helpstring("Null string value for IMsiCursor data")]
		iMsiNullStringIndex = 0,
	[helpcontext(MsiTable_Object),helpstring("MsiTable: Maximum number of columns in a table")]
		iMsiMaxTableColumns = 32,

	[helpcontext(MsiDatabase_OpenView),helpstring("0, OpenView intent: No data access")]
		ivcNoData = 0,
	[helpcontext(MsiDatabase_OpenView),helpstring("1, OpenView intent: Fetch rows")]
		ivcFetch  = 1,
	[helpcontext(MsiDatabase_OpenView),helpstring("2, OpenView intent: Update rows")]
		ivcUpdate = 2,
	[helpcontext(MsiDatabase_OpenView),helpstring("4, OpenView intent: Insert rows")]
		ivcInsert = 4,
	[helpcontext(MsiDatabase_OpenView),helpstring("8, OpenView intent: Delete rows")]
		ivcDelete = 8,

	[helpcontext(MsiDatabase_UpdateState),helpstring("UpdateState: database open read-only, changes are not saved")]
		idsRead     = 0,
	[helpcontext(MsiDatabase_UpdateState),helpstring("UpdateState: database fully operational for read and write")]
		idsWrite    = 1,

	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: refresh fetched data in current record")]
		irmRefresh = 0,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: insert new record, fails if matching key exists")]
		irmInsert  = 1,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: update existing non-key data of fetched record")]
		irmUpdate  = 2,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: insert record, replacing any existing record")]
		irmAssign  = 3,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: modify record, delete old if primary key edit")]
		irmReplace = 4,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: fails if record with duplicate key not identical")]
		irmMerge   = 5,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: remove row referenced by this record from table")]
		irmDelete  = 6,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: insert temporary record")]
		irmInsertTemporary = 7,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a fetched record")]
		irmValidate = 8,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a new record")]
		irmValidateNew = 9,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a field(s) for incomplete query record")]
		irmValidateField = 10,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a fetched record before delete")]
		irmValidateDelete = 11,

	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: no error")]
		iveNoError = 0,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Duplicate Primary Key")]
		iveDuplicateKey = 1,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Not a nullable column")]
		iveRequired = 2,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Not a valid foreign key")]
		iveBadLink = 3,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Value exceeds MaxValue")]
		iveOverFlow = 4,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Value below MinValue")]
		iveUnderFlow = 5,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Value not a member of set")]
		iveNotInSet = 6,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid version string")]
		iveBadVersion = 7,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid case, must be all upper or all lower case")]
		iveBadCase = 8,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid GUID")]
		iveBadGuid = 9,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid wildcard or wildcard usage")]
		iveBadWildCard = 10,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid identifier")]
		iveBadIdentifier = 11,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid LangID")]
		iveBadLanguage = 12,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid filename")]
		iveBadFilename = 13,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid path")]
		iveBadPath = 14,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Bad condition string")]
		iveBadCondition = 15,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid format string")]
		iveBadFormatted = 16,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid template string")]
		iveBadTemplate = 17,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid DefaultDir string")]
		iveBadDefaultDir = 18,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid registry path")]
		iveBadRegPath = 19,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid CustomSource string")]
		iveBadCustomSource = 20,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid Property string")]
		iveBadProperty = 21,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: _Validation table doesn't have entry for column")]
		iveMissingData = 22,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Category string listed in _Validation table is not supported")]
		iveBadCategory = 23,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Table in KeyTable of _Validation table could not be found/loaded")]
		iveBadKeyTable = 24,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: value in MaxValue col of _Validation table is smaller than MinValue col value")]
		iveBadMaxMinValues = 25,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid Cabinet string")]
		iveBadCabinet = 26,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid Shortcut Target string")]
		iveBadShortcut = 27,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: String Greater Than Length Allowed By Column Def")]
		iveStringOverflow = 28,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Primary Keys Cannot Be Set To Be Localized")]
		iveBadLocalizeAttrib = 29,

	[helpcontext(MsiCursor_RowState),helpstring("RowState: persistent attribute for external use")]
		iraUserInfo     = 0,   
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row will not normally be persisted if state is set")]
		iraTemporary    = 1,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row has been updated if set (not settable)")]
		iraModified     = 2,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row has been inserted (not settable)")]
		iraInserted     = 3,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: attempt to merge with non-identical non-key data (not settable)")]
		iraMergeFailed  = 4,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row is not accessible until lock is released (not settable)")]
		iraLocked       = 7,

	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table has persistent columns")]
		itsPermanent   = 0,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: temporary table, no persistent columns")]
		itsTemporary   = 1,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table currently defined in system catalog")]
		itsTableExists = 2,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table currently present in memory")]
		itsDataLoaded  = 3,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: user state flag reset, not used internally")]
		itsUserClear   = 4,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: user state flag set, not used internally")]
		itsUserSet     = 5,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table has been transferred to output database")]
		itsOutputDb    = 6,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: unable to write table to database")]
		itsSaveError   = 7,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table is not locked in memory")]
		itsUnlockTable = 8,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table is locked in memory")]
		itsLockTable   = 9,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table needs to be transformed when loaded")]
		itsTransform   = 10,

	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: Named table is not in database")]
		itsUnknown = 0,
//	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table is temporary, not persistent")]
//		itsTemporary = 1,
	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table exists in database, not loaded")]
		itsUnloaded = 2,
	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table is loaded into memory")]
		itsLoaded = 3,
	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table has been transferred to output database")]
		itsOutput = 6,
//	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: unable to write table to database")]
//		itsSaveError = 7,
//	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table needs to have transform applied")]
//		itsTransform = 10,

	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: no errors suppressed")]
		iteNone = 0,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: adding row that exists")]
		iteAddExistingRow = 1,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: deleting row that doesn't exist")]
		iteDelNonExistingRow = 2,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: adding table that exists")]
		iteAddExistingTable = 4,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: deleting table that doesn't exist")]
		iteDelNonExistingTable = 8,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: modifying a row that doesn't exist")]
		iteUpdNonExistingRow = 16,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: changing the code page of a database")]
		iteChangeCodePage =    32,


   [helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: no validation")]
		itvNone = 0,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: transform language matches datbase default language")]
		itvLanguage = 1,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: transform product matches database product")]
		itvProduct = 2,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: transform platform matches database product")]
		itvPlatform = 4,
   [helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: use major version")]
		itvMajVer = 8,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: use minor version")]
		itvMinVer = 16,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: use update version")]
		itvUpdVer = 32,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version < transform version")]
		itvLess = 64,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version <= transform version")]
		itvLessOrEqual = 128,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version = transform version")]
		itvEqual = 256,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version >= transform version")]
		itvGreaterOrEqual = 512,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version > transform version")]
		itvGreater = 1024,

	[helpcontext(MsiTable_ColumnType),helpstring("ColumnType: Column does not exist")]
		icdUndefined = -1,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: 32-bit integer, OBSOLETE")]
		icdInteger = 0,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: 32-bit integer")]
		icdLong    = 0x000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: 16-bit integer")]
		icdShort   = 0x400,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: MsiData object or MsiStream")]
		icdObject  = 0x800,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: Database string index")]
		icdString  = 0xC00,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column will accept null values")]
		icdNullable = 0x1000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column is component of primary key")]
		icdPrimaryKey = 0x2000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column will not accept null values")]
		icdNoNulls = 0x0000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column is saved in persistent database")]
		icdPersistent = 0x0100,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column is temporary, in-memory only")]
		icdTemporary = 0x0000,
	[helpcontext(MsiTable_ColumnType),helpstring("ColumnType: for isolating the SQL column size from the column defintion")]
		icdSizeMask = 0x00FF,

	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Read-only")]
		ismReadOnly = 0,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Transacted mode, can rollback")]
		ismTransact = 1,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Direct write, not transacted")]
		ismDirect   = 2,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Create new storage file, transacted mode")]
		ismCreate   = 3,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Create new storage file, direct mode")]
		ismCreateDirect = 4,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Uncompressed stream names (for downlevel compatibility)")]
		ismRawStreamNames = 16,

	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Read-only")]
		idoReadOnly = 0,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Transacted mode, can rollback")]
		idoTransact = 1,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Direct write, not transacted")]
		idoDirect   = 2,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Create new storage file, transacted mode")]
		idoCreate   = 3,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Create new storage file, direct mode")]
		idoCreateDirect = 4,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Opens an execution script for enumeration")]
		idoListScript = 5,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Uncompressed stream names (for downlevel compatibility)")]
		idoRawStreamNames = 16,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Patch file, using different CLSID")]
		idoPatchFile = 32,

	[helpcontext(MsiServices_SupportLanguageId),helpstring("System doesn't support language")]
		isliNotSupported = 0,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Base language differs from current language")]
		isliLanguageMismatch = 1,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Base language matches, but dialect mismatched")]
		isliDialectMismatch = 2,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Base language matches, no dialect supplied")]
		isliLanguageOnlyMatch = 3,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Exact match, both language and dialect")]
		isliExactMatch = 4,

	[helpcontext(MsiHandler_Message),helpstring("MessageType: OBSOLETE - use imtFatalExit")]
		imtOutOfMemory = 0x00000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: fatal error, hang or out of memory")]
		imtFatalExit   = 0x00000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: error message,   [1] is error code")]
		imtError      =  0x01000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: warning message, [1] is error code, not fatal")]
		imtWarning    =  0x02000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: user request message")]
		imtUser       =  0x03000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: informative message, no action should be taken")]
		imtInfo       =  0x04000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: list of files in use that need to be replaced")]
		imtFilesInUse =  0x05000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: request to determine a valid source location")]
		imtResolveSource=0x06000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: out of disk space")]
		imtOutOfDiskSpace = 0x07000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: start of action, [1] action name, [2] description")]
		imtActionStart = 0x08000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: data associated with individual action item")]
		imtActionData  = 0x09000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: progress gauge info, [1] units so far, [2] total")]
		imtProgress    = 0x0A000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: UI control message")]
		imtCommonData =  0x0B000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Ok button")]
		imtOk               = 0,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Ok, Cancel buttons")]
		imtOkCancel         = 1,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Abort, Retry, Ignore buttons")]
		imtAbortRetryIgnore = 2,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Yes, No, Cancel buttons")]
		imtYesNoCancel      = 3,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Yes, No buttons")]
		imtYesNo            = 4,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Retry, Cancel buttons")]
		imtRetryCancel      = 5,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: first button is default")]
		imtDefault1     = 0x000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: second button is default")]
		imtDefault2     = 0x100,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: third button is default")]
		imtDefault3     = 0x200,

	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: error occurred")]
		imsError  =  -1,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: no action taken")]
		imsNone   =  0,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDOK")]
		imsOk     =  1,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDCANCEL")]
		imsCancel =  2,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDABORT")]
  		imsAbort  =  3,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDRETRY")]
		imsRetry  =  4,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDIGNORE")]
		imsIgnore =  5,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDYES")]
		imsYes    =  6,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDNO")]
		imsNo     =  7,

	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("No memory debugging information")]  
		idbgmemNone   = 0,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Don't reuse freed blocks.")]
		idbgmemKeepMem = 1,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Log all allocations")]
		idbgmemLogAllocs = 2,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Check all blocks for corruption on each allocation.")]
		idbgmemCheckOnAlloc = 4,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Check all blocks for corruption on each Free.")]
		idbgmemCheckOnFree = 8,

	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: action not invoked")]
		iesNoAction       = 0,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDOK, completed actions successfully")]
		iesSuccess        = 1,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDCANCEL, user terminated prematurely, resume with next action")]
		iesUserExit       = 2,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDABORT, unrecoverable error occurred")]
		iesFailure        = 3,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDRETRY, sequence suspended, resume with same action")]
		iesSuspend        = 4,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDIGNORE, skip remaining actions")]
		iesFinished       = 5,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: calling sequence error, not in executable state")]
		iesWrongState     = 6,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: invalid Action table record data")]
		iesBadActionData  = 7,

	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  initialization complete")]
		ieiSuccess             =  0,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  this engine object is already initialized")]
		ieiAlreadyInitialized  =  2,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  invalid command line syntax")]
		ieiCommandLineOption   =  3,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  an installation is already in progress")]
		ieiInstallInProgress   =  4,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  database could not be opened")]
		ieiDatabaseOpenFailed  =  5,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  incompatible database")]
		ieiDatabaseInvalid     =  6,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  installer version does not support database format")]
		ieiInstallerVersion    =  7,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not resolve source")]
		ieiSourceAbsent        =  8,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not initialize handler interface")]
		ieiHandlerInitFailed   = 10,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not open logfile in requested mode")]
		ieiLogOpenFailure      = 11,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  no acceptable language could be found")]
		ieiLanguageUnsupported = 12,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  no acceptable platform could be found")]
		ieiPlatformUnsupported = 13,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  database transform failed to merge")]
		ieiTransformFailed     = 14,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  digital signature rejected.")]
		ieiSignatureRejected   = 15,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not copy database to temp dir.")]
		ieiDatabaseCopyFailed   = 16,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not open patch package.")]
		ieiPatchPackageOpenFailed   = 17,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  patch package invalid.")]
		ieiPatchPackageInvalid   = 18,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  transform file not found.")]
		ieiTransformNotFound     = 19,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  patch package unsupported.")]
		ieiPatchPackageUnsupported   = 20,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  package rejected.")]
		ieiPackageRejected    = 21,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  product unknown.")]
		ieiProductUnknown     = 22,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  different user after reboot.")]
		ieiDiffUserAfterReboot = 23,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  product has been installed already w/ a different package")]
		ieiProductAlreadyInstalled = 24,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  can't do installations from a remote session on Hydra")]
		ieiTSRemoteInstallDisallowed = 25,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  patch cannot be applied to this product")]
		ieiNotValidPatchTarget = 26,



	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: default, full interactive UI")]
		iuiFull    = 0,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: progress and errors, no modeless dialogs (wizards)")]
		iuiReduced = 1,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: progress and errors using engine default handler")]
		iuiBasic   = 2,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: no UI")]
		iuiNone    = 3,

	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: minimum version")]
		icmrcfMinVersion    = 1,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: version")]	
	   icmrcfVersion       = 2,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: registry key")]	
	   icmrcfRegKey        = 3,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: cost")]	
	   icmrcfCost          = 4,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: File")]	
	   icmrcfFile          = 5,

} Constants;

*/

//____________________________________________________________________________
//
// MsiAuto definitions
//____________________________________________________________________________

class CAutoInstall : public CAutoBase
{
 public:
	CAutoInstall();
	~CAutoInstall();
	IUnknown& GetInterface();
	void CreateServices(CAutoArgs& args);
	void CreateEngine(CAutoArgs& args);
	void CreateHandler(CAutoArgs& args);
	void CreateMessageHandler(CAutoArgs& args);
	void CreateConfigurationManager(CAutoArgs& args);
	void CreateExecutor(CAutoArgs& args);
#ifdef CONFIGDB
	void CreateConfigurationDatabase(CAutoArgs& args);
#endif
	void OpcodeName(CAutoArgs& args);
	void ShowAsserts(CAutoArgs& args);
	void SetDBCSSimulation(CAutoArgs& args);
	void AssertNoObjects(CAutoArgs& args);
	void SetRefTracking(CAutoArgs& args);
 private:
	IMsiServices* m_piServices;
	IMsiEngine*   m_piEngine;
	IMsiHandler*  m_piHandler;
};

//____________________________________________________________________________
//
// External DLL management
//____________________________________________________________________________

struct LibLink
{
	LibLink*  pNext;
	HDLLINSTANCE hInst;
};

static LibLink* qLibLink = 0;

HDLLINSTANCE GetLibrary(const ICHAR* szLibrary)
{
	HDLLINSTANCE hInst;
	hInst = WIN::LoadLibraryEx(szLibrary,0, LOAD_WITH_ALTERED_SEARCH_PATH);
	if (hInst == 0)
	{
		ICHAR rgchBuf[MAX_PATH];
		int cchName = WIN::GetModuleFileName(g_hInstance, rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR));
		ICHAR* pch = rgchBuf + cchName;
		while (*(--pch) != chDirSep)
			;
		IStrCopy(pch+1, szLibrary);
		hInst = WIN::LoadLibraryEx(rgchBuf,0, LOAD_WITH_ALTERED_SEARCH_PATH);
		if (hInst == 0)
			return 0;
	}
	for (LibLink* pLink = qLibLink; pLink; pLink = pLink->pNext)
	{
		if (hInst == pLink->hInst)
		{
			WIN::FreeLibrary(hInst);
			return pLink->hInst;
		}
	}
	pLink = new LibLink;
	if ( ! pLink )
	{
		WIN::FreeLibrary(hInst);
		return 0;
	}
	pLink->pNext = qLibLink;
	pLink->hInst = hInst;
	qLibLink = pLink;
	return hInst;
}

void FreeLibraries()
{
	while (qLibLink)
	{
		LibLink* pLink = qLibLink;
		// should we call DllCanUnloadNow() on each DLL first?
		WIN::FreeLibrary(pLink->hInst);
		qLibLink = pLink->pNext;
		delete pLink;
	}
}

IUnknown& LoadObject(const ICHAR* szModule, const IID& riid)
{
	PDllGetClassObject fpFactory;
	IClassFactory* piClassFactory;
	IUnknown* piUnknown;
	HRESULT hrStat;
	HDLLINSTANCE hInst;
	if (!szModule || !szModule[0])  // no explicit path, use OLE to load the registered instance
	{
		IUnknown* piInstance;
		if (OLE::CoCreateInstance(riid, 0, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&piInstance) == NOERROR)
		{
			hrStat = piInstance->QueryInterface(riid, (void**)&piUnknown);
			piInstance->Release();
			if (hrStat == NOERROR)
				return *piUnknown;
		}
		throw axCreationFailed;
	}
	if ((hInst = AUT::GetLibrary(szModule)) == 0)
		throw axCreationFailed;
	fpFactory = (PDllGetClassObject)WIN::GetProcAddress(hInst, SzDllGetClassObject);
	if (!fpFactory)
		throw axCreationFailed;
	hrStat = (*fpFactory)(riid, IID_IClassFactory, (void**)&piClassFactory);
	if (hrStat != NOERROR)
		throw axCreationFailed;
	hrStat = piClassFactory->CreateInstance(0, riid, (void**)&piUnknown);
	piClassFactory->Release();
	if (hrStat != NOERROR)
		throw axCreationFailed;
	return *piUnknown;  // returns ownership of reference count
}

//____________________________________________________________________________
//
// CAutoInstall automation implementation
//____________________________________________________________________________

/*O
	[
		uuid(000C1060-0000-0000-C000-000000000046),  // IID_IMsiAuto
		helpcontext(MsiAuto_Object),helpstring("Automation object.")
	]
	dispinterface MsiAuto
	{
		properties:
		methods:
			[id(1),helpcontext(MsiAuto_CreateServices),helpstring("Loads the services library and creates an MsiServices object")]
					MsiServices* CreateServices([in] BSTR dll);
			[id(2),helpcontext(MsiAuto_CreateEngine),helpstring("Loads the engine library and creates an MsiEngine object")]
					MsiEngine* CreateEngine([in] BSTR dll);
			[id(3),helpcontext(MsiAuto_CreateHandler),helpstring("Loads the message handler library and creates an MsiHandler object")]
					MsiHandler* CreateHandler([in] BSTR dll);
			[id(4),helpcontext(MsiAuto_CreateMessageHandler),helpstring("Creates a simple MsiMessage object")]
					MsiMessage* CreateMessageHandler([in] BSTR dll);
			[id(5),helpcontext(MsiAuto_CreateConfigurationManager),helpstring("Loads the configuration manager and creates an MsiConfigurationManager object")]
					MsiConfigurationManager* CreateConfigurationManager([in] BSTR dll);
			[id(6),propget, helpcontext(MsiAuto_OpcodeName), helpstring("Return enumeration name for numeric opcode")]
					BSTR OpcodeName([in] int opcode);
			[id(7),helpcontext(MsiAuto_ShowAsserts),helpstring("In debug componente, sets asserts to show or not.")]
				    void ShowAsserts([in] long fShowAsserts);
			[id(8),helpcontext(MsiAuto_SetDBCSSimulation),helpstring("In debug services, enables DBCS using specified lead byte character.")]
				    void SetDBCSSimulation([in] int leadByte);
			[id(9),helpcontext(MsiAuto_AssertNoObjects),helpstring("In debug services, displays objects and ref count calls for those objects being tracked.")]
				    void AssertNoObjects();
			[id(10),helpcontext(MsiAuto_SetRefTracking),helpstring("In debug dlls, turns on reference count tracking for the given objects.")]
				    void SetRefTracking([in] long iid, [in] long fTrack);
			[id(11),helpcontext(MsiAuto_CreateExecutor),helpstring("Loads the engine library and creates an MsiExecute object")]
			       MsiExecute* CreateExecutor([in] BSTR dll);
#ifdef CONFIGDB
#define MsiAuto_CreateExecutor            1012
			[id(12),helpcontext(MsiAuto_CreateConfigurationDatabase),helpstring("Loads the engine library and creates an MsiConfigurationDatabase object")]
			       MsiExecute* CreateConfigurationDatabase([in] BSTR dll);
#endif
	};
*/

DispatchEntry<CAutoInstall> AutoInstallTable[] = {
	1, aafMethod, CAutoInstall::CreateServices,   TEXT("CreateServices,dll"),
	2, aafMethod, CAutoInstall::CreateEngine,     TEXT("CreateEngine,dll"),
	3, aafMethod, CAutoInstall::CreateHandler,    TEXT("CreateHandler,dll"),
	4, aafMethod, CAutoInstall::CreateMessageHandler,  TEXT("CreateMessageHandler,dll"),
	5, aafMethod, CAutoInstall::CreateConfigurationManager,  TEXT("CreateConfigurationManager,dll"),
	6, aafPropRO, CAutoInstall::OpcodeName,       TEXT("OpcodeName,opcode"),
	7, aafMethod, CAutoInstall::ShowAsserts,      TEXT("ShowAsserts,fShowAsserts"),
	8, aafMethod, CAutoInstall::SetDBCSSimulation,TEXT("SetDBCSSimulation,leadByte"),
	9, aafMethod, CAutoInstall::AssertNoObjects,  TEXT("AssertNoObjects"),
	10,aafMethod, CAutoInstall::SetRefTracking,   TEXT("SetRefTracking,iid,fTrack"),
	11,aafMethod, CAutoInstall::CreateExecutor,   TEXT("CreateExecutor,dll"),
#ifdef CONFIGDB
	12,aafMethod, CAutoInstall::CreateConfigurationDatabase, TEXT("CreateConfigurationDatabase,dll"),
#endif
};
const int AutoInstallCount = sizeof(AutoInstallTable)/sizeof(DispatchEntryBase);

IUnknown* CreateAutomation()
{
	return new CAutoInstall();
}

CAutoInstall::CAutoInstall()
 : CAutoBase(*AutoInstallTable, AutoInstallCount),
	m_piServices(0), m_piEngine(0), m_piHandler(0)
{
	g_cInstances++;
}

CAutoInstall::~CAutoInstall()
{
	if (m_piEngine)
		m_piEngine->Release();
	if (m_piHandler)
		m_piHandler->Release();
	if (m_piServices)
	{
		m_piServices->ClearAllCaches();
		m_piServices->Release();
	}
	g_cInstances--;
}

IUnknown& CAutoInstall::GetInterface()
{
	return g_NullInterface;  // no installer interface available
}

void CAutoInstall::CreateServices(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	if (m_piServices)
		m_piServices->Release();
	m_piServices = &(IMsiServices&)AUT::LoadObject(szName, CLSID_IMsiServices);
	m_piServices->AddRef();
	args = AUT::CreateAutoServices(*m_piServices);
//	InitializeAssert(m_piServices);
}

void CAutoInstall::CreateEngine(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	if (m_piEngine)
		m_piEngine->Release();
	m_piEngine = &(IMsiEngine&)AUT::LoadObject(szName, CLSID_IMsiEngine);
	m_piEngine->AddRef();
	args = AUT::CreateAutoEngine(*m_piEngine);
}

void CAutoInstall::CreateExecutor(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	IMsiExecute& riExecute = (IMsiExecute&)AUT::LoadObject(szName, CLSID_IMsiExecute);
	args = AUT::CreateAutoExecute(riExecute);
}

#ifdef CONFIGDB
class IMsiConfigurationDatabase;
IDispatch* CreateAutoConfigurationDatabase(IMsiConfigurationDatabase& riExecute); // in autosrv.cpp

void CAutoInstall::CreateConfigurationDatabase(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	IMsiConfigurationDatabase& riConfigDatabase = (IMsiConfigurationDatabase&)AUT::LoadObject(szName, CLSID_IMsiConfigurationDatabase);
	args = AUT::CreateAutoConfigurationDatabase(riConfigDatabase);
}
#endif

void CAutoInstall::CreateHandler(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	if (m_piHandler)
		m_piHandler->Release();
	m_piHandler = &(IMsiHandler&)AUT::LoadObject(szName, CLSID_IMsiHandler);
	m_piHandler->AddRef();
	args = AUT::CreateAutoHandler(*m_piHandler);
}

void CAutoInstall::CreateMessageHandler(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	IMsiMessage& riMessage = (IMsiMessage&)AUT::LoadObject(szName, CLSID_IMsiMessage);
	args = AUT::CreateAutoMessage(riMessage);
}

void CAutoInstall::CreateConfigurationManager(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
// The following would be used if the ConfigurationManager is a separate module
//	if (m_piConfigurationManager)
//		m_piConfigurationManager->Release();
//	m_piConfigurationManager = &(IMsiConfigurationManager&)AUT::LoadObject(szName, IID_IMsiConfigurationManager);
//	m_piConfigurationManager->AddRef();
//	args = AUT::CreateAutoConfigurationManager(*m_piConfigurationManager);
	IMsiConfigurationManager* piConfigurationManager = &(IMsiConfigurationManager&)AUT::LoadObject(szName, CLSID_IMsiConfigurationManager);
	args = AUT::CreateAutoConfigurationManager(*piConfigurationManager);
}

void CAutoInstall::ShowAsserts(CAutoArgs& args)
{
	Bool fShowAsserts = Bool(args[1]) ? fFalse : fTrue;  // invert logic
	IMsiDebug *piDebug;

	if (m_piEngine)
	{
		if (m_piEngine->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetAssertFlag(fShowAsserts);
			piDebug->Release();
		}
	}
	
	if (m_piServices)
	{
		if (m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetAssertFlag(fShowAsserts);
			piDebug->Release();
		}
	}

	if (m_piHandler)
	{
		if (m_piHandler->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetAssertFlag(fShowAsserts);
			piDebug->Release();
		}
	}
}

void CAutoInstall::SetDBCSSimulation(CAutoArgs& args)
{
	int chLeadByte = args[1];
	IMsiDebug *piDebug;
	if (m_piServices && m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
	{
		piDebug->SetDBCSSimulation((char)chLeadByte);
		piDebug->Release();
	}
}

void CAutoInstall::AssertNoObjects(CAutoArgs& /* args */)
{
	IMsiDebug *piDebug;
	Bool fServices = fFalse;
	
	if (m_piServices)
	{
		if (m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			fServices = fTrue;
			piDebug->AssertNoObjects();
			piDebug->Release();
		}
	}

	if (m_piEngine)
	{
		if (m_piEngine->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->AssertNoObjects();
			piDebug->Release();
		}

		// If we don't have a services object in the auto object, try the
		// one in the engine object
		if (!fServices)
		{
			IMsiServices* piServices;
			piServices = m_piEngine->GetServices();
			if (piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
			{
				fServices = fTrue;
				piDebug->AssertNoObjects();
				piDebug->Release();
			}
			piServices->Release();
		}
		
	}
	
	if (m_piHandler)
	{
		if (m_piHandler->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->AssertNoObjects();
			piDebug->Release();
		}
	}
}

void CAutoInstall::SetRefTracking(CAutoArgs& args)
{
	IMsiDebug *piDebug;
	Bool fServices = fFalse;
	long iid = args[1];
	Bool fTrack = args[2];
	
	if (m_piServices)
	{
		if (m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			fServices = fTrue;
			piDebug->SetRefTracking(iid, fTrack);
			piDebug->Release();
		}
	}

	if (m_piEngine)
	{
		if (m_piEngine->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetRefTracking(iid, fTrack);
			piDebug->Release();
		}

		// If we don't have a services object in the auto object, try the
		// one in the engine object
		if (!fServices)
		{
			IMsiServices* piServices;
			piServices = m_piEngine->GetServices();
			if (piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
			{
				fServices = fTrue;
				piDebug->SetRefTracking(iid, fTrack);
				piDebug->Release();
			}
			piServices->Release();
		}
		
	}
	
	if (m_piHandler)
	{
		if (m_piHandler->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetRefTracking(iid, fTrack);
			piDebug->Release();
		}
	}
}

const ICHAR* const rgszOpcode[] = 
{
#define MSIXO(op,type,args) TEXT("ixo") TEXT(#op),
#include "opcodes.h"
};
void CAutoInstall::OpcodeName(CAutoArgs& args)
{
	unsigned int iOpcode = args[1];
	if (iOpcode >= sizeof(rgszOpcode)/sizeof(ICHAR*))
		throw MsiAuto_OpcodeName;
	args = rgszOpcode[iOpcode];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\auto\make.inc ===
!INCLUDE ..\..\MsiMake.inc

AutoRes:$(AUTO_OBJDIR)\msiauto.hh \
        $(AUTO_OBJDIR)\auto.res \
	$(BUILD_COMMONDIR)\msiauto.hlp \
	$(BUILD_COMMONDIR)\msiauto.cnt \
	$(BUILD_COMMONDIR)\msitool.hlp \
	$(BUILD_COMMONDIR)\msitool.cnt \
	$(BUILD_COMMONDIR)\cabinet.dll
        
$(AUTO_OBJDIR)\auto.res: $(AUTO_DIR)\auto.rc $(INC_DIR)\version.h $(AUTO_OBJDIR)\msiauto.tlb
	rc $(C_DEFINES) -D_RC32 -Fo$*.res /I$(INC_DIR) /I$(SDK_INC_PATH) /I$(RES_OBJDIR) /I$(AUTO_OBJDIR) $(AUTO_DIR)\auto.rc

$(AUTO_OBJDIR)\msiauto.tlb : $(AUTO_OBJDIR)\msi.odl $(AUTO_OBJDIR)\msiauto.hh
#	mktyplib $(C_DEFINES) /tlb $@ /I$(INC_DIR) /I$(AUTO_OBJDIR) /w0 
	midl -char unsigned -ms_ext -c_ext $(C_DEFINES) -D__MKTYPLIB__  -tlb $@ /I$(INC_DIR) /I$(AUTO_OBJDIR) /I$(SDK_INC_PATH) -cpp_cmd $(MIDL_CPP) -mktyplib203 $(AUTO_OBJDIR)\msi.odl

ODLSRC = $(AUTO_DIR)\autocom.cpp $(AUTO_DIR)\autosrv.cpp

$(AUTO_OBJDIR)\msi.odl : $(ODLSRC)  
	makeodl.exe $(AUTO_OBJDIR)\msi.odl $(ODLSRC)

$(AUTO_OBJDIR)\msiauto.hh: $(HELP_DIR)\msiauto.hh $(INC_DIR)\opcodes.h
	cl /EP /TC $(INC_DIR)\opcodes.h > $(AUTO_OBJDIR)\opcodes.tmp
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genhh.prl $(HELP_DIR)\msiauto.hh $(AUTO_OBJDIR)\opcodes.tmp > $@
	@del $(AUTO_OBJDIR)\opcodes.tmp

HELPAUTO =  $(HELP_DIR)\general.rtf \
				$(HELP_DIR)\objects.rtf \
				$(HELP_DIR)\services.rtf $(HELP_DIR)\database.rtf \
				$(HELP_DIR)\property.rtf \
				$(HELP_DIR)\handler.rtf $(HELP_DIR)\author.rtf \
				$(HELP_DIR)\path.rtf $(HELP_DIR)\suminfo.rtf\
				$(HELP_DIR)\transfrm.rtf $(HELP_DIR)\conman.rtf \
				$(HELP_DIR)\server.rtf \
				$(AUTO_OBJDIR)\errors.rtf

$(BUILD_COMMONDIR)\msiauto.hlp: $(HELP_DIR)\msiauto.hpj $(HELPAUTO) $(AUTO_OBJDIR)\msiauto.hh
	echo !@copy $** $(BUILD_COMMONDIR)
	!@copy $** $(BUILD_COMMONDIR)
	$(TOOLS_DIR)\echotmpl $(INC_DIR)\helpver.tpl $(INC_DIR)\version.h $(INC_DIR)\version.h > $(BUILD_COMMONDIR)\helpver.h
	hcrtf -o $@ -xn $(BUILD_COMMONDIR)\msiauto.hpj
	@type $(BUILD_COMMONDIR)\msiauto.err
	@del $(BUILD_COMMONDIR)\helpver.h
	@del $(BUILD_COMMONDIR)\*.hpj 
	@del $(BUILD_COMMONDIR)\*.rtf 
	@del $(BUILD_COMMONDIR)\*.hh
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msiauto.err
	@del $(BUILD_COMMONDIR)\msiauto.err

$(BUILD_COMMONDIR)\msiauto.cnt: $(HELP_DIR)\msiauto.cnt
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msiauto.err
	echo copy $** $@
	copy $** $@

$(AUTO_OBJDIR)\errors.rtf : 
	mkerrtbl.exe $@

HELPTOOL =  $(HELP_DIR)\msitool.rtf

$(BUILD_COMMONDIR)\msitool.hlp:: $(HELP_DIR)\msitool.hpj $(HELPTOOL) $(HELP_DIR)\msispy.hh
	echo !@copy $** $(BUILD_COMMONDIR)
	!@copy $** $(BUILD_COMMONDIR)
	$(TOOLS_DIR)\echotmpl $(INC_DIR)\helpver.tpl $(INC_DIR)\version.h $(INC_DIR)\version.h > $(BUILD_COMMONDIR)\helpver.h
	hcrtf -o $@ -xn $(BUILD_COMMONDIR)\msitool.hpj
	@del $(BUILD_COMMONDIR)\helpver.*
	@type $(BUILD_COMMONDIR)\msitool.err
	@del $(BUILD_COMMONDIR)\*.hpj 
	@del $(BUILD_COMMONDIR)\*.rtf 
	@del $(BUILD_COMMONDIR)\*.hh
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msitool.err
	@del $(BUILD_COMMONDIR)\msitool.err

$(BUILD_COMMONDIR)\msitool.cnt: $(HELP_DIR)\msitool.cnt
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msitool.err
	echo copy $** $@
	copy $** $@

$(BUILD_COMMONDIR)\cabinet.dll:
	copy $(TOOLS_DIR)\cabinet.dll $(BUILD_COMMONDIR)\cabinet.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\action.cpp ===
/* action.cpp - action and message processing
   Copyright  1997 - 1999 Microsoft Corporation
____________________________________________________________________________*/

#include "precomp.h"
#include "_engine.h"
#include "_msiutil.h"  // CreateAndRunEngine
#include "_msinst.h"
#include "_srcmgmt.h"
#include "_camgr.h"
#include "resource.h"
#include "eventlog.h"
#include "version.h"  // rmj, rmm, rup, rin
#include "imagehlp.h"
#include "_autoapi.h"

#define MsiHiddenWindowClass            TEXT("MsiHiddenWindow")

const GUID IID_IMsiHandler      = GUID_IID_IMsiHandler;
#ifdef DEBUG
const GUID IID_IMsiHandlerDebug = GUID_IID_IMsiHandlerDebug;
#endif //DEBUG


const int iDebugLogMessage = WM_USER+123;

int g_cFlushLines = 0;

class CMsiConfigurationManager;
extern iesEnum InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
extern Bool IsTerminalServerInstalled();

// global functions callable from services and engine
bool   CreateLog(const ICHAR* szFile, bool fAppend);
bool   LoggingEnabled();
bool   WriteLog(const ICHAR* szText);
void   HandleOutOfMemory();  // global function called by memory manager
void   MsiDisableTimeout()      { g_MessageContext.DisableTimeout(); }
void   MsiEnableTimeout()       { g_MessageContext.EnableTimeout(); }
void   MsiSuppressTimeout()     { g_MessageContext.SuppressTimeout(); }
HANDLE GetUserToken()           { return g_MessageContext.GetUserToken();}

// local functions defined in this module
UINT CloseMsiHandle(MSIHANDLE hAny, DWORD dwThreadId);
HINSTANCE MsiLoadLibrary(const ICHAR* szModuleName, Bool fDataOnly = fFalse);
bool LogRecord(IMsiRecord& riRecord);
void CopyStreamToString(IMsiStream& riStream, const IMsiString*& rpistrData); // assume file has ANSI data

typedef DWORD   (__stdcall *PThreadEntry)(void*);


//____________________________________________________________________________
//
// CBasicUI definition - internal default message handler, static non-COM object
//____________________________________________________________________________

const int cchMaxCaption       = 255;

class CBasicUI
{
 public:  // external methods
	imsEnum  Message(imtEnum imt, IMsiRecord& riRecord);
	imsEnum  FatalError(imtEnum imt, const ICHAR* szMessage);
	void     SetUserCancel(bool fCancel);
	bool     Initialize(HWND hwndParent, bool fQuiet, bool fHideDialog,
							bool fNoModalDialogs, bool fHideCancel, bool fUseUninstallBannerText, 
							bool fSourceResOnly);
	bool     Terminate();
	bool     IsInitialized();
	bool     SetCancelButtonText();
	bool     Quiet();
	bool     SourceResolutionDialogOnly();
	const ICHAR* GetCaption();
	void     SetDefaultCaption();
	HWND     GetWindow() { return m_hProgress ? m_hProgress : m_hwndParent; }
	LANGID   GetPackageLanguage();
	UINT     GetPackageCodepage();
	bool     Mirrored(UINT uiCodepage);
 private: // internal methods
	bool     CheckDialog();
	bool     CreateProgressDialog(int idDlg);
	imsEnum  SetProgressData(int iControl, const ICHAR* szData, bool fCheckDialog);
	imsEnum  SetProgressGauge(int iControl, int cSoFar, int cTotal);
	imsEnum  SetProgressTimeRemaining(IMsiRecord& riRecord);
	imsEnum  SetScriptInProgress(Bool fSet);
	imsEnum  FilesInUseDialog(IMsiRecord* piRecord);
 public:
	CBasicUI();
 protected:
	HFONT    m_hButtonFont;     // non-zero if font created
	UINT     m_iButtonCodepage; // codepage of last button font update
	HFONT    m_hTextFont;       // non-zero if font created
	UINT     m_iTextCodepage;   // codepage of last text font update
	UINT     m_iPackageLanguage; // lauguage of database strings
	UINT     m_iPackageCodepage; // codepage of database strings
 private:
	bool     m_fInitialized;
	bool     m_fProgressByData;
	int      m_iPerTick;
	int      m_iProgress;
	int      m_iProgressTotal;
	unsigned int m_uiStartTime;
	unsigned int m_uiLastReportTime;
	ICHAR    m_szCaption[cchMaxCaption+1];
	bool     m_fCaptionChanged;
	bool     m_fUserCancel; // the user hit the Cancel button on the minimal UI
	bool     m_fCancelVisible;
	bool     m_fNeverShowCancel;
	bool     m_fWindowVisible;
	bool     m_fQuiet;
	bool     m_fSourceResolutionOnly;
	bool     m_fHideDialog;
	bool     m_fNoModalDialogs;
	bool     m_fBiDi;      // right-to-left language, Arabic or Hebrew
	bool     m_fMirrored;  // mirroring change (only happens on Win2K and above, mirroring occurs with RTL languages)
	UINT     m_uiBannerText; // banner text for "preparing to <install|remove>..."
	HWND     m_hwndParent;
	HWND     m_hProgress;  // progress dialog handle
	int              m_cSoFarPrev;
	int              m_cTotalPrev;
	ProgressData::ipdEnum m_ipdDirection;
	ProgressData::ietEnum  m_ietEventType;
	IMsiRecord* m_piFilesInUseRecord;
};
inline bool CBasicUI::IsInitialized() {return m_fInitialized;}
inline bool CBasicUI::Quiet() {return m_fQuiet;}
inline bool CBasicUI::SourceResolutionDialogOnly() {return m_fSourceResolutionOnly;}
inline LANGID CBasicUI::GetPackageLanguage() {return (LANGID)m_iPackageLanguage;}
inline UINT   CBasicUI::GetPackageCodepage() {return m_iPackageCodepage;}

//____________________________________________________________________________
//
// CFilesInUseDialog definition
//____________________________________________________________________________

class CFilesInUseDialog : public CMsiMessageBox
{
 public:
	CFilesInUseDialog(const ICHAR* szMessage, const ICHAR* szCaption, IMsiRecord& m_riFileList);
   ~CFilesInUseDialog();
 private:
	bool InitSpecial();
	IMsiRecord&   m_riFileList;
	HFONT         m_hfontList;
};

//____________________________________________________________________________
//
// Message dispatching and processing, external to engine
//____________________________________________________________________________

// messages logged before UI called
const int iPreLogMask  = 1 << (imtInfo           >> imtShiftCount)
							  | 1 << (imtFatalExit      >> imtShiftCount)
							  | 1 << (imtActionStart    >> imtShiftCount)
							  | 1 << (imtActionData     >> imtShiftCount)
							  | 1 << (imtActionData     >> imtShiftCount);

// messages logged after UI called
const int iPostLogMask = 1 << (imtWarning        >> imtShiftCount)
							  | 1 << (imtError          >> imtShiftCount)
							  | 1 << (imtUser           >> imtShiftCount)
							  | 1 << (imtOutOfDiskSpace >> imtShiftCount);

// messages never sent to UI
const int iNoUIMask    = 1 << (imtInfo           >> imtShiftCount);

// messages requiring format string
const int iFormatMask  = 1 << (imtActionStart    >> imtShiftCount)
							  | 1 << (imtActionData     >> imtShiftCount);

// messages written to log
const int iLogMessages     = (1<<(imtFatalExit     >>imtShiftCount))
									+ (1<<(imtError         >>imtShiftCount))
									+ (1<<(imtWarning       >>imtShiftCount))
									+ (1<<(imtUser          >>imtShiftCount))
									+ (1<<(imtInfo          >>imtShiftCount))
									+ (1<<(imtCommonData    >>imtShiftCount))
									+ (1<<(imtActionStart   >>imtShiftCount))
									+ (1<<(imtActionData    >>imtShiftCount))
									+ (1<<(imtOutOfDiskSpace>>imtShiftCount));
									//  no imtProgress

// messages handled by dispatcher, all except for internal functions
const int iDispatchMessages= (1<<(imtFatalExit     >>imtShiftCount))
									+ (1<<(imtError         >>imtShiftCount))
									+ (1<<(imtWarning       >>imtShiftCount))
									+ (1<<(imtUser          >>imtShiftCount))
									+ (1<<(imtInfo          >>imtShiftCount))
									+ (1<<(imtFilesInUse    >>imtShiftCount))
									+ (1<<(imtCommonData    >>imtShiftCount))
									+ (1<<(imtActionStart   >>imtShiftCount))
									+ (1<<(imtActionData    >>imtShiftCount))
									+ (1<<(imtOutOfDiskSpace>>imtShiftCount))
									+ (1<<(imtProgress      >>imtShiftCount))
									+ (1<<(imtResolveSource >>imtShiftCount));

// messages which can set the cancel state
const int iSetCancelState  = (1<<(imtActionStart   >>imtShiftCount))
									+ (1<<(imtActionData    >>imtShiftCount))
									+ (1<<(imtProgress      >>imtShiftCount));

// messages which can reset the cancel state
const int iResetCancelState= (1<<(imtFatalExit     >>imtShiftCount))
									+ (1<<(imtError         >>imtShiftCount))
									+ (1<<(imtWarning       >>imtShiftCount))
									+ (1<<(imtUser          >>imtShiftCount))
									+ (1<<(imtFilesInUse    >>imtShiftCount))
									+ (1<<(imtOutOfDiskSpace>>imtShiftCount))
									+ (1<<(imtResolveSource >>imtShiftCount));

// message type codes used by fatal error messages, must all be unique, used to retrieve text

const int imtFatalOutOfMemory = imtInternalExit + imtOk + imtDefault1 + imtIconWarning;
const int imtFatalTimedOut    = imtInternalExit + imtRetryCancel + imtDefault2 + imtIconQuestion;
const int imtFatalException   = imtInternalExit + imtOk + imtDefault1 + imtIconError;
const int imtExceptionInfo    = imtInternalExit + imtOk + imtDefault1 + imtIconInfo;
const int imtDumpProperties   = imtInternalExit + imtYesNo;
const int imtExitThread       = imtInternalExit + imtRetryCancel + imtDefault2 + imtIconWarning;

const int imtForceLogInfo     = imtInfo + imtIconError;
const int iLogPropertyDump = (1 << (imtProgress>>imtShiftCount)); // no log progress info, use bit for property dump

// global, per-process  message handling objects
CBasicUI              g_BasicUI;         // simple UI handler
MsiUIMessageContext   g_MessageContext;  // message dispatcher/processor
extern IMsiRecord*    g_piNullRecord;
extern CMsiAPIMessage g_message;         // external UI handling/configuration
extern Bool    g_fLogAppend;
extern bool    g_fFlushEachLine;
CAPITempBufferStatic<ICHAR, 64>  g_szTimeRemaining;
CAPITempBufferStatic<ICHAR, 256> g_szFatalOutOfMemory;
CAPITempBufferStatic<ICHAR, 256> g_szFatalTimedOut;
CAPITempBufferStatic<ICHAR, 128> g_szFatalException;
CAPITempBufferStatic<ICHAR, 128> g_szBannerText;
CAPITempBufferStatic<ICHAR, 128> g_szScriptInProgress;
#ifndef FAST_BUT_UNDOCUMENTED
CAPITempBufferStatic<WCHAR, 4096> g_rgchEnvironment; //?? is this initial value reasonable?
#endif

extern CRITICAL_SECTION vcsHeap;
CActionThreadData* g_pActionThreadHead = 0;  // linked list of custom action threads

const int iWaitTick    = 50;  // event loop wait before UI refresh, in msec
const int cRetryLimit  = 10;  // number of timeout retries in quiet mode
int g_cWaitTimeout     =  0;  // default value is 20*iDefaultWaitTimeoutPolicy in msinst.cpp


CRITICAL_SECTION CProductContextCache::g_csCacheCriticalSection;
CAPITempBufferStatic<sProductContext ,20> CProductContextCache::g_rgProductContext;
int CProductContextCache::g_cProductCacheCount = 0;
#ifdef DEBUG
bool CProductContextCache::g_fInitialized = false;
#endif


IMsiRecord* MsiUIMessageContext::GetNoDataRecord()
{
	if (!m_pirecNoData)  // must delay creation until after allocator initialized
		m_pirecNoData = &ENG::CreateRecord(0);
	return m_pirecNoData;
}

//!! temp routine to determine if debugger is running the process, until we figure out how to do it right
bool IsDebuggerRunning()
{
	static int fDebuggerPresent = 2;
	if (g_fWin9X)
		return false;  // how do we tell?
	if (fDebuggerPresent == 2)
	{
		fDebuggerPresent = false;
		HINSTANCE hLib = WIN::LoadLibrary(TEXT("KERNEL32"));
		FARPROC pfEntry = WIN::GetProcAddress(hLib, "IsDebuggerPresent");  // NT only
		if (pfEntry)
			fDebuggerPresent = (int)(INT_PTR)(*pfEntry)();                  //--merced: added (INT_PTR)
	}
	return *(bool*)&fDebuggerPresent;
}

void  HandleOutOfMemory()  // global function called by memory manager
{
	imsEnum ims = g_MessageContext.Invoke(imtEnum(imtFatalOutOfMemory), 0);
	// extremely small window where this could possibly get blocked by EnterCriticalSection?
	if (ims == imsNone)
		RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
	return;
}

void MsiUIMessageContext::LogDebugMessage(const ICHAR* szMessage)
{
	if (!m_hwndDebugLog)
		return;

	#define MAX_ATOM_TRIES 4
	const int MAX_ATOM_LEN=255;  // maximum allowed by GlobalAddAtom

	const ICHAR* pchMessage = szMessage;

	int iLen = IStrLen(szMessage);

	ATOM atom;
	int cTries = 0;

	ICHAR rgchTemp[MAX_ATOM_LEN+1];
	const ICHAR *pchOutput = 0;
	do {

		if (iLen > MAX_ATOM_LEN)
		{
			IStrCopyLen(rgchTemp, pchMessage, MAX_ATOM_LEN);
			iLen -= MAX_ATOM_LEN;
			pchMessage += MAX_ATOM_LEN;
			pchOutput = rgchTemp;

		}
		else
		{
			pchOutput = pchMessage;
			iLen = 0;
		}

		cTries = 0;
		do
		{
			atom = WIN::GlobalAddAtom(pchOutput);

			if (atom == 0)
			{       // Bug 7196: No more atoms left (there's a max of 37 in the GlobalAtom table).  We'll
				// sleep for a bit to allow our other thread time to retrieve our messages and free
				// up some table space.
				Sleep(100);
				cTries++;
			}
		} while (atom == 0 && cTries < MAX_ATOM_TRIES);
		WIN::PostMessage(m_hwndDebugLog, iDebugLogMessage, (WPARAM)atom, (LPARAM)0);

	} while (iLen > 0);
}


imsEnum MsiUIMessageContext::Invoke(imtEnum imt, IMsiRecord* piRecord)  // no memory allocation in this function!
{
	if(!IsInitialized())
		return imsNone;

	if (GetTestFlag('T'))
		return ProcessMessage(imt, piRecord);
	DWORD dwCurrentThread = WIN::GetCurrentThreadId();
	if (dwCurrentThread == m_tidUIHandler)  //  calling from UI thread, allowed reentrancy, already in critical section
	{
		// However, progress messages from the UI thread are not allowed
		if (imtEnum(imt & ~(iInternalFlags)) == imtProgress)
			return imsNone;
		return ProcessMessage(imt, piRecord);
	}
	else if (MsiGetCurrentThreadId() == m_tidDisableMessages) // we're disabling messages for this thread; don't process this message
		return imsNone;

	WIN::EnterCriticalSection(&m_csDispatch);
	imsEnum imsReturn;
	if (m_pirecMessage)  m_pirecMessage->Release();  // should never happen
	m_imtMessage   = imt;
	if ((m_pirecMessage = piRecord) != 0) piRecord->AddRef();
	m_imsReturn    = imsInvalid;  // check for bogus event trigger
	WIN::SetEvent(m_hUIRequest);
	for (;;)   // event loop waiting on UI thread
	{
		DWORD dwWait = WIN::MsgWaitForMultipleObjects(1, &m_hUIReturn,
																	 FALSE, 30000, QS_ALLINPUT);
		if (dwWait == WAIT_OBJECT_0 + 1)  // window Msg
		{
			MSG msg;
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				WIN::TranslateMessage(&msg);
				WIN::DispatchMessage(&msg);
			}
			continue;
		}
		if (dwWait == WAIT_FAILED)
		{
			AssertSz(0, "Wait Failed in Invoke");
			imsReturn = imsError;
			break;
		}
		if (dwWait == WAIT_TIMEOUT)
		{
			DEBUGMSG("Invoke wait timed out");
			continue;
		}
		if (m_imsReturn == imsInvalid || m_imsReturn == imsBusy)
		{
			DEBUGMSG("Invalid event trigger in Invoke"); //!!# temp for debug
			continue;
		}
		Assert(dwWait == WAIT_OBJECT_0);
		imsReturn = m_imsReturn;
		break;
	} // end event wait loop
	if (m_pirecMessage) m_pirecMessage->Release(), m_pirecMessage = 0;
	if (dwCurrentThread != m_tidUIHandler)
		WIN::LeaveCriticalSection(&m_csDispatch);
	return imsReturn;
}

#ifdef PROFILE
DWORD MyWaitForMultipleObjects(int count, HANDLE * ph, int flag, int iWait)
{
	DWORD dwWait = WIN::WaitForMultipleObjects(count, ph, flag, iWait);

	return dwWait;
}
#endif //PROFILE

/*static*/ DWORD WINAPI MsiUIMessageContext::ChildUIThread(MsiUIMessageContext* This)  // runs only in UI thread
{
	if (This->m_iuiLevel == iuiNextEnum)  // UIPreview, FullUI, no Basic UI
		This->m_iuiLevel = iuiFull;     // must do this in UI thread
	else
	{
		bool fQuiet =  This->m_iuiLevel == iuiNone ||
							This->m_iuiLevel == iuiDefault;

		if(!g_BasicUI.Initialize(g_message.m_hwnd, fQuiet, This->m_fHideBasicUI,
										 This->m_fNoModalDialogs, This->m_fHideCancel, This->m_fUseUninstallBannerText,
										 This->m_fSourceResolutionOnly))
		{
			return ERROR_CREATE_FAILED; //!! what error?
		}
	}

	// initialize OLE on this thread
	if (false == This->m_fChildUIOleInitialized && SUCCEEDED(OLE32::CoInitialize(0)))
	{
		This->m_fChildUIOleInitialized = true;
	}

	int cTicks = 0;
	bool fContinue = true;
	while(fContinue)  // thread loops until main thread exits
	{
		DWORD dwWait = WIN::WaitForSingleObject(This->m_hUIRequest, iWaitTick);
		if (dwWait == WAIT_FAILED)
		{
			AssertSz(0, "Wait Failed in ChildUIThread");
			return WIN::GetLastError();
		}
		if (dwWait == WAIT_TIMEOUT)  // main engine thread is hung
		{
			if (This->m_piClientMessage == 0)  // not remote UI
				This->ProcessMessage(imtProgress, g_piNullRecord);  // refresh UI
			if (This->m_cTimeoutDisable != 0)
				continue;
			if (++cTicks < g_cWaitTimeout)
				continue;
			DEBUGMSG("ChildUIThread wait timed out");
			//!! should we do anything here, as main thread is calling thread?
			cTicks = 0;
			continue;
		}
		cTicks = 0;

		// else we were signaled with a message request
		if (This->m_imtMessage == imtInvalid)
		{
			DEBUGMSG("Invalid event trigger in ChildUIThread"); //!!# temp for debug
			continue;
		}
		else if(This->m_imtMessage == imtExitThread)
		{
			if(g_BasicUI.IsInitialized())
				g_BasicUI.Terminate();

			// uninitialize COM if necessary
			if (true == This->m_fChildUIOleInitialized)
			{
				OLE32::CoUninitialize();
				This->m_fChildUIOleInitialized = false;
			}

			This->m_imsReturn = imsNone;
			fContinue = false; // end of thread
		}
		else
		{
			Assert(!This->m_piClientMessage); // only here if called through MsiOpenProduct/Package
			This->m_imsReturn = imsBusy;      // to indicate processing in UI thread
			This->m_imsReturn = This->ProcessMessage(This->m_imtMessage,
														This->m_pirecMessage);
			This->m_imtMessage = imtInvalid;  // to detect invalid event triggers
		}
		WIN::SetEvent(This->m_hUIReturn);
	} // end message wait/process loop
	return NOERROR;
}

// Message processing and routing to external UI, handler, basic UI, and log
// Only called within UI thread, reentrant only for calls from the UI handler
// Due to reentrancy (from UI thread), m_imtMessage, m_piMessage, and m_imsReturn are be accessed

imsEnum MsiUIMessageContext::ProcessMessage(imtEnum imt, IMsiRecord* piRecord)
{
	int iSuppressLog = imt & imtSuppressLog;
	int iForceQuietMessage = imt & imtForceQuietMessage;
	imt = imtEnum(imt & ~(iInternalFlags));
	imsEnum imsReturn = imsNone;
	int imsg = (unsigned)imt >> imtShiftCount;  // message header message
	int fMask = 1 << imsg;
	if (fMask & iDispatchMessages)  // messages for UI and/or Log
	{
		if (m_fCancelPending && (fMask & iResetCancelState)) // cancel button pushed before modal dialog
		{
			m_fCancelPending = false;
			if (imt & 1)  // MB_OKCANCEL, MB_YESNOCANCEL, MB_RETRYCANCEL have low bit set, no others do
				return imsCancel;  // caller expected to process since cancel button appears
		}

		if (!piRecord)
			piRecord = GetNoDataRecord();  // dummy record in case none passed in

		if (m_piClientMessage)   // running on server, must forward messages to client
			return m_piClientMessage->Message(imtEnum(imt|iForceQuietMessage), *piRecord);

		if(iForceQuietMessage)
		{
			if(m_iuiLevel == iuiNone || m_iuiLevel == iuiBasic)
				return g_BasicUI.Message(imtEnum(imt|imtForceQuietMessage), *piRecord);
			else
				return imsNone;
		}

		if((imsg == (imtError >> imtShiftCount) || imsg == (imtWarning >> imtShiftCount))
			 && LoggingEnabled() == false)
		{
			// error or warning and no log - create a log on the fly
			InitializeLog(true); // ignore error
		}

		if ((iPreLogMask & fMask) && !iSuppressLog)  //!!?  && !piRecord->IsNull(0))
		{
			if ((g_dwLogMode & fMask) || (imt == imtForceLogInfo))
				ENG::LogRecord(*piRecord);
		}

		if ((g_message.m_iMessageFilter & fMask) && !((fMask & iFormatMask) && piRecord->IsNull(0)))
		{
			imsReturn = g_message.Message(imt, *piRecord);
		}

		if ((((!g_BasicUI.Quiet() && imsReturn == imsNone) || imsg == (imtCommonData >> imtShiftCount))  // external UI handled it, or it's CommonData
			|| (g_BasicUI.SourceResolutionDialogOnly() && (imsg == (imtResolveSource >> imtShiftCount)) && (imsReturn == imsNone))) // or resolve source and the sourceresonly flag
		 && !((fMask & iFormatMask) && piRecord->IsNull(0))) // missing required format template
		{
			if (m_piHandler)
				imsReturn = m_piHandler->Message(imt, *piRecord);

			if (imsReturn == imsNone || imsg == (imtCommonData >> imtShiftCount)) // always send CommonData to BasicUI
				imsReturn = g_BasicUI.Message(imt, *piRecord);
		}

		if ((iPostLogMask & fMask & g_dwLogMode) && !iSuppressLog)  //!!?  && !piRecord->IsNull(0))
		{
			ENG::LogRecord(*piRecord);
		}
		if (fMask & iSetCancelState)  // progress notification - process cancel state
		{
			if (m_fCancelPending)
				imsReturn = imsCancel, m_fCancelPending = false;  // return and clear cached cancel
#ifdef DEBUG
			if (imsReturn == imsCancel && piRecord != g_piNullRecord)
				m_fCancelReturned = true;  // save for possible assert at exit
#endif
		}  // if called from UI timer, m_fCancelPending will immediately get set again
	}
	else if (m_piClientMessage)   // running on server, must forward requests to client
	{
		switch(imsg)
		{
		case imtInternalExit   >> imtShiftCount:  // can't use allocated memory here
			switch (imt)
			{
			case imtExceptionInfo:
				{
					ICHAR rgchSerializedRecord[sizeof(m_rgchExceptionInfo)/sizeof(ICHAR)];
					unsigned int cchExceptionInfo = SerializeStringIntoRecordStream(m_rgchExceptionInfo, rgchSerializedRecord, sizeof(rgchSerializedRecord)/sizeof(ICHAR));
					m_rgchExceptionInfo[0] = 0; // reset string to empty
					if (cchExceptionInfo)
					{
						HRESULT hres = IMsiMessage_MessageRemote_Proxy(m_piClientMessage, imt, cchExceptionInfo*sizeof(ICHAR), (char*)rgchSerializedRecord, &imsReturn);
						if (FAILED(hres))
							return imsError;
					}
				}
				return imsReturn; //?? OK to return here?
			default:
				return m_piClientMessage->MessageNoRecord(imt);
			}
			break;
		case imtLoadHandler   >> imtShiftCount:
		case imtFreeHandler   >> imtShiftCount:
		case imtUpgradeRemoveScriptInProgress >> imtShiftCount:
		case imtUpgradeRemoveTimeRemaining    >> imtShiftCount:
			return imsNone;
		case imtShowDialog    >> imtShiftCount:
		case imtOutOfMemory   >> imtShiftCount:
		case imtTimeRemaining >> imtShiftCount:
		case imtScriptInProgress >> imtShiftCount:
		case imtTimedOut      >> imtShiftCount:
		case imtException     >> imtShiftCount:
		case imtBannerText    >> imtShiftCount:
			piRecord = GetNoDataRecord();
			piRecord->SetMsiString(0, *MsiString(m_szAction));  // not ref string, may be cached by record streamer
			break;
		default: AssertSz(0, "Unexpected message type in ProcessMessage");
		} // end switch(imsg)
		imsReturn = m_piClientMessage->Message(imt, *piRecord);
		piRecord->SetNull(0);
		m_szAction = 0;
	}
	else // function that must be called from this thread, piRecord not used
	{
		switch(imsg)
		{
		case imtInternalExit   >> imtShiftCount:
		{
			const ICHAR* szFatalError = TEXT("");
			switch(imt) // called locally from HandleOutOfMemory or event loop
			{
			// dump properties if logging or externalUI is available and interested
			case imtDumpProperties:     return ((g_dwLogMode & iLogPropertyDump)
											    || (g_message.m_iMessageFilter & (1<<( imtInfo>>imtShiftCount)) )) ? imsYes : imsNo;
			case imtFatalOutOfMemory: szFatalError = g_szFatalOutOfMemory; break;
			case imtFatalTimedOut:    szFatalError = g_szFatalTimedOut;    break;
			case imtFatalException:   szFatalError = g_szFatalException;   break;
			case imtExceptionInfo:
				if (*m_rgchExceptionInfo)
					szFatalError = m_rgchExceptionInfo;
				else if (m_szAction)
					szFatalError = m_szAction;
				break;
			}
			if (*szFatalError == 0)  // crash before initialization or coding error, should not happen unless debugging
				szFatalError = (imt == imtFatalTimedOut) ? TEXT("Install server not responding")
																	  : TEXT("Unexpected Termination");
			if (g_message.m_iMessageFilter & fMask)
				imsReturn = g_message.Message(imt, szFatalError);
			if ((1<<(imtFatalExit>>imtShiftCount)) & g_dwLogMode)
			{
				if (ENG::LoggingEnabled())
					ENG::WriteLog(szFatalError); //!! need to enable log if not already
			}
			if (imt == imtFatalTimedOut && g_BasicUI.Quiet() && ++m_iTimeoutRetry <= cRetryLimit)
					return imsRetry;   // allow retries if quiet mode
#ifdef DEBUG
			if (imsReturn == imsNone && !g_BasicUI.Quiet())
#else // SHIP
			if (imt != imtExceptionInfo && imsReturn == imsNone && !g_BasicUI.Quiet()) // don't display exception info in SHIP build
#endif
				imsReturn = g_BasicUI.FatalError(imt, szFatalError);
			return imsReturn;
		}

		case imtLoadHandler   >> imtShiftCount:
		{
			IMsiHandler* piHandler = 0;
#ifdef DEBUG
			const GUID& riid = IID_IMsiHandlerDebug;
#else
			const GUID& riid = IID_IMsiHandler;
#endif
			m_hinstHandler = ENG::MsiLoadLibrary(MSI_HANDLER_NAME);
			PDllGetClassObject fpFactory = (PDllGetClassObject)WIN::GetProcAddress(m_hinstHandler, SzDllGetClassObject);
			IClassFactory* piClassFactory;
			if (fpFactory && (*fpFactory)(riid, IID_IUnknown, (void**)&piClassFactory) == NOERROR)
			{
				piClassFactory->CreateInstance(0, riid, (void**)&piHandler);
				piClassFactory->Release();
			}
			if (!piHandler)
				return imsNone;
			Assert(m_piEngine);
			bool fMissingTables = false;
			Bool fHandlerOk = piHandler->Initialize(*m_piEngine, m_iuiLevel, g_message.m_hwnd, fMissingTables);
			m_piEngine = 0;  // temp for transfer only
			if (!fHandlerOk)
			{
				piHandler->Release(), piHandler = 0;

				if (fMissingTables) // if the initialization failed because of missing tables then we'll ignore the failure
					return imsOk;
				else
					return imsNone;
			}

			PMsiRecord pHideDialog(&CreateRecord(1));
			pHideDialog->SetInteger(1, icmtDialogHide);
			g_BasicUI.Message(imtCommonData, *pHideDialog);

			m_piHandler = piHandler;
			return imsOk;
		}
		case imtFreeHandler   >> imtShiftCount:
			if(m_piHandler)
			{
				m_piHandler->Terminate();   // break circular reference
				m_piHandler->Release();
				m_piHandler = 0;
			}
			return imsOk;
		case imtShowDialog    >> imtShiftCount:
			if (!m_piHandler || !m_szAction) // shouldn't happen
				return imsNone;
			if (g_message.m_iMessageFilter & (1 << (imtShowDialog>>imtShiftCount)))
				imsReturn = g_message.Message(imtShowDialog, m_szAction);
			if (imsReturn == imsNone)
				imsReturn = (imsEnum)m_piHandler->DoAction(m_szAction);
			break;
		case imtTimeRemaining >> imtShiftCount:
			g_szTimeRemaining.SetSize(IStrLen(m_szAction) + 1);
			if(m_szAction)
				IStrCopy(g_szTimeRemaining, m_szAction);
			else
				g_szTimeRemaining[0] = 0;
			break;
		case imtScriptInProgress >> imtShiftCount:
			g_szScriptInProgress.SetSize(IStrLen(m_szAction) + 1);
			if(m_szAction)
				IStrCopy(g_szScriptInProgress, m_szAction);
			else
				g_szScriptInProgress[0] = 0;
			break;
		case imtOutOfMemory   >> imtShiftCount:
			g_szFatalOutOfMemory.SetSize(IStrLen(m_szAction) + 1);
			if(m_szAction)
				IStrCopy(g_szFatalOutOfMemory, m_szAction);
			else
				g_szFatalOutOfMemory[0] = 0;
			break;
		case imtTimedOut      >> imtShiftCount:
			g_szFatalTimedOut.SetSize(IStrLen(m_szAction) + 1);
			if(m_szAction)
				IStrCopy(g_szFatalTimedOut, m_szAction);
			else
				g_szFatalTimedOut[0] = 0;
			break;
		case imtException     >> imtShiftCount:
			g_szFatalException.SetSize(IStrLen(m_szAction) + 1);
			if(m_szAction)
				IStrCopy(g_szFatalException, m_szAction);
			else
				g_szFatalException[0] = 0;
			break;
		case imtBannerText    >> imtShiftCount:
		{
			g_szBannerText.SetSize(IStrLen(m_szAction) + 1);
			if(m_szAction)
				IStrCopy(g_szBannerText, m_szAction);
			else
				g_szBannerText[0] = 0;
			break;
		}
		case imtUpgradeRemoveScriptInProgress >> imtShiftCount:
		case imtUpgradeRemoveTimeRemaining    >> imtShiftCount:
			// these strings are not cached - they are just used to replace other strings during upgrade uninstalls
			break;
		default: AssertSz(0, "Unexpected message type in ProcessMessage");
		} // end switch(imsg)
		m_szAction = 0;
	}  // end if message | function
	return imsReturn;
}

bool LoadCurrentUserKey(bool fSystem = false)
{
	if (!RunningAsLocalSystem())
		return true;

	// Make sure HKEY_CURRENT_USER is closed before remapping it.

	if (ERROR_SUCCESS != RegCloseKey(HKEY_CURRENT_USER))
	{
		Assert(0);
		return false;
	}

	if (!fSystem)
		AssertNonZero(StartImpersonating());

	// Access the registry to force HKEY_CURRENT_USER to be re-opened

	CElevate elevate(fSystem); // ensure that we're not impersonate if fSystem is set
	RegEnumKey(HKEY_CURRENT_USER, 0, NULL, 0);

	if (!fSystem)
		StopImpersonating();

	return true;
}

bool MsiUIMessageContext::Terminate(bool fFatalExit)
{
        // We need to terminate the thread before terminating the handler so we don't try to poke the
        // handler while it's in the process of shutting down
        //
        // must call other thread to shut down while we are still "initialized"
        // since Invoke checks for m_fInitialized
        if (m_hUIThread)
        {
                if(m_fInitialized) //kill the other thread, the civilized way
                        Invoke(imtEnum(imtExitThread), 0), WIN::CloseHandle(m_hUIThread), m_hUIThread = 0;
                else // Invoke is a noop if not m_fInitialized, no option but to be brutal
                        WIN::TerminateThread(m_hUIThread, 0), WIN::CloseHandle(m_hUIThread), m_hUIThread = 0;
        }

	// uninitialize OLE if already initialized
	if (true == m_fOleInitialized)
	{
		OLE32::CoUninitialize();
		m_fOleInitialized = false;
	}

	m_fInitialized = false; // must be first, now that we have disposed off the other thread
	m_fOEMInstall = false;
	if ( m_hSfcHandle ) {SFC::SfcClose(m_hSfcHandle); m_hSfcHandle = NULL;}
	SFC::Unbind();

	if ( m_hSaferLevel )
	{
		ADVAPI32::SaferCloseLevel(m_hSaferLevel);
		m_hSaferLevel = 0;
	}

	g_szBannerText.Destroy();
	g_szScriptInProgress.Destroy();
	g_szTimeRemaining.Destroy();
	g_szFatalOutOfMemory.Destroy();
	g_szFatalTimedOut.Destroy();
	g_szFatalException.Destroy();
	KillHiddenWindow();
	m_rgchExceptionInfo[0] = 0;

	if (g_scServerContext == scService)
	{
		CProductContextCache::Reset(); // reset product context cache
	}

	if (m_piHandlerSave) m_piHandler=m_piHandlerSave;m_piHandlerSave = 0;
	if (!fFatalExit)  // avoid freeing of objects when allocator is gone
	{
		if (m_pirecMessage)  m_pirecMessage->Release(),  m_pirecMessage  = 0;
		if (m_pirecNoData)   m_pirecNoData->Release(),   m_pirecNoData   = 0;
	}
	else
	{
		m_pirecMessage = 0;
		m_pirecNoData = 0;
		g_piSharedDllsRegKey = 0;
#ifdef _WIN64
		g_piSharedDllsRegKey32 = 0;
#endif
	}

        if (m_piHandler) m_piHandler->Terminate(fFatalExit), m_piHandler->Release(), m_piHandler = 0;
        if (m_piClientMessage) m_piClientMessage->Release(), m_piClientMessage = 0;
//      if (m_piServerSecurity) m_piServerSecurity->Release(), m_piServerSecurity = 0;
	if (m_hMainThread)   WIN::CloseHandle(m_hMainThread), m_hMainThread = 0;
	m_cTimeoutDisable = 0;
	if (g_message.m_iMessageFilter & (1 << (imtFreeHandler>>imtShiftCount))) g_message.Message(imtFreeHandler, (const ICHAR*)0);
	if(g_BasicUI.IsInitialized()) g_BasicUI.Terminate();
	if (m_hinstHandler)  WIN::FreeLibrary(m_hinstHandler), m_hinstHandler = 0;
	m_iuiLevel = (iuiEnum)iuiDefault;
	if (!GetTestFlag('X'))
		WIN::SetUnhandledExceptionFilter(m_tlefOld);
	WIN::CloseHandle(m_hUIRequest), m_hUIRequest = 0;
	WIN::CloseHandle(m_hUIReturn),  m_hUIReturn  = 0;

	extern CMsiConfigurationManager* g_piConfigManager;

	//!!future Hack! The message context shouldn't be cleaning up stuff in the global config manager.
	if (g_scServerContext == scService && g_piConfigManager)
		((IMsiConfigurationManager *)g_piConfigManager)->ShutdownCustomActionServer();

	m_tidMainThread      = 0;
	m_tidUIHandler       = 0;
	m_tidDisableMessages = 0;
	m_fHideBasicUI       = false;
	m_fNoModalDialogs    = false;
	m_fHideCancel        = false;
	m_fSourceResolutionOnly = false;
	m_fUseUninstallBannerText = false;


	if (fFatalExit)
	{
		MsiCloseAllSysHandles();
		FreeMsiMalloc(fTrue);
		// Need to set system to powerdown state so we don't leave ourselves with a machine that
		// might not go to sleep
		KERNEL32::SetThreadExecutionState(0);

		extern IMsiServices* g_piSharedServices;
		//
		// Clear out the volume list, but don't actually free
		// the memory (we've done that already)
		//
		DestroyMsiVolumeList(fTrue);

		if (g_piSharedServices != 0)
		{
			g_piSharedServices = 0;
			IMsiServices* piServices = ENG::LoadServices();

			//
			// Change the services that the global config manager knows about
			//
			if (g_piConfigManager)
				((IMsiConfigurationManager *)g_piConfigManager)->ChangeServices(*piServices);
		}
		else
			Assert(g_piConfigManager == 0);

	}
	else
	{
		if (m_piServices)
			ENG::FreeServices(), m_piServices=0;
	}


	if (m_csDispatch.OwningThread != INVALID_HANDLE_VALUE)
	{
		WIN::DeleteCriticalSection(&m_csDispatch);
		m_csDispatch.OwningThread = INVALID_HANDLE_VALUE;
	}

	if (m_hLogFile)
	{
		if(FDiagnosticModeSet(dmVerboseLogging))
		{
			ICHAR rgchLog[100];
			wsprintf(rgchLog, TEXT("=== Verbose logging stopped: %s  %s ===\r\n"),
						((const IMsiString&)g_MsiStringDate).GetString(), ((const IMsiString&)g_MsiStringTime).GetString());
			WriteLog(rgchLog);
		}
		if(m_fLoggingFromPolicy)
		{
			// logging was triggered by policy, so we need to clear the log settings so we don't use the
			// same log for the next install session
			g_szLogFile[0] = 0;
			g_dwLogMode = 0;
		}
		WIN::CloseHandle(m_hLogFile);
		m_hLogFile = 0;
		g_cFlushLines = 0;
	}

	m_fLoggingFromPolicy = false;

	if (g_rgchEnvironment[0])
		AssertNonZero(RestoreEnvironmentVariables());

	m_hwndDebugLog = 0;

#ifndef FAST_BUT_UNDOCUMENTED
	g_rgchEnvironment.Destroy(); // must be done after RestoreEnvironmentVariables
	g_rgchEnvironment[0] = 0;

#endif
	m_fCancelPending = false;
#ifdef DEBUG
	m_fCancelReturned = false;
#endif
	if (g_scServerContext == scService)
		AssertNonZero(LoadCurrentUserKey(true));

	m_iBusyLock = 0;

	// resets the stores user token, needs to be the very last thing we do
	// any operations later on better not want to use the user token or classes
	// like the CElevate class that rely on the user token
	SetUserToken(true); 

	return true;
}  // free library at final destruction to avoid loss of constant referenced strings

/*static*/ DWORD WINAPI MsiUIMessageContext::MainEngineThread(LPVOID pInstallData)
{
	DISPLAYACCOUNTNAME(TEXT("Beginning of MainEngineThread"));

#ifdef DEBUG
	HANDLE hToken = 0;
	ICHAR szAccount[300];
	OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	GETACCOUNTNAMEFROMTOKEN(hToken, szAccount);
	DEBUGMSGV1(TEXT("MainEngineThread: Process token is for: %s"), szAccount);
	WIN::CloseHandle(hToken);
#endif

	CMainThreadData* pThreadData = (CMainThreadData*)pInstallData;
	DWORD iReturn;
	if (pThreadData->m_ireProductSpec == ireInstallFinalize)
	{
		PMsiMessage pMessage = new CMsiClientMessage();
		iReturn = (int)InstallFinalize(((CInstallFinalizeMainThreadData*)pInstallData)->m_iesState,
												 *((CInstallFinalizeMainThreadData*)pInstallData)->m_piConman,
												 *pMessage, fFalse /*fUserChangedDuringInstall*/);
	}
	else
	{
		iReturn = ENG::CreateAndRunEngine(((CEngineMainThreadData*)pInstallData)->m_ireProductSpec,
														 ((CEngineMainThreadData*)pInstallData)->m_szProduct,
														 ((CEngineMainThreadData*)pInstallData)->m_szAction,
														 ((CEngineMainThreadData*)pInstallData)->m_szCmdLine, 0,
														 ((CEngineMainThreadData*)pInstallData)->m_iioOptions);
	}

	DEBUGMSG1(TEXT("MainEngineThread is returning %d"), (const ICHAR*)(INT_PTR)iReturn);
	WIN::ExitThread(iReturn);
	return iReturn;  // never gets here, needed to compile
}

//!! remove this function when callers changed to call RunInstall directly

UINT RunEngine(ireEnum ireProductSpec,   // type of string specifying product
			   const ICHAR* szProduct,      // required, matches ireProductSpec
			   const ICHAR* szAction,       // optional, engine defaults to "INSTALL"
			   const ICHAR* szCommandLine,  // optional command line
				iuiEnum      iuiLevel,
				iioEnum      iioOptions)    // installation options

{
	// load services, required for MsiString use
	IMsiServices* piServices = ENG::LoadServices();
	if (!piServices)
	{
		DEBUGMSG(TEXT("Unable to load services"));
		return ERROR_FUNCTION_FAILED; //??
	}
	
	// this if block also scopes the MsiString usage
	if(szCommandLine && *szCommandLine)
	{
		MsiString strRemove;
		ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_FEATUREREMOVE), &strRemove, fTrue, 0, 0);

		if (strRemove.Compare(iscExactI, IPROPVALUE_FEATURE_ALL))
			iuiLevel = iuiEnum(iuiLevel | iuiUseUninstallBannerText);
	}
	
	ENG::FreeServices();
	
	CEngineMainThreadData threadData(ireProductSpec, szProduct, szAction, szCommandLine, iioOptions);

	UINT ui = g_MessageContext.RunInstall(threadData, iuiLevel, 0);
	Assert(ui != ERROR_INSTALL_REBOOT && ui != ERROR_INSTALL_REBOOT_NOW);
	DEBUGMSG1(TEXT("RunEngine is returning: %u"), (const ICHAR*)(INT_PTR)ui);
	return ui;
}

void SetEngineInitialImpersonationCount();

UINT MsiUIMessageContext::SetUserToken(bool fReset)
{
	if (m_hUserToken)
		WIN::CloseHandle(m_hUserToken), m_hUserToken = 0;

	if (fReset)
	{
		return ERROR_SUCCESS;
	}
	else if (g_scServerContext == scService)
	{
		CComPointer<IServerSecurity> pServerSecurity(0);
		HRESULT hRes = OLE32::CoGetCallContext(IID_IServerSecurity, (void**)&pServerSecurity);
		if (ERROR_SUCCESS != hRes)
		{
			AssertSz(0, "CoGetCallContext failed");
			return ERROR_INSTALL_SERVICE_FAILURE;
		}
		if (ERROR_SUCCESS != pServerSecurity->ImpersonateClient())
		{
			AssertSz(0, "ImpersonateClient failed");
			return ERROR_INSTALL_SERVICE_FAILURE;
		}
		if (!WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE, TRUE, &m_hUserToken))
		{
			AssertSz(0, "Failed to get user token");
			return ERROR_INSTALL_SERVICE_FAILURE;
		}
		pServerSecurity->RevertToSelf();  //! do we need/want to do this here?
	}
	else if (g_scServerContext == scClient)
	{
		if (RunningAsLocalSystem())
		{
			// if this fails then we're not impersonating 
			if (!WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE, TRUE, &m_hUserToken))
			{
				DEBUGMSGV1(TEXT("Failed to open thread token (error %d): we're not impersonated"), (const ICHAR*)(INT_PTR)GetLastError());
				m_hUserToken = 0;
			}
			else
			{
				DEBUGMSGV("Opened thread token: we're impersonated");
				SetEngineInitialImpersonationCount();
			}
		}
	}

	return ERROR_SUCCESS;
}

// Initializes UI in current thread, creates main engine in new thread, handles messages
UINT MsiUIMessageContext::RunInstall(CMainThreadData& riThreadData,
												 iuiEnum iuiLevel,
												 IMsiMessage* piClientMessage)// optional client message handler
{

	LPEXCEPTION_POINTERS lpExceptionInfo = 0;

	__try
	{

		UINT iStat = Initialize(fFalse, iuiLevel);  // UI runs in current thread
		if (iStat != NOERROR)
			return iStat;

		Assert(m_iBusyLock);

	#ifdef DEBUG
		if (m_hUserToken)
		{
			ICHAR szAccount[400] = TEXT("");
			GETACCOUNTNAMEFROMTOKEN(m_hUserToken, szAccount);
			DEBUGMSGV1(TEXT("m_hUserToken's account (in MsiUIMessageContext::RunInstall): %s"), szAccount);
		}
		else
		{
			DEBUGMSGV(TEXT("m_hUserToken's account (in MsiUIMessageContext::RunInstall): NULL"));
		}
	#endif

		if (piClientMessage)
		{
			Assert(g_scServerContext == scServer || g_scServerContext == scService);
			m_piClientMessage = piClientMessage;
			piClientMessage->AddRef();  //!! need this? lifetime only within function
		}

		if (GetTestFlag('T'))
		{
			int iReturn = ENG::CreateAndRunEngine(((CEngineMainThreadData&)riThreadData).m_ireProductSpec,
															  ((CEngineMainThreadData&)riThreadData).m_szProduct,
															  ((CEngineMainThreadData&)riThreadData).m_szAction,
															  ((CEngineMainThreadData&)riThreadData).m_szCmdLine, 0,
															  ((CEngineMainThreadData&)riThreadData).m_iioOptions);
			Terminate(false);
			return iReturn;
		}
		DWORD iReturn = ERROR_SUCCESS;
		m_hMainThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
													MainEngineThread, (LPVOID)&riThreadData, 0, &m_tidMainThread);
		if (!m_hMainThread)
		{
			AssertSz(0, TEXT("CreateThread for main engine thread failed"));
			Terminate(fTrue);
			return ERROR_CREATE_FAILED; //!! need another error here?
		}

		int cTicks = 0;
		m_iTimeoutRetry = 0;
		for(;;)  // event thread loops until main thread exits
		{
			DWORD dwWait;

			if (g_scServerContext != scClient)
			{
				// on the server we need to process messages for the hidden RPC window so we'll
				// use MsgWait

				dwWait = WIN::MsgWaitForMultipleObjects(2, &m_hUIRequest, FALSE, iWaitTick, QS_ALLINPUT);
			}
			else
			{
				dwWait = WIN::WaitForMultipleObjects(2, &m_hUIRequest, FALSE, iWaitTick);
			}

			// dump any pending debug log messages to our log file

			MSG msg;

			while (WIN::PeekMessage(&msg, m_hwndDebugLog, iDebugLogMessage, iDebugLogMessage, PM_REMOVE))
			{
				ICHAR szText[256];
				if (!WIN::GlobalGetAtomName((ATOM)msg.wParam, szText, sizeof(szText)/sizeof(ICHAR)))
					IStrCopy(szText, TEXT("*** Log Line Missing ***"));
				AssertZero(WIN::GlobalDeleteAtom((ATOM)msg.wParam));
				IMsiRecord* piRecord = GetNoDataRecord();
				AssertNonZero(piRecord->SetString(0, szText));
				ProcessMessage(imtInfo, piRecord);
			}

			if (dwWait == WAIT_FAILED)
			{
				AssertSz(0, "Wait Failed in RunEngine");
				iReturn = WIN::GetLastError();
				break;
			}
			if (dwWait == WAIT_TIMEOUT)  // main engine thread is busy
			{
				if (m_piClientMessage == 0)  // not remote UI
				{
					if (ProcessMessage(imtProgress, g_piNullRecord) == imsCancel)  // refresh UI
						m_fCancelPending = true; // cache message until next real message
				}
				if(m_cTimeoutSuppress)
				{
					m_cTimeoutSuppress = 0;
					cTicks = 0;
					continue;
				}
				if (m_cTimeoutDisable || (++cTicks < g_cWaitTimeout))
					continue;
				DEBUGMSG("RunEngine wait timed out");
				if (!ENG::IsDebuggerRunning())
				{
					imsEnum ims = ProcessMessage(imtEnum(imtFatalTimedOut), 0);
					if (ims != imsRetry)
					{
						// Ensure that we're not doing memory manager operations
						// in the other thread. We're assuming that the memory
						// manager is "safe" and will never bring us down.

						EnterCriticalSection(&vcsHeap);
						WIN::TerminateThread(m_hMainThread, ERROR_OPERATION_ABORTED);
						LeaveCriticalSection(&vcsHeap);
						Terminate(fTrue);
						return ERROR_INSTALL_FAILURE;
					}
				}
				cTicks = 0;
				m_iTimeoutRetry = 0;
				continue;
			}
			else if (dwWait == WAIT_OBJECT_0 + 1) // main thread terminated or died
			{
				WIN::GetExitCodeThread(m_hMainThread, &iReturn);  // can't access member data, may be deleted
				switch (iReturn)
				{
					default:                 // normal exit
						Terminate(false);
						return iReturn;
					case ERROR_ARENA_TRASHED:      // engine thread crashed
						ProcessMessage(imtEnum(imtFatalException), 0);
						iReturn = ERROR_OPERATION_ABORTED;
						break;
					case ERROR_NOT_ENOUGH_MEMORY: // out of memory, already handled
						iReturn = ERROR_OUTOFMEMORY;
						break;
					case ERROR_OPERATION_ABORTED: // UI already handled
						break;
				}
				Terminate(fTrue);   // main thread is dead, can't free anything allocated there
				return iReturn;
			}
			else if (dwWait == WAIT_OBJECT_0 + 2)  // window Msg
			{
				MSG msg;
				while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
				{
					WIN::TranslateMessage(&msg);
					WIN::DispatchMessage(&msg);
				}
				continue;
			}
			cTicks = 0;
			m_iTimeoutRetry = 0;

			// else we were signaled with a message request
			if (m_imtMessage == imtInvalid)
			{
				DEBUGMSG("Invalid event trigger in wait for engine thread"); //!!# temp for debug
				continue;
			}
			m_imsReturn = imsBusy;      // to indicate processing in UI thread
			m_imsReturn = ProcessMessage(m_imtMessage, m_pirecMessage);
			m_imtMessage = imtInvalid;  // to detect invalid event triggers
			WIN::SetEvent(m_hUIReturn);
		} // end message wait/process loop

		return NOERROR;
	}
	__except(lpExceptionInfo=GetExceptionInformation(),
			 (!lpExceptionInfo ||
			  lpExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT) ?
				EXCEPTION_CONTINUE_SEARCH : EXCEPTION_EXECUTE_HANDLER)
	{
		GenerateExceptionReport(lpExceptionInfo);
		::ReportToEventLog(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_EXCEPTION, g_MessageContext.m_rgchExceptionInfo);
		g_MessageContext.Invoke(imtEnum(imtExceptionInfo), 0);
		Terminate(fTrue);
		return ERROR_INSTALL_FAILURE;
	}
};

// Unhandled exception handler, enabled/disabled by Initialize/Terminate

DWORD g_tidDebugBreak = 0;

LONG WINAPI MsiUIMessageContext::ExceptionHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	DWORD tidCurrent = WIN::GetCurrentThreadId();
	if (tidCurrent == g_MessageContext.m_tidInitialize  // caller's thread, not ours
	 || (tidCurrent == g_tidDebugBreak && ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT))
	{
		g_tidDebugBreak = 0;
		return (*g_MessageContext.m_tlefOld)(ExceptionInfo);  // use original exception handler
	}

	GenerateExceptionReport(ExceptionInfo);
	::ReportToEventLog(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_EXCEPTION, g_MessageContext.m_rgchExceptionInfo);
	g_MessageContext.Invoke(imtEnum(imtExceptionInfo), 0);

	WIN::ExitThread(ERROR_ARENA_TRASHED);   // terminate our thread
	return ERROR_SUCCESS;                   // for compilation, never gets here
}

// Initialize message context and create child UI thread if engine is operating in the main thread
// Else the main engine thread is created afterwards, and no memory allocator may be available yet

UINT MsiUIMessageContext::Initialize(bool fCreateUIThread, iuiEnum iuiLevel) // called only from main thread before any child threads
{
	class CTerminate
	{
	public:
		~CTerminate() { if (!g_MessageContext.IsInitialized()) g_MessageContext.Terminate(false); }
	};

	if(TestAndSet(&m_iBusyLock) == true)
	{
		DEBUGMSG(TEXT("Message context already initialized, returning ERROR_INSTALL_ALREADY_RUNNING"));
		return ERROR_INSTALL_ALREADY_RUNNING;
	}

	CTerminate terminate; // only terminate if we've made it past the TestAndSet

	UINT uiRes = SetUserToken();
	if (ERROR_SUCCESS != uiRes)
		return uiRes;

	m_tidInitialize = WIN::GetCurrentThreadId();
	if (!GetTestFlag('X'))
		m_tlefOld = WIN::SetUnhandledExceptionFilter(MsiUIMessageContext::ExceptionHandler);

	m_hUIRequest = WIN::CreateEvent((LPSECURITY_ATTRIBUTES)0, FALSE/*autoreset*/, FALSE/*unsignaled*/, (LPCTSTR)0/*unnamed*/);
	m_hUIReturn  = WIN::CreateEvent((LPSECURITY_ATTRIBUTES)0, FALSE/*autoreset*/, FALSE/*unsignaled*/, (LPCTSTR)0/*unnamed*/);

/*remove*/      Assert(m_hUIRequest && m_hUIReturn);
	if (m_hUIRequest == 0 || m_hUIReturn == 0)
		return ERROR_CREATE_FAILED;
	WIN::InitializeCriticalSection(&m_csDispatch);
	if ((m_piServices = ENG::LoadServices()) == 0)
		return ERROR_CREATE_FAILED;

	m_fServicesAndCritSecInitialized = true;

	// set timeout value
	g_cWaitTimeout = GetIntegerPolicyValue(szWaitTimeoutValueName, fTrue)*20;
	Assert(g_cWaitTimeout);

	if ((int)iuiLevel & iuiHideBasicUI)
	{
		m_fHideBasicUI = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiHideBasicUI);
	}

	if ((int)iuiLevel & iuiNoModalDialogs)
	{
		m_fNoModalDialogs = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiNoModalDialogs);
	}

	if ((int)iuiLevel & iuiSourceResOnly)
	{
		m_fSourceResolutionOnly = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiSourceResOnly);
	}

	if ((int)iuiLevel & iuiUseUninstallBannerText)
	{
		m_fUseUninstallBannerText = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiUseUninstallBannerText);
	}
	
	if ((int)iuiLevel & iuiHideCancel)
	{
		m_fHideCancel = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiHideCancel);
	}

	m_iuiLevel = iuiLevel;  // could be set to iuiNextEnum if UIPreview mode
	if (fCreateUIThread)  // engine running in main thread so API functions can be called
	{
		if (GetTestFlag('T'))
		{
			m_tidUIHandler = WIN::GetCurrentThreadId();  // UI and main engine in same thread
			m_hUIThread = INVALID_HANDLE_VALUE;  // so that ChildUIThreadExists() works
		}
		else
		{
			m_hUIThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
														(PThreadEntry)ChildUIThread, (LPVOID)this, 0, &m_tidUIHandler);
			AssertSz(m_hUIThread, TEXT("CreateThread for child UI thread failed"));
			if (!m_hUIThread)
			{
				return ERROR_CREATE_FAILED;
			}
		}
	}
	else // called from RunEngine, UI remains in this main thread
	{
		m_tidUIHandler = WIN::GetCurrentThreadId();
		if (m_iuiLevel == iuiNextEnum)  // UIPreview, FullUI, no Basic UI
			m_iuiLevel = iuiFull;     // must do this in UI thread
		else
		{
			bool fQuiet = m_iuiLevel == iuiNone ||
							  m_iuiLevel == iuiDefault;
			if(!g_BasicUI.Initialize(g_message.m_hwnd, fQuiet, m_fHideBasicUI,
											 m_fNoModalDialogs, m_fHideCancel, m_fUseUninstallBannerText, 
											 m_fSourceResolutionOnly))
			{
				return ERROR_CREATE_FAILED; //!! what error?
			}
		}
		
		// need to initialize OLE on this thread
		if (false == m_fOleInitialized && SUCCEEDED(OLE32::CoInitialize(0)))
		{
			m_fOleInitialized = true;
		}
	}

	if (g_message.m_iMessageFilter & (1 << (imtLoadHandler>>imtShiftCount)))
		g_message.Message(imtLoadHandler, (const ICHAR*)0);  //!! need to check return and disable starting dialog

	g_szScriptInProgress[0] = 0;
	g_szTimeRemaining[0] = 0;
	g_szFatalOutOfMemory[0] = 0;
	g_szFatalTimedOut[0] = 0;
	g_szFatalException[0] = 0;
	m_rgchExceptionInfo[0] = 0;


	if (g_scServerContext == scService)
	{
		// reset product context cache for every installation session
		CProductContextCache::Initialize();

		if (!LoadCurrentUserKey())
		{
			return ERROR_CREATE_FAILED; //?? correct error?
		}
	}

	if (!InitializeEnvironmentVariables())
	{
		return ERROR_CREATE_FAILED; //?? correct error?
	}

	if (!InitializeLog())
	{
		return ERROR_INSTALL_LOG_FAILURE;
	}

	if (!FCreateHiddenWindow())
	{
		AssertSz(fFalse, "Unable to create hidden window");
	}

	// Set m_hwndDebugLog to the *client's* hidden window

	if (g_scServerContext == scClient)
		m_hwndDebugLog = m_hwndHidden;
	else
	{
		// Look for the client's hidden window. We have the server's hwnd (m_hwndHidden) so
		// we'll just look for another window of class MsiHiddenWindowClass that has an
		// hwnd other than m_hwndHidden

		HWND hwndStart = 0;
		HWND hwndDebugLog;
		while ((hwndDebugLog = FindWindowEx(0, hwndStart, MsiHiddenWindowClass, 0)) != 0)
		{
			if (hwndDebugLog != m_hwndHidden)
			{
				m_hwndDebugLog = hwndDebugLog;
				break;
			}
			hwndStart = hwndDebugLog;
		}
	}

	AssertSz(!m_hSfcHandle, TEXT("Windows File Protection handle should not be initialized!"));
	if ( MinimumPlatformWindows2000() && !m_hSfcHandle ) m_hSfcHandle = SFC::SfcConnectToServer(NULL);
	m_fInitialized = true; // must be last

	return NOERROR;
}

LONG_PTR CALLBACK HiddenWindowProc(HWND pWnd, unsigned int message, WPARAM wParam, LPARAM lParam)               //--merced: changed return type from long to LONG_PTR
{
	switch(message)
	{
		case WM_POWERBROADCAST:
			if (PBT_APMQUERYSUSPEND == wParam)
			{
				if (FTestNoPowerdown())
				{
					DEBUGMSGD("Hidden window Refusing Powerdown");
					return BROADCAST_QUERY_DENY;
				}
			}
			break;
		case WM_QUERYENDSESSION:
			if (FTestNoPowerdown())
			{
				DEBUGMSGD("Hidden window Refusing QueryEndSession");
				return FALSE;
			}
			break;
	}
	return DefWindowProc(pWnd, message, wParam, lParam);
}

HWND MsiUIMessageContext::GetCurrentWindow()
{
	return g_MessageContext.m_piHandler ? g_MessageContext.m_piHandler->GetTopWindow()
										: g_BasicUI.GetWindow();
}

const ICHAR* MsiUIMessageContext::GetWindowCaption()
{
	return g_BasicUI.GetCaption();
}

LANGID MsiUIMessageContext::GetCurrentUILanguage()
{
	return g_BasicUI.GetPackageLanguage();
}

bool MsiUIMessageContext::FCreateHiddenWindow()
{
	WNDCLASS wc;

	memset(&wc, 0, sizeof(wc));
	wc.style       = CS_DBLCLKS;
	wc.lpfnWndProc = HiddenWindowProc;
	wc.hInstance   = g_hInstance;
	wc.lpszClassName = MsiHiddenWindowClass;
	if (RegisterClass(&wc) == 0)
	{
		return false;
	}

	m_hwndHidden =  WIN::CreateWindowEx(0, MsiHiddenWindowClass,
						TEXT(""),
						WS_POPUP,                // Style
						CW_USEDEFAULT,                   // horizontal position
						CW_USEDEFAULT,                   // vertical position
						CW_USEDEFAULT,               // window width
						CW_USEDEFAULT,              // window height
						0,
						0,                      // hmenu
						g_hInstance,            // hinst
						0                       // lpvParam
						);

	return true;

}

void MsiUIMessageContext::KillHiddenWindow()
{

	if (m_hwndHidden)
	{
		WIN::DestroyWindow(m_hwndHidden);
		m_hwndHidden = 0;
	}

	UnregisterClass(MsiHiddenWindowClass, g_hInstance);

}


//____________________________________________________________________________
//
// Log handling
//____________________________________________________________________________

bool CreateLog(const ICHAR* szFile, bool fAppend)
{
	if (g_MessageContext.m_hLogFile)  // close any existing log file //!! is this what we want to do?
		CloseHandle(g_MessageContext.m_hLogFile);

	if (szFile)
		g_MessageContext.m_hLogFile = CreateFile(szFile, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ,
										0, fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
										FILE_ATTRIBUTE_NORMAL, 0);
	else
		g_MessageContext.m_hLogFile = INVALID_HANDLE_VALUE;
	if (g_MessageContext.m_hLogFile == INVALID_HANDLE_VALUE)
	{
		g_MessageContext.m_hLogFile = 0;
		return false;
	}

	DWORD fp = 0;
	if (fAppend && (fp = WIN::SetFilePointer(g_MessageContext.m_hLogFile, 0, NULL, FILE_END)) == 0xFFFFFFFF)
	{
		WIN::CloseHandle(g_MessageContext.m_hLogFile);
		g_MessageContext.m_hLogFile = 0;
		return false;
	}
#ifdef UNICODE
	else if (fp == 0)
	{
		const char rgUnicode[2] = { (char)0xff, (char)0xfe };
		DWORD dwBytesWritten;
		if (!WIN::WriteFile(g_MessageContext.m_hLogFile, rgUnicode, sizeof(rgUnicode), &dwBytesWritten, 0))
		{
			WIN::CloseHandle(g_MessageContext.m_hLogFile);
			g_MessageContext.m_hLogFile = 0;
			return false;
		}
	}
#endif //UNICODE

	return true;
}

bool LoggingEnabled()
{
	return (g_MessageContext.m_hLogFile != 0);
}

const ICHAR rgchLFCR[2] = {'\r','\n'};

const int cMinLinesToFlush = 20;

bool WriteLog(const ICHAR* szText) // cannot allocate memory
{
	DWORD dwBytesWritten;
	if (!g_MessageContext.m_hLogFile || !szText)
		return false;
	if (!WriteFile(g_MessageContext.m_hLogFile, szText, IStrLen(szText)*sizeof(ICHAR), &dwBytesWritten, 0))
		return false;
	WIN::WriteFile(g_MessageContext.m_hLogFile, rgchLFCR, sizeof(rgchLFCR), &dwBytesWritten, 0);

	if (g_cFlushLines <= 0)
	{
		if (!FlushFileBuffers(g_MessageContext.m_hLogFile))
			return false;
		g_cFlushLines = g_fFlushEachLine ? 0 : cMinLinesToFlush;
	}
	else
		g_cFlushLines--;

	return true;
}

bool MsiUIMessageContext::InitializeLog(bool fDynamicLog)
{
	if (ENG::LoggingEnabled())
		return true;

	if (g_dwLogMode == 0 && g_scServerContext == scClient)
	{
		CAPITempBuffer<ICHAR, 25> rgchLogMode;
		GetStringPolicyValue(szLoggingValueName, fTrue, rgchLogMode);
		if ( (ICHAR *)rgchLogMode && *rgchLogMode)
		{
			DWORD dwMode = 0;

			const int iFlushBit = 1 << (cchLogModeCharsMax + lmaFlushEachLine);

			if (ERROR_SUCCESS == StringToModeBits(rgchLogMode, szLogChars, dwMode))
			{
				g_fFlushEachLine = false;

				if (dwMode & iFlushBit)
				{
					g_fFlushEachLine = true;
					dwMode &= ~iFlushBit;
				}

				g_dwLogMode = dwMode;
				fDynamicLog = fTrue;
			}
		}
	}

	if(fDynamicLog)
	{
		m_fLoggingFromPolicy = true; // tells us to stop using this log when the install is over

		// generate a log on the fly, need a name for log
		MsiString strFile;
		IMsiServices* piServices = ENG::LoadServices();
		MsiString strTempDir = ENG::GetTempDirectory();
		PMsiPath pPath(0);
		PMsiRecord pError = piServices->CreatePath(strTempDir,*&pPath);

		if(!pError)
			pError = pPath->TempFileName(TEXT("MSI"),TEXT("LOG"),fFalse,*&strFile, 0);

		if(!pError)
		{
			strFile.CopyToBuf(g_szLogFile,sizeof(g_szLogFile)/sizeof(ICHAR)-1);
			if (g_dwLogMode == 0)
				g_dwLogMode = INSTALLLOGMODE_ERROR|INSTALLLOGMODE_WARNING;
		}

		ENG::FreeServices();

		if(pError)
			return false;
	}

	if (g_dwLogMode == 0) //!! is this right?
		return true;
	if (g_szLogFile == 0)   //!! we don't support routing log to external UI yet
		return false;

	if ((g_dwLogMode & (INSTALLLOGMODE_INFO|INSTALLLOGMODE_VERBOSE)) == INSTALLLOGMODE_VERBOSE)
	{
		// VERBOSE turns on INFO
		g_dwLogMode |= INSTALLLOGMODE_INFO;
	}

	if (!ENG::CreateLog(g_szLogFile, g_fLogAppend ? true : false))
		return false;
	m_iLogMode = g_dwLogMode & iLogMessages;
	SetDiagnosticMode(); // set mode again in case it was set before log mode set

	if(FDiagnosticModeSet(dmVerboseLogging))
	{
		ICHAR rgchModule[MAX_PATH];
		int cch = WIN::GetModuleFileName(NULL, rgchModule, MAX_PATH);

#ifdef DEBUG
#define _debugflavor_ __TEXT("DEBUG")
#else
#define _debugflavor_ __TEXT("SHIP")
#endif

#ifdef UNICODE
#define _unicodeflavor_ __TEXT("UNICODE")
#else
#define _unicodeflavor_ __TEXT("ANSI")
#endif

		ICHAR rgchLogEntry[MAX_PATH+200]; // enough for module path plus text plus dates, etc...
		wsprintf(rgchLogEntry, TEXT("=== Verbose logging started: %s  %s  Build type: %s %s %d.%02d.%04d.%02d  Calling process: %s ==="),
					((const IMsiString&)g_MsiStringDate).GetString(), ((const IMsiString&)g_MsiStringTime).GetString(),
					_debugflavor_, _unicodeflavor_, rmj, rmm, rup, rin, rgchModule);

		WriteLog(rgchLogEntry); // DEBUGMSG doesn't work outside of MainEngineThread
	}

	return true;
}

bool LogRecord(IMsiRecord& riRecord)
{
	if (!ENG::LoggingEnabled())
		return true;  // else we must test at point of call
	MsiString istrData(riRecord.FormatText(fTrue));
	return ENG::WriteLog(istrData);
}

void GetHomeEnvironmentVariables(const IMsiString*& rpiProperties)
{
	MsiString strCommandLine;
	if (!g_fWin9X && (g_iMajorVersion < 5 || (g_iMajorVersion == 5 && g_iMinorVersion ==0))) // CreateEnvironmentBlock on NT4 and Win2k doesn't set these 2 variables
	{
		const ICHAR* rgszEnvVarsToPass[] = {
			TEXT("HOMEPATH"),
			TEXT("HOMEDRIVE"),
			TEXT("HOMESHARE"),
			0,
		};
		
		const ICHAR** szEnv = rgszEnvVarsToPass;
		do{
			ICHAR rgchEnvVar[MAX_PATH+1] = {0};
			ICHAR rgchTmp[1024];
			WIN::GetEnvironmentVariable(*szEnv, rgchEnvVar, sizeof(rgchEnvVar)/sizeof(ICHAR));
			wsprintf(rgchTmp, TEXT(" %%%s=\"%s\""), *szEnv, rgchEnvVar);
			strCommandLine += rgchTmp;
		}while(*(++szEnv));
	}
	strCommandLine.ReturnArg(rpiProperties);
}

void DumpEnvironment()
{
	DEBUGMSGV("START Environment block dump:");
	WCHAR* pchEnviron = GetEnvironmentStringsW();

	WCHAR* pch = pchEnviron;
	while (*pch)
	{
		DEBUGMSGV1(L"%s", pch);
		while (*pch++)
			;
	}
	DEBUGMSGV("END Environment block dump:");

	FreeEnvironmentStringsW(pchEnviron);
}

#ifndef FAST_BUT_UNDOCUMENTED
enum esceAction
{
	esceNormal, 
	esceSetAllToBlank,
	esceSkipPath
};

bool SetCurrentEnvironmentVariables(WCHAR* pchEnvironment, const esceAction eAction)
// Sets each environment variable in the block pchEnvironment into the
// current process' environment block by calling WIN::SetEnvironmentVariable
{
	WCHAR* pch = pchEnvironment;
	WCHAR* pchName;
	BOOL fStatus = TRUE;

	if (pch)
	{
		while (*pch)
		{
			// save pointer to beginning of name

			pchName = pch;

			// skip possible leading equals sign

			if (*pch == '=')
				pch++;

			// advance to equals sign separating name from value

			while (*pch != '=')
			{
				Assert(*pch != 0);
				pch++;
			}

			// null-terminate name, overwriting equals sign

			*pch++ = 0;

			// set the value. pchName now points to the name and pch points to the value

			if (esceSetAllToBlank == eAction)
			{
				AssertNonZero(fStatus = WIN::SetEnvironmentVariableW(pchName, 0));
#ifdef DEBUG
				if (GetTestFlag('V'))
					DEBUGMSGV2(L"Setting env var %s=%s", pchName, L"" );
#endif
			}
			else
			{
				if ((esceNormal == eAction) || ((esceSkipPath == eAction) && (0 != lstrcmpiW(pchName, L"PATH"))))
				{
					AssertNonZero(fStatus = WIN::SetEnvironmentVariableW(pchName, pch));
#ifdef DEBUG
					if (GetTestFlag('V'))
						DEBUGMSGV2(L"Setting env var %s=%s", pchName, pch);
#endif
				}
				else
				{
#ifdef DEBUG
					if (GetTestFlag('V'))
						DEBUGMSGV1(L"Skipping env var %s", pchName);
#endif
				}
			}

			if ( ! fStatus )
				return false;



			// advance over the value

			while (*pch++ != 0)
				;

			// we're now positioned at the next name, or at the block's null
			// terminator and we're ready to go again
		}
	}

	return true;
}

bool CopyEnvironmentBlock(CAPITempBufferRef<WCHAR>& rgchDest, WCHAR* pchEnvironment)
// Copies the environment block pchEnvironment into rgchDest
{
	WCHAR* pch = pchEnvironment;
	if (pch)
	{
		while (*pch != 0)
		{
			while (*pch++ != 0)
				;
		}
	}

	Assert(((pch - pchEnvironment) + 1) < INT_MAX);                 //--merced: we're typecasting to int32 below, it better be in range.
	rgchDest.SetSize((int)((pch - pchEnvironment) + 1));
	if ( (WCHAR *)rgchDest )
	{
		memcpy(rgchDest, pchEnvironment, rgchDest.GetSize() * sizeof(WCHAR));
		return true;
	}

	return false;
}
#endif // FAST_BUT_UNDOCUMENTED

void RemoveBlankEnvironmentStrings()
{
	IMsiServices* piServices = ENG::LoadServices();
	if (!piServices)
	{
		Assert(0);
		return;
	}

	PMsiRegKey     pEnvironment(0);
	PMsiRegKey     pRoot(0);
	PEnumMsiString pValueEnum(0);
	PMsiRecord     pError(0);

	for (int c=0; c<2; c++)
	{
		if (c == 0)
		{
			// check machine environment
			pRoot = &piServices->GetRootKey(rrkLocalMachine);
			pEnvironment = &pRoot->CreateChild(szMachineEnvironmentSubKey);
		}
		else
		{
			// check user environment; HKCU should already be set to the correct user

			pRoot = &piServices->GetRootKey(rrkCurrentUser);
			pEnvironment = &pRoot->CreateChild(szUserEnvironmentSubKey);
		}

		AssertRecord(pEnvironment->GetValueEnumerator(*&pValueEnum));

		MsiString strValueName;
		MsiString strValue;

		if (pValueEnum)
		{
			while((pValueEnum->Next(1, &strValueName, 0)) == S_OK)
			{
				if ((pError = pEnvironment->GetValue(strValueName, *&strValue)) || strValue.TextSize())
					continue;

				// remove the blank environment variable

				AssertRecord(pEnvironment->RemoveValue(strValueName, 0));
			}
		}
	}

	ENG::FreeServices();
}

bool BlankCurrentEnvironment()
{
	CAPITempBuffer<WCHAR, 1024> rgchEnvironment; // CopyEnvironmentBlock may resize

	WCHAR* pchCurrentEnvironment = WIN::GetEnvironmentStringsW();
	Assert(pchCurrentEnvironment);

	bool fResult = false;
	if ( pchCurrentEnvironment )
	{
		// SetCurrentEnvironmentVariables is intrusive (but restorative), so must make a copy
		if (CopyEnvironmentBlock(rgchEnvironment, pchCurrentEnvironment))
		{
			fResult = SetCurrentEnvironmentVariables(rgchEnvironment, esceSetAllToBlank);

			// free current environment block; we're done with it
			WIN::FreeEnvironmentStringsW(pchCurrentEnvironment);
		}
		else
		{
			DEBUGMSGV("Cannot copy environment block");
			Assert(0);
		}
	}

	return fResult;
}

bool MsiUIMessageContext::InitializeEnvironmentVariables()
// add the user's environment variables to our process' environment block
{

	// Only set the environment variables into our service. (our own process.)
	// Running in the normal client, these should already be set.
	// Running in the client under WinLogon will hose WinLogon's variables.

	if (g_scServerContext != scService)
	{
		return true;
	}

	DEBUGMSGV("Initializing environment variables");

	// If the user has blank environment strings then CreateEnvironmentBlock will fail.
	// We'll remove any blanks.

	RemoveBlankEnvironmentStrings();

	DEBUGMSGV("Refreshing system environment block for service");

	WCHAR *pchSystemEnvironment;
	if (USERENV::CreateEnvironmentBlock((void**)&pchSystemEnvironment, NULL, FALSE))
	{
		AssertNonZero(BlankCurrentEnvironment());

		// set each machine environment variable into the current process's environment block
		SetCurrentEnvironmentVariables(pchSystemEnvironment, esceNormal);

		// we're done with the block so destroy it
		USERENV::DestroyEnvironmentBlock(pchSystemEnvironment);
	}
	else
	{
		DEBUGMSGV("Could not refresh system environment");
		AssertSz(0, "Could not refresh system environment");
	}

#ifdef DEBUG
	if (GetTestFlag('V'))
	{
		DEBUGMSGV("Current environment block before setting user's environment variables");
		DumpEnvironment();
	}
#endif

	// create an environment block for the user

	WCHAR *pchUserEnvironment;
	if (!USERENV::CreateEnvironmentBlock((void**)&pchUserEnvironment, IsLocalSystemToken(g_MessageContext.GetUserToken()) ? 0 : g_MessageContext.GetUserToken(), TRUE))
	{

#ifdef DEBUG
		ICHAR rgchDebug[500];
		ICHAR rgchAccount[500];
		Assert(GetAccountNameFromToken(g_MessageContext.GetUserToken(), rgchAccount));
		wsprintf(rgchDebug, TEXT("CreateEnvironmentBlock failed. The most likely reason for this is ")
					TEXT("passing a LocalSystem token to it. The token passed to it was for the account: %s"),
					rgchAccount);
		AssertSz(0, rgchDebug);
#endif
		return false;
	}

#ifdef FAST_BUT_UNDOCUMENTED

	// Make the block we just created the current environment, and save a pointer to
	// the old environment so we can restore it later. This RTL function is faster
	// and equivalent to what we do below, but it's undocumented.

	// NOTE: This function returns a garbage value upon success so we have to assume
	//       it's successful. There's not much room for failure so this should be fine.

	NTDLL::RtlSetCurrentEnvironment(pchUserEnvironment, (void**)&m_pchEnvironment);

#else

	// save current environment variables so we can restore
	// them when the install is complete

	bool fCopy = false;
	WCHAR* pchEnvironment = WIN::GetEnvironmentStringsW();
	Assert(pchEnvironment);

	if ( pchEnvironment )
	{
		if ( CopyEnvironmentBlock(g_rgchEnvironment, pchEnvironment) )
		{
			// set each user environment variable into the current process's environment block

			fCopy = SetCurrentEnvironmentVariables(pchUserEnvironment, esceSkipPath);
		}

		// we don't need the environment string pointer anymore; we've copied the strings

		WIN::FreeEnvironmentStringsW(pchEnvironment);
	}

	// we're done with the block so destroy it
	USERENV::DestroyEnvironmentBlock(pchUserEnvironment);

#endif // FAST_BUT_UNDOCUMENTED

	DEBUGMSG("Current environment block after setting user's environment variables");
	DumpEnvironment();

	// refresh test flags that are based on environment variables.
	SetTestFlags();

	return fCopy;
}

bool MsiUIMessageContext::RestoreEnvironmentVariables()
// remove the user's environment variables to our process' environment
// block, restoring the block to what it was when the install began
{
	// if we're not running as the service then there's nothing
	// to restore

	if (g_scServerContext != scService)
		return true;

	DEBUGMSG("Restoring environment variables");

#ifdef FAST_BUT_UNDOCUMENTED

	// Restore our original environment block. We pass as the second parameter
	// here because we don't want the previous environment returned to us.
	// RtlSetCurrentEnvironment will free the memory associated with this
	// previous environment. This RTL function is faster and equivalent to what
	// we do below, but it's undocumented.

	// NOTE: This function returns a garbage value upon success so we have to assume
	//       it's successful. There's not much room for failure so this should be fine.

	NTDLL::RtlSetCurrentEnvironment(m_pchEnvironment, 0);

#else

	// set current environment variables to blank. need to copy the block
	// because SetCurrentEnvironmentVariable mucks with it

	AssertNonZero(BlankCurrentEnvironment());

	bool fCopy = false;
	// restore our original environment variables
	// even if the above failed we are best off attempting to set the old 
	// values on top

	if ( g_rgchEnvironment[0] )
		fCopy = SetCurrentEnvironmentVariables(g_rgchEnvironment, esceNormal);

#endif

#ifdef DEBUG
	if (GetTestFlag('V'))
	{
		DEBUGMSG("Current environment block after restoring original environment block");
		DumpEnvironment();
	}
#endif
	return fCopy;
}



//____________________________________________________________________________
//
// Engine message formatting
//____________________________________________________________________________

enum easEnum
{
	easAction = 1,   // non-localized name of action, use to find action
	easActionName,   // localized action name for execute record, ":", template
	easCondition,    // condition expression, action skipped if False
	easNextEnum,
	easActionTemplate = 3, // format template for ActionData record
};

const ICHAR sqlErrorMessage[] =
TEXT("SELECT `Message` FROM `Error` WHERE `Error` = ?");


imsEnum CMsiEngine::MessageNoRecord(imtEnum imt)
{
	return Message(imt, *g_piNullRecord);
}

bool ShouldGoToEventLog(imtEnum imt)
{
	int imsg = (unsigned)(imt & ~iInternalFlags) >> imtShiftCount;  // message header message

	if (imsg == (imtError >> imtShiftCount) ||
		(imsg == (imtOutOfDiskSpace >> imtShiftCount)) ||
		(imt & imtSendToEventLog))
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool IsNotAnError(int iError) { return iError == idbgCreatedFont; }


struct DebugErrorString
{
	int iErrNum;
	const ICHAR* szString;
};

#define IShipError(a,b)
#define IDebugError(a,b,c) { (b), TEXT(c) },
DebugErrorString g_rgDebugErrors[] = {
#include "debugerr.h"
	{0, 0}
};

const int g_cDebugErrors = sizeof(g_rgDebugErrors)/sizeof(DebugErrorString);

#undef IShipError
#undef IDebugError

const IMsiString& GetDebugErrorString(int iError)
{
	// find the debug string in our global table
	// NOTE: we could do a fancy binary search here, but this function won't be called very often
	MsiString strRet;

	// 0th element is a debug error prefix
	for(int i = 1; i < g_cDebugErrors; i++)
	{
		if(iError == g_rgDebugErrors[i].iErrNum)
		{
			strRet = g_rgDebugErrors[0].szString;
			strRet += g_rgDebugErrors[i].szString;
		}
	}

	return strRet.Return();
}

imsEnum CMsiEngine::Message(imtEnum imt, IMsiRecord& riRecord)
{
	const IMsiString* pistrTemp;
	int iSuppressLog = 0;   // set to imtSuppressLog to disable logging of this message
	int imsg = (unsigned)(imt & ~iInternalFlags) >> imtShiftCount;  // message header message
	if (m_piParentEngine) // if nested install, route messages to parent engine
	{
		if (imsg == (imtCommonData  >> imtShiftCount))
			return imsOk;  //!! ignore nested parameters - keep parents' - for all paramters??
	}
	MsiString strMessageTemplate;

	imsEnum imsReturn = imsNone;
	if(m_scmScriptMode != scmRunScript)
	{
		if(imsg == (imtActionStart >> imtShiftCount))
		{
			// we are about to send an ActionStart message from an action, set the flag
			m_fDispatchedActionStart = fTrue;
		}
		else if(!m_fDispatchedActionStart && m_pCachedActionStart && !m_fInExecuteRecord &&
				  (imsg == imtActionData >> imtShiftCount))
		{
			// progress message from an action, need to dispatch ActionStart message
			m_scmScriptMode = scmIdleScript;
			imsReturn = Message(imtActionStart, *m_pCachedActionStart);
			m_fDispatchedActionStart = fTrue;
			if (imsReturn == imsCancel)
				return imsReturn;
		}
	}

	bool fOnlyOK = false;
	MsiString strDebugErrorTemplate;
	switch(imsg)
	{
	case imtCommonData  >> imtShiftCount: // [1] == icmtLangId: [2] LANGID  [3] codepage
												     // [1] == icmtCaption: [2] caption
												     // [1] == icmtCancel: [2] enable/disable cancel button
		if(riRecord.GetInteger(1) == icmtCaption)
		{
			// need to format string
			riRecord.SetMsiString(2, *MsiString(FormatText(*MsiString(riRecord.GetMsiString(2)))));
		}
		pistrTemp = m_rgpiMessageHeader[imsg];
		if (pistrTemp)
		{
			strMessageTemplate = TEXT("{{");
			strMessageTemplate += *pistrTemp;
			strMessageTemplate += TEXT("}}");
		}
		else
			strMessageTemplate = TEXT("{{[1]:[2] [3]}}");
		break;

	case imtInfo        >> imtShiftCount: // informative message, no action should be taken
	case imtWarning        >> imtShiftCount: // warning message, field[1] is error, not fatal
	case imtError          >> imtShiftCount: // error message, field[1] is error
	case imtUser           >> imtShiftCount: // request message
	case imtFatalExit      >> imtShiftCount: // fatal exit message from server to client
	case imtOutOfDiskSpace >> imtShiftCount:
	{
		int iError = riRecord.GetInteger(1);
		if (iError >= imsgStart) // ignore messages out of range
		{
			MsiString istrMessage = riRecord.GetMsiString(0);
			if (istrMessage.TextSize() == 0)
			{
				istrMessage = GetErrorTableString(iError);
				if ( istrMessage.TextSize() == 0 )
				{
					// don't have an error string - need to display on an "OK" button
					// and return imsNone below
					fOnlyOK = true;
					imt = imtEnum(imt & imtTypeMask);

					if (iError >= idbgBase && !IsNotAnError(iError))
					{
						strDebugErrorTemplate = GetDebugErrorString(iError);
						imsg = imsgDebugError;
					}
					else if (m_rgpiMessageHeader[imsgDefaultError])
					{
						istrMessage = *m_rgpiMessageHeader[imsgDefaultError];
						istrMessage.Return();  // AddRef
					}
				}
			}
			pistrTemp = m_rgpiMessageHeader[imsg];
			if (pistrTemp)
				strMessageTemplate = *pistrTemp, pistrTemp->AddRef();
			strMessageTemplate += istrMessage;
		}
		break;
	}
	case imtActionStart >> imtShiftCount: // start of action, field[1] is action name
		m_fProgressByData = false;
		if(m_istrLogActions.TextSize())
		{
			// check if we should enable logging for this Action
			MsiString strAction = riRecord.GetMsiString(easAction);
			MsiString strDelimPreAction = MsiString(MsiString(*TEXT(";")) + strAction);
			MsiString strDelimPostAction = MsiString(strAction + MsiString(*TEXT(";")));
			MsiString strDelimPrePostAction = strDelimPreAction + MsiString(*TEXT(";"));
			if(m_istrLogActions.Compare(iscExactI, strAction) ||
				m_istrLogActions.Compare(iscStartI, strDelimPostAction) ||
				m_istrLogActions.Compare(iscEndI, strDelimPreAction) ||
				m_istrLogActions.Compare(iscWithinI, strDelimPrePostAction))
			{
				m_fLogAction = fTrue;
			}
			else
			{
				m_fLogAction = fFalse;
				iSuppressLog = imtSuppressLog;
			}
		}
		if (m_piActionDataFormat)
			m_piActionDataFormat->Release(), m_piActionDataFormat = 0;
		if (m_piActionDataLogFormat)
			m_piActionDataLogFormat->Release(), m_piActionDataLogFormat = 0;
		pistrTemp = m_rgpiMessageHeader[imsgActionStart];
		if (pistrTemp)
			strMessageTemplate = *pistrTemp, pistrTemp->AddRef();
		if (!riRecord.IsNull(easActionTemplate))
		{
			//!! should be a more efficient way of doing this
			MsiString strFormat = TEXT("{{");
			strFormat += MsiString(riRecord.GetMsiString(easAction));
			strFormat += TEXT(": }}");
			strFormat += MsiString(riRecord.GetMsiString(easActionTemplate));
			m_piActionDataFormat = strFormat, m_piActionDataFormat->AddRef();
		}

		{
		MsiString strDescription = riRecord.GetMsiString(2);
		riRecord.SetMsiString(2, *MsiString(FormatText(*strDescription)));
		}
		break;
	case imtActionData >> imtShiftCount:  // data associated with individual action item
		// set data format template
		if (m_piActionDataFormat)
			strMessageTemplate = *m_piActionDataFormat, m_piActionDataFormat->AddRef();
		if (!m_fLogAction)   // selectively logging actions, suppress data from other actions
			iSuppressLog = imtSuppressLog;
		// trigger progress if data record driven
		if (m_fProgressByData)
		{
			using namespace ProgressData;
			PMsiRecord pRecord = &m_riServices.CreateRecord(3);
			pRecord->SetInteger(imdSubclass, iscProgressReport);
			pRecord->SetInteger(imdIncrement, 0);
			imsReturn = Message(imtProgress, *pRecord);
			if(imsReturn == imsCancel || imsReturn == imsAbort)  // cancel button hit
				return imsReturn;
		}
		break;
	case imtProgress >> imtShiftCount:    // progress gauge info, field[1] is units of 1/1024
		if (riRecord.GetInteger(ProgressData::imdSubclass) == ProgressData::iscActionInfo)
			m_fProgressByData = riRecord.GetInteger(ProgressData::imdType) != 0;
		else if (riRecord.GetInteger(ProgressData::imdSubclass) == ProgressData::iscProgressAddition)
			m_iProgressTotal += riRecord.GetInteger(ProgressData::imdProgressTotal);
		break;
	};

	if (strDebugErrorTemplate.TextSize())
	{
		Assert(riRecord.IsNull(0));
		riRecord.SetMsiString(0, *MsiString(FormatText(*strDebugErrorTemplate)));
		g_MessageContext.Invoke(imtInfo, &riRecord); // ignore return
		riRecord.SetNull(0);
	}

	if (!strMessageTemplate.TextSize())  // no template supplied above
		strMessageTemplate = riRecord.GetMsiString(0); // check if record has a template
	if (strMessageTemplate.TextSize())
		riRecord.SetMsiString(0, *MsiString(FormatText(*strMessageTemplate)));

	imsReturn = g_MessageContext.Invoke(imtEnum(imt | iSuppressLog), &riRecord);
	if(fOnlyOK)
	{
		// buttons changed to just OK, need to change return type to imsNone as caller must handle
		// that value
		imsReturn = imsNone;
	}

	if ( ShouldGoToEventLog(imt) )
	{
		int iError = riRecord.GetInteger(1);

		if ( iError != iMsiStringBadInteger )
		{
			int iEventId = iError >= idbgBase ? EVENTLOG_TEMPLATE_ERROR_5 : EVENTLOG_ERROR_OFFSET + iError;
			ReportToEventLog(EVENTLOG_ERROR_TYPE,
								  iEventId,
								  riRecord);
		}
		else
		{
			ReportToEventLog(EVENTLOG_ERROR_TYPE,
								  EVENTLOG_TEMPLATE_EXCEPTION,
								  riRecord);
		}
	}

	return imsReturn;
}

// Only send this message once every 150 milliseconds
const unsigned int lTickMin = 150;

imsEnum CMsiEngine::ActionProgress()
{

	DWORD lTickCur;

	if (((int)(m_lTickNextProgress - (lTickCur = GetTickCount()))) > 0)
		return imsOk;

	m_lTickNextProgress = lTickCur + lTickMin;

	if (!m_pActionProgressRec)
	{
		using namespace ProgressData;
		m_pActionProgressRec = &m_riServices.CreateRecord(2);
		AssertNonZero(m_pActionProgressRec->SetInteger(imdSubclass, iscProgressReport));
		AssertNonZero(m_pActionProgressRec->SetInteger(imdIncrement, 0));
	}

	return Message(imtProgress, *m_pActionProgressRec);
}


// LoadLibrary which first looks in this DLL's directory

extern HINSTANCE g_hInstance;

HINSTANCE MsiLoadLibrary(const ICHAR* szModuleName, Bool fDataOnly)
{
	ICHAR rgchPath[MAX_PATH];   // load full path first in this directory
	int cch = WIN::GetModuleFileName(g_hInstance, rgchPath, MAX_PATH);
	ICHAR* pch = rgchPath + cch;
	while (*(--pch) != chDirSep) ;
	IStrCopy(pch + 1, szModuleName);
	HINSTANCE hInstance = WIN::LoadLibraryEx(rgchPath, 0,
									fDataOnly ? LOAD_LIBRARY_AS_DATAFILE : 0);
	if (!hInstance)
		hInstance = WIN::LoadLibraryEx(szModuleName, 0,     // probably in system
									fDataOnly ? LOAD_LIBRARY_AS_DATAFILE : 0);
	return hInstance;
}

int GetInstallerMessage(UINT iError, ICHAR* rgchBuf, int cchBuf)
{
	DWORD cchMsg = WIN::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, iError, 0, rgchBuf, cchBuf, 0);
	if (cchMsg == 0)  // message not in system message file
	{
		if (g_hInstance != 0)
			if (MsiLoadString(g_hInstance, iError, rgchBuf, cchBuf, 0))
				cchMsg = IStrLen(rgchBuf);
	}
	else if (cchMsg >= 2)
		cchMsg -= 2; // remove CR/LF
	rgchBuf[cchMsg] = 0;
	return cchMsg;
}

const int cchMessageBuffer = 512;

const IMsiString& GetInstallerMessage(UINT iError)
{
	ICHAR rgchBuffer[cchMessageBuffer];
	int cchMsg = GetInstallerMessage(iError, rgchBuffer, cchMessageBuffer);
	const IMsiString* pistr = &g_MsiStringNull;
	if (cchMsg)
		pistr->SetString(rgchBuffer, pistr);
	return *pistr;
}

imsEnum CMsiEngine::LoadHandler()
{
	if (m_piParentEngine)
		return imsNone;
	g_MessageContext.m_piEngine = this;
	imsEnum ims = g_MessageContext.Invoke(imtLoadHandler, 0);
	return ims;
}

void CMsiEngine::ReleaseHandler(void)
{
	if (!m_piParentEngine)
		g_MessageContext.Invoke(imtFreeHandler, 0);
}

CMsiCustomActionManager* CMsiEngine::GetCustomActionManager()
{
	AssertSz(g_scServerContext != scService, TEXT("Wrong context for engine's custom action manager"));

	CMsiCustomActionManager* pManager = NULL;
	EnterCriticalSection(&m_csCreateProxy);

	// always use the CA Manager from the parent install
	if (m_piParentEngine)
	{
		pManager = m_piParentEngine->GetCustomActionManager();
	}
	else
	{
		// the engine only stores the custom action manager on the client side
		// in the service, the configuration manager is responsible for holding the custom action manager
		// the client cannot create elevated custom action servers, so it does not have to worry about 
		// remapping HKCU
		if (!m_pCustomActionManager)
			m_pCustomActionManager = new CMsiCustomActionManager(/* fRemapHKCU */ false);

		pManager = m_pCustomActionManager;
	}
	LeaveCriticalSection(&m_csCreateProxy);
	return pManager;
}

UINT CMsiEngine::ShutdownCustomActionServer()
{
	EnterCriticalSection(&m_csCreateProxy);
	if (m_pCustomActionManager)
	{
		m_pCustomActionManager->ShutdownCustomActionServer();
		delete m_pCustomActionManager;
		m_pCustomActionManager = 0;
	}
	LeaveCriticalSection(&m_csCreateProxy);
	return ERROR_SUCCESS;
};


IMsiHandler* CMsiEngine::GetHandler() //!!# drop this function?
{
	if (m_piParentEngine)
		return 0;
	if (g_MessageContext.m_piHandler)
		g_MessageContext.m_piHandler->AddRef();
	return g_MessageContext.m_piHandler;
}

//____________________________________________________________________________
//
// Action definitions
//____________________________________________________________________________

// scripting engine definitions
#undef  DEFINE_GUID  // force GUID initialization
#define DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
	const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <activscp.h> // ActiveScript Interfaces and IIDs
const GUID IID_VBScript = {0xb54f3741L,0x5b07,0x11cf,{0xa4,0xb0,0x00,0xaa,0x00,0x4a,0x55,0xe8}};
const GUID IID_JScript  = {0xf414c260L,0x6ac0,0x11cf,{0xb6,0xd1,0x00,0xaa,0x00,0xbb,0xbb,0x58}};

const ICHAR sqlCustomAction[] =
	TEXT("SELECT `Action`,`Type`,`Source`,`Target`, NULL FROM `CustomAction` WHERE `Action` = '%s'");
enum icolCustomAction
{
	icolAction = 1,
	icolActionType,
	icolSource,
	icolTarget,
	icolContextData, // scheduled execution record only, not in table
}; // NOTE: Assumption made that columns in execution record are identical to table query

const ICHAR sqlCustomActionFile[] =
	TEXT("SELECT `FileName`, `Directory_` FROM `File`,`Component` WHERE `File`='%s' AND `Component_`=`Component`");

const ICHAR sqlCustomActionBinary[] =
	TEXT("SELECT `Data` FROM `Binary` WHERE `Name`='%s'");

//____________________________________________________________________________
//
// CScriptSite definition - client for scripting engine
//____________________________________________________________________________

class CScriptSite : public IActiveScriptSite, public IActiveScriptSiteWindow
{
 public:  // external methods
	friend CScriptSite* CreateScriptSite(const IID& riidLanguage, IDispatch* piHost, HWND hwndParent, LANGID langid);
	friend void DestroyScriptSite(CScriptSite*& rpiScriptSite);
	HRESULT ParseScript(const TCHAR* szFile, int cchScriptMax);
	HRESULT CallScriptFunction(const TCHAR* szFunction);
	HRESULT GetIntegerResult(int& riResult);
//      HRESULT GetStringResult(const WCHAR*& rszResult); // pointer valid until next CallScriptFunction
	HRESULT      GetErrorCode();
	const TCHAR* GetErrorObjName();
	const TCHAR* GetErrorObjDesc();
	const TCHAR* GetErrorSourceLine();
	int          GetErrorLineNumber();
	int          GetErrorColumnNumber();
	void    ClearError();  // release error strings
 private: // IUnknown virtual methods implemented
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj);
	ULONG   __stdcall AddRef();
	ULONG   __stdcall Release();
 private: // IActiveScriptSite virtual methods implemented
	HRESULT __stdcall GetLCID(LCID* plcid);
	HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppiunkItem, ITypeInfo** ppti);
	HRESULT __stdcall GetDocVersionString(BSTR* pszVersion);
	HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pexcepinfo);
	HRESULT __stdcall OnStateChange(SCRIPTSTATE ssScriptState);
	HRESULT __stdcall OnScriptError(IActiveScriptError* pscripterror);
	HRESULT __stdcall OnEnterScript();
	HRESULT __stdcall OnLeaveScript();
 private: // IActiveScriptSiteWindow virtual methods implemented
	HRESULT __stdcall GetWindow(HWND* phwnd);
	HRESULT __stdcall EnableModeless(BOOL fEnable);
 private: // internal methods
	CScriptSite(HWND hwndParent, LANGID langid);
  ~CScriptSite();
	HRESULT AttachScriptEngine(const IID& iidLanguage, IDispatch* piHost);
	HRESULT CloseScriptEngine();
	void    SaveErrorString(const TCHAR*& rszSave, BSTR szData);
 private: // internal data
	int         m_iRefCnt;
	SCRIPTSTATE m_ssScriptState;
	HWND        m_hwnd;
	LANGID      m_langid;
	int         m_iCodePage;
	bool        m_fCoInitialized;
	IActiveScript*      m_piScriptEngine;
	IActiveScriptParse* m_piScriptParse;
	IDispatch*          m_piHost;
	VARIANT     m_varResult;
 private: // set by OnScriptError callback
	HRESULT       m_hrError;
	const TCHAR*  m_szErrorObj;
	const TCHAR*  m_szErrorDesc;
	const TCHAR*  m_szSourceLine;
	ULONG         m_iErrorLine;
	LONG          m_iErrorColumn;
};
inline HRESULT      CScriptSite::GetErrorCode()         {return m_hrError;}
inline const TCHAR* CScriptSite::GetErrorObjName()      {return m_szErrorObj;}
inline const TCHAR* CScriptSite::GetErrorObjDesc()      {return m_szErrorDesc;}
inline const TCHAR* CScriptSite::GetErrorSourceLine()   {return m_szSourceLine;}
inline int          CScriptSite::GetErrorLineNumber()   {return m_iErrorLine;}
inline int          CScriptSite::GetErrorColumnNumber() {return m_iErrorColumn;}

//____________________________________________________________________________
//
//  Custom action thread management
//____________________________________________________________________________

// class holding data required for cleanup after custom action termination

class CActionThreadData
{
public:
	CActionThreadData(IMsiMessage& riMessage, CMsiEngine* piEngine, const ICHAR* szAction, int icaFlags,
					  const IMsiString* pistrActionEndLogTemplate, bool fRunScriptElevated, bool fAppCompat,
					  const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID);
  ~CActionThreadData();
	void InitializeRemoteDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall);
	Bool InitializeDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall);
	void InitializeEXE(const IMsiString& ristrPath, const IMsiString& ristrCommandLine);
	void InitializeInstall(const IMsiString& ristrProduct, const IMsiString& ristrCommandLine,iioEnum iioOptions);
	Bool CreateTempFile(IMsiStream& riStream, const IMsiString*& rpiPath);
	iesEnum RunThread();
	MsiString           m_strAction;   // name of action
	int                 m_icaFlags;    // custom action type flags
	HANDLE              m_hThread;     // thread handle that called action
	MSIHANDLE           m_hMsi;        // MSI engine handle to close
	DWORD               m_dwThreadId;  // thread ID of handle creator
	DWORD               m_dwRunThreadId; // ID of actualy thread being run
	HINSTANCE           m_hLib;        // DLL handle for DLL action
	PCustomActionEntry  m_pfEntry;     // DLL entry point address
	const IMsiString*   m_pistrTemp;   // temporary file to delete
	const IMsiString*   m_pistrProduct;// product for nested install, source for EXE action
	const IMsiString*   m_pistrCmdLine;// command line for EXE action or nested install
	const IMsiString*   m_pistrActionEndLogTemplate; // template for action end log message
	CMsiEngine*         m_piEngine;    // engine calling this custom action - NULL if called from script
	IMsiMessage&        m_riMessage;   // progress message handler, client engine or server proxy
	CActionThreadData*  m_pNext;       // next in linked list of active actions
	PThreadEntry        m_pfThread;    // thread entry point
	iioEnum             m_iioOptions;  // options for nested install
	bool                m_fDisableMessages; // set if the custom action is a DLL action called from the UI thread
	bool                m_fElevationEnabled; // if false, CAs will always impersonate, even if marked to elevate
	bool                m_fAppCompat;  // true if this package has potential custom action app compat shims
	GUID                m_guidAppCompatDB; 
	GUID                m_guidAppCompatID;
};

DWORD WINAPI CustomDllThread(CActionThreadData* pActionData);
DWORD WINAPI CustomRemoteDllThread(CActionThreadData* pActionData);
DWORD WINAPI CustomExeThread(CActionThreadData* pActionData);
DWORD WINAPI NestedInstallThread(CActionThreadData* pActionData);

CActionThreadData::CActionThreadData(IMsiMessage& riMessage, CMsiEngine* piEngine, const ICHAR* szAction,
				     int icaFlags, const IMsiString* pistrActionEndLogTemplate,
									 bool fElevationEnabled, bool fAppCompat,
					 const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID)
    : m_riMessage(riMessage), m_piEngine(piEngine), m_strAction(szAction)
	, m_icaFlags(icaFlags), m_pistrActionEndLogTemplate(pistrActionEndLogTemplate)
	, m_pistrTemp(0), m_pistrCmdLine(0), m_pistrProduct(0)
	, m_hMsi(0), m_hLib(0), m_hThread(0), m_iioOptions((iioEnum)0), m_fDisableMessages(false)
	, m_fElevationEnabled(fElevationEnabled), m_fAppCompat(fAppCompat)
{
	// don't hold ref to m_piEngine - will stay around longer than thread
	ENG::InsertInCustomActionList(this);
	if(m_pistrActionEndLogTemplate)
		m_pistrActionEndLogTemplate->AddRef();
	if (fAppCompat && pguidAppCompatDB)
		memcpy(&m_guidAppCompatDB, pguidAppCompatDB, sizeof(m_guidAppCompatDB));
	else
		memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
	if (fAppCompat && pguidAppCompatID)
		memcpy(&m_guidAppCompatID, pguidAppCompatID, sizeof(m_guidAppCompatID));
	else
		memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));
}

CActionThreadData::~CActionThreadData()
{
	if ((m_icaFlags & icaTypeMask) == icaDll)
	{
		if (m_hLib)
			AssertNonZero(WIN::FreeLibrary(m_hLib));
		AssertZero(CloseMsiHandle(m_hMsi, m_dwThreadId));

		// only Win9X needs to close the handles here. On WindowsNT/2000, the actions are
		// run in a different process, and must be closed based on the thread Id in the
		// remote process
		UINT cHandles = 0;
		if (m_dwRunThreadId && g_fWin9X && ((cHandles = CheckAllHandlesClosed(true, m_dwRunThreadId)) != 0))
		{
			// if messages were disabled for this action, we certainly can't post one now.
			if (!m_fDisableMessages)
				m_riMessage.Message(imtInfo, *PMsiRecord(::PostError(Imsg(idbgCustomActionLeakedHandle), *m_strAction, cHandles)));
		}
	}

	if (m_pistrTemp)   // temp file created from Binary table stream
	{
		CElevate elevate; // elevate to remove file in %windows%\msi folder

		BOOL fDeleted = WIN::DeleteFile(m_pistrTemp->GetString());
		if (!fDeleted && (m_icaFlags & (icaTypeMask | icaAsync | icaContinue)) != (icaExe | icaAsync | icaContinue))
		{

			WIN::Sleep(100);  //!! need wait here, as EXE doesn't appear to be deletable for a while
			AssertNonZero(WIN::DeleteFile(m_pistrTemp->GetString())); // not much we can do if this fails
		}
		m_pistrTemp->Release();
	}
	if(m_pistrActionEndLogTemplate)
		m_pistrActionEndLogTemplate->Release();
	RemoveFromCustomActionList(this);
}

void CActionThreadData::InitializeRemoteDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall)
{
	(m_pistrCmdLine = &ristrLibrary)->AddRef();
	(m_pistrProduct = &ristrEntry)->AddRef();
	m_pfThread = (PThreadEntry)CustomRemoteDllThread;
	m_hMsi = hInstall;

	// store thread to free handle from custom action's thread. This
	// could be called via a DoAction() call in another custom action, so
	// we must handle thread impersonation.
	m_dwThreadId = WIN::MsiGetCurrentThreadId();
}

Bool CActionThreadData::InitializeDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall)
{
    // this function should never run on NT/2000. Every DLL should be run out-of-proc
    AssertSz(g_fWin9X, TEXT("Running in-proc DLL on NT."));

    g_MessageContext.DisableTimeout();
    UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS);
    m_hLib = WIN::LoadLibrary(ristrLibrary.GetString());
    WIN::SetErrorMode(uiErrorMode);
    if (m_hLib != 0)
    {
#ifdef UNICODE
		char rgchEntry[100];
		AssertNonZero(WIN::WideCharToMultiByte(CP_ACP, 0, ristrEntry.GetString(), -1, rgchEntry, sizeof(rgchEntry), 0, 0));
		m_pfEntry = (PCustomActionEntry)WIN::GetProcAddress(m_hLib, rgchEntry);
#else
		m_pfEntry = (PCustomActionEntry)WIN::GetProcAddress(m_hLib, ristrEntry.GetString());
#endif
	}
	g_MessageContext.EnableTimeout();
	if (!m_hLib || !m_pfEntry)
	{
		::MsiCloseHandle(hInstall);
		return fFalse;
	}
	m_hMsi = hInstall;

	// store thread to free handle from custom action's thread. This
	// could be called via a DoAction() call in another custom action, so
	// we must handle thread impersonation.
	m_dwThreadId = WIN::MsiGetCurrentThreadId();
	m_pfThread = (PThreadEntry)CustomDllThread;
	return fTrue;
}

void CActionThreadData::InitializeEXE(const IMsiString& ristrPath, const IMsiString& ristrCommandLine)
{
	(m_pistrCmdLine = &ristrCommandLine)->AddRef();
	(m_pistrProduct = &ristrPath)->AddRef();
	m_pfThread = (PThreadEntry)CustomExeThread;
}

void CActionThreadData::InitializeInstall(const IMsiString& ristrProduct, const IMsiString& ristrCommandLine,
														iioEnum iioOptions)
{
	(m_pistrProduct = &ristrProduct)->AddRef();
	m_pistrCmdLine = &ristrCommandLine;   // refcnt bumped by FormatText result
	m_pfThread = (PThreadEntry)NestedInstallThread;
	m_iioOptions = iioOptions;
}

Bool CActionThreadData::CreateTempFile(IMsiStream& riStream, const IMsiString*& rpiPath)
{
	//?? Do we have an impersonation problem here if we're running this on the server and the temp
	//?? directory is on the server? - malcolmh

	CElevate elevate; // elevate in case creating file in %windows%\msi
	ICHAR rgchTempPath[MAX_PATH];

	// this file must be secured, to prevent someone else from tampering with the bits.
	// it will be possible for someone else to read it (to allow impersonation,) and
	// potentially run it, but only with their permissions.
	HANDLE hTempFile = INVALID_HANDLE_VALUE;

	if (RunningAsLocalSystem())
	{
		hTempFile = OpenSecuredTempFile(/*fHidden*/ false, rgchTempPath);
	}
	else
	{
		MsiString strTempFolder = ENG::GetTempDirectory();

		//!! SECURITY:  This needs to be secured to the user, so that another
		// user may not slide in new bits.
		if (WIN::GetTempFileName(strTempFolder, TEXT("MSI"), 0, rgchTempPath) == 0)
			return fFalse; //!! should never happen except permission error

		hTempFile = WIN::CreateFile(rgchTempPath, GENERIC_WRITE, FILE_SHARE_READ, 0,
				TRUNCATE_EXISTING, 0, 0);    // INVALID_HANDLE_VALUE will fail at WriteFile
	}

	char rgbBuffer[512];
	int cbWrite;
	do
	{
		cbWrite = riStream.GetData(rgbBuffer, sizeof(rgbBuffer));
		DWORD cbWritten;
		if (cbWrite && !WIN::WriteFile(hTempFile, rgbBuffer, cbWrite, &cbWritten, 0))
			cbWrite = -1; // force failure, exit loop, test below
	} while (cbWrite == sizeof(rgbBuffer));
	if (hTempFile != INVALID_HANDLE_VALUE)
		WIN::CloseHandle(hTempFile); // LoadLibrary fails if handle left open
	if (cbWrite == -1)  // failure creating temp file
		return fFalse;
	MsiString istrPath = rgchTempPath;
	(m_pistrTemp = istrPath)->AddRef();
	istrPath.ReturnArg(rpiPath);
	return fTrue;
}

iesEnum CActionThreadData::RunThread()
{
	int icaFlags = m_icaFlags;  // need to make copy in case this object deleted
	Bool fAsync = icaFlags & icaAsync ? fTrue : fFalse;

	// Disable messages for synchronous DLL custom actions called from the UI thread. These
	// are typically invoked via the DoAction ControlEvent. If we allow messages through
	// then we'll block in Invoke's critical section and we'll be hung.

	if (((icaFlags & icaTypeMask) == icaDll) && (fAsync == fFalse))
	{
		if (g_MessageContext.IsUIThread())
			m_fDisableMessages = true;
	}

	HANDLE hThread = m_hThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
											m_pfThread, (LPVOID)this, 0, &m_dwRunThreadId);
	AssertSz(m_hThread, TEXT("CreateThread for custom action failed"));
	DWORD iWait = WAIT_OBJECT_0;
	DWORD iReturn = ERROR_SUCCESS;

	IMsiMessage& riMessage = m_riMessage; // cache, thread may delete this object
	if (fAsync == fFalse)
	{
		if (GetTestFlag('T')) // old code before UI refresh put into engine wait loops
		{
			do
			{
				iWait = WIN::WaitForSingleObject(hThread, 20);
				g_MessageContext.Invoke(imtProgress, g_piNullRecord);  // refresh UI
			} while (iWait == WAIT_TIMEOUT);  // allow messages to be processed in main thread
		}
		else  // UI handles timeout in separate thread
		{
			g_MessageContext.DisableTimeout();
			for(;;)
			{
				iWait = WIN::MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT);
				if (iWait == WAIT_OBJECT_0 + 1)  // window Msg
				{
					MSG msg;
					while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
					{
						WIN::TranslateMessage(&msg);
						WIN::DispatchMessage(&msg);
					}
					continue;
				}
				else break;
			}
			g_MessageContext.EnableTimeout();
		}

		WIN::GetExitCodeThread(hThread, &iReturn);  // can't access member data, may be deleted
		WIN::CloseHandle(hThread);  // still running if async, else pThreadData deleted
	}
	// NOTE: nested installs always have icaNoTranslate set
	if(icaFlags & icaNoTranslate)
		return (iesEnum)iReturn;// return the result as is

	switch (iReturn)
	{
	case ERROR_FUNCTION_NOT_CALLED:  return iesNoAction;
	case ERROR_SUCCESS:              return fAsync ? (iesEnum)iesNotDoneYet : iesSuccess;
	case ERROR_INSTALL_USEREXIT:     return iesUserExit;
	case ERROR_INSTALL_FAILURE:      return iesFailure;
	case ERROR_INSTALL_SUSPEND:      return iesSuspend;
	case ERROR_MORE_DATA:            return iesFinished; // for backwards compatibility, maps to same value as ERROR_NO_MORE_ITEMS
	case ERROR_NO_MORE_ITEMS:        return iesFinished;
	case ERROR_INVALID_HANDLE_STATE: return iesWrongState;
	case ERROR_ARENA_TRASHED:        return iesBadActionData;
	case ERROR_CREATE_FAILED:        return (iesEnum)iesExeLoadFailed; // error will be posted on return
	case ERROR_INSTALL_REBOOT_NOW:   return (iesEnum)iesRebootNow;
	case ERROR_INSTALL_REBOOT:                 return (iesEnum)iesReboot;
	case ERROR_SUCCESS_REBOOT_REQUIRED: return (iesEnum)iesRebootRejected;
	case ERROR_DLL_NOT_FOUND:        return (iesEnum)iesDLLLoadFailed;
	case ERROR_INVALID_DLL:          return (iesEnum)iesDLLLoadFailed;
	case ERROR_INSTALL_SERVICE_FAILURE: return (iesEnum)iesServiceConnectionFailed;
	default:                         return iesFailure;
	}
}

Bool ThreadLogActionEnd(CActionThreadData* pActionData, DWORD iReturn)
{
	if(pActionData->m_icaFlags & icaAsync)
	{
		// log action end
		PMsiRecord pLogRecord = &ENG::CreateRecord(2);
		if(pActionData->m_pistrActionEndLogTemplate)
			AssertNonZero(pLogRecord->SetMsiString(0,*(pActionData->m_pistrActionEndLogTemplate)));
		AssertNonZero(pLogRecord->SetMsiString(1,*(pActionData->m_strAction)));
		AssertNonZero(pLogRecord->SetInteger(2,iReturn));
		pActionData->m_riMessage.Message(imtInfo,*pLogRecord);
	}
	return fTrue;
}

DWORD WINAPI NestedInstallThread(CActionThreadData* pActionData)
{
	ireEnum ireProductSpec;
	// only substorage and product code nested installs are supported
	switch (pActionData->m_icaFlags & icaSourceMask)
	{
	case icaBinaryData: ireProductSpec = ireSubStorage;  break; // database in substorage
	case icaDirectory:  ireProductSpec = ireProductCode; break; // product code, advertised or installed
	case icaSourceFile: ireProductSpec = irePackagePath; break; // relative to install source root
	default: AssertSz(0, "Invalid nested install type"); // fall through
	case icaProperty:   ireProductSpec = irePackagePath; break; // already resolved to property
	}

	DWORD iReturn = CreateAndRunEngine(ireProductSpec, pActionData->m_pistrProduct->GetString(), 0,
															pActionData->m_pistrCmdLine->GetString(),
															pActionData->m_piEngine,
															pActionData->m_iioOptions);
	pActionData->m_pistrProduct->Release();
	pActionData->m_pistrCmdLine->Release();

	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));

	// if "ignore error" bit is set - change non-success codes to success
	Assert(iReturn != ERROR_SUCCESS_REBOOT_INITIATED);
	if ((pActionData->m_icaFlags & icaContinue) != 0 &&
		 iReturn != ERROR_SUCCESS &&
		 iReturn != ERROR_INSTALL_USEREXIT &&
		 iReturn != ERROR_INSTALL_REBOOT &&
		 iReturn != ERROR_INSTALL_REBOOT_NOW &&
		 iReturn != ERROR_SUCCESS_REBOOT_REQUIRED)
	{
		iReturn = ERROR_SUCCESS;
	}
	else if (iReturn == ERROR_FILE_NOT_FOUND)
		iReturn = ERROR_CREATE_FAILED;  // force error message
	AssertSz(!(pActionData->m_icaFlags & icaAsync), "Invalid nested install type");
	delete pActionData;
	WIN::ExitThread(iReturn);
	return iReturn;  // never gets here, needed to compile
}

// GetCustomActionManager tracks down the custom action manager that is appropriate
// for this process. In the service it gets the global ConfigMgr object and asks
// it for the object. In the client, it takes the provided engine pointer and
// retrieves the object from it.
CMsiCustomActionManager *GetCustomActionManager(IMsiEngine *piEngine)
{
	CMsiCustomActionManager* pCustomActionManager = NULL;
	if (g_scServerContext == scService)
	{
		// in the service, the manager lives in the ConfigManager because there isn't
		// necessarily an engine
		IMsiConfigurationManager *piConfigMgr = CreateConfigurationManager();
		if (piConfigMgr)
		{
			pCustomActionManager = piConfigMgr->GetCustomActionManager();
			piConfigMgr->Release();
		}
	}
	else
	{
		Assert(piEngine);
		if (piEngine)
			pCustomActionManager = piEngine->GetCustomActionManager();
	}
	return pCustomActionManager;
}

DWORD WINAPI CustomRemoteDllThread(CActionThreadData* pActionData)
{
	// This function calls ExitThread. No smart COM pointers allowed on stack!

	DWORD iReturn = ERROR_SUCCESS;
	icacCustomActionContext icacContext = icac32Impersonated;

	// the action can elevate only if it in the service, elevated, and the script
	// is elevated.
	bool fElevate = (g_scServerContext == scService) && (pActionData->m_fElevationEnabled) && (pActionData->m_icaFlags & icaNoImpersonate) && (pActionData->m_icaFlags & icaInScript);

	// determine custom action platform (64/32bit). No need to check on non-64 systems
	bool fIs64Bit = false;
	if (g_fWinNT64)
	{
		PMsiPath pPath = 0;
		PMsiRecord piError = 0;
		MsiString strPath = 0;
		MsiString strFilename = 0;
		IMsiServices* piServices = LoadServices();

		// split DLL path into path/file
		if ((piError = SplitPath(pActionData->m_pistrCmdLine->GetString(), &strPath, &strFilename)) == 0)
		{
			if ((piError = piServices->CreatePath(strPath,*&pPath)) == 0)
			{
				piError = pPath->IsPE64Bit(strFilename, fIs64Bit);
			}
		}
		if (piError)
			iReturn = ERROR_DLL_NOT_FOUND;

		FreeServices();
	}

	if (iReturn == ERROR_SUCCESS)
	{
		if (fIs64Bit)
		{
			//!!future - should fail if not running on 64bit machine
			icacContext = fElevate ? icac64Elevated : icac64Impersonated;
		}
		else
		{
			icacContext = fElevate ? icac32Elevated : icac32Impersonated;
		}

		// Custom Action remote threads MUST have COM initialized in a MTA mode, otherwise
		// we would need to marshall the RemoteAPI interface over to this thread before
		// passing it to the client process.
		OLE32::CoInitializeEx(0, COINIT_MULTITHREADED);

		// find the custom action manager to run the action
		CMsiCustomActionManager *pCustomActionManager = GetCustomActionManager(pActionData->m_piEngine);

		if (pCustomActionManager)
		{
			DEBUGMSG2(TEXT("Invoking remote custom action. DLL: %s, Entrypoint: %s"), pActionData->m_pistrCmdLine->GetString(), pActionData->m_pistrProduct->GetString());

			if (ERROR_SUCCESS != pCustomActionManager->RunCustomAction(icacContext, pActionData->m_pistrCmdLine->GetString(),
				pActionData->m_pistrProduct->GetString(), pActionData->m_hMsi, ((pActionData->m_icaFlags & icaDebugBreak) != 0), pActionData->m_fDisableMessages,
				pActionData->m_fAppCompat, &pActionData->m_guidAppCompatDB, &pActionData->m_guidAppCompatID, pActionData->m_riMessage, pActionData->m_strAction, &iReturn))
				iReturn = ERROR_INSTALL_SERVICE_FAILURE;
		}
		else
		{
			DEBUGMSG(TEXT("Failed to get custom action manager."));
			iReturn = ERROR_INSTALL_SERVICE_FAILURE;
		}

		OLE32::CoUninitialize();
	}

	pActionData->m_pistrCmdLine->Release();
	pActionData->m_pistrProduct->Release();

	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));

	if ((pActionData->m_icaFlags & icaContinue) != 0)
		iReturn = ERROR_SUCCESS;
	else if (iReturn == ERROR_FILE_NOT_FOUND)
		iReturn = ERROR_DLL_NOT_FOUND;  // force error message

	// delete ActionData if CA is synchronous - if async it will be cleaned up by WaitForCustomActionThreads
	if (!(pActionData->m_icaFlags & icaAsync))
		delete pActionData;

	WIN::ExitThread(iReturn);
	return 0;  // never gets here, needed to compile
}


DWORD CallCustomDllEntrypoint(PCustomActionEntry pfEntry, bool fDebugBreak, MSIHANDLE hInstall, const ICHAR* szAction)
{
	if (fDebugBreak)
		WIN::DebugBreak();  // handle with debugger or JIT
	// do not put code in here between DebugBreak and custom action entry

#if _X86_
	int iOldEsp = 0;  // on the stack to handle multi-threading, OK even if regs change, as compare will fail
	int iNewEsp = 0;
	__asm   mov iOldEsp, esp
#endif

	DWORD iReturn = (*pfEntry)(hInstall);

#if _X86_
	__asm   mov iNewEsp, esp
	if (iNewEsp != iOldEsp)
	{
		// do not declare any local variables in this frame

		// try restoring the stack 
		__asm   mov esp, iOldEsp

		// the action name cannot be trusted in ship builds. If the stack is corrupt, the pointer
		// could be invalid.
		DEBUGMSG(TEXT("Possible stack corruption. Custom action may not be declared __stdcall."));
#ifdef DEBUG
		ICHAR rgchError[1024];

		wsprintf(rgchError, TEXT("Possible stack corruption. Custom action %s may not be declared __stdcall."), szAction);
		AssertSz(fFalse, rgchError);
#else
		szAction; // prevent compiler from complaining
#endif
	}
#else
	szAction; // prevent compiler from complaining
#endif

   	// map the return values from a custom action to an "approved" value
	switch (iReturn)
	{
	// the following are the approved custom action return values, documented in the SDK
	case ERROR_FUNCTION_NOT_CALLED:
	case ERROR_SUCCESS:
	case ERROR_INSTALL_USEREXIT:
	case ERROR_INSTALL_FAILURE:
	case ERROR_NO_MORE_ITEMS:
		break;
	// ERROR_MORE_DATA was removed from documentation, but it was documented as valid at one point
	// so we have to allow it
	case ERROR_MORE_DATA:
		break;
	// _SUSPEND doesn't really have a useful meaning as a CA return value, but it was documented as valid
	// in the MSI 1.0  SDK so we have to allow it
	case ERROR_INSTALL_SUSPEND:
		break;
	default:
		DEBUGMSG2(TEXT("Custom Action %s returned unexpected value %d. Converted to ERROR_INSTALL_FAILURE."), szAction, reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(iReturn)));
		iReturn = ERROR_INSTALL_FAILURE;
	}

	return iReturn;
}

DWORD WINAPI CustomDllThread(CActionThreadData* pActionData)
{
    // this function should never run on NT/2000. Every DLL should be run out-of-proc
    AssertSz(g_fWin9X, TEXT("Running in-proc DLL on NT."));

	// This function calls ExitThread. No smart COM pointers allowed on stack!

	if((g_scServerContext == scService) && (!pActionData->m_fElevationEnabled || !(pActionData->m_icaFlags & icaInScript) || !(pActionData->m_icaFlags & icaNoImpersonate)))
		AssertNonZero(StartImpersonating());

	if ((pActionData->m_icaFlags & icaDebugBreak) != 0)
		g_tidDebugBreak = WIN::MsiGetCurrentThreadId(); // flag our breakpoint

	if (pActionData->m_fDisableMessages)
		g_MessageContext.DisableThreadMessages(WIN::GetCurrentThreadId());

	DWORD iReturn = CallCustomDllEntrypoint(pActionData->m_pfEntry,
										    (pActionData->m_icaFlags & icaDebugBreak) != 0,
											pActionData->m_hMsi,
											(const ICHAR*)pActionData->m_strAction);
	if (pActionData->m_fDisableMessages)
		g_MessageContext.EnableMessages();

	if((g_scServerContext == scService) && (!pActionData->m_fElevationEnabled || !(pActionData->m_icaFlags & icaInScript) || !(pActionData->m_icaFlags & icaNoImpersonate)))
		StopImpersonating();

	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));
	if ((pActionData->m_icaFlags & icaContinue) != 0)
		iReturn = ERROR_SUCCESS;

	// delete ActionData if CA is synchronous - if async it will be cleaned up by WaitForCustomActionThreads
	if (!(pActionData->m_icaFlags & icaAsync))
		delete pActionData;

	WIN::ExitThread(iReturn);
	return iReturn;  // never gets here, needed to compile
}

DWORD WINAPI CustomExeThread(CActionThreadData* pActionData)
{
	// This function calls ExitThread. No smart COM pointers allowed on stack!

	PROCESS_INFORMATION pi;
	memset(&pi, 0, sizeof(pi));
	
	STARTUPINFO si;
	memset(&si, 0, sizeof(si));
	si.cb        = sizeof(si);
	DWORD iReturn = ERROR_SUCCESS;
	DWORD dwWait = WAIT_OBJECT_0;
	BOOL fCreate = FALSE;
	bool fImpersonated = 0;
	const ICHAR* szWorkingDir = 0;

	// environment for child EXE. NULL (to inherit from parent) unless app compat fix requires additions
	VOID* pvChildEnvironment = NULL;

	int cbCommandArgs = pActionData->m_pistrCmdLine->TextSize();
	int cbLocation    = pActionData->m_pistrProduct->TextSize();
	int cbCommandLine = cbCommandArgs;
	if ((pActionData->m_icaFlags & icaSourceMask) != icaDirectory)
		cbCommandLine += (cbLocation + 3);  // room for quotes and separator
	CTempBuffer<ICHAR, 512> szCommandLine;
	szCommandLine.SetSize(cbCommandLine+1);
	ICHAR* pch = szCommandLine;
	if ( ! pch )
		goto CustomExeThreadExit;
	if ((pActionData->m_icaFlags & icaSourceMask) != icaDirectory)
	{
		*pch++ = '"';
		IStrCopy(pch, pActionData->m_pistrProduct->GetString());
		pch += cbLocation;
		*pch++ = '"';
		if (cbCommandArgs)
			*pch++ = ' ';
	}
	else
		szWorkingDir = pActionData->m_pistrProduct->GetString();
	IStrCopy(pch, pActionData->m_pistrCmdLine->GetString());

	if (g_scServerContext == scService)
	{
		fImpersonated = StartImpersonating();
		AssertNonZero(fImpersonated);
	}

	if (pActionData->m_icaFlags & icaDebugBreak)
		WIN::DebugBreak();

	// apphelp APIs not defined in ANSI versions, so none of this code will compile
#ifdef UNICODE
	// check AppCompat information for custom actions
	if (pActionData->m_fAppCompat && MinimumPlatformWindowsNT51())
	{
		// app compat team claims no compat layer strings longer than MAX_PATH and at most two strings
		// so the buffer will start with enough space for those strings.
		CTempBuffer<WCHAR, 2*MAX_PATH+3> rgchEnvironment;
		DWORD cchEnvironment = rgchEnvironment.GetSize();

		// Initialize the buffer to be safe.
		IStrCopy (rgchEnvironment, TEXT(""));
		if (!APPHELP::ApphelpFixMsiPackageExe(&pActionData->m_guidAppCompatDB, &pActionData->m_guidAppCompatID, pActionData->m_strAction, rgchEnvironment, &cchEnvironment))
		{
			// error or no-op, ensure environment is empty
			IStrCopy(rgchEnvironment, TEXT(""));
		}
		else
		{
			// the AppHelp API will return success even if the buffer is too small. 
			if (cchEnvironment > rgchEnvironment.GetSize())
			{
				rgchEnvironment.SetSize(cchEnvironment);
				// Make sure that we are passing in the right buffer size (just in case the SetSize failed)
				cchEnvironment = rgchEnvironment.GetSize();
				// Initialize the buffer to be safe.
				IStrCopy (rgchEnvironment, TEXT(""));
				if (!APPHELP::ApphelpFixMsiPackageExe(&pActionData->m_guidAppCompatDB, &pActionData->m_guidAppCompatID, pActionData->m_strAction, rgchEnvironment, &cchEnvironment)
					|| cchEnvironment > rgchEnvironment.GetSize())
				{
					// error or no-op, ensure environment is empty
					// Also take into account the possibility that AppHelpFixMsiPackageExe does not find the buffer
					// to be sufficient again, either because SetSize failed above or because of some other problem
					// in the AppHelpFixMsiPackageExe API.
					IStrCopy(rgchEnvironment, TEXT(""));
				}
			}
		}


		// clone the current environment into a new environment block
		if ((IStrLen(rgchEnvironment) != 0) && STATUS_SUCCESS == NTDLL::RtlCreateEnvironment(TRUE, &pvChildEnvironment))
		{
			// set each name and value into the environment block
			WCHAR* pchName = rgchEnvironment;
			while (*pchName)
			{
				WCHAR* pchValue = wcschr(pchName, L'=');
				if (pchValue)
				{
					// null terminate the name and increment the pointer to the beginning of the value
					*(pchValue++) = L'\0';
	
					// set the value into the new environment
					UNICODE_STRING strName;
					UNICODE_STRING strValue;

					// RtlInitUnicodeString returns void, so there is no way to detect that we can't latebind
					// to the function (which would leave the structures uninitialized.) As a backup, we zero
					// the structure.
					memset(&strValue, 0, sizeof(UNICODE_STRING));
					memset(&strName, 0, sizeof(UNICODE_STRING));

					NTDLL::RtlInitUnicodeString(&strName, pchName);
					NTDLL::RtlInitUnicodeString(&strValue, pchValue);
					if (STATUS_SUCCESS != NTDLL::RtlSetEnvironmentVariable(&pvChildEnvironment, &strName, &strValue))
					{
						DEBUGMSGV1(TEXT("Failed to apply app compat flags to environment for custom action %s."), pActionData->m_strAction);
						goto CustomExeThreadExit;
					}

					// increment to the next name=value pair, one char past the terminating NULL of the value
					pchName = pchValue; 
					while (*pchName)
						pchName++;
					pchName++;
				}
				else
				{
					// protect against possible corruption in the environment block.
					break;
				}
			}
		}
	}
#endif

	// set STARTUPINFO.lpDesktop to WinSta0\Default. When combined with the TS sessionID from the
	// token, this places any UI on the visible desktop of the appropriate session.
	si.lpDesktop=TEXT("WinSta0\\Default");

	// We can't do SetErrorMode(0) here, as other threads will be affected and will Assert
	// if in the service, and either not set to run elevated, not in the script, or set to impersonate
	if((g_scServerContext == scService) && (!pActionData->m_fElevationEnabled || (!(pActionData->m_icaFlags & icaInScript) || !(pActionData->m_icaFlags & icaNoImpersonate))))
	{
		HANDLE hTokenPrimary = INVALID_HANDLE_VALUE;
		if (g_MessageContext.GetUserToken())
		{
			// create a primary token for use with CreateProcessAsUser
			ADVAPI32::DuplicateTokenEx(g_MessageContext.GetUserToken(), 0, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary);

			//
			// SAFER: must mark token inert on Whistler
			//

			if (MinimumPlatformWindowsNT51())
			{
				// SaferComputeTokenFromLevelwill take hTokenTemp and modify the token to include the SANDBOX_INERT flag
				// The modified token is output as hTokenPrimary.
				HANDLE hTokenTemp = hTokenPrimary;
				hTokenPrimary = INVALID_HANDLE_VALUE;
				if (hTokenTemp != INVALID_HANDLE_VALUE && !ADVAPI32::SaferComputeTokenFromLevel(g_MessageContext.m_hSaferLevel, hTokenTemp, &hTokenPrimary, SAFER_TOKEN_MAKE_INERT, 0))
				{
					DEBUGMSG1(TEXT("SaferComputeTokenFromLevel failed with last error = %d"), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(GetLastError())));
					hTokenPrimary = INVALID_HANDLE_VALUE;
				}
				if (hTokenTemp != INVALID_HANDLE_VALUE)
				{
					WIN::CloseHandle(hTokenTemp);
					hTokenTemp = INVALID_HANDLE_VALUE;
				}
			}

			if (hTokenPrimary != INVALID_HANDLE_VALUE)
			{
				UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
				fCreate = ADVAPI32::CreateProcessAsUser(hTokenPrimary, 0, szCommandLine,
									(LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
									NORMAL_PRIORITY_CLASS | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), pvChildEnvironment, 
									szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				WIN::SetErrorMode(uiErrorMode);
				WIN::CloseHandle(hTokenPrimary);
			}
		}
	}
	else
	{
		// in the service, we need to ensure that the process runs using the correct session information
		if (g_scServerContext == scService && (g_iMajorVersion > 4))
		{
			HANDLE hTokenUser = g_MessageContext.GetUserToken();
			HANDLE hTokenPrimary = 0;
			HANDLE hTokenService = 0;
			bool fTryCreate = false;

			{
				//
				// SAFER: no need to mark inert since this is the local_system token and local_system is not subject to SAFER
				//

				CElevate elevate(true);
				// work with a duplicate of our process token so we don't make any permanent changes
				if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hTokenService) && hTokenService)
				{
					if (ADVAPI32::DuplicateTokenEx(hTokenService, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary) && hTokenPrimary)
					{
						DWORD dwSessionId = 0;
						DWORD cbResult = 0;

						// grab the session ID from the users token and place it in the duplicate service token
						if (GetTokenInformation(hTokenUser, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD), &cbResult) &&
							SetTokenInformation(hTokenPrimary, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD)))
						{
							fTryCreate = true;
						}
					}
				}
			}

			if (fTryCreate)
			{
				UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
				fCreate = ADVAPI32::CreateProcessAsUser(hTokenPrimary, 0, szCommandLine,
						(LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
						NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), 
						pvChildEnvironment, szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				WIN::SetErrorMode(uiErrorMode);
			}
			if (hTokenPrimary)
				WIN::CloseHandle(hTokenPrimary);
			if (hTokenService)
				WIN::CloseHandle(hTokenService);
		}
		else
		{
			//
			// SAFER: need to mark INERT on Whistler since this is user token
			//

			if (MinimumPlatformWindowsNT51())
			{
				// SaferComputeTokenFromLevelwill modify the token based upon the supplied safer level and include the SANDBOX_INERT
				// flag such that subsequent safer checks do not occur.  Because installs only proceed on fully trusted safer levels, the
				// supplied token will only be modified by inclusion of the inert flag.  Note that passing in 0 for the InToken will use the
				// thread token if present, otherwise it uses the process token
				HANDLE hTokenInert = INVALID_HANDLE_VALUE;
				if (!ADVAPI32::SaferComputeTokenFromLevel(g_MessageContext.m_hSaferLevel, /*InToken = */0, &hTokenInert, SAFER_TOKEN_MAKE_INERT, 0))
				{
					DEBUGMSG1(TEXT("SaferComputeTokenFromLevel failed with last error = %d"), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(GetLastError())));
					hTokenInert = INVALID_HANDLE_VALUE;
				}

				if (hTokenInert != INVALID_HANDLE_VALUE)
				{
					// create a primary token for use with CreateProcessAsUser
					HANDLE hTokenPrimaryDup = INVALID_HANDLE_VALUE;
					if (ADVAPI32::DuplicateTokenEx(hTokenInert, 0, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimaryDup))
					{
						// create the process
						UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
						fCreate = ADVAPI32::CreateProcessAsUser(hTokenPrimaryDup, 0, szCommandLine, (LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
							NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), pvChildEnvironment, szWorkingDir, 
							(LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
						WIN::SetErrorMode(uiErrorMode);
						WIN::CloseHandle(hTokenPrimaryDup);
					}
					WIN::CloseHandle(hTokenInert);
				}
			}
			else
			{
				// only from the client can we just call createprocess
				UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
				fCreate = WIN::CreateProcess(0, szCommandLine,
					(LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
					NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), 
					pvChildEnvironment, szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				WIN::SetErrorMode(uiErrorMode);
			}
		}

		if (fCreate)
		{
			// must elevate for access to the process
			CElevate elevate(true);

			if ((pActionData->m_icaFlags & icaSetThreadToken) != 0)
			{
				SetThreadToken(&pi.hThread, GetUserToken());
			}
			AssertNonZero(1 == ResumeThread(pi.hThread));
		}
	}

	pActionData->m_pistrCmdLine->Release();
	pActionData->m_pistrProduct->Release();
CustomExeThreadExit:
	// free the cloned environment
	if (pvChildEnvironment)
	{
		NTDLL::RtlDestroyEnvironment(pvChildEnvironment);
		pvChildEnvironment=NULL;
	}

	if (!fCreate)
		iReturn = ERROR_CREATE_FAILED; // to force specific error message when returning to engine
	else
	{
		WIN::CloseHandle(pi.hThread);  // don't need this
		if (!(pActionData->m_icaFlags & icaAsync)   // wait here if synchronous
		 || (!(pActionData->m_icaFlags & icaContinue) // no wait if async return ignored
		  && !((pActionData->m_icaFlags & (icaInScript | icaRollback)) == (icaInScript | icaRollback))))
		{
			for(;;)
			{
				dwWait = WIN::MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT);
				if (dwWait == WAIT_OBJECT_0 + 1)  // window Msg
				{
					MSG msg;
					while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
					{
						WIN::TranslateMessage(&msg);
						WIN::DispatchMessage(&msg);
					}
					continue;
				}
				else break;
			}
			if ((pActionData->m_icaFlags & icaContinue) == 0)  // need to check exit code unless ignore
				WIN::GetExitCodeProcess(pi.hProcess, &iReturn);
		}
		WIN::CloseHandle(pi.hProcess);
		if (dwWait == WAIT_FAILED || (!(pActionData->m_icaFlags & icaNoTranslate) && iReturn != ERROR_SUCCESS))
			iReturn = ERROR_INSTALL_FAILURE;  // any non-zero return from an EXE assumed to be an error
	}
	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));

	// delete ActionData if CA is synchronous - if async it will be cleaned up by WaitForCustomActionThreads
	if (!(pActionData->m_icaFlags & icaAsync))
		delete pActionData;

	if (fImpersonated)
		StopImpersonating();

	WIN::ExitThread(iReturn);
	return iReturn;  // never gets here, needed to compile
}

void WaitForCustomActionThreads(IMsiEngine* piEngine, Bool fTerminate, IMsiMessage& /*riMessage*/)
{
	CActionThreadData*  pActionThreadData;

	EnterCriticalSection(&vcsHeap);
	CActionThreadData** ppActionThreadHead = &g_pActionThreadHead;
	while((pActionThreadData = *ppActionThreadHead) != 0)
	{
		//
		// See if this is one that we care about
		//
		if (pActionThreadData->m_piEngine != piEngine)
		{
			ppActionThreadHead = &pActionThreadData->m_pNext;
			continue;
		}

		HANDLE hThread = pActionThreadData->m_hThread;
		if (!hThread)  // thread never created, just clear data
			delete pActionThreadData; // will unlink
		else if (fTerminate || (pActionThreadData->m_icaFlags & icaContinue)==0)
		{
			//
			// While waiting for this to finish, we don't want to be in a critical section
			//
			LeaveCriticalSection(&vcsHeap);
			DWORD iWait;
			if (GetTestFlag('T')) // old code before UI refresh put into engine wait loops
			{
				do
				{
					iWait = WIN::WaitForSingleObject(hThread, 20);
					g_MessageContext.Invoke(imtProgress, g_piNullRecord);  // refresh UI
				} while (iWait == WAIT_TIMEOUT);  // allow messages to be processed in main thread
			}
			else  // UI in separate thread
			{
				g_MessageContext.DisableTimeout();
				iWait = WIN::WaitForSingleObject(hThread, INFINITE);
				g_MessageContext.EnableTimeout();
			}

			// synchronous CAs clean themselves up - async CAs are cleaned up here
			delete pActionThreadData;
			WIN::CloseHandle(hThread);
			EnterCriticalSection(&vcsHeap);
			//
			// Now we have to restart at the beginning however (the list may have been changed on us)
			//
			ppActionThreadHead = &g_pActionThreadHead;
		}
		else  // wait for thread at engine terminate
			ppActionThreadHead = &pActionThreadData->m_pNext;
	}
	LeaveCriticalSection(&vcsHeap);
}


void CopyStreamToString(IMsiStream& riStream, const IMsiString*& rpistrData)
{
	int cbStream = riStream.GetIntegerValue();  // script data is ANSI in file
	rpistrData = &g_MsiStringNull;
	if(!cbStream) // empty stream
		return;
#ifdef UNICODE
	char* rgbBuf = new char[cbStream];
	if ( rgbBuf )
	{
		int cbRead = riStream.GetData(rgbBuf, cbStream);
		Assert (cbRead == cbStream);
		int cch = WIN::MultiByteToWideChar(CP_ACP, 0, rgbBuf, cbRead, 0, 0);
		WCHAR* pch = SRV::AllocateString(cch, fFalse, rpistrData);
		if ( pch )
			WIN::MultiByteToWideChar(CP_ACP, 0, rgbBuf, cbRead, pch, cch);
		delete rgbBuf;
	}
#else
	// JScript or VBScript could have DBCS characters, especially with UI or property values
	// we can't tell prior to copying the stream, so instead we default to fDBCS = fTrue in the ANSI
	// build and take the performance hit to guarantee that DBCS is supported.
	// We actually never do string manipulations on this since we pass it directly to the scripting
	// engine for compilation.  In that case, this could seem *unnecessary*, but better safe than sorry
	char* pch = SRV::AllocateString(cbStream, /*fDBCS=*/fTrue, rpistrData);
	if ( pch )
	{
		int cbRead = riStream.GetData(pch, cbStream);
		Assert (cbRead == cbStream);
	}
#endif
}

//____________________________________________________________________________
//
//  Error handling
//____________________________________________________________________________

IMsiRecord* PostScriptError(IErrorCode imsg, const ICHAR* szAction, CScriptSite* pScriptSite)
{
	IMsiRecord* piError = &ENG::CreateRecord(8);
	ISetErrorCode(piError, imsg);
	piError->SetString(2, szAction);
	if (pScriptSite && pScriptSite->GetErrorCode() != S_OK)
	{
		piError->SetInteger(3, pScriptSite->GetErrorCode());
		piError->SetString (4, pScriptSite->GetErrorObjName());
		piError->SetString (5, pScriptSite->GetErrorObjDesc());
		piError->SetInteger(6, pScriptSite->GetErrorLineNumber());
		piError->SetInteger(7, pScriptSite->GetErrorColumnNumber());
		piError->SetString (8, pScriptSite->GetErrorSourceLine());
	}
	return piError;
}

//____________________________________________________________________________
//
//  DoAction method
//____________________________________________________________________________

iesEnum CMsiEngine::DoAction(const ICHAR* szAction)
{
	if (!m_fInitialized)
		return iesWrongState;

	// no action specified, check "Action" property, else do default action
	MsiString istrTopAction;
	if (!szAction || !*szAction)
	{
		istrTopAction = GetPropertyFromSz(IPROPNAME_ACTION);
		istrTopAction.UpperCase();
		szAction = istrTopAction;
		Assert(szAction);  // should never return a null pointer
		if (!*szAction)
		{
			szAction = szDefaultAction;
			SetProperty(*MsiString(*IPROPNAME_ACTION), *MsiString(*szDefaultAction));
		}
	}

	DEBUGMSG1(TEXT("Doing action: %s"), szAction);

	PMsiRecord pOldCachedActionStart = m_pCachedActionStart;

	// generate action start record, should never fail, doesn't hurt if it does
	MsiString strDescription, strTemplate;
	GetActionText(szAction, *&strDescription, *&strTemplate); // ignore failure
	m_pCachedActionStart = &m_riServices.CreateRecord(3);
	AssertNonZero(m_pCachedActionStart->SetString(1,szAction));
	AssertNonZero(m_pCachedActionStart->SetMsiString(2,*strDescription));
	AssertNonZero(m_pCachedActionStart->SetMsiString(3,*strTemplate));

	m_fExecutedActionStart = fFalse; // need to write action start to script before next op
												// in ExecuteRecord()

	m_fDispatchedActionStart = fFalse; // need to dispatch action start before next
												  // progress message in Message()

	// log action start if necessary
	if(m_rgpiMessageHeader[imsgActionStarted])
	{
		if(!m_pActionStartLogRec)
		{
			m_pActionStartLogRec = &m_riServices.CreateRecord(2);
		}
		AssertNonZero(m_pActionStartLogRec->SetMsiString(0,*m_rgpiMessageHeader[imsgActionStarted]));
		AssertNonZero(m_pActionStartLogRec->SetString(1,szAction));
		Message(imtInfo,*m_pActionStartLogRec);
	}

	// run action
	iesEnum iesReturn = FindAndRunAction(szAction);

	if (iesReturn == iesActionNotFound)
	{
		PMsiRecord pError = &m_riServices.CreateRecord(2);
		pError->SetInteger(1, idbgMissingAction);
		pError->SetString(2, szAction);
		Message(imtInfo, *pError);
		iesReturn = iesNoAction;
	}

	if((int)iesReturn == iesNotDoneYet)
	{
		iesReturn = iesSuccess; // don't log action end
	}
	else
	{
		if(m_rgpiMessageHeader[imsgActionEnded])
		{
			Assert(m_pActionStartLogRec); // should have been created above
			if(m_pActionStartLogRec)
			{
				AssertNonZero(m_pActionStartLogRec->SetMsiString(0,*m_rgpiMessageHeader[imsgActionEnded]));
				AssertNonZero(m_pActionStartLogRec->SetString(1,szAction));
				AssertNonZero(m_pActionStartLogRec->SetInteger(2,iesReturn));
				Message(imtInfo,*m_pActionStartLogRec);
			}
		}
	}

	AssertSz(!(g_MessageContext.WasCancelReturned() && (iesReturn == iesNoAction || iesReturn == iesSuccess)), TEXT("Unprocessed Cancel button"));

	// put back old cached action start record
	m_pCachedActionStart = pOldCachedActionStart;
	m_fExecutedActionStart = fFalse; // need to write action start to script before next op
	m_fDispatchedActionStart = fFalse; // need to dispatch action start before next progress message

	return iesReturn;
}

iesEnum CMsiEngine::RunNestedInstall(const IMsiString& ristrProduct,
												 Bool fProductCode, // else package path
												 const ICHAR* szAction,
												 const IMsiString& ristrCommandLine,
												 iioEnum iioOptions,
												 bool fIgnoreFailure)
{
	int icaFlags = fProductCode ? icaDirectory : icaProperty;

	if(fIgnoreFailure)
		icaFlags |= icaContinue;

	return RunNestedInstallCustomAction(ristrProduct,ristrCommandLine,szAction,
													icaFlags, iioOptions);
}

iesEnum CMsiEngine::RunNestedInstallCustomAction(const IMsiString& ristrProduct,
																 const IMsiString& ristrCommandLine,
																 const ICHAR* szAction,
																 int icaFlags,
																 iioEnum iioOptions)
{
	if((GetMode() & iefRollbackEnabled) == 0)
		iioOptions = (iioEnum)(iioOptions | iioDisableRollback);

	// don't translate error code for nested installs - we will do the remapping here
	icaFlags |= icaNoTranslate;

	CActionThreadData* pThreadData = new CActionThreadData(*this, this, szAction, icaFlags,
							   m_rgpiMessageHeader[imsgActionEnded], m_fRunScriptElevated, /*fAppCompat=*/false, NULL, NULL);
	int iError; 
	iesEnum iesReturn = iesSuccess;

	if ( pThreadData )
	{
		pThreadData->InitializeInstall(ristrProduct, FormatText(ristrCommandLine), iioOptions);
		// action end log handled by RunThread

		iError = pThreadData->RunThread();
	}
	else
		iError = ERROR_OUTOFMEMORY;

	// handle special return codes from custom action
	if (iError == ERROR_INSTALL_REBOOT)  // reboot required at end of install
	{
		SetMode(iefReboot, fTrue);
		iesReturn = iesSuccess;
	}
	else if (iError == ERROR_INSTALL_REBOOT_NOW)  // reboot required before completing install
	{
		SetMode(iefReboot, fTrue);
		SetMode(iefRebootNow, fTrue);
		iesReturn = iesSuspend;
	}
	else if (iError == ERROR_SUCCESS_REBOOT_REQUIRED)  // reboot required but suppressed or rejected by user
	{
		SetMode(iefRebootRejected, fTrue);
		iesReturn = iesSuccess;
	}
	else if (iError == ERROR_INSTALL_USEREXIT)
	{
		iesReturn = iesUserExit;
	}
	else if (iError == ERROR_INSTALL_SUSPEND)
	{
		iesReturn = iesSuspend;
	}
	else if (iError == ERROR_INSTALL_FAILURE)
	{
		// failure and message displayed by nested install
		iesReturn = iesFailure;
	}
	else if (iError == ERROR_SUCCESS)
	{
		iesReturn = iesSuccess;
	}
	else // some initialization error - display error message
	{
		// we'll ignore the "product not found" error when uninstalling a product during an upgrade
		if((iioOptions & iioUpgrade) && iError == ERROR_UNKNOWN_PRODUCT)
		{
			DEBUGMSG(TEXT("Ignoring failure to remove product during upgrade - product already uninstalled."));
			iesReturn = iesSuccess;
		}
		else
		{
			MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME); // parent's product name
			IErrorCode imsg;
			if(iioOptions & iioUpgrade)
				imsg = Imsg(imsgUpgradeRemovalInitError);
			else
				imsg = Imsg(imsgNestedInstallInitError);

			PMsiRecord precError(PostError(imsg, *strProductName, iError));
			iesReturn = FatalError(*precError);
		}
	}
	return iesReturn;
}

// script actions also must run through the CA server if they are impersonated, but because they don't run asynchronously
// there is no need for a bunch of fancy thread work to run the script.

// RunScript action actually creates the Site, runs the script, and posts error messages. It does not handle
// continue flags, etc.
HRESULT RunScriptAction(int icaType, IDispatch* piDispatch, MsiString istrSource, MsiString istrTarget, LANGID iLangId, HWND hWnd, int& iScriptResult, IMsiRecord** piMSIResult)
{
	MsiString szAction;
	iScriptResult = 0;

	CScriptSite* piScriptSite = CreateScriptSite(icaType == icaJScript ? IID_JScript : IID_VBScript, piDispatch, hWnd, iLangId);
	if (piScriptSite)  // successfully created scripting session
	{
		HRESULT hRes = piScriptSite->ParseScript(istrSource, istrSource.TextSize());
		if (hRes == S_OK)
		{
			if (istrTarget.TextSize() != 0)  // function specified to call
			{
				hRes = piScriptSite->CallScriptFunction(istrTarget);
				piScriptSite->GetIntegerResult(iScriptResult);
			}
		}
		if (hRes != S_OK)
			*piMSIResult = PostScriptError(Imsg(imsgCustomActionScriptFailed), szAction, piScriptSite);
	}
	else if (icaType == icaVBScript)
		*piMSIResult = PostScriptError(Imsg(idbgCustomActionNoVBScriptEngine), szAction, 0);
	else // (icaType == icaJScript)
		*piMSIResult = PostScriptError(Imsg(idbgCustomActionNoJScriptEngine), szAction, 0);
	DestroyScriptSite(piScriptSite);

	// filter script return values the approved set
	switch (iScriptResult)
	{
	// the following 5 values are documented as valid return values
	case iesSuccess:
	case iesUserExit:
	case iesNoAction:
	case iesFailure:
	case iesFinished:
		break;
	// iesSuspend is equivalent to INSTALL_SUSPEND, meaning that we don't really know
	// what to do with it (but it was documented, so must be "supported")
	case iesSuspend:
		break;
	default:
		DEBUGMSG2(TEXT("Script custom action %s returned unexpected value %d. Converted to IDABORT."), szAction, reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(iScriptResult)));
		iScriptResult = iesFailure;
		break;
	}

	return S_OK;
}

// CustomRemoteScriptAction create the custom action server and passes the script to the process to run,
// unmarshals the resulting error record (if any) and handles internal failures. If asynch actions are
// ever allowed, this code should be in CustomRemoteScriptThread.
int CustomRemoteScriptAction(bool fScriptElevate, int icaFlags, IMsiEngine* piEngine, IDispatch* piDispatch, MsiString istrSource, MsiString istrTarget, IMsiRecord** piMSIResult)
{
	g_MessageContext.DisableTimeout();
	int iReturn =0;
	*piMSIResult = 0;

	icacCustomActionContext icacContext = icac32Impersonated;
	bool fElevate = (g_scServerContext == scService) && fScriptElevate && (icaFlags & icaNoImpersonate) && (icaFlags & icaInScript);

        // determine custom action platform (64/32bit). It isn't possible to just "look" at the script like
        // it is with DLL actions, so the author must explicitly mark if an action is 64bit.
        if (ica64BitScript & icaFlags)
        {
                //!! Need to figure out how to handle scripts
                //!!future - should fail if not running on 64bit machine
                icacContext = fElevate ? icac64Elevated : icac64Impersonated;
        }
        else
        {
                icacContext = fElevate ? icac32Elevated : icac32Impersonated;
        }

	bool fDisableMessages = false;
	if (g_MessageContext.IsUIThread())
		fDisableMessages = true;

	CMsiCustomActionManager *pCustomActionManager = GetCustomActionManager(piEngine);

	if (pCustomActionManager)
	{
		HRESULT hRes = pCustomActionManager->RunScriptAction(icacContext, icaFlags & icaTypeMask, piDispatch,
			istrSource, istrTarget, g_BasicUI.GetPackageLanguage(), fDisableMessages, &iReturn, piMSIResult);
		if (hRes != S_OK)
		{
			// problem marshaling
			DEBUGMSGV(TEXT("Failed to marshal script action."));
			iReturn = iesFailure;
		}
	}
	else
	{
		DEBUGMSG(TEXT("Failed to get custom action manager."));
		iReturn = iesFailure;
	}
	g_MessageContext.EnableTimeout();
	return iReturn;
}

// class CViewAndStreamRelease is used for FindAndRunAction to ensure that
// the stream and view pointers are released in the correct order
// (stream before view).  Acts as a CComPointer.  Also enables
// use of original stream and views.  No releases need to be used
// as this class will take care of it.
//NOTE:  we always want the stream to be released before the view

class CViewAndStreamRelease
{
private:
	IMsiStream** m_ppiStream;
	IMsiView**   m_ppiView;
public:
	CViewAndStreamRelease(IMsiStream** ppiStream, IMsiView** ppiView): m_ppiStream(ppiStream), m_ppiView(ppiView){}
	~CViewAndStreamRelease();
	void ReleaseAll();
};
inline CViewAndStreamRelease::~CViewAndStreamRelease()
{if (*m_ppiStream) (*m_ppiStream)->Release(); if (*m_ppiView) (*m_ppiView)->Release();}

inline void CViewAndStreamRelease::ReleaseAll()
{
	if (*m_ppiStream)
	{
		(*m_ppiStream)->Release();
		*m_ppiStream = 0;
	}
	if (*m_ppiView)
	{
		(*m_ppiView)->Release();
		*m_ppiView = 0;
	}
}

iesEnum CMsiEngine::FindAndRunAction(const ICHAR* szAction)
{
	// scan for built-in action, and execute it and return if found
	iesEnum iesReturn;
	const CActionEntry* pAction = CActionEntry::Find(szAction);
	if (pAction && pAction->m_pfAction)
	{
		// only execute the action if we're not in a restricted engine OR we're in a restricted engine and the action is safe
		if (!m_fRestrictedEngine || pAction->m_fSafeInRestrictedEngine)
		{
			return (*(pAction->m_pfAction))(*this);
		}
		else
		{
			DEBUGMSG1(TEXT("Action '%s' is not permitted in a restricted engine."), szAction);
			return iesNoAction;
		}
	}

	// query CustomAction table to check if it is a custom action
	PMsiRecord precAction(m_fCustomActionTable ? FetchSingleRow(sqlCustomAction, szAction) : 0);
	if (precAction == 0)  // if not a custom action, then sent it to the UI handler
	{
		if (m_piParentEngine || !g_MessageContext.IsHandlerLoaded()) // no need for (g_scServerContext != scClient), as handler can't be loaded if not client
			return iesNoAction; // actions can't be executed in this context

		g_MessageContext.m_szAction = szAction;
		iesReturn = (iesEnum)g_MessageContext.Invoke(imtShowDialog, 0);
		if (iesReturn == iesNoAction) // if Handler didn't find action, action doesn't exist
			iesReturn = (iesEnum)iesActionNotFound;
		return iesReturn;
	}

	// get custom action parameters and decode type
	MsiString istrSource(precAction->GetMsiString(icolSource));
	MsiString istrTarget(precAction->GetMsiString(icolTarget));
	int icaFlags  = precAction->GetInteger(icolActionType);
	int icaType   = icaFlags & icaTypeMask;
	int icaSource = icaFlags & icaSourceMask;

	// determine if action may run on both client and server and resolve execution
	int iPassFlags = icaFlags & icaPassMask;
	if ((iPassFlags == icaFirstSequence  && (m_fMode & iefSecondSequence))
	 || (iPassFlags == icaOncePerProcess && g_scServerContext == scClient && (m_fMode & iefSecondSequence))
	 || (iPassFlags == icaClientRepeat   && (g_scServerContext != scClient || !(m_fMode & iefSecondSequence))))
	{
		LPCSTR szOption = NULL;
		switch (iPassFlags)
		{
		case icaFirstSequence: szOption = "msidbCustomActionTypeFirstSequence"; break;
		case icaOncePerProcess: szOption = "msidbCustomActionTypeOncePerProcess"; break;
		case icaClientRepeat: szOption = "msidbCustomActionTypeClientRepeat"; break;
		default: szOption = "unknown scheduling"; break;
		}
		DEBUGMSGV1("Skipping action due to %s option.", szOption);
		return iesNoAction;
	}

	// check for property or directory assignment, fast execution and return
	if (icaType == icaTextData)
	{
		MsiString istrValue = FormatText(*istrTarget);
		switch (icaFlags & (icaSourceMask | icaInScript | icaContinue | icaAsync))
		{
		case icaProperty:
			SetProperty(*istrSource, *istrValue);
			break;
		case icaDirectory:
		{
			PMsiRecord pError = SetTargetPath(*istrSource, istrValue, fFalse);
			if (pError)
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return FatalError(*pError);
			}
			break;
		}
		case icaSourceFile: // "error message" custom action - simply put up an error message and
								  // return "failure"
		{
			PMsiRecord pErrorMsgRec = &CreateRecord(1);

			int iError = istrValue;
			if(iError != iMsiStringBadInteger)
			{
				// source is an integer - grab the string from the Error table
				AssertNonZero(pErrorMsgRec->SetMsiString(0, *MsiString(GetErrorTableString(iError))));
			}
			else
			{
				// target is a string that we will use
				AssertNonZero(pErrorMsgRec->SetMsiString(0, *istrValue));
			}

			Message(imtEnum(imtError|imtSendToEventLog), *pErrorMsgRec);  // same message type used by LaunchConditions action
			return iesFailure;
		}
		default: // icaBinaryData, icaSourceFile OR invalid flags: icaInScript/Continue/Async
			return FatalError(*PMsiRecord(PostError(Imsg(idbgInvalidCustomActionType), szAction)));
		}
		return iesSuccess;
	}

	// DLL, Script, EXE, and Nested Install custom actions cannot execute in a restricted engine
	if (m_fRestrictedEngine)
	{
		DEBUGMSG1(TEXT("Action '%s' is not permitted in a restricted engine."), szAction);
		return iesNoAction;
	}

	// check for property reference, set istrSource to property value
	if (icaSource == icaProperty)
	{
		istrSource = MsiString(GetProperty(*istrSource));
	}

	// check for nested install, source data processed specially
	if (icaType == icaInstall)
	{
		// for nested installs, only valid types are "substorage", "product code" and "relative path"
		// async is not allowed
		// no pass flags (rollback, commit, runonce, etc...) are allowed
		if ((icaSource == icaProperty) || (icaFlags & icaAsync) || (iPassFlags != 0))
		{
			return FatalError(*PMsiRecord(PostError(Imsg(idbgInvalidCustomActionType), szAction)));  //!! new message?
		}

		CMsiEngine* piEngine = 0;
		PMsiDatabase pDatabase(0);
		if (icaSource == icaSourceFile)
		{
			PMsiRecord pError(0);
			MsiString istrTemp = istrSource;
			if ((pError = ENG::GetSourcedir(*this, *&istrSource)) != 0)
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return FatalError(*pError);
			}

			istrSource += istrTemp;
		}
		return RunNestedInstallCustomAction(*istrSource,*istrTarget,szAction,icaFlags,iioChild);
	}

	// If we are installing on Hydra5 in a per-machine install, set the icaNoImpersonate flag.
	// Running the CA elevated will cause the CAs HKCU reg writes to go to .Default. This
	// enables the hydra registry propogation system. Security issues are equivalent to
	// a machine deployment scenario.
	if (g_iMajorVersion >= 5 && IsTerminalServerInstalled() && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
	{
		if (!(icaFlags & icaNoImpersonate) && (icaFlags & icaInScript))
		{
			DEBUGMSG("Not impersonating action for per-machine Win2000 TS install.");
			icaFlags |= icaNoImpersonate;
		}
	}

	// check for stream in binary table, set pStream to data stream
	IMsiStream* piStream = 0; // we want to control its release.  Must be before the view
	IMsiView* piView = 0; // DO NOT release.  ViewAndStreamRelease ensures released in correct order.  View must be released after stream
	CViewAndStreamRelease ViewAndStreamRelease(&piStream, &piView); // ensures releases are in correct order
	if (icaSource == icaBinaryData)
	{
		ICHAR rgchQueryBuf[256];  // large enough for any query string
		wsprintf(rgchQueryBuf, sqlCustomActionBinary, (const ICHAR*)istrSource); // faster than parameterized query
		PMsiRecord precError(OpenView(rgchQueryBuf, ivcFetch, piView));
		if (precError != 0
		|| (precError = piView->Execute(0)) != 0)
		{
			AssertSz(0, MsiString(precError->FormatText(fFalse)));
			return FatalError(*PMsiRecord(PostError(Imsg(idbgCustomActionNotInBinaryTable), szAction))); //?? is this right return
		}
		IMsiRecord* pirecBinary = piView->Fetch();
		if (pirecBinary)
		{
			piStream = (IMsiStream*)pirecBinary->GetMsiData(1);
			pirecBinary->Release();
		}
		if (!piStream)
			return FatalError(*PMsiRecord(PostError(Imsg(idbgCustomActionNotInBinaryTable), szAction)));
	}

	// check for reference to installed file, set istrSource to full file path
	if (icaSource == icaSourceFile)
	{
		MsiString strFile = istrSource;
		PMsiRecord pError = GetFileInstalledLocation(*strFile,*&istrSource);
		if(pError)
			return FatalError(*pError); //!! do we want to do something else?
	}

	// check for script data, execute script, and return
	if (icaType == icaJScript || icaType == icaVBScript)
	{
		iesEnum iesStatus = iesSuccess;
		if (icaSource == icaDirectory)  // Source column ignored, should be empty
		{
			istrSource = istrTarget;  // can't use FormatText, removes template markers
			istrTarget = (const ICHAR*)0;
		}
		else if (icaSource == icaBinaryData)  // piStream already initialized
			::CopyStreamToString(*piStream, *&istrSource);

		if ((icaFlags & icaInScript) == 0)  // execute if not scheduled
		{
			if (icaSource == icaSourceFile)
			{
				PMsiRecord pError = ::CreateFileStream(istrSource, fFalse, *&piStream);
				if (pError)
				{
					if ((icaFlags & icaContinue) != 0)
						return Message(imtInfo, *pError), iesSuccess;
					else
						return FatalError(*pError);
				}
				::CopyStreamToString(*piStream, *&istrSource);
			}
			// release stream so that if this custom action calls other custom actions (via MsiDoAction) and they
			// live in the same DLL, they can still be accessed
			ViewAndStreamRelease.ReleaseAll();

			IDispatch* piDispatch = ENG::CreateAutoEngine(ENG::CreateMsiHandle((IMsiEngine*)this, iidMsiEngine));
			AddRef();   // CreateMsiHandle grabs the ref count
			Assert(piDispatch);

            // if the script action is running on NT/2000, we need to run it through the custom action server
            PMsiRecord piError = 0;
            int iResult = 0;
            if (!g_fWin9X)
            {
                iResult = CustomRemoteScriptAction(/*fRunScriptElevated*/false, icaFlags, (IMsiEngine*)this, piDispatch, istrSource, istrTarget, &piError);
            }
            else
            {
                // otherwise, we're on Win9X
                g_MessageContext.DisableTimeout();

				// if in UIThread, disable messages to prevent deadlock
				if (g_MessageContext.IsUIThread())
				{
					// impersonate ThreadId is used to disable message processing during a 
					// synchronous custom action (to avoid deadlock in UI handler)
					DWORD dwImpersonateThreadId = GetCurrentThreadId();

					// store the impersonate ThreadId in the Session object
					((CAutoEngine*)(piDispatch))->m_dwThreadId = dwImpersonateThreadId;

					// disable thread messages to the UI handler from this thread
					g_MessageContext.DisableThreadMessages(dwImpersonateThreadId);
				}

                RunScriptAction(icaType, piDispatch, istrSource, istrTarget, g_BasicUI.GetPackageLanguage(), g_message.m_hwnd, iResult, &piError);

				// re-enable messages
				if (g_MessageContext.IsUIThread())
					g_MessageContext.EnableMessages();

                g_MessageContext.EnableTimeout();
            }

            if (piError)
            {
                piError->SetString(2, szAction);
                if ((icaFlags & icaContinue) != 0)
                {
                    DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
                    Message(imtInfo, *piError);
                    iesStatus = iesSuccess;
                }
                else
                    iesStatus = FatalError(*piError);
            }
            else
            {
                // no error
                iesStatus = (icaFlags & icaContinue) != 0 ? iesSuccess : (iesEnum)iResult;
            }

            piDispatch->Release();
            return iesStatus;
        }
    }
    else if (icaType == icaDll)
    {
		if (icaSource == icaDirectory || icaSource == icaProperty   // unsupported for existing DLLs, security issue
			|| (icaFlags & (icaAsync | icaInScript | icaRollback)) == (icaAsync | icaInScript | icaRollback))   // asyncronous call during rollback not supported
			return FatalError(*PMsiRecord(PostError(Imsg(idbgInvalidCustomActionType), szAction)));
    }
    else if (icaType == icaExe)
    {
		if (icaSource == icaDirectory && istrSource.TextSize()) // if Directory table reference, use for working directory
		{
			PMsiPath pTarget(0);
			PMsiRecord pError = GetTargetPath(*istrSource, *&pTarget);
			if (pError)
				return FatalError(*pError);
			istrSource = pTarget->GetPath();
		}
		istrTarget = FormatText(*istrTarget);  // format any parameterized command-line args
    }
    else
		return iesBadActionData;  // unknown custom action type

	// check if debug break set for this action
	if (IsAdmin())
	{
		MsiString istrBreak = GetPropertyFromSz(TEXT("%MsiBreak"));
		if (istrBreak.Compare(iscExact, szAction) == 1)
			icaFlags |= icaDebugBreak;
	}

	if (icaFlags & icaInScript)  // update and queue execute if deferred
	{
		if (icaType != icaJScript && icaType != icaVBScript && icaSource == icaBinaryData)
			precAction->SetMsiData(icolSource, piStream);
		else
			precAction->SetMsiString(icolSource, *istrSource);
		precAction->SetMsiString(icolTarget, *istrTarget);
		precAction->SetInteger(icolActionType, icaFlags);
		precAction->SetMsiString(icolContextData, *MsiString(GetPropertyFromSz(szAction)));
		iesReturn = ExecuteRecord(ixoCustomActionSchedule, *precAction);
		return iesReturn;
	}

	// initialize thread data object for EXE or DLL custom action
	CActionThreadData* pThreadData = new CActionThreadData(*this, this, szAction, icaFlags,
							m_rgpiMessageHeader[imsgActionEnded], m_fRunScriptElevated, this->m_fCAShimsEnabled, &this->m_guidAppCompatDB, &this->m_guidAppCompatID);
	if ( ! pThreadData )
		return iesFailure;

	// if Binary table stream, create temp file for DLL or EXE
	if (icaSource == icaBinaryData)
	{
		while (!pThreadData->CreateTempFile(*piStream, *&istrSource))
		{
			if(false == PostScriptWriteError(*this))
			{
				delete pThreadData;
				return iesFailure;
			}
			piStream->Reset();
		}
		// release stream so that if this custom action calls other custom actions (via MsiDoAction) and they
		// live in the same DLL, they can still be accessed
		ViewAndStreamRelease.ReleaseAll();
	}

	// create a separate thread for launching the custom action and cleaning up afterwards
	if (icaType == icaDll)
	{
		AddRef();  // CreateMsiHandle does not AddRef();

		Bool fRet = fTrue;

        // for security reasons, all DLL CAs run remoted when on Win2000 or NT4
        if (!g_fWin9X)
        {
            pThreadData->InitializeRemoteDLL(*istrSource, *istrTarget, ENG::CreateMsiHandle((IMsiEngine*)this, iidMsiEngine));
        }
        else
        {
            fRet = pThreadData->InitializeDLL(*istrSource, *istrTarget, ENG::CreateMsiHandle((IMsiEngine*)this, iidMsiEngine));
        }


		if (!fRet)
		{
			delete pThreadData;
			PMsiRecord precError(PostError(Imsg(imsgCustomActionLoadLibrary), *MsiString(szAction),
													 *istrTarget, *istrSource));
			if ((icaFlags & icaContinue) != 0)
				return Message(imtInfo, *precError), iesSuccess;
			else
				return FatalError(*precError);
		}
		iesReturn = pThreadData->RunThread();

		// check for problems creating the CA server.
		if (iesReturn == iesServiceConnectionFailed)
			return FatalError(*PMsiRecord(PostError(Imsg(imsgServiceConnectionFailure))));

		if (iesReturn == iesBadActionData)  // crashes always fatal
			return FatalError(*PMsiRecord(PostError(Imsg(idbgCustomActionDied), szAction)));

		if (iesReturn == iesDLLLoadFailed)
		{
			PMsiRecord precError(PostError(Imsg(imsgCustomActionLoadLibrary), *MsiString(szAction),
													 *istrTarget, *istrSource));
			if ((icaFlags & icaContinue) != 0)
				return Message(imtInfo, *precError), iesSuccess;
			else
				return FatalError(*precError);
		}

		if ((icaFlags & icaContinue) != 0)
			return iesSuccess;
		return iesReturn;
	}
	else // (icaType == icaExe)
	{
		pThreadData->InitializeEXE(*istrSource, *istrTarget);
		iesReturn = pThreadData->RunThread();
		if (iesReturn != iesSuccess && iesReturn != iesNotDoneYet)     // EXE returned non-zero result and return not ignored
		{
			IErrorCode imsg = (iesReturn == iesExeLoadFailed ? Imsg(imsgCustomActionCreateExe)
															 : Imsg(imsgCustomActionExeFailed));
			PMsiRecord precError(PostError(imsg, *MsiString(szAction), *istrSource, *istrTarget));
			if ((icaFlags & icaContinue) != 0)
				return Message(imtInfo, *precError), iesSuccess;
			else
				return FatalError(*precError);
		}
		return iesReturn;
	}
}

iesEnum ScheduledCustomAction(IMsiRecord& riParams, const IMsiString& ristrProductCode,
				LANGID langid, IMsiMessage& riMessage, bool fRunScriptElevated, bool fAppCompatEnabled, 
				const GUID* guidAppCompatDB, const GUID* guidAppCompatID)
{
	// get custom action parameters and decode type
	int icaFlags  = riParams.GetInteger(icolActionType);
	if (icaFlags & icaRollback)
		icaFlags += icaContinue;  // force UI suppression and termination if during rollback
	int icaType   = icaFlags & icaTypeMask;
	int icaSource = icaFlags & icaSourceMask;
	const ICHAR* szAction = riParams.GetString(icolAction);
	MsiString istrTarget(riParams.GetMsiString(icolTarget));
	MsiString istrSource;
	MsiString istrContext(riParams.GetMsiString(icolContextData));
	iesEnum iesStatus = iesSuccess;

	if (icaType == icaJScript || icaType == icaVBScript)
	{
		IErrorCode iecError = 0;  // integer in SHIP, string in DEBUG
		istrSource = riParams.GetMsiString(icolSource);
		if (icaSource == icaSourceFile)
		{
			PMsiStream pStream(0);
			PMsiRecord pError = ::CreateFileStream(istrSource, fFalse, *&pStream);
			if (pError)
			{
				riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError, *pError);
				return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
			}
			::CopyStreamToString(*pStream, *&istrSource);
		}
		IDispatch* piDispatch = ENG::CreateAutoEngine(ENG::CreateCustomActionContext(icaFlags,
										*istrContext, ristrProductCode, langid, riMessage));
		Assert(piDispatch);

	// if not on Win9X, scripts run via the custom action server.
	PMsiRecord piError = 0;
	int iResult = 0;

        if (!g_fWin9X)
        {
            iResult = CustomRemoteScriptAction(fRunScriptElevated, icaFlags, NULL, piDispatch, istrSource, istrTarget, &piError);
        }
        else
        {
            // otherwise, we're onWin9X
            g_MessageContext.DisableTimeout();

			// if in UIThread, disable messages to prevent deadlock
			if (g_MessageContext.IsUIThread())
			{
				// impersonate ThreadId is used to disable message processing during a 
				// synchronous custom action (to avoid deadlock in UI handler)
				DWORD dwImpersonateThreadId = GetCurrentThreadId();

				// store the impersonate ThreadId in the Session object
				((CAutoEngine*)(piDispatch))->m_dwThreadId = dwImpersonateThreadId;

				// disable thread messages to the UI handler from this thread
				g_MessageContext.DisableThreadMessages(dwImpersonateThreadId);
			}

            RunScriptAction(icaType, piDispatch, istrSource, istrTarget, langid, WIN::GetActiveWindow(), iResult, &piError);

			// re-enable messages
			if (g_MessageContext.IsUIThread())
				g_MessageContext.EnableMessages();

            g_MessageContext.EnableTimeout();
        }
		if (piError)
		{
			// problem with action execution
			piError->SetString(2, szAction);
			DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError, *piError);
			iesStatus = (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
		}
		else
		{
			// no error
			iesStatus = (icaFlags & icaContinue) != 0 ? iesSuccess : (iesEnum)iResult;
		}

		piDispatch->Release();
		return iesStatus;
	}

	CActionThreadData* pThreadData = new CActionThreadData(riMessage, 0, szAction, icaFlags, 0, fRunScriptElevated, fAppCompatEnabled, guidAppCompatDB, guidAppCompatID);
	if ( ! pThreadData )
		return iesFailure;

	if (icaSource == icaBinaryData)
	{
		PMsiStream pStream = (IMsiStream*)riParams.GetMsiData(icolSource); //!! should use QueryInterface?
		if (!pStream)
		{
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
					*PMsiRecord(::PostError(Imsg(idbgCustomActionNotInBinaryTable), szAction)));
			return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
		}

		Assert(pStream);
		g_MessageContext.DisableTimeout();
		Bool fRet = pThreadData->CreateTempFile(*pStream, *&istrSource);
		g_MessageContext.EnableTimeout();
		if (!fRet)
		{
			delete pThreadData;
			return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
		}
	}
	else
		istrSource = riParams.GetMsiString(icolSource);

	if (riMessage.Message(imtProgress, *g_piNullRecord) == imsCancel)
		return iesUserExit;

	if (icaType == icaDll)
	{
		Bool fRet = fTrue;

        // for security reasons, all DLLs run remoted on NT4 or Win2000
        if (!g_fWin9X)
        {
            pThreadData->InitializeRemoteDLL(*istrSource, *istrTarget,
                            ENG::CreateCustomActionContext(icaFlags, *istrContext,
                            ristrProductCode, langid, riMessage));
        }
        else
        {
            fRet = pThreadData->InitializeDLL(*istrSource, *istrTarget,
                                ENG::CreateCustomActionContext(icaFlags, *istrContext,
                                ristrProductCode, langid, riMessage));
        }

		if (!fRet)
		{
			delete pThreadData;
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
					*PMsiRecord(::PostError(Imsg(imsgCustomActionLoadLibrary), szAction, (const ICHAR*)istrTarget, (const ICHAR*)istrSource)));
			return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
		}
	}
	else // (icaType == icaExe)
	{
		pThreadData->InitializeEXE(*istrSource, *istrTarget);
	}
	iesStatus = pThreadData->RunThread();
	if(icaFlags & icaNoTranslate)   // handle call for running self-reg from MsiExec
		return iesStatus;  // return the result as is
	if (iesStatus == iesNotDoneYet)     // EXE still running, we can ignore that here
		iesStatus = iesSuccess;

	// display error for exes only - dlls handle own errors
	if (iesStatus != iesSuccess)
	{
		if (icaType == icaDll && iesStatus == iesDLLLoadFailed)
		{
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
				*PMsiRecord(::PostError(Imsg(imsgCustomActionLoadLibrary), szAction,
										 (const ICHAR*)istrTarget, (const ICHAR*)istrSource)));
			iesStatus = iesFailure;
		}

		if(icaType == icaExe)
		{
			IErrorCode imsg = (iesStatus == iesExeLoadFailed ? Imsg(imsgCustomActionCreateExe)
															 : Imsg(imsgCustomActionExeFailed));
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
					*PMsiRecord(::PostError(imsg, szAction, (const ICHAR*)istrSource, (const ICHAR*)istrTarget)));

			if(iesStatus == iesExeLoadFailed)
				iesStatus = iesFailure;

		}
		if(icaFlags & icaContinue)
			iesStatus = iesSuccess;
	}
	return iesStatus;
}

//____________________________________________________________________________
//
// CMsiEngine local methods related to action processing
//____________________________________________________________________________

Bool CMsiEngine::GetActionText(const ICHAR* szAction, const IMsiString*& rpistrDescription,
										 const IMsiString*& rpistrTemplate)
{
	if(!szAction || *szAction == 0)
		return fFalse;

	MsiString strTemp(TEXT(""));
	strTemp.ReturnArg(rpistrTemplate);
	strTemp.ReturnArg(rpistrDescription);

	bool fLookupDll = false;
	if (!m_piActionTextCursor)
	{
		PMsiTable pActionTextTable(0);
		PMsiRecord pError(0);
		if((pError = m_piDatabase->LoadTable(*MsiString(*TEXT("ActionText")),0,*&pActionTextTable)) != 0)
			fLookupDll = true;
		else
		{
			m_piActionTextCursor = pActionTextTable->CreateCursor(fFalse);
			m_piActionTextCursor->SetFilter(iColumnBit(1));
		}
	}
	if ( !fLookupDll )
	{
		AssertNonZero(m_piActionTextCursor->PutString(1,*MsiString(szAction)));
		if( !m_piActionTextCursor->Next() )
			fLookupDll = true;
		else
		{
			rpistrDescription = &m_piActionTextCursor->GetString(2);
			rpistrTemplate = &m_piActionTextCursor->GetString(3);
		}
		m_piActionTextCursor->Reset();
	}
	if ( !fLookupDll )
		return fTrue;

	//  the action text hasn't been found in the table; I look it up in the message DLL.
	HMODULE hLib = WIN::LoadLibraryEx(MSI_MESSAGES_NAME, NULL,
												 LOAD_LIBRARY_AS_DATAFILE);
	if ( hLib )
	{
		WORD wLanguage = (WORD)GetPropertyInt(*MsiString(IPROPNAME_INSTALLLANGUAGE));
		int iRetry = (wLanguage == 0) ? 1 : 0;
		bool fEndLoop = false;

		while ( !fEndLoop )
		{
			if ( !MsiSwitchLanguage(iRetry, wLanguage) )
			{
				fEndLoop = true;        //  we've run out of languages
				continue;
			}

			HRSRC   hRsrc;
			HGLOBAL hGlobal;
			CHAR* szText;

			if ( (hRsrc = FindResourceEx(hLib, RT_RCDATA, (LPCTSTR)szAction, wLanguage)) != 0
				  && (hGlobal = LoadResource(hLib, hRsrc)) != 0
				  && (szText = (CHAR*)LockResource(hGlobal)) != 0
				  && *szText != 0 )
			{
				CTempBuffer<ICHAR, MAX_PATH> szBuffer;
				int cch = 0;
#ifdef UNICODE
				unsigned int iCodePage = MsiGetCodepage(wLanguage);
				cch = WIN::MultiByteToWideChar(iCodePage, 0, szText, -1, 0, 0);
				if ( cch )
				{
					szBuffer.SetSize(cch);
					AssertNonZero(WIN::MultiByteToWideChar(iCodePage, 0, szText, -1,
																		szBuffer, cch));
				}
#else
				cch = IStrLen(szText);
				if ( cch )
				{
					szBuffer.SetSize(cch+1);
					IStrCopy(szBuffer, szText);
				}
#endif // UNICODE
				if ( cch )
				{
					ICHAR * pchTab = IStrChr(szBuffer, TEXT('\t'));
					MsiString strTemp;
					if ( pchTab )
					{
						*pchTab = 0;
						strTemp = pchTab+1;
						strTemp.ReturnArg(rpistrTemplate);
					}
					else
						AssertSz(0, TEXT("Tab character should be present in ActionText generated string!"));
					strTemp = (ICHAR*)szBuffer;
					strTemp.ReturnArg(rpistrDescription);
				}
				fEndLoop = (rpistrDescription->TextSize() || rpistrTemplate->TextSize());

			}       // if find & load resource

		}       // while ( !fEndLoop )
		AssertNonZero(WIN::FreeLibrary(hLib));

	}       // if ( hLib )

	return (rpistrDescription->TextSize() || rpistrTemplate->TextSize()) ? fTrue : fFalse;
}

IMsiRecord* CMsiEngine::FetchSingleRow(const ICHAR* szQuery, const ICHAR* szValue)
{
	CTempBuffer<ICHAR, MAX_PATH+1> rgchQueryBuf;  // should be large enough for any query string
	AssertSz(szQuery && *szQuery, TEXT("Bad szQuery argument in CMsiEngine::FetchSingleRow"));
	AssertSz(szValue, TEXT("Bad szValue argument in CMsiEngine::FetchSingleRow"));
	//  I assume that in the case the combined string is larger than MAX_PATH chars
	//  szValue is replaced only once in szQuery.
	rgchQueryBuf.SetSize(IStrLen(szQuery) + IStrLen(szValue) + 1);
	wsprintf(rgchQueryBuf, szQuery, szValue); // faster than parameterized query
	PMsiView pView(0);
	PMsiRecord precError(OpenView(rgchQueryBuf, ivcFetch, *&pView));
	if (precError != 0
	|| (precError = pView->Execute(0)) != 0)
	{
		AssertSz(0, MsiString(precError->FormatText(fFalse)));
		return 0;
	}
	return pView->Fetch();
}

IMsiRecord* CMsiEngine::GetFileInstalledLocation(const IMsiString& ristrFile,
												 const IMsiString*& rpistrFilePath, bool fUseRequestedComponentState, bool *pfSourceResolutionAttempted)
{
	PMsiTable pFileTable(0);
	IMsiRecord* piError = 0;

	piError = LoadFileTable(0, *&pFileTable);

	if (piError)
		return piError;

	PMsiCursor pFileCursor = pFileTable->CreateCursor(fFalse);

	pFileCursor->SetFilter(iColumnBit(m_mpeftCol[ieftKey]));
	pFileCursor->PutString(m_mpeftCol[ieftKey], ristrFile);

	if (!pFileCursor->Next())
		return PostError(Imsg(idbgBadFile),ristrFile);

	MsiStringId idComponent = pFileCursor->GetInteger(m_mpeftCol[ieftComponent]);

	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pComponentCursor = m_piComponentTable->CreateCursor(fFalse);
	if (!pComponentCursor)
		return PostError(Imsg(imsgOutOfMemory));

	pComponentCursor->SetFilter(iColumnBit(m_colComponentKey));
	pComponentCursor->PutInteger(m_colComponentKey, idComponent);

	if (!pComponentCursor->Next())
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponent)));

	PMsiPath pPath(0);
	int iefLFN = iefSuppressLFN;

	iisEnum iisState = (iisEnum)pComponentCursor->GetInteger(m_colComponentAction);
	if(iisState == iMsiNullInteger && fUseRequestedComponentState)
		iisState = (iisEnum)pComponentCursor->GetInteger(m_colComponentActionRequest);
	if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent || iisState == iMsiNullInteger)
	{
		// If the action state is Absent or the state is not changing, we should get the Installed
		// state to cover the cases where the state is not chaning, or the file is schedule for
		// removal (In this case the caller/Custom Action should be conditioned properly to use this
		// information before the file is removed).
		iisState = (iisEnum)pComponentCursor->GetInteger(m_colComponentInstalled);
	}

	if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent || iisState == iMsiNullInteger)
	{
		return PostError(Imsg(idbgFileNotMarkedForInstall),ristrFile);
	}
	else if(iisState == iisSource)
	{
		if (pfSourceResolutionAttempted)
			*pfSourceResolutionAttempted = true;

		if((piError = GetSourcePath(*MsiString(pComponentCursor->GetString(m_colComponentDir)),*&pPath)) != 0)
			return piError;
		iefLFN = iefNoSourceLFN;
	}
	else if(iisState == iisLocal)
	{
		if((piError = GetTargetPath(*MsiString(pComponentCursor->GetString(m_colComponentDir)),*&pPath)) != 0)
			return piError;
		iefLFN = iefSuppressLFN;
	}
	else
		AssertSz(0, "Invalid component action state in GetFileInstalledLocation");

	Bool fLFN = ((GetMode() & iefLFN) == 0 && pPath->SupportsLFN()) ? fTrue : fFalse;
	MsiString strFileName;
	if((piError = m_riServices.ExtractFileName(MsiString(pFileCursor->GetString(m_mpeftCol[ieftName])),fLFN,*&strFileName)) != 0 ||
		(piError = pPath->GetFullFilePath(strFileName, rpistrFilePath)) != 0)
	{
		return piError;
	}

	return 0;
}

/*----------------------------------------------------------------------------
  CMsiEngine::Sequence() - overall action sequencer
 [1] = Name of action, used for lookup in engine, handler, CustomAction table
 [2] = (optional) Localized text for action, separated with a ':' from:
       (optional) Localized action data record format template string
 [3] = Condition expression, action called only if result is fTrue
 [4] = Sequence number, negative numbers reserved for exit actions:
       -1 for iesSuccess, -2 for iesUserExit, -3 for iesFailure

  Note: this function may be called recursively! As such, it should not do
  anything that may break during recursion.
----------------------------------------------------------------------------*/

const ICHAR sqlActionsTemplate[] =
TEXT("SELECT `Action`,NULL,`Condition` FROM `%s` WHERE `Sequence` > 0 ORDER BY `Sequence`");

const ICHAR sqlFinalTemplate[] =
TEXT("SELECT `Action`,NULL,`Condition` FROM `%s` WHERE `Sequence` = ?");

iesEnum CMsiEngine::Sequence(const ICHAR* szTable)
{
	if (m_fInitialized == fFalse)
		return iesWrongState;

	m_cSequenceLevels++; // must decrement before we return

	// Open Action table and begin sequencing
	// Does not return to install host until completion or abort

	ICHAR sqlActions[sizeof(sqlActionsTemplate)/sizeof(ICHAR) + 3*32];

	PMsiView pSequenceView(0);
	wsprintf(sqlActions, sqlActionsTemplate, szTable);

	// nothing to do.
	if (!m_piDatabase->FindTable(*MsiString(*szTable)))
		return(m_cSequenceLevels--, iesSuccess);

	PMsiRecord Error(m_piDatabase->OpenView(sqlActions, ivcFetch, *&pSequenceView));
	if (Error)
		return (m_cSequenceLevels--, FatalError(*Error));
	Error = pSequenceView->Execute(0);
	if (Error)
		return (m_cSequenceLevels--, FatalError(*Error));
	iesEnum iesReturn = iesSuccess;  // status to return to caller
	iesEnum iesAction = iesSuccess;  // result of previous action
	const ICHAR* szAction = 0;       //!! watch out, this is used after the record to which it points is out of scope
	m_issSegment = issPreExecution;
	while (iesReturn == iesSuccess)
	{
		iesReturn = iesAction;
		if (iesReturn != iesSuccess)
		{
			if(m_cSequenceLevels-1 == m_cExecutionPhaseSequenceLevel)
			{
				// User may elect to abort if rollback fails
				iesEnum iesEndTrans = EndTransaction(iesReturn);
				Assert(iesEndTrans == iesSuccess || iesEndTrans == iesUserExit || iesEndTrans == iesFailure);
			}

			if(m_cSequenceLevels == 1)  // one final pass to process terminate action
			{
				ENG::WaitForCustomActionThreads(this, fFalse, *this); // wait for async custom actions, except if icaContinue

				if (iesReturn == iesBadActionData)  // currently no exit dialog (custom action not found, or bad expression)
				{
					iesReturn = iesFailure;  // should be an exit dialog for this
					Error = PostError(Imsg(idbgBadActionData), szAction);
					Message(imtError, *Error);
				}

				// display the final confirmation dialog if necessary
				if(m_fEndDialog && !m_piParentEngine &&
					(
						// successful completion with no pending reboot prompt
						((iesReturn == iesSuccess || iesReturn == iesFinished) &&
						 ((GetMode() & (iefReboot|iefRebootNow)) == 0))

						||

						// failure
						(iesReturn == iesFailure)
				  ))
				{
					Error = PostError(iesReturn == iesFailure ? Imsg(imsgInstallFailed) : Imsg(imsgInstallSucceeded));
					Message(imtEnum(imtUser|imtForceQuietMessage), *Error);
				}

				pSequenceView->Close();
				wsprintf(sqlActions, sqlFinalTemplate, szTable);
				Error = m_piDatabase->OpenView(sqlActions, ivcFetch, *&pSequenceView);
				if (Error)
				{
					m_issSegment = issNotSequenced;
					return (m_cSequenceLevels--, FatalError(*Error));
				}
				PMsiRecord Param = &m_riServices.CreateRecord(1);
				Param->SetInteger(1, iesReturn == iesFinished ? -iesSuccess : -iesReturn);
				AssertRecord(pSequenceView->Execute(Param));
			}
			else
				break;
		}
		PMsiRecord pSequenceRecord(pSequenceView->Fetch());
		if (!pSequenceRecord)
		{
			if (iesReturn != iesSuccess)    // terminate action not found
				break;
			iesAction = iesFinished;
			continue;
		}
		szAction = pSequenceRecord->GetString(easAction);
		if (!szAction)  // should never happen, since easAction is primary key
			continue;
		iecEnum iecStat = EvaluateCondition(pSequenceRecord->GetString(easCondition));

		if (iecStat == iecError)
		{
			iesAction = iesBadActionData;
			continue;
		}
		if (iecStat == iecFalse)
		{
			DEBUGMSG1(TEXT("Skipping action: %s (condition is false)"), szAction);
			continue;
		}
		// else continue if iecTrue or iecNone

		// nothing set before the call to DoAction should be depended upon after the call
		// - DoAction may possibly call Sequence
		iesAction = DoAction(szAction);
		if(iesAction == iesNoAction)
			iesAction = iesSuccess;

	}
	m_cSequenceLevels--;
	m_issSegment = issNotSequenced;
	return iesReturn == iesFinished ? iesSuccess : iesReturn; //JDELO
}

//______________________________________________________________________________
//
// CScriptSite implementation
//______________________________________________________________________________

const WCHAR g_szHostItemName[] = L"Session";

// temporary logging for development use
BOOL g_fLogCalls = FALSE;
const WCHAR*  g_szErrorContext = L"";        // normally a static string, never freed
const WCHAR*  g_szErrorContextString = L"";  // only valid during call to SetContext
int           g_iErrorContextInt = 0x80000000L;

void SetContextInt(int iContext)
{
	g_iErrorContextInt = iContext;
}
void SetContextString(const WCHAR* szContext)
{
	g_szErrorContextString = szContext;
}
void SetContext(const WCHAR* szContext)
{
	g_szErrorContext = szContext;
	if (g_fLogCalls)
	{
//              if (g_iErrorContextInt == 0x80000000L)
//                      wprintf(L"%s %s\n", g_szErrorContext, g_szErrorContextString);
//              else
//                      wprintf(L"%s %s 0x%X\n", g_szErrorContext, g_szErrorContextString, g_iErrorContextInt);
	}
	g_iErrorContextInt = 0x80000000L;
	g_szErrorContextString = L"";
}

HRESULT __stdcall CScriptSite::QueryInterface(const IID& riid, void** ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;
	SetContextInt(riid.Data1);
	*ppvObj = 0L;
	if (riid == IID_IUnknown || riid == IID_IActiveScriptSite)
		*ppvObj = (IActiveScriptSite*)this;
	else if (riid == IID_IActiveScriptSiteWindow)
		*ppvObj = (IActiveScriptSiteWindow*)this;
	else
	{
		SetContext(L"QueryInterface failed");
		return E_NOINTERFACE;
	}
	SetContext(L"QueryInterface succeeded");
	AddRef();
	return S_OK;
}

ULONG CScriptSite::AddRef()
{
	return ++m_iRefCnt;
}

ULONG CScriptSite::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT __stdcall CScriptSite::GetLCID(LCID* plcid)
{
	SetContext(L"GetLCID");
	*plcid = m_langid;
	return S_OK;
}

HRESULT __stdcall CScriptSite::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppiunk, ITypeInfo **ppiTypeInfo)
{
	SetContextString(g_szHostItemName);
	SetContextInt(dwReturnMask);
	SetContext(L"GetItemInfo");
	if (lstrcmpiW(pstrName, g_szHostItemName) != 0)
			return TYPE_E_ELEMENTNOTFOUND;
	if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
		return E_NOTIMPL;
	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	{
		if (!ppiunk)
			return E_INVALIDARG;
		(*ppiunk = m_piHost)->AddRef();
	}
	if (ppiTypeInfo)
		*ppiTypeInfo = 0;  // scripting engines don't use this even if we do set it
	return S_OK;
}

HRESULT __stdcall CScriptSite::GetDocVersionString(BSTR* /* pszVersion */)
{
	SetContext(L"GetDocVersionString");
	return E_NOTIMPL;
}

HRESULT __stdcall CScriptSite::OnScriptTerminate(const VARIANT* /*pvarResult*/, const EXCEPINFO* /*pexcepinfo*/)
{  // never appears to be called from VBScript of JScript
	SetContext(L"OnScriptTerminate");
	return S_OK;
}

HRESULT __stdcall CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
	SetContextInt(ssScriptState);
	SetContext(L"OnStateChange");
	m_ssScriptState = ssScriptState;
	return S_OK;
}

HRESULT __stdcall CScriptSite::OnScriptError(IActiveScriptError *pierror)
{
	SetContext(L"OnScriptError");
	ClearError();
	if (pierror)
	{
		DWORD iContext = 0;
		const WCHAR* szErrorObj = L"Unknown";
		const WCHAR* szErrorDesc = L"(no info)";
		EXCEPINFO excepinfo;
		if (pierror->GetExceptionInfo(&excepinfo) == S_OK)
		{
			m_hrError = excepinfo.scode ? excepinfo.scode : TYPE_E_IOERROR;
			SaveErrorString(m_szErrorObj, excepinfo.bstrSource);
			SaveErrorString(m_szErrorDesc, excepinfo.bstrDescription);
			if (excepinfo.bstrHelpFile)
				OLEAUT32::SysFreeString(excepinfo.bstrHelpFile);
		}
		else  // should never occur
			m_hrError = E_ABORT;
		BSTR bstrSourceLine = 0;
		pierror->GetSourceLineText(&bstrSourceLine);
		SaveErrorString(m_szSourceLine, bstrSourceLine);
		if (pierror->GetSourcePosition(&iContext, &m_iErrorLine, &m_iErrorColumn) == S_OK)
		{
			m_iErrorColumn++;
			m_iErrorLine++;
		}
		else
			m_iErrorColumn = m_iErrorLine = 0;
	}
	return S_OK;  // return S_FALSE to keep running script in debugger, if available, S_OK to keep running regardless
}  // JD: Does not seem to matter what is returned here. Execution stops in all cases.

HRESULT __stdcall CScriptSite::OnEnterScript()
{
	return S_OK;
}

HRESULT __stdcall CScriptSite::OnLeaveScript()
{
	return S_OK;
}

HRESULT __stdcall CScriptSite::GetWindow(HWND *phwnd)
{
	SetContext(L"GetWindow");
	*phwnd = m_hwnd;
//      *phwnd = WIN::GetDesktopWindow();
	return S_OK;
}

HRESULT __stdcall CScriptSite::EnableModeless(BOOL fEnable)
{
	SetContextInt(fEnable);
	SetContext(L"EnableModeless");
//      return WIN::EnableWindow(m_hwnd, fEnable) ? S_OK : E_FAIL;
	return S_OK;
}

CScriptSite* CreateScriptSite(const IID& riidLanguage, IDispatch* piHost,
										HWND hwndParent, LANGID langid)
{
	SetContext(L"CreateScriptSite");
	CScriptSite* piScriptSite = new CScriptSite(hwndParent, langid);
	if (piScriptSite == 0)
		return 0;
	HRESULT hr = piScriptSite->AttachScriptEngine(riidLanguage, piHost);
	if (hr != S_OK)
		DestroyScriptSite(piScriptSite);
	return piScriptSite;
}

void DestroyScriptSite(CScriptSite*& rpiScriptSite)
{
	if (rpiScriptSite == 0)
		return;
	HRESULT hr = rpiScriptSite->CloseScriptEngine();
	if (hr == S_OK)
	{
		rpiScriptSite->Release();
		rpiScriptSite = 0;
	}
}

CScriptSite::CScriptSite(HWND hwndParent, LANGID langid)
	: m_piScriptEngine(0), m_piScriptParse(0), m_piHost(0)
	, m_szErrorObj(0), m_szErrorDesc(0), m_szSourceLine(0)
	, m_hwnd(hwndParent), m_langid(langid), m_iRefCnt(1)
	, m_ssScriptState(SCRIPTSTATE_UNINITIALIZED)
	, m_fCoInitialized(false)
{
	m_varResult.vt = VT_EMPTY;
}

CScriptSite::~CScriptSite()
{
	SetContext(L"CScriptSite Destructor");
	if (m_piScriptParse) m_piScriptParse->Release();
	if (m_piScriptEngine) m_piScriptEngine->Release();
	if (m_piHost) m_piHost->Release();
	if (m_varResult.vt != VT_EMPTY)
		OLEAUT32::VariantClear(&m_varResult);
	if (m_fCoInitialized)
		OLE32::CoUninitialize();
}

void CScriptSite::ClearError()
{
	m_hrError = S_OK;
#ifdef UNICODE
	if (m_szErrorObj)   OLEAUT32::SysFreeString(m_szErrorObj),   m_szErrorObj = 0;
	if (m_szErrorDesc)  OLEAUT32::SysFreeString(m_szErrorDesc),  m_szErrorDesc = 0;
	if (m_szSourceLine) OLEAUT32::SysFreeString(m_szSourceLine), m_szSourceLine = 0;
#else
	if (m_szErrorObj)   delete const_cast<TCHAR*>(m_szErrorObj),   m_szErrorObj = 0;
	if (m_szErrorDesc)  delete const_cast<TCHAR*>(m_szErrorDesc),  m_szErrorDesc = 0;
	if (m_szSourceLine) delete const_cast<TCHAR*>(m_szSourceLine), m_szSourceLine = 0;
#endif
}

HRESULT CScriptSite::AttachScriptEngine(const IID& iidLanguage, IDispatch* piHost)
{
	SetContext(L"Create Script Engine");
	HRESULT hr = OLE32::CoCreateInstance(iidLanguage, 0, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&m_piScriptEngine);
	if (hr == CO_E_NOTINITIALIZED)  // probably called early on from the UI thread
	{
		OLE32::CoInitialize(0);   // initialize OLE and try again
		m_fCoInitialized = true;
		hr = OLE32::CoCreateInstance(iidLanguage, 0, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&m_piScriptEngine);
	}
	if (hr == S_OK)
	{
		SetContext(L"Get Script Parser");
		hr = m_piScriptEngine->QueryInterface(IID_IActiveScriptParse, (void **)&m_piScriptParse);
	}
	if (hr == S_OK)
	{
		(m_piHost = piHost)->AddRef();  // need to do this before AddNamedItem to support callback GetItemInfo
		SetContext(L"SetScriptSite");
		hr = m_piScriptEngine->SetScriptSite(this);
	}
	if (hr == S_OK)
	{
		SetContext(L"IActiveScriptParse::InitNew");
		hr = m_piScriptParse->InitNew();
	}
	if (hr == S_OK)
	{
		SetContext(L"AddNamedItem: Session");
		hr = m_piScriptEngine->AddNamedItem(g_szHostItemName, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
	}
	return hr;
}

HRESULT CScriptSite::ParseScript(const TCHAR* szScript, int cchScriptMax)
{
	SetContext(L"ParseScript");
#ifdef UNICODE
	cchScriptMax;
	HRESULT hr = m_piScriptParse->ParseScriptText(szScript, g_szHostItemName, 0, 0, (DWORD)0, 0, 0L, 0, 0);
#else
	WCHAR* wszScript = new WCHAR[cchScriptMax+1];
	if ( ! wszScript )
		return E_OUTOFMEMORY;
	AssertNonZero(WIN::MultiByteToWideChar(CP_ACP, 0, szScript, -1, wszScript, cchScriptMax+1));
	HRESULT hr = m_piScriptParse->ParseScriptText(wszScript, g_szHostItemName, 0, 0, (DWORD)0, 0, 0L, 0, 0);
#endif
	if (hr == S_OK && m_ssScriptState != SCRIPTSTATE_STARTED)
	{
		SetContext(L"Start script execution");
		m_ssScriptState = SCRIPTSTATE_STARTED; // not set by engine, prevent getting here on recursion
		m_hrError = S_OK;
		hr = m_piScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
		SetContext(L"Script parsed");
		if (hr == S_OK)  // SetScriptState normally succeeds, error set by OnScriptError() callback
			hr = m_hrError;
		m_piScriptEngine->GetScriptState(&m_ssScriptState);
	}
#ifndef UNICODE
	delete wszScript;
#endif
	return hr;
}

HRESULT CScriptSite::CallScriptFunction(const TCHAR* szFunction)
{
#ifdef UNICODE
	OLECHAR* szName = const_cast<OLECHAR*>(szFunction);  // prototype non-const
#else
	OLECHAR rgchBuf[100];
	OLECHAR* szName = rgchBuf;
	AssertNonZero(WIN::MultiByteToWideChar(CP_ACP, 0, szFunction, -1, rgchBuf, sizeof(rgchBuf)/sizeof(OLECHAR)));
#endif
	if (m_ssScriptState != SCRIPTSTATE_CONNECTED)
		return E_UNEXPECTED;  // wrong calling sequence
	SetContext(L"GetScriptDispatch");
	if (m_varResult.vt != VT_EMPTY)
		OLEAUT32::VariantClear(&m_varResult);
	IDispatch* piDispatch;
	HRESULT hr = m_piScriptEngine->GetScriptDispatch(g_szHostItemName, &piDispatch);
//      HRESULT hr = m_piScriptEngine->GetScriptDispatch(0, &piDispatch);
	if (hr != S_OK)
		return hr;
	DISPID dispid;
	SetContextString(szName);
	SetContext(L"GetIDsOfNames");
	hr = piDispatch->GetIDsOfNames(GUID_NULL, &szName, 1, 0, &dispid);
	if (hr != S_OK)
	{
		SetContext(L"GetIDsOfNames(0) failed, trying lcid,");
		hr = piDispatch->GetIDsOfNames(GUID_NULL, &szName, 1, m_langid, &dispid);
		if (hr != S_OK)
		{
			piDispatch->Release();
			return hr;
		}
	}
	SetContext(L"Invoke Script Function");
	unsigned int cArgs = 0;
	DISPPARAMS dispparams = {(VARIANT*)0, (DISPID*)0, cArgs, (unsigned int)0};
	m_hrError = S_OK;
	hr = piDispatch->Invoke(dispid, GUID_NULL, m_langid, DISPATCH_METHOD, &dispparams, &m_varResult, 0, 0);
	piDispatch->Release();
	if (m_hrError != S_OK)  // if error set by OnScriptError() callback
	{
		SetContext(L"Script Function Failed");
		hr = m_hrError;
	}
	return hr;
}

HRESULT CScriptSite::GetIntegerResult(int& riResult)
{
	if (m_varResult.vt == VT_EMPTY)
		return DISP_E_PARAMNOTFOUND;
	HRESULT hr = OLEAUT32::VariantChangeType(&m_varResult, &m_varResult, 0, VT_I4);
	riResult = (hr == S_OK ? m_varResult.lVal : 0);
	return hr;
}

void CScriptSite::SaveErrorString(const TCHAR*& rszSave, BSTR szData)
{
	if (rszSave)
#if UNICODE
		OLEAUT32::SysFreeString(rszSave);
	rszSave = szData;
#else
		delete const_cast<TCHAR*>(rszSave);
	if (szData && *szData)
	{
		unsigned int cb = WIN::WideCharToMultiByte(CP_ACP, 0, szData, -1, 0, 0, 0, 0);
		rszSave = new TCHAR[cb];
		if ( rszSave )
			WIN::WideCharToMultiByte(CP_ACP, 0, szData, -1, const_cast<TCHAR*>(rszSave), cb, 0, 0);
		OLEAUT32::SysFreeString(szData);
	}
	else
		rszSave = 0;
#endif
}

#if 0
HRESULT CScriptSite::GetStringResult(const WCHAR*& rszResult)
{
	if (m_varResult.vt == VT_EMPTY)
		return DISP_E_PARAMNOTFOUND;
	HRESULT hr = WIN::VariantChangeType(&m_varResult, &m_varResult, 0, VT_BSTR);
	rszResult = (hr == S_OK ? m_varResult.bstrVal : 0);
	return hr;
}
#endif
HRESULT CScriptSite::CloseScriptEngine()
{
	SetContext(L"CloseScriptEngine");
	ClearError();
	if (m_piScriptEngine == 0)
		return S_OK;
	return m_piScriptEngine->Close();
}

//____________________________________________________________________________
//
// MessageHandler factory
//____________________________________________________________________________

IUnknown* CreateMessageHandler()
{
	CMsiClientMessage* piMessage = 0;
	if (g_MessageContext.Initialize(fFalse, iuiNone) == NOERROR)
	{
		piMessage = new CMsiClientMessage();
		piMessage->m_fMessageContextInitialized = true;
	}
	return piMessage;
}

//____________________________________________________________________________
//
// Basic UI implementation - simple UI handler
//     Note: cannot use MsiString wrapper objects or Asserts - no MsiServices
//____________________________________________________________________________

CBasicUI::CBasicUI()  // global object, called per-process at DLL load
 : m_fInitialized(false)
 , m_hProgress(0), m_hButtonFont(0), m_iButtonCodepage(0), m_hTextFont(0), m_iTextCodepage(0)
 , m_iPerTick(0), m_iProgress(0), m_iProgressTotal(0), m_fProgressByData(false)
 , m_fCancelVisible(true), m_fNeverShowCancel(false), m_fWindowVisible(false)
 , m_uiStartTime(0), m_uiLastReportTime(0), m_fCaptionChanged(true)
 , m_fHideDialog(false), m_fQuiet(false), m_fBiDi(false), m_fMirrored(false)
 , m_uiBannerText(0), m_iPackageLanguage(0), m_iPackageCodepage(0), m_fUserCancel(false)
{
	m_ipdDirection = ProgressData::ipdForward;
	m_szCaption[0] = 0;
	m_cTotalPrev = 0;
	m_cSoFarPrev = 0;
}

bool CBasicUI::Initialize(HWND hwndParent, bool fQuiet, bool fHideDialog, bool fNoModalDialogs, bool fHideCancel, bool fUseUninstallBannerText, bool fSourceResOnly)
{
	if (m_fInitialized)
		return false;
	m_hwndParent       = hwndParent;
	m_fQuiet           = fQuiet;
	m_fSourceResolutionOnly = (fQuiet && fSourceResOnly);
	m_fHideDialog      = fHideDialog;
	m_fNoModalDialogs  = fNoModalDialogs;
	m_fNeverShowCancel = fHideCancel;
	m_fCancelVisible   = ! fHideCancel;
	m_fUserCancel      = false;

	INITCOMMONCONTROLSEX iccData = {sizeof(INITCOMMONCONTROLSEX), ICC_PROGRESS_CLASS};
	COMCTL32::InitCommonControlsEx(&iccData);

	SetDefaultCaption();
	m_fCaptionChanged = true;
	ICHAR rgchBuf[256] = {0};    // room for "Setup is starting..." message

	m_uiBannerText = IDS_PREPARING_TO_INSTALL;
	if(fUseUninstallBannerText)
		m_uiBannerText = IDS_PREPARING_TO_UNINSTALL;

	m_iPackageCodepage = MsiLoadString(g_hInstance, m_uiBannerText, rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR), GetPackageLanguage());
	Assert(m_iPackageCodepage != 0);

	if(!fQuiet && !fHideDialog)
		SetProgressData(imtActionStart >> imtShiftCount, rgchBuf, true);
	//!! detect errors here?
	m_fInitialized = true;
	return true;
}

//
// The Windows installer title is always in the system codepage
//
void CBasicUI::SetDefaultCaption()
{
	AssertNonZero(MsiLoadString(g_hInstance, IDS_WINDOWS_INSTALLER_TITLE, m_szCaption, sizeof(m_szCaption)/sizeof(ICHAR), 0) != 0);
}

const ICHAR* CBasicUI::GetCaption()
{
	if (m_szCaption[0] == 0)
		SetDefaultCaption();

	return m_szCaption;
}

bool CBasicUI::Terminate()
{
	if (!m_fInitialized)
		return false;
	if (m_hProgress)
		WIN::DestroyWindow(m_hProgress), m_hProgress = 0;
	MsiDestroyFont(m_hButtonFont);
	COMCTL32::Unbind();
	m_fBiDi = false;
	m_fMirrored = false;
	m_uiBannerText = 0;
	m_iButtonCodepage = 0;
	m_iPackageLanguage = 0;
	MsiDestroyFont(m_hTextFont);
	m_iTextCodepage = 0;
	m_fCancelVisible = true;
	m_fNeverShowCancel = false;
	m_fWindowVisible = false;
	m_fQuiet = false;
	m_szCaption[0] = 0;
	m_fCaptionChanged = true;
	m_fInitialized = false;
	m_cTotalPrev = 0;
	m_cSoFarPrev = 0;
	m_fUserCancel = false;
	return true;
}

void CBasicUI::SetUserCancel(bool fCancel)
{
	if (fCancel)
	{
		// show that we have recognized that the user cancelled the install
		// by greying out the cancel button (i.e. disabling)
		HWND hButton = WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL);
		EnableWindow(hButton, /* bEnable = */ FALSE);

		// change banner text to indicate user cancel
		ICHAR rgchBuf[512] = {0};
		AssertNonZero(MsiLoadString(g_hInstance, IDS_CANCELING_INSTALL, rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR), GetPackageLanguage()));
		g_szBannerText.SetSize(IStrLen(rgchBuf) + 1);
		IStrCopy(g_szBannerText, rgchBuf);
		SetProgressData(imtActionStart >> imtShiftCount, g_szBannerText, true);
	}

	// set m_fUserCancel last to make sure it is set to the "user-cancelled" state
	m_fUserCancel = fCancel;
}

imsEnum CBasicUI::FatalError(imtEnum imt, const ICHAR* szMessage)
{
	return (imsEnum)MsiMessageBox(0, szMessage, 0, (imt & ~imtTypeMask) | MB_TASKMODAL, GetPackageCodepage(), GetPackageLanguage());
}

imsEnum CBasicUI::Message(imtEnum imt, IMsiRecord& riRecord)
{
	int iForceQuietMessage = imt & imtForceQuietMessage;
	imt = imtEnum(imt & ~(iInternalFlags));

	int iError = riRecord.GetInteger(1);
	int iMsgBox = imt & ~imtTypeMask;
	UINT uiType = 0;

	switch(imt >> imtShiftCount)
	{
	case imtCommonData  >> imtShiftCount: // language ID, for cacheing by IMsiMessage impl.
	{
		if(iError == (int)icmtLangId)
		{
			if (!riRecord.IsNull(3))  // should always be present unless we are executing an old script
				m_iPackageCodepage = riRecord.GetInteger(3);
			UINT iLangId = riRecord.GetInteger(2);
			if (iLangId != m_iPackageLanguage)
			{
				m_iPackageLanguage = iLangId;
				AssertNonZero(SetCancelButtonText());
			}
		}
		else if(iError == (int)icmtCaption)
		{
			if (!riRecord.IsNull(2))
			{
				IStrCopyLen(m_szCaption, riRecord.GetString(2), cchMaxCaption);
				m_fCaptionChanged = true;
			}
		}
		else if(iError == (int)icmtCancelShow)
		{
			m_fCancelVisible = m_fNeverShowCancel ? false : riRecord.GetInteger(2) != 0;
			if (m_hProgress)
				WIN::ShowWindow(WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL), m_fCancelVisible ? SW_SHOW : SW_HIDE);
			//!! IVAN, fill in the blanks here
		}
		else if (iError == (int)icmtDialogHide)
		{
			WIN::ShowWindow(m_hProgress, SW_HIDE);
			// cannot destroy window, else custom actions don't work 0> WIN::DestroyWindow(m_hProgress), m_hProgress = 0;
			m_fWindowVisible = false;
		}
		return imsOk;
	}
	case imtFatalExit      >> imtShiftCount: // fatal exit, only from server to client
	case imtOutOfDiskSpace >> imtShiftCount:
	case imtError          >> imtShiftCount: // error message, field[1] is error
		if (!(iMsgBox & MB_ICONMASK))
		{
			// set icon if none was provided
			uiType = MB_ICONEXCLAMATION;
		}
		// fall through
	case imtWarning        >> imtShiftCount: // warning message, field[1] is error, not fatal
		if ( 0 == uiType && !(iMsgBox & MB_ICONMASK))
		{
			// set icon if none was provided
			uiType = MB_ICONINFORMATION;
		}
		// fall through
	case imtUser           >> imtShiftCount: // request message
	{
		if (m_fNoModalDialogs && !iForceQuietMessage)
			return imsNone;

		const IMsiString& riString = riRecord.FormatText(fFalse);
		unsigned int uiBreakStartTime = GetTickCount();
		imsEnum ims = (imsEnum)MsiMessageBox(0, riString.GetString(), 0, uiType | iMsgBox | MB_TASKMODAL, GetPackageCodepage(), GetPackageLanguage());
		m_uiStartTime += GetTickCount() - uiBreakStartTime;
		riString.Release();
		return ims;
	}
	case imtFilesInUse >> imtShiftCount:
	{
		if (m_fNoModalDialogs)
			return imsNone;

		imsEnum ims = FilesInUseDialog(&riRecord);
		switch (ims)
		{
			case imsRetry:  return imsRetry;
			case imsIgnore: return imsIgnore;
			default: return imsCancel;  // imsNone if dialog failed in creation
		}
	}

	case imtActionStart >> imtShiftCount: // start of action, field[1] is action name
	{
		return SetProgressData(imtActionStart >> imtShiftCount, g_szBannerText, true);
		/*imsEnum imsReturn;
		imsReturn = SetProgressData(imtActionStart >> imtShiftCount, riRecord.GetString(2));
		if (imsReturn != imsOk)
			return imsReturn;
		imsReturn = SetProgressData(imtActionData  >> imtShiftCount, 0);
		if (imsReturn != imsOk)
			return imsReturn;
		return SetProgressData(imtProgress    >> imtShiftCount, 0);*/
	}
	case imtActionData  >> imtShiftCount: // data associated with individual action item
	{
		if (riRecord.IsNull(0))
			return imsNone;
		return SetProgressData(0, 0, true);
	}
	case imtProgress    >> imtShiftCount: // progress gauge info, field[1] is units of 1/1024
	{
		using namespace ProgressData;
		switch (riRecord.GetInteger(imdSubclass))
		{
		case iscProgressAddition:
			return imsOk;
		case iMsiNullInteger:  // no progess, used to keep UI alive when running in other thread/process
			return SetProgressData(0, 0, true);
		case iscMasterReset: // Master reset
		{
			m_iProgressTotal = riRecord.GetInteger(imdProgressTotal);
			m_ipdDirection = (ipdEnum) riRecord.GetInteger(imdDirection);
			m_iProgress = m_ipdDirection == ipdForward ? 0 : m_iProgressTotal;
			m_fProgressByData = false;
			m_uiStartTime = 0;
			m_uiLastReportTime = 0;

			// If previous event type was ScriptInProgress, finish off the
			// progress bar; otherwise, reset it.
			imsEnum imsReturn;
			if (m_ietEventType == ietScriptInProgress)
				imsReturn = SetProgressGauge(imtProgress >> imtShiftCount, m_iProgressTotal, m_iProgressTotal);
			else
				imsReturn = SetProgressGauge(imtProgress >> imtShiftCount, m_iProgress, m_iProgressTotal);

			// If the new event type is ScriptInProgress, throw up the
			// ScriptInProgress information string
			m_ietEventType = (ietEnum) riRecord.GetInteger(imdEventType);
			if (m_ietEventType == ietScriptInProgress)
				imsReturn = SetScriptInProgress(fTrue);

			return imsReturn;
		}
		case iscActionInfo: // Action init
			m_iPerTick = riRecord.GetInteger(imdPerTick);
			m_fProgressByData = riRecord.GetInteger(imdType) != 0;
			return imsOk;
		case iscProgressReport: // Reporting actual progress
			{
				if (m_iProgressTotal == 0)
					return imsOk;

				if (m_uiStartTime == 0)
				{
					m_uiStartTime = GetTickCount();
					m_uiLastReportTime = m_uiStartTime;
					imsEnum imsReturn = imsOk;
					if (m_ietEventType != ietScriptInProgress)
						imsReturn = SetScriptInProgress(fFalse);
					return imsReturn;
				}
				int iSign = m_ipdDirection == ipdForward ? 1 : -1;
				if (m_fProgressByData)
					m_iProgress += (m_iPerTick * iSign);
				else
					m_iProgress += riRecord.GetInteger(imdIncrement) * iSign;

				imsEnum imsReturn = SetProgressGauge(imtProgress >> imtShiftCount, m_iProgress, m_iProgressTotal);
				if (imsReturn != imsOk)
					return imsReturn;

				if (m_ietEventType == ietTimeRemaining)
				{
					// Report time remaining (in seconds)
					int iBytesSoFar = m_ipdDirection == ipdForward ? m_iProgress : m_iProgressTotal - m_iProgress;
					int iBytesRemaining = m_iProgressTotal - iBytesSoFar;
					if (iBytesRemaining < 0) iBytesRemaining = 0;
					int iBytesPerSec = MulDiv(iBytesSoFar, 1000, GetTickCount() - m_uiStartTime);
					if (iBytesPerSec == 0) iBytesPerSec = 1;
					int iSecsRemaining = iBytesRemaining / iBytesPerSec;

					int iReportInterval = iSecsRemaining > 60 ? 15000 : 1000;
					if (iBytesSoFar > 0 && (GetTickCount() - m_uiLastReportTime > iReportInterval))
					{
						m_uiLastReportTime = GetTickCount();
						AssertNonZero(riRecord.SetInteger(1, iSecsRemaining));
						imsReturn = SetProgressTimeRemaining(riRecord);
					}
				}
				return imsReturn;
			}

		default:
			Assert(0);
			return imsNone;
		}
	}
	case imtResolveSource >> imtShiftCount:
	{
		if (m_fNoModalDialogs)
			return imsNone;

		return PromptUserForSource(riRecord);
	}

	default:
		return imsNone;
	};

}


imsEnum CBasicUI::SetScriptInProgress(Bool fSet)
{
	imsEnum imsReturn = SetProgressData(IDC_BASIC_PROGRESSTIME, fSet ? g_szScriptInProgress : TEXT(""), true);
	HWND hTimeRemaining = WIN::GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSTIME);
	WIN::SendMessage(hTimeRemaining, WM_SETREDRAW, fTrue, 0L);
	AssertNonZero(WIN::InvalidateRect(hTimeRemaining, 0, fTrue));
	return imsReturn;
}


imsEnum CBasicUI::SetProgressTimeRemaining(IMsiRecord& riRecord)
{
	// Used to call CheckDialog here. Since SetProgressTimeRemaining is always
	// called after SetProgressGauge and it checks the dialog, we don't need to here.
	int iSecsRemaining = riRecord.GetInteger(1);
	Assert(iSecsRemaining != iMsiStringBadInteger);
	iSecsRemaining < 60 ? AssertNonZero(riRecord.SetNull(1)) : AssertNonZero(riRecord.SetInteger(1, iSecsRemaining / 60));
	iSecsRemaining >= 60 ? AssertNonZero(riRecord.SetNull(2)) : AssertNonZero(riRecord.SetInteger(2, iSecsRemaining % 60));
	AssertNonZero(riRecord.SetMsiString(0, *MsiString(*g_szTimeRemaining)));  // string reference for efficiency here
	MsiString strFormatted;
	if(!riRecord.IsNull(0))
	{
		strFormatted = riRecord.FormatText(fFalse);
		riRecord.SetNull(0);  // insure that string reference is not passed back to caller
	}
	imsEnum imsStatus = SetProgressData(IDC_BASIC_PROGRESSTIME, strFormatted, true);
	if (imsStatus != imsOk)
		return imsStatus; // could return imsError or imsCancel
	HWND hTimeRemaining = WIN::GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSTIME);
	WIN::SendMessage(hTimeRemaining, WM_SETREDRAW, fTrue, 0L);
	AssertNonZero(WIN::InvalidateRect(hTimeRemaining, 0, fTrue));
	return imsOk;
}

Bool CALLBACK ProgressProc(HWND hDlg, unsigned int msg, WPARAM wParam, LPARAM /*lParam*/)
{
	if (msg == WM_INITDIALOG)
	{
		//lParam;
		return fTrue;
	}
	else if (msg == WM_COMMAND && wParam == IDCANCEL)
	{
		HWND hButton = WIN::GetDlgItem(hDlg, IDC_BASIC_CANCEL);
		if ( hButton && WIN::IsWindowVisible(hButton) &&
			  WIN::IsWindowEnabled(hButton) )
			g_BasicUI.SetUserCancel(true);
		return fTrue;
	}
	else if (msg == WM_SETCURSOR)
	{
		// Always display WAIT cursor if mouse not over Cancel button
		if ((HWND) wParam != WIN::GetDlgItem(hDlg, IDC_BASIC_CANCEL))
		{
			SetCursor(LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));
			return fTrue;
		}
	}
	else if (msg == WM_CLOSE)
	{
	}

	return fFalse;
}

extern void MoveButton(HWND hDlg, HWND hBtn, LONG x, LONG y);  // in msiutil.cpp, used by MsiMessageBox

bool CBasicUI::Mirrored(UINT uiCodepage)
{
	// mirrored if BiDi and on Windows 2000 or greater
	if ((uiCodepage == 1256 || uiCodepage == 1255) && MinimumPlatformWindows2000())
		return true;
	return false;
}

bool CBasicUI::SetCancelButtonText()
{
	if (m_hProgress == 0)
		return true;   // not initialized yet, can this happen?
	ICHAR rgchBuf[40];
	UINT iCodepage = MsiLoadString(g_hInstance, IDS_CANCEL, rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR), GetPackageLanguage());
	if (iCodepage == 0)
		return false;
	if (iCodepage != m_iButtonCodepage)  // codepage changed, need to create new font
	{
		MsiDestroyFont(m_hButtonFont);
		m_hButtonFont = MsiCreateFont(iCodepage);
		m_iButtonCodepage = iCodepage;

		bool fBiDi = (iCodepage == 1256 || iCodepage == 1255);
		bool fMirrored = Mirrored(iCodepage);

		// if our mirrored state is changing, then we need to re-create the dialog (note, this is only applicable on Windows 2000 and greater)
		if (fMirrored != m_fMirrored)
		{
			HWND hwndOld = m_hProgress;
			WIN::DestroyWindow(hwndOld);
			if (!CreateProgressDialog(fMirrored ? IDD_PROGRESSMIRRORED : IDD_PROGRESS))
				return false;
			if (m_fWindowVisible)
			{
				m_fWindowVisible = false; // turn off temporarily
				if (!CheckDialog())
					return false;
			}

			// RTL reading order is handled automatically by mirroring, so we shouldn't have to change it
			m_fMirrored = fMirrored;
		}
		else if (!fMirrored && fBiDi != m_fBiDi)  // right-to-left change
		{
			HWND  hwndButton = GetDlgItem(m_hProgress, IDC_BASIC_CANCEL);
			HWND  hwndGauge  = GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSBAR);
			RECT  rcButton;
			RECT  rcGauge;
			WIN::GetWindowRect(hwndButton, &rcButton);
			WIN::GetWindowRect(hwndGauge,  &rcGauge);
			MoveButton(m_hProgress, hwndButton, fBiDi ? rcGauge.left : rcButton.left + rcGauge.right - rcButton.right, rcButton.top);
			MoveButton(m_hProgress, hwndGauge,  fBiDi ? rcGauge.left + rcButton.right - rcGauge.right : rcButton.left, rcGauge.top);
			LONG iExStyle = WIN::GetWindowLong(hwndButton, GWL_EXSTYLE);
			WIN::SetWindowLong(hwndButton, GWL_EXSTYLE, iExStyle ^ WS_EX_RTLREADING);
			m_fBiDi = fBiDi;
		}
	}
	if (m_hButtonFont)
		WIN::SendDlgItemMessage(m_hProgress, IDC_BASIC_CANCEL, WM_SETFONT, (WPARAM)m_hButtonFont, MAKELPARAM(TRUE, 0));
	AssertNonZero(WIN::SetDlgItemText(m_hProgress, IDC_BASIC_CANCEL, rgchBuf));

	// update banner text w/ new text for new language
	ICHAR rgchBannerText[cchMaxCaption + 1];
	AssertNonZero(MsiLoadString(g_hInstance, m_uiBannerText, rgchBannerText, sizeof(rgchBannerText)/sizeof(ICHAR), GetPackageLanguage()));
	if(!m_fQuiet && !m_fHideDialog)
		SetProgressData(imtActionStart >> imtShiftCount, rgchBannerText, m_fWindowVisible);

	return true;
}

bool GetScreenCenterCoord(HWND hDlg, int& iDialogLeft, int& iDialogTop,
								  int& iDialogWidth, int& iDialogHeight)
{
	RECT rcDialog;
	if ( !WIN::GetWindowRect(hDlg, &rcDialog) )
		return false;

	RECT rcScreen;
	if ( !WIN::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0) )
	{
		rcScreen.left = 0;
		rcScreen.top = 0;
		rcScreen.right = WIN::GetSystemMetrics(SM_CXSCREEN);
		rcScreen.bottom = WIN::GetSystemMetrics(SM_CYSCREEN);
	}
	iDialogWidth = rcDialog.right - rcDialog.left;
	iDialogHeight = rcDialog.bottom - rcDialog.top;
	iDialogLeft = rcScreen.left + (rcScreen.right - rcScreen.left - iDialogWidth)/2;
	iDialogTop = rcScreen.top + (rcScreen.bottom - rcScreen.top - iDialogHeight)/2;

	return true;
}

bool CBasicUI::CreateProgressDialog(int idDlg)
{
	int iDialogLeft, iDialogTop;
	int iDialogWidth, iDialogHeight;

	if (IDD_PROGRESSMIRRORED == idDlg)
		m_fMirrored = true;

	m_hProgress = WIN::CreateDialogParam(g_hInstance, MAKEINTRESOURCE(idDlg), m_hwndParent, (DLGPROC)ProgressProc, (LPARAM)this);
	if (!m_hProgress)
		return false;

	AssertNonZero(::GetScreenCenterCoord(m_hProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight));
	AssertNonZero(WIN::MoveWindow(m_hProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight, fTrue));
	WIN::SetFocus(WIN::GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSBAR));
	WIN::ShowWindow(WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL), m_fCancelVisible ? SW_SHOW : SW_HIDE);
	WIN::SetForegroundWindow(m_hProgress);

	HICON hIcon = (HICON) WIN::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_INSTALLER));
	if (hIcon)
		WIN::SendMessage(m_hProgress, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

	return true;
}

bool CBasicUI::CheckDialog()
{
	int iDialogLeft, iDialogTop;
	int iDialogWidth, iDialogHeight;

	if (!m_hProgress)
	{
		int idDlg = IDD_PROGRESS;

		// need to determine if we should create the mirrored progress dialog -- only applicable with BiDi languages on
		// Windows2000 or greater systems
		UINT uiCodepage = GetPackageCodepage();
		if (0 == uiCodepage)
		{
			// neutral, so use user's
			uiCodepage = MsiGetCodepage((WORD)MsiGetDefaultUILangID());
		}

		if (Mirrored(uiCodepage))
		{
			// create mirrored progress dialog (only on Win2K and greater)
			idDlg = IDD_PROGRESSMIRRORED;
		}

		if (!CreateProgressDialog(idDlg))
			return false;

		AssertNonZero(SetCancelButtonText());
	}

	if (!m_fWindowVisible && !m_fQuiet && !m_fHideDialog &&
				::GetScreenCenterCoord(m_hProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight))
	{
		AssertNonZero(WIN::SetWindowPos(m_hProgress, HWND_TOP,
												  iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight,
												  SWP_SHOWWINDOW));
		m_fWindowVisible = true;
	}

	if (m_fCaptionChanged && *m_szCaption)
	{
		m_fCaptionChanged = false;
		WIN::SetWindowText(m_hProgress, m_szCaption);
	}

	WIN::ShowWindow(WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL), m_fCancelVisible ? SW_SHOW : SW_HIDE);
	return true;
}

imsEnum CBasicUI::SetProgressData(int iControl, const ICHAR* szData, bool fCheckDialog)
{
	if (iControl && (WIN::GetDlgItem(m_hProgress, iControl) || !m_hProgress))
	{
		Assert(szData);
		if (fCheckDialog && !CheckDialog())
			return imsError;

		ICHAR rgchCurrText[cchMaxCaption + 1];
		WIN::GetDlgItemText(m_hProgress, iControl,rgchCurrText,cchMaxCaption);
		if (IStrComp(szData, rgchCurrText) != 0)
		{
			int iTextCodepage = m_iPackageCodepage ? m_iPackageCodepage : ::MsiGetCodepage(m_iPackageLanguage);
			if (iTextCodepage != m_iTextCodepage)  // codepage changed, need to create new font
			{
				MsiDestroyFont(m_hTextFont);
				m_hTextFont = MsiCreateFont(iTextCodepage);
				m_iTextCodepage = iTextCodepage;
			}
			HWND hwndText = GetDlgItem(m_hProgress, iControl);
			bool fBiDi = (m_iTextCodepage == 1256 || m_iTextCodepage == 1255);
			LONG iStyle   = WIN::GetWindowLong(hwndText, GWL_STYLE);
			LONG iExStyle = WIN::GetWindowLong(hwndText, GWL_EXSTYLE);
			if (fBiDi)
			{
				// on mirrored dialog, left justification is correct because everything has already been adjusted to display properly
				if (!m_fMirrored)
				{
					iStyle |= SS_RIGHT;
					iExStyle |= (WS_EX_RIGHT | WS_EX_RTLREADING);
				}
				// mirroring is a dialog change, so we don't have to worry about text switching
			}
			else
			{
				if (!m_fMirrored)
				{
					iStyle &= ~SS_RIGHT;
					iExStyle &= ~(WS_EX_RIGHT | WS_EX_RTLREADING);
				}
				// mirroring is a dialog change, so we don't have to worry about text switching
			}
			WIN::SetWindowLong(hwndText, GWL_STYLE, iStyle);
			WIN::SetWindowLong(hwndText, GWL_EXSTYLE, iExStyle);
			if (m_hTextFont)
				SendDlgItemMessage(m_hProgress, iControl, WM_SETFONT, (WPARAM)m_hTextFont, MAKELPARAM(TRUE, 0));
			AssertNonZero(WIN::SetDlgItemText(m_hProgress, iControl, szData));
		}
	}
	MSG msg;
	while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		if (!WIN::IsDialogMessage(m_hProgress, &msg))
		{
			WIN::TranslateMessage(&msg);
			WIN::DispatchMessage(&msg);
		}
	}
	if (m_fUserCancel)
	{
		return imsCancel;
	}
	return imsOk;
}

imsEnum CBasicUI::SetProgressGauge(int iControl, int cSoFar, int cTotal)
{
	if (!CheckDialog())
		return imsError;
	HWND hWnd = WIN::GetDlgItem(m_hProgress, iControl);
	WIN::ShowWindow(hWnd, SW_SHOW);
	int cDiff = cSoFar - m_cSoFarPrev;
	if (cDiff < 0)
		cDiff = -cDiff;

	// Only change the progress gauge if we've actually made some visible progress
	if (m_cTotalPrev != cTotal || cDiff > cTotal/0x100)
	{
		m_cTotalPrev = cTotal;
		m_cSoFarPrev = cSoFar;
		while (cTotal > 0xFFFF)  // the control can take at most a 16 bit integer, so we have to scale the values
		{
			// We can afford to scale down by a bunch because we assume that the granularity
			// of the control is smaller that 0xFFF. We could probably be more aggressive here
			cTotal >>= 8;
			cSoFar >>= 8;
		}

		WIN::SendMessage(hWnd, PBM_SETRANGE, 0, MAKELPARAM(0, cTotal));
		WIN::SendMessage(hWnd, PBM_SETPOS, cSoFar, 0);
	}
	MSG msg;
	while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		if (!WIN::IsDialogMessage(m_hProgress, &msg))
		{
			WIN::TranslateMessage(&msg);
			WIN::DispatchMessage(&msg);
		}
	}
	if (m_fUserCancel)
	{
		return imsCancel;
	}
	return imsOk;
}

//____________________________________________________________________________
//
// CFilesInUseDialog implementation
//____________________________________________________________________________

imsEnum CBasicUI::FilesInUseDialog(IMsiRecord* piRecord)
{
	if (piRecord == 0)
		return imsNone;
	CFilesInUseDialog msgbox(piRecord->GetString(0), m_szCaption, *piRecord);

	// must use mirrored dialog on Win2K or above for Arabic and Hebrew languages
	UINT uiCodepage = g_BasicUI.GetPackageCodepage();
	if (Mirrored(uiCodepage))
		return (imsEnum)msgbox.Execute(0, IDD_FILESINUSEMIRRORED, 0);
	return (imsEnum)msgbox.Execute(0, IDD_FILESINUSE, 0);
}

CFilesInUseDialog::CFilesInUseDialog(const ICHAR* szMessage, const ICHAR* szCaption, IMsiRecord& riFileList)
 : CMsiMessageBox(szMessage, szCaption, 0, 1, IDCANCEL, IDRETRY, IDIGNORE, g_BasicUI.GetPackageCodepage(), g_BasicUI.GetPackageLanguage())
 , m_riFileList(riFileList), m_hfontList(0)
{
}

CFilesInUseDialog::~CFilesInUseDialog()
{
	MsiDestroyFont(m_hfontList);
}

bool CFilesInUseDialog::InitSpecial()
{
	// We need to display file names as they would appear to the user with system tools
	UINT iListCodepage = MsiGetSystemDataCodepage();  // need to display paths correctly
	HFONT hfontList = m_hfontText;   // optimize if same codepage as text from database
	if (iListCodepage != m_iCodepage) // database codepage different that text data
		hfontList = m_hfontList = MsiCreateFont(iListCodepage);
	SetControlText(IDC_FILESINUSELIST, hfontList, (const ICHAR*)0);

	HWND hWndListBox = WIN::GetDlgItem(m_hDlg, IDC_FILESINUSELIST);
	Assert(hWndListBox);
	HDC hDCListBox = WIN::GetDC(hWndListBox);
	Assert(hDCListBox);
	TEXTMETRIC tm;
	memset(&tm, 0, sizeof(tm));
	AssertNonZero(WIN::GetTextMetrics(hDCListBox, (LPTEXTMETRIC)&tm));
	HFONT hFontOld = (HFONT)WIN::SelectObject(hDCListBox, hfontList);
	Assert(hFontOld);
	WIN::SendMessage(hWndListBox, WM_SETREDRAW, false, 0L);
	WPARAM dwMaxExtent = 0;

	int iFieldIndex = 1;
	while (!m_riFileList.IsNull(iFieldIndex))
	{
		MsiString strProcessName(m_riFileList.GetMsiString(iFieldIndex++));  //!! not used?
		MsiString strProcessTitle(m_riFileList.GetMsiString(iFieldIndex++));

		// catch duplicate window titles - most likely these are the same window
		if(LB_ERR == WIN::SendDlgItemMessage(m_hDlg, IDC_FILESINUSELIST, LB_FINDSTRINGEXACT, 0, (LPARAM) (const ICHAR*) strProcessTitle))
		{
			WIN::SendDlgItemMessage(m_hDlg, IDC_FILESINUSELIST, LB_ADDSTRING, 0, (LPARAM) (const ICHAR*) strProcessTitle);
			SIZE size;
			size.cx = size.cy = 0;
			AssertNonZero(WIN::GetTextExtentPoint32(hDCListBox, (const ICHAR*)strProcessTitle,
																 strProcessTitle.TextSize(), &size));
			if ( size.cx + tm.tmAveCharWidth > dwMaxExtent )
				dwMaxExtent = size.cx + tm.tmAveCharWidth;
		}
	}
	WIN::SendMessage(hWndListBox, LB_SETHORIZONTALEXTENT, dwMaxExtent, 0L);
	WIN::SelectObject(hDCListBox, hFontOld);
	WIN::ReleaseDC(hWndListBox, hDCListBox);
	WIN::SendMessage(hWndListBox, WM_SETREDRAW, true, 0L);
	AssertNonZero(WIN::InvalidateRect(hWndListBox, 0, true));

	AdjustButtons();  // to allow switching of buttons for BiDi
	return true;
}

//____________________________________________________________________________


//
// Add and remove items from the action thread list
//
void InsertInCustomActionList(CActionThreadData* pData)
{
	EnterCriticalSection(&vcsHeap);

	pData->m_pNext = g_pActionThreadHead;
	g_pActionThreadHead = pData;

	LeaveCriticalSection(&vcsHeap);
}

void RemoveFromCustomActionList(CActionThreadData* pData)
{
	Debug(bool fFound = false);

	EnterCriticalSection(&vcsHeap);

	CActionThreadData** ppList = &g_pActionThreadHead;

	for ( ; *ppList; ppList = &(*ppList)->m_pNext)
	{
		if (*ppList == pData)
		{
			*ppList = pData->m_pNext;  // unlink from chain
			Debug(fFound = true);
			break;
		}
	}

	LeaveCriticalSection(&vcsHeap);

	Assert(fFound);
}

bool FIsCustomActionThread(DWORD dwThreadId)
{
	bool fFound = false;

	EnterCriticalSection(&vcsHeap);

	CActionThreadData* pList = g_pActionThreadHead;

	for ( ; pList; pList = pList->m_pNext)
	{
		if (pList->m_dwThreadId == dwThreadId)
		{
			fFound = true;
			break;
		}
	}

	LeaveCriticalSection(&vcsHeap);

	return fFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\callback.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       callback.cpp
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////
// callback.cpp -- contains all the FDI callbacks for the FDI server
//                 and some additional miscellaneous routines
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// #defines and #includes
////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "database.h"
#include "_databas.h"
#include <io.h>
#include <sys\stat.h>

#include "callback.h"
#include "fdisvr.h"
#include "path.h"
#include "notify.h"
#include "_assert.h"


// log assembly errors
IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName);

////////////////////////////////////////////////////////////////////////////
// Global/Shared data
////////////////////////////////////////////////////////////////////////////

extern FDIShared*           g_pFDIs;			// Defined in fdisvr.cpp
extern ERF					g_erf;				// Defined in fdisvr.cpp
extern FDIServerResponse	g_fdirCallbackError;	// Defined in fdisvr.cpp
extern HANDLE               g_hCurDestFile;     // Defined in fdisvr.cpp
extern IStream* g_pDestFile;

// For events
extern HANDLE g_hCallbackInterfaceEvent;
extern HANDLE g_hCallbackServerEvent;

////////////////////////////////////////////////////////////////////////////
// Private data
////////////////////////////////////////////////////////////////////////////
#define MAX_SEEK_COUNT		4	// Supported number of independent seek pointers
static icbtEnum	s_icbtCurrCabType = icbtNextEnum;	// Start with unknown type

static IMsiStream*	s_piStream[MAX_SEEK_COUNT + 1];
static int          s_iNextStream = 0;

static int OpenFileCabinet(const ICHAR* pszCabName, int oflag, int pmode);
static int OpenStreamCabinet(const ICHAR* pszCabName, int oflag, int pmode);
static UINT ReadStreamCabinet(INT_PTR hf, void* pv, UINT cb);
static int CloseStreamCabinet(INT_PTR hf);
static int SeekStreamCabinet(INT_PTR hf, long dist, int seektype);

Bool StartFdiImpersonating(bool fNonWrapperCall)
{
	bool fSuccess = true;
	if (fNonWrapperCall && g_pFDIs->fServerIsImpersonated)
		return ToBool(fSuccess);

	if (g_pFDIs->hImpersonationToken != INVALID_HANDLE_VALUE)
		fSuccess = StartImpersonating();
	Assert(fSuccess);

	return ToBool(fSuccess);
}

void StopFdiImpersonating(bool fNonWrapperCall)
{
	if (fNonWrapperCall && g_pFDIs->fServerIsImpersonated)
		return;

	if (g_pFDIs->hImpersonationToken != INVALID_HANDLE_VALUE)
		StopImpersonating();
}

/* W A I T  C O M M A N D */
/*----------------------------------------------------------------------------
%%Function: WaitCommand

Waits for, and then returns, a FDI server command from the FDI Interface.
The fdir parameter tells WaitCommand what value to return to FDI Interface
as the command result.
----------------------------------------------------------------------------*/
FDIServerCommand WaitCommand(FDIServerResponse fdir)
{
	// Initialize shared data with our response
	g_pFDIs->fdic = fdicNoCommand;
	g_pFDIs->fdir = fdir;

	if (g_hCallbackServerEvent == NULL)
	{
		g_hCallbackServerEvent = OpenEvent(EVENT_ALL_ACCESS, 0, TEXT("MsiFDIServer"));
		if (NULL == g_hCallbackServerEvent)
			return fdicNoCommand;
		else
			MsiRegisterSysHandle(g_hCallbackServerEvent);
	}
	if (g_hCallbackInterfaceEvent == NULL)
	{
		g_hCallbackInterfaceEvent = OpenEvent(EVENT_ALL_ACCESS, 0, TEXT("MsiFDIInterface"));
		if (NULL == g_hCallbackInterfaceEvent)
			return fdicNoCommand;
		else
			MsiRegisterSysHandle(g_hCallbackInterfaceEvent);
	}
	
	SetEvent(g_hCallbackServerEvent);	
	DWORD dw = WaitForSingleObject(g_hCallbackInterfaceEvent, INFINITE);


	// If we just received an extract file command we take special note,
	// so later on, during error checking, we know whether we were in the
	// middle of extracting a file
	if (g_pFDIs->fdic == fdicExtractFile) g_pFDIs->fPendingExtract = 1;

	// Clear any callback errors (we just received a command and haven't
	// done any processing yet, so there can't be any call back errors, can
	// there?)
	g_fdirCallbackError = fdirNoResponse;
	return g_pFDIs->fdic;
}

/* H A N D L E  E R R O R */
/*----------------------------------------------------------------------------
	%%Function: HandleError

	Based on the value of fdicCallbackError and the error returned from
	FDI in g_erf.erfOper, puts a suitable error response into g_pFDIs->fdir
----------------------------------------------------------------------------*/
// A little #define to make our switch statement a little more compact and easy
// to read
#define ErrorCase(x,y) \
case x: { \
	g_pFDIs->fdir = y; \
	break; \
}
void HandleError()
{
	if (g_fdirCallbackError == fdirNoResponse || 
		g_fdirCallbackError == fdirSuccessfulCompletion)
	{
		switch(g_erf.erfOper)
		{
			ErrorCase(FDIERROR_CABINET_NOT_FOUND,		fdirCabinetNotFound)
			ErrorCase(FDIERROR_NOT_A_CABINET,			fdirNotACabinet)
			ErrorCase(FDIERROR_UNKNOWN_CABINET_VERSION, fdirUnknownCabinetVersion)
			ErrorCase(FDIERROR_CORRUPT_CABINET,			fdirCorruptCabinet)
			ErrorCase(FDIERROR_ALLOC_FAIL,				fdirNotEnoughMemory)
			ErrorCase(FDIERROR_BAD_COMPR_TYPE,			fdirBadCompressionType)
			ErrorCase(FDIERROR_MDI_FAIL,				fdirMDIFail)
			ErrorCase(FDIERROR_TARGET_FILE,				fdirTargetFile)
			ErrorCase(FDIERROR_RESERVE_MISMATCH,		fdirReserveMismatch)
			ErrorCase(FDIERROR_WRONG_CABINET,			fdirWrongCabinet)
			ErrorCase(FDIERROR_USER_ABORT,				fdirUserAbort)
			ErrorCase(FDIERROR_NONE,					fdirSuccessfulCompletion)
			default:
			{
				NotifyUser("FDI Server: Unknown FDI error type!");
				g_pFDIs->fdir = fdirUnknownFDIError;
				break;
			}
		}
	}
	else g_pFDIs->fdir = g_fdirCallbackError;	// return more specific error
}
#undef ERRORCASE

////////////////////////////////////////////////////////////////////////////
// FDI Callbacks
////////////////////////////////////////////////////////////////////////////	
	
/* F N A L L O C */
/*----------------------------------------------------------------------------
	%%Function: FNALLOC

	FDI memory allocation callback. Must emulate "malloc". 
----------------------------------------------------------------------------*/
FNALLOC(pfnalloc)
{
	char *pc = new char[cb];
	if (!pc)
	{
		NotifyUser("FDI Server:Failure in pfnalloc");
	}
	return pc;
}

/* F N F R E E  */
/*----------------------------------------------------------------------------
	%%Function: FNFREE

	FDI memory freeing callback. Must emulate "free".
----------------------------------------------------------------------------*/
FNFREE(pfnfree)
{
	delete [] pv;
}

/* P F N  O P E N */
/*----------------------------------------------------------------------------
	%%Function: pfnopen

	FDI file open callback. Must emulate "_open".
----------------------------------------------------------------------------*/
// May Need to modify this to support the full semantics of _open
INT_PTR FAR DIAMONDAPI pfnopen(char FAR *pszFile, int oflag, int pmode)
{
// Okay, this function is a hack.  Instead of emulating _open with all of its
// myriad flag combinations, we handle only one case (the case that FDI calls us
// for).  If, at some future time, FDI should pass us different file creation/access
// flags, we will need to change this code to handle that.
// ****NOTE********************************************************************
// * There is one case where FDI calls us with different flags, and that is   *
// * when there is not enough memory for the decompressor.  In this case, FDI *
// * will attempt to create a spillfile "*" that is temporarily used for      *
// * decompression. If this ever happens, performance will be dog slow, so I'm*
// * not currently supporting it in this function.                            *
// ****************************************************************************

	if ((oflag != (/*_O_BINARY*/ 0x8000 | /*_O_RDONLY*/ 0x0000)) || (pmode != (_S_IREAD | _S_IWRITE)))
	{
		// Crash and burn horribly
		NotifyUser("FDI Server: Unexpected access flags in pfnopen()");
		return 0;
	}

	int iReturn = -1;
	CConvertString rgchConvertFile(pszFile);
	if (g_pFDIs->icbtCabinetType == icbtFileCabinet)
		iReturn = OpenFileCabinet(rgchConvertFile, oflag, pmode);

	else if (g_pFDIs->icbtCabinetType == icbtStreamCabinet)
		iReturn = OpenStreamCabinet(rgchConvertFile, oflag, pmode);

	if (iReturn == -1)
		g_fdirCallbackError = fdirCabinetNotFound;

	return iReturn;
}


int OpenFileCabinet(const ICHAR* pszCabFileName, int /*oflag*/, int /*pmode*/)
/*----------------------------------------------------------------------------
Called from pfnopen - Opens a standard file-based cabinet.

Returns:
-1 if the cabinet file cannot be found and opened, otherwise, a handle to the
opened file.
----------------------------------------------------------------------------*/
{
	if ( ! pszCabFileName )
		return -1;
	s_icbtCurrCabType = icbtFileCabinet;
	Bool fImpersonate = g_pFDIs->iCabDriveType == DRIVE_REMOTE ? fTrue : fFalse;
	if (fImpersonate)
		AssertNonZero(StartFdiImpersonating());
	HANDLE hf;
	hf = CreateFile(pszCabFileName,		// file name
				   GENERIC_READ,    // we want to read
				   FILE_SHARE_READ, // we'll let people share this
				   NULL,			     // ignore security
				   OPEN_EXISTING,	  // must already exist
				   0L,				  // don't care about attributes
				   NULL);			  // no template file

	if (fImpersonate)
		StopFdiImpersonating();

	if (hf != INVALID_HANDLE_VALUE)
		MsiRegisterSysHandle(hf);

	Assert((INT_PTR)hf <= INT_MAX);		//--merced: need to ensure that hf is in the 32-bit range, else we can't pass it out as an int.
	return (int)HandleToLong(hf);		//--merced: okay to typecast since hf will be in the 32-bit range.
}


int OpenStreamCabinet(const ICHAR* pszCabFileName, int /*oflag*/, int /*pmode*/)
/*----------------------------------------------------------------------------
Called from pfnopen - Opens a cabinet stored in a stream within an IMsiStorage
container.

Returns:
-1 if the cabinet stream cannot be found and opened, otherwise, a pointer to
the IMsiStream object.
----------------------------------------------------------------------------*/
{
	s_icbtCurrCabType = icbtStreamCabinet;
	Assert(g_pFDIs->piStorage);
	IMsiStorage* piStorage = g_pFDIs->piStorage;
	IMsiStream* piStream;
	if (s_iNextStream == 0)
	{
		PMsiRecord pErrRec = piStorage->OpenStream(pszCabFileName, fFalse,piStream);
		if (pErrRec)
			return -1;
	}
	else
	{
		piStream = s_piStream[s_iNextStream]->Clone();
		if (!piStream)
			return -1;
	}
	s_iNextStream++;
	s_piStream[s_iNextStream] = piStream;
#ifdef USE_OBJECT_POOL
	return PutObjectData(piStream);
#else
	Assert((INT_PTR)piStream <= INT_MAX);		//!!merced: need to ensure that piStream is in the 32-bit range, else we can't pass it out as an int.
	return (int)HandleToLong(piStream);			//!!merced: this may not be okay since we just create it!
#endif
}


/* P F N  R E A D */
/*----------------------------------------------------------------------------
	%%Function: pfnread

	FDI file read callback. Must emulate "_read".
----------------------------------------------------------------------------*/
UINT FAR DIAMONDAPI pfnread(INT_PTR hf, void FAR *pv, UINT cb)
{
	if (s_icbtCurrCabType == icbtStreamCabinet)
	{
		for (;;)
		{
			int cbActual = ReadStreamCabinet(hf, pv, cb);
			if (cbActual == 0)
			{
				FDIServerCommand fdic = WaitCommand(fdirStreamReadError);
				if (fdic == fdicCancel)
				{
					g_fdirCallbackError = fdirUserAbort;
					return 0;
				}
				else
					continue;
			}
			return cbActual;
		}
	}
	else
	{
		AssertFDI(s_icbtCurrCabType == icbtFileCabinet);
		DWORD cbRead;

		for (;;)
		{
			UINT iCurrMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS);
			Bool fReadSuccess = ToBool(ReadFile((HANDLE)hf, pv, cb, &cbRead, NULL));
			DWORD dwLastError = WIN::GetLastError();
			WIN::SetErrorMode(iCurrMode);

			if (!fReadSuccess)
			{
				 if (dwLastError == ERROR_NOT_READY || dwLastError == ERROR_GEN_FAILURE)
					 g_fdirCallbackError = fdirDriveNotReady;
				 else if (NET_ERROR(dwLastError))
				 {
					 g_fdirCallbackError = fdirNetError;
					 return 0;
				 }		
				 else
					 g_fdirCallbackError = fdirCabinetReadError;

				FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
				if ((fdic == fdicCancel) || (fdic == fdicOpenCabinet))
				{
					// Opening another cabinet in the middle of a read
					// is basically the same as cancelling.  There might have
					// been some sort of error, so let the caller know they
					// need to start over.
					g_fdirCallbackError = fdirUserAbort;
					return 0;
				}
				else
					continue;
			}
			break;
		}

		return cbRead;
	}
}


UINT ReadStreamCabinet(INT_PTR hf, void* pv, UINT cb)
/*----------------------------------------------------------------------------
Called from pfnread - Reads data from a cabinet that has been stored as a
stream within our host database.

Returns: the actual count of bytes copied to the caller's buffer.
----------------------------------------------------------------------------*/
{
#ifdef USE_OBJECT_POOL
	IMsiStream* piStream = (IMsiStream*)GetObjectData((int)hf);
#else
	IMsiStream* piStream = (IMsiStream*) hf;
#endif
	int iRemaining = piStream->Remaining();
	cb = (iRemaining < (int)cb) ? iRemaining : cb;
	return piStream->GetData(pv,cb);
}


/* P F N  W R I T E */
/*----------------------------------------------------------------------------
	%%Function: pfnwrite

	FDI file write callback. Must emulate "_write".  Writes data to our new
	decompressed target file.

	This function writes data in g_pFDIs->cbNotification size blocks,
	returning an fdirNotification message after each such block.
----------------------------------------------------------------------------*/

UINT FAR DIAMONDAPI pfnwrite(INT_PTR hf, void FAR *pv, UINT cb)
{
	unsigned long cbWritten;
	UINT          cbToNextNotification;
	BOOL          fEnd;
	UINT          cbLeft = cb;
	FDIServerCommand fdic;
	while (cbLeft)
	{
		// Get count of bytes to next notification - if cbNotification is 0,
		// we want to send no notifications.
		if (g_pFDIs->cbNotification == 0)
			cbToNextNotification = cbLeft + 1;
		else
			cbToNextNotification = g_pFDIs->cbNotification - g_pFDIs->cbNotifyPending;
		// If this count is less than the number we have left, 
		// then use that number instead
		UINT cbBytesToWrite;
		fEnd = cbLeft < cbToNextNotification;
		if (fEnd)
			cbBytesToWrite = cbLeft;
		else
			cbBytesToWrite = cbToNextNotification;
		// Write a piece out

		for (;;)
		{
			if(g_pFDIs->piASM)
			{
				IStream* piStream = (IStream*) hf;
				HRESULT hr = piStream->Write(pv, cbBytesToWrite, &cbWritten);
				if(!SUCCEEDED(hr))
				{
					g_fdirCallbackError = fdirErrorWritingFile;
					FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
					if (fdic == fdicCancel)
					{
						g_fdirCallbackError = fdirUserAbort;
						return 0;
					}
					else
						continue;
				}
			}
			else
			{
				BOOL fWriteOK = WriteFile((HANDLE)hf, pv, cbBytesToWrite, &cbWritten, NULL);
				if (!fWriteOK)
				{
					DWORD dwLastError = GetLastError();
					if (dwLastError == ERROR_DISK_FULL)
						g_fdirCallbackError = fdirDiskFull;
					else if (NET_ERROR(dwLastError))
					{
						 g_fdirCallbackError = fdirNetError;
						 return 0;
					}		
					else
						g_fdirCallbackError = fdirErrorWritingFile;

					FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
					if (fdic == fdicCancel)
					{
						g_fdirCallbackError = fdirUserAbort;
						return 0;
					}
					else
						continue;
				}
			}
			break;
		}

		// Update counts, pointers
		pv = (char *)pv + cbWritten;
		cbLeft -= cbWritten;
		g_pFDIs->cbNotifyPending += cbWritten;

		if (!fEnd)
		{
			g_pFDIs->cbNotifyPending -= g_pFDIs->cbNotification;
			fdic = WaitCommand(fdirNotification);
			if (fdic == fdicClose)
			{
				g_fdirCallbackError = fdirClose;
				return 0;
			}
			else if (fdic != fdicContinue)
			{
				NotifyUser("FDI Server: Not allowed to continue after notification in pfnwrite");
				return 0;
			}
		}
	}
	return cb; 
}

/* P F N  C L O S E */
/*----------------------------------------------------------------------------
	%%Function: pfnclose

	FDI file close callback. Must emulate "_close".
----------------------------------------------------------------------------*/
int FAR DIAMONDAPI pfnclose(INT_PTR hf)
{
	if(g_pFDIs->piASM)
	{
		IStream* piStream = (IStream*) hf;
		if(g_pDestFile == piStream)
		{
			piStream->Release();
			return 0;
		}
	}
	else
	{
		// pfnclose can also be called to close the destination file if an
		// error occurred when writing to it, so check for that now.
		Assert((INT_PTR)g_hCurDestFile <= INT_MAX);				//--merced: g_hCurDestFile better fit into an int, else we can't typecast below.
		if (hf == (int) HandleToLong(g_hCurDestFile))			//--merced: okay to typecast
		{
			int f = MsiCloseSysHandle((HANDLE) hf);
			f &= ToBool(WIN::DeleteFile(g_pFDIs->achFileDestinationPath));
			return f;
		}
	}

	if (s_icbtCurrCabType == icbtStreamCabinet)
		return CloseStreamCabinet(hf);

	AssertFDI(s_icbtCurrCabType == icbtFileCabinet || s_icbtCurrCabType == icbtNextEnum);
	s_icbtCurrCabType = icbtNextEnum;

	// Returns 0 if unsuccessful
	return !MsiCloseSysHandle((HANDLE)hf);
}


int CloseStreamCabinet(INT_PTR hf)
/*----------------------------------------------------------------------------
Called from pfnclose - releases the cabinet stream.

Returns: 0 if the stream was released successfully.
----------------------------------------------------------------------------*/
{
#ifdef USE_OBJECT_POOL
	IMsiStream* piStream = (IMsiStream*)GetObjectData((int)hf);
#else
	IMsiStream* piStream = (IMsiStream*) hf;
#endif
	piStream->Release();
	if (--s_iNextStream == 0)
		s_icbtCurrCabType = icbtNextEnum;
	return 0;
}


/* P F N  S E E K */
/*----------------------------------------------------------------------------
	%%Function: pfnseek

	FDI file seek callback. Must emulate "_lseek".
----------------------------------------------------------------------------*/
long FAR DIAMONDAPI pfnseek(INT_PTR hf, long dist, int seektype)
{
	if (s_icbtCurrCabType == icbtStreamCabinet)
		return SeekStreamCabinet(hf, dist, seektype);

	AssertFDI(s_icbtCurrCabType == icbtFileCabinet);
	DWORD dwMoveMethod;

	switch (seektype)
	{
		case 0 /* SEEK_SET */ :
		{
			dwMoveMethod = FILE_BEGIN;
			break;
		}
		case 1 /* SEEK_CUR */ :
		{
			dwMoveMethod = FILE_CURRENT;
			break;
		}
		case 2 /* SEEK_END */ :
		{
			dwMoveMethod = FILE_END;
			break;
		}
		default :
		{
			AssertFDI(0);
			return -1;
		}
	}
	// SetFilePointer returns -1 if it fails (this will cause FDI to quit with an
	// FDIERROR_USER_ABORT error. (Unless this happens while working on a cabinet,
	// in which case FDI returns FDIERROR_CORRUPT_CABINET)
	int fpos = SetFilePointer((HANDLE) hf, dist, NULL, dwMoveMethod);
	return fpos;
}


int SeekStreamCabinet(INT_PTR hf, long dist, int seektype)
/*----------------------------------------------------------------------------
Called from pfnseek - seeks to a specific spot within the stream.
Returns:
-1 if the seek fails, otherwise the current seek position. IMsiStream
----------------------------------------------------------------------------*/
{
#ifdef USE_OBJECT_POOL
	IMsiStream* piStream = (IMsiStream*)GetObjectData((int)hf);
#else
	IMsiStream* piStream = (IMsiStream*) hf;
#endif
	int iByteCount = piStream->GetIntegerValue();
	int iRemaining = piStream->Remaining();
	int iSeek;
	switch (seektype)
	{
		case 0 /* SEEK_SET */ :
			iSeek = dist;
			break;
		case 1 /* SEEK_CUR */ :
			iSeek = iByteCount - iRemaining + dist;
			break;
		case 2 /* SEEK_END */ :
			iSeek = iByteCount - dist;
			break;
		default :
			NotifyUser("FDI Server:unknown seektype in pfnseek");
			return -1;
			break;
	}
	if (iSeek < 0 || iSeek > iByteCount)
		return -1;
	else
	{
		piStream->Seek(iSeek);
		return iSeek;
	}
}



/* C A B I N E T  I N F O */
/*----------------------------------------------------------------------------
	%%Function: CabinetInfo

	Called when we receive a fdintCABINET_INFO notification.
----------------------------------------------------------------------------*/
int CabinetInfo(PFDINOTIFICATION /*pfdin*/)
{
	// We actually get access to some cabinet info through p->,
	// but don't need to do anything with it.
	return 0;  // Do nothing
}

/* C R E A T E  D E S T I N A T I O N  F I L E */
/*----------------------------------------------------------------------------
	%%Function: CreateDestinationFile

	Creates and opens the file specified by g_pFDIs->achFileDestinationPath and 
	g_pFDIs->achFileSourceName. Returns a handle to the file. 
----------------------------------------------------------------------------*/
INT_PTR CreateDestinationFile()
{
	if(g_pFDIs->piASM)
	{
		IStream* piDestFile;
		for(;;)
		{			
#ifdef UNICODE
			HRESULT hr = (g_pFDIs->piASM)->CreateStream(0, g_pFDIs->achFileDestinationPath, g_pFDIs->fManifest ? STREAM_FORMAT_COMPLIB_MANIFEST : 0, 0, &piDestFile, NULL);
#else
			void ConvertMultiSzToWideChar(const IMsiString& ristrFileNames, CTempBufferRef<WCHAR>& rgch);// from execute.cpp
			CTempBuffer<WCHAR, MAX_PATH>  rgchDestPath;
			MsiString strDestPath = *g_pFDIs->achFileDestinationPath;
			ConvertMultiSzToWideChar(*strDestPath, rgchDestPath);
			HRESULT hr = (g_pFDIs->piASM)->CreateStream(0, rgchDestPath, g_pFDIs->fManifest ? STREAM_FORMAT_COMPLIB_MANIFEST : 0, 0, &piDestFile, NULL);
#endif
			if(!SUCCEEDED(hr))
			{
				g_fdirCallbackError = fdirCannotCreateTargetFile;

				FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
				if (fdic == fdicCancel)
				{
					g_fdirCallbackError = fdirUserAbort;
					return INT_PTR(INVALID_HANDLE_VALUE);
				}
				else if (fdic == fdicIgnore)
				{
					// Acknowledge that we've successfully ignored this file,
					// and call WaitCommand to await further instructions
					g_fdirCallbackError = fdirUserIgnore;
					fdic = WaitCommand(fdirSuccessfulCompletion);
					return 0;
				}
				else
					continue;
			}
			else
				break;
		}
		return INT_PTR(g_pDestFile = piDestFile);
	}
	else
	{
		// Try to create the file
		HANDLE hf;
		for(;;)
		{


			bool fImpersonate = (g_pFDIs->iDestDriveType == DRIVE_REMOTE);
			if (fImpersonate)
				AssertNonZero(StartFdiImpersonating());

			hf = MsiCreateFileWithUserAccessCheck(g_pFDIs->achFileDestinationPath,	// file name
									g_pFDIs->pSecurityAttributes,   // do NOT ignore security						
									g_pFDIs->fileAttributes.attr,	// required file attributes
									fImpersonate);

			int iLastError = WIN::GetLastError();
			if (fImpersonate)
				StopFdiImpersonating();
			
			// If this doesn't work, then we probably don't have write permission to that file,
			// because we know the MsiCabinetCopier object already made sure any existing
			// destination file was not READ_ONLY, HIDDEN, etc.
			if (hf != INVALID_HANDLE_VALUE)
			{
				MsiRegisterSysHandle(hf);
				break;
			}
			else
			{
				if (iLastError == ERROR_ACCESS_DENIED)
				{
					if (fImpersonate)
						AssertNonZero(StartFdiImpersonating());
					DWORD dwAttr = MsiGetFileAttributes(g_pFDIs->achFileDestinationPath);
					if (fImpersonate)
						StopFdiImpersonating();
					if (dwAttr != 0xFFFFFFFF && (dwAttr & FILE_ATTRIBUTE_DIRECTORY))
						g_fdirCallbackError = fdirDirErrorCreatingTargetFile;
					else
						g_fdirCallbackError = fdirCannotCreateTargetFile;
				}
				else
					g_fdirCallbackError = fdirCannotCreateTargetFile;

				FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
				if (fdic == fdicCancel)
				{
					g_fdirCallbackError = fdirUserAbort;
					break;
				}
				else if (fdic == fdicIgnore)
				{
					// Acknowledge that we've successfully ignored this file,
					// and call WaitCommand to await further instructions
					g_fdirCallbackError = fdirUserIgnore;
					fdic = WaitCommand(fdirSuccessfulCompletion);
					hf = 0; // Tells FDI to continue, ignoring the current file
					break;
				}
				else
					continue;
			}
		}

		//!! eugend: in the future we'll have to replace the three lines below
		// with:  return INT_PTR(g_hCurDestFile = hf);
		// This is so because on Win64 pointers (and implicitly HANDLEs)
		// are 64-bit and what we're doing below is that we truncate them to 32-bit
		// values before returning them.  We didn't crash so far on Win64 because
		// the handle values returned by CreateFile fit into 32-bits.
		Assert((INT_PTR)hf <= INT_MAX);		//--merced: need to ensure that hf is in the 32-bit range, else we can't pass it out as an int.
		g_hCurDestFile = hf;
		return (int)HandleToLong(hf);		//--merced: okay to typecast since hf will be in the 32-bit range.
	}
}
	

/* C O P Y  F I L E */
/*----------------------------------------------------------------------------
	%%Function: CopyFile
	Called when we receive a fdintCOPY_FILE notification. 
	
	  The following FDI interface requests, and CopyFile's responses are possible:
	
	FDIi:      extract the file "pfdin->psz1"
	CopyFile:  create and return a handle to the destination file. 
	
	FDIi:      extract a file other than "pfdin->psz1"
	CopyFile:  return 0, indicating we don't want that file extracted.
	
	FDIi:      close
	CopyFile:  return -1, indicating we want to abort
	
	FDIi:      open cabinet, or no command pending
	CopyFile:  wait for a command. If it's ExtractFile, then call CopyFile again,
	           otherwise, return -1, indicated we want to abort.
----------------------------------------------------------------------------*/
INT_PTR CopyFile(PFDINOTIFICATION pfdin)
{
	switch(g_pFDIs->fdic)
	{
		case fdicNoCommand: // No command, so we wait for one
		case fdicOpenCabinet:
		{
			// If the last command was fdicOpenCabinet, then this must
			// be the first CopyFile notification after opening a cabinet
			for(;;)
			{
				switch (WaitCommand(fdirSuccessfulCompletion))
				{
					case fdicOpenCabinet:
					{
						g_fdirCallbackError = fdirNeedNextCabinet;
						return -1; // Break out of current cabinet, go on to next
					}
					case fdicExtractFile:
					{
						return CopyFile(pfdin);
					}
					case fdicClose:
					{
						g_fdirCallbackError = fdirClose;
						return -1;
					}
					case fdicContinue:
					{
						g_fdirCallbackError = fdirIllegalCommand;
						return -1;
					}
					case fdicIgnore:
						continue;
					case fdicCancel:
					{
						g_fdirCallbackError = fdirUserAbort;
						return -1;
					}
					default:
					{
						NotifyUser("FDI Server: Unknown command type");
						g_fdirCallbackError = fdirIllegalCommand;
						return -1;
					}
				}
			}
		}
		case fdicClose:
		{
			return -1;
		}
		case fdicExtractFile:
		{
			// If the file we've been asked to extract by the FDI Interface object
			// is the same as the one FDI has, then create the destination file

			if (!IStrCompI(CConvertString(pfdin->psz1), g_pFDIs->achFileSourceName))
			{
				return CreateDestinationFile();
			}
			else
			{
				// Nope, this is not the file we want
				return 0;
			}
		}
		default:
		{
			NotifyUser("FDI Server: Unknown command type");
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
	}
}


/* C L O S E  F I L E  I N F O */
/*----------------------------------------------------------------------------
	%%Function: CloseFileInfo

	Called when we receive the fdintCLOSE_FILE_INFO notification.
	
	Closes the specified (pfdin->hf) file handle.

	Sets the file Date/Time using the values passed in through 
	FDI_Interface::ExtractFile(..).  If datetime==0, then it uses the
	values from the cabinet.
----------------------------------------------------------------------------*/
int CloseFileInfo(PFDINOTIFICATION pfdin)
{
	// Here we set the file date, time and attributes
	FILETIME ftLocalUTC;
	BOOL     rc;

	// Make sure we have something to close!
	if ((HANDLE)pfdin->hf == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(g_pFDIs->piASM)
	{
		IStream* piStream = (IStream*) pfdin->hf;
		HRESULT hr = piStream->Commit(0);
		piStream->Release();
		if(!SUCCEEDED(hr))
		{
			// capture assembly error in verbose log
			PMsiRecord pError(PostAssemblyError(TEXT(""), hr, TEXT("IStream"), TEXT("Commit"), TEXT("")));
			return FALSE;
		}
	}
	else
	{
		rc = DosDateTimeToFileTime(pfdin->date,
											pfdin->time,
											&ftLocalUTC);

		// Per bug 9225, convert from local to universal time first, then set file date/time
		// Also, set the last acccessed time to the current time, same as for non-compressed files
		FILETIME ftUTC, ftCurrentUTC;
		rc &= LocalFileTimeToFileTime(&ftLocalUTC, &ftUTC);
		GetSystemTimeAsFileTime(&ftCurrentUTC);
		// Set the file date/time
		rc &= SetFileTime((HANDLE)pfdin->hf,&ftUTC,&ftCurrentUTC,&ftUTC);
		// Close the file
		rc &= MsiCloseSysHandle((HANDLE)pfdin->hf);

		if (!rc)  // Couldn't set one or more attribs -- or couldn't close file
		{
			g_fdirCallbackError = fdirCannotSetAttributes;
			return FALSE;
		}
	}
	g_pFDIs->fdic = fdicNoCommand;
	g_pFDIs->fPendingExtract = 0;
	return TRUE;
}

/* P A R T I A L  F I L E */
/*----------------------------------------------------------------------------
	%%Function: PartialFile

	Called when we receive the fdintPARTIAL_FILE notification.
	
	This call only happens when a file is split across cabinets
----------------------------------------------------------------------------*/
int PartialFile(PFDINOTIFICATION /*pfdin*/)
{
	return 0; //Yes, just continue; no special processing necessary
}


/* N E X T  C A B I N E T */
/*----------------------------------------------------------------------------
	%%Function: NextCabinet

	Called when we receive the fdintNEXT_CABINET notification.
	
	Reponds to the FDI interface that a new cabinet is needed. If the interface
	commands the server to continue, then 0 is returned. If the interface issues
	any other command, -1 is returned, aborting the extraction.
----------------------------------------------------------------------------*/
int NextCabinet(PFDINOTIFICATION pfdin)
{
	const ICHAR * psz1convert = CConvertString(pfdin->psz1);
	const ICHAR * psz2convert = CConvertString(pfdin->psz2);
	const ICHAR * psz3convert = CConvertString(pfdin->psz3);

	if ( ! psz1convert || ! psz2convert || ! psz3convert )
		return -1;

	// Set up shared data
	IStrCopy(g_pFDIs->achCabinetName, psz1convert);
	IStrCopy(g_pFDIs->achCabinetPath, psz3convert);
	IStrCopy(g_pFDIs->achDiskName, psz2convert);

	switch(WaitCommand(fdirNeedNextCabinet))
	{
		case fdicOpenCabinet:
		{
			// FDIInterface returns from the fdirNeedNextCabinet message with
			// the path of the new cabinet.  Give that path back to FDI.  And
			// in case the cabinet name in the Media table is different than
			// that stored in the cabinet file, give our name back to FDI too.
			lstrcpyA(pfdin->psz1,CConvertString(g_pFDIs->achCabinetName));
			lstrcpyA(pfdin->psz1,CConvertString(g_pFDIs->achCabinetName));
			lstrcpyA(pfdin->psz3,CConvertString(g_pFDIs->achCabinetPath));
			if (WaitCommand(fdirSuccessfulCompletion) == fdicContinue)
			{
				return 0;
			}
			else
			{
				g_fdirCallbackError = fdirIllegalCommand;
				return -1;
			}
		}
		case fdicClose:
		{
			g_fdirCallbackError = fdirClose;
			return -1;
		}
		case fdicExtractFile:
		{
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
		case fdicContinue:
		{
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
		default:
		{
			NotifyUser("FDI Server: Unknown command in NextCabinet()");
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
	}
}


/* F N  F D I  N O T I F Y */
/*----------------------------------------------------------------------------
	%%Function: FNFDINOTIFY

	Dispatches FDI notifications to the appropriate functions.
----------------------------------------------------------------------------*/
FNFDINOTIFY(fdinotify)
{
	switch(fdint)
	{
		case fdintCABINET_INFO :
		{
			//NotifyUser("FDI Server: Received fdintCABINET_INFO notification");
			return CabinetInfo(pfdin);
		}
		case fdintCOPY_FILE :	
		{
			//NotifyUser("FDI Server: Received fdintCOPY_FILE notification");
			return CopyFile(pfdin);
		}
		case fdintCLOSE_FILE_INFO :
		{
			//NotifyUser("FDI Server: Received fdintCLOSE_FILE_INFO notification");
			return CloseFileInfo(pfdin);
		}
		case fdintPARTIAL_FILE :
		{
			//NotifyUser("FDI Server: Received fdintPARTIAL_FILE notification");
			return PartialFile(pfdin);
		}
		case fdintNEXT_CABINET :
		{
			//NotifyUser("FDI Server: Received fdintNEXT_CABINET notification");
			return NextCabinet(pfdin);
		}
		case fdintENUMERATE:
			// Not specifically supporting enumeration - return anything but -1
			// to continue normally
			return 0;
		default:
		{
			NotifyUser("FDI Server: unknown command received by fdinotify");
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
	}
}

/* F N  F D I  D E C R Y P T*/
/*----------------------------------------------------------------------------
	%%Function: FNFDIDECRYPT
	
	We don't do any decryption yet.  But when we do, this is the routine
	to put all the decryption stuff in.
----------------------------------------------------------------------------*/
FNFDIDECRYPT(fdidecrypt)
{
	&pfdid; // This is here to avoid the unused argument warning.
			// It comes from the expansion of the macro in the
			// declaration.

	NotifyUser("FDI Server: Decryption not implemented yet!");
	g_fdirCallbackError = fdirDecryptionNotSupported;
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\autoapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       autoapi.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"  // GUID definitions

#define TYPELIB_MAJOR_VERSION 1  // released version, not rmj
#define TYPELIB_MINOR_VERSION 0  // released version, not rmm

#ifdef INTERNAL
# include <commctrl.h>
# include <shlobj.h>
  class IMsiServices;
# include "imemory.h"
# define IMSIMALLOC_DEFINED
#endif
#include <olectl.h>   // SELFREG_E_*
#include <tchar.h>
#include "msiquery.h"
#include "version.h"
#include "AutoApi.h"  // dispatch IDs, help context IDs
#include "_msinst.h"  // policy defs
#include "msip.h"
#undef  DEFINE_GUID  // allow selective GUID initialization
#define DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
		const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <objsafe.h>
#include "_autoapi.h"
#define OLE
#define W32
#define MSI
#define INITGUID
#ifdef INTERNAL
#define LATEBIND_TYPEDEF
#include "latebind.h"
#define LATEBIND_VECTREF
#include "latebind.h"
#include "_msiutil.h"
bool GetTestFlag(int chTest);
DWORD GetCurrentUserStringSID(TCHAR* szSID);
#else
#define VERSION
namespace OLEAUT32  // wrapper functions to bind on first call
{
typedef BSTR    (WINAPI *T_SysAllocString)(const OLECHAR* sz);
typedef BSTR    (WINAPI *T_SysAllocStringLen)(const OLECHAR* sz, UINT cch);
typedef UINT    (WINAPI *T_SysStringLen)(const OLECHAR* sz);
typedef void    (WINAPI *T_SysFreeString)(const OLECHAR* sz);
typedef HRESULT (WINAPI *T_VariantClear)(VARIANTARG * pvarg);
typedef HRESULT (WINAPI *T_VariantChangeType)(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt);
typedef HRESULT (WINAPI *T_LoadTypeLib)(const OLECHAR  *szFile, ITypeLib ** pptlib);
typedef HRESULT (WINAPI *T_RegisterTypeLib)(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir);
typedef HRESULT (WINAPI *T_UnRegisterTypeLib)(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);
typedef INT     (WINAPI *T_DosDateTimeToVariantTime)(USHORT wDosDate, USHORT wDosTime, double *pvtime);
typedef INT     (WINAPI *T_SystemTimeToVariantTime)(LPSYSTEMTIME lpSystemTime, double *pvtime);
typedef INT     (WINAPI *T_VariantTimeToSystemTime)(double vtime, LPSYSTEMTIME lpSystemTime);
typedef HRESULT (WINAPI *T_VarI4FromR8)(double dblIn, LONG* plOut);

BSTR    WINAPI F_SysAllocString(const OLECHAR* sz);
BSTR    WINAPI F_SysAllocStringLen(const OLECHAR* sz, UINT cch);
UINT    WINAPI F_SysStringLen(const OLECHAR* sz);
void    WINAPI F_SysFreeString(const OLECHAR* sz);
HRESULT WINAPI F_VariantClear(VARIANTARG * pvarg);
HRESULT WINAPI F_VariantChangeType(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt);
HRESULT WINAPI F_LoadTypeLib(const OLECHAR  *szFile, ITypeLib ** pptlib);
HRESULT WINAPI F_RegisterTypeLib(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir);
HRESULT WINAPI F_UnRegisterTypeLib(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);
INT     WINAPI F_DosDateTimeToVariantTime(USHORT wDosDate, USHORT wDosTime, double *pvtime);
INT     WINAPI F_SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, double *pvtime);
INT     WINAPI F_VariantTimeToSystemTime(double vtime, LPSYSTEMTIME lpSystemTime);
HRESULT WINAPI F_VarI4FromR8(double dblIn, LONG* plOut);

T_SysAllocString            SysAllocString           = F_SysAllocString;
T_SysAllocStringLen         SysAllocStringLen        = F_SysAllocStringLen;
T_SysStringLen              SysStringLen             = F_SysStringLen;
T_SysFreeString             SysFreeString            = F_SysFreeString;
T_VariantClear              VariantClear             = F_VariantClear;
T_VariantChangeType         VariantChangeType        = F_VariantChangeType;
T_LoadTypeLib               LoadTypeLib              = F_LoadTypeLib;
T_RegisterTypeLib           RegisterTypeLib          = F_RegisterTypeLib;
T_UnRegisterTypeLib         UnRegisterTypeLib        = F_UnRegisterTypeLib;
T_DosDateTimeToVariantTime  DosDateTimeToVariantTime = F_DosDateTimeToVariantTime;
T_SystemTimeToVariantTime   SystemTimeToVariantTime  = F_SystemTimeToVariantTime;
T_VariantTimeToSystemTime   VariantTimeToSystemTime  = F_VariantTimeToSystemTime;
T_VarI4FromR8               VarI4FromR8              = F_VarI4FromR8;
} // end namespace OLEAUT32
#endif // INTERNAL

// non-public API functions
extern "C"
{
UINT __stdcall MsiGetFeatureParentW(LPCWSTR szProduct, LPCWSTR szFeature, LPWSTR lpParentBuf);
UINT __stdcall MsiGetQualifierDescriptionW(LPCWSTR szComponent, LPCWSTR szQualifier, LPWSTR lpDescription, DWORD *pcchDescription);
}

const GUID IID_IMsiApiInstall     = MSGUID(iidMsiApiInstall);
#ifdef DEBUG
const GUID IID_IMsiApiInstallDebug= MSGUID(iidMsiApiInstallDebug);
#endif
const GUID IID_IMsiSystemAccess   = MSGUID(iidMsiSystemAccess);
const GUID IID_IMsiApiTypeLib     = MSGUID(iidMsiApiTypeLib);
const GUID IID_IMsiApiEngine      = MSGUID(iidMsiApiEngine);
const GUID IID_IMsiApiUIPreview   = MSGUID(iidMsiApiUIPreview);
const GUID IID_IMsiApiDatabase    = MSGUID(iidMsiApiDatabase);
const GUID IID_IMsiApiView        = MSGUID(iidMsiApiView);
const GUID IID_IMsiApiRecord      = MSGUID(iidMsiApiRecord);
const GUID IID_IMsiApiSummaryInfo = MSGUID(iidMsiApiSummaryInfo);
const GUID IID_IMsiApiFeatureInfo = MSGUID(iidMsiApiFeatureInfo);
const GUID IID_IMsiApiCollection  = MSGUID(iidMsiApiCollection);
const GUID IID_IMsiRecordCollection = MSGUID(iidMsiRecordCollection);
const GUID IID_IEnumVARIANT       = MSGUID(iidEnumVARIANT);
#ifndef INTERNAL
const GUID IID_IUnknown           = MSGUID(iidUnknown);
const GUID IID_IClassFactory      = MSGUID(iidClassFactory);
const GUID IID_IDispatch          = MSGUID(iidDispatch);
#endif
#define ERROR_SOURCE_NAME L"Msi API Error"


//____________________________________________________________________________
//
// Global data
//____________________________________________________________________________

#ifdef INTERNAL
extern HINSTANCE g_hInstance;
extern int g_cInstances;
extern bool g_fWin9X;
extern bool g_fWinNT64;
#else
HINSTANCE g_hInstance = 0;
int g_cInstances = 0;
bool g_fWin9X = false;         // TRUE if Windows 95 or 98
bool g_fWinNT64 = false;       // TRUE if 64-bit Windows NT
#endif

//____________________________________________________________________________
//
// CAutoArgs definition, access to automation variant arguments
// operator[] returns CVariant& argument 1 to n, 0 for property value
//____________________________________________________________________________

inline Bool CAutoArgs::PropertySet()
{
	return (m_wFlags & DISPATCH_PROPERTYPUT) ? fTrue : fFalse;
}

inline unsigned int CAutoArgs::GetLastArg()
{
	return m_iLastArg;
}

inline CVariant* CAutoArgs::ResultVariant()
{
	return m_pvResult;
}

// sole function is to force template instantiation for VC4.0, never called
inline DISPID GetEntryDispId(DispatchEntryBase* pTable)
{
	return pTable->dispid;
}

//____________________________________________________________________________
//
// External COM access class for system use
//____________________________________________________________________________

class IMsiSystemAccess : public IUnknown
{
 public:
	virtual UINT __stdcall ProvideComponentFromDescriptor(
				const OLECHAR* szDescriptor,     // product,feature,component info
				OLECHAR*       pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)=0;// returned offset of args in descriptor
	virtual UINT __stdcall ProvideComponentFromDescriptorA(
				const char*    szDescriptor,     // product,feature,component info
				char*          pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)=0;// returned offset of args in descriptor
};

class CMsiSystemAccess : public IMsiSystemAccess  // class private to this module
{
 public:   // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	UINT __stdcall ProvideComponentFromDescriptor(
				const OLECHAR* szDescriptor,     // product,feature,component info
				OLECHAR*       pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset);  // returned offset of args in descriptor
	UINT __stdcall ProvideComponentFromDescriptorA(
				const char*    szDescriptor,     // product,feature,component info
				char*          pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset);  // returned offset of args in descriptor
 public:  // constructor
	CMsiSystemAccess() : m_iRefCnt(1)  { g_cInstances++; }
  ~CMsiSystemAccess()                 { g_cInstances--; }
	void *operator new(size_t cb)   { return W32::GlobalAlloc(GMEM_FIXED, cb); }  // keep local cache
	void operator delete(void * pv) { W32::GlobalFree(pv); }
 protected:
	int         m_iRefCnt;
};

class CInstallerFactory : public IClassFactory
{
 public: // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall CreateInstance(IUnknown* pUnkOuter, const IID& riid,
														void** ppvObject);
	HRESULT       __stdcall LockServer(BOOL fLock);
};
CInstallerFactory g_InstallerFactory;

//____________________________________________________________________________
//
// External COM access class implementation
//____________________________________________________________________________

HRESULT CInstallerFactory::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
		return (*ppvObj = this, NOERROR);
	else
		return (*ppvObj = 0, E_NOINTERFACE);
}
unsigned long CInstallerFactory::AddRef()
{
	return 1;
}
unsigned long CInstallerFactory::Release()
{
	return 1;
}
HRESULT CInstallerFactory::CreateInstance(IUnknown* pUnkOuter, const IID& riid,
													void** ppvObject)
{
	if (pUnkOuter)
		return CLASS_E_NOAGGREGATION;
	if (!(riid == IID_IUnknown || riid == IID_IMsiSystemAccess))
		return E_NOINTERFACE;
	*ppvObject = (void*)new CMsiSystemAccess();
	if (!(*ppvObject))
		return E_OUTOFMEMORY;
	return NOERROR;
}
HRESULT CInstallerFactory::LockServer(BOOL fLock)
{
   if (fLock)
	  g_cInstances++;
   else if (g_cInstances)
		g_cInstances--;
	return NOERROR;
}

HRESULT CMsiSystemAccess::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiSystemAccess)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CMsiSystemAccess::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiSystemAccess::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;              // need to delete before MsiCloseHandle
	return 0;
}

UINT CMsiSystemAccess::ProvideComponentFromDescriptor(
				const OLECHAR* szDescriptor,     // product,feature,component info
				OLECHAR*       pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)   // returned offset of args in descriptor
{
	return MsiProvideComponentFromDescriptorW(szDescriptor, pchPathBuf, pcchPathBuf, pcchArgsOffset);
}

UINT CMsiSystemAccess::ProvideComponentFromDescriptorA(
				const char*    szDescriptor,     // product,feature,component info
				char*          pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)   // returned offset of args in descriptor
{
	return MsiProvideComponentFromDescriptorA(szDescriptor, pchPathBuf, pcchPathBuf, pcchArgsOffset);
}

//____________________________________________________________________________
//
// CVariant inline function definitions
//____________________________________________________________________________

inline int CVariant::GetType()
{
	return vt;
}

inline Bool CVariant::IsRef()
{
	return (vt & VT_BYREF) ? fTrue : fFalse;
}

inline Bool CVariant::IsNull()
{
	return (vt & 0xFF) == VT_NULL ? fTrue : fFalse;
}

inline Bool CVariant::IsString()
{
	return (vt & 0xFF) == VT_BSTR ? fTrue : fFalse;
}

inline Bool CVariant::IsNumeric()
{
	switch (vt & 0xFF)
	{
	case VT_I2: case VT_I4: case VT_R8: case VT_R4: return fTrue;
	default: return fFalse;
	}
}

//____________________________________________________________________________
//
// Class factory definition, factory used temporarily to bootstrap first handle
//____________________________________________________________________________

class CAutoApiFactory : public IClassFactory
{
 public: // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall CreateInstance(IUnknown* pUnkOuter, const IID& riid,
														void** ppvObject);
	HRESULT       __stdcall LockServer(BOOL fLock);
};
CAutoApiFactory g_AutoInstallFactory;

//____________________________________________________________________________
//
// CAutoArgs implementation
//____________________________________________________________________________

CAutoArgs::CAutoArgs(DISPPARAMS* pdispparms, VARIANT* pvarResult, WORD wFlags)
{
	m_cArgs = pdispparms->cArgs;
	m_cNamed = pdispparms->cNamedArgs;
	m_rgiNamed = pdispparms->rgdispidNamedArgs;
	m_rgvArgs = (CVariant*)pdispparms->rgvarg;
	m_pvResult= (CVariant*)pvarResult;
	m_wFlags = wFlags;
	if (pvarResult != 0 && pvarResult->vt != VT_EMPTY)
		OLEAUT32::VariantClear(pvarResult);
}

CVariant g_varEmpty;

CVariant& CAutoArgs::operator [](unsigned int iArg)
{
//  if (iArg > m_cArgs) // || (iArg ==0 && (wFlags & DISPATCH_PROPERTYPUT))
//      throw axMissingArg;
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		iArg = iArg==0 ? DISPID_PROPERTYPUT : iArg - 1;  // values are 0-based
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == iArg)
				break;
	}
	if (ivarArgs < 0)  // loop termination above without match
	{
		g_varEmpty.vt = VT_EMPTY;
		return g_varEmpty;
	}
	m_iLastArg = ivarArgs;
	CVariant* pvarRet = &m_rgvArgs[ivarArgs];
	if (pvarRet->GetType() == VT_VARIANT+VT_BYREF)
		pvarRet = (CVariant*)pvarRet->pvarVal;
	return *pvarRet;
}

Bool CAutoArgs::Present(unsigned int iArg)
{
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == iArg-1)
				break;
	}
	if (ivarArgs < 0)
		return fFalse;
	CVariant& rvar = m_rgvArgs[ivarArgs];
	if (rvar.GetType() == VT_EMPTY)
		return fFalse;
	if (rvar.GetType() == VT_VARIANT+VT_BYREF && rvar.pvarVal->vt == VT_EMPTY)
		return fFalse;
	return fTrue;
}

//____________________________________________________________________________
//
// CAutoArgs return value assignment functions implementation
//____________________________________________________________________________

inline DISPERR CAutoArgs::Assign(enum varVoid)
{
	if (m_pvResult)
		m_pvResult->vt = VT_EMPTY;
	return S_OK;
}

inline DISPERR CAutoArgs::Assign(unsigned int i) {return Assign(int(i));}
inline DISPERR CAutoArgs::Assign(long i) {return Assign(int(i));}
inline DISPERR CAutoArgs::Assign(unsigned long i) {return Assign(int(i));}
inline DISPERR CAutoArgs::Assign(unsigned short i) {return Assign(int(unsigned int(i)));}

DISPERR CAutoArgs::Assign(int i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = i;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(Bool f)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BOOL;
		//m_pvResult->boolVal = short(f == fFalse ? 0 : -1);
		V_BOOL(m_pvResult) = short(f == fFalse ? 0 : -1);
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(FILETIME& rft)
{
	if (m_pvResult)
	{
		SYSTEMTIME stime;
		m_pvResult->vt = VT_DATE;
		if (!W32::FileTimeToSystemTime(&rft, &stime))
			return DISP_E_TYPEMISMATCH;
		if (!OLEAUT32::SystemTimeToVariantTime(&stime, &m_pvResult->date))
			return DISP_E_TYPEMISMATCH;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(DATE& rdate)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_DATE;
		m_pvResult->date = rdate;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(short i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I2;
		m_pvResult->iVal = i;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(IDispatch* pi)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_DISPATCH;
		m_pvResult->pdispVal = pi;  // reference count already bumped
	}
	else if(pi)
		pi->Release();
	return S_OK;
}

DISPERR CAutoArgs::Assign(const char* sz)
{
	if (m_pvResult)
	{
		BSTR bstr = 0;
		if (sz != 0)
		{
			int cchWide = W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, 0, 0);
			bstr = OLEAUT32::SysAllocStringLen(0, cchWide - 1); // null added by API
			W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, bstr, cchWide);
		}
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = bstr;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(const wchar_t* wsz)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = OLEAUT32::SysAllocString(wsz);
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(IEnumVARIANT& ri)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_UNKNOWN; // no defined type for IEnumVARIANT
		m_pvResult->punkVal = &ri;  // reference count already bumped
	}
	else
		ri.Release();
	return S_OK;
}

DISPERR CAutoArgs::Assign(void* pv)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = (long)(LONG_PTR)pv;          //!!merced: 4311 ptr to long
	}
	return S_OK;
}

DISPERR CAutoArgs::ReturnBSTR(BSTR bstr)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = bstr;
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CVariant access functions implementation
//____________________________________________________________________________

DISPERR CVariant::GetInt(int& ri)
{
	switch (vt)
	{
	case VT_R8:              OLEAUT32::VarI4FromR8(dblVal, (long*)&ri); break;
	case VT_R8 | VT_BYREF:   OLEAUT32::VarI4FromR8(*pdblVal, (long*)&ri); break;
	case VT_I4:              ri = lVal;   break;
	case VT_I4 | VT_BYREF:   ri = *plVal; break;
	case VT_I2:              ri = iVal;   break;
	case VT_I2 | VT_BYREF:   ri = *piVal; break;
	case VT_BOOL:            ri = V_BOOL(this) ? TRUE : FALSE; break;
	case VT_BOOL | VT_BYREF: ri = *V_BOOLREF(this) ? TRUE : FALSE; break;
	default: return DISP_E_TYPEMISMATCH;
	}
	return S_OK;
}
inline DISPERR CVariant::GetInt(unsigned int& ri)  {return GetInt((int&)ri);}
inline DISPERR CVariant::GetInt(unsigned long& ri) {return GetInt((int&)ri);}

DISPERR CVariant::GetBool(Bool& rf)
{
	int i;
	HRESULT hr = GetInt(i);
	if (hr == S_OK)
		rf = i ? fTrue : fFalse;
	return hr;
}

#if 0
HRESULT CVariant::GetShort(short& ri)
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hr = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I2);
	if (hr == S_OK)
		ri = varTemp.iVal;
	return hr;
}

CVariant::operator MsiDate()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_DATE);
	if (hrStat != NOERROR)
		throw axConversionFailed;

	unsigned short usDOSDate, usDOSTime;
	int fTime = (varTemp.dblVal >= 0. && varTemp.dblVal < 1.);
	if (fTime)
		varTemp.dblVal += 29221.;  // add 1/1/80 offset so that conversion doesn't fail
	if (!OLEAUT32::VariantTimeToDosDateTime(varTemp.date, &usDOSDate, &usDOSTime))
		throw axConversionFailed;

	if (fTime)
		usDOSDate = 0;  // remove offset, should be 0021H
	MsiDate ad = (MsiDate)((usDOSDate << 16) | usDOSTime);
	return ad;
}
#endif

DISPERR CVariant::GetString(const wchar_t*& rsz)
{
	if (vt == VT_EMPTY)
		rsz = 0;
	if (vt == VT_BSTR)
		rsz = bstrVal;
	else if (vt == (VT_BYREF | VT_BSTR))
		rsz = *pbstrVal;
	else
		return DISP_E_TYPEMISMATCH;
	return S_OK;
}

DISPERR CVariant::GetDispatch(IDispatch*& rpiDispatch)
{
	if (vt == VT_EMPTY)
		rpiDispatch = 0;
	if (vt == VT_DISPATCH)
		rpiDispatch = pdispVal;
	else if (vt == (VT_BYREF | VT_DISPATCH))
		rpiDispatch = *ppdispVal;
	else
		return DISP_E_TYPEMISMATCH;
	if (rpiDispatch)
		rpiDispatch->AddRef();
	return S_OK;
}

MSIHANDLE CVariant::GetHandle(const IID& riid)
{
	IUnknown* piUnknown = NULL;
	MSIHANDLE hMSI = 0;

	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else
		piUnknown = 0;
	if (piUnknown == 0)
		return MSI_NULL_HANDLE;

	// verify that the object is the right type (meaning that it implements
	// the right underlying interface)
	IUnknown* piUnknown2 = NULL;
	if (piUnknown->QueryInterface(riid, (void**)&piUnknown2) != NOERROR)
		return MSI_INVALID_HANDLE;
	piUnknown2->Release();

	// get a dispatch interface pointer
	IDispatch* piDispatch = NULL;
	if (piUnknown->QueryInterface(IID_IDispatch, (void**)&piDispatch) != NOERROR)
		return MSI_INVALID_HANDLE;

	// create the DISPPARMS structure containing the arguments
	VARIANTARG vArg;
	VARIANTARG vRet;
	DISPPARAMS args;
	OLEAUT32::VariantInit(&vRet);
	OLEAUT32::VariantInit(&vArg);	
	args.rgvarg = &vArg;
	args.rgdispidNamedArgs = NULL;
	args.cArgs = 0;
	args.cNamedArgs = 0;

	// determine the dispatch ID for the hidden GetHandle method
	int iDispatchId = 0;
	if (riid == IID_IMsiApiRecord)
	{
		iDispatchId = DISPID_MsiRecord_GetHandle;
	}
	else if (riid == IID_IMsiApiDatabase)
	{
		iDispatchId = DISPID_MsiDatabase_GetHandle;
	}
	else
	{
		AssertSz(0, "Calling GetHandle dispatch on invalid automation object.");
		piDispatch->Release();
		return MSI_INVALID_HANDLE;
	}

	// invoke the call, resulting handle is retrieved from vRet
	HRESULT hRes = piDispatch->Invoke(iDispatchId, IID_NULL, GetUserDefaultLCID(), DISPATCH_PROPERTYGET, &args, &vRet, NULL, NULL);
	hMSI = vRet.lVal;
	piDispatch->Release();

	if (hRes != S_OK)
		return MSI_INVALID_HANDLE;
	return hMSI;
}

//____________________________________________________________________________
//
// CAutoBase implementation, common implementation for IDispatch
//____________________________________________________________________________

CAutoBase::CAutoBase(DispatchEntry<CAutoBase>* pTable, int cDispId, const IID& riid, MSIHANDLE hMsi)
 : m_pTable(pTable)
 , m_cDispId(cDispId)
 , m_hMsi(hMsi)
 , m_riid(riid)
{
	m_iRefCnt = 1;
   g_cInstances++;
}

HRESULT CAutoBase::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IDispatch || riid == m_riid)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CAutoBase::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CAutoBase::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	MSIHANDLE hMsi = m_hMsi;  // save handle before object destroyed
	delete this;              // need to delete before MsiCloseHandle
	g_cInstances--;
	MsiCloseHandle(hMsi);     // may remove memory allocator
	return 0;
}

HRESULT CAutoBase::GetTypeInfoCount(unsigned int *pcTinfo)
{
	*pcTinfo = 0;
	return NOERROR;
}

HRESULT CAutoBase::GetTypeInfo(unsigned int /*itinfo*/, LCID /*lcid*/, ITypeInfo** ppi)
{
	*ppi = 0;
	return E_NOINTERFACE;
}

HRESULT CAutoBase::GetIDsOfNames(const IID&, OLECHAR** rgszNames, unsigned int cNames,
												LCID /*lcid*/, DISPID* rgDispId)
{
	if (cNames == 0 || rgszNames == 0 || rgDispId == 0)
		return E_INVALIDARG;

	unsigned int cErr = cNames;
	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	*rgDispId = DISPID_UNKNOWN;
	for (; --cEntry >= 0; pTable++)
	{
		wchar_t* pchName = pTable->sz;
		for (OLECHAR* pchIn = *rgszNames; *pchIn; pchIn++, pchName++)
		{
			if ((*pchIn ^ *pchName) & ~0x20)
				break;
		}
		if (*pchIn == 0 && *pchName < '0')
		{
			*rgDispId++ = pTable->dispid;
			cErr--;
			while(--cNames != 0)
			{
				rgszNames++;
				*rgDispId = DISPID_UNKNOWN;
				wchar_t* pch = pchName;
				for (DISPID dispid = 0; *pch != 0; dispid++)
				{
					if (*pch != 0)
						pch++;
					for (pchIn = *rgszNames; *pchIn; pchIn++, pch++)
					{
						if ((*pchIn ^ *pch) & ~0x20)
							break;
					}
					if (*pchIn == 0 && *pchName < '0')
					{
						*rgDispId++ = dispid;
						cErr--;
						break;
					}
					while (*pch >= '0')
						pch++;
				}
			}
			break;
		}
	}
	return cErr ? DISP_E_UNKNOWNNAME : NOERROR;
}

HRESULT CAutoBase::Invoke(DISPID dispid, const IID&, LCID /*lcid*/, WORD wFlags,
										DISPPARAMS* pdispparams, VARIANT* pvarResult,
										EXCEPINFO* pExceptInfo, unsigned int* /*puArgErr*/)
{
	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	while (pTable->dispid != dispid)
	{
		pTable++;
		if (--cEntry == 0)
				return DISP_E_MEMBERNOTFOUND;
	}

	if ((wFlags & pTable->aaf) == 0)
		return DISP_E_MEMBERNOTFOUND;

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
		pvarResult = 0;

	CAutoArgs Args(pdispparams, pvarResult, wFlags);
	HRESULT hr = (this->*(pTable->pmf))(Args);
	if (hr != S_OK && (hr & 0xFFFF8000) != 0x80020000)  // pass DISP_E error through
	{
		if ((hr & 0x80000000) == 0)
		{
			switch (hr)
			{
			case ERROR_INVALID_HANDLE:       hr = DISP_E_UNKNOWNINTERFACE;
			case ERROR_INVALID_HANDLE_STATE: hr = TYPE_E_INVALIDSTATE;
			default:                          hr = E_FAIL;
			}
		}
		if (pExceptInfo)
		{
			pExceptInfo->wCode = 1000; //!! ? what should we give?
			pExceptInfo->wReserved = 0;
			pExceptInfo->bstrSource = OLEAUT32::SysAllocString(ERROR_SOURCE_NAME);
			pExceptInfo->bstrDescription = OLEAUT32::SysAllocString(pTable->sz);
			pExceptInfo->bstrHelpFile = OLEAUT32::SysAllocString(L"Msi.chm");
			pExceptInfo->dwHelpContext =  pTable->helpid;
			pExceptInfo->pfnDeferredFillIn = 0;
			pExceptInfo->scode = hr;
			hr = DISP_E_EXCEPTION;
		}
	}
	return hr;
}

MSIHANDLE CAutoBase::GetHandle()
{
	return m_hMsi;
}

//____________________________________________________________________________
//
// CObjectSafety implementation
//____________________________________________________________________________

HRESULT CObjectSafety::QueryInterface(const IID& riid, void** ppvObj)
{
	return This->QueryInterface(riid, ppvObj);
}

unsigned long CObjectSafety::AddRef()
{
	return This->AddRef();
}

unsigned long CObjectSafety::Release()
{
	return This->Release();
}

HRESULT CObjectSafety::GetInterfaceSafetyOptions(const IID& riid, DWORD* pdwSupportedOptions, DWORD* pdwEnabledOptions)
{
	if (!pdwSupportedOptions || !pdwEnabledOptions)
		return E_POINTER;
	DWORD options = 0;
	if (::GetIntegerPolicyValue(szSafeForScripting, fTrue) == 1)
		options = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	*pdwSupportedOptions = options;
	*pdwEnabledOptions = 0;
	if (riid == IID_IDispatch) // Client wants to know if object is safe for scripting
	{       
		*pdwEnabledOptions = options;
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}   
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(const IID& riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
	if (riid == IID_IDispatch) // Client asking if it's safe to call through IDispatch
	{
		if (::GetIntegerPolicyValue(szSafeForScripting, fTrue) == 1 && INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwOptionSetMask && INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwEnabledOptions)
			return S_OK;
		else
			return E_FAIL;
	}
	else
	{
		return E_FAIL;
	}
}

//____________________________________________________________________________
//
// CEnumVARIANTRECORD implementation
//____________________________________________________________________________

CEnumVARIANTRECORD::CEnumVARIANTRECORD(CEnumBuffer& rBuffer)
	: m_rBuffer(rBuffer)
{
	m_iRefCnt = 1;
	rBuffer.iRefCnt++;
	m_cItems = rBuffer.cItems;
	CEnumVARIANTRECORD::Reset();
}

CEnumVARIANTRECORD::~CEnumVARIANTRECORD()
{
	if (--m_rBuffer.iRefCnt <= 0)
	{
		if ( m_cItems )
		{
			VolumeCost** ppstVol = (VolumeCost**)(&m_rBuffer+1);
			for ( int i=0; i < m_cItems; i++ )
				delete *(ppstVol+i);
		}
		delete &m_rBuffer;
	}
}

HRESULT CEnumVARIANTRECORD::QueryInterface(const GUID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumVARIANT)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumVARIANTRECORD::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumVARIANTRECORD::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CEnumVARIANTRECORD::Skip(unsigned long cItem)
{
	while (cItem--)
	{
		if (m_iItem >= m_cItems)
			return S_FALSE;
		m_iItem++;
	}
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Reset()
{
	m_iItem = 0;
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Clone(IEnumVARIANT** ppiRet)
{
	*ppiRet = new CEnumVARIANTRECORD(m_rBuffer);
	return S_OK;
}

unsigned long CEnumVARIANTRECORD::Count()
{
	return m_cItems;
}

HRESULT CEnumVARIANTRECORD::ReturnItem(int iItem, VARIANT* pvarRet)
{
	if (pvarRet)
		pvarRet->vt = VT_EMPTY;

	if ( iItem >= m_cItems )
		return DISP_E_BADINDEX;

	MSIHANDLE hRec;
	hRec = MsiCreateRecord(3);
	if ( !hRec )
		return S_FALSE;

	VolumeCost* pstVol = *((VolumeCost**)(&m_rBuffer+1) + iItem);
	if ( MsiRecordSetStringW(hRec, 1, pstVol->m_szDrive) != ERROR_SUCCESS ||
		  MsiRecordSetInteger(hRec, 2, pstVol->m_iCost) != ERROR_SUCCESS   ||
		  MsiRecordSetInteger(hRec, 3, pstVol->m_iTempCost) != ERROR_SUCCESS )
	{
		MsiCloseHandle(hRec);
		return S_FALSE;
	}
	pvarRet->vt = VT_DISPATCH;
	pvarRet->pdispVal = new CAutoRecord(hRec);
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Next(unsigned long cItem, VARIANT* rgvarRet, unsigned long* pcItemRet)
{
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	while (cItem--)
	{
		HRESULT hRes = ReturnItem(m_iItem, rgvarRet);
		if ( hRes != S_OK )
			return hRes;
		m_iItem++;
		rgvarRet++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Item(unsigned long iIndex, VARIANT* pvarRet)
{
	if (pvarRet)
		return ReturnItem(iIndex, pvarRet);
	else
		return S_FALSE;
}

//____________________________________________________________________________
//
// CEnumVARIANTBSTR implementation
//____________________________________________________________________________

CEnumVARIANTBSTR::CEnumVARIANTBSTR(CEnumBuffer& rBuffer)
	: m_rBuffer(rBuffer)
{
	m_iRefCnt = 1;
	rBuffer.iRefCnt++;
	m_cItems = rBuffer.cItems;
	CEnumVARIANTBSTR::Reset();
}

CEnumVARIANTBSTR::~CEnumVARIANTBSTR()
{
	if (-- m_rBuffer.iRefCnt <= 0)
		delete &m_rBuffer;
}

HRESULT CEnumVARIANTBSTR::QueryInterface(const GUID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumVARIANT)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumVARIANTBSTR::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumVARIANTBSTR::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CEnumVARIANTBSTR::Skip(unsigned long cItem)
{
	while (cItem--)
	{
		if (m_iItem >= m_cItems)
			return S_FALSE;
		int cch = *m_pchNext++;
		m_pchNext += cch;
		m_iItem++;
	}
	return S_OK;
}

HRESULT CEnumVARIANTBSTR::Reset()
{
	m_iItem = m_iLastItem = 0;
	m_pchNext = m_pchLastItem = (WCHAR*)(&m_rBuffer + 1);
	return S_OK;
}

HRESULT CEnumVARIANTBSTR::Clone(IEnumVARIANT** ppiRet)
{
	*ppiRet = new CEnumVARIANTBSTR(m_rBuffer);
	return S_OK;
}

HRESULT CEnumVARIANTBSTR::Next(unsigned long cItem, VARIANT* rgvarRet, unsigned long* pcItemRet)
{
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	while (cItem--)
	{
		if (m_iItem >= m_cItems)
			return S_FALSE;
		int cch = *m_pchNext++;
		rgvarRet->vt = VT_BSTR;
		rgvarRet->bstrVal = OLEAUT32::SysAllocStringLen(m_pchNext, cch);
		m_pchNext += cch;
		m_iItem++;
		rgvarRet++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

unsigned long CEnumVARIANTBSTR::Count()
{
	return m_cItems;
}

HRESULT CEnumVARIANTBSTR::Item(unsigned long iIndex, VARIANT* pvarRet)
{
	if (iIndex >= m_cItems)
	{
		if (pvarRet)
			pvarRet->vt = VT_EMPTY;
		return DISP_E_BADINDEX;
	}
	if (iIndex < m_iLastItem)
	{
		m_iLastItem = 0;
		m_pchLastItem = (WCHAR*)(&m_rBuffer + 1);
	}
	while (m_iLastItem != iIndex)
	{
		int cch = *m_pchLastItem++;
		m_pchLastItem += cch;
		m_iLastItem++;
	}
	if (pvarRet)
	{
		pvarRet->vt = VT_BSTR;
		pvarRet->bstrVal = OLEAUT32::SysAllocStringLen(m_pchLastItem + 1, *m_pchLastItem);
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CAutoCollection implementation
//____________________________________________________________________________

DispatchEntry<CAutoCollection> AutoEnumVARIANTTable[] = {
	DISPID_NEWENUM,             0, aafMethod, CAutoCollection::_NewEnum, L"_NewEnum",
	DISPID_VALUE,               0, aafPropRO, CAutoCollection::Item    , L"Item,Index",
	DISPID_MsiCollection_Count, 0, aafPropRO, CAutoCollection::Count   , L"Count",
};
const int AutoEnumVARIANTCount = sizeof(AutoEnumVARIANTTable)/sizeof(DispatchEntryBase);

CAutoCollection::CAutoCollection(IMsiCollection& riEnum, const IID& riid)
	: CAutoBase(*AutoEnumVARIANTTable, AutoEnumVARIANTCount, riid, 0)
	, m_riEnum(riEnum)
{
}

unsigned long CAutoCollection::Release()
{
	if (m_iRefCnt == 1)
		m_riEnum.Release();
	return CAutoBase::Release();
}

DISPERR CAutoCollection::_NewEnum(CAutoArgs& args)
{
	m_riEnum.AddRef();
	return args.Assign(m_riEnum);
}

DISPERR CAutoCollection::Item(CAutoArgs& args)
{
	unsigned int iIndex;
	DISPERR iErr = args[1].GetInt(iIndex);
	if (iErr)
		return iErr;
	return m_riEnum.Item(iIndex, args.ResultVariant());
}

DISPERR CAutoCollection::Count(CAutoArgs& args)
{
	return args.Assign(m_riEnum.Count());
}

DISPERR CreateAutoEnum(CAutoArgs& args, DISPID dispid, const WCHAR* szParent)
{
	CEnumBuffer* pBuffer = 0;
	int cbBuffer = sizeof(CEnumBuffer);
	WCHAR rgchTemp[1024];
	WCHAR* pchTempEnd = rgchTemp + sizeof(rgchTemp)/sizeof(WCHAR);
	WCHAR* pchTemp = rgchTemp;
	int cItems = 0;
	int iIndex = 0;
	UINT iStat;
	do
	{
		Assert(pchTempEnd - pchTemp <= UINT_MAX);       //--merced: 64-bit ptr subtraction may lead to values too big for cchTemp
		DWORD cchTemp = (DWORD) (pchTempEnd - pchTemp);

		switch (dispid)
		{
		case DISPID_MsiInstall_Products:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumProductsW(iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		case DISPID_MsiInstall_Features:
			if (cchTemp < MAX_FEATURE_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumFeaturesW(szParent, iIndex, pchTemp+1, 0);
			if (iStat == NOERROR)
				cchTemp = lstrlenW(pchTemp + 1);
			break;
		case DISPID_MsiInstall_Components:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumComponentsW(iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		case DISPID_MsiInstall_ComponentQualifiers:
			iStat = MsiEnumComponentQualifiersW(szParent, iIndex, pchTemp+1, &cchTemp, 0, 0);
			break;
		case DISPID_MsiInstall_ComponentClients:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumClientsW(szParent, iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		case DISPID_MsiInstall_Patches:
		{
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
			{
                CTempBuffer<WCHAR, 128> bTransforms;
                DWORD dwSize = bTransforms.GetSize();
                int iRetry = 0;
                do
                    iStat = MsiEnumPatchesW(szParent, iIndex, pchTemp+1,
                                                    bTransforms, &dwSize);
                while (iStat == ERROR_MORE_DATA && ++iRetry < 2 && (bTransforms.SetSize(++dwSize), true));
			}
			cchTemp = STRING_GUID_CHARS;  // transforms are left out here
			break;
		}
		case DISPID_MsiInstall_RelatedProducts:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumRelatedProductsW(szParent, 0, iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		default:
			Assert(0);
			return DISP_E_BADCALLEE;
		}
		if (iStat == NOERROR)
		{
			*pchTemp++ = (unsigned short)cchTemp;
			pchTemp += cchTemp;
			iIndex++;
			cItems++;
		}
		else if (iStat == ERROR_MORE_DATA || iStat == ERROR_NO_MORE_ITEMS)
		{
			CEnumBuffer* pOldBuffer = pBuffer;
			int cbOld = cbBuffer;
			Assert((char*)pchTemp - (char*)rgchTemp <= INT_MAX);    //--merced: 64-bit ptr subtraction may lead to values too big for cbNew
			int cbNew = (int)((char*)pchTemp - (char*)rgchTemp);
			cbBuffer = cbOld + cbNew;
			pBuffer = (CEnumBuffer*)new char[cbBuffer];
			if ( ! pBuffer )
			{
				delete pOldBuffer;
				return E_OUTOFMEMORY;
			}
			if (pOldBuffer == 0)
			{
				pBuffer->iRefCnt = 0;
				pBuffer->cItems = 0;
			}
			else
			{
				memcpy(pBuffer, pOldBuffer, cbOld);
				delete pOldBuffer;
			}
			memcpy((char*)pBuffer + (INT_PTR)cbOld, rgchTemp, cbNew);       //--merced: added (INT_PTR)
			pBuffer->cItems += cItems; cItems = 0;
			pBuffer->cbSize = cbBuffer;
			pchTemp = rgchTemp;
		}
		else
		{
			delete pBuffer;
			return HRESULT_FROM_WIN32(iStat);
		}
	} while(iStat != ERROR_NO_MORE_ITEMS);
	IMsiCollection* piEnum = new CEnumVARIANTBSTR(*pBuffer);
	return args.Assign(new CAutoCollection(*piEnum, IID_IMsiApiCollection));
}

//____________________________________________________________________________
//
// CAutoInstall implementation
//____________________________________________________________________________

DispatchEntry<CAutoInstall> AutoInstallTable[] = {
  DISPID_MsiInstall_OpenPackage ,       HELPID_MsiInstall_OpenPackage ,       aafMethod, CAutoInstall::OpenPackage,        L"OpenPackage,PackagePath,Options",
  DISPID_MsiInstall_OpenProduct ,       HELPID_MsiInstall_OpenProduct ,       aafMethod, CAutoInstall::OpenProduct,        L"OpenProduct,ProductCode",
  DISPID_MsiInstall_OpenDatabase,       HELPID_MsiInstall_OpenDatabase,       aafMethod, CAutoInstall::OpenDatabase,       L"OpenDatabase,DatabasePath,OpenMode",
  DISPID_MsiInstall_CreateRecord,       HELPID_MsiInstall_CreateRecord,       aafMethod, CAutoInstall::CreateRecord,       L"CreateRecord,Count",
  DISPID_MsiInstall_SummaryInformation, HELPID_MsiInstall_SummaryInformation, aafPropRO, CAutoInstall::SummaryInformation, L"SummaryInformation,DatabasePath,UpdateCount",
  DISPID_MsiInstall_UILevel,            HELPID_MsiInstall_UILevel,            aafPropRW, CAutoInstall::UILevel,            L"UILevel",
  DISPID_MsiInstall_EnableLog,          HELPID_MsiInstall_EnableLog,          aafMethod, CAutoInstall::EnableLog,          L"EnableLog,LogMode,LogFile",
  DISPID_MsiInstall_InstallProduct,     HELPID_MsiInstall_InstallProduct,     aafMethod, CAutoInstall::InstallProduct,     L"InstallProduct,PackagePath,PropertyValues",
  DISPID_MsiInstall_Version,            HELPID_MsiInstall_Version,            aafPropRO, CAutoInstall::Version,            L"Version",
  DISPID_MsiInstall_LastErrorRecord  ,  HELPID_MsiInstall_LastErrorRecord,    aafPropRO, CAutoInstall::LastErrorRecord,    L"LastErrorRecord",
  DISPID_MsiInstall_RegistryValue,      HELPID_MsiInstall_RegistryValue,      aafMethod, CAutoInstall::RegistryValue,      L"RegistryValue,Root,Key,Value",
  DISPID_MsiInstall_FileAttributes,     HELPID_MsiInstall_FileAttributes,     aafMethod, CAutoInstall::FileAttributes,     L"FileAttributes,FilePath",
  DISPID_MsiInstall_FileSize,           HELPID_MsiInstall_FileSize,           aafMethod, CAutoInstall::FileSize,           L"FileSize,FilePath",
  DISPID_MsiInstall_FileVersion,        HELPID_MsiInstall_FileVersion,        aafMethod, CAutoInstall::FileVersion,        L"FileVersion,FilePath,Language",
  DISPID_MsiInstall_Environment,        HELPID_MsiInstall_Environment,        aafPropRW, CAutoInstall::Environment,        L"Environment,Variable",
  DISPID_MsiInstall_ExternalUI,         0,                                    aafMethod, CAutoInstall::ExternalUI,         L"ExternalUI,Filter,Delay",
  DISPID_MsiInstall_ProductState      , HELPID_MsiInstall_ProductState      , aafPropRO, CAutoInstall::ProductState      , L"ProductState,Product",
  DISPID_MsiInstall_ProductInfo       , HELPID_MsiInstall_ProductInfo       , aafPropRO, CAutoInstall::ProductInfo       , L"ProductInfo,Product,Attribute",
  DISPID_MsiInstall_ConfigureProduct  , HELPID_MsiInstall_ConfigureProduct  , aafMethod, CAutoInstall::ConfigureProduct  , L"ConfigureProduct,Product,InstallLevel,InstallState",
  DISPID_MsiInstall_ReinstallProduct  , HELPID_MsiInstall_ReinstallProduct  , aafMethod, CAutoInstall::ReinstallProduct  , L"ReinstallProduct,Product,ReinstallMode",
  DISPID_MsiInstall_CollectUserInfo   , HELPID_MsiInstall_CollectUserInfo   , aafMethod, CAutoInstall::CollectUserInfo   , L"CollectUserInfo",
  DISPID_MsiInstall_ApplyPatch        , HELPID_MsiInstall_ApplyPatch        , aafMethod, CAutoInstall::ApplyPatch        , L"ApplyPatch,PatchPackage,InstallPackage,InstallType,CommandLine",
  DISPID_MsiInstall_FeatureParent     , HELPID_MsiInstall_FeatureParent     , aafPropRO, CAutoInstall::FeatureParent     , L"FeatureParent,Product,Feature",
  DISPID_MsiInstall_FeatureState      , HELPID_MsiInstall_FeatureState      , aafPropRO, CAutoInstall::FeatureState      , L"FeatureState,Product,Feature",
  DISPID_MsiInstall_UseFeature        , HELPID_MsiInstall_UseFeature        , aafMethod, CAutoInstall::UseFeature        , L"UseFeature,Product,Feature",
  DISPID_MsiInstall_FeatureUsageCount , HELPID_MsiInstall_FeatureUsageCount , aafPropRO, CAutoInstall::FeatureUsageCount , L"FeatureUsageCount,Product,Feature",
  DISPID_MsiInstall_FeatureUsageDate  , HELPID_MsiInstall_FeatureUsageDate  , aafPropRO, CAutoInstall::FeatureUsageDate  , L"FeatureUsageDate,Product,Feature",
  DISPID_MsiInstall_ConfigureFeature  , HELPID_MsiInstall_ConfigureFeature  , aafMethod, CAutoInstall::ConfigureFeature  , L"ConfigureFeature,Product,Feature,InstallState",
  DISPID_MsiInstall_ReinstallFeature  , HELPID_MsiInstall_ReinstallFeature  , aafMethod, CAutoInstall::ReinstallFeature  , L"ReinstallFeature,Product,Feature,ReinstallMode",
  DISPID_MsiInstall_ProvideComponent  , HELPID_MsiInstall_ProvideComponent  , aafMethod, CAutoInstall::ProvideComponent  , L"ProvideComponent,Product,Feature,Component,InstallMode",
  DISPID_MsiInstall_ComponentPath     , HELPID_MsiInstall_ComponentPath     , aafPropRO, CAutoInstall::ComponentPath     , L"ComponentPath,Product,Component",
  DISPID_MsiInstall_ProvideQualifiedComponent, HELPID_MsiInstall_ProvideQualifiedComponent, aafMethod, CAutoInstall::ProvideQualifiedComponent, L"ProvideQualifiedComponent,Category,Qualifier,InstallMode",
  DISPID_MsiInstall_QualifierDescription, HELPID_MsiInstall_QualifierDescription, aafPropRO, CAutoInstall::QualifierDescription, L"QualifierDescription,Category,Qualifier",
  DISPID_MsiInstall_ComponentQualifiers,HELPID_MsiInstall_ComponentQualifiers,aafPropRO, CAutoInstall::ComponentQualifiers,L"ComponentQualifiers",
  DISPID_MsiInstall_Products,           HELPID_MsiInstall_Products,           aafPropRO, CAutoInstall::Products,           L"Products",
  DISPID_MsiInstall_Features,           HELPID_MsiInstall_Features,           aafPropRO, CAutoInstall::Features,           L"Features,Product",
  DISPID_MsiInstall_Components,         HELPID_MsiInstall_Components,         aafPropRO, CAutoInstall::Components,         L"Components",
  DISPID_MsiInstall_ComponentClients,   HELPID_MsiInstall_ComponentClients,   aafPropRO, CAutoInstall::ComponentClients,   L"ComponentClients,Product",
  DISPID_MsiInstall_Patches,            HELPID_MsiInstall_Patches,            aafPropRO, CAutoInstall::Patches,            L"Patches,Product",
  DISPID_MsiInstall_RelatedProducts,    HELPID_MsiInstall_RelatedProducts,    aafPropRO, CAutoInstall::RelatedProducts,    L"RelatedProducts,UpgradeCode",
  DISPID_MsiInstall_PatchInfo,          HELPID_MsiInstall_PatchInfo,          aafPropRO, CAutoInstall::PatchInfo,          L"PatchInfo,Patch,Attribute",
  DISPID_MsiInstall_PatchTransforms,    HELPID_MsiInstall_PatchTransforms,    aafPropRO, CAutoInstall::PatchTransforms,    L"PatchTransforms,Product,Patch",
  DISPID_MsiInstall_AddSource,          HELPID_MsiInstall_AddSource,          aafMethod, CAutoInstall::AddSource,          L"AddSource,Product,User,Source",
  DISPID_MsiInstall_ClearSourceList,    HELPID_MsiInstall_ClearSourceList,    aafMethod, CAutoInstall::ClearSourceList,    L"ClearSourceList,Product,User",
  DISPID_MsiInstall_ForceSourceListResolution, HELPID_MsiInstall_ForceSourceListResolution, aafMethod, CAutoInstall::ForceSourceListResolution, L"ForceSourceListResolution,Product,User",
  DISPID_MsiInstall_GetShortcutTarget,  HELPID_MsiInstall_GetShortcutTarget,  aafPropRO, CAutoInstall::GetShortcutTarget,  L"ShortcutTarget",
  DISPID_MsiInstall_FileHash,           HELPID_MsiInstall_FileHash,           aafMethod, CAutoInstall::FileHash,           L"FileHash,FilePath,Options",
  DISPID_MsiInstall_FileSignatureInfo,  HELPID_MsiInstall_FileSignatureInfo,  aafMethod, CAutoInstall::FileSignatureInfo,  L"FileSignatureInfo,FilePath,Options,Format",
};
const int AutoInstallCount = sizeof(AutoInstallTable)/sizeof(DispatchEntryBase);

HRESULT CAutoInstall::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IObjectSafety)
	{
		*ppvObj = &m_ObjectSafety;
		AddRef();
		return S_OK;
	}
	return CAutoBase::QueryInterface(riid, ppvObj);
}

CAutoInstall::CAutoInstall(MSIHANDLE hBase)
 : CAutoBase(*AutoInstallTable, AutoInstallCount, IID_IMsiApiInstall, hBase)
{
	m_ObjectSafety.This = this;
}

#ifdef INTERNAL
MSIHANDLE CreateMsiHandle(IUnknown* pi, int iid);
void RedirectMsiHandle(MSIHANDLE h, IUnknown& riunk);
#endif // INTERNAL

CAutoInstall* CreateAutoInstall()
{
	MSIHANDLE hBase;
#ifdef INTERNAL
	hBase = ::CreateMsiHandle(&g_AutoInstallFactory, 0);
	if (hBase == 0)   // can't allocate memory
		return 0;
#else
	hBase = 0;
#endif // INTERNAL
	return new CAutoInstall(hBase);
}

IDispatch* CreateAutoInstallDispatch()
{
	return static_cast<IDispatch*>(CreateAutoInstall());
}

#if 0 //def INTERNAL
unsigned long CAutoInstall::Release()  // override to destruct from handle manager
{
	if (--m_iRefCnt > 0)
		return m_iRefCnt;
	if (m_iRefCnt == 0)
	{
		RedirectMsiHandle(m_hMsi, *this);
		MsiCloseHandle(m_hMsi);  // forces another release, then may free allocator
	}
	else  // called recursively from MsiCloseHandle
		delete this;
	return 0;
}
#endif // INTERNAL

DISPERR CAutoInstall::OpenPackage(CAutoArgs& args)
{
	MSIHANDLE hEngine;
	const WCHAR* szPath;
	WCHAR rgchBuf[20];
	DISPERR iErr;

	DWORD dwOptions = 0;
	if (args.Present(2) && (iErr = args[2].GetInt((int&)dwOptions)) != S_OK)
		return iErr;

   if ((iErr = args[1].GetString(szPath)) != S_OK)
	{
		MSIHANDLE h = args[1].GetHandle(IID_IMsiApiDatabase);
		if (h == MSI_NULL_HANDLE || h == MSI_INVALID_HANDLE)
			return iErr;
#ifdef UNICODE
		W32::wsprintfW(rgchBuf, L"#%i", h);
#else
		char rgchTemp[20];
		W32::wsprintfA(rgchTemp, "#%i", h);
		W32::MultiByteToWideChar(CP_ACP, 0, rgchTemp, -1, rgchBuf, sizeof(rgchBuf)/sizeof(WCHAR));
#endif
		szPath = rgchBuf;
	}
	if ((iErr = MsiOpenPackageExW(szPath, dwOptions, &hEngine)) == NOERROR)
		args.Assign(new CAutoEngine(hEngine, this));
	return iErr;
}

DISPERR CAutoInstall::OpenProduct(CAutoArgs& args)
{
	MSIHANDLE hEngine;
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) == S_OK
	 && (iErr = MsiOpenProductW(szProduct, &hEngine)) == NOERROR)
		args.Assign(new CAutoEngine(hEngine, this));
	return iErr;
}

DISPERR CAutoInstall::OpenDatabase(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;
	CVariant& var = args[2];
	UINT iDataType = var.GetType();
	LPCWSTR szPersist;
	int i;      
	if ((iErr = var.GetInt(i)) == S_OK)
		szPersist = (LPCWSTR)(INT_PTR)i;        //--merced: added (INT_PTR) to avoid warning 4312
	else if ((iErr = var.GetString(szPersist)) != S_OK)
		return iErr;
	MSIHANDLE hDatabase;
	if ((iErr = MsiOpenDatabaseW(szPath, szPersist, &hDatabase)) == NOERROR)
		args.Assign(new CAutoDatabase(hDatabase));
	if (iErr == ERROR_INVALID_PARAMETER)  // let API function do arg validation
		return DISP_E_BADINDEX;
	return iErr;
}

DISPERR CAutoInstall::CreateRecord(CAutoArgs& args)
{
	int cFields;
	DISPERR iErr = args[1].GetInt(cFields);
	if (iErr)
		return iErr;
	if (cFields < 0 || cFields > MSIRECORD_MAXFIELDS)
		return E_INVALIDARG;
   MSIHANDLE hRecord = MsiCreateRecord(cFields);
	if (hRecord == 0)
		return DISP_E_TYPEMISMATCH;
	return args.Assign(new CAutoRecord(hRecord));
}

DISPERR CAutoInstall::SummaryInformation(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szPath;
	MSIHANDLE hSummaryInfo;
	UINT cUpdate = 0;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;
	if (args.Present(2) && (iErr = args[2].GetInt((int&)cUpdate)) != S_OK)
		return iErr;
	if ((iErr = MsiGetSummaryInformationW(0, szPath, cUpdate, &hSummaryInfo)) == S_OK)
		args.Assign(new CAutoSummaryInfo(hSummaryInfo));
	return iErr;
}

DISPERR CAutoInstall::UILevel(CAutoArgs& args)
{
	DISPERR iErr;
	if (args.PropertySet())
	{
		INSTALLUILEVEL eUI;
		if ((iErr = args[0].GetInt((int&)eUI)) != S_OK)
			return iErr;
		if (MsiSetInternalUI(eUI, 0) == INSTALLUILEVEL_NOCHANGE)
			return DISP_E_BADINDEX;
	}
	else
		args.Assign((int)MsiSetInternalUI(INSTALLUILEVEL_NOCHANGE, 0));
	return S_OK;
}

int WINAPI ExternalUIHandler(LPVOID pvContext, UINT /*iMessageType*/, LPCTSTR /*szMessage*/)
{
//  int iMsg = iMessageType >> 24;  
	W32::Sleep((DWORD)(ULONG_PTR)pvContext);  // just slow down a bit for now           //--merced: added (ULONG_PTR) to avoid warning 4311
	return 0;  // not handled here
}

DISPERR CAutoInstall::ExternalUI(CAutoArgs& args)
{
	int iFilter;
	int iDelay = 50;
	int iErr;
	if ((iErr = args[1].GetInt(iFilter)) != S_OK)
		return iErr;
	if (args.Present(2) && (iErr = args[2].GetInt(iDelay)) != S_OK)
		return iErr;
	MsiSetExternalUI(iFilter ? ExternalUIHandler : 0, iFilter, (LPVOID)(INT_PTR)iDelay);        //--merced: added (INT_PTR) to avoid warning 4312
	return S_OK;
}

DISPERR CAutoInstall::EnableLog(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szLogMode;
	LPCWSTR szLogFile;
	if ((iErr = args[1].GetString(szLogMode)) != S_OK
	||  (iErr = args[2].GetString(szLogFile)) != S_OK)
		return iErr;
	BOOL fAppend = FALSE;
	WCHAR ch;
	const ICHAR* pchLogChars = szLogChars;
	DWORD dwLogMode = 0;
	while ((ch = *szLogMode++) != 0)
	{
		if (ch == TEXT(' '))
			continue;
		if (ch == TEXT('*'))
		{
			dwLogMode |= ((1 << (sizeof(szLogChars)/sizeof(*szLogChars) - 1)) - 1) & ~INSTALLLOGMODE_VERBOSE;
			continue;
		}
		if (ch == TEXT('+'))
		{
			fAppend = TRUE;
			continue;
		}
		if (ch >= TEXT('A') && ch <= TEXT('Z'))
			ch += (TEXT('a') - TEXT('A'));
		for (const ICHAR* pch = szLogChars; *pch != ch; pch++)
			if (*pch == 0)
				return DISP_E_BADINDEX;
		dwLogMode |= (1 << (pch - szLogChars));
	}
   return MsiEnableLogW(dwLogMode, szLogFile, fAppend);
}

DISPERR CAutoInstall::InstallProduct(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szProperties = 0;
	LPCWSTR szPath;
	WCHAR rgchBuf[20];
	if ((iErr = args[1].GetString(szPath)) != S_OK)
	{
		MSIHANDLE h = args[1].GetHandle(IID_IMsiApiDatabase);
		if (h == MSI_NULL_HANDLE || h == MSI_INVALID_HANDLE)
			return iErr;
#ifdef UNICODE
		W32::wsprintfW(rgchBuf, L"#%i", h);
#else
		char rgchTemp[20];
		W32::wsprintfA(rgchTemp, "#%i", h);
		W32::MultiByteToWideChar(CP_ACP, 0, rgchTemp, -1, rgchBuf, sizeof(rgchBuf)/sizeof(WCHAR));
#endif
		szPath = rgchBuf;
	}
	if (args.Present(2) && (iErr = args[2].GetString(szProperties)) != S_OK)
		return iErr;
   return MsiInstallProductW(szPath, szProperties);
}

DISPERR CAutoInstall::Version(CAutoArgs& args)
{
	TCHAR rgchBuf[20];
	W32::wsprintf(rgchBuf, TEXT("%i.%i.%i.%i"), rmj, rmm, rup, rin);
	return args.Assign(rgchBuf);
}
	
DISPERR CAutoInstall::LastErrorRecord(CAutoArgs& args)
{
	MSIHANDLE h = MsiGetLastErrorRecord();
	return args.Assign((IDispatch*)(h ? new CAutoRecord(h) : 0));
}

DISPERR CAutoInstall::ProductState(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return args.Assign((long)MsiQueryProductStateW(szProduct));
}

DISPERR CAutoInstall::ProductInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szAttribute;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szAttribute)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiGetProductInfoW(szProduct, szAttribute, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;

	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::PatchInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szPatch;
	const WCHAR* szAttribute;
	if ((iErr = args[1].GetString(szPatch)) != S_OK
	 || (iErr = args[2].GetString(szAttribute)) != S_OK)
		return iErr;

	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	int iRetry = 0;
	do
		iErr = MsiGetPatchInfoW(szPatch, szAttribute, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && ++iRetry < 2 && (bResult.SetSize(++dwSize), true));

	return iErr != ERROR_SUCCESS ? iErr : args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::PatchTransforms(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szArgPatch;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szArgPatch)) != S_OK)
		return iErr;

	CTempBuffer<WCHAR, 128> bTransforms;
	DWORD dwSize = bTransforms.GetSize();
	CTempBuffer<WCHAR, STRING_GUID_CHARS+1> szPatch;
	int iIndex = 0;
	do
	{
		int iRetry = 0;
		do
			iErr = MsiEnumPatchesW(szProduct, iIndex, szPatch,
										  bTransforms, &dwSize);
		while (iErr == ERROR_MORE_DATA && ++iRetry < 2 && (bTransforms.SetSize(++dwSize), true));
		if ( iErr == ERROR_SUCCESS && !lstrcmpW(szArgPatch, szPatch) )
		{
			// we're on the right patch
			return args.Assign((const WCHAR* )bTransforms);
		}
		iIndex++;
	}
	while ( iErr == ERROR_SUCCESS );

	return iErr;
}

DISPERR CAutoInstall::AddSource(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szUser;
	const WCHAR* szSource;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szUser)) != S_OK
	 || (iErr = args[3].GetString(szSource)) != S_OK)
		return iErr;

	return MsiSourceListAddSourceW(szProduct, szUser, 0, szSource);
}

DISPERR CAutoInstall::ClearSourceList(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szUser;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szUser)) != S_OK)
		return iErr;

	return MsiSourceListClearAllW(szProduct, szUser, 0);
}

DISPERR CAutoInstall::ForceSourceListResolution(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szUser;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szUser)) != S_OK)
		return iErr;

	return MsiSourceListForceResolutionW(szProduct, szUser, 0);
}

DISPERR CAutoInstall::ConfigureProduct(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	int          iInstallLevel;
	INSTALLSTATE eInstallState;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetInt(iInstallLevel)) != S_OK
	 || (iErr = args[3].GetInt((int&)eInstallState)) != S_OK)
		return iErr;
	return MsiConfigureProductW(szProduct, iInstallLevel, eInstallState);
}

DISPERR CAutoInstall::ReinstallProduct(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	int          iReinstallMode;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetInt(iReinstallMode)) != S_OK)
		return iErr;
	return MsiReinstallProductW(szProduct, iReinstallMode);
}

DISPERR CAutoInstall::CollectUserInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return MsiCollectUserInfoW(szProduct);
}

DISPERR CAutoInstall::ApplyPatch(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szPatchPackage;
	const WCHAR* szInstallPackage;
	int          iInstallType;
	const WCHAR* szCommandLine;
	if ((iErr = args[1].GetString(szPatchPackage)) != S_OK
	 || (iErr = args[2].GetString(szInstallPackage)) != S_OK
	 || (iErr = args[3].GetInt(iInstallType)) != S_OK
	 || (iErr = args[4].GetString(szCommandLine)) != S_OK)
		return iErr;
	return MsiApplyPatchW(szPatchPackage, szInstallPackage, (INSTALLTYPE)iInstallType, szCommandLine);
}

DISPERR CAutoInstall::FeatureParent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	WCHAR szParent[MAX_FEATURE_CHARS+1 + 100];
	if ((iErr = MsiGetFeatureParentW(szProduct, szFeature, szParent)) != NOERROR)
		return iErr;
	return args.Assign(szParent);
}

DISPERR CAutoInstall::FeatureState(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	return args.Assign((int)MsiQueryFeatureStateW(szProduct, szFeature));
}

DISPERR CAutoInstall::UseFeature(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	INSTALLMODE iInstallMode = INSTALLMODE_DEFAULT;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (args.Present(3) && (iErr = args[3].GetInt((int&)iInstallMode)) != S_OK))
		return iErr;
	return args.Assign((int)MsiUseFeatureExW(szProduct, szFeature, iInstallMode, 0));
}

DISPERR CAutoInstall::FeatureUsageCount(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	DWORD iUseCount;
	if ((iErr = MsiGetFeatureUsageW(szProduct, szFeature, &iUseCount, 0)) != NOERROR)
		return iErr;
	return args.Assign(iUseCount);
}

DISPERR CAutoInstall::FeatureUsageDate(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	WORD iDate;
	if ((iErr = MsiGetFeatureUsageW(szProduct, szFeature, 0, &iDate)) != NOERROR)
		return iErr;
	DATE date = 0;
	if (iDate != 0)
		OLEAUT32::DosDateTimeToVariantTime(iDate, 0, &date);
	return args.Assign(date);
}

DISPERR CAutoInstall::ConfigureFeature(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	INSTALLSTATE eInstallState;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (iErr = args[3].GetInt((int&)eInstallState)) != S_OK)
		return iErr;
	return MsiConfigureFeatureW(szProduct, szFeature, eInstallState);
}

DISPERR CAutoInstall::ReinstallFeature(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	int          iReinstallMode;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (iErr = args[3].GetInt(iReinstallMode)) != S_OK)
		return iErr;
	return MsiReinstallFeatureW(szProduct, szFeature, iReinstallMode);
}

DISPERR CAutoInstall::ProvideComponent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	const WCHAR* szComponent;
	int          iInstallMode;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (iErr = args[3].GetString(szComponent)) != S_OK
	 || (iErr = args[4].GetInt(iInstallMode)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiProvideComponentW(szProduct, szFeature, szComponent, iInstallMode, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != NOERROR)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::ComponentPath(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szComponent;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szComponent)) != S_OK)
		return iErr;
	INSTALLSTATE iState;
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iState = MsiGetComponentPathW(szProduct, szComponent, bResult, &dwSize);
	while (iState == INSTALLSTATE_MOREDATA && (bResult.SetSize(++dwSize), true));
	if (iState != INSTALLSTATE_LOCAL && iState != INSTALLSTATE_SOURCE)
		return args.Assign(fVoid);
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::ProvideQualifiedComponent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szCategory;
	const WCHAR* szQualifier;
	int          iInstallMode;
	if ((iErr = args[1].GetString(szCategory)) != S_OK
	 || (iErr = args[2].GetString(szQualifier)) != S_OK
	 || (iErr = args[3].GetInt(iInstallMode)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiProvideQualifiedComponentW(szCategory, szQualifier, iInstallMode, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != NOERROR)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::QualifierDescription(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szCategory;
	const WCHAR* szQualifier;
	if ((iErr = args[1].GetString(szCategory)) != S_OK
	 || (iErr = args[2].GetString(szQualifier)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiGetQualifierDescriptionW(szCategory, szQualifier, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != NOERROR)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::GetShortcutTarget(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szShortcutTarget;

	// from msi.h
	#define MAX_FEATURE_CHARS  38   // maximum chars in feature name (same as string GUID)
	const int cchGUID                     = 38;
	const int cchMaxFeatureName           = MAX_FEATURE_CHARS;
	const int cchProductCode              = cchGUID;
	const int cchComponentId              = cchGUID;

	WCHAR szProductCode[cchProductCode+1];
	WCHAR szFeatureId[cchMaxFeatureName+1];
	WCHAR szComponentCode[cchComponentId+1];

	if ((iErr = args[1].GetString(szShortcutTarget)) != S_OK)
		return iErr;
	
	iErr = MsiGetShortcutTargetW(szShortcutTarget, szProductCode, szFeatureId, szComponentCode);
	if (iErr != ERROR_SUCCESS)
		return iErr;

	MSIHANDLE pRec = MsiCreateRecord(3);
	MsiRecordSetStringW(pRec, 1, szProductCode);
	MsiRecordSetStringW(pRec, 2, szFeatureId);
	MsiRecordSetStringW(pRec, 3, szComponentCode);

	return args.Assign(new CAutoRecord(pRec));
}

DISPERR CAutoInstall::ComponentQualifiers(CAutoArgs& args)
{
	const WCHAR* szCategory;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szCategory)) != S_OK)
		return iErr;
	return CreateAutoEnum(args, DISPID_MsiInstall_ComponentQualifiers, szCategory);
}

DISPERR CAutoInstall::Products(CAutoArgs& args)
{
	return CreateAutoEnum(args, DISPID_MsiInstall_Products, 0);
}

DISPERR CAutoInstall::Features(CAutoArgs& args)
{
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return CreateAutoEnum(args, DISPID_MsiInstall_Features, szProduct);
}

DISPERR CAutoInstall::Components(CAutoArgs& args)
{
	return CreateAutoEnum(args, DISPID_MsiInstall_Components, 0);
}

DISPERR CAutoInstall::ComponentClients(CAutoArgs& args)
{
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return CreateAutoEnum(args, DISPID_MsiInstall_ComponentClients, szProduct);
}

DISPERR CAutoInstall::Patches(CAutoArgs& args)
{
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;

	return CreateAutoEnum(args, DISPID_MsiInstall_Patches, szProduct);
}

DISPERR CAutoInstall::RelatedProducts(CAutoArgs& args)
{
	const WCHAR* szUpgradeCode;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szUpgradeCode)) != S_OK)
		return iErr;

	return CreateAutoEnum(args, DISPID_MsiInstall_RelatedProducts, szUpgradeCode);
}

// Non-installer functions to access system properties

DISPERR CAutoInstall::RegistryValue(CAutoArgs& args)
{
	enum rvEnum
	{
		rvGetValue   = 0,
		rvKeyPresent = 1,
		rvEnumValue  = 2,
		rvEnumKey    = 3,
		rvGetClass   = 4,
	};
	DISPERR iErr;
	int iRoot = 0;
	HKEY hkeyRoot;
	HKEY hkey;
	const WCHAR* szKey;
	int iValueName = 0x80000000L;
	const WCHAR* szValue = 0; //L"";
	BYTE  rgbValBuf[MAX_PATH];
	BYTE* pbVal;
	WCHAR rgchExpandBuf[MAX_PATH*2];
	DWORD iValueType;
	unsigned long cbData;
	DWORD cchData;
	rvEnum rvType = rvKeyPresent; // default to key detect, arg missing
	CVariant& var1 = args[1];
	if (var1.IsNumeric())
	{
		var1.GetInt(iRoot);
		if ((iRoot & 0x7FFFFFF0) != 0)
			return DISP_E_BADINDEX;
		hkeyRoot = (HKEY)(INT_PTR)(iRoot | (1<<31));            //!!merced: 4312 int to hkey
	}
	else
	{
		const WCHAR* szMachine;
		if ((iErr = var1.GetString(szMachine)) != S_OK)
			return iErr;
		TCHAR szServer[MAX_PATH];
		szServer[0] = szServer[1] = chRegSep;
		TCHAR* pch = szServer + 2;
		do
		{
			*pch++ = (TCHAR)*szMachine;
		} while (*szMachine++ != 0);
		if ((iErr = W32::RegConnectRegistry(szServer, HKEY_LOCAL_MACHINE, &hkeyRoot)) != ERROR_SUCCESS)
			return iErr;
	}
	if ((iErr = args[2].GetString(szKey)) != S_OK)
		return iErr;
	if (args.Present(3))
	{
		CVariant& var3 = args[3];
		rvType = rvGetValue;
		if (var3.IsNull())
			szValue = 0;
		else if (var3.IsNumeric())
		{
			var3.GetInt(iValueName);
			if (iValueName == 0)
				rvType = rvGetClass;
			else if (iValueName > 0)
			{
				rvType = rvEnumValue;
				iValueName--;
			}
			else
			{
				rvType = rvEnumKey;
				iValueName = ~iValueName;
			}
		}
		else if ((iErr = var3.GetString(szValue)) != S_OK)
			return iErr;
	}
#ifndef UNICODE
	char rgbBuf[256];
	if (g_fWin9X)
	{
		char* pchKey = (char*)rgbBuf;
		unsigned int cb = W32::WideCharToMultiByte(CP_ACP, 0, szKey, -1, 0, 0, 0, 0);
		if (cb > sizeof(rgbBuf))
			pchKey = new char[cb];
		if ( ! pchKey )
			return E_OUTOFMEMORY;
		W32::WideCharToMultiByte(CP_ACP, 0, szKey, -1, pchKey, cb, 0, 0);
		iErr = W32::RegOpenKeyExA(hkeyRoot, pchKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkey);
		if (pchKey != rgbBuf)
			delete pchKey;
	}
	else
#endif
		iErr = W32::RegOpenKeyExW(hkeyRoot, szKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkey);
	if (rvType == rvKeyPresent)
	{
		args.Assign(iErr == S_OK ? fTrue : fFalse);
		return S_OK;
	}
	if (iErr != ERROR_SUCCESS)
		return DISP_E_BADINDEX;
	pbVal = rgbValBuf;
	Bool fDataInBuf = fFalse;
	const WCHAR* szReturn = 0;
#ifndef UNICODE
	if (g_fWin9X)
		cchData = sizeof(rgbValBuf)/sizeof(char);
	else
#endif
		cchData = sizeof(rgbValBuf)/sizeof(WCHAR);
	if (rvType == rvGetClass)
	{
#ifndef UNICODE
		if (g_fWin9X)
			iErr = W32::RegQueryInfoKeyA(hkey, (char*)pbVal, &cchData, 0, 0, 0, 0, 0 ,0, 0, 0, 0);
		else
#endif
			iErr = W32::RegQueryInfoKeyW(hkey, (WCHAR*)pbVal, &cchData, 0, 0, 0, 0, 0 ,0, 0, 0, 0);
		if (iErr != ERROR_SUCCESS)
		{
			if (cchData == 0)  // internal OS error, ignore if no class data: ERROR_INSUFFICIENT_BUFFER
				*((WCHAR*)(pbVal)) = 0;
			else
				return DISP_E_BADINDEX;
		}
		fDataInBuf = fTrue;
   }
	else if (rvType == rvEnumValue)
	{
#ifndef UNICODE
		if (g_fWin9X)
		{
			do
			{
				iErr = W32::RegEnumValueA(hkey, iValueName, (char*)rgbValBuf, &cchData, 0, &iValueType, 0, 0);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = (BYTE*)new char[cchData]) != 0);
		}
		else
#endif
		{
			do
			{
				iErr = W32::RegEnumValueW(hkey, iValueName, (WCHAR*)pbVal, &cchData, 0, &iValueType, 0, 0);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = (BYTE*)new WCHAR[cchData]) != 0);
		}
		if (iErr == ERROR_NO_MORE_ITEMS)
			args.Assign(fVoid);
		else if (iErr != ERROR_SUCCESS)
			return iErr;
		else
			fDataInBuf = fTrue;
   }
	else if (rvType == rvEnumKey)
	{
#ifndef UNICODE
		if (g_fWin9X)
			iErr = W32::RegEnumKeyExA(hkey, iValueName, (char*)rgbValBuf, &cchData, 0, 0, 0, 0);
		else
#endif
			iErr = W32::RegEnumKeyExW(hkey, iValueName, (WCHAR*)rgbValBuf, &cchData, 0, 0, 0, 0);
		if (iErr == ERROR_NO_MORE_ITEMS)
			args.Assign(fVoid);
		else if (iErr != ERROR_SUCCESS)
			return iErr; // shouldn't happen
		else
			fDataInBuf = fTrue;
	}
	else // rvType == rvGetValue
	{
		cbData = sizeof(rgbValBuf);
#ifndef UNICODE
		if (g_fWin9X)
		{
			char* pchValue = (char*)rgbBuf;
			unsigned int cb = W32::WideCharToMultiByte(CP_ACP, 0, szValue, -1, 0, 0, 0, 0);
			if (cb > sizeof(rgbBuf))
				pchValue = new char[cb];
			W32::WideCharToMultiByte(CP_ACP, 0, szValue, -1, pchValue, cb, 0, 0);
			do
			{
				iErr = W32::RegQueryValueExA(hkey, pchValue, 0, &iValueType, pbVal, &cbData);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = new BYTE[cbData]) != 0);
			if (pchValue != rgbBuf)
				delete pchValue;
		}
		else
#endif
		{
			do
			{
				iErr = W32::RegQueryValueExW(hkey, szValue, 0, &iValueType, pbVal, &cbData);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = new BYTE[cbData]) != 0);
		}
		if (iErr != ERROR_SUCCESS)
		{
			if (szValue != 0)
				return DISP_E_BADINDEX;
			else
				iValueType = REG_NONE;
		}
		switch(iValueType)
		{
		case REG_EXPAND_SZ:
		{
			WCHAR* szExpand = rgchExpandBuf;
#ifndef UNICODE
			if (g_fWin9X)
			{
				cchData = sizeof(rgchExpandBuf);
				do
				{
					cchData = W32::ExpandEnvironmentStringsA((const char*)pbVal, (char*)szExpand, cchData);
				} while (cchData > sizeof(rgchExpandBuf) && szExpand == rgchExpandBuf && (szExpand = (WCHAR*)new char[cchData]) != 0);
			}
			else
#endif
			{
				cchData = sizeof(rgchExpandBuf)/sizeof(WCHAR);
				do
				{
					cchData = W32::ExpandEnvironmentStringsW((const WCHAR*)pbVal, szExpand, cchData);
				} while (cchData > sizeof(rgchExpandBuf)/sizeof(WCHAR) && szExpand == rgchExpandBuf && (szExpand = new WCHAR[cchData]) != 0);
			}
			if (pbVal != rgbValBuf)
				delete pbVal;
			pbVal = (BYTE*)szExpand;
			fDataInBuf = fTrue;
			break;
		}
		case REG_MULTI_SZ:
#ifndef UNICODE
			if (g_fWin9X)
			{
				int cch = cbData;
				for (char* pch = (char*)pbVal; cch-- > 2; pch++)
					if (*pch == 0)
						*pch = '\n';
			}
			else
#endif
			{
				int cch = cbData/sizeof(WCHAR);
				for (WCHAR* pch = (WCHAR*)pbVal; cch-- > 2; pch++)
					if (*pch == 0)
						*pch = '\n';
			}
			fDataInBuf = fTrue;
			break;
		case REG_NONE:                       args.Assign(fVoid); break;
		case REG_DWORD:                      args.Assign(*(int*)pbVal); break; // same as REG_DWORD_LITTLE_ENDIAN
		case REG_SZ:                         fDataInBuf = fTrue; break;
		case REG_RESOURCE_LIST:              szReturn = L"(REG_RESOURCE_LIST)"; break;
		case REG_RESOURCE_REQUIREMENTS_LIST: szReturn = L"(REG_RESOURCE_REQUIREMENTS_LIST)"; break;
		case REG_FULL_RESOURCE_DESCRIPTOR:   szReturn = L"(REG_FULL_RESOURCE_DESCRIPTOR)"; break;
		case REG_LINK:                       szReturn = L"(REG_LINK)"; break;
		case REG_DWORD_BIG_ENDIAN:           szReturn = L"(REG_DWORD_BIG_ENDIAN)"; break;
		case REG_BINARY:                     szReturn = L"(REG_BINARY)"; break;
		default:                             szReturn = L"(REG_??)"; break;
		}
	}
	if (fDataInBuf)
	{
#ifndef UNICODE
		if (g_fWin9X)
			args.Assign((char*)pbVal);
		else
#endif
			args.Assign((WCHAR*)pbVal);
	}
	else if (szReturn != 0)
		args.Assign(szReturn);
	if (pbVal != rgbValBuf && pbVal != (BYTE*)rgchExpandBuf)
		delete pbVal;
	return S_OK;
}

DISPERR CAutoInstall::FileAttributes(CAutoArgs& args)
{
	DISPERR iErr;
	int iAttr;
	const WCHAR* szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;
#ifndef UNICODE
	if (g_fWin9X)
	{
		char rgchPath[1024];
		W32::WideCharToMultiByte(CP_ACP, 0, szPath, -1, rgchPath, sizeof(rgchPath), 0, 0);
		iAttr = W32::GetFileAttributesA(rgchPath);
	}
	else
#endif
		iAttr = W32::GetFileAttributesW(szPath);
	args.Assign(iAttr);
	return S_OK;
}

DISPERR CAutoInstall::FileSize(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr;
	const WCHAR* szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;

	// open the file specified
	HANDLE hFile;
#ifndef UNICODE
	if (g_fWin9X)
	{
		char rgchPath[1024];
		W32::WideCharToMultiByte(CP_ACP, 0, szPath, -1, rgchPath, sizeof(rgchPath), 0, 0);
		hFile = W32::CreateFileA(rgchPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	}
	else
#endif
		hFile = W32::CreateFileW(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	
	// if failed to open the file bail
	if (hFile == INVALID_HANDLE_VALUE)
		return W32::GetLastError();

	// get the file size and close the file
	DWORD cbFile = W32::GetFileSize(hFile, 0);
	DWORD dwError = W32::GetLastError();
	W32::CloseHandle(hFile);

	// if there was an error reading the file size bail
	if (cbFile == 0xFFFFFFFF)
		return dwError;

	// return the file size
	args.Assign(cbFile);
	return S_OK;
}   // end of FileSize

DISPERR CAutoInstall::FileVersion(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr;
	WCHAR* szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;
	Bool fLang = fFalse;    
	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	if (args.Present(2) && (iErr = args[2].GetBool(fLang)) != S_OK)
		return iErr;
	do
		if (fLang)
			iErr = MsiGetFileVersionW(szPath, 0, 0, bResult, &dwSize);
		else
			iErr = MsiGetFileVersionW(szPath, bResult, &dwSize, 0, 0);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr == NOERROR)
		args.Assign((const WCHAR* )bResult);
	else if (iErr != ERROR_FILE_INVALID)
		return iErr;
	return S_OK;
}   // end of FileVersion

DISPERR CAutoInstall::FileHash(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr;
	WCHAR* szPath;
	DWORD dwOptions = 0;
	DWORD dwPart    = 0;

	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;

	if ((iErr = args[2].GetInt(dwOptions)) != S_OK)
		return iErr;

	MSIFILEHASHINFO sHash;
	memset(&sHash, 0, sizeof(sHash));
	BOOL fHashSet = FALSE;

	sHash.dwFileHashInfoSize = sizeof(MSIFILEHASHINFO);
	iErr = MsiGetFileHashW(szPath, dwOptions, &sHash);

	if (iErr != NOERROR)
		return iErr;
	
	MSIHANDLE pRec = MsiCreateRecord(4);

	if (pRec == 0)
		return DISP_E_TYPEMISMATCH;

	MsiRecordSetInteger(pRec, 1, sHash.dwData[0]);
	MsiRecordSetInteger(pRec, 2, sHash.dwData[1]);
	MsiRecordSetInteger(pRec, 3, sHash.dwData[2]);
	MsiRecordSetInteger(pRec, 4, sHash.dwData[3]);
	return args.Assign(new CAutoRecord(pRec));

}   // end of FileHash

DISPERR CAutoInstall::FileSignatureInfo(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr = S_OK;
	WCHAR* szPath = NULL;
	DWORD  dwOptions = 0;
	unsigned int uiFormat = 0;
	unsigned int cb       = 0;

	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;

	if ((iErr = args[2].GetInt(dwOptions)) != S_OK)
		return iErr;

	if ((iErr = args[3].GetInt(uiFormat)) != S_OK)
		return iErr;

	PCCERT_CONTEXT pcCert = NULL;
	CTempBuffer<BYTE, 256> bHash;
	HRESULT hr = S_OK;
	DWORD dwSize = 0;

	switch (uiFormat)
	{
	case 0: // certificate
		{
			hr = MsiGetFileSignatureInformationW(szPath, dwOptions, &pcCert, NULL, NULL);
			if (pcCert)
				dwSize = pcCert->cbCertEncoded;
			break;
		}
	case 1: // hash
		{
			dwSize = bHash.GetSize();
			
			do
			{
				hr = MsiGetFileSignatureInformationW(szPath, dwOptions, &pcCert, bHash, &dwSize);
			}
			while (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA) && (bHash.SetSize(++dwSize), true));
			
			break;
		}
	default: // shouldn't be here!
		return E_INVALIDARG;
	}

	if (S_OK != hr || !pcCert || !pcCert->pbCertEncoded)
		return HRESULT_FROM_WIN32(hr);

	SAFEARRAYBOUND saBound[1];
	saBound[0].lLbound = 0;
	saBound[0].cElements = dwSize;

	VARIANT *pvar = args.ResultVariant();
	pvar->vt = VT_UI1 | VT_ARRAY;
	pvar->parray = OLEAUT32::SafeArrayCreate(VT_UI1, 1, saBound);
	if (!pvar->parray)
	{
		CRYPT32::CertFreeCertificateContext(pcCert);
		return E_OUTOFMEMORY; // allocation failed
	}

	unsigned char FAR *pc = NULL;   
	if (S_OK != (hr = OLEAUT32::SafeArrayAccessData(pvar->parray, (void HUGEP* FAR*)&pc)) || !pc)
	{
		CRYPT32::CertFreeCertificateContext(pcCert);
		return (!pc) ? E_FAIL : hr;
	}
	memcpy(pc, (uiFormat == 0) ? pcCert->pbCertEncoded : bHash, dwSize);
	if (S_OK != (hr = OLEAUT32::SafeArrayUnaccessData(pvar->parray)))
	{
		CRYPT32::CertFreeCertificateContext(pcCert);
		return hr;
	}

	// must release certificate context
	if (pcCert)
		CRYPT32::CertFreeCertificateContext(pcCert);

	return S_OK;

}   // end of FileSignatureInfo

DISPERR CAutoInstall::Environment(CAutoArgs& args)
{
	DISPERR iErr;
	WCHAR rgchBuf[1024];
	rgchBuf[0] = 0;
	const WCHAR* szName;
	const WCHAR* szValue = 0;
	if ((iErr = args[1].GetString(szName)) != S_OK)
		return iErr;
	if (args.PropertySet() && args[0].GetType() != VT_EMPTY && (iErr = args[0].GetString(szValue)) != S_OK)
		return iErr;
#ifndef UNICODE
	if (g_fWin9X)
	{
		char rgchName[256];
		W32::WideCharToMultiByte(CP_ACP, 0, szName, -1, rgchName, sizeof(rgchName), 0, 0);
		if (args.PropertySet())
		{
			W32::WideCharToMultiByte(CP_ACP, 0, szValue, -1, (char*)rgchBuf, sizeof(rgchBuf), 0, 0);
			if (!W32::SetEnvironmentVariableA(rgchName, (char*)rgchBuf))
				return DISP_E_BADINDEX;
		}
		else
		{
			W32::GetEnvironmentVariableA(rgchName, (char*)rgchBuf, sizeof(rgchBuf));
			args.Assign((char*)rgchBuf);
		}
	}
	else
#endif
	{
		if (args.PropertySet())
		{
			if (!W32::SetEnvironmentVariableW(szName, szValue))
				return DISP_E_BADINDEX;
		}
		else
		{
			W32::GetEnvironmentVariableW(szName, rgchBuf, sizeof(rgchBuf)/sizeof(WCHAR));
			args.Assign(rgchBuf);
		}
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CAutoRecord automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoRecord> AutoRecordTable[] = {
  DISPID_MsiRecord_FieldCount , HELPID_MsiRecord_FieldCount , aafPropRO, CAutoRecord::FieldCount, L"FieldCount",
  DISPID_MsiRecord_StringData , HELPID_MsiRecord_StringData , aafPropRW, CAutoRecord::StringData, L"StringData,Field",
  DISPID_MsiRecord_IntegerData, HELPID_MsiRecord_IntegerData, aafPropRW, CAutoRecord::IntegerData,L"IntegerData,Field",
  DISPID_MsiRecord_SetStream  , HELPID_MsiRecord_SetStream  , aafMethod, CAutoRecord::SetStream,  L"SetStream,Field,FilePath",
  DISPID_MsiRecord_ReadStream , HELPID_MsiRecord_ReadStream , aafMethod, CAutoRecord::ReadStream, L"ReadStream,Field,Length,Format",
  DISPID_MsiRecord_DataSize   , HELPID_MsiRecord_DataSize   , aafPropRO, CAutoRecord::DataSize,   L"DataSize,Field",
  DISPID_MsiRecord_IsNull     , HELPID_MsiRecord_IsNull     , aafPropRO, CAutoRecord::IsNull,     L"IsNull,Field",
  DISPID_MsiRecord_ClearData  , HELPID_MsiRecord_ClearData  , aafMethod, CAutoRecord::ClearData,  L"ClearData",
  DISPID_MsiRecord_FormatText , HELPID_MsiRecord_FormatText , aafMethod, CAutoRecord::FormatText, L"FormatText",
//DISPID_MsiRecord_SetNull    , HELPID_MsiRecord_SetNull    , aafMethod, CAutoRecord::SetNull,    L"SetNull,Field",
  DISPID_MsiRecord_GetHandle  , 0                           , aafPropRO, CAutoRecord::GetHandle,  L"",
};
const int AutoRecordCount = sizeof(AutoRecordTable)/sizeof(DispatchEntryBase);

CAutoRecord::CAutoRecord(MSIHANDLE hRecord)
 : CAutoBase(*AutoRecordTable, AutoRecordCount, IID_IMsiApiRecord, hRecord)
{
}

DISPERR CAutoRecord::StringData(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		const WCHAR* szData = 0;
		if (var.GetType()!=VT_EMPTY && (iErr = var.GetString(szData)) != S_OK)
			return iErr;
		return MsiRecordSetStringW(m_hMsi, iField, szData);
	}
	else
	{
		CTempBuffer<WCHAR, 1024> bValue;
		DWORD dwSize = bValue.GetSize();
		do
			iErr = MsiRecordGetStringW(m_hMsi, iField, bValue, &dwSize);
		while (iErr == ERROR_MORE_DATA && (bValue.SetSize(++dwSize), true));
		return iErr == S_OK ? args.Assign((const WCHAR* )bValue) : iErr;
	}
}

DISPERR CAutoRecord::IntegerData(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	int iValue;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	if (!args.PropertySet())
		return args.Assign(MsiRecordGetInteger(m_hMsi, iField));
	else if ((iErr = args[0].GetInt(iValue)) != S_OK)
		return iErr;
	else
		return MsiRecordSetInteger(m_hMsi, iField, iValue);
}

DISPERR CAutoRecord::SetStream(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	const WCHAR* szData;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	if (!args.Present(2) || args[2].IsNull())
		szData = 0;  // request to reset stream
	else if ((iErr = args[2].GetString(szData)) != S_OK)
		return iErr;
	return MsiRecordSetStreamW(m_hMsi, iField, szData);
}

DISPERR CAutoRecord::ReadStream(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	unsigned int cb;
	unsigned int iFormat;
	if ((iErr = args[1].GetInt(iField)) != S_OK
	||  (iErr = args[2].GetInt(cb)) != S_OK
	||  (iErr = args[3].GetInt(iFormat)) != S_OK)
		return iErr;
	unsigned long cbData = cb;
	char* rgbBuffer = 0;
	char* pch;
	BSTR bstr = 0;
	int iData = 0;
	if (iFormat > 3)
		return DISP_E_BADINDEX;
	if (MsiRecordIsNull(m_hMsi, iField))
		return S_OK;   // null or non-existent field, variant is cleared to Empty
	// check errors and get remaining count, may resize count smaller, no data transfer
	if ((iErr = MsiRecordReadStream(m_hMsi, iField, 0, &cbData)) != ERROR_SUCCESS)
		return iErr;
	if (cbData == 0)
		return S_OK;   // no more bytes, variant is cleared to Empty
	if (cbData > cb)  // if more bytes available than requested
		cbData = cb;   // restore original count
	OLECHAR* pwch;
	int cwch;
	switch (iFormat)
	{
	case 0:
		if (cbData > 4)
			return DISP_E_BADINDEX;
		pch = (char*)&iData;
		MsiRecordReadStream(m_hMsi, iField, (char*)&iData, &cbData);  // assumes Intel byte ordering
		return args.Assign(iData);
	case 1:
		rgbBuffer = new char[cbData];  //FUTURE optimize to local buffer if not large
		MsiRecordReadStream(m_hMsi, iField, rgbBuffer, &cbData);
		bstr = OLEAUT32::SysAllocStringLen(0, cbData);
		for (pwch = bstr, pch = rgbBuffer, cb = cbData; cb--; )
			*pwch++ = *pch++;
		*pwch = 0;
		delete rgbBuffer;
		return args.ReturnBSTR(bstr);
	case 2:
		rgbBuffer = new char[cbData];
		MsiRecordReadStream(m_hMsi, iField, rgbBuffer, &cbData);
		cwch = W32::MultiByteToWideChar(CP_ACP, 0, rgbBuffer, cbData, 0, 0);
		bstr = OLEAUT32::SysAllocStringLen(0, cwch);
		W32::MultiByteToWideChar(CP_ACP, 0, rgbBuffer, cbData, bstr, cwch);
		bstr[cwch] = 0;
		delete rgbBuffer;
		return args.ReturnBSTR(bstr);
	case 3:
		bstr = OLEAUT32::SysAllocStringLen(0, (cbData+1)/2);
		MsiRecordReadStream(m_hMsi, iField, (char*)bstr, &cbData);
		if (cbData & 1)      // if odd byte count, pad last wide char
			((char*)bstr)[cbData] = 0;
		return args.ReturnBSTR(bstr);
	default: return S_OK; // can't happen
	}
}

DISPERR CAutoRecord::FieldCount(CAutoArgs& args)
{
	return args.Assign(MsiRecordGetFieldCount(m_hMsi));
}

DISPERR CAutoRecord::IsNull(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	return args.Assign((Bool)MsiRecordIsNull(m_hMsi, iField));
}

DISPERR CAutoRecord::DataSize(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	return args.Assign(MsiRecordDataSize(m_hMsi, iField));
}

DISPERR CAutoRecord::ClearData(CAutoArgs& /*args*/)
{
	return MsiRecordClearData(m_hMsi);
}

DISPERR CAutoRecord::FormatText(CAutoArgs& args)
{
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	DISPERR iErr;
	do
		iErr = MsiFormatRecordW(0, m_hMsi, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoRecord::GetHandle(CAutoArgs& args)
{
	return args.Assign((long)CAutoBase::GetHandle());
}


//____________________________________________________________________________
//
// CAutoDatabase implementation
//____________________________________________________________________________

DispatchEntry<CAutoDatabase> AutoDatabaseTable[] = {
  DISPID_MsiDatabase_DatabaseState     , HELPID_MsiDatabase_DatabaseState     , aafPropRO, CAutoDatabase::DatabaseState,      L"DatabaseState",
  DISPID_MsiDatabase_SummaryInformation, HELPID_MsiDatabase_SummaryInformation, aafPropRO, CAutoDatabase::SummaryInformation, L"SummaryInformation,UpdateCount",
  DISPID_MsiDatabase_OpenView          , HELPID_MsiDatabase_OpenView          , aafMethod, CAutoDatabase::OpenView,           L"OpenView,Sql",
  DISPID_MsiDatabase_Commit            , HELPID_MsiDatabase_Commit            , aafMethod, CAutoDatabase::Commit,             L"Commit",
  DISPID_MsiDatabase_PrimaryKeys       , HELPID_MsiDatabase_PrimaryKeys       , aafMethod, CAutoDatabase::PrimaryKeys,        L"PrimaryKeys,Table",
  DISPID_MsiDatabase_Import            , HELPID_MsiDatabase_Import            , aafMethod, CAutoDatabase::Import,             L"Import,Folder,File",
  DISPID_MsiDatabase_Export            , HELPID_MsiDatabase_Export            , aafMethod, CAutoDatabase::Export,             L"Export,Table,Folder,File",
  DISPID_MsiDatabase_Merge             , HELPID_MsiDatabase_Merge             , aafMethod, CAutoDatabase::Merge,              L"Merge,Database,ErrorTable",
  DISPID_MsiDatabase_GenerateTransform , HELPID_MsiDatabase_GenerateTransform , aafMethod, CAutoDatabase::GenerateTransform,  L"GenerateTransform,ReferenceDatabase,TransformFile",
  DISPID_MsiDatabase_ApplyTransform    , HELPID_MsiDatabase_ApplyTransform    , aafMethod, CAutoDatabase::ApplyTransform,     L"ApplyTransform,TransformFile,ErrorConditions",
  DISPID_MsiDatabase_EnableUIPreview   , HELPID_MsiDatabase_EnableUIPreview   , aafMethod, CAutoDatabase::EnableUIPreview,    L"EnableUIPreview",
  DISPID_MsiDatabase_TablePersistent   , HELPID_MsiDatabase_TablePersistent   , aafPropRO, CAutoDatabase::TablePersistent,    L"TablePersistent,Table",
  DISPID_MsiDatabase_CreateTransformSummaryInfo , HELPID_MsiDatabase_CreateTransformSummaryInfo , aafMethod, CAutoDatabase::CreateTransformSummaryInfo,  L"CreateTransformSummaryInfo,ReferenceDatabase,TransformFile,ErrorConditions,Validation",
  DISPID_MsiDatabase_GetHandle         , 0                                    , aafPropRO, CAutoDatabase::GetHandle,  L"",
};
const int AutoDatabaseCount = sizeof(AutoDatabaseTable)/sizeof(DispatchEntryBase);

CAutoDatabase::CAutoDatabase(MSIHANDLE hDatabase)
 : CAutoBase(*AutoDatabaseTable, AutoDatabaseCount, IID_IMsiApiDatabase, hDatabase)
{
}

DISPERR CAutoDatabase::OpenView(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szQuery;
	if ((iErr = args[1].GetString(szQuery)) != S_OK)
		return iErr;
	MSIHANDLE hView;
	if ((iErr = MsiDatabaseOpenViewW(m_hMsi, szQuery, &hView)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoView(hView));
}

DISPERR CAutoDatabase::PrimaryKeys(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable;
	if ((iErr = args[1].GetString(szTable)) != S_OK)
		return iErr;
	MSIHANDLE hRecord;
	if ((iErr = MsiDatabaseGetPrimaryKeysW(m_hMsi, szTable, &hRecord)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoRecord(hRecord));
}

DISPERR CAutoDatabase::Import(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szFolder;
	const WCHAR* szFile;
	if ((iErr = args[1].GetString(szFolder)) != S_OK
	||  (iErr = args[2].GetString(szFile)) != S_OK)
		return iErr;
	return MsiDatabaseImportW(m_hMsi, szFolder, szFile);
}

DISPERR CAutoDatabase::Export(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable;
	const WCHAR* szFolder;
	const WCHAR* szFile;
	if ((iErr = args[1].GetString(szTable)) != S_OK
	||  (iErr = args[2].GetString(szFolder)) != S_OK
	||  (iErr = args[3].GetString(szFile)) != S_OK)
		return iErr;
	return MsiDatabaseExportW(m_hMsi, szTable, szFolder, szFile);
}

DISPERR CAutoDatabase::Merge(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable = 0;
	if (args.Present(2) && (iErr = args[2].GetString(szTable)) != S_OK)
		return iErr;
	iErr = MsiDatabaseMergeW(m_hMsi, args[1].GetHandle(IID_IMsiApiDatabase), szTable);
	if (iErr == ERROR_FUNCTION_FAILED) // merge completed, but conflicts were found
		return args.Assign(fTrue);
	else if (iErr == ERROR_SUCCESS)    // no conflicts found
		return args.Assign(fFalse);
	else                               // other error, such as schema mismatch
		return iErr;
}

DISPERR CAutoDatabase::GenerateTransform(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTransformFile = 0;
	if (args.Present(2) && (iErr = args[2].GetString(szTransformFile)) != S_OK)
		return iErr;
	iErr = MsiDatabaseGenerateTransformW(m_hMsi, args[1].GetHandle(IID_IMsiApiDatabase), szTransformFile, 0, 0);
	if (iErr == NOERROR)
		return args.Assign(fTrue);
	if (iErr == ERROR_NO_DATA)
		return args.Assign(fFalse);
	return iErr;
}

DISPERR CAutoDatabase::CreateTransformSummaryInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTransformFile;
	int iErrorConditions;
	int iValidation;
	if ((iErr = args[2].GetString(szTransformFile)) != S_OK
	||  (iErr = args[3].GetInt(iErrorConditions)) != S_OK
	||  (iErr = args[4].GetInt(iValidation)) != S_OK)
		return iErr;
	return MsiCreateTransformSummaryInfoW(m_hMsi, args[1].GetHandle(IID_IMsiApiDatabase), szTransformFile, iErrorConditions, iValidation);
}

DISPERR CAutoDatabase::ApplyTransform(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTransformFile;
	int iErrorConditions;
	if ((iErr = args[1].GetString(szTransformFile)) != S_OK
	||  (iErr = args[2].GetInt(iErrorConditions)) != S_OK)
		return iErr;
	return MsiDatabaseApplyTransformW(m_hMsi, szTransformFile, iErrorConditions);
}

DISPERR CAutoDatabase::Commit(CAutoArgs& /*args*/)
{
	return MsiDatabaseCommit(m_hMsi);
}

DISPERR CAutoDatabase::DatabaseState(CAutoArgs& args)
{
	return args.Assign((int)MsiGetDatabaseState(m_hMsi));
}

DISPERR CAutoDatabase::SummaryInformation(CAutoArgs& args)
{
	DISPERR iErr;
	MSIHANDLE hSummaryInfo;
	UINT cUpdate = 0;
	if (args.Present(1) && (iErr = args[1].GetInt(cUpdate)) != S_OK)
		return iErr;
	if ((iErr = MsiGetSummaryInformationW(m_hMsi, 0, cUpdate, &hSummaryInfo)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoSummaryInfo(hSummaryInfo));
}

DISPERR CAutoDatabase::EnableUIPreview(CAutoArgs& args)
{
	DISPERR iErr;
	MSIHANDLE hPreview;
	if ((iErr = MsiEnableUIPreview(m_hMsi, &hPreview)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoUIPreview(hPreview));
}

DISPERR CAutoDatabase::TablePersistent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable;
	if ((iErr = args[1].GetString(szTable)) != S_OK)
		return iErr;
	return args.Assign((int)MsiDatabaseIsTablePersistentW(m_hMsi, szTable));
}

DISPERR CAutoDatabase::GetHandle(CAutoArgs& args)
{
	return args.Assign((long)CAutoBase::GetHandle());
}

//____________________________________________________________________________
//
// CAutoView automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoView> AutoViewTable[] = {
  DISPID_MsiView_Execute   , HELPID_MsiView_Execute   , aafMethod, CAutoView::Execute ,  L"Execute,Params",
  DISPID_MsiView_Fetch     , HELPID_MsiView_Fetch     , aafMethod, CAutoView::Fetch   ,  L"Fetch",
  DISPID_MsiView_Modify    , HELPID_MsiView_Modify    , aafMethod, CAutoView::Modify  ,  L"Modify,Mode,Record",
  DISPID_MsiView_ColumnInfo, HELPID_MsiView_ColumnInfo, aafPropRO, CAutoView::ColumnInfo,L"ColumnInfo,Info",
  DISPID_MsiView_Close     , HELPID_MsiView_Close     , aafMethod, CAutoView::Close   ,  L"Close",
  DISPID_MsiView_GetError  , HELPID_MsiView_GetError  , aafMethod, CAutoView::GetError,  L"GetError",
};
const int AutoViewCount = sizeof(AutoViewTable)/sizeof(DispatchEntryBase);

CAutoView::CAutoView(MSIHANDLE hView)
 : CAutoBase(*AutoViewTable, AutoViewCount, IID_IMsiApiView, hView)
{
}

DISPERR CAutoView::Execute(CAutoArgs& args)
{
	MSIHANDLE hRecord = 0;
	if (args.Present(1))
		hRecord = args[1].GetHandle(IID_IMsiApiRecord);
	return MsiViewExecute(m_hMsi, hRecord);
}

DISPERR CAutoView::Fetch(CAutoArgs& args)
{
	MSIHANDLE hRecord;
	IDispatch* piDispatch;
	DISPERR iErr = MsiViewFetch(m_hMsi, &hRecord);
	if (iErr == ERROR_NO_MORE_ITEMS)
		piDispatch = 0;
	else if (iErr == ERROR_SUCCESS)
		piDispatch = new CAutoRecord(hRecord);
	else
		return iErr;
	return args.Assign(piDispatch);
}

DISPERR CAutoView::Modify(CAutoArgs& args)
{
	DISPERR iErr;
	int iMode;
	if ((iErr = args[1].GetInt(iMode)) != S_OK)
		return iErr;
	return MsiViewModify(m_hMsi, (MSIMODIFY)iMode, args[2].GetHandle(IID_IMsiApiRecord));
}

DISPERR CAutoView::ColumnInfo(CAutoArgs& args)
{
	DISPERR iErr;
	int iMode;
	MSIHANDLE hRecord;
	if ((iErr = args[1].GetInt(iMode)) != S_OK
	||  (iErr = MsiViewGetColumnInfo(m_hMsi, (MSICOLINFO)iMode, &hRecord)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoRecord(hRecord));
}

DISPERR CAutoView::Close(CAutoArgs& /*args*/)
{
	return MsiViewClose(m_hMsi);
}

const int cchColumnNameMax = 64;
DISPERR CAutoView::GetError(CAutoArgs& args)
{
	CTempBuffer<WCHAR, cchColumnNameMax+2> bColumn;
	DWORD dwSize = bColumn.GetSize();
	MSIDBERROR iError;
	do
	{
		dwSize-= 2;// extra work to pack two digits into buffer
		iError = MsiViewGetErrorW(m_hMsi, (WCHAR*)bColumn + 2, &dwSize);
		dwSize += 2; // in case of overflow, need extra space for digits
	} while (iError == MSIDBERROR_MOREDATA && (bColumn.SetSize(++dwSize), true));
	if (iError == MSIDBERROR_FUNCTIONERROR)
		return E_FAIL;
	if (iError == MSIDBERROR_INVALIDARG)
		return DISP_E_BADINDEX;
	bColumn[0] = (WCHAR)(iError/10 + '0');
	bColumn[1] = (WCHAR)(iError%10 + '0');
	return args.Assign((const WCHAR* )bColumn);
}

//____________________________________________________________________________
//
// CAutoSummaryInfo automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoSummaryInfo> AutoSummaryInfoTable[] = {
  DISPID_MsiSummaryInfo_Property     , HELPID_MsiSummaryInfo_Property     , aafPropRW, CAutoSummaryInfo::Property,      L"Property,Pid",
  DISPID_MsiSummaryInfo_PropertyCount, HELPID_MsiSummaryInfo_PropertyCount, aafPropRO, CAutoSummaryInfo::PropertyCount, L"PropertyCount",
  DISPID_MsiSummaryInfo_Persist      , HELPID_MsiSummaryInfo_Persist      , aafMethod, CAutoSummaryInfo::Persist,       L"Persist",
};
const int AutoSummaryInfoCount = sizeof(AutoSummaryInfoTable)/sizeof(DispatchEntryBase);

CAutoSummaryInfo::CAutoSummaryInfo(MSIHANDLE hSummaryInfo)
 : CAutoBase(*AutoSummaryInfoTable, AutoSummaryInfoCount, IID_IMsiApiSummaryInfo, hSummaryInfo)
{
}

#if 0  // Win32 time conversion APIs
INT  WINAPI SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, double *pvtime);
INT  WINAPI VariantTimeToSystemTime(double vtime, LPSYSTEMTIME lpSystemTime);
INT  WINAPI DosDateTimeToVariantTime(USHORT wDosDate, USHORT wDosTime, double * pvtime);
INT  WINAPI VariantTimeToDosDateTime(double vtime, USHORT * pwDosDate, USHORT * pwDosTime);
BOOL WINAPI CoFileTimeToDosDateTime(FILETIME *lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
BOOL WINAPI CoDosDateTimeToFileTime(WORD nDosDate, WORD nDosTime, FILETIME *lpFileTime);
BOOL WINAPI SystemTimeToFileTime(CONST SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
BOOL WINAPI FileTimeToLocalFileTime(CONST FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
BOOL WINAPI LocalFileTimeToFileTime(CONST FILETIME *lpLocalFileTime, LPFILETIME lpFileTime);
BOOL WINAPI FileTimeToSystemTime(CONST FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
BOOL WINAPI FileTimeToDosDateTime(CONST FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime);
BOOL WINAPI DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime);
#endif

static DISPERR VariantTimeToFileTime(double vtime, FILETIME* pfiletime)
{
	SYSTEMTIME stime;
	FILETIME ftime;
	if (!OLEAUT32::VariantTimeToSystemTime(vtime, &stime)
	||   !W32::SystemTimeToFileTime(&stime, &ftime)
	||   !W32::LocalFileTimeToFileTime(&ftime, pfiletime))
		return DISP_E_TYPEMISMATCH;
	return S_OK;
}

static DISPERR FileTimeToVariantTime(FILETIME* pfiletime, double* pvtime)
{
	SYSTEMTIME stime;
	FILETIME ftime;
	if (!W32::FileTimeToLocalFileTime(pfiletime, &ftime)
	||   !W32::FileTimeToSystemTime(&ftime, &stime)
	||   !OLEAUT32::SystemTimeToVariantTime(&stime, pvtime))
		return DISP_E_TYPEMISMATCH;
	return S_OK;
}

DISPERR CAutoSummaryInfo::Property(CAutoArgs& args)
{
	DISPERR iErr;
	UINT iProperty;
	if ((iErr = args[1].GetInt(iProperty)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		UINT iDataType = var.GetType();
		int  iValue = 0;
		FILETIME ftValue;
		WCHAR* szValue = NULL;
		switch (iDataType)
		{
		case VT_EMPTY:           break;
		case VT_I4:              iValue = var.lVal;       break;
		case VT_I4 | VT_BYREF:   iValue = *var.plVal;     break;
		case VT_I2:              iValue = var.iVal;       iDataType = VT_I4;    break;
		case VT_I2 | VT_BYREF:   iValue = *var.piVal;     iDataType = VT_I4;    break;
		case VT_BSTR:            szValue = var.bstrVal;   iDataType = VT_LPSTR; break;
		case VT_BSTR | VT_BYREF: szValue = *var.pbstrVal; iDataType = VT_LPSTR; break;
		case VT_R8:
		case VT_DATE:            VariantTimeToFileTime(var.dblVal, &ftValue);   iDataType = VT_FILETIME; break;
		case VT_R8 | VT_BYREF:
		case VT_DATE | VT_BYREF: VariantTimeToFileTime(*var.pdblVal, &ftValue); iDataType = VT_FILETIME; break;
		default: return DISP_E_TYPEMISMATCH;
		};
		return MsiSummaryInfoSetPropertyW(m_hMsi, iProperty, iDataType, iValue, &ftValue, szValue);
	}
	else
	{
		UINT iDataType;
		FILETIME ftValue;
		double vtime;
		int iValue;
		WCHAR rgchValueBuf[MAX_PATH];
		DWORD cchValue = MAX_PATH;
		if ((iErr = MsiSummaryInfoGetPropertyW(m_hMsi, iProperty, &iDataType, &iValue, &ftValue, rgchValueBuf, &cchValue)) != ERROR_SUCCESS)
			return iErr;
		switch (iDataType)
		{
		case VT_I2:
		case VT_I4:       return args.Assign(iValue);
		case VT_LPSTR:    return args.Assign(rgchValueBuf);
		case VT_FILETIME: FileTimeToVariantTime(&ftValue, &vtime); return args.Assign(vtime);
		case VT_EMPTY:    return S_OK;   // variant already set to VT_EMPTY;
		default:          return E_FAIL; // shouldn't happen
		};
	}
}

DISPERR CAutoSummaryInfo::PropertyCount(CAutoArgs& args)
{
	DISPERR iErr;
	UINT cProperties;
	if ((iErr = MsiSummaryInfoGetPropertyCount(m_hMsi, &cProperties)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(cProperties);
}

DISPERR CAutoSummaryInfo::Persist(CAutoArgs& /*args*/)
{
	return MsiSummaryInfoPersist(m_hMsi);
}

//____________________________________________________________________________
//
// CAutoEngine automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoEngine> AutoEngineTable[] = {
  DISPID_MsiEngine_Application          , HELPID_MsiEngine_Application          , aafPropRO, CAutoEngine::Application          , L"Installer",
  DISPID_MsiEngine_Property             , HELPID_MsiEngine_Property             , aafPropRW, CAutoEngine::Property             , L"Property,Name",
  DISPID_MsiEngine_Language             , HELPID_MsiEngine_Language             , aafPropRO, CAutoEngine::Language             , L"Language",
  DISPID_MsiEngine_Mode                 , HELPID_MsiEngine_Mode                 , aafPropRW, CAutoEngine::Mode                 , L"Mode,Flag",
  DISPID_MsiEngine_Database             , HELPID_MsiEngine_Database             , aafPropRO, CAutoEngine::Database             , L"Database",
  DISPID_MsiEngine_SourcePath           , HELPID_MsiEngine_SourcePath           , aafPropRO, CAutoEngine::SourcePath           , L"SourcePath,Folder",
  DISPID_MsiEngine_TargetPath           , HELPID_MsiEngine_TargetPath           , aafPropRW, CAutoEngine::TargetPath           , L"TargetPath,Folder",
  DISPID_MsiEngine_DoAction             , HELPID_MsiEngine_DoAction             , aafMethod, CAutoEngine::DoAction             , L"DoAction,Action",
  DISPID_MsiEngine_Sequence             , HELPID_MsiEngine_Sequence             , aafMethod, CAutoEngine::Sequence             , L"Sequence,Table,Mode",
  DISPID_MsiEngine_EvaluateCondition    , HELPID_MsiEngine_EvaluateCondition    , aafMethod, CAutoEngine::EvaluateCondition    , L"EvaluateCondition,Expression",
  DISPID_MsiEngine_FormatRecord         , HELPID_MsiEngine_FormatRecord         , aafMethod, CAutoEngine::FormatRecord         , L"FormatRecord,Record",
  DISPID_MsiEngine_Message              , HELPID_MsiEngine_Message              , aafMethod, CAutoEngine::Message              , L"Message,Kind,Record",
  DISPID_MsiEngine_FeatureCurrentState  , HELPID_MsiEngine_FeatureCurrentState  , aafPropRO, CAutoEngine::FeatureCurrentState  , L"FeatureCurrentState,Feature",
  DISPID_MsiEngine_FeatureRequestState  , HELPID_MsiEngine_FeatureRequestState  , aafPropRW, CAutoEngine::FeatureRequestState  , L"FeatureRequestState,Feature",
  DISPID_MsiEngine_FeatureValidStates   , HELPID_MsiEngine_FeatureValidStates   , aafPropRO, CAutoEngine::FeatureValidStates   , L"FeatureValidStates,Feature",
  DISPID_MsiEngine_FeatureCost          , HELPID_MsiEngine_FeatureCost          , aafPropRO, CAutoEngine::FeatureCost          , L"FeatureCost,Feature,CostTree,State",
  DISPID_MsiEngine_ComponentCurrentState, HELPID_MsiEngine_ComponentCurrentState, aafPropRO, CAutoEngine::ComponentCurrentState, L"ComponentCurrentState,Component",
  DISPID_MsiEngine_ComponentRequestState, HELPID_MsiEngine_ComponentRequestState, aafPropRW, CAutoEngine::ComponentRequestState, L"ComponentRequestState,Component",
  DISPID_MsiEngine_SetInstallLevel      , HELPID_MsiEngine_SetInstallLevel      , aafMethod, CAutoEngine::SetInstallLevel      , L"SetInstallLevel,Level",
  DISPID_MsiEngine_VerifyDiskSpace      , HELPID_MsiEngine_VerifyDiskSpace      , aafPropRO, CAutoEngine::VerifyDiskSpace      , L"VerifyDiskSpace",
  DISPID_MsiEngine_ProductProperty      , HELPID_MsiEngine_ProductProperty      , aafPropRO, CAutoEngine::ProductProperty      , L"ProductProperty,Property",
  DISPID_MsiEngine_FeatureInfo          , HELPID_MsiEngine_FeatureInfo          , aafPropRO, CAutoEngine::FeatureInfo          , L"FeatureInfo,Feature",
  DISPID_MsiEngine_ComponentCosts       , HELPID_MsiEngine_ComponentCosts       , aafPropRO, CAutoEngine::ComponentCosts       , L"ComponentCosts,Component,State",
};
const int AutoEngineCount = sizeof(AutoEngineTable)/sizeof(DispatchEntryBase);

#ifdef INTERNAL
IDispatch* CreateAutoEngine(MSIHANDLE hEngine)
{
	CAutoInstall* piInstaller = CreateAutoInstall();
	CAutoEngine*  piAutoEngine = new CAutoEngine(hEngine, piInstaller);
	piInstaller->Release();
	return piAutoEngine;
}
#endif // INTERNAL

CAutoEngine::CAutoEngine(MSIHANDLE hEngine, CAutoInstall* piInstaller)
 : m_piInstaller(piInstaller), m_dwThreadId(0)
 , CAutoBase(*AutoEngineTable, AutoEngineCount, IID_IMsiApiEngine, hEngine)
{
	piInstaller->AddRef();
}

unsigned long CAutoEngine::Release()
{
	if (m_iRefCnt == 1)
		m_piInstaller->Release();
	return CAutoBase::Release();
}

DISPERR CAutoEngine::Application(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	m_piInstaller->AddRef();
	return args.Assign(m_piInstaller);
}

DISPERR CAutoEngine::Property(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szProperty;
	if ((iErr = args[1].GetString(szProperty)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		const WCHAR* szValue = 0;
		if (var.GetType() != VT_EMPTY && (iErr = var.GetString(szValue)) != S_OK)
			return iErr;
		return MsiSetPropertyW(m_hMsi, szProperty, szValue);
	}
	else
	{
		CTempBuffer<WCHAR, 1024> bValue;
		DWORD dwSize = bValue.GetSize();
		UINT iStat;
		do
			iStat = MsiGetPropertyW(m_hMsi, szProperty, bValue, &dwSize);
		while (iStat == ERROR_MORE_DATA  && (bValue.SetSize(++dwSize), true));
		if (iStat != ERROR_SUCCESS)
			return iStat;
		return args.Assign((const WCHAR* )bValue);
	}
}

DISPERR CAutoEngine::Language(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	return args.Assign(MsiGetLanguage(m_hMsi));
}

DISPERR CAutoEngine::Mode(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	int iMode;
	if ((iErr = args[1].GetInt(iMode)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		Bool fSet;
		if ((iErr = args[0].GetBool(fSet)) != S_OK)
			return iErr;
		return MsiSetMode(m_hMsi, (MSIRUNMODE)iMode, fSet);
	}
	else
	{
		return args.Assign((Bool)MsiGetMode(m_hMsi, (MSIRUNMODE)iMode));
	}
}

DISPERR CAutoEngine::Database(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	MSIHANDLE hDatabase = MsiGetActiveDatabase(m_hMsi);
	if (hDatabase == 0)
		return E_FAIL; //FUTURE could use different error code?
	return args.Assign(new CAutoDatabase(hDatabase));
}

DISPERR CAutoEngine::SourcePath(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	CTempBuffer<WCHAR, MAX_PATH> bPath;
	DWORD dwSize = bPath.GetSize();
	const WCHAR* szDir;
	if ((iErr = args[1].GetString(szDir)) != S_OK)
		return iErr;
	do
		iErr = MsiGetSourcePathW(m_hMsi, szDir, bPath, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bPath.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bPath);
}

DISPERR CAutoEngine::TargetPath(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szDir;
	if ((iErr = args[1].GetString(szDir)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		const WCHAR* szPath;
		if ((iErr = args[0].GetString(szPath)) != S_OK)
			return iErr;
		return MsiSetTargetPathW(m_hMsi, szDir, szPath);
	}
	else
	{
		CTempBuffer<WCHAR, MAX_PATH> bPath;
		DWORD dwSize = bPath.GetSize();
		do
			iErr = MsiGetTargetPathW(m_hMsi, szDir, bPath, &dwSize);
		while (iErr == ERROR_MORE_DATA && (bPath.SetSize(++dwSize), true));
		if (iErr != ERROR_SUCCESS)
			return iErr;
		return args.Assign((const WCHAR* )bPath);
	}
}

// constant returned when none of the ies error codes apply. Trapped by automation layer
// and never returned to user
const int iesCallError = -1;

iesEnum MapErrorReturnToAction(UINT iRet)
{
	switch (iRet)
	{
	case ERROR_FUNCTION_NOT_CALLED:    return iesNoAction;
	case ERROR_SUCCESS:                return iesSuccess;
	case ERROR_INSTALL_USEREXIT:       return iesUserExit;
	case ERROR_INSTALL_FAILURE:        return iesFailure;
	case ERROR_INSTALL_SUSPEND:        return iesSuspend;
	case ERROR_MORE_DATA:              return iesFinished;
	case ERROR_INVALID_HANDLE_STATE:   return iesWrongState;
	case ERROR_INVALID_DATA:           return iesBadActionData;
	default:                           return (iesEnum)iesCallError;
	}
}

DISPERR CAutoEngine::DoAction(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szAction;
	if ((iErr = args[1].GetString(szAction)) != S_OK)
		return iErr;
	iesEnum ies = MapErrorReturnToAction(MsiDoActionW(m_hMsi, szAction));
	return ies == iesCallError ? E_FAIL : args.Assign((int)ies);
}

DISPERR CAutoEngine::Sequence(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szTable;
	if ((iErr = args[1].GetString(szTable)) != S_OK)
		return iErr;
	int iSequence = 0;
	if (args.Present(2) && (iErr = args[2].GetInt(iSequence)) != S_OK)  // reserved integer argument
		return iErr;
	iesEnum ies = MapErrorReturnToAction(MsiSequenceW(m_hMsi, szTable, iSequence));
	return ies == iesCallError ? E_FAIL : args.Assign((int)ies);
}

DISPERR CAutoEngine::EvaluateCondition(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szExpr;
	if ((iErr = args[1].GetString(szExpr)) != S_OK)
		return iErr;
	return args.Assign((int)MsiEvaluateConditionW(m_hMsi, szExpr));
}

DISPERR CAutoEngine::FormatRecord(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	DISPERR iErr;
	do
		iErr = MsiFormatRecordW(m_hMsi, args[1].GetHandle(IID_IMsiApiRecord), bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoEngine::Message(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	int iType;
	if ((iErr = args[1].GetInt(iType)) != S_OK)
		return iErr;
	int iStat = MsiProcessMessage(m_hMsi, (INSTALLMESSAGE)iType, args[2].GetHandle(IID_IMsiApiRecord));
	if (iStat < 0)
		return E_FAIL;
	return args.Assign(iStat);
}

DISPERR CAutoEngine::FeatureCurrentState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	INSTALLSTATE iInstalled;
	INSTALLSTATE iAction;
	if ((iErr = MsiGetFeatureStateW(m_hMsi, szFeature, &iInstalled, &iAction)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign((int)iInstalled);
}

DISPERR CAutoEngine::FeatureRequestState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		int iState;
		if ((iErr = args[0].GetInt(iState)) != S_OK)
			return iErr;
		return MsiSetFeatureStateW(m_hMsi, szFeature, (INSTALLSTATE)iState);
	}
	else
	{
		INSTALLSTATE iInstalled;
		INSTALLSTATE iAction;
		if ((iErr = MsiGetFeatureStateW(m_hMsi, szFeature, &iInstalled, &iAction)) != ERROR_SUCCESS)
			return iErr;
		return args.Assign((int)iAction);
	}
}

DISPERR CAutoEngine::FeatureValidStates(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	DWORD dwInstallStates;
	if ((iErr = MsiGetFeatureValidStatesW(m_hMsi, szFeature, &dwInstallStates)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(dwInstallStates);
}

DISPERR CAutoEngine::FeatureCost(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	int iCostTree;
	int iState;
	if ((iErr = args[1].GetString(szFeature)) != S_OK
	||  (iErr = args[2].GetInt(iCostTree)) != S_OK
	||  (iErr = args[3].GetInt(iState)) != S_OK)
		return iErr;
	int iCost;
	if ((iErr = MsiGetFeatureCostW(m_hMsi, szFeature, (MSICOSTTREE)iCostTree, (INSTALLSTATE)iState, &iCost)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(iCost);
}

DISPERR CAutoEngine::ComponentCosts(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szComponent;
	int iState;
	if ((iErr = args[1].GetString(szComponent)) != S_OK
	 || (iErr = args[2].GetInt(iState)) != S_OK)
		return iErr;

	CTempBuffer<VolumeCost*, 10> rgVolumes;
	int cVolumes = 0;
	UINT uRes = ERROR_SUCCESS;
	CTempBuffer<WCHAR, MAX_PATH> bVolume;

	iErr = S_OK;

	for (DWORD dwIndex = 0; uRes == ERROR_SUCCESS; dwIndex++)
	{
		int iCost, iTempCost;

		DWORD dwSize = bVolume.GetSize();
		int iRetry = 0;
		do
			uRes = MsiEnumComponentCostsW(m_hMsi, szComponent, dwIndex,
													(INSTALLSTATE)iState,
													bVolume, &dwSize,
													&iCost, &iTempCost);
		while ( uRes == ERROR_MORE_DATA && ++iRetry < 2 && (bVolume.SetSize(++dwSize), true) );
		if ( uRes != ERROR_SUCCESS )
			break;

		VolumeCost* pstVol = new VolumeCost(bVolume, iCost, iTempCost);
		if ( !pstVol || (*bVolume && !pstVol->m_szDrive) )
		{
			iErr = E_OUTOFMEMORY;
			goto Error;
		}
		if ( cVolumes == rgVolumes.GetSize() )
			rgVolumes.Resize(cVolumes+5);
		rgVolumes[cVolumes++] = pstVol;
	}
	if ( uRes == ERROR_NO_MORE_ITEMS )
	{
		int iSize = cVolumes * sizeof(VolumeCost*);
		int cbBuffer = sizeof(CEnumBuffer) + iSize;
		CEnumBuffer* pBuffer = (CEnumBuffer*)new char[cbBuffer];
		if ( !pBuffer )
		{
			iErr = E_OUTOFMEMORY;
			goto Error;
		}
		memcpy((char*)pBuffer + sizeof(CEnumBuffer), (void*)(VolumeCost**)rgVolumes, iSize);
		pBuffer->iRefCnt = 0;
		pBuffer->cItems = cVolumes;
		pBuffer->cbSize = cbBuffer;
		IMsiCollection* piEnum = new CEnumVARIANTRECORD(*pBuffer);
		return args.Assign(new CAutoCollection(*piEnum, IID_IMsiRecordCollection));
	}

Error:
	for ( int i=0; i < cVolumes; i++ )
		delete rgVolumes[i];

	return iErr == S_OK ? E_FAIL : iErr;
}

DISPERR CAutoEngine::ComponentCurrentState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szComponent;
	if ((iErr = args[1].GetString(szComponent)) != S_OK)
		return iErr;
	INSTALLSTATE iInstalled;
	INSTALLSTATE iAction;
	if ((iErr = MsiGetComponentStateW(m_hMsi, szComponent, &iInstalled, &iAction)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign((int)iInstalled);
}

DISPERR CAutoEngine::ComponentRequestState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szComponent;
	if ((iErr = args[1].GetString(szComponent)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		int iState;
		if ((iErr = args[0].GetInt(iState)) != S_OK)
			return iErr;
		return MsiSetComponentStateW(m_hMsi, szComponent, (INSTALLSTATE)iState);
	}
	else
	{
		INSTALLSTATE iInstalled;
		INSTALLSTATE iAction;
		if ((iErr = MsiGetComponentStateW(m_hMsi, szComponent, &iInstalled, &iAction)) != ERROR_SUCCESS)
			return iErr;
		return args.Assign((int)iAction);
	}
}

DISPERR CAutoEngine::SetInstallLevel(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	int iLevel;
	if ((iErr = args[1].GetInt(iLevel)) != S_OK)
		return iErr;
	return MsiSetInstallLevel(m_hMsi, iLevel);
}

DISPERR CAutoEngine::VerifyDiskSpace(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	UINT iStat;
	Bool fStat;
	switch (iStat = MsiVerifyDiskSpace(m_hMsi))
	{
	case ERROR_SUCCESS:   fStat = fTrue; break;
	case ERROR_DISK_FULL: fStat = fFalse; break;
	default:              return iStat;
	}
	return args.Assign(fStat);
}

DISPERR CAutoEngine::ProductProperty(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szProperty;
	if ((iErr = args[1].GetString(szProperty)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, 256> bValue;
	DWORD dwSize = bValue.GetSize();
	do
		iErr = MsiGetProductPropertyW(m_hMsi, szProperty, bValue, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bValue.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bValue);
}

DISPERR CAutoEngine::FeatureInfo(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	CAutoFeatureInfo* pInfo = new CAutoFeatureInfo();
	if ( ! pInfo )
		return E_OUTOFMEMORY;
	if (!pInfo->Initialize(m_hMsi, szFeature))
	{
		pInfo->Release();
		return DISP_E_BADINDEX;
	}
	return args.Assign(pInfo);
}

//____________________________________________________________________________
//
// CAutoFeatureInfo automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoFeatureInfo> AutoFeatureInfoTable[] = {
  DISPID_MsiFeatureInfo_Title      , HELPID_MsiFeatureInfo_Title      , aafPropRO, CAutoFeatureInfo::Title      , L"Title",
  DISPID_MsiFeatureInfo_Description, HELPID_MsiFeatureInfo_Description, aafPropRO, CAutoFeatureInfo::Description, L"Description",
  DISPID_MsiFeatureInfo_Attributes , HELPID_MsiFeatureInfo_Attributes , aafPropRW, CAutoFeatureInfo::Attributes , L"Attributes",
};
const int AutoFeatureInfoCount = sizeof(AutoFeatureInfoTable)/sizeof(DispatchEntryBase);

CAutoFeatureInfo::CAutoFeatureInfo()
	: CAutoBase(*AutoFeatureInfoTable, AutoFeatureInfoCount, IID_IUnknown, (MSIHANDLE)0)
{
}

bool CAutoFeatureInfo::Initialize(MSIHANDLE hProduct, const WCHAR* szFeature)
{
	m_hProduct = hProduct;
	if ( lstrlenW(szFeature)+1 <= sizeof(m_szFeature)/sizeof(WCHAR) )
		lstrcpyW(m_szFeature, szFeature);
	else
	{
		*m_szFeature = 0;
		Assert(false);
	}
	DWORD cchTitleBuf = sizeof(m_szTitle)/sizeof(WCHAR);
	DWORD cchHelpBuf  = sizeof(m_szDescription)/sizeof(WCHAR);
	UINT iStat = MsiGetFeatureInfoW(hProduct, szFeature, &m_iAttributes, m_szTitle, &cchTitleBuf, m_szDescription, &cchHelpBuf);
	return iStat == ERROR_SUCCESS || iStat == ERROR_MORE_DATA; // ignore truncation, should never happen due to schema limitations
}

DISPERR CAutoFeatureInfo::Title(CAutoArgs& args)
{
	return args.Assign(m_szTitle);
}

DISPERR CAutoFeatureInfo::Description(CAutoArgs& args)
{
	return args.Assign(m_szDescription);
}

DISPERR CAutoFeatureInfo::Attributes(CAutoArgs& args)
{
	if ( args.PropertySet() )
	{
		if ( *m_szFeature == 0 )
			return E_INVALIDARG;

		DISPERR iErr;
		DWORD dwValue;
		if ((iErr = args[0].GetInt((int&)dwValue)) != S_OK)
			return iErr;
		return MsiSetFeatureAttributesW(m_hProduct, m_szFeature, dwValue);
	}
	else
		return args.Assign(m_iAttributes);
}

//____________________________________________________________________________
//
// CAutoUIPreview automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoUIPreview> AutoUIPreviewTable[] = {
  DISPID_MsiUIPreview_Property     , HELPID_MsiEngine_Property        , aafPropRW, CAutoUIPreview::Property,      L"Property,Name",
  DISPID_MsiUIPreview_ViewDialog   , HELPID_MsiUIPreview_ViewDialog   , aafMethod, CAutoUIPreview::ViewDialog,    L"ViewDialog,Dialog",
  DISPID_MsiUIPreview_ViewBillboard, HELPID_MsiUIPreview_ViewBillboard, aafMethod, CAutoUIPreview::ViewBillboard, L"ViewBillboard,Control,Billboard",
};
const int AutoUIPreviewCount = sizeof(AutoUIPreviewTable)/sizeof(DispatchEntryBase);

CAutoUIPreview::CAutoUIPreview(MSIHANDLE hUIPreview)
 : CAutoBase(*AutoUIPreviewTable, AutoUIPreviewCount, IID_IMsiApiUIPreview, hUIPreview)
{
}

DISPERR CAutoUIPreview::Property(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProperty;
	if ((iErr = args[1].GetString(szProperty)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		const WCHAR* szValue = 0;
		if (var.GetType() != VT_EMPTY && (iErr = var.GetString(szValue)) != S_OK)
			return iErr;
		return MsiSetPropertyW(m_hMsi, szProperty, szValue);
	}
	else
	{
		CTempBuffer<WCHAR, 1024> bValue;
		DWORD dwSize = bValue.GetSize();
		UINT iStat;
		do
			iStat = MsiGetPropertyW(m_hMsi, szProperty, bValue, &dwSize);
		while (iStat == ERROR_MORE_DATA && (bValue.SetSize(++dwSize), true));
		if (iStat != ERROR_SUCCESS)
			return iStat;
		return args.Assign((const WCHAR* )bValue);
	}
}

DISPERR CAutoUIPreview::ViewDialog(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szDialog;
	if ((iErr = args[1].GetString(szDialog)) != S_OK)
		return iErr;
	return MsiPreviewDialogW(m_hMsi, szDialog);
}

DISPERR CAutoUIPreview::ViewBillboard(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szControl;
	const WCHAR* szBillboard;
	if ((iErr = args[1].GetString(szControl)) != S_OK
	||  (iErr = args[2].GetString(szBillboard)) != S_OK)
		return iErr;
	return MsiPreviewBillboardW(m_hMsi, szControl, szBillboard);
}

//____________________________________________________________________________
//
// DLL management
//____________________________________________________________________________

#ifdef INTERNAL
extern "C" HRESULT __stdcall DllRegisterServerTest();
extern "C" HRESULT __stdcall DllUnregisterServerTest();
extern "C" HRESULT __stdcall DllGetClassObjectTest(const GUID& clsid, const IID& iid, void** ppvRet);
#else // !INTERNAL (standalone DLL)
int __stdcall
DllMain(HINSTANCE hInst, DWORD fdwReason, void* /*pvreserved*/)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstance = hInst;
	else if (fdwReason == DLL_PROCESS_DETACH)
		g_hInstance = 0;
	OSVERSIONINFO osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	W32::GetVersionEx(&osviVersion); // fails only if size set wrong
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		g_fWin9X = true;

	AcquireRefCountedTokenPrivileges(itkpSD_READ);
	return TRUE;
};
#endif // INTERNAL

HRESULT CAutoApiFactory::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
		return (*ppvObj = this, NOERROR);
	else
		return (*ppvObj = 0, E_NOINTERFACE);
}
unsigned long CAutoApiFactory::AddRef()
{
	return 1;
}
unsigned long CAutoApiFactory::Release()
{
	return 1;
}

extern CMsiCustomAction* g_pCustomActionContext;
HRESULT CAutoApiFactory::CreateInstance(IUnknown* pUnkOuter, const IID& riid,
													void** ppvObject)
{
	if (pUnkOuter)
		return CLASS_E_NOAGGREGATION;
	if (!(riid == IID_IUnknown || riid == IID_IMsiApiInstall || riid == IID_IDispatch))
		return E_NOINTERFACE;
    
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		if (S_OK != g_pCustomActionContext->GetInstallerObject(reinterpret_cast<IDispatch**>(ppvObject)))
			return E_OUTOFMEMORY;
	}
	else
#endif // UNICODE
		*ppvObject = (void*)::CreateAutoInstall();

	if (!(*ppvObject))
		return E_OUTOFMEMORY;
	return NOERROR;
}
HRESULT CAutoApiFactory::LockServer(BOOL fLock)
{
   if (fLock)
	  g_cInstances++;
   else if (g_cInstances)
		g_cInstances--;
	return NOERROR;
}

extern "C" HRESULT __stdcall
DllGetClassObject(const GUID& clsid, const IID& iid, void** ppvRet)
{
	*ppvRet = 0;
#ifdef INTERNAL
	HRESULT hres;
	
	hres = DllGetClassObjectTest(clsid, iid, ppvRet);
	if (hres == NOERROR)
		return hres;
#endif //INTERNAL

	if (!(iid == IID_IUnknown || iid == IID_IClassFactory))
		return E_NOINTERFACE;
	if (clsid == IID_IMsiSystemAccess)
	{
		*ppvRet = (void*)&g_InstallerFactory;
		return NOERROR;
	}
#ifdef DEBUG
	if (clsid == IID_IMsiApiInstall || clsid == IID_IMsiApiInstallDebug)
#else
	if (clsid == IID_IMsiApiInstall)
#endif
	{
		*ppvRet = (void*)&g_AutoInstallFactory;
		return NOERROR;
	}
	return E_FAIL;
}

#ifndef INTERNAL
extern "C" HRESULT __stdcall
DllCanUnloadNow()
{
   return g_cInstances ? S_FALSE : S_OK;
}
#endif // INTERNAL

static TCHAR szRegFilePath[MAX_PATH];
static TCHAR szRegCLSIDAuto[40];  // buffer for string form of CLSID
static TCHAR szRegCLSIDMessage[40];  // buffer for string form of CLSID
static TCHAR szRegLIBID[40];  // buffer for string form of LIBID
static TCHAR szRegDllVersionString [100]; // buffer for string form of dll version.

static const TCHAR szRegProgId[]          = TEXT("WindowsInstaller.Installer");
static const TCHAR szRegProgIdMessage[]   = TEXT("WindowsInstaller.Message");
static const TCHAR szRegDescription[] = TEXT("Microsoft Windows Installer");
static const TCHAR szRegDescriptionMessage[] = TEXT("Microsoft Windows Installer Message RPC");

#ifdef DEBUG
static TCHAR szRegCLSIDDebug[40];  // buffer for string form of CLSID
static const TCHAR szRegProgIdDebug[]      = TEXT("WindowsInstaller.Debug");
static const TCHAR szRegDescriptionDebug[] = TEXT("Microsoft Windows Installer - Debug");
#endif
static TCHAR szRegCLSIDPriv[40];

static const TCHAR* rgszRegData[] = {
	TEXT("CLSID\\%s\\InprocServer32"),  szRegCLSIDAuto, szRegFilePath,                      TEXT("ThreadingModel"), TEXT("Apartment"),
	TEXT("CLSID\\%s\\InprocHandler32"), szRegCLSIDAuto, TEXT("ole32.dll"),                  NULL, NULL,
	TEXT("CLSID\\%s\\ProgId"),          szRegCLSIDAuto, szRegProgId,                        NULL, NULL,
	TEXT("CLSID\\%s\\TypeLib"),         szRegCLSIDAuto, szRegLIBID,                         NULL, NULL,
	TEXT("CLSID\\%s"),                  szRegCLSIDAuto, szRegDescription,                   NULL, NULL,
	TEXT("%s\\CLSID"),                  szRegProgId,    szRegCLSIDAuto,                     NULL, NULL,
	TEXT("%s"),                         szRegProgId,    szRegDescription,                   NULL, NULL,
	TEXT("CLSID\\%s\\InprocServer32"),  szRegCLSIDPriv, szRegFilePath,                      TEXT("ThreadingModel"), TEXT("Apartment"),
	TEXT("CLSID\\%s"),                  szRegCLSIDPriv, TEXT(""),                           NULL, NULL,

	TEXT("%s\\CLSID"),                  szRegProgIdMessage,  szRegCLSIDMessage,             NULL, NULL,
	TEXT("%s"),                         szRegProgIdMessage,  szRegDescriptionMessage,       NULL, NULL,
	TEXT("CLSID\\%s\\ProgId"),          szRegCLSIDMessage,   szRegProgIdMessage,            NULL, NULL,
	TEXT("CLSID\\%s"),                  szRegCLSIDMessage,   szRegDescriptionMessage,       NULL, NULL,
	TEXT("CLSID\\%s\\DllVersion"),      szRegCLSIDMessage,	 szRegDllVersionString,         NULL, NULL,

#ifdef DEBUG
	TEXT("CLSID\\%s\\InprocServer32"),  szRegCLSIDDebug, szRegFilePath,                     TEXT("ThreadingModel"), TEXT("Apartment"),
	TEXT("CLSID\\%s\\InprocHandler32"), szRegCLSIDDebug, TEXT("ole32.dll"),                 NULL, NULL,
	TEXT("CLSID\\%s\\ProgId"),          szRegCLSIDDebug, szRegProgIdDebug,                  NULL, NULL,
	TEXT("CLSID\\%s\\TypeLib"),         szRegCLSIDDebug, szRegLIBID,                        NULL, NULL,
	TEXT("CLSID\\%s"),                  szRegCLSIDDebug, szRegDescriptionDebug,             NULL, NULL,
	TEXT("%s\\CLSID"),                  szRegProgIdDebug, szRegCLSIDDebug,                  NULL, NULL,
	TEXT("%s"),                         szRegProgIdDebug, szRegDescriptionDebug,            NULL, NULL,
#endif
	0
};

extern "C" HRESULT __stdcall ProxyDllRegisterServer();
extern "C" HRESULT __stdcall ProxyDllUnregisterServer();
void UnRegisterOldInfo(void);

static const TCHAR szEventLogRegKey[] = TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\MsiInstaller");
static const TCHAR szEventLogFileValue[] = TEXT("EventMessageFile");
static const TCHAR szEventLogTypesValue[] = TEXT("TypesSupported");
extern void GetVersionInfo(int* piMajorVersion, int* piMinorVersion, int* piWindowsBuild, bool* pfWin9X, bool* pfWinNT64);
extern "C" HRESULT __stdcall DllGetVersion (DLLVERSIONINFO * pVerInfo);

HRESULT __stdcall
DllRegisterServer()
{
	DLLVERSIONINFO	verInfo;

#if 0 //OLD defined(INTERNAL) && defined(DEBUG)
	UnRegisterOldInfo();
#endif // INTERNAL && DEBUG

	HRESULT hRes = 0;
	int cchFilePath = W32::GetModuleFileName(g_hInstance, szRegFilePath, sizeof(szRegFilePath)/sizeof(TCHAR));
#if defined(INTERNAL)
#ifdef UNICODE
	bool fWin9X = false;
#else
	bool fWin9X = true;
#endif
	GetVersionInfo(0, 0, 0, &fWin9X, 0);
	if (cchFilePath > 0 && !fWin9X)
	{   // Register the location of the MSI Event Log message file
		HKEY hkey;
		if (MsiRegCreate64bitKey(HKEY_LOCAL_MACHINE, szEventLogRegKey, 0, 0, 0, KEY_READ|KEY_WRITE, 0, &hkey, 0) == ERROR_SUCCESS)
		{
			DWORD dwTypesSupported = 7;
			W32::RegSetValueEx(hkey, szEventLogFileValue, 0, REG_SZ, (CONST BYTE*)szRegFilePath, (lstrlen(szRegFilePath)+1)*sizeof(TCHAR));
			W32::RegSetValueEx(hkey, szEventLogTypesValue, 0, REG_DWORD, (CONST BYTE*)&dwTypesSupported, sizeof(DWORD));
			W32::RegCloseKey(hkey);
		}
	}
	int cErr = (ProxyDllRegisterServer() == S_OK ? 0 : 1);
#else
	int cErr = 0;
#endif
	wsprintf(szRegCLSIDAuto,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstall);
	wsprintf(szRegCLSIDMessage,   TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiMessage);
	verInfo.cbSize = sizeof (DLLVERSIONINFO);
	DllGetVersion (&verInfo);
	wsprintf (szRegDllVersionString, TEXT("%d.%d.%d"), verInfo.dwMajorVersion, verInfo.dwMinorVersion, verInfo.dwBuildNumber);
#ifdef DEBUG
	wsprintf(szRegCLSIDDebug, TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstallDebug);
#endif
	wsprintf(szRegCLSIDPriv,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiSystemAccess);
	wsprintf(szRegLIBID,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiTypeLib);
	const TCHAR** psz = rgszRegData;
	while (*psz)
	{
		if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
		{
			TCHAR szRegKey[80];
			const TCHAR* szTemplate = *psz++;
			wsprintf(szRegKey, szTemplate, *psz++);
			HKEY hkey;
			hkey = 0;
			if (RegCreateKeyAPI(HKEY_CLASSES_ROOT, szRegKey, 0, 0, 0,
									  KEY_READ|KEY_WRITE, 0, &hkey, 0) != ERROR_SUCCESS
			 || W32::RegSetValueEx(hkey, 0, 0, REG_SZ, (CONST BYTE*)*psz, (lstrlen(*psz)+1)*sizeof(TCHAR)) != ERROR_SUCCESS)
				cErr++;
			psz++;

			if (hkey && *psz)
			{
				if (W32::RegSetValueEx(hkey, (*psz), 0, REG_SZ, (CONST BYTE*)*(psz+1), (lstrlen(*(psz+1))+1)*sizeof(TCHAR)) != ERROR_SUCCESS)
				cErr++;
			}
			psz+=2;
			if (hkey)
				W32::RegCloseKey(hkey);
		}
	}
#ifdef INTERNAL
	if (GetTestFlag('r') && DllRegisterServerTest() != NOERROR)
		cErr++;
#endif // INTERNAL
	if (cErr)
		return SELFREG_E_CLASS;
#ifdef UNICODE
	OLECHAR *szTypeLibPath = szRegFilePath;
#else
	OLECHAR szTypeLibPath[MAX_PATH];
	W32::MultiByteToWideChar(CP_ACP, 0, szRegFilePath, cchFilePath+1, szTypeLibPath, MAX_PATH);
#endif
	ITypeLib* piTypeLib = 0;
	HRESULT hres = OLEAUT32::LoadTypeLib(szTypeLibPath, &piTypeLib);
	if (hres == TYPE_E_INVDATAREAD)  // ignore if Win95 virgin OLEAUT32.DLL, different typelib format
		return S_OK;
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
	hres = OLEAUT32::RegisterTypeLib(piTypeLib, szTypeLibPath, 0);
	piTypeLib->Release();
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
//NT4,Win95+new OLEAUT32 only: if (OLEAUT32::LoadTypeLibEx(szTypeLibPath, REGKIND_REGISTER, &piTypeLib) != S_OK)
	return NOERROR;
}

HRESULT __stdcall
DllUnregisterServer()
{
	TCHAR szRegKey[80];
	int cErr = 0;

#if 0 //OLD defined(INTERNAL) && defined(DEBUG)
	UnRegisterOldInfo();
#endif // INTERNAL && DEBUG

#if defined(INTERNAL)
#ifdef UNICODE
	bool fWin9X = false;
#else
	bool fWin9X = true;
#endif
	GetVersionInfo(0, 0, 0, &fWin9X, 0);
	if (!fWin9X)
	{
		// Delete Event log registration
		W32::RegDeleteKey(HKEY_LOCAL_MACHINE, szEventLogRegKey);
	}

	HRESULT hr = ProxyDllUnregisterServer();
#else
	HRESULT hr = NOERROR;
#endif
	if (hr != S_OK && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
		cErr ++;

	// unregister keys under CLSID and ProgId
	wsprintf(szRegCLSIDAuto,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstall);
	wsprintf(szRegCLSIDMessage,   TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiMessage);
#ifdef DEBUG
	wsprintf(szRegCLSIDDebug, TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstallDebug);
#endif
	wsprintf(szRegCLSIDPriv,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiSystemAccess);
	wsprintf(szRegLIBID,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiTypeLib);
	const TCHAR** psz = rgszRegData;
	while (*psz)
	{
		if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
		{
			const TCHAR* szTemplate = *psz++;
			wsprintf(szRegKey, szTemplate, *psz++);
			long lResult = W32::RegDeleteKey(HKEY_CLASSES_ROOT, szRegKey);
			if((ERROR_KEY_DELETED != lResult) &&
				(ERROR_FILE_NOT_FOUND != lResult) && (ERROR_SUCCESS != lResult))
			{
				if (ERROR_ACCESS_DENIED == lResult)
				{
					DWORD cSubKeys;
					HKEY hKey;
					
					lResult = RegOpenKeyAPI(HKEY_CLASSES_ROOT, szRegKey, 0, KEY_READ, &hKey);
					if (lResult == ERROR_SUCCESS)
					{
						lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, &cSubKeys, NULL,
										NULL, NULL, NULL, NULL, NULL, NULL);
						if (lResult != ERROR_SUCCESS || cSubKeys == 0)
							cErr++;
						RegCloseKey(hKey);
					}
					else                                                
						cErr++;
				}
				else
					cErr++;
			}
			psz+= 3;
		}
	}
	OLEAUT32::UnRegisterTypeLib(IID_IMsiApiTypeLib, TYPELIB_MAJOR_VERSION, TYPELIB_MINOR_VERSION, 0x0409, SYS_WIN32);
#ifdef INTERNAL
	if (GetTestFlag('r') && DllUnregisterServerTest() != NOERROR)
		cErr++;
#endif // INTERNAL
	return cErr ? SELFREG_E_CLASS : NOERROR;
}

#if 0 // OLD - no longer needed: defined(INTERNAL) && defined(DEBUG)
//
// Debug only, kills off old information in the registry
//

const TCHAR *rgKillKeys[] =
{
	TEXT("CLSID\\{000C101C-0000-0000-C000-000000000046}\\TypeLib"),
	TEXT("Interface\\{000C101C-0000-0000-C000-000000000046}\\TypeLib"),
	TEXT("Interface\\{000C101C-0000-0000-C000-000000000046}\\ProxyStubClsid"),
	TEXT("Interface\\{000C101D-0000-0000-C000-000000000046}\\TypeLib"),
	TEXT("Interface\\{000C101D-0000-0000-C000-000000000046}\\ProxyStubClsid"),
};

#define cKillKeys   (sizeof(rgKillKeys)/sizeof(TCHAR *))

void UnRegisterOldInfo()
{
	long lResult;
	long lErr;

	for (int i = 0 ; i < cKillKeys ; i++)
	{
		lResult = W32::RegDeleteKey(HKEY_CLASSES_ROOT, rgKillKeys[i]);
		if((ERROR_KEY_DELETED != lResult) &&
			(ERROR_FILE_NOT_FOUND != lResult) && (ERROR_SUCCESS != lResult))
		{
			lErr = GetLastError();
		}
	}
}
#endif

#ifndef INTERNAL
//____________________________________________________________________________
//
// Win32 API wrappers to perform on-demand binding to expensive DLLs
//____________________________________________________________________________

// doesn't work for function definitions: using namespace OLEAUT32;

FARPROC Bind_OLEAUT32(const char* szEntry)
{
	static HINSTANCE hInst = 0;
	if (hInst == 0)
	{
		hInst = W32::LoadLibrary(TEXT("OLEAUT32.DLL"));
		Assert(hInst != 0);
	}
	return W32::GetProcAddress(hInst, szEntry);
}

BSTR WINAPI OLEAUT32::F_SysAllocString(const OLECHAR* sz)
{
	SysAllocString = (T_SysAllocString)Bind_OLEAUT32("SysAllocString");
	Assert(SysAllocString != 0);
	return SysAllocString ? (*SysAllocString)(sz) : 0;
}

BSTR WINAPI OLEAUT32::F_SysAllocStringLen(const OLECHAR* sz, UINT cch)
{
	SysAllocStringLen = (T_SysAllocStringLen)Bind_OLEAUT32("SysAllocStringLen");
	Assert(SysAllocStringLen != 0);
	return SysAllocStringLen ? (*SysAllocStringLen)(sz, cch) : 0;
}

void WINAPI OLEAUT32::F_SysFreeString(const OLECHAR* sz)
{
	SysFreeString = (T_SysFreeString)Bind_OLEAUT32("SysFreeString");
	Assert(SysFreeString != 0);
	if (SysFreeString) (*SysFreeString)(sz);
}

UINT WINAPI OLEAUT32::F_SysStringLen(const OLECHAR* sz)
{
	SysStringLen = (T_SysStringLen)Bind_OLEAUT32("SysStringLen");
	Assert(SysStringLen != 0);
	return SysStringLen ? (*SysStringLen)(sz) : 0;
}

HRESULT WINAPI OLEAUT32::F_VariantClear(VARIANTARG * pvarg)
{
	VariantClear = (T_VariantClear)Bind_OLEAUT32("VariantClear");
	Assert(VariantClear != 0);
	return VariantClear ? (*VariantClear)(pvarg) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

HRESULT WINAPI OLEAUT32::F_VariantChangeType(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt)
{
	VariantChangeType = (T_VariantChangeType)Bind_OLEAUT32("VariantChangeType");
	Assert(VariantChangeType != 0);
	if (VariantChangeType == 0)
		return TYPE_E_DLLFUNCTIONNOTFOUND;
	return (*VariantChangeType)(pvargDest, pvarSrc, wFlags, vt);
}

HRESULT WINAPI OLEAUT32::F_LoadTypeLib(const OLECHAR  *szFile, ITypeLib ** pptlib)
{
	LoadTypeLib = (T_LoadTypeLib)Bind_OLEAUT32("LoadTypeLib");
	Assert(LoadTypeLib != 0);
	return LoadTypeLib ? (*LoadTypeLib)(szFile, pptlib) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

HRESULT WINAPI OLEAUT32::F_RegisterTypeLib(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir)
{
	RegisterTypeLib = (T_RegisterTypeLib)Bind_OLEAUT32("RegisterTypeLib");
	Assert(RegisterTypeLib != 0);
	return RegisterTypeLib ? (*RegisterTypeLib)(ptlib, szFullPath, szHelpDir) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

HRESULT WINAPI OLEAUT32::F_UnRegisterTypeLib(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind)
{
	UnRegisterTypeLib = (T_UnRegisterTypeLib)Bind_OLEAUT32("UnRegisterTypeLib");
	Assert(UnRegisterTypeLib != 0);
	return UnRegisterTypeLib ? (*UnRegisterTypeLib)(libID, wVerMajor, wVerMinor, lcid, syskind) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

INT WINAPI OLEAUT32::F_DosDateTimeToVariantTime(USHORT wDosDate, USHORT wDosTime, double *pvtime)
{
	DosDateTimeToVariantTime = (T_DosDateTimeToVariantTime)Bind_OLEAUT32("DosDateTimeToVariantTime");
	Assert(DosDateTimeToVariantTime != 0);
	return DosDateTimeToVariantTime ? (*DosDateTimeToVariantTime)(wDosDate, wDosTime, pvtime) : 0;
}

INT WINAPI OLEAUT32::F_SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, double *pvtime)
{
	SystemTimeToVariantTime = (T_SystemTimeToVariantTime)Bind_OLEAUT32("SystemTimeToVariantTime");
	Assert(SystemTimeToVariantTime != 0);
	return SystemTimeToVariantTime ? (*SystemTimeToVariantTime)(lpSystemTime, pvtime) : 0;
}

INT WINAPI OLEAUT32::F_VariantTimeToSystemTime(double vtime, LPSYSTEMTIME lpSystemTime)
{
	VariantTimeToSystemTime = (T_VariantTimeToSystemTime)Bind_OLEAUT32("VariantTimeToSystemTime");
	Assert(VariantTimeToSystemTime != 0);
	return VariantTimeToSystemTime ? (*VariantTimeToSystemTime)(vtime, lpSystemTime) : 0;
}

HRESULT WINAPI OLEAUT32::F_VarI4FromR8(double dblIn, LONG* plOut)
{
	VarI4FromR8 = (T_VarI4FromR8)Bind_OLEAUT32("VarI4FromR8");
	Assert(VarI4FromR8 != 0);
	return VarI4FromR8 ? (*VarI4FromR8)(dblIn, plOut) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

/*
FARPROC Bind_CRYPT32(const char* szEntry)
{
	static HINSTANCE hInst = 0;
	if (hInst == 0)
	{
		hInst = W32::LoadLibrary(TEXT("CRYPT32.DLL"));
		Assert(hInst != 0);
	}
	return W32::GetProcAddress(hInst, szEntry);
}

BOOL WINAPI CRYPT32::F_CertFreeCertificateContext(PCCERT_CONTEXT pcCert)
{
	CertFreeCertificateContext = (T_CertFreeCertificateContext)Bind_CRYPT32("CertFreeCertificateContext");
	Assert(CertFreeCertificateContext != 0);
	return CertFreeCertificateContext ? (*CertFreeCertificateContext)(pcCert) : FALSE;
}
*/

#ifdef DEBUG
void FailAssert(const TCHAR* szFile, int iLine)
{
	TCHAR szMessage[256];   
	wsprintf(szMessage,TEXT("Assertion failed in %s: Line %i"), szFile, iLine);
	W32::MessageBox(0, szMessage, TEXT("Automation Assert Message"), MB_OK);
}
#endif // DEBUG
#endif // INTERNAL

//____________________________________________________________________________
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\comadmin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       comadmin.c
//
//--------------------------------------------------------------------------

/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Tue Feb 09 15:34:51 1999
 */
/* Compiler settings for comadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICOMAdminCatalog = {0xDD662187,0xDFC2,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const IID IID_ICatalogObject = {0x6eb22871,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_ICatalogCollection = {0x6eb22872,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_COMAdmin = {0xF618C513,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalog = {0xF618C514,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalogObject = {0xF618C515,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalogCollection = {0xF618C516,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\appcompat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 2001
//
//  File:       appcompat.cpp
//
//--------------------------------------------------------------------------

/* appcompat.cpp - MSI application compatibility features implementation
____________________________________________________________________________*/

#include "precomp.h"
#include "_engine.h"
#include "_msiutil.h"
#include "version.h"


#define PROPPREFIX           TEXT("MSIPROPERTY_")
#define PACKAGECODE          TEXT("PACKAGECODE")
#define APPLYPOINT           TEXT("APPLYPOINT")
#define MINMSIVERSION        TEXT("MINMSIVERSION")
#define SDBDOSSUBPATH        TEXT("\\apppatch\\msimain.sdb")
#define SDBNTFULLPATH        TEXT("\\SystemRoot\\AppPatch\\msimain.sdb")
#define MSIDBCELL            TEXT("MSIDBCELL")
#define MSIDBCELLPKS         TEXT("PRIMARYKEYS")
#define MSIDBCELLLOOKUPDATA  TEXT("LOOKUPDATA")
#define SHIMFLAGS            TEXT("SHIMFLAGS")

#define DEBUGMSG_AND_ASSERT(string)     \
	DEBUGMSG(string);                    \
	AssertSz(0, string);                 \


bool FCheckDatabaseCell(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, IMsiDatabase& riDatabase, const ICHAR* szTable);


inline SHIMDBNS::HSDB LocalSdbInitDatabase(DWORD dwFlags, LPCTSTR pszDatabasePath)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbInitDatabase(dwFlags, pszDatabasePath);
	else
		return SDBAPIU::SdbInitDatabase(dwFlags, pszDatabasePath);
#else
	return SDBAPI::SdbInitDatabase(dwFlags, pszDatabasePath);
#endif
}

inline VOID LocalSdbReleaseDatabase(SHIMDBNS::HSDB hSDB)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbReleaseDatabase(hSDB);
	else
		return SDBAPIU::SdbReleaseDatabase(hSDB);
#else
	return SDBAPI::SdbReleaseDatabase(hSDB);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindFirstMsiPackage_Str(SHIMDBNS::HSDB hSDB, LPCTSTR lpszGuid, LPCTSTR lpszLocalDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbFindFirstMsiPackage_Str(hSDB, lpszGuid, lpszLocalDB, pFindInfo);
	else
		return SDBAPIU::SdbFindFirstMsiPackage_Str(hSDB, lpszGuid, lpszLocalDB, pFindInfo);
#else
	return SDBAPI::SdbFindFirstMsiPackage_Str(hSDB, lpszGuid, lpszLocalDB, pFindInfo);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindNextMsiPackage(SHIMDBNS::HSDB hSDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbFindNextMsiPackage(hSDB, pFindInfo);
	else
		return SDBAPIU::SdbFindNextMsiPackage(hSDB, pFindInfo);
#else
	return SDBAPI::SdbFindNextMsiPackage(hSDB, pFindInfo);
#endif
}

inline DWORD LocalSdbQueryDataEx(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trExe, LPCTSTR lpszDataName, LPDWORD lpdwDataType, LPVOID lpBuffer, LPDWORD lpdwBufferSize, SHIMDBNS::TAGREF* ptrData)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbQueryDataEx(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData);
	else
		return SDBAPIU::SdbQueryDataEx(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData);
#else
	return SDBAPI::SdbQueryDataEx(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData);
#endif
}

inline DWORD LocalSdbEnumMsiTransforms(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, SHIMDBNS::TAGREF* ptrBuffer, DWORD* pdwBufferSize)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbEnumMsiTransforms(hSDB, trMatch, ptrBuffer, pdwBufferSize);
	else
		return SDBAPIU::SdbEnumMsiTransforms(hSDB, trMatch, ptrBuffer, pdwBufferSize);
#else
	return SDBAPI::SdbEnumMsiTransforms(hSDB, trMatch, ptrBuffer, pdwBufferSize);
#endif
}

inline BOOL LocalSdbReadMsiTransformInfo(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trTransformRef, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbReadMsiTransformInfo(hSDB, trTransformRef, pTransformInfo);
	else
		return SDBAPIU::SdbReadMsiTransformInfo(hSDB, trTransformRef, pTransformInfo);
#else
	return SDBAPI::SdbReadMsiTransformInfo(hSDB, trTransformRef, pTransformInfo);
#endif
}

inline BOOL LocalSdbCreateMsiTransformFile(SHIMDBNS::HSDB hSDB, LPCTSTR lpszFileName, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbCreateMsiTransformFile(hSDB, lpszFileName, pTransformInfo);
	else
		return SDBAPIU::SdbCreateMsiTransformFile(hSDB, lpszFileName, pTransformInfo);
#else
	return SDBAPI::SdbCreateMsiTransformFile(hSDB, lpszFileName, pTransformInfo);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindFirstTagRef(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAG tTag)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbFindFirstTagRef(hSDB, trParent, tTag);
	else
		return SDBAPIU::SdbFindFirstTagRef(hSDB, trParent, tTag);
#else
	return SDBAPI::SdbFindFirstTagRef(hSDB, trParent, tTag);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindNextTagRef(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAGREF trPrev)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbFindNextTagRef(hSDB, trParent, trPrev);
	else
		return SDBAPIU::SdbFindNextTagRef(hSDB, trParent, trPrev);
#else
	return SDBAPI::SdbFindNextTagRef(hSDB, trParent, trPrev);
#endif
}

inline BOOL LocalSdbReadStringTagRef(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, LPTSTR pwszBuffer, DWORD dwBufferSize)
{
#ifdef UNICODE
	if(MinimumPlatformWindowsNT51())
		return APPHELP::SdbReadStringTagRef(hSDB, trMatch, pwszBuffer, dwBufferSize);
	else
		return SDBAPIU::SdbReadStringTagRef(hSDB, trMatch, pwszBuffer, dwBufferSize);
#else
	return SDBAPI::SdbReadStringTagRef(hSDB, trMatch, pwszBuffer, dwBufferSize);
#endif
}


DWORD LocalSdbQueryData(SHIMDBNS::HSDB    hSDB,
								SHIMDBNS::TAGREF  trMatch,
								LPCTSTR szDataName,
								LPDWORD pdwDataType,
								CTempBufferRef<BYTE>& rgbBuffer,
								SHIMDBNS::TAGREF* ptrData)
{							
	Assert(pdwDataType);
	Assert(rgbBuffer.GetSize() >= 2);

	DWORD cbBuffer = rgbBuffer.GetSize();

	DWORD dwResult = LocalSdbQueryDataEx(hSDB, trMatch, szDataName, pdwDataType, (BYTE*)rgbBuffer, &cbBuffer, ptrData);

	if(ERROR_INSUFFICIENT_BUFFER == dwResult)
	{
		rgbBuffer.Resize(cbBuffer);
		dwResult = LocalSdbQueryDataEx(hSDB, trMatch, szDataName, pdwDataType, (BYTE*)rgbBuffer, &cbBuffer, ptrData);
	}

	if(*pdwDataType == REG_NONE) // in case buffer is treated as string, null first WCHAR
	{
		rgbBuffer[0] = 0;
		rgbBuffer[1] = 0;
	}

	return dwResult;
}

bool GetSdbDataNames(SHIMDBNS::HSDB hSDB,
							SHIMDBNS::TAGREF trMatch,
							CTempBufferRef<BYTE>& rgbBuffer)
{
	DWORD dwDataType = 0;
	DWORD dwStatus = LocalSdbQueryData(hSDB,
												  trMatch,
												  NULL,
												  &dwDataType,
												  rgbBuffer,
												  NULL);

	if(dwStatus != ERROR_SUCCESS)
	{
		// no DATA tags, which may be fine
		return false;
	}
	else if(dwDataType != REG_MULTI_SZ)
	{
		DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbQueryData failed unexpectedly.  Sdb may be invalid."));
		return false;
	}

	return true;
}

int GetShimFlags(SHIMDBNS::HSDB hSDB,
						SHIMDBNS::TAGREF trMatch)
{
	DWORD dwDataType = 0;
	DWORD dwFlags = 0;

	CTempBuffer<BYTE, 256> rgbAttributeData;

	DWORD dwStatus = LocalSdbQueryData(hSDB,
								 trMatch,
								 SHIMFLAGS,
								 &dwDataType,
								 rgbAttributeData,
								 NULL);

	if(dwStatus == ERROR_SUCCESS)
	{
		if(dwDataType == REG_DWORD)
		{
			dwFlags = *((DWORD*)(BYTE*)rgbAttributeData);
			DEBUGMSG2(TEXT("APPCOMPAT: %s: %d"), SHIMFLAGS, (const ICHAR*)(INT_PTR)dwFlags);
		}
		else
		{
			DEBUGMSG1(TEXT("APPCOMPAT: found invalid '%s' entry.  Ignoring..."), SHIMFLAGS);
		}
	}

	return dwFlags;
}


bool FIsMatchingAppCompatEntry(SHIMDBNS::HSDB hSDB,
										 SHIMDBNS::TAGREF trMatch,
										 const IMsiString& ristrPackageCode,
										 iacpAppCompatTransformApplyPoint iacpApplyPoint,
										 IMsiEngine& riEngine,
										 IMsiDatabase& riDatabase)
{
	DWORD dwStatus = 0;
	DWORD dwDataType = 0;
	
	CTempBuffer<BYTE, 256> rgbAttributeData;

	// first, we check for the required DATA entries
	// 1) MINMSIVERSION tells us the minimum version of msi that should process this entry
	//		(if no version tag is supplied, assume there is no minimum version)

	dwStatus = LocalSdbQueryData(hSDB,
								 trMatch,
								 MINMSIVERSION,
								 &dwDataType,
								 rgbAttributeData,
								 NULL);

	if(ERROR_SUCCESS == dwStatus && REG_SZ == dwDataType)
	{
		DWORD dwSdbMS = 0;
		DWORD dwSdbLS = 0;
		if(fFalse == ParseVersionString((ICHAR*)(BYTE*)rgbAttributeData, dwSdbMS, dwSdbLS))
		{
			DEBUGMSG1(TEXT("APPCOMPAT: invalid minimum version string '%s' found."),
						 (ICHAR*)(BYTE*)rgbAttributeData);
			return false;
		}

		DWORD dwMsiMS = (rmj << 16) + rmm;
		DWORD dwMsiLS = (rup << 16) + rin;

		if(dwMsiMS < dwSdbMS || (dwMsiMS == dwSdbMS && dwMsiLS < dwSdbLS))
		{
			DEBUGMSG5(TEXT("APPCOMPAT: skipping this entry.  Minimum MSI version required: '%s'; current version: %d.%02d.%04d.%02d."),
						 (ICHAR*)(BYTE*)rgbAttributeData,
						 (const ICHAR*)(INT_PTR)rmj, (const ICHAR*)(INT_PTR)rmm, (const ICHAR*)(INT_PTR)rup, (const ICHAR*)(INT_PTR)rin);
			return false;
		}
		// else valid version supplied that is equal to or older than current version
	}

	//	2) APPLYPOINT tells us where this entry should be processed
	//    (if it isn't the current applypoint we skip this entry)
	dwStatus = LocalSdbQueryData(hSDB,
								 trMatch,
								 APPLYPOINT,
								 &dwDataType,
								 rgbAttributeData,
								 NULL);

	DWORD dwApplyPoint = iacpBeforeTransforms; // default value

	if(ERROR_SUCCESS == dwStatus && REG_DWORD == dwDataType)
	{
		dwApplyPoint = *((DWORD*)(BYTE*)rgbAttributeData);
	}

	if(dwApplyPoint != iacpApplyPoint)
	{
		DEBUGMSG(TEXT("APPCOMPAT: skipping transform because it should be applied at a different point of the install."));
		return false;
	}


	// now enumerate remaining optional data

	CTempBuffer<BYTE, 256> rgbDataNames;
	if(false == GetSdbDataNames(hSDB, trMatch, rgbDataNames))
		return true; // no remaining data to process

	bool fPackageCodeAttributeExists = false;
	bool fPackageCodeMatchFound      = false;
	
	for(ICHAR* pchName = (ICHAR*)(BYTE*)rgbDataNames; *pchName; pchName += lstrlen(pchName) + 1)
	{
		SHIMDBNS::TAGREF trData;
		dwStatus = LocalSdbQueryData(hSDB,
									 trMatch,
									 pchName,
									 &dwDataType,
									 rgbAttributeData,
									 &trData);

		if(dwStatus != ERROR_SUCCESS)
		{
			DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbQueryData failed unexpectedly.  Sdb may be invalid."));
			return false;
		}
		else if(dwDataType == REG_SZ &&
				  (0 == IStrCompI(pchName, MINMSIVERSION)))
		{
			// handled this one above
		}
		else if(dwDataType == REG_DWORD &&
				  (0 == IStrCompI(pchName, APPLYPOINT)))
		{
			// handled this one above
		}
		else if(dwDataType == REG_DWORD &&
				  (0 == IStrCompI(pchName, SHIMFLAGS)))
		{
			// handle this one elsewhere
		}
		else if((REG_SZ == dwDataType || REG_NONE == dwDataType) &&
				  0 == IStrNCompI(pchName, PROPPREFIX, (sizeof(PROPPREFIX)-1)/sizeof(ICHAR)))
		{
			// this is a property name - check for a value match
			MsiString strPropValue = riEngine.GetPropertyFromSz(pchName + (sizeof(PROPPREFIX)-1)/sizeof(ICHAR));

			DEBUGMSG2(TEXT("APPCOMPAT: testing Property value.  Property: '%s'; expected value: '%s'"),
						 pchName + (sizeof(PROPPREFIX)-1)/sizeof(ICHAR),
						 (ICHAR*)(BYTE*)rgbAttributeData);
			
			// compare works for missing property and REG_NONE data from SDB
			if(0 == strPropValue.Compare(iscExact, (ICHAR*)(BYTE*)rgbAttributeData)) // case-insensitive compare
			{
				// not a match
				DEBUGMSG3(TEXT("APPCOMPAT: mismatched attributes.  Property: '%s'; expected value: '%s'; true value: '%s'"),
							 pchName + (sizeof(PROPPREFIX)-1)/sizeof(ICHAR),
							 (ICHAR*)(BYTE*)rgbAttributeData,
							 (const ICHAR*)strPropValue);

				return false;
			}
		}
		else if(REG_SZ == dwDataType &&
				  0 == IStrNCompI(pchName, PACKAGECODE, (sizeof(PACKAGECODE)-1)/sizeof(ICHAR)))
		{
			fPackageCodeAttributeExists = true;
			
			DEBUGMSG1(TEXT("APPCOMPAT: testing PackageCode.  Expected value: '%s'"),
						 (ICHAR*)(BYTE*)rgbAttributeData);

			if(ristrPackageCode.Compare(iscExactI, (ICHAR*)(BYTE*)rgbAttributeData))
			{
				fPackageCodeMatchFound = true;
			}
		}
		else if(REG_SZ == dwDataType &&
				  0 == IStrNCompI(pchName, MSIDBCELL, (sizeof(MSIDBCELL)-1)/sizeof(ICHAR)))
		{
			// db cell lookup 

			DEBUGMSG1(TEXT("APPCOMPAT: testing cell data in '%s' table."),
						 (ICHAR*)(BYTE*)rgbAttributeData);

			if(false == FCheckDatabaseCell(hSDB, trData, riDatabase, (ICHAR*)(BYTE*)rgbAttributeData))
			{
				// if check failed, sub-function will do DEBUGMSG explaining why
				return false;	
			}
		}
		else
		{
			// don't understand this data tag - we'll just ignore it and move on
			DEBUGMSG2(TEXT("APPCOMPAT: ignoring unknown data.  Data name: '%s', data type: %d"),
						 pchName, (const ICHAR*)(INT_PTR)dwDataType);
		}
	}

	if(fPackageCodeAttributeExists == true && fPackageCodeMatchFound == false)
	{
		// not a match
		DEBUGMSG1(TEXT("APPCOMPAT: PackageCode attribute(s) exist, but no matching PackageCode found.  Actual PackageCode: '%s'"),
					 ristrPackageCode.GetString());

		return false;
	}

	return true;
}

enum ipcolColumnTypes
{
	ipcolPrimaryKeys,
	ipcolLookupColumns,
};

bool ProcessColumns(ipcolColumnTypes ipcolType,
						  SHIMDBNS::HSDB hSDB,
						  SHIMDBNS::TAGREF trMatch,
						  IMsiDatabase& riDatabase,
						  IMsiTable& riTable,
						  IMsiCursor& riCursor,
						  const ICHAR* szTable)
{
	DWORD dwStatus = 0;
	DWORD dwDataType = 0;
	CTempBuffer<BYTE, 256> rgbAttributeData;

	const ICHAR* szTagName = ipcolType == ipcolPrimaryKeys ? MSIDBCELLPKS : MSIDBCELLLOOKUPDATA;
	
	SHIMDBNS::TAGREF trData = 0;
	dwStatus = LocalSdbQueryData(hSDB,
								 trMatch,
								 szTagName,
								 &dwDataType,
								 rgbAttributeData,
								 &trData);

	if(dwStatus != ERROR_SUCCESS || REG_NONE != dwDataType)
	{
		// the missing tag is only a failure in the PrimaryKeys case
		// the LookupData tag is optional
		if(ipcolType == ipcolPrimaryKeys)
		{
			DEBUGMSG(TEXT("APPCOMPAT: database cell lookup failed.  Missing or invalid primary key data in appcompat database."));
			return false;
		}
		else
		{
			return true;
		}
	}

	CTempBuffer<BYTE, 256> rgbColumns;
	if(false == GetSdbDataNames(hSDB, trData, rgbColumns))
		return false;

	int iPKFilter = 0;
	
	for(ICHAR* pchColumn = (ICHAR*)(BYTE*)rgbColumns; *pchColumn; pchColumn += lstrlen(pchColumn) + 1)
	{
		CTempBuffer<BYTE, 256> rgbValue;
		DWORD dwDataType = 0;

		dwStatus = LocalSdbQueryData(hSDB,
									 trData,
									 pchColumn,
									 &dwDataType,
									 rgbValue,
									 NULL);

		if(ERROR_SUCCESS != dwStatus)
		{
			DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbQueryData failed unexpectedly.  Sdb may be invalid."));
			return false;
		}

		// get column index
		int iColIndex = riTable.GetColumnIndex(riDatabase.EncodeStringSz(pchColumn));

		if(0 == iColIndex)
		{
			// column doesn't exist in table
			DEBUGMSG2(TEXT("APPCOMPAT: database cell lookup failed.  Column '%s' does not exist in table '%s'."),
						 pchColumn, szTable);
			return false;
		}

		// load value into cursor
		bool fRes = false;
		if(ipcolType == ipcolPrimaryKeys)
		{
			iPKFilter |= iColumnBit(iColIndex);
			
			switch(dwDataType)
			{
			case REG_DWORD:
				fRes = riCursor.PutInteger(iColIndex, *((DWORD*)(BYTE*)rgbValue)) ? true : false;
				break;
			case REG_SZ:
				fRes = riCursor.PutString(iColIndex, *MsiString((ICHAR*)(BYTE*)rgbValue)) ? true : false;
				break;
			case REG_NONE:
				fRes = riCursor.PutNull(iColIndex) ? true : false;
				break;
			default:
				// unknown type for a primary key column
				// can't just ignore unknown data in this case because this is a primary key column and not using it
				// may cause unexpected results
				DEBUGMSG3(TEXT("APPCOMPAT: database cell lookup failed.  Unknown data type %d specified for column '%s' in table '%s'."),
							 (const ICHAR*)(INT_PTR)dwDataType, pchColumn, szTable);
				return false;
			};

			if(fRes == false)
			{
				// column can't take expected data type
				DEBUGMSG2(TEXT("APPCOMPAT: database cell lookup failed.  Column '%s' in table '%s' does not accept the lookup data."),
							 pchColumn, szTable);
				return false;
			}
		}
		else
		{
			// check for data in this row
			switch(dwDataType)
			{
			case REG_NONE:
				if(MsiString(riCursor.GetString(iColIndex)).TextSize() == 0)
					fRes = true;
				break;
			case REG_DWORD:
				if(riCursor.GetInteger(iColIndex) == *((DWORD*)(BYTE*)rgbValue))
					fRes = true;
				break;
			case REG_SZ:
				if(MsiString(riCursor.GetString(iColIndex)).Compare(iscExact, (ICHAR*)(BYTE*)rgbValue)) // case-sensitive compare
					fRes = true;
				break;
			default:
				DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: database cell lookup failed.  Unexpected cell lookup data in appcompat database."));
				return false;
			};
			
			if(fRes == false)
			{
				DEBUGMSG1(TEXT("APPCOMPAT: database cell lookup failed.  Expected cell data does not exist in table '%s'."),
							 szTable);
				return false;
			}
		}
	}

	if(ipcolType == ipcolPrimaryKeys)
	{
		// set cursor filter
		if(0 == iPKFilter)
		{
			DEBUGMSG(TEXT("APPCOMPAT: database cell lookup failed.  Missing primary key data in appcompat database."));
			return false;
		}

		riCursor.SetFilter(iPKFilter);
	}

	return true;
}

bool FCheckDatabaseCell(SHIMDBNS::HSDB hSDB,
								SHIMDBNS::TAGREF trMatch,
								IMsiDatabase& riDatabase,
								const ICHAR* szTable)
{
	PMsiRecord pError(0);
	PMsiTable pTable(0);
	DWORD dwStatus = 0;

	// STEP 1: load table and cursor
	if((pError = riDatabase.LoadTable(*MsiString(szTable), 0, *&pTable)))
	{
		DEBUGMSG1(TEXT("APPCOMPAT: database cell lookup failed.  Table '%s' does not exist"), szTable);
		return false;
	}
	
	PMsiCursor pCursor = pTable->CreateCursor(fFalse);
	if(pCursor == 0)
	{
		DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: unexpected failure: couldn't create cursor object"));
		return false;
	}

	
	// STEP 2: read primary key values and populate cursor
	if(false == ProcessColumns(ipcolPrimaryKeys, hSDB, trMatch, riDatabase, *pTable, *pCursor, szTable))
		return false;


	// STEP 3: locate row in table
	if(fFalse == pCursor->Next())
	{
		DEBUGMSG1(TEXT("APPCOMPAT: database cell lookup failed.  Expected row does not exist in table '%s'."),
					 szTable);
		return false;
	}


	// STEP 4 (optional): check lookup values in row
	if(false == ProcessColumns(ipcolLookupColumns, hSDB, trMatch, riDatabase, *pTable, *pCursor, szTable))
		return false;

	return true;
}

bool GetTransformTempDir(IMsiServices& riServices, IMsiPath*& rpiTempPath)
{
	MsiString strTempDir = GetTempDirectory();

	PMsiRecord pError = riServices.CreatePath(strTempDir, rpiTempPath);
	AssertRecordNR(pError);

	if(pError)
	{
		return false;
	}

	return true;
}

bool ApplyTransforms(SHIMDBNS::HSDB hSDB,
							SHIMDBNS::TAGREF trMatch,
							IMsiServices& riServices,
							IMsiDatabase& riDatabase,
							IMsiPath& riTempDir)
{
	if(riDatabase.GetUpdateState() != idsRead)
	{
		DEBUGMSG(TEXT("APPCOMPAT: cannot apply appcompat transforms - database is open read/write."));
		return true; // not a failure
	}
	
	SHIMDBNS::TAGREF trTransform = LocalSdbFindFirstTagRef(hSDB, trMatch, TAG_MSI_TRANSFORM_REF);

	while (trTransform != TAGREF_NULL)
	{
		SHIMDBNS::SDBMSITRANSFORMINFO MsiTransformInfo;

		BOOL bSuccess = LocalSdbReadMsiTransformInfo(hSDB, trTransform, &MsiTransformInfo);

		if(bSuccess)
		{
			PMsiRecord pError(0);
			MsiString strTransformPath;

			// creating a file in our acl'ed folder, need to elevate this block
			{
				CElevate elevate;

				pError = riTempDir.TempFileName(0, TEXT("mst"), fFalse, *&strTransformPath, 0); //?? need to secure this file?
				if(pError)
				{
					AssertRecordNR(pError);
					return false; // can't extract transforms if we can't get a temp file name
				}
				
				bSuccess = LocalSdbCreateMsiTransformFile(hSDB, (const ICHAR*)strTransformPath, &MsiTransformInfo);
				if(FALSE == bSuccess)
				{
					Debug(DWORD dwDebug = GetLastError());
					DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbCreateMsiTransformFile failed unexpectedly.  Sdb may be invalid."));
					return false;
				}
			
				// done elevating
			}

			// apply the transform
			// NOTE: we aren't going to validate the transform using the transforms suminfo properties
			// sufficient validation that this is the correct transform has been done above
			PMsiStorage pTransStorage(0);
			
			// don't call SAFER here - transform is from appcompat database and should be considered safe
			pError = OpenAndValidateMsiStorageRec(strTransformPath, stTransform, riServices, *&pTransStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
			if(pError)
			{
				AssertRecordNR(pError);
				return false; // can't apply transform if we can't open it
			}

			AssertNonZero(pTransStorage->DeleteOnRelease(true));

			DEBUGMSG1(TEXT("APPCOMPAT: applying appcompat transform '%s'."), (const ICHAR*)strTransformPath);
			pError = riDatabase.SetTransform(*pTransStorage, iteAddExistingRow|iteDelNonExistingRow|iteAddExistingTable|iteDelNonExistingTable|iteUpdNonExistingRow);
			if(pError)
			{
				AssertRecordNR(pError);
				return false; // can't apply transform if we can't open it
			}
		}
		else
		{
			DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbCreateMsiTransformFile failed unexpectedly.  Sdb may be invalid."));
			return false;
		}


		trTransform = LocalSdbFindNextTagRef(hSDB, trMatch, trTransform);
	}

	return true;
}


bool CMsiEngine::ApplyAppCompatTransforms(IMsiDatabase& riDatabase,
														const IMsiString& ristrProductCode,
														const IMsiString& ristrPackageCode,
														iacpAppCompatTransformApplyPoint iacpApplyPoint,
														iacsAppCompatShimFlags& iacsShimFlags,
#ifdef UNICODE
														bool fQuiet,
#else
														bool /*fQuiet*/,
#endif
														bool fProductCodeChanged,
														bool& fDontInstallPackage)
{
	class CCloseSDB
	{
	 public:
		 CCloseSDB(SHIMDBNS::HSDB hSDB) : m_hSDB(hSDB) {}
		 ~CCloseSDB() { LocalSdbReleaseDatabase(m_hSDB); }
	 protected:
		SHIMDBNS::HSDB m_hSDB;
	};
	
	iacsShimFlags = (iacsAppCompatShimFlags)0;
	fDontInstallPackage = false;

	// if the product code has changed (either from a major upgrade patch or a transform for a multi-language install)
	// then we reset m_fCAShimsEnabled and the guids and check for a reference to a shim in the new product
	if (fProductCodeChanged)
	{
		m_fCAShimsEnabled = false;
		memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
		memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));
	}

	SHIMDBNS::HSDB hSDB;
	SHIMDBNS::SDBMSIFINDINFO MsiFindInfo;
	DWORD dwStatus = 0;

#ifndef UNICODE
	// construct path to msimain.sdb
	ICHAR rgchSdbPath[MAX_PATH];
	if(0 == (MsiGetWindowsDirectory(rgchSdbPath, sizeof(rgchSdbPath)/sizeof(ICHAR))))
	{
		DEBUGMSG(TEXT("APPCOMPAT: can't get path to Windows folder."));
		return false;
	}
	IStrCat(rgchSdbPath, SDBDOSSUBPATH);

	hSDB = LocalSdbInitDatabase(HID_DATABASE_FULLPATH | HID_DOS_PATHS, rgchSdbPath);
#else
	hSDB = LocalSdbInitDatabase(HID_DATABASE_FULLPATH, SDBNTFULLPATH);
#endif

	if(NULL == hSDB)
	{
		DEBUGMSG(TEXT("APPCOMPAT: unable to initialize database."));
		return false;
	}

	CCloseSDB closeSDB(hSDB); // ensures that hSDB is closed before returning from fn
	
	DEBUGMSG1(TEXT("APPCOMPAT: looking for appcompat database entry with ProductCode '%s'."),
				 ristrProductCode.GetString());

	SHIMDBNS::TAGREF trMatch = LocalSdbFindFirstMsiPackage_Str(hSDB,
													 ristrProductCode.GetString(),
													 NULL,
													 &MsiFindInfo);

	if(TAGREF_NULL == trMatch)
	{
		DEBUGMSG(TEXT("APPCOMPAT: no matching ProductCode found in database."));
		return true;
	}

	PMsiPath pTempDir(0);
	do
	{
		ICHAR rgchTagName[255];

		SHIMDBNS::TAGREF trName = LocalSdbFindFirstTagRef(hSDB, trMatch, TAG_NAME);
		if (TAGREF_NULL != trName) {
			 LocalSdbReadStringTagRef(hSDB, trName, rgchTagName, 255);
		}

		DEBUGMSG1(TEXT("APPCOMPAT: matching ProductCode found in database.  Entry name: '%s'.  Testing other attributes..."),
					 rgchTagName);

		// found a product code match
		// check other characteristics of this database entry to ensure it belongs to this package
		if(false == FIsMatchingAppCompatEntry(hSDB, trMatch, ristrPackageCode, iacpApplyPoint, *this, riDatabase))
		{
			DEBUGMSG(TEXT("APPCOMPAT: found matching ProductCode in database, but other attributes do not match."));
			continue;
		}

		DEBUGMSG(TEXT("APPCOMPAT: matching ProductCode found in database, and other attributes match.  Applying appcompat fix."));

		iacsShimFlags = (iacsAppCompatShimFlags)GetShimFlags(hSDB, trMatch);


		// check if this entry contains APPHELP info or custom action shims
		SHIMDBNS::MSIPACKAGEINFO sPackageInfo;
		memset(&sPackageInfo, 0, sizeof(sPackageInfo));

#ifdef UNICODE // NT-only code follows

		if(MinimumPlatformWindowsNT51())
		{
			if (FALSE == APPHELP::SdbGetMsiPackageInformation(hSDB, trMatch, &sPackageInfo))
			{
				DEBUGMSG(TEXT("APPCOMPAT: SdbGetMsiPackageInformation failed unexpectedly."));
			}
			else
			{
				// if this entry contains apphelp info, make the apphelp call now
				if(sPackageInfo.dwPackageFlags & MSI_PACKAGE_HAS_APPHELP)
				{
					if(FALSE == APPHELP::ApphelpCheckMsiPackage(&(sPackageInfo.guidDatabaseID), &(sPackageInfo.guidID),
																			  0, fQuiet ? TRUE : FALSE))
					{
						// shouldn't install this app
						DEBUGMSG(TEXT("APPCOMPAT: ApphelpCheckMsiPackage returned FALSE.  This product will not be installed due to application compatibility concerns."));
						fDontInstallPackage = true;
						return false;
					}
				}

				// look for at least one custom action entry. We only accept the first matching sdb entry with custom
				// action shims. The AppCompat team has guaranteed that multiple matches will not exist even if multiple
				// transform matches exist.

				if (!m_fCAShimsEnabled)
				{
					// no CA shims found yet. Search this match entry
					SHIMDBNS::TAGREF trCustomAction = LocalSdbFindFirstTagRef(hSDB, trMatch, TAG_MSI_CUSTOM_ACTION);
					if (trCustomAction != TAGREF_NULL)
					{
						memcpy(&m_guidAppCompatDB, &sPackageInfo.guidDatabaseID, sizeof(sPackageInfo.guidDatabaseID));
						memcpy(&m_guidAppCompatID, &sPackageInfo.guidID, sizeof(sPackageInfo.guidID));
						m_fCAShimsEnabled = true;
					}
				}
			}
		}
#endif //UNICODE

		if(pTempDir == 0 &&
			false == GetTransformTempDir(m_riServices, *&pTempDir))
		{
			AssertSz(0, TEXT("Failed to determine temp directory for appcompat transforms."));
			DEBUGMSG(TEXT("APPCOMPAT: Failed to determine temp directory for appcompat transforms."));
			return false; // need to be able to get our temp dir
		}

		if(false == ApplyTransforms(hSDB, trMatch, m_riServices, riDatabase, *pTempDir))
		{
			AssertSz(0, TEXT("Failed to apply appcompat transform."));
			DEBUGMSG(TEXT("APPCOMPAT: Failed to apply appcompat transform."));
			continue;
		}
	}
	while (TAGREF_NULL != (trMatch = LocalSdbFindNextMsiPackage(hSDB, &MsiFindInfo)));

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\client.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       client.cpp
//
//--------------------------------------------------------------------------

/* client.cpp - DCOM access to install server, WIN only
____________________________________________________________________________*/

#include "precomp.h"
#include "_engine.h"
#include "msidspid.h"
#include "vertrust.h" // iauthEnum
#include "iconfig.h"  // icmruf
#include "rpcdce.h"    // RPC_C_AUTH*
#include "proxy.h"
#include "eventlog.h"

const GUID IID_IMsiServerProxy          = GUID_IID_IMsiServerProxy;
const GUID IID_IDispatch                = GUID_IID_IDispatch;


extern IMsiServices* g_piSharedServices;
IMsiRecord* UnserializeRecord(IMsiServices& riServices, int cbSize, char *pData);

extern int  g_iMajorVersion;

extern "C" HRESULT __stdcall DllGetVersion (DLLVERSIONINFO * pverInfo);

//____________________________________________________________________________
//
// CMsiServerProxy - proxy client for IMsiServer
//____________________________________________________________________________

class CMsiServerProxy : public IMsiServer
{
 public:
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();

	iesEnum         __stdcall RunScript(const ICHAR* szScriptFile, IMsiMessage& riMessage, boolean fRollbackEnabled);
	iesEnum         __stdcall InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
	boolean         __stdcall RecordShutdownReason();
	boolean         __stdcall Reboot();

	IMsiRecord*     __stdcall LocateComponent(const IMsiString& riComponentCode, IMsiRecord*& rpiRec);
	IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch);
	int             __stdcall DoInstall(ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
													const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions);
	IMsiRecord*     __stdcall RegisterUser(const ICHAR* szProductCode, const ICHAR* szUserName,
															 const ICHAR* szCompany, const ICHAR* szProductID);
	IMsiRecord*     __stdcall RemoveRunOnceEntry(const ICHAR* szEntry);
	boolean         __stdcall CleanupTempPackages(IMsiMessage& riMessage);
	unsigned int    __stdcall SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType);
	unsigned int    __stdcall SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, const ICHAR* szSource);
	unsigned int    __stdcall SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName);
	unsigned int    __stdcall RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD* pdwPrivileges);
	unsigned int    __stdcall CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *dwServerProcessId);

 public:  // constructor
 	void *operator new(size_t cb) { return AllocSpc(cb); }
	void operator delete(void * pv) { FreeSpc(pv); }
	CMsiServerProxy(IMsiServices& riServices, IMsiServer& riServer);
 protected:
	~CMsiServerProxy();  // protected to prevent creation on stack
 private:
	IMsiServer&		m_riServer;
	IMsiServices&	m_riServices;
	int				m_iRefCnt;
};

#define EOAC_STATIC_CLOAKING 0x20 // From NT5 headers

bool FCheckProxyInfo(void);

CMsiServerProxy::CMsiServerProxy(IMsiServices& riServices, IMsiServer& riServer)
	: m_riServer(riServer), 
		m_riServices(riServices), 
		m_iRefCnt(1)

{
//	SetAllocator(&riServices);

	// The remainder of the constructor sets the proxy's security to allow 
	// the server to impersonate the client.

	riServer.AddRef();
	riServices.AddRef();

	if (g_fWin9X)
	{
		AssertSz(fFalse, "Trying to create ServerProxy on win9x");
		return;
	}
	
	if (!FCheckProxyInfo())
	{
		AssertSz(fFalse, "Registered MSI.DLL is not the one being used. You will have problems with proxies.");
		return;
	}
	
		

	const DWORD iImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	DWORD iCapabilities   = 0;

	if (g_iMajorVersion >= 5)
	{
		iCapabilities = EOAC_STATIC_CLOAKING;
		DEBUGMSGV("Cloaking enabled.");
	}

	AssertNonZero(StartImpersonating()); // need to impersonate so that the proxy picks up the impersonation token if we're cloaking
	HRESULT hRes = OLE32::CoSetProxyBlanket(&riServer, RPC_C_AUTHN_WINNT,
		RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
		iImpLevel, NULL, iCapabilities);

	StopImpersonating();

	if (hRes != S_OK)
	{
		DEBUGMSG1(TEXT("SetProxyBlanket failed with: 0x%X"), (const ICHAR*)(INT_PTR)hRes);
		return; //!! What to do here; not much we can do, but we're gonna fail down the line
	}

}

CMsiServerProxy::~CMsiServerProxy()
{

	m_riServer.Release();
	m_riServices.Release();

}

HRESULT CMsiServerProxy::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiServer || riid == IID_IMsiServerProxy)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CMsiServerProxy::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiServerProxy::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
//	ReleaseAllocator();
	ENG::FreeServices();
	return 0;
}

iesEnum CMsiServerProxy::InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
	HRESULT hres;
	iesEnum iesRet;
	
	hres = IMsiServer_InstallFinalizeRemote_Proxy(&m_riServer, iesState, &riMessage, fUserChangedDuringInstall, &iesRet);

	if (FAILED(hres))
		return iesFailure;
		
	return iesRet;
}

boolean CMsiServerProxy::RecordShutdownReason()
{
	HRESULT hres;
	boolean fRet;
	
	hres = IMsiServer_RecordShutdownReasonRemote_Proxy(&m_riServer, &fRet);

	if (FAILED(hres))
		return false;
	
	return fRet;
}

boolean CMsiServerProxy::Reboot()
{
	HRESULT hres;
	boolean fRet;
	
	hres = IMsiServer_RebootRemote_Proxy(&m_riServer, &fRet);

	if (FAILED(hres))
		return false;
	
	return fRet;
}


int __stdcall CMsiServerProxy::DoInstall(ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
													  const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions)
{
	HRESULT hres;
	int retVal;

	g_MessageContext.DisableTimeout();  // server will handle timeouts over there
	Assert(szProduct != 0);
	hres = IMsiServer_DoInstallRemote_Proxy(&m_riServer, ireProductCode, szProduct, szAction, szCommandLine, szLogFile, iLogMode, fFlushEachLine, &riMessage, iioOptions, &retVal);
	g_MessageContext.EnableTimeout();
	
	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;

	return retVal;
	
}

IMsiRecord* CMsiServerProxy::SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord *piRec;
	
	Assert(szProductCode != 0);
	Assert(szPath != 0);
	hres = IMsiServer_SetLastUsedSourceRemote_Proxy(&m_riServer, szProductCode, szPath, fAddToList, fPatch, &cb, &precStream);

	if (FAILED(hres))
		return PostError(Imsg(idbgMarshalingFailed), hres);

	piRec = UnserializeRecord(m_riServices, cb, precStream);
	OLE32::CoTaskMemFree(precStream);	
	
	return piRec;
}

IMsiRecord* CMsiServerProxy::RegisterUser(const ICHAR* szProductKey, const ICHAR* szUserName,
														const ICHAR* szCompany, const ICHAR* szProductID)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord *piRec;
	
	Assert(szProductKey != 0);
	hres = IMsiServer_RegisterUserRemote_Proxy(&m_riServer, szProductKey, szUserName, szCompany,
														  szProductID, &cb, &precStream);

	if (FAILED(hres))
		return PostError(Imsg(idbgMarshalingFailed), hres);

	piRec = UnserializeRecord(m_riServices, cb, precStream);
	OLE32::CoTaskMemFree(precStream);	
	
	return piRec;
}

IMsiRecord* CMsiServerProxy::RemoveRunOnceEntry(const ICHAR* szEntry)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord *piRec;
	
	hres = IMsiServer_RemoveRunOnceEntryRemote_Proxy(&m_riServer, szEntry, &cb, &precStream);

	if (FAILED(hres))
		return PostError(Imsg(idbgMarshalingFailed), hres);

	piRec = UnserializeRecord(m_riServices, cb, precStream);
	OLE32::CoTaskMemFree(precStream);	
	
	return piRec;
}

boolean CMsiServerProxy::CleanupTempPackages(IMsiMessage& riMessage)
{
	HRESULT hres;
	boolean fRet;
	
	hres = IMsiServer_CleanupTempPackagesRemote_Proxy(&m_riServer, &riMessage, &fRet);

	if (FAILED(hres))
		return fFalse;
		
	return fRet;
}

unsigned int CMsiServerProxy::SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_SourceListClearByTypeRemote_Proxy(&m_riServer, szProductCode, szUserName, isrcType, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, const ICHAR* szSource)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_SourceListAddSourceRemote_Proxy(&m_riServer, szProductCode, szUserName, isrcType, szSource, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_SourceListClearLastUsedRemote_Proxy(&m_riServer, szProductCode, szUserName, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD* pdwPrivileges)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_RegisterCustomActionServerRemote_Proxy(&m_riServer, picacContext, rgchCookie, cbCookie, piCustomAction, pdwProcessId, piRemoteAPI, pdwPrivileges, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *pdwServerProcessId)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_CreateCustomActionServerRemote_Proxy(&m_riServer, icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, cbCookie, piCustomAction, pdwServerProcessId, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

char *SerializeRecord(IMsiRecord *piRecord, IMsiServices* piServices, int* pcb);


iesEnum STDMETHODCALLTYPE IMsiServer_InstallFinalize_Proxy(IMsiServer* piServer, iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
	HRESULT hres;
	iesEnum iesRet;
	
	hres = IMsiServer_InstallFinalizeRemote_Proxy(piServer, iesState, &riMessage, fUserChangedDuringInstall, &iesRet);
	if (FAILED(hres))
		return iesFailure;
		
	return iesRet;
}

int STDMETHODCALLTYPE IMsiServer_DoInstall_Proxy(IMsiServer* piServer, ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
																 const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions)
{
	HRESULT hres;
	int retVal;
	
	hres = IMsiServer_DoInstallRemote_Proxy(piServer, ireProductCode, szProduct, szAction, szCommandLine, szLogFile, iLogMode, fFlushEachLine, &riMessage, iioOptions, &retVal);
	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
	
}

boolean STDMETHODCALLTYPE IMsiServer_RecordShutdownReason_Proxy(IMsiServer* piServer)
{
	HRESULT hres;
	boolean retVal;
	
	hres = IMsiServer_RecordShutdownReasonRemote_Proxy(piServer, &retVal);
	if (FAILED(hres))
		return false;

	return retVal;
}

boolean STDMETHODCALLTYPE IMsiServer_Reboot_Proxy(IMsiServer* piServer)
{
	HRESULT hres;
	boolean retVal;
	
	hres = IMsiServer_RebootRemote_Proxy(piServer, &retVal);
	if (FAILED(hres))
		return false;

	return retVal;
}

IMsiRecord* STDMETHODCALLTYPE IMsiServer_SetLastUsedSource_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord* piRec;
	
	hres = IMsiServer_SetLastUsedSourceRemote_Proxy(piServer, szProductCode, szPath, fAddToList, fPatch, &cb, &precStream);

	if (FAILED(hres))
		return 0;

	if (g_piSharedServices == 0)
	{
		Assert(fFalse);
		return 0;
	}
		
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, precStream);

	return piRec;
}

IMsiRecord* STDMETHODCALLTYPE IMsiServer_RegisterUser_Proxy(IMsiServer* piServer, const ICHAR* szProductKey,
																					 const ICHAR* szUserName, const ICHAR* szCompany,
																					 const ICHAR* szProductID)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord* piRec;
	
	hres = IMsiServer_RegisterUserRemote_Proxy(piServer, szProductKey, szUserName, szCompany, szProductID, &cb, &precStream);

	if (FAILED(hres))
		return 0;

	if (g_piSharedServices == 0)
	{
		Assert(fFalse);
		return 0;
	}
		
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, precStream);

	return piRec;
}

IMsiRecord* STDMETHODCALLTYPE IMsiServer_RemoveRunOnceEntry_Proxy(IMsiServer* piServer, const ICHAR* szEntry)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord* piRec;
	
	hres = IMsiServer_RemoveRunOnceEntryRemote_Proxy(piServer, szEntry, &cb, &precStream);

	if (FAILED(hres))
		return 0;

	if (g_piSharedServices == 0)
	{
		Assert(fFalse);
		return 0;
	}
		
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, precStream);

	return piRec;
}

boolean STDMETHODCALLTYPE IMsiServer_CleanupTempPackages_Proxy(IMsiServer* piServer, IMsiMessage& riMessage)
{
	HRESULT hres;
	boolean retVal;
	
	hres = IMsiServer_CleanupTempPackagesRemote_Proxy(piServer, &riMessage, &retVal);
	if (FAILED(hres))
		return false;

	return retVal;


}

unsigned int STDMETHODCALLTYPE IMsiServer_SourceListClearByType_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType)
{
	HRESULT hres;
	unsigned int retVal;
	
	hres = IMsiServer_SourceListClearByTypeRemote_Proxy(piServer, szProductCode, szUserName, isrcType, &retVal);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
}


unsigned int STDMETHODCALLTYPE IMsiServer_SourceListAddSource_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType, const ICHAR* szSource)
{
	HRESULT hres;
	unsigned int retVal;
	
	hres = IMsiServer_SourceListAddSourceRemote_Proxy(piServer, szProductCode, szUserName, isrcType, szSource, &retVal);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
}

unsigned int STDMETHODCALLTYPE IMsiServer_SourceListClearLastUsed_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName)
{
	HRESULT hres;
	unsigned int retVal;
	
	hres = IMsiServer_SourceListClearLastUsedRemote_Proxy(piServer, szProductCode, szUserName, &retVal);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
}

unsigned int STDMETHODCALLTYPE IMsiServer_RegisterCustomActionServer_Proxy(IMsiServer* piServer, icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD *pdwPrivileges)
{
	HRESULT hRes;
	unsigned int retVal;
	hRes = IMsiServer_RegisterCustomActionServerRemote_Proxy(piServer, picacContext, rgchCookie, cbCookie, piCustomAction, pdwProcessId, piRemoteAPI, pdwPrivileges, &retVal);

	if (FAILED(hRes))
		return ERROR_INSTALL_SERVICE_FAILURE;

	return retVal;
}

unsigned int STDMETHODCALLTYPE IMsiServer_CreateCustomActionServer_Proxy(IMsiServer* piServer, const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *pdwServerProcessId)
{
	HRESULT hRes;
	unsigned int retVal;
	hRes = IMsiServer_CreateCustomActionServerRemote_Proxy(piServer, icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, cbCookie, piCustomAction, pdwServerProcessId, &retVal);

	if (FAILED(hRes))
		return ERROR_INSTALL_SERVICE_FAILURE;

	return retVal;
}

IMsiMessage *g_piMessage = 0;

HRESULT STDMETHODCALLTYPE IMsiServer_InstallFinalize_Stub(IMsiServer* piServer, iesEnum iesState, IMsiMessage * piMessage, boolean fUserChangedDuringInstall, iesEnum* piesRet)
{
	CResetImpersonationInfo impReset;
	*piesRet = piServer->InstallFinalize(iesState, *piMessage, fUserChangedDuringInstall);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_DoInstall_Stub(IMsiServer* piServer, ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
																	 const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage * piMessage, iioEnum iioOptions, int *retVal)
{
	CResetImpersonationInfo impReset;
	*retVal = piServer->DoInstall(ireProductCode, szProduct, szAction, szCommandLine, szLogFile, iLogMode, fFlushEachLine, *piMessage, iioOptions);
	return S_OK;	
}

HRESULT STDMETHODCALLTYPE IMsiServer_RecordShutdownReason_Stub(IMsiServer* piServer, boolean * pretVal)
{
	boolean fRet = false;
	
	if (piServer)
	{
		CResetImpersonationInfo impReset;
		{
			// set impersonation on this thread to COM impersonation
			CCoImpersonate impersonate;

			fRet = piServer->RecordShutdownReason();
		}
	}
	
	if (pretVal)
		*pretVal = fRet;
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_Reboot_Stub(IMsiServer* piServer, boolean * pretVal)
{
	boolean fRet = false;
	
	if (piServer)
	{
		CResetImpersonationInfo impReset;
		{
			// set impersonation on this thread to COM impersonation
			CCoImpersonate impersonate;

			fRet = piServer->Reboot();
		}
	}
	
	if (pretVal)
		*pretVal = fRet;
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SetLastUsedSource_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch, int* pcb, char **pprecStream)
{
	CResetImpersonationInfo impReset;
	PMsiRecord piRec(0);

	piRec = piServer->SetLastUsedSource(szProductCode, szPath, fAddToList, fPatch);
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	*pprecStream = SerializeRecord(piRec, g_piSharedServices, pcb);
	
	return S_OK;

}

HRESULT STDMETHODCALLTYPE IMsiServer_RegisterUser_Stub(IMsiServer* piServer, const ICHAR* szProductKey,
																			  const ICHAR* szUserName, const ICHAR* szCompany,
																			  const ICHAR* szProductID,
																			  int* pcb, char **pprecStream)
{
	CResetImpersonationInfo impReset;
	CCoImpersonate impersonate;
	PMsiRecord piRec(0);

	piRec = piServer->RegisterUser(szProductKey, szUserName, szCompany, szProductID);
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	*pprecStream = SerializeRecord(piRec, g_piSharedServices, pcb);
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_RemoveRunOnceEntry_Stub(IMsiServer* piServer, const ICHAR* szEntry,
																				 int* pcb, char **pprecStream)
{
	CResetImpersonationInfo impReset;
	PMsiRecord piRec(0);

	piRec = piServer->RemoveRunOnceEntry(szEntry);
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	*pprecStream = SerializeRecord(piRec, g_piSharedServices, pcb);
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_CleanupTempPackages_Stub(IMsiServer* piServer, IMsiMessage * piMessage, boolean * pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->CleanupTempPackages(*piMessage);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SourceListClearByType_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, unsigned int * pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->SourceListClearByType(szProductCode, szUserName, isrcType);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SourceListAddSource_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, const ICHAR* szSource, unsigned int * pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->SourceListAddSource(szProductCode, szUserName, isrcType, szSource);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SourceListClearLastUsed_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, unsigned int * pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->SourceListClearLastUsed(szProductCode, szUserName);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_RegisterCustomActionServer_Stub(IMsiServer* piServer, icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD *pdwPrivileges, unsigned int *pretVal)
{
	CResetImpersonationInfo impReset;
	if (!picacContext)
		return E_FAIL;
	*pretVal = piServer->RegisterCustomActionServer(picacContext, rgchCookie, cbCookie, piCustomAction, pdwProcessId, piRemoteAPI, pdwPrivileges);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_CreateCustomActionServer_Stub(IMsiServer* piServer, const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *pdwServerProcessId, unsigned int *pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->CreateCustomActionServer(icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, cbCookie, piCustomAction, pdwServerProcessId);
	return S_OK;
}

imsEnum STDMETHODCALLTYPE IMsiMessage_Message_Proxy(IMsiMessage *piMessage, imtEnum imt, IMsiRecord& riRecord)
{
	HRESULT hres;
	imsEnum imsRet;
	char *pchRecord;
	int cb;
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return imsError;
	pchRecord = SerializeRecord(&riRecord, g_piSharedServices, &cb);
	
	hres = IMsiMessage_MessageRemote_Proxy(piMessage, imt, cb, pchRecord, &imsRet);

	OLE32::CoTaskMemFree(pchRecord);
	
	if (FAILED(hres))
		return imsError;

	return imsRet;
}


HRESULT STDMETHODCALLTYPE IMsiMessage_Message_Stub(IMsiMessage *piMessage, imtEnum imt, int cb, char *pchRecord, imsEnum* pims) 
{
	PMsiRecord piRec(0);
	
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, pchRecord);

	*pims = piMessage->Message(imt, *piRec);
	return S_OK;
}

imsEnum STDMETHODCALLTYPE IMsiMessage_MessageNoRecord_Proxy(IMsiMessage *piMessage, imtEnum imt)
{
	HRESULT hres;
	imsEnum imsRet;
	
	hres = IMsiMessage_MessageNoRecordRemote_Proxy(piMessage, imt, &imsRet);

	if (FAILED(hres))
		return imsError;

	return imsRet;
}

HRESULT STDMETHODCALLTYPE IMsiMessage_MessageNoRecord_Stub(IMsiMessage *piMessage, imtEnum imt, imsEnum* pims) 
{
	*pims = piMessage->MessageNoRecord(imt);
	return S_OK;
}

char *SerializeRecord(IMsiRecord *piRecord, IMsiServices* piServices, int* pcb)
{
	int cbData;
	
	*pcb = 0;
	if (piRecord != 0)
	{
		PMsiStream piStream(0);

		piServices->AllocateMemoryStream(512, *&piStream);

		piServices->FWriteScriptRecordMsg(ixoFullRecord, *piStream, *piRecord);

		cbData = piStream->GetIntegerValue() - piStream->Remaining();
		
		// We need to find a better way that doesn't cause the extra memory allocation
		piStream->Reset();
		char *pch = (char *)OLE32::CoTaskMemAlloc(cbData);
		if (pch == 0)
			return 0;
		piStream->GetData(pch, cbData);
		*pcb = cbData;
		return pch;
	}
	
	return 0;

}

IMsiRecord* UnserializeRecord(IMsiServices& riServices, int cbSize, char *pData)
{
	PMsiStream piStream(0);
	char *pch;
	IMsiRecord *piRec = 0;

	if (cbSize == 0)
		return 0;
	// Create the returned record
	pch = pData;
	piStream = riServices.CreateStreamOnMemory(pch, cbSize);

	piRec = riServices.ReadScriptRecordMsg(*piStream);

	return piRec;
}

IMsiServer* CreateMsiServerProxyFromRemote(IMsiServer& riDispatch)
{
	
	IMsiServices* piServices = ENG::LoadServices();
	if (piServices == 0)
		return 0;
	IMsiServer* piServer = 0;
	//
	// see if the proxy information is correct
	//
	if (FCheckProxyInfo())
	{
		piServer = new CMsiServerProxy(*piServices, riDispatch);
	}
	else
	{
		DEBUGMSGE(EVENTLOG_ERROR_TYPE,
					 EVENTLOG_TEMPLATE_INCORRECT_PROXY_REGISTRATION,
					 TEXT("(NULL)"));
	}
	if (piServer == 0)
		ENG::FreeServices();
	return piServer;
}

bool FCheckProxyInfo()
{
	ICHAR rgchKey[MAX_PATH];
	ICHAR szDllVersion [MAX_PATH];
	DLLVERSIONINFO verInfo;
	unsigned char rgchDllVersion[MAX_PATH];
	DWORD cbLen;
	DWORD type;
	HKEY hkey;


	const GUID IID_IMsiMessageRPCClass	= GUID_IID_IMsiMessageRPCClass;
	extern HINSTANCE g_hInstance;

	wsprintf(rgchKey, TEXT("CLSID\\{%08lX-0000-0000-C000-000000000046}\\DllVersion"), IID_IMsiMessage.Data1);

	cbLen = sizeof(rgchDllVersion);
	
	if (MsiRegOpen64bitKey(HKEY_CLASSES_ROOT, rgchKey, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
	{
		DWORD hres = REG::RegQueryValueEx(hkey, NULL, NULL, &type, rgchDllVersion, &cbLen);
		REG::RegCloseKey(hkey);

		if (hres == ERROR_SUCCESS)
		{
			verInfo.cbSize = sizeof (DLLVERSIONINFO);
			DllGetVersion (&verInfo);
			wsprintf (szDllVersion, TEXT("%d.%d.%d"), verInfo.dwMajorVersion, verInfo.dwMinorVersion, verInfo.dwBuildNumber);
			if (!IStrCompI(szDllVersion, (ICHAR *)rgchDllVersion))
			{
				return true;
			}	
		}
	}

	return false;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\camgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       camgr.cpp
//
//--------------------------------------------------------------------------

// The Custom Action Manager is responsible for complete management of remote servers, 
// actions running on them, and API calls coming from them. It manages the lifetime of
// the API thread, stores interface ponters to remote processes based on context, and
// determines the correct way to create CA servers (based on context and client/server)
//!! future: in an ideal world, even inproc actions would run through the mananger so
//!!   that all actions are managed at a single location.

#include "precomp.h" 
#include "_camgr.h"
#include "_msiutil.h"
#include "_engine.h"
#include "_autoapi.h"

CMsiCustomActionManager::CMsiCustomActionManager(bool fRemapHKCU) :
	m_fRemapHKCU(fRemapHKCU), m_piGIT(0), m_hRemoteAPIEvent(0), m_dwRemoteAPIThread(0), m_hRemoteAPIThread(0), m_pRemoteAPI(0)
{
	InitializeCriticalSection(&m_csCreateProxy);
	for (int i=0; i<icacNext; i++)
	{
		m_CustomActionInfo[i].dwServerProcess = 0;
		m_CustomActionInfo[i].hServerProcess = 0;
		m_CustomActionInfo[i].dwGITCookie = 0;
	}
};

CMsiCustomActionManager::~CMsiCustomActionManager()
{
	// we should never have a custom action server this late, but if for
	// some reason we do, kill it with extreme prejudice.
	for (int icacContext=icacFirst; icacContext < icacNext; icacContext++)
	{
		if (m_CustomActionInfo[icacContext].hServerProcess)
		{
			TerminateProcess(m_CustomActionInfo[icacContext].hServerProcess, 0);
			CloseHandle(m_CustomActionInfo[icacContext].hServerProcess);
			m_CustomActionInfo[icacContext].hServerProcess = 0;
			m_CustomActionInfo[icacContext].dwServerProcess = 0;
		}
	}

	// if we've got a GIT, release it.
	if (m_piGIT)
	{
		m_piGIT->Release();
		m_piGIT = 0;
	}
	DeleteCriticalSection(&m_csCreateProxy);
}


///////////////////////////////////////////////////////////////////////
// verifies that the HKCU remapping flag for elevated servers matches
// the requested stase. If not, it shuts down the elevated servers and
// refreshes the desired state. Returns true if the state was already
// correct, false otherwise.
bool CMsiCustomActionManager::EnsureHKCUKeyMappingState(bool fRemapHKCU)
{
	if (m_fRemapHKCU == fRemapHKCU)
		return true;

	m_fRemapHKCU = fRemapHKCU;
	ShutdownSpecificCustomActionServer(icac32Elevated);
#ifdef WIN64
	ShutdownSpecificCustomActionServer(icac64Elevated);
#endif
	return false;
}


// RunCustomAction runs the specified DLL and entry point in the specified context,
// creating a custom action server if necessary. This function may connect to the service
// if called from the client. 
HRESULT CMsiCustomActionManager::RunCustomAction(icacCustomActionContext icacContext,
		const ICHAR* szPath, const ICHAR* szEntryPoint, MSIHANDLE hInstall, 
		bool fDebugBreak, bool fDisableMessages, bool fAppCompat, const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID,
		IMsiMessage& riMessage, const ICHAR* szAction, unsigned long* pulRet)
{
	// GetCustomActionInterface will create the server if needed and return
	// an AddRef-ed interface pointer.
	PMsiCustomAction piAction = GetCustomActionInterface(true, icacContext);

	if (piAction)
	{
		// remote ThreadId is used to disable message processing during a 
		// synchronous custom action (to avoid deadlock in UI handler)
		DWORD dwRemoteThreadId = 0;

		// increment context action refcount to enable API handler for this 
		// context
		if (m_pRemoteAPI)
			m_pRemoteAPI->BeginAction(icacContext);

		// set-up the remote process for the DLL action. The thread to run
		// the action is created in a suspended state and initialized.
		if (ERROR_SUCCESS == piAction->PrepareDLLCustomAction(szAction, szPath, szEntryPoint, hInstall, 
			fDebugBreak, fAppCompat, pguidAppCompatDB, pguidAppCompatID, &dwRemoteThreadId))
		{
			// disable thread messages to the UI handler from the remote thread
			if (fDisableMessages)
				g_MessageContext.DisableThreadMessages(dwRemoteThreadId);

			// if in the client, pass rights to the foreground to the CA server. 
			if (g_scServerContext == scClient)
				USER32::AllowSetForegroundWindow(m_CustomActionInfo[icacContext].dwServerProcess);

			// re-enable the remote thread to run the action
			piAction->RunDLLCustomAction(dwRemoteThreadId, pulRet);

			// re-enable messages from all threads
			if (fDisableMessages)
				g_MessageContext.EnableMessages();

			// check that all handles are closed based on the thread Id in the
			// remote process
			UINT cHandles = 0;
			if ((cHandles = CheckAllHandlesClosed(true, dwRemoteThreadId)) != 0)
			{
				// if messages are disabled for this action, leaked handle notification
				// must also be disabled.
				if (!fDisableMessages)
					riMessage.Message(imtInfo, *PMsiRecord(::PostError(Imsg(idbgCustomActionLeakedHandle), szAction, cHandles)));
			}

			piAction->FinishDLLCustomAction(dwRemoteThreadId);
		}

		// decrement context action refcount to disable the API handler for this 
		// context. This prevents "stale" threads from misbehaving.
		if (m_pRemoteAPI)
			m_pRemoteAPI->EndAction(icacContext);

		return ERROR_SUCCESS;
	}
	return ERROR_FUNCTION_FAILED;
}

#define NO_CA_POINTER { \
	const ICHAR rgchMsg[] = TEXT("Failed to get IMsiCustomAction*"); \
	AssertSz(0, rgchMsg); \
	DEBUGMSG(rgchMsg); \
}
#define GET_CA_POINTER  \
	PMsiCustomAction piAction = NULL; \
	piAction = GetCustomActionInterface(true, \
													IsImpersonating(false) ? icac32Impersonated : icac32Elevated);


HRESULT CMsiCustomActionManager::QueryPathOfRegTypeLib(REFGUID guid,
										unsigned short wVerMajor, unsigned short wVerMinor,
										LCID lcid, OLECHAR *lpszPathName, int cchPath)
{
	GET_CA_POINTER
	if (piAction)
		return piAction->QueryPathOfRegTypeLib(guid, wVerMajor, wVerMinor, lcid,
															lpszPathName, cchPath);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

HRESULT
CMsiCustomActionManager::ProcessTypeLibrary(const OLECHAR* szLibID, LCID lcidLocale, 
											const OLECHAR* szTypeLib, const OLECHAR* szHelpPath, 
											int fRemove, int *fInfoMismatch)
{
	GET_CA_POINTER
	if (piAction)
		return piAction->ProcessTypeLibrary(szLibID, lcidLocale, szTypeLib, szHelpPath, 
														fRemove, fInfoMismatch);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLInstallDriverEx(int cDrvLen, const ICHAR* szDriver,
														  const ICHAR* szPathIn, ICHAR* szPathOut,
														  WORD cbPathOutMax, WORD* pcbPathOut,
														  WORD fRequest, DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLInstallDriverEx(cDrvLen, szDriver, szPathIn, szPathOut,
													cbPathOutMax, pcbPathOut, fRequest, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLConfigDriver(WORD fRequest,
										const ICHAR* szDriver, const ICHAR* szArgs,
										ICHAR* szMsg, WORD cbMsgMax, WORD* pcbMsgOut)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLConfigDriver(fRequest, szDriver, szArgs,
															szMsg, cbMsgMax, pcbMsgOut);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLRemoveDriver(const ICHAR* szDriver, int fRemoveDSN,
										DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLRemoveDriver(szDriver, fRemoveDSN, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLInstallTranslatorEx(int cTranLen, const ICHAR* szTranslator,
																const ICHAR* szPathIn, ICHAR* szPathOut,
																WORD cbPathOutMax, WORD* pcbPathOut,
																WORD fRequest, DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLInstallTranslatorEx(cTranLen, szTranslator,
													szPathIn, szPathOut, cbPathOutMax, pcbPathOut,
													fRequest, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLRemoveTranslator(const ICHAR* szTranslator, DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLRemoveTranslator(szTranslator, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLConfigDataSource(WORD fRequest,
										const ICHAR* szDriver, const ICHAR* szAttributes,
										DWORD cbAttrSize)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLConfigDataSource(fRequest, szDriver,
													szAttributes, cbAttrSize);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLInstallDriverManager(ICHAR* szPath, WORD cbPathMax,
																 WORD* pcbPathOut)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLInstallDriverManager(szPath, cbPathMax, pcbPathOut);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLRemoveDriverManager(DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLRemoveDriverManager(pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

short
CMsiCustomActionManager::SQLInstallerError(WORD iError, DWORD* pfErrorCode,
														 ICHAR* szErrorMsg, WORD cbErrorMsgMax,
														 WORD* pcbErrorMsg)
{
	GET_CA_POINTER
	if (piAction)
		return (short)piAction->SQLInstallerError(iError, pfErrorCode, szErrorMsg,
													cbErrorMsgMax, pcbErrorMsg);
	else
	{
		NO_CA_POINTER
		return -3;  // none of the documented return values
	}
}

extern IMsiRecord* UnserializeRecord(IMsiServices& riServices, int cbSize, char *pData);

// RunScriptAction takes the specified script and runs it in the specified context, 
// creating a custom action server if necessory. This function may connect to the service
// if called from the client. The IDispatch interface is from an engine (or for deferred
// actions, a generated pseudo-context).
HRESULT CMsiCustomActionManager::RunScriptAction(icacCustomActionContext icacContext,
	int icaType, IDispatch* piDispatch, const ICHAR* szSource, const ICHAR *szTarget, 
	LANGID iLangId, bool fDisableMessages, int* iScriptResult, IMsiRecord **piMsiRec)
{
	Assert(piMsiRec && szSource && szTarget && piDispatch && iScriptResult);
	
	// GetCustomActionInterface will create the server if needed and return
	// an AddRef-ed interface pointer.
	PMsiCustomAction piAction = GetCustomActionInterface(true, icacContext);

	if (piAction)
	{
		char *pchRecord = 0;
		int pcb = 0;

		// impersonate ThreadId is used to disable message processing during a 
		// synchronous custom action (to avoid deadlock in UI handler)
		DWORD dwImpersonateThreadId = GetCurrentThreadId();

		// store the impersonate ThreadId in the Session object
		((CAutoEngine*)(piDispatch))->m_dwThreadId = dwImpersonateThreadId;

		m_pRemoteAPI->BeginAction(icacContext);

		// disable thread messages to the UI handler from the remote thread
		if (fDisableMessages)
			g_MessageContext.DisableThreadMessages(dwImpersonateThreadId);

		// if in the client, pass rights to the foreground to the CA server. 
		if (g_scServerContext == scClient)
			USER32::AllowSetForegroundWindow(m_CustomActionInfo[icacContext].dwServerProcess);

		HRESULT hRes = piAction->RunScriptAction(icaType, piDispatch, szSource, szTarget, iLangId, iScriptResult, &pcb, &pchRecord);

		// re-enable messages from all threads
		if (fDisableMessages)
			g_MessageContext.EnableMessages();

		m_pRemoteAPI->EndAction(icacContext);
		
		if (hRes != S_OK)
		{
			// problem marshaling
			DEBUGMSGV(TEXT("Failed to marshal script action."));
			return E_FAIL;
		}
		else
		{
			// marshaling was OK. Unserialize record with potential error information
			IMsiServices* piServices = ENG::LoadServices();
			*piMsiRec = UnserializeRecord(*piServices, pcb, pchRecord);
			OLE32::CoTaskMemFree(pchRecord);	
			ENG::FreeServices();
		}
	}
	else
	{
		// problem obtaining custom action interface
		DEBUGMSGV(TEXT("Failed to obtain custom action interface"));
		return E_FAIL;
	}
	return ERROR_SUCCESS;
}

bool CMsiCustomActionManager::MsgWaitForThreadOrEvent()
{
	HANDLE rghWaitArray[2] = {m_hRemoteAPIThread, m_hRemoteAPIEvent};
	for(;;)
	{
		DWORD iWait = WIN::MsgWaitForMultipleObjects(2, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
		if (iWait == WAIT_OBJECT_0 + 2)  
		{		
			// window message, need to pump until the queue is clear
			MSG msg;
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				WIN::TranslateMessage(&msg);
				WIN::DispatchMessage(&msg);
			}
			continue;
		}
		else if (iWait == WAIT_OBJECT_0 + 1)
		{
			// m_hRemoteAPIEvent was signaled, we are ready
			return true;
		}
		else if (iWait == WAIT_OBJECT_0)
		{
			// because the thread is first in the wait array, WAIT_OBJECT_0 means the 
			// thread died before it could get anywhere
			return false;
		}
		else if (iWait == 0xFFFFFFFF) // should be the same on 64bit;
		{
			// error
			AssertSz(0, "Error in MsgWait");
			return false;
		}
	}
}
	
// checks for an interface with the appropriate context in the GIT. If one exists, returns it (the act of
// retrieving from the GIT AddRefs the interface). Otherwise, calls the service to create the appropriate
// interface function.
IMsiCustomAction *CMsiCustomActionManager::GetCustomActionInterface(bool fCreate, icacCustomActionContext icacDesiredContext)
{
	// creation and destruction of any proxy interface must be atomic
	EnterCriticalSection(&m_csCreateProxy);
	IMsiCustomAction *piCustomAction = NULL;

	// if in the service and the client token is actually system, then a request for an impersonated context maps
	// to a request for the elevated context. Since impersonated and elevated servers are the same, we consolidate
	// the 4 servers into 2.
	if (g_scServerContext == scService)
	{
		// don't close this handle, it belongs to the message context
		HANDLE hUserToken = GetUserToken();

		if (hUserToken && IsLocalSystemToken(hUserToken))
		{
			if (icacDesiredContext == icac32Impersonated)
			{
				icacDesiredContext = icac32Elevated;
			}
			else if (icacDesiredContext == icac64Impersonated)
			{
				icacDesiredContext = icac64Elevated;
			}
		}
	}

	// ensure that we have a GIT pointer. Only one GIT exists per process, but can have multiple
	// interface to it. This interface is inherently thread safe without marshaling.
	if (!m_piGIT)
	{
		if (S_OK != OLE32::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&m_piGIT))
		{
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}
	}
 
	// We can lose connection with the CA server in 5 ways: We could lose our GIT cookie, lose the data at that cookie,
	// lose the process handle, the process could die, or the object in the CA server could be destroyed, 
	// if any of that has happened, we are lost and need to kill the CA server and regenerate everything
	bool fConnectionValid = true;
	if (!m_CustomActionInfo[icacDesiredContext].dwGITCookie ||
	    !m_CustomActionInfo[icacDesiredContext].hServerProcess || 
		WAIT_OBJECT_0 == WaitForSingleObject(m_CustomActionInfo[icacDesiredContext].hServerProcess, 0))
		fConnectionValid = false;
	else
	{	
		// if successful, this calls AddRef() on the interface
		if (S_OK != m_piGIT->GetInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie, IID_IMsiCustomAction, reinterpret_cast<void **>(&piCustomAction)))
			fConnectionValid = false;
		
		if (fConnectionValid && FAILED(SetMinProxyBlanketIfAnonymousImpLevel(piCustomAction)))
			fConnectionValid = false;

 		// verify the returned proxy still points to a valid object in the server process
		if (fConnectionValid && !OLE32::CoIsHandlerConnected(piCustomAction))
		{
			fConnectionValid = false;
		}
	}

	// if the connection is busted, clean up the custom action server state. Note that the RemoteAPI object is 
	// possibly still valid.
	if (!fConnectionValid)
	{
		if (m_CustomActionInfo[icacDesiredContext].dwGITCookie || m_CustomActionInfo[icacDesiredContext].hServerProcess)
		{
			// if either the cookie or process exists, we think we should have a connection but don't.
			// otherwise we think this is a first-time creation
			DEBUGMSGV(TEXT("Lost connection to custom action server process. Attempting to regenerate."));
		}
		
		// clean up GIT data
		if (m_CustomActionInfo[icacDesiredContext].dwGITCookie)
		{
			m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
			m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
		}

		// kill process
		if (m_CustomActionInfo[icacDesiredContext].hServerProcess)
		{
			// the handle could be open but the process dead. Terminate the process if its still running
			if (WAIT_TIMEOUT == WaitForSingleObject(m_CustomActionInfo[icacDesiredContext].hServerProcess, 0))
				TerminateProcess(m_CustomActionInfo[icacDesiredContext].hServerProcess, 0);

			// once its guaranteed that the process is gone, close the handle
			CloseHandle(m_CustomActionInfo[icacDesiredContext].hServerProcess);
			m_CustomActionInfo[icacDesiredContext].hServerProcess = 0;
		}

		// verify ProcessID is 0
		m_CustomActionInfo[icacDesiredContext].dwServerProcess = 0;

		// if fCreate is false, there is no need to do anything else
		if (!fCreate)
		{
			LeaveCriticalSection(&m_csCreateProxy);			
			return NULL;
		}
			
		// now we need to create a remote MSI handler if one doesn't exist. Because we will be passing an 
		// interface to this object across to the CA server process, we need to carefully manage its lifetime. 
		// We can't call CoUnitialize on the apartment owning the object, so the object is created in its own 
		// thread because this thread could be STA meaning thread==apartment.
		if (!m_hRemoteAPIThread)
		{
			m_hRemoteAPIEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			m_hRemoteAPIThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
								(LPTHREAD_START_ROUTINE)CustomActionManagerThread, (LPVOID)this, 0, &m_dwRemoteAPIThread);
			if (!m_hRemoteAPIThread)
			{
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
				m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
			
			// its unclear if we need to pump messages here, but since we're on a thread that 
			// could have COM running, the assumption is that we do.
			if (!MsgWaitForThreadOrEvent())
			{
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
				m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
		}

		// Signal CreateEvent to waken the manager thread and let it know to create 
		// the proxy
		m_icacCreateContext = icacDesiredContext;
		SetEvent(m_hCreateEvent);

		// then wait for the manager thread to signal the RemoteAPIEvent to signify that
		// the proxy is ready or that the creation has failed. Its not clear if we 
		// need to pump messages here, but since we're on a thread that could have COM
		// running, the assumption is that we do.
		if (!MsgWaitForThreadOrEvent())
		{
			m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
			m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}

		// when the thread comes back, the interface might be ready in the GIT. If there
		// was a problem creating the server, the GIT entry will be missing or empty
		// we don't bother checking that the process is still running or that the proxy
		// is still connected, because nobody should be talking to the process right now but us.
		// both of of those failures are non-fixable and will just cause a falure return 
		// from the actual invocation call
		if (m_CustomActionInfo[icacDesiredContext].dwGITCookie && m_CustomActionInfo[icacDesiredContext].hServerProcess)
			m_piGIT->GetInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie, IID_IMsiCustomAction, reinterpret_cast<void **>(&piCustomAction));
		
		if (piCustomAction)
		{
			if (FAILED(SetMinProxyBlanketIfAnonymousImpLevel(piCustomAction)))
			{
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
				m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
		}
	}

	LeaveCriticalSection(&m_csCreateProxy);
	return piCustomAction;
}


void CMsiCustomActionManager::ShutdownSpecificCustomActionServer(icacCustomActionContext iContext)
{
	// get a connection to the CA server, but DO NOT create one if it doesn't exist (since we're just
	// going to shut it down). If successful, calls AddRef() on the returned interface
	PMsiCustomAction piCustomAction = GetCustomActionInterface(/*fCreate=*/false, iContext);

	// revoke the interface from the GIT
	if (m_CustomActionInfo[iContext].dwGITCookie)
	{
		m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[iContext].dwGITCookie);
		m_CustomActionInfo[iContext].dwGITCookie = 0;
	}

	if (piCustomAction)
	{
		// should we call DisconnectObject on the RemoteAPI first or just kill the process?
		unsigned long ulRet = 0;
		piCustomAction->PrepareDLLCustomAction(0, 0, 0, 0, false, false, NULL, NULL, &ulRet); 
	}

	if (m_CustomActionInfo[iContext].hServerProcess)
	{
		CloseHandle(m_CustomActionInfo[iContext].hServerProcess);
		m_CustomActionInfo[iContext].hServerProcess = 0;
	}

	m_CustomActionInfo[iContext].dwServerProcess = 0;
}

// For perf reasons, the custom action server will not shut down until told, even if it has 
// no objects currently running. Thus freeing the custom action server consists of two parts, 
// cleaning up our internal state so the service knows to create a new custom action server
// for the next custom action, PLUS telling the existing custom action server to destroy itself.
// once all running custom actions have finished.
UINT CMsiCustomActionManager::ShutdownCustomActionServer()
{
	// we can't tell the CA server to shutdown while another thread is trying to
	// connect to it. Shutdown and creation operation must be atomic.
	EnterCriticalSection(&m_csCreateProxy);

	for (int iContext=icacFirst; iContext < icacNext; iContext++)
	{
		ShutdownSpecificCustomActionServer(static_cast<icacCustomActionContext>(iContext));
	}

	// destroy the manager thread and remoteAPI
	if (m_pRemoteAPI)
	{
		// grab the interface pointer 
		IMsiRemoteAPI *pRemoteAPI = m_pRemoteAPI;
		m_pRemoteAPI=NULL;
		DWORD dwRes = OLE32::CoDisconnectObject(pRemoteAPI, 0);

		// release the initial refcount on the RemoteAPI object.
		// this triggers the manager thread to exit
		pRemoteAPI->Release();
		
		// wait for the manager/API thread to exit. Must pump messages
		HANDLE rghWaitArray[1] = {m_hRemoteAPIThread};
		for(;;)
		{
			DWORD iWait = WIN::MsgWaitForMultipleObjects(1, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
			if (iWait == WAIT_OBJECT_0 + 1)  // window Msg
			{		
				MSG msg;
				while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
				{
					WIN::TranslateMessage(&msg);
					WIN::DispatchMessage(&msg);
				}
				continue;
			}
			else
				// either thread signaled or error
				break;
		}
		WIN::CloseHandle(m_hRemoteAPIThread);
		m_hRemoteAPIThread = 0;
	}

	LeaveCriticalSection(&m_csCreateProxy);
	return ERROR_SUCCESS;
}

// this function is called only from the manager thread. If you use m_csCreateProxy in this function
// you will deadlock.
DWORD WINAPI CMsiCustomActionManager::CreateAndRegisterInterface(icacCustomActionContext icacDesiredContext)
{
	// the server creation process generates a cookie which is then returned to this object
	// for use in the RemoteAPI interface.
	unsigned char rgchCookie[iRemoteAPICookieSize];
	int cchCookieSize = iRemoteAPICookieSize;

	IMsiCustomAction* piCustomAction = 0;
	
	// ensure that interactive users have SYNCHRONIZE access to this process handle. 
	// Since this is the way that the CA Server watches for its client termination, 
	// we need to explicitly grant SYNCHRONIZE access to the user so the CA server 
	// won't feel orphaned and exit immediately.
	if (icacDesiredContext == icac32Impersonated || icacDesiredContext == icac64Impersonated)
	{
		// if unable to set process rights to enable SYNCHRONIZE, try opening the handle to
		// see if the process already grants the rights by chance
		CImpersonate impersonate;

		HANDLE hProcess = OpenProcess(SYNCHRONIZE, /*fInherit*/FALSE, GetCurrentProcessId());
		if (!hProcess)
		{
			if (!SetInteractiveSynchronizeRights(true))
				return false;
		}
		else
			CloseHandle(hProcess);
	}

	if (g_scServerContext == scService)
	{
		// the service can directly create a custom action server by calling the configuration manager
		// interface to create the proxy.
		PMsiConfigurationManager piConfigMgr = CreateConfigurationManager();
		{
			CImpersonate impersonate(fTrue);
			
			// thread token must be desired user token before calling this function
			piCustomAction = piConfigMgr->CreateCustomActionProxy(icacDesiredContext, GetCurrentProcessId(), m_pRemoteAPI, NULL, 0,
				rgchCookie, &cchCookieSize, &m_CustomActionInfo[icacDesiredContext].hServerProcess, &m_CustomActionInfo[icacDesiredContext].dwServerProcess, false, m_fRemapHKCU);
		}
	}
	else
	{
		m_CustomActionInfo[icacDesiredContext].dwServerProcess = 0;
		m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;

		// grab the current environment for use in the custom action server, then determine its size for
		// marshaling purposes
		WCHAR* pvEnvironment = reinterpret_cast<WCHAR*>(KERNEL32::GetEnvironmentStringsW());
		WCHAR* pchEnvironment = pvEnvironment;
		do {
			// scan for the end of the string
			while (*pchEnvironment != '\0')				
				pchEnvironment++;

			// move past null 
			pchEnvironment++;
		}
		while (*pchEnvironment != '\0');

		// enable all privileges in the current thread token
		DWORD dwPrivileges = 0;
		HANDLE hToken = INVALID_HANDLE_VALUE;

		// On Win2000+, manipulate the cloaking token to ensure that privileges are correctly passed to the 
		// custom action server. 
		bool fThreadToken = false;
		HANDLE hTokenDup = INVALID_HANDLE_VALUE;
		if (MinimumPlatformWindows2000())
		{
			// determine whether to work with the process or thread token.
			if (!OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &hToken))
			{           
				// if OpenThreadToken failed due to the fact that there was no thread token, use the process token
				if (GetLastError() == ERROR_NO_TOKEN)
				{
					OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);
				}
			}
			else
				fThreadToken = true;
	
			// make a copy of whatever token we're using so we don't modify the actual process token
			if (hToken != INVALID_HANDLE_VALUE)
			{
				if (!ADVAPI32::DuplicateTokenEx(hToken, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE, 0, SecurityImpersonation, TokenImpersonation, &hTokenDup))
				{
					hTokenDup = INVALID_HANDLE_VALUE;
				}
				if (!EnableAndMapDisabledPrivileges(hTokenDup, dwPrivileges))
				{
					CloseHandle(hTokenDup);
					hTokenDup = INVALID_HANDLE_VALUE;
				}
			}
	
			// if any of the token manipulation failed, creation of the CA server will fail.
			if (hTokenDup == INVALID_HANDLE_VALUE)
			{
				if (hToken != INVALID_HANDLE_VALUE)
					CloseHandle(hToken);
				KERNEL32::FreeEnvironmentStringsW(pvEnvironment);
				return false;
			}

			// set the new token into the thread. 
			SetThreadToken(NULL, hTokenDup);
			CloseHandle(hTokenDup);
			hTokenDup = INVALID_HANDLE_VALUE;
		}

		// we do not handle cases where the environment is greater than can fit in a DWORD 
		// (only possible on 64bit machines)
		DWORD cchEnvironment = static_cast<DWORD>(pchEnvironment - pvEnvironment + 1);

		// client connects to service for broker work. It must provide the RemoteAPI interface, the desired
		// context (elevated not allowed), and the current ProcessId
		PMsiServer piServer = ENG::CreateMsiServer(); 
		if (piServer)
		{
			DEBUGMSGV("Connected to service for CA interface.");
			DWORD dwProcId = 0;
			cchCookieSize = iRemoteAPICookieSize;
			if (ERROR_SUCCESS == piServer->CreateCustomActionServer(icacDesiredContext, GetCurrentProcessId(), m_pRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, &cchCookieSize, &piCustomAction, &dwProcId))
			{
				m_CustomActionInfo[icacDesiredContext].hServerProcess = OpenProcess(SYNCHRONIZE, /*fInherit*/FALSE, dwProcId);

				// even if opening the handle works, the process could have died and a new proecss been created with
				// the same process id, and we actually have a handle to the impostor. To detect this, we ensure that 
				// the handler is still connected.
				if (!m_CustomActionInfo[icacDesiredContext].hServerProcess || !OLE32::CoIsHandlerConnected(piCustomAction))
				{
					// clear out the interface pointer to generate failure below
					piCustomAction->Release();
					piCustomAction = NULL;
				}
				m_CustomActionInfo[icacDesiredContext].dwServerProcess = dwProcId;
			}
		}

		KERNEL32::FreeEnvironmentStringsW(pvEnvironment);

		if (MinimumPlatformWindows2000())
		{
			Assert(hToken != INVALID_HANDLE_VALUE);
			SetThreadToken(NULL, fThreadToken ? hToken : NULL);
			CloseHandle(hToken);
			hToken = INVALID_HANDLE_VALUE;
		}
	}

	// register the new interface in the GIT
	if (!piCustomAction || (S_OK != m_piGIT->RegisterInterfaceInGlobal(piCustomAction, IID_IMsiCustomAction, &m_CustomActionInfo[icacDesiredContext].dwGITCookie)))
	{
		CloseHandle(m_CustomActionInfo[icacDesiredContext].hServerProcess);
		m_CustomActionInfo[icacDesiredContext].hServerProcess = 0;
		m_CustomActionInfo[icacDesiredContext].dwServerProcess = 0;
		return false;
	}

	// finally register the cookie for this context in the RemoteAPI handler. The RemoteAPI can now
	// accept calls in this context (once the action count on that context is incremented)
	return m_pRemoteAPI->SetCookie(icacDesiredContext, rgchCookie, cchCookieSize);
}

DWORD WINAPI CMsiCustomActionManager::CustomActionManagerThread(CMsiCustomActionManager *pThis)
{
	// This function calls ExitThread. No smart COM pointers allowed on stack!

	// The RemoteAPI object MUST be created in an MTA, or any incoming 
	// calls on it will be serialized through this thread. That is bad
	// for remote calls such as "DoAction" which could be re-entrant
	// in their API calls, as well as for asynchronous actions.
	OLE32::CoInitializeEx(0, COINIT_MULTITHREADED);

	// create the object, initial refcount is 1
	pThis->m_pRemoteAPI = new CMsiRemoteAPI();

	// create an unnamed event to wait on. (non-inheritable, auto-reset, initially unsignaled)
	pThis->m_hCreateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// signal the event to waken the main thread
	SetEvent(pThis->m_hRemoteAPIEvent);

	// wait until its time to quit or the thread is activated to do something
	HANDLE rghWaitArray[1] = {pThis->m_hCreateEvent};
	for(;;)
	{
		DWORD iWait = WIN::MsgWaitForMultipleObjects(1, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
		if (iWait == WAIT_OBJECT_0 + 1)  
		{		
			// window message, need to pump until the queue is clear
			MSG msg;
			bool fBreak = false;
			
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				if (msg.message == WM_QUIT)
				{
					fBreak = true;
					break;
				}
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
			if (fBreak)
				break;
		}
		else if (iWait == WAIT_OBJECT_0)
		{
			// signal to create a custom action server of a specific type
			pThis->CreateAndRegisterInterface(pThis->m_icacCreateContext);

			// set event to let other thread know we are done
			SetEvent(pThis->m_hRemoteAPIEvent);
		}
		else if (iWait == 0xFFFFFFFF) //!! what is this on 64bit;
		{
			DEBUGMSGV("Error in CA Manager thread.");
			// error
			break;
		}
		else if (iWait == WAIT_TIMEOUT)
		{
			// our current wait period is forever, but if that changes, this could happen.
			DEBUGMSGV("Timeout in CA Manager thread.");
			break;
		} 
	}

	CloseHandle(pThis->m_hCreateEvent);
	CloseHandle(pThis->m_hRemoteAPIEvent);
	pThis->m_hCreateEvent = 0;
	pThis->m_hRemoteAPIEvent = 0;
	
	pThis->m_pRemoteAPI = NULL;	
	OLE32::CoUninitialize();

	DEBUGMSG("Custom Action Manager thread ending.");
	WIN::ExitThread(0);
	return 0;  // never gets here, needed to compile
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\copy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       copy.cpp
//
//--------------------------------------------------------------------------

/*  copy.cpp - IMsiFileCopy implementation
____________________________________________________________________________*/

#include "precomp.h" 
#include "services.h"
#include "_service.h"
#include "path.h"
#include <accctrl.h>

// log assembly errors
IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName);

// The diamond files use _DEBUG instead of DEBUG, so we have to include this
// define here.
#ifdef DEBUG
#ifndef _DEBUG
     #define _DEBUG
#endif
#endif

#include "intrface.h"

#ifdef WIN
//#include <lzexpand.h>
#endif //WIN

const int cbCopyBufferSize = 64*1024;

DWORD GetFileLastWriteTime(const ICHAR* szSrcFile, FILETIME& rftLastWrite)
{
	BOOL fStat = FALSE;
	bool fImpersonate = GetImpersonationFromPath(szSrcFile);

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);

	if (fImpersonate)
		MsiDisableTimeout();

	DWORD dwLastError = ERROR_SUCCESS;
	HANDLE hSrcFile = WIN::CreateFile(szSrcFile, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);		
	if (hSrcFile != INVALID_HANDLE_VALUE)
	{
		fStat = WIN::GetFileTime(hSrcFile, NULL, NULL, &rftLastWrite);
		if ( !fStat )
			dwLastError = GetLastError();
		WIN::CloseHandle(hSrcFile);
	}
	else
		dwLastError = GetLastError();

	if (fImpersonate)
		MsiEnableTimeout();

	if (fStat == FALSE)
		return dwLastError;
	else
		return NO_ERROR;
}

DWORD MsiSetFileTime(HANDLE hDestFile, FILETIME* pftLastWrite, bool fImpersonate)
{
	// Sets the CreationTime, LastAccessTime, and LastWriteTime values for the
	// file referenced by the given open file handle, as follows:
	//
	// If pftLastWrite points to a valid FILETIME structure, the CreationTime and
	// LastWriteTime values are set to *pftLastWrite, and LastAccessTime is set to
	// the current system time.
	//
	// If pftLastWrite is a NULL pointer, all three values will be set to the 
	// current system time.
	//
	DWORD dwResult = NO_ERROR;
	FILETIME ftLastWrite, ftLastAccess;

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);

	WIN::GetSystemTimeAsFileTime(&ftLastAccess);

	if (pftLastWrite == 0)
		ftLastWrite = ftLastAccess;
	else
		ftLastWrite = * pftLastWrite;

	BOOL fResult = WIN::SetFileTime(hDestFile, &ftLastWrite, &ftLastAccess, &ftLastWrite);

	if (!fResult)
		return GetLastError();

	return NO_ERROR;
}

DWORD MsiSetFileTime(const ICHAR* szDestFile, FILETIME* pftLastWrite)
{
	bool fImpersonate = GetImpersonationFromPath(szDestFile);

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);

	if (fImpersonate)
		MsiDisableTimeout();

	HANDLE hDestFile = WIN::CreateFile(szDestFile, GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	DWORD dwLastError = ERROR_SUCCESS;
	if (hDestFile == INVALID_HANDLE_VALUE)
		dwLastError = GetLastError();

	if (fImpersonate)
		MsiEnableTimeout();

	if (hDestFile == INVALID_HANDLE_VALUE)
		return dwLastError;

	DWORD dwResult = MsiSetFileTime(hDestFile, pftLastWrite, fImpersonate);
	WIN::CloseHandle(hDestFile);
	return dwResult;
}


DWORD MsiSyncFileTimes(HANDLE hSrcFile, HANDLE hDestFile, bool fImpersonate)
{
	// Synchronizes the CreationTime, LastAccessTime, and LastWriteTime values
	// between the given files, as follows:
	//
	// If hSrcFile represents a valid file handle, CreationTime and LastWriteTime
	// of hDestFile will be set to that of hSrcFile, and LastAccessTime of 
	// hDestFile will be set to the current system time.
	//
	// If hSrcFile is INVALID_HANDLE_VALUE, CreationTime, LastAccessTime, and 
	// LastWriteTime of hDestFile will all be set to the current system time.
	//
	FILETIME ftLastWrite;
	BOOL fValidSource = FALSE;

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);
	
	if (hSrcFile != INVALID_HANDLE_VALUE)
	{
		if (WIN::GetFileTime(hSrcFile,NULL,NULL,&ftLastWrite) == FALSE)
			return GetLastError();
		fValidSource = TRUE;
	}

	// no open source handle, hDestFile must be a new 0-length file, so
	// pass NULL pointer for pftLastWrite
	return MsiSetFileTime(hDestFile, fValidSource ? &ftLastWrite : 0, fImpersonate);
}

//____________________________________________________________________________
//
// CMsiFileCopy definition
//____________________________________________________________________________

class CMsiFileCopy : public IMsiFileCopy  // class private to this module
{
 public:   // implemented virtual functions
	virtual HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	virtual unsigned long __stdcall AddRef();
	virtual unsigned long __stdcall Release();
	virtual IMsiRecord*   __stdcall CopyTo(IMsiPath& riSourcePath, IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo);
	virtual IMsiRecord*   __stdcall ChangeMedia(IMsiPath& riMediaPath, const ICHAR* szKeyFile, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash);
	virtual int           __stdcall SetNotification(int cbNotification, int cbSoFar);
	virtual IMsiRecord*   __stdcall InitCopy(IMsiStorage* piStorage);
	virtual IMsiRecord*	  __stdcall CopyTo(IMsiPath& riSourcePath, IAssemblyCacheItem& riDestASM, bool fManifest, IMsiRecord& rirecCopyInfo);
 public:  // constructor
	 CMsiFileCopy(IMsiServices *piServices);
 protected: // local state
    virtual ~CMsiFileCopy();  // prevent creation on stack
	IMsiRecord*    EndCopy(bool fError);
	IMsiRecord*    CheckSpaceAvailable(IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo);
	virtual IMsiRecord*    _CopyTo(IMsiPath& riSourcePath, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo);
	IMsiRecord* ValidateDestination();
	IMsiRecord* OpenSource();
	IMsiRecord* OpenDestination();
	IMsiRecord* WriteFileBits(char* szBuf, unsigned long cbRead);
	int            m_iRefCnt;
	IMsiServices*  m_piServices;
	PMsiPath       m_pDestPath;
	PMsiRecord     m_precCopyInfo;
	int            m_cbSoFar;
	int            m_cbNotification;
	HANDLE         m_hDestFile;
	HANDLE         m_hSrcFile;
	MsiString      m_strDestFullPath;
	MsiString      m_strSourceFullPath;
	bool           m_fDisableTimeout;
	char*          m_szCopyBuffer;
	PAssemblyCacheItem m_pDestASM;
	PStream        m_pDestFile;
	PMsiPath       m_pSourcePath;
	bool           m_fManifest;

};


//____________________________________________________________________________
//
// CMsiCabinetCopy definition
//____________________________________________________________________________


class CMsiCabinetCopy : public CMsiFileCopy  // class private to this module
{
 public:   // implemented virtual functions
	virtual IMsiRecord*   __stdcall ChangeMedia(IMsiPath& riMediaPath, const ICHAR* szKeyFile, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash);
	virtual int           __stdcall SetNotification(int cbNotification, int cbSoFar);
	IMsiRecord*   __stdcall InitCopy(IMsiStorage* piStorage);
 public:  // constructor
	 CMsiCabinetCopy(IMsiServices *piServices, icbtEnum icbtCabinetType);
 protected: // local state
    ~CMsiCabinetCopy();   // prevent creation on stack
	IMsiRecord*    PostCabinetError(IMsiPath& riMediaPath, const ICHAR* szKeyFile, FDIInterfaceError iErr, HRESULT hr);
	virtual IMsiRecord*    _CopyTo(IMsiPath& riSourcePath, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo);
	IMsiRecord*    EndCopy();
	MsiString      m_strCabinet;
	FDI_Interface  m_fdii;
	FDIServerResponse  m_fdisResponse;
	icbtEnum       m_icbtCabinetType;
	IMsiStorage*   m_piStorage;
	PMsiPath       m_pMediaPath;
	MsiString      m_strMediaFileName;

	// digital signature information
	IMsiStream*    m_piSignatureCert;
	IMsiStream*    m_piSignatureHash;
	Bool           m_fSignatureRequired;
};

IMsiRecord* CreateMsiFileCopy(ictEnum ictCopierType, IMsiServices* piServices, 
							  IMsiStorage* piStorage, IMsiFileCopy*& rpacopy)
{
	CMsiFileCopy* pCopy;
	IMsiRecord* precErr;

	if (ictCopierType == ictFileCopier)
	{
		pCopy = new CMsiFileCopy(piServices);
	}
	else if (ictCopierType == ictFileCabinetCopier)
	{
		pCopy = new CMsiCabinetCopy(piServices,icbtFileCabinet);
	}
	else if (ictCopierType == ictStreamCabinetCopier)
	{
		pCopy = new CMsiCabinetCopy(piServices,icbtStreamCabinet);
	}
	else
	{
		precErr = &piServices->CreateRecord(1);
		ISetErrorCode(precErr, Imsg(idbgErrorBadCreateCopierEnum));
		return precErr;
	}

	precErr = pCopy->InitCopy(piStorage);
	if (precErr)
	{
		pCopy->Release();
		return precErr; 
	}
	else
	{
		rpacopy = pCopy;
		return NULL;
	}
}


IMsiRecord* CMsiFileCopy::CheckSpaceAvailable(IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo)
/*----------------------------------------------------------------------
If despite all our costing measures we don't have enough space to install
the file specified by our parameters, this function will detect that,
and return an error record.  Returns 0 if everything's fine.
------------------------------------------------------------------------*/
{
 	unsigned int iSpaceRequired = 0;
	IMsiRecord* piRec = riDestPath.ClusteredFileSize(rirecCopyInfo.GetInteger(IxoFileCopyCore::FileSize),iSpaceRequired);
	if (piRec)
		return piRec;

	unsigned int iExistingSize = 0;
	piRec = riDestPath.FileSize(rirecCopyInfo.GetString(IxoFileCopyCore::DestName), iExistingSize);
	if (piRec)
	{
		if (piRec->GetInteger(1) == idbgFileDoesNotExist)
		{
			piRec->Release();
		}
		else
			return piRec;
	}
	else
	{
		piRec = riDestPath.ClusteredFileSize(iExistingSize,iExistingSize);
		if (piRec)
			return piRec;
		if(iSpaceRequired <= iExistingSize)
			return 0; // no extra space required
		else
			iSpaceRequired -= iExistingSize;
	}

	PMsiVolume pDestVolume(&(riDestPath.GetVolume()));
	unsigned int iSpaceAvail = pDestVolume->FreeSpace();
	if (iSpaceRequired >= iSpaceAvail)
		return PostError(Imsg(imsgDiskFull), (const ICHAR*) m_strDestFullPath);

	return 0;
}


//____________________________________________________________________________
//
// CMsiFileCopy implementation
//____________________________________________________________________________

CMsiFileCopy::CMsiFileCopy(IMsiServices *piServices)
 : m_piServices(piServices), m_precCopyInfo(0), m_pDestPath(0), m_cbSoFar(0), m_cbNotification(0),
   m_hDestFile(INVALID_HANDLE_VALUE), m_hSrcFile(INVALID_HANDLE_VALUE), m_szCopyBuffer(0),
   m_pDestASM(0), m_pDestFile(0), m_pSourcePath(0) 
{
	m_iRefCnt = 1;
	m_piServices->AddRef();
	//assert(piServices);
}

int CMsiFileCopy::SetNotification(int cbNotification, int cbSoFar)
{
	m_cbNotification = cbNotification;
	int cbResidual = m_cbSoFar;
	m_cbSoFar = cbSoFar;
	return cbResidual;
}

IMsiRecord* CMsiFileCopy::InitCopy(IMsiStorage* /* piStorage */)
{
	m_szCopyBuffer = new char[cbCopyBufferSize];
	m_cbSoFar = 0;
	return 0;
}

CMsiFileCopy::~CMsiFileCopy()
{
	PMsiRecord pRecErr = EndCopy(true);
	if (m_szCopyBuffer)
		delete [] m_szCopyBuffer;
}


HRESULT CMsiFileCopy::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiFileCopy)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiFileCopy::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiFileCopy::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	IMsiServices* piServices = m_piServices;
	delete this;
	piServices->Release();
	return 0;
}

IMsiRecord* CMsiFileCopy::EndCopy(bool fError)
{
	Bool fCloseError = fFalse;
	HRESULT hr = ERROR_SUCCESS;
	if (m_pDestPath) // file copy in progress
	{
		bool fDeleteFile = fError && m_hDestFile != INVALID_HANDLE_VALUE;
		
		Bool fSetTimeError = fFalse;
		DWORD dwSetTimeError = 0;
		if(fError == false)
		{
			// set file times for new file

			// per bug 7887, we set both the creation and last modified dates of the new file
			// to the modified dates of the source file.  this is to ensure both dates are
			// identical for newly installed files
			PMsiVolume pDestVolume(&m_pDestPath->GetVolume());
			bool fImpersonateDest = FVolumeRequiresImpersonation(*pDestVolume);
			dwSetTimeError = MsiSyncFileTimes(m_hSrcFile, m_hDestFile, fImpersonateDest);
			if (dwSetTimeError != NO_ERROR)
				fSetTimeError = fTrue;
		}

		if (m_hSrcFile != INVALID_HANDLE_VALUE && !MsiCloseSysHandle(m_hSrcFile))
			fCloseError = fTrue;
		m_hSrcFile = INVALID_HANDLE_VALUE;
		
		if (m_hDestFile != INVALID_HANDLE_VALUE && !MsiCloseSysHandle(m_hDestFile))
			fCloseError = fTrue;
		m_hDestFile = INVALID_HANDLE_VALUE;
		
		IMsiRecord* piError = 0;
		if(fDeleteFile)
		{
			piError = m_pDestPath->RemoveFile(m_precCopyInfo->GetString(IxoFileCopyCore::DestName));
		}

		if(piError)
			return piError;
		if (fSetTimeError)
			return PostError(Imsg(idbgErrorSettingFileTime), dwSetTimeError, m_strDestFullPath);
		if (fCloseError)
			return PostError(Imsg(idbgErrorClosingFile));
	}
	else if(m_pDestASM) // fusion file copy in progress
	{
		if(fError == false)
		{
			// commit the file stream
			Assert(m_pDestFile);
			hr = m_pDestFile->Commit(0);
			if(!SUCCEEDED(hr))
				fCloseError = fTrue;
		}

		if (m_hSrcFile != INVALID_HANDLE_VALUE && !MsiCloseSysHandle(m_hSrcFile))
			fCloseError = fTrue;
		m_hSrcFile = INVALID_HANDLE_VALUE;

		if (fCloseError)
		{
			// capture assembly error in verbose log
			PMsiRecord pError(PostAssemblyError(TEXT(""), hr, TEXT("IStream"), TEXT("Commit"), TEXT("")));
			return PostError(Imsg(idbgErrorClosingFile));
		}
	}
	m_pDestPath = 0; // release
	m_pDestASM = 0;// release
	m_pDestFile = 0;// release
	m_pSourcePath = 0;// release
	m_precCopyInfo = 0; // release
	m_cbSoFar = 0;
	return 0;
}

IMsiRecord* CMsiFileCopy::ChangeMedia(IMsiPath& /*riMediaPath*/, const ICHAR* /*szKeyFile*/, Bool /*fSignatureRequired*/, IMsiStream* /*piSignatureCert*/, IMsiStream* /*piSignatureHash*/)
//-----------------------------------
{
	return 0; 
}


IMsiRecord* CMsiFileCopy::ValidateDestination()
{
	if(m_pDestASM)
	{
		// there is no destination validation to be performed
		return 0;
	}

	Assert(m_pDestPath);

	IMsiRecord* piRec = 0;
	Bool fDirExists = fFalse;
	if ((piRec = m_pDestPath->Exists(fDirExists)) != 0)
	{
		int iError = piRec->GetInteger(1);
		if (iError == idbgErrorGettingFileAttrib)
		{
			piRec->Release();
			return PostError(Imsg(imsgPathNotAccessible), (const ICHAR*) MsiString(m_pDestPath->GetPath()));
		}
		else
			return piRec;
	}
	if(!fDirExists)
		return PostError(Imsg(idbgDirDoesNotExist), (const ICHAR*) MsiString(m_pDestPath->GetPath()));
		
	// If despite all our costing measures we don't have enough space to install, detect it
	// now, before creating the destination file and trying to write to it.
	piRec = CheckSpaceAvailable(*m_pDestPath, *m_precCopyInfo);
	if (piRec)
		return piRec;

	// If an existing file is in our way, make sure it doesn't have read-only,
	// hidden, or system attributes.
	piRec = m_pDestPath->EnsureOverwrite(m_precCopyInfo->GetString(IxoFileCopyCore::DestName), 0);
	if (piRec)
		return piRec;
	return 0;
}

IMsiRecord* CMsiFileCopy::OpenSource()
{
	IMsiRecord* piRec = 0;
	m_hSrcFile = INVALID_HANDLE_VALUE;

	PMsiVolume pSourceVolume(&(m_pSourcePath->GetVolume()));
	bool fImpersonate = FVolumeRequiresImpersonation(*pSourceVolume);

	// check if absent source file = zero-length target file
	int iCopyAttributes = m_precCopyInfo->GetInteger(IxoFileCopyCore::Attributes);
	if ((iCopyAttributes & (ictfaNoncompressed | ictfaCompressed))
							  == (ictfaNoncompressed | ictfaCompressed))
	{
		iCopyAttributes &= ~ictfaCopyACL;
		// set back the attributes
		m_precCopyInfo->SetInteger(IxoFileCopyCore::Attributes, iCopyAttributes);
	}
	else
	{
		if (fImpersonate)
			StartImpersonating();

		m_fDisableTimeout = false;

		if (fImpersonate)
			m_fDisableTimeout = true;

#ifdef DEBUG
		// This should already be set by services, but just to check it out
		UINT iCurrMode = WIN::SetErrorMode(0);
		Assert((iCurrMode & SEM_FAILCRITICALERRORS) == SEM_FAILCRITICALERRORS);
		WIN::SetErrorMode(iCurrMode);
#endif //DEBUG
	
		if (m_fDisableTimeout)
			MsiDisableTimeout();

		m_hSrcFile = CreateFile(m_strSourceFullPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	
		DWORD dwLastError = WIN::GetLastError();

		if (m_fDisableTimeout)
			MsiEnableTimeout();

		if (fImpersonate)
			StopImpersonating();

		if(m_hSrcFile == INVALID_HANDLE_VALUE)
		{
			if (dwLastError == ERROR_NOT_READY || dwLastError == ERROR_GEN_FAILURE) 
				return PostError(Imsg(idbgDriveNotReady));
			else if (dwLastError == ERROR_FILE_NOT_FOUND)
				return PostError(Imsg(imsgErrorSourceFileNotFound), (const ICHAR*) m_strSourceFullPath);
			else if (dwLastError == ERROR_SHARING_VIOLATION)
				return PostError(Imsg(imsgSharingViolation), (const ICHAR*) m_strSourceFullPath);
			else if (NET_ERROR(dwLastError))
				return PostError(Imsg(imsgNetErrorReadingFromFile), (const ICHAR*) m_strSourceFullPath);
			else
				return PostError(Imsg(imsgErrorOpeningFileForRead), dwLastError, m_strSourceFullPath);
		}
		MsiRegisterSysHandle(m_hSrcFile);
	}
	return 0;
}

HANDLE MsiCreateFileWithUserAccessCheck(const ICHAR* szDestFullPath, 
								 /*dwDesiredAccess calculated internally,*/ 
								 PSECURITY_ATTRIBUTES pSecurityAttributes,
								 DWORD dwFlagsAndAttributes,
								 bool fImpersonateDest)
{

	if (g_fWin9X || (0 == pSecurityAttributes) || !WIN::IsValidSecurityDescriptor(pSecurityAttributes->lpSecurityDescriptor))
		return CreateFile(szDestFullPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, dwFlagsAndAttributes, 0);

	HANDLE hDestFile = INVALID_HANDLE_VALUE;
	// We need to create the file initially w/o elevating, to determine whether the user really has
	// access to create the file. If we can't open it with all of the rights that we need then we'll
	// have to open it for GENERIC_WRITE and then re-open it below when we're elevated. The presumption
	// is that if the user has permission to write the file then in general the first call will succeed.

	bool	fReopenFile      = false;
	DWORD	dwDesiredAccess  = GENERIC_WRITE | WRITE_DAC | WRITE_OWNER;

	//FUTURE: generally only the local system has the ability to modify system auditing 
	// and we won't assume that our local system is trusted remotely.  It might, but it's
	// not something we support.
	if (RunningAsLocalSystem() && !fImpersonateDest) dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;

	hDestFile = CreateFile(szDestFullPath, dwDesiredAccess, 0, 0, CREATE_ALWAYS, dwFlagsAndAttributes, 0);
	
	if (hDestFile == INVALID_HANDLE_VALUE && (GetLastError() == ERROR_ACCESS_DENIED || GetLastError() == ERROR_PRIVILEGE_NOT_HELD))
	{
		fReopenFile = true;
		hDestFile = CreateFile(szDestFullPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
	}

	if (hDestFile != INVALID_HANDLE_VALUE)
	{
		// user can basically open file, so now elevate, re-open, and apply the attributes and security descriptor
		CElevate elevate;

		if (fReopenFile)
		{
			WIN::CloseHandle(hDestFile);
			hDestFile = CreateFile(szDestFullPath, dwDesiredAccess, 0, 0, OPEN_ALWAYS, 0, 0);
			AssertNonZero(WIN::SetFileAttributes(szDestFullPath, dwFlagsAndAttributes));
		}

		if (hDestFile != INVALID_HANDLE_VALUE)
		{
			// required to write *different* owner information.
			CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);

			SECURITY_INFORMATION si = GetSecurityInformation(pSecurityAttributes->lpSecurityDescriptor);
			if (!SetUserObjectSecurity(hDestFile, &si, pSecurityAttributes->lpSecurityDescriptor))
			{
				int iLastError = WIN::GetLastError();
				WIN::CloseHandle(hDestFile);
				hDestFile = INVALID_HANDLE_VALUE;
				WIN::SetLastError(iLastError);
			}
		}
	}

	return hDestFile;
}


IMsiRecord* CMsiFileCopy::OpenDestination()
{
	IMsiRecord* piRec = 0;
	int iCopyAttributes = m_precCopyInfo->GetInteger(IxoFileCopyCore::Attributes);
	if(m_pDestPath)
	{
		m_hDestFile = INVALID_HANDLE_VALUE;

		CTempBuffer<char, 3*1024> rgchFileSD;
		DWORD cbFileSD = 3*1024;
		BOOL fFileSD = FALSE;

		PMsiVolume pDestVolume(&m_pDestPath->GetVolume());
		bool fDestSupportsACLs   =   (pDestVolume->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;

		if (iCopyAttributes & ictfaCopyACL)
		{
			bool fSourceSupportsACLs =   (PMsiVolume(&m_pSourcePath->GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;
			PMsiVolume pSourceVolume(&(m_pSourcePath->GetVolume()));
			bool fImpersonateSource = FVolumeRequiresImpersonation(*pSourceVolume);
			
			if (fSourceSupportsACLs && fDestSupportsACLs && !g_fWin9X && !fImpersonateSource && m_precCopyInfo->IsNull(IxoFileCopyCore::SecurityDescriptor))
			{
				CElevate elevate; // so we can always read the security info
				fFileSD = TRUE;

				DEBUGMSGV("Using source file security for destination.");

				if (!ADVAPI32::GetFileSecurity((const ICHAR*)m_strSourceFullPath, 
							OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION, 
							(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD))
				{
					DWORD dwLastError = WIN::GetLastError();
					BOOL fRet = FALSE;
					if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
					{
						fRet = ADVAPI32::GetFileSecurity((const ICHAR*)m_strSourceFullPath, 
							OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION, 
							(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD);
					}
					if (!fRet)
					{
						return PostError(Imsg(imsgGetFileSecurity), GetLastError(), m_strSourceFullPath);
					}
				}
			}
		}


		// Ok (for the moment at least), we've got enough space. Create the destination file.
		int fCreateAttributes = iCopyAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
		bool fImpersonateDest = FVolumeRequiresImpersonation(*pDestVolume);
		if (fImpersonateDest)
			StartImpersonating();

		if (fImpersonateDest)
			m_fDisableTimeout = true;

		if (!fDestSupportsACLs || (m_precCopyInfo->IsNull(IxoFileCopyCore::SecurityDescriptor) && !fFileSD))
		{
			if (m_fDisableTimeout)
				MsiDisableTimeout();

			m_hDestFile = CreateFile(m_strDestFullPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, fCreateAttributes, 0);

			if (m_fDisableTimeout)
				MsiEnableTimeout();
		}
		else // either the source file has a security descriptor or we have one to put on the destination
		{
			SECURITY_ATTRIBUTES sa;		
			CTempBuffer<char, cbDefaultSD> rgchSD;
			char* pchSD = 0;  // points to the actual descriptor we'll finally put on the file.

			if (!m_precCopyInfo->IsNull(IxoFileCopyCore::SecurityDescriptor))
			{
				DEBUGMSGV("File will have security applied from OpCode.");
				PMsiStream pSD((IMsiStream*)m_precCopyInfo->GetMsiData(IxoFileCopyCore::SecurityDescriptor));

				//const int cbDefaultSD = 512;
				
				pSD->Reset();

				int cbSD = pSD->GetIntegerValue();
				if (cbDefaultSD < cbSD)
					rgchSD.SetSize(cbSD);

				pchSD = rgchSD; // SetSize can change ultimate pointer.


				// Self Relative Security Descriptor
				pSD->GetData(rgchSD, cbSD);
				AssertNonZero(WIN::IsValidSecurityDescriptor(rgchSD));
				AssertNonZero(WIN::IsValidSecurityDescriptor(pchSD));
			}
			else // use the descriptor that was on the source file
			{
				pchSD = rgchFileSD;
			}

			// Add the security descriptor to the sa structure
			sa.nLength = sizeof(SECURITY_ATTRIBUTES);
			sa.lpSecurityDescriptor = pchSD;
			sa.bInheritHandle = FALSE;

			if (m_fDisableTimeout)
				MsiDisableTimeout();

			Assert(WIN::IsValidSecurityDescriptor(pchSD));

			m_hDestFile = MsiCreateFileWithUserAccessCheck((const ICHAR*) m_strDestFullPath, &sa, fCreateAttributes, fImpersonateDest);

			if (m_fDisableTimeout)
				MsiEnableTimeout();
		}

		if (fImpersonateDest)
			StopImpersonating();

		if (m_hDestFile == INVALID_HANDLE_VALUE)
		{
			int iLastError = WIN::GetLastError();
			if (iLastError == ERROR_ACCESS_DENIED)
			{
				if (fImpersonateDest) StartImpersonating();
				DWORD dwAttr = MsiGetFileAttributes(m_strDestFullPath);
				if (fImpersonateDest) StopImpersonating();
				if (dwAttr != 0xFFFFFFFF && dwAttr & FILE_ATTRIBUTE_DIRECTORY)
					return PostError(Imsg(imsgDirErrorOpeningFileForWrite), (const ICHAR*) m_strDestFullPath);
			}
			return PostError(Imsg(imsgErrorOpeningFileForWrite), iLastError, m_strDestFullPath);
		}
		MsiRegisterSysHandle(m_hDestFile);
	}
	else
	{
		MsiString strDestName = m_precCopyInfo->GetMsiString(IxoFileCopyCore::DestName);
		Assert(m_pDestASM);
#ifdef UNICODE
		HRESULT hr = m_pDestASM->CreateStream(0, strDestName, m_fManifest ? STREAM_FORMAT_COMPLIB_MANIFEST : 0, 0, &m_pDestFile, NULL);
#else
		void ConvertMultiSzToWideChar(const IMsiString& ristrFileNames, CTempBufferRef<WCHAR>& rgch); // from execute.cpp

		CTempBuffer<WCHAR, MAX_PATH>  rgchDestName;
		ConvertMultiSzToWideChar(*strDestName, rgchDestName);
		HRESULT hr = m_pDestASM->CreateStream(0, rgchDestName, m_fManifest ? STREAM_FORMAT_COMPLIB_MANIFEST : 0, 0, &m_pDestFile, NULL);
#endif
		if(!SUCCEEDED(hr))
			return PostError(Imsg(imsgErrorOpeningFileForWrite), HRESULT_CODE(hr), strDestName);
	}
	return 0;
}

IMsiRecord* CMsiFileCopy::WriteFileBits(char* szBuf, unsigned long cbRead)
{
	unsigned long cbWritten;
	int iLastError = ERROR_SUCCESS;
	if(m_pDestPath)
	{
		Assert(m_hDestFile != INVALID_HANDLE_VALUE);
		if (WriteFile(m_hDestFile, szBuf, cbRead, &cbWritten, 0))
			return 0;
		iLastError = GetLastError();
	}
	else
	{
		Assert(m_pDestFile);
		HRESULT hr = m_pDestFile->Write(szBuf, cbRead, &cbWritten);
		if(SUCCEEDED(hr))
			return 0;
		iLastError = HRESULT_CODE(hr);
	}
	if (iLastError == ERROR_DISK_FULL)
		return PostError(Imsg(imsgDiskFull), (const ICHAR*) m_strDestFullPath);
	else
		return PostError(Imsg(imsgErrorWritingToFile), (const ICHAR*) m_strDestFullPath);
}

IMsiRecord* CMsiFileCopy::_CopyTo(IMsiPath& riSourcePath, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo)
//------------------------------
{
	int iCopyAttributes = rirecCopyInfo.GetInteger(IxoFileCopyCore::Attributes);
	if (iCopyAttributes & ictfaCancel)
	{
		return PostRecord(Imsg(idbgUserAbort));		
	}

	if (iCopyAttributes & ictfaIgnore)
	{
		return PostRecord(Imsg(idbgUserIgnore));
	}

	if (iCopyAttributes & ictfaFailure)
	{
		return PostRecord(Imsg(idbgUserFailure));
	}

	IMsiRecord* piRec;
	if (iCopyAttributes & ictfaRestart)
	{
		piRec = EndCopy(true);
		if (piRec)
			return piRec;

		iCopyAttributes &= (~ictfaRestart);
		rirecCopyInfo.SetInteger(IxoFileCopyCore::Attributes, iCopyAttributes);
	}

	if (!m_pDestPath && !m_pDestASM)  // no copy in progress
	{
		if (rirecCopyInfo.IsNull(IxoFileCopyCore::SourceName))
			return PostError(Imsg(idbgFileKeyIsNull));

		if (rirecCopyInfo.IsNull(IxoFileCopyCore::DestName))
			return PostError(Imsg(idbgFileNameIsNull));

		MsiString strSourceName = rirecCopyInfo.GetString(IxoFileCopyCore::SourceName);
		// m_strSourceFullPath is saved for error requirements later
		if((piRec = riSourcePath.GetFullFilePath(strSourceName, *&m_strSourceFullPath)) != 0)
			return piRec;
	
		MsiString strDestName = rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName);
		// m_strDestFullPath is saved for error requirements later
		if(piDestPath)
		{
			if((piRec = piDestPath->GetFullFilePath(strDestName, *&m_strDestFullPath)) != 0)
				return piRec;
		}
		else
		{
			// simply use the file name only
			m_strDestFullPath = strDestName;
		}


		m_pDestPath = piDestPath;
		if(piDestPath)
			m_pDestPath->AddRef();
		m_pDestASM = piDestASM;
		if(piDestASM)
			m_pDestASM->AddRef();
		m_fManifest = fManifest;

		m_precCopyInfo = &rirecCopyInfo;
		m_precCopyInfo->AddRef();

		m_pSourcePath = &riSourcePath;
		m_pSourcePath->AddRef();

		if ((piRec = ValidateDestination()) != 0)
		{
			PMsiRecord(EndCopy(true));
			return piRec;
		}

		if ((piRec = OpenSource()) != 0)
		{
			PMsiRecord(EndCopy(true));
			return piRec;	 
		}

		if ((piRec = OpenDestination()) != 0)
		{
			PMsiRecord(EndCopy(true));
			return piRec;
		}				
	}
	else // copy in progress
	{
		if((m_pDestPath && !piDestPath) || (m_pDestASM && !piDestASM))
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

		if(m_pDestPath)
		{
			if(!piDestPath)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

			ipcEnum ipc;
			if((piRec = piDestPath->Compare(*m_pDestPath, ipc)) != 0)
				return piRec;
			
			if(ipc != ipcEqual)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		else
		{
			if(!piDestASM || m_pDestASM != piDestASM)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		
		MsiString strOldDest(m_precCopyInfo->GetMsiString(IxoFileCopyCore::DestName));
		MsiString strNewDest(rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName));

		if (strOldDest.Compare(iscExact, strNewDest) == 0)
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		
	}

	if (m_hSrcFile == INVALID_HANDLE_VALUE) // no source file, 0 length
		return EndCopy(false);

	for(;;)
	{
		unsigned long cbToCopy = cbCopyBufferSize;
		if (m_cbNotification && (m_cbNotification - m_cbSoFar) < cbToCopy)
			cbToCopy = m_cbNotification - m_cbSoFar;

		unsigned long cbRead;
#ifdef DEBUG
		// This should already be set by services, but just to check it out
		UINT iCurrMode = WIN::SetErrorMode(0);
		Assert((iCurrMode & SEM_FAILCRITICALERRORS) == SEM_FAILCRITICALERRORS);
		WIN::SetErrorMode(iCurrMode);
#endif //DEBUG

		if (m_fDisableTimeout)
			MsiDisableTimeout();

		Bool fRead = ToBool(ReadFile(m_hSrcFile, m_szCopyBuffer, cbToCopy, &cbRead, 0));
		DWORD dwLastError = ERROR_SUCCESS;
		if ( !fRead )
			dwLastError = GetLastError();

		if (m_fDisableTimeout)
			MsiEnableTimeout();

		if (!fRead)
		{
			if (dwLastError == ERROR_NOT_READY || dwLastError == ERROR_GEN_FAILURE) 
				return PostError(Imsg(idbgDriveNotReady));
			else if (NET_ERROR(dwLastError))
				return PostError(Imsg(imsgNetErrorReadingFromFile), (const ICHAR*) m_strSourceFullPath);
			else
				return PostError(Imsg(imsgErrorReadingFromFile), (const ICHAR*) m_strSourceFullPath, dwLastError);
		}
		if (cbRead)
		{
			if((piRec = WriteFileBits(m_szCopyBuffer, cbRead)) != 0)
				return piRec;
		}
		m_cbSoFar += cbRead;
		if (cbRead < cbToCopy) //EOF
			return EndCopy(false);

		if (m_cbNotification && m_cbSoFar >= m_cbNotification)
		{
			m_cbSoFar -= m_cbNotification;
			return PostRecord(Imsg(idbgCopyNotify), m_cbNotification);
		}
	}

}

IMsiRecord* CMsiFileCopy::CopyTo(IMsiPath& riSourcePath, IAssemblyCacheItem& riDestASM, bool fManifest, IMsiRecord& rirecCopyInfo)
{
	return _CopyTo(riSourcePath, 0, &riDestASM, fManifest, rirecCopyInfo);

}

IMsiRecord* CMsiFileCopy::CopyTo(IMsiPath& riSourcePath, IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo)
{
	return _CopyTo(riSourcePath, &riDestPath, 0, false, rirecCopyInfo);
}

//____________________________________________________________________________
//
// CMsiCabinetCopy implementation
//____________________________________________________________________________

inline CMsiCabinetCopy::CMsiCabinetCopy(IMsiServices *piServices, icbtEnum icbtCabinetType) : CMsiFileCopy(piServices), m_pMediaPath(0), m_piSignatureCert(0), m_piSignatureHash(0)
{
	m_icbtCabinetType = icbtCabinetType;
	m_piStorage = 0;
	m_fSignatureRequired = fFalse; // init to false
}

IMsiRecord* CMsiCabinetCopy::InitCopy(IMsiStorage* piStorage)
{
	CMsiFileCopy::InitCopy(piStorage);
	FDIInterfaceError fdiiErr;
	
	fdiiErr = m_fdii.Init(m_piServices, piStorage);
	if (fdiiErr != ifdiServerLaunched)
		return PostError(Imsg(idbgErrorInitializingFDI));

	if (piStorage && !m_piStorage)
	{
		m_piStorage = piStorage;
		m_piStorage->AddRef();
	}
	return NULL;
}

CMsiCabinetCopy::~CMsiCabinetCopy()
{
	FDIServerResponse fdiResponse = m_fdii.Done();

	// Can get CabinetReadError as response if user aborted as a result of a cabinet read error, and cabinet still not accessible
	AssertNonZero(fdiResponse == fdirSuccessfulCompletion || fdiResponse == fdirClose || fdiResponse == fdirCabinetReadError);
	PMsiRecord pRecErr = EndCopy();
	if (m_piSignatureCert)
		m_piSignatureCert->Release();
	if (m_piSignatureHash)
		m_piSignatureHash->Release();
	if (m_piStorage)
		m_piStorage->Release();

}

IMsiRecord* CMsiCabinetCopy::PostCabinetError(IMsiPath& riMediaPath, const ICHAR* szKeyFile, FDIInterfaceError iErr, HRESULT hr)
{
	MsiString strFullPath;
	PMsiRecord pErrRec(riMediaPath.GetFullFilePath(szKeyFile,*&strFullPath));
	switch (iErr) 
	{
	case ifdiMissingSignature:
		return PostError(Imsg(imsgCABSignatureMissing), (const ICHAR*) strFullPath);
	case ifdiBadSignature: // includes WVT return code
		return PostError(Imsg(imsgCABSignatureRejected), (const ICHAR*) strFullPath, HRESULT_CODE(hr));
	case ifdiNetError:
		return PostError(Imsg(imsgNetErrorOpeningCabinet), (const ICHAR*) strFullPath);
	case ifdiCorruptCabinet:
		return PostError(Imsg(imsgCorruptCabinet), (const ICHAR*) strFullPath);
	default:
		return PostError(Imsg(imsgErrorOpeningCabinet), (const ICHAR*) strFullPath);
	}
}

IMsiRecord* CMsiCabinetCopy::ChangeMedia(IMsiPath& riMediaPath, const ICHAR* szKeyFile, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash)
{
	// set up signature information
	m_fSignatureRequired = fSignatureRequired;
	if (m_piSignatureCert)
	{
		m_piSignatureCert->Release(); // release old
		m_piSignatureCert = 0;
	}
	m_piSignatureCert = piSignatureCert;
	if (piSignatureCert)
		piSignatureCert->AddRef();

	if (m_piSignatureHash)
	{
		m_piSignatureHash->Release(); // release old
		m_piSignatureHash = 0;
	}
	m_piSignatureHash = piSignatureHash;
	if (piSignatureHash)
		piSignatureHash->AddRef();
	HRESULT hrWVT = S_OK; // init to no error

	if (m_icbtCabinetType == icbtFileCabinet)
	{
		Bool fExists = fFalse;
		IMsiRecord* piRec = riMediaPath.FileExists(szKeyFile,fExists);
		if (piRec)
			return piRec;
		else if (!fExists)
			return PostCabinetError(riMediaPath,szKeyFile, ifdiErrorOpeningCabinet, hrWVT);
	}
	
	PMsiVolume pCabVolume = &riMediaPath.GetVolume();
	int iCabDrivetype = pCabVolume->DriveType();
	FDIInterfaceError fdiiErr = m_fdii.OpenCabinet(szKeyFile,MsiString(riMediaPath.GetPath()),m_icbtCabinetType, iCabDrivetype, 
		m_fSignatureRequired, m_piSignatureCert, m_piSignatureHash, hrWVT);

	if (fdiiErr == ifdiDriveNotReady)
		return PostError(Imsg(idbgDriveNotReady));
	else if (fdiiErr != ifdiNoError)
	{
		switch (m_icbtCabinetType)
		{
			case icbtStreamCabinet:
				return PostError(Imsg(idbgStreamCabinetError), szKeyFile);
			default:
				return PostCabinetError(riMediaPath, szKeyFile, fdiiErr, hrWVT);
		}
	}
	m_strCabinet = szKeyFile;
	if (m_pMediaPath != &riMediaPath)
	{
		m_pMediaPath = &riMediaPath;
		m_pMediaPath->AddRef();
	}
	return 0;
}


int CMsiCabinetCopy::SetNotification(int cbNotification, int cbPending)
{
	return m_fdii.SetNotification(cbNotification, cbPending);
}


IMsiRecord* CMsiCabinetCopy::_CopyTo(IMsiPath& /*riSourcePath*/, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo)
{
	IMsiRecord* piRec;
	MsiString astrSrcFile;
	MsiString astrDestFile;
	FDIServerResponse fdisResp;

	int iCopyAttributes = rirecCopyInfo.GetInteger(IxoFileCopyCore::Attributes);

	if (iCopyAttributes & ictfaRestart)
	{
		iCopyAttributes &= (~ictfaRestart);
		rirecCopyInfo.SetInteger(IxoFileCopyCore::Attributes, iCopyAttributes);
		if ((piRec = EndCopy()) != 0)
			return piRec;

		if ((piRec = ChangeMedia(*m_pMediaPath, m_strCabinet, m_fSignatureRequired, m_piSignatureCert, m_piSignatureHash)) != 0)
			return piRec;
	}


	if ((iCopyAttributes & ictfaCancel) || (iCopyAttributes & ictfaFailure))
	{
		fdisResp = m_fdii.SendCommand(fdicCancel);
		if (iCopyAttributes & ictfaFailure)
		{
			return PostRecord(Imsg(idbgUserFailure));
		}
	}
	else if (iCopyAttributes & ictfaIgnore)
	{
		fdisResp = m_fdii.SendCommand(fdicIgnore);
	}
	else if (!m_pDestPath && !m_pDestASM)  // no copy in progress
	{
		if (rirecCopyInfo.IsNull(IxoFileCopyCore::SourceName))
			return PostError(Imsg(idbgFileKeyIsNull));
		if (rirecCopyInfo.IsNull(IxoFileCopyCore::DestName))
			return PostError(Imsg(idbgFileNameIsNull));

		MsiString strDestName = rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName);

		int iDestDriveType;

		if(piDestPath)
		{
			// m_strDestFullPath is saved for error requirements later
			if((piRec = piDestPath->GetFullFilePath(strDestName, *&m_strDestFullPath)) != 0)
				return piRec;

			PMsiVolume pDestVolume = &piDestPath->GetVolume();
			iDestDriveType = pDestVolume->DriveType();
		}
		else
		{
			// simply use the file name only
			m_strDestFullPath = strDestName;
			//!! need to get drive type of fusion assembly
			iDestDriveType = DRIVE_FIXED;
		}

		m_pDestPath = piDestPath;
		if(piDestPath)
			m_pDestPath->AddRef();
		m_pDestASM = piDestASM;
		if(piDestASM)
			m_pDestASM->AddRef();
		m_fManifest = fManifest;

		m_precCopyInfo = &rirecCopyInfo;
		m_precCopyInfo->AddRef();

		if ((piRec = ValidateDestination()) != 0)
			return piRec;		
		

		FileAttributes Attributes;
		CSecurityDescription cSecurityDescription(PMsiStream((IMsiStream*)m_precCopyInfo->GetMsiData(IxoFileCopyCore::SecurityDescriptor)));

		Attributes.attr = rirecCopyInfo.GetInteger(IxoFileCopyCore::Attributes) & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
		if(piDestPath)
			fdisResp = m_fdii.ExtractFile(rirecCopyInfo.GetString(IxoFileCopyCore::SourceName), 0, false, m_strDestFullPath, &Attributes, iDestDriveType, cSecurityDescription);
		else
		{
			Assert(piDestASM);
			fdisResp = m_fdii.ExtractFile(rirecCopyInfo.GetString(IxoFileCopyCore::SourceName), piDestASM, fManifest, m_strDestFullPath, &Attributes, DRIVE_FIXED, cSecurityDescription);
		}
	}
	else // copy in progress
	{
		if((m_pDestPath && !piDestPath) || (m_pDestASM && !piDestASM))
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

		if(m_pDestPath)
		{
			if(!piDestPath)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

			ipcEnum ipc;
			if((piRec = piDestPath->Compare(*m_pDestPath, ipc)) != 0)
				return piRec;
			
			if(ipc != ipcEqual)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		else
		{
			if(!piDestASM || m_pDestASM != piDestASM)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		
		MsiString strOldDest(m_precCopyInfo->GetMsiString(IxoFileCopyCore::DestName));
		MsiString strNewDest(rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName));

		if (strOldDest.Compare(iscExact, strNewDest) == 0)
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		
		fdisResp = m_fdii.SendCommand(fdicContinue);
	}

	//!! add target file name to appropriate errors
	switch(fdisResp)
	{
		case fdirNetError:
			return PostError(Imsg(imsgNetErrorReadingFromFile), (const ICHAR*) m_strCabinet);
		case fdirDirErrorCreatingTargetFile:
			return PostError(Imsg(imsgDirErrorOpeningFileForWrite), (const ICHAR*) m_strDestFullPath);
		case fdirCannotCreateTargetFile:
			// this value can come from a couple of locations, and it's not clear
			// what really went wrong - used to be a debug message.
			EndCopy();
			return PostError(Imsg(imsgErrorWritingToFile), (const ICHAR*) m_strDestFullPath);
		case fdirDiskFull:
			return PostError(Imsg(imsgDiskFull), (const ICHAR*) m_strDestFullPath);
		case fdirErrorWritingFile:
		case fdirTargetFile:
			return PostError(Imsg(imsgErrorWritingToFile), (const ICHAR*) m_strDestFullPath);
		case fdirCabinetReadError:
			return PostError(Imsg(imsgErrorReadingFromFile), (const ICHAR*) m_strDestFullPath, 0);
		case fdirNotification:
			return PostError(Imsg(idbgCopyNotify));
		case fdirFileNotFound:          //File table sequence problem
		case fdirNoCabinetOpen:
			EndCopy();
			return PostError(Imsg(imsgFileNotInCabinet),*MsiString(rirecCopyInfo.GetMsiString(IxoFileCopyCore::SourceName)),
				*m_strCabinet);
		case fdirSuccessfulCompletion:  //File copy successful
			return EndCopy();
		case fdirNeedNextCabinet:
			return PostRecord(Imsg(idbgNeedNextCabinet));
		case fdirCannotBreakExtractInProgress:
		case fdirUserAbort:
			return PostError(Imsg(idbgUserAbort));
		case fdirUserIgnore:
			return PostError(Imsg(idbgUserIgnore));
		case fdirNoResponse:
			Assert(0);
		case fdirCabinetNotFound:
			EndCopy();
			return PostError(Imsg(idbgCabinetNotFound));
		case fdirNotACabinet:           //Cabinet signature not found
			EndCopy();
			return PostError(Imsg(idbgNotACabinet));
		case fdirUnknownCabinetVersion: //we can't handle cabinets w/ this version number
		case fdirBadCompressionType:    // or compression type
			EndCopy();
			return PostError(Imsg(idbgCannotHandleCabinet));
		case fdirCorruptCabinet:
		case fdirReserveMismatch:
		case fdirMDIFail:  //decompressor failed...possibly due to bad data
			EndCopy();
			return PostError(Imsg(imsgCorruptCabinet), (const ICHAR*) m_strCabinet);
		case fdirCannotSetAttributes:
			EndCopy();
			return PostError(Imsg(idbgCannotSetAttributes));
		case fdirServerDied:
			EndCopy();
			return PostError(Imsg(idbgFDICannotCreateTargetFile));
		case fdirDriveNotReady:
			return PostError(Imsg(idbgDriveNotReady));
		case fdirStreamReadError:
			return PostError(Imsg(idbgStreamReadError));
		case fdirMissingSignature:
			EndCopy();
			return PostError(Imsg(imsgCABSignatureMissing), (const ICHAR*) m_strCabinet);
		case fdirBadSignature: // includes WVT return code
			EndCopy();
			return PostError(Imsg(imsgCABSignatureRejected), (const ICHAR*) m_strCabinet, HRESULT_CODE(m_fdii.RetrieveWVTReturnCode()));
		default:  // in case we forgot any cases
			EndCopy();
			return PostError(Imsg(idbgFDIServerError));
	}
}

IMsiRecord* CMsiCabinetCopy::EndCopy()
{
	if (m_pDestPath) // file copy in progress
	{
		m_pDestPath = 0; // release
		m_precCopyInfo = 0; // release
	}
	else if(m_pDestASM) // fusion file copy in progress
	{
		m_pDestASM = 0;// release
		m_precCopyInfo = 0; // release
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\complus.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ComPlus.cpp
//
//--------------------------------------------------------------------------

/* complus.cpp - COM+ actions and execution
____________________________________________________________________________*/
#include "precomp.h" 
#include "_execute.h"
#include "comadmin.h"
#include "comadmin.c"

// Forward declarations.
HRESULT GetSafeArrayOfCLSIDs(LPOLESTR	i_szComponentCLSID,	SAFEARRAY** o_paCLSIDs);
HRESULT RemoveApplicationIfExists(ICOMAdminCatalog *pIAdminCatalog, BSTR &bstrAppID);
static BSTR AllocBSTR(const TCHAR* sz);

// SQL Queries.
const ICHAR sqlRegisterComPlus[]    = TEXT("SELECT `ComponentId`,  `FileName`, `Component`.`Directory_`, `ExpType`, `Component`.`Action`, `Component`.`Installed`  FROM `Complus`, `Component`, `File` WHERE `Complus`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Action` = 1 OR `Action` = 2)");
const ICHAR sqlUnregisterComPlus[]    = TEXT("SELECT `ComponentId`,  `FileName`, `Component`.`Directory_`, `ExpType`, `Component`.`Action`, `Component`.`Installed`  FROM `Complus`, `Component`, `File` WHERE `Complus`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND `Action` = 0");

enum atApplicationType{
	atClient = 0x00000020,
	atServer = 0x00000040,
};

#define fIMPORT_APP_APL		0x00010000

// Actions.
iesEnum ProcessComPlusInfo(IMsiEngine& riEngine, int fRemove)
{
	enum cpiComPlusInfo{
		cpiAppID = 1,
		cpiAplName,
		cpiAppDir,
		cpiAppType,
		cpiComponentAction,
		cpiComponentInstalled,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;

	using namespace IxoComPlusRegister;

	const ICHAR* szQuery = (fRemove != fFalse) ? sqlRegisterComPlus : sqlUnregisterComPlus;

	// Execute the query to get the apl file name.
	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) || (pError = piView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*pError);
	}
	
	while(piRec = piView->Fetch())
	{
		MsiString strFileName, strFullPath, strPath, strInstallUsers;
		PMsiPath piPath(0);

		PMsiRecord piComPlusRec = &piServices->CreateRecord(Args);
	
		// Get the appid, apptype, aplname.
		AssertNonZero(piComPlusRec->SetMsiString(AppID, *MsiString(piRec->GetMsiString(cpiAppID))));
		AssertNonZero(piComPlusRec->SetInteger(AppType, piRec->GetInteger(cpiAppType)));
		strFileName = piRec->GetMsiString(cpiAplName);

		iisEnum iisState = (iisEnum)piRec->GetInteger(cpiComponentAction);
		if(iisState == iisAbsent)
			iisState = (iisEnum)piRec->GetInteger(cpiComponentInstalled);
		if(iisState == iisSource)
		{
			pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(cpiAppDir)), *&piPath);
		}
		else
		{
			pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(cpiAppDir)), *&piPath);
		}

		if(pError)
		{
			if (pError->GetInteger(1) == imsgUser)
				return iesUserExit;
			else
				return riEngine.FatalError(*pError);
		}

		if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
		{
			return riEngine.FatalError(*pError);
		}

		AssertNonZero(piComPlusRec->SetMsiString(AplFileName, *strFullPath));
		strPath = piPath->GetPath();
		AssertNonZero(piComPlusRec->SetMsiString(AppDir, *strPath));
		AssertNonZero(piComPlusRec->SetMsiString(InstallUsers, *MsiString(riEngine.GetProperty(*MsiString(*TEXT("INSTALLUSERS"))))));
		AssertNonZero(piComPlusRec->SetMsiString(RSN, *MsiString(riEngine.GetProperty(*MsiString(*TEXT("REMOTESERVERNAME"))))));
		if ((iesRet = riEngine.ExecuteRecord((fRemove != fFalse) ? ixoComPlusRegister : ixoComPlusUnregister, *piComPlusRec)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

iesEnum RegisterComPlus(IMsiEngine& riEngine)
{
	return ProcessComPlusInfo(riEngine, fTrue);
}

iesEnum UnregisterComPlus(IMsiEngine& riEngine)
{
	return ProcessComPlusInfo(riEngine, fFalse);
}

// Executions.
iesEnum CMsiOpExecute::ixfComPlusRegister(IMsiRecord& riParams) 
{ 
	CComPointer<ICOMAdminCatalog> pIAdminCatalog(0);
	BSTR		bstrAppFile=NULL;
	BSTR		bstrAppDir=NULL;
	BSTR		bstrAppID=NULL;
	BSTR		bstrRSN=NULL;
	LONG		lOptions= fIMPORT_APP_APL;
	LONG		lAppType=0;
	iesEnum		iesReturn=iesSuccess;
	HRESULT		hr=S_OK;

	using namespace IxoComPlusRegister;

	lAppType                  = riParams.GetInteger(AppType);
	MsiString strInstallUsers = riParams.GetMsiString(InstallUsers);
	MsiString strAppFile      = riParams.GetMsiString(AplFileName);
	MsiString strAppDir       = riParams.GetMsiString(AppDir);
	MsiString strAppID        = riParams.GetMsiString(AppID);
	MsiString strRSN          = riParams.GetMsiString(RSN);

	IMsiRecord& riActionData = GetSharedRecord(4); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strAppID));
	AssertNonZero(riActionData.SetInteger(2, lAppType));
	AssertNonZero(riActionData.SetMsiString(3, *strInstallUsers));
	AssertNonZero(riActionData.SetMsiString(4, *strRSN));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	CImpersonate impersonate(fTrue);

	hr = OLE32::CoCreateInstance(CLSID_COMAdminCatalog, NULL, CLSCTX_SERVER, IID_ICOMAdminCatalog, (void**) &pIAdminCatalog);
	if (FAILED(hr)) 
	{
		// We can't perform a server install, if the machine doesn't have
		// COM+ installed on it.
		if (!(lAppType & atClient))
		{
			return FatalError(*PMsiRecord(PostError(Imsg(imsgComPlusNotInstalled))));
		}
		else
		{
			return iesSuccess;
		}
	}

	if (strInstallUsers.Compare(iscExactI, TEXT("TRUE")))
		lOptions |= COMAdminInstallUsers;

	bstrAppFile = ::AllocBSTR(strAppFile);

	bstrAppDir = ::AllocBSTR(strAppDir);
	
	bstrAppID = ::AllocBSTR(strAppID);

	bstrRSN = ::AllocBSTR(strRSN);

	if (!bstrAppFile || !bstrAppDir || !bstrAppID || !bstrRSN)
	{
		return FatalError(*PMsiRecord(PostError(Imsg(imsgOutOfMemory))));
	}
	
	// Install the app.
	hr = pIAdminCatalog->InstallApplication(bstrAppFile, bstrAppDir, lOptions, NULL, NULL, !(lAppType & atClient) ? NULL : bstrRSN);
	OLEAUT32::SysFreeString(bstrAppFile);
	OLEAUT32::SysFreeString(bstrAppDir);
	OLEAUT32::SysFreeString(bstrAppID);
	OLEAUT32::SysFreeString(bstrRSN);
	if (FAILED(hr))
	{
		// dispatch an informational error with extra logging info
		DispatchError(imtInfo, Imsg(idbgComPlusInstallFailed), (const ICHAR*)strAppFile, hr);

		// return fatal error
		return FatalError(*PMsiRecord(PostError(Imsg(imsgComPlusCantInstallApp))));
	}

	if (!RollbackRecord(ixoComPlusUnregister,riParams))
		iesReturn = iesFailure;

	return iesReturn; 
}

iesEnum CMsiOpExecute::ixfComPlusUnregister(IMsiRecord& riParams) 
{ 
	CComPointer<ICOMAdminCatalog> pIAdminCatalog(0);
	BSTR		bstrAppFile=NULL;
	BSTR		bstrAppID=NULL;
	LONG		lAppType = 0;
	iesEnum		iesReturn=iesSuccess;
	HRESULT		hr=S_OK;

	using namespace IxoComPlusRegister;

	lAppType = riParams.GetInteger(AppType);
	MsiString strAppFile = riParams.GetMsiString(AplFileName);
	MsiString strAppID = riParams.GetMsiString(AppID);

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strAppID));
	AssertNonZero(riActionData.SetInteger(2, lAppType));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	hr = OLE32::CoCreateInstance(CLSID_COMAdminCatalog, NULL, CLSCTX_SERVER, IID_ICOMAdminCatalog, (void**) &pIAdminCatalog);
	if (FAILED(hr)) 
	{
		// We can't perform a server or qc client install, if the machine doesn't have
		// COM+ installed on it.
		if (!(lAppType & atClient))
		{
			return FatalError(*PMsiRecord(PostError(Imsg(imsgComPlusNotInstalled))));
		}
		else
		{
			return iesSuccess;
		}
	}

	bstrAppFile = ::AllocBSTR(strAppFile);

	bstrAppID = ::AllocBSTR(strAppID);
	if (!bstrAppFile || !bstrAppID)
	{
		return FatalError(*PMsiRecord(PostError(Imsg(imsgOutOfMemory))));
	}


	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry)  // retry loop
	{
		hr = RemoveApplicationIfExists(pIAdminCatalog, bstrAppID);
		if (FAILED(hr))
		{
			switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3), Imsg(imsgComPlusCantRemoveApp)))
			{
			case imsAbort: iesReturn = iesFailure; fRetry = fFalse; break;
			case imsRetry: continue;
			default:       iesReturn = iesSuccess; fRetry = fFalse;
			};
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	OLEAUT32::SysFreeString(bstrAppFile);
	OLEAUT32::SysFreeString(bstrAppID);

	// If we did remove the app and something goes wrong, we would need to reinstall 
	// the application we just removed.
	if (hr == S_OK)
	{
		if (!RollbackRecord(ixoComPlusRegister,riParams))
			iesReturn = iesFailure;
	}

	return iesReturn; 
}

//*****************************************************************************
HRESULT RemoveApplicationIfExists(ICOMAdminCatalog *pIAdminCatalog, BSTR &bstrAppID)
{
	CComPointer<ICatalogCollection> pIAppCollection(0);
	BSTR		bstrCollection =NULL;
    SAFEARRAY*  aCLSIDs = NULL;
	long		lChanges;
	HRESULT		hr=S_OK;

	if ((bstrCollection = OLEAUT32::SysAllocString(L"Applications")) == NULL)
		return E_OUTOFMEMORY;

	hr = pIAdminCatalog->GetCollection(bstrCollection, (IDispatch **) &pIAppCollection);
	OLEAUT32::SysFreeString(bstrCollection);
	if (FAILED(hr))
		return hr;

	// Populate the collection with the item to be deleted.
	hr = GetSafeArrayOfCLSIDs(bstrAppID, &aCLSIDs);
	if (FAILED(hr))
		return hr;
	hr = pIAppCollection->PopulateByKey(aCLSIDs);
	OLEAUT32::SafeArrayDestroy(aCLSIDs);
	if (FAILED(hr))
		return hr;

	// Remove the one and only element from the collection. If there doesn't exist one
	// we can safely continue.
	if (pIAppCollection->Remove(0) == S_OK)
	{
		hr = pIAppCollection->SaveChanges(&lChanges);
		if(FAILED (hr))
			return hr;
		hr = S_OK;
	}
	else
	{
		hr = S_FALSE;
	}

	return hr; 
}

static BSTR AllocBSTR(const TCHAR* sz)
{
#ifndef UNICODE
	if (sz == 0)
		return 0;
	int cchWide = WIN::MultiByteToWideChar(CP_ACP, 0, sz, -1, 0, 0) - 1;
	BSTR bstr = OLEAUT32::SysAllocStringLen(0, cchWide); // null added by API
	WIN::MultiByteToWideChar(CP_ACP, 0, sz, -1, bstr, cchWide);
	bstr[cchWide] = 0; // API function does not null terminate
	return bstr;
#else if
	return OLEAUT32::SysAllocString(sz);
#endif

}

//*****************************************************************************
//*****************************************************************************
HRESULT GetSafeArrayOfCLSIDs(
	LPOLESTR	i_szComponentCLSID,
	SAFEARRAY** o_paCLSIDs)
{
    SAFEARRAY*          aCLSIDs = NULL;
    SAFEARRAYBOUND      rgsaBound[1];
    LONG                Indices[1];
    VARIANT             varT;
    HRESULT             hr = NOERROR;

   
    // PopulateByKey is expecting a SAFEARRAY parameter input,
    // Create a one element SAFEARRAY, the one element of the SAFEARRAY contains
    // the packageID.
    rgsaBound[0].cElements = 1;
    rgsaBound[0].lLbound = 0;
    aCLSIDs = OLEAUT32::SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

    if (aCLSIDs)
    {
        Indices[0] = 0;

		OLEAUT32::VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = OLEAUT32::SysAllocString(i_szComponentCLSID);
        hr = OLEAUT32::SafeArrayPutElement(aCLSIDs, Indices, &varT);
        OLEAUT32::VariantClear(&varT);

        if (FAILED(hr))
		{       
			OLEAUT32::SafeArrayDestroy(aCLSIDs);
            aCLSIDs = NULL;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	*o_paCLSIDs = aCLSIDs;
    return hr;
}



iesEnum CMsiOpExecute::ixfComPlusRegisterMetaOnly(IMsiRecord& /*riParams*/) { return iesNoAction; }
iesEnum CMsiOpExecute::ixfComPlusUnregisterMetaOnly(IMsiRecord& /*riParams*/) { return iesNoAction; }
iesEnum CMsiOpExecute::ixfComPlusCommit(IMsiRecord& /*riParams*/) { return iesNoAction; }
iesEnum CMsiOpExecute::ixfComPlusRollback(IMsiRecord& /*riParams*/) { return iesNoAction; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\dbfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbfile.cpp
//
//--------------------------------------------------------------------------

/* dbfile.cpp - persistant database implemtation

CMsiStorage - database file management, based on IStorage
CMsiStream - stream object, based on IStream
CMsiMemoryStream - stream object, based on memory allocation
CMsiFileStream   - stream object created on a file
CMsiSummaryInfo  - summary stream property input/output
CFileRead CFileWrite - internal objects for database table import/export
CMsiLockBytes - internal object to allow lockbytes on a resource
____________________________________________________________________________*/

#include "precomp.h"
#include "_databas.h"

extern int g_cInstances;

#define LOC  // module scope

enum issEnum  // stream state, to prevent simultaneous read/write
{
	issReset = 0,
	issRead,
	issWrite,
	issError,
};

enum idorEnum // delete-on-release possibilities
{
	idorDontDelete = 0,
	idorDelete,
	idorElevateAndDelete,
};

const GUID IID_NULL = {0,0,0,{0,0,0,0,0,0,0,0}};

//____________________________________________________________________________
//
//  CMsiLockBytes definitions
//____________________________________________________________________________
//
//
// The implementation of CreateILockBytesOnHGlobal doesn't correctly handle
// an HGLOBAL that was returned from LoadResource. Apparently it internally
// does a GlobalSizeof which doesn't seem to deal with resource HGLOBAL's 
// correctly. 
//
// This is a minimal, read-only implementation of ILockBytes to allow creation
// of MsiStorage's on streams, or on memory by creating a memory stream object.
//

const GUID IID_ILockBytes = GUID_IID_ILockBytes;
class CMsiLockBytes: public ILockBytes
{
 public:
	CMsiLockBytes(const char* pchMem, int iLength);
	CMsiLockBytes(IMsiStream& riStream);
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall ReadAt(ULARGE_INTEGER ulOffset, void* pv, ULONG cb, ULONG* pcbRead);
	HRESULT __stdcall WriteAt(ULARGE_INTEGER ulOffset, const void* pv, ULONG cb, ULONG* pcbWritten);
	HRESULT __stdcall Flush();
	HRESULT __stdcall SetSize(ULARGE_INTEGER cb);
	HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT __stdcall Stat(STATSTG* pstatstg, DWORD grfStatFlag);
 protected:
	~CMsiLockBytes();  // protected to prevent creation on stack
	int             m_iRefCnt;      // COM reference count
	IMsiStream*     m_piStream;
};

//____________________________________________________________________________
//
//  CMsiStorage, CMsiStream definitions
//____________________________________________________________________________

class CMsiStream;  // forward declaration

class CMsiStorage : public IMsiStorage
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString& __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	IMsiRecord*   __stdcall OpenStream(const ICHAR* szName, Bool fWrite,
									IMsiStream*& rpiStream);
	IMsiRecord*   __stdcall RemoveElement(const ICHAR* szName, Bool fStorage);
	IMsiRecord*   __stdcall RenameElement(const ICHAR* szOldName, const ICHAR* szNewName, Bool fStorage);
	IEnumMsiString* __stdcall GetStreamEnumerator();
	IEnumMsiString* __stdcall GetStorageEnumerator();
	IMsiRecord*   __stdcall OpenStorage(const ICHAR* szName, ismEnum ismOpenMode, IMsiStorage*& rpiStorage);
	IMsiRecord*   __stdcall SetClass(const IID& riid);
	Bool          __stdcall GetClass(IID* piid);
	IMsiRecord*   __stdcall Commit();
	IMsiRecord*   __stdcall Rollback();
	Bool          __stdcall DeleteOnRelease(bool fElevateToDelete);
	IMsiRecord*   __stdcall CreateSummaryInfo(unsigned int cMaxProperties,
															IMsiSummaryInfo*& rpiSummary);
	IMsiRecord* __stdcall CopyTo(IMsiStorage& riDestStorage, IMsiRecord* piExcludedStreams);
	IMsiRecord* __stdcall GetName(const IMsiString*& rpiName);
	IMsiRecord* __stdcall GetSubStorageNameList(const IMsiString*& rpiTopParent, const IMsiString*& rpiSubStorageList);
	bool        __stdcall ValidateStorageClass(ivscEnum ivsc);
 public: // constructor, destructor
	void* operator new(size_t cb);
	void  operator delete(void * pv);
	CMsiStorage(IStorage& riStorage, ismEnum ismOpenMode, CMsiStorage* piParent, bool fFile);
 protected:
  ~CMsiStorage();  // protected to prevent creation on stack
 public: // for use by members of this and stream classes
	ismEnum GetOpenMode();
	void StreamCreated(CMsiStream& riStream);
	void StreamReleased(CMsiStream& riStream);
	void FlushStreams();
 private:
	CMsiRef<iidMsiStorage>   m_Ref;      // COM reference count
	IStorage& m_riStorage;
	CMsiStorage* m_piParent;
	CMsiStream*  m_piStreams;  // list of active streams
	ismEnum   m_ismOpenMode;
	Bool      m_fCommit;
	idorEnum  m_idorDeleteOnRelease;
	bool	    m_fNetworkFile;
	bool	    m_fRawStreamNames;
#ifdef USE_OBJECT_POOL
	unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
 private: // eliminate warning: assignment operator could not be generated
	void operator =(const CMsiStorage&){}
};
inline void*   CMsiStorage::operator new(size_t cb) {return AllocObject(cb);}
inline void    CMsiStorage::operator delete(void * pv) { FreeObject(pv); }
inline ismEnum CMsiStorage::GetOpenMode() { return m_ismOpenMode; }

const int cbMinReadDirect = 512;
const int cbBufferSize	= 1024;

class CMsiStreamBuffer : public IMsiStream
{
 public:
	short         __stdcall GetInt16();
	int           __stdcall GetInt32();
	void          __stdcall PutInt16(short i);
	void          __stdcall PutInt32(int i);
	unsigned int  __stdcall GetData(void* pch, unsigned int cb);
	void 		  __stdcall PutData(const void* pch, unsigned int cb);
	Bool		  __stdcall Error();
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
 protected:
 	CMsiStreamBuffer();
 #ifdef USE_OBJECT_POOL
 	~CMsiStreamBuffer();
 #endif //USE_OBJECT_POOL
	unsigned int  m_cbCopied;
	char          m_rgbBuffer[cbBufferSize]; // local buffer for performance
	unsigned long m_cbBuffer;  // bytes read into buffer
	unsigned long m_cbUsed;    // bytes currently used in buffer
	issEnum       m_issState;
	Bool                m_fWrite;
	unsigned int        m_cbLength;
#ifdef USE_OBJECT_POOL
 private:
	unsigned int  m_iCacheId;
#endif //USE_OBJECT_POOL
 protected:
	virtual HRESULT __stdcall Read(void *pv, unsigned long cb, unsigned long *pcbRead) = 0;
};

class CMsiStream : public CMsiStreamBuffer
{
 public:  // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
	unsigned int  __stdcall Remaining() const;
	void          __stdcall Reset();
	void          __stdcall Seek(int position);
	IMsiStream*   __stdcall Clone();
 	void          __stdcall Flush();
	HRESULT 	  __stdcall Read(void *pv, unsigned long cb, unsigned long *pcbRead);
 public: // constructor, destructor
	void* operator new(size_t cb);
	void  operator delete(void * pv);
	CMsiStream(CMsiStorage& riStorage, IStream& riStream, Bool fWrite);
 protected:
  ~CMsiStream();  // protected to prevent creation on stack
 private:  // internal functions
	CMsiRef<iidMsiStream>	m_Ref;      // COM reference count
	CMsiStorage&  m_riStorage;
	CMsiStream*   m_piNextStream;  // link list, maintained by CMsiStorage
	IStream&      m_riStream;
 private: // eliminate warning: assignment operator could not be generated
	void operator =(const CMsiStream&){}
	friend class CMsiStorage;  // access to linked list
};
inline void* CMsiStream::operator new(size_t cb) {return AllocObject(cb);}
inline void  CMsiStream::operator delete(void * pv) { FreeObject(pv); }

inline void  CMsiStorage::StreamCreated(CMsiStream& riStream)
	{riStream.m_piNextStream = m_piStreams; m_piStreams = &riStream;}
inline void  CMsiStorage::StreamReleased(CMsiStream& riStream)
{
	for (CMsiStream** ppPrev = &m_piStreams;
						 *ppPrev != &riStream;
						  ppPrev = &((*ppPrev)->m_piNextStream))
		if (*ppPrev == 0)
		{
			AssertSz(0, "Stream unlink error");
			break;
		}
	*ppPrev = riStream.m_piNextStream;
}

//____________________________________________________________________________
//
//  Definitions for Summary Stream
//____________________________________________________________________________

const unsigned int iFileTimeDosBaseLow  = 0xE1D58000L;
const unsigned int iFileTimeDosBaseHigh = 0x01A8E79FL;
const unsigned int iFileTimeOneDayLow   = 0x2A69C000L;
const unsigned int iFileTimeOneDayHigh  = 0x000000C9L;

const int cbSummaryHeader = 48;
const int cbSectionHeader = 2 * sizeof(int);  // section size + property count

static const ICHAR szSummaryStream[] = TEXT("\005SummaryInformation");
static const unsigned char fmtidSummaryStream[16] =
		{ 0xE0, 0x85, 0x9F, 0xF2, 0xF9, 0x4F, 0x68, 0x10,
		  0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9 };
static const char fmtidSourceClsid[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
const int PID_Deleted = -1;

struct PropertyData
{
	int iPID;     // property ID, PID_XXX
	int iType;    // data type, VT_XXX
	union
	{
		int cbText;     // if VT_LPSTR
		int iLow;       // if VT_FILETIME
		int iValue;     // if VT_I4
	};
	union
	{
		const IMsiString* piText;  // if VT_LPSTR
		int iHigh;           // if VT_FILETIME
	};
};

class CMsiSummaryInfo : public IMsiSummaryInfo
{
 public:
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	int           __stdcall GetPropertyCount();
	int           __stdcall GetPropertyType(int iPID); // returns VT_XXX
	const IMsiString&   __stdcall GetStringProperty(int iPID);
	Bool          __stdcall GetIntegerProperty(int iPID, int& iValue);
	Bool          __stdcall GetTimeProperty(int iPID, MsiDate& riDateTime);
	Bool          __stdcall RemoveProperty(int iPID);
	int           __stdcall SetStringProperty(int iPID, const IMsiString& riText);
	int           __stdcall SetIntegerProperty(int iPID, int iValue);
	int           __stdcall SetTimeProperty(int iPID, MsiDate iDateTime);
	Bool          __stdcall WritePropertyStream();
	Bool          __stdcall GetFileTimeProperty(int iPID, FILETIME& rftDateTime);
	int           __stdcall SetFileTimeProperty(int iPID, FILETIME& rftDateTime);
 public: // constructor
	static IMsiRecord* Create(CMsiStorage& riStorage, unsigned int cMaxProperties,
									  IMsiSummaryInfo*& rpiSummary);
	void* operator new(size_t iBase, unsigned int cbStream, unsigned int cMaxProperties);
	void* operator new(size_t cb);
	void  operator delete(void * pv);
	CMsiSummaryInfo(unsigned int cbStream, unsigned int cMaxProperties);
 protected:
  ~CMsiSummaryInfo();  // protected to prevent creation on stack
 private:
	int  GetInt32(int* p);  // accessor that swaps bytes on Mac
	int  GetInt16(int* p);  // accessor that swaps bytes on Mac
	int*          FindOldProperty(int iPID);
	PropertyData* FindNewProperty(int iPID);
	PropertyData* GetPropertyData();
	void operator=(CMsiSummaryInfo&); // avoid warning
 private:
	unsigned int m_iRefCnt;
	int          m_iCodepage;
	unsigned int m_cbStream;
	void*        m_pvStream;
	unsigned int m_cOldProp;
	unsigned int m_cDeleted;
	unsigned int m_cNewProp;
	char*        m_pbSection;
	int*         m_pPropertyIndex;
	IMsiStream*  m_piStream;
	unsigned int m_cMaxProp;
	unsigned int m_cbSection;
};
inline void* CMsiSummaryInfo::operator new(size_t iBase, unsigned int cbStream, unsigned int cMaxProperties)
	{return CMsiSummaryInfo::operator new(iBase + cbStream + cMaxProperties * sizeof(PropertyData));}
inline void* CMsiSummaryInfo::operator new(size_t cb) {return AllocObject(cb);}
inline void  CMsiSummaryInfo::operator delete(void * pv) { FreeObject(pv); }
inline PropertyData* CMsiSummaryInfo::GetPropertyData() { return (PropertyData*)(this + 1); }
	
inline int CMsiSummaryInfo::GetInt32(int* p) {return *p;}
inline int CMsiSummaryInfo::GetInt16(int* p) {return (int)*(short*)p;}

//____________________________________________________________________________
//
//  Implementation of CMsiStreamBuffer
//____________________________________________________________________________

CMsiStreamBuffer::CMsiStreamBuffer()
	: m_cbCopied(0)
	, m_issState(issReset)
{
#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}

#ifdef USE_OBJECT_POOL
CMsiStreamBuffer::~CMsiStreamBuffer()
{
	RemoveObjectData(m_iCacheId);
}
#endif //USE_OBJECT_POOL

Bool CMsiStreamBuffer::Error()
{
	return (m_issState == issError ? fTrue : fFalse);
}


short CMsiStreamBuffer::GetInt16()
{
	short i = 0; // default value in case error
	CMsiStreamBuffer::GetData(&i, sizeof(i));
	return i;
}

int CMsiStreamBuffer::GetInt32()
{
	int i = 0; // default value in case error
	CMsiStreamBuffer::GetData(&i, sizeof(i));
	return i;
}

void CMsiStreamBuffer::PutInt16(short i)
{
	CMsiStreamBuffer::PutData(&i, sizeof(i));
}

void CMsiStreamBuffer::PutInt32(int i)
{
	CMsiStreamBuffer::PutData(&i, sizeof(i));
}


unsigned int CMsiStreamBuffer::GetData(void* pch, unsigned int cb)
{
	if (m_issState != issRead) // first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbBuffer = m_cbUsed = sizeof(m_rgbBuffer);
	}
	int cbCopied = 0;
	while (cb)
	{
		int cbCopy = m_cbBuffer - m_cbUsed;
		if (!cbCopy)
		{
			if (m_cbBuffer < sizeof(m_rgbBuffer))
			{
				m_issState = issError;
				break;
			}

			if (cb >= cbMinReadDirect)
			{			
				unsigned long cbRead;
				
				if (Read(pch, cb, &cbRead) != 0)
				{
					m_issState = issError;
					return 0;
				}
				cbCopied += cbRead;
				cb -= cbRead;
				if (cb > 0)
				{
					m_issState = issError;
				}
				break;
			}
			else
			{
				if (Read(m_rgbBuffer, sizeof(m_rgbBuffer), &m_cbBuffer) != 0)
				{
					m_issState = issError;
					return 0;
				}
				m_cbUsed = 0;
			}
			continue;
		}
		if (cbCopy > cb)
			cbCopy = cb;
		memcpy(pch, &m_rgbBuffer[m_cbUsed], cbCopy);
		m_cbUsed += cbCopy;
		cb -= cbCopy;
		cbCopied += cbCopy;
		*(char**)&pch += cbCopy;
	}
	m_cbCopied += cbCopied;
	return cbCopied;
}

void CMsiStreamBuffer::PutData(const void* pch, unsigned int cb)
{
	if (m_issState != issWrite) // first write
	{
		if (!m_fWrite || m_issState != issReset)
		{
			m_issState = issError;
			return;
		}
		m_issState = issWrite;
		m_cbLength = m_cbCopied = m_cbUsed = 0;
	}
	m_cbLength += cb;
	while (cb)
	{
		int cbCopy = sizeof(m_rgbBuffer) - m_cbUsed;
		if (cb >= cbCopy)
		{
			memcpy(&m_rgbBuffer[m_cbUsed], pch, cbCopy);
			m_cbUsed += cbCopy;
			Flush();
			cb -= cbCopy;
			*(char**)&pch += cbCopy;
		}
		else
		{
			memcpy(&m_rgbBuffer[m_cbUsed], pch, cb);
			m_cbUsed += cb;
			return;
		}
	}
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiStreamBuffer::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiStreamBuffer::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL



//____________________________________________________________________________
//
//  Implementation of CMsiStream
//____________________________________________________________________________

const GUID IID_IMsiStream     = GUID_IID_IMsiStream;
const GUID IID_IMsiMemoryStream = GUID_IID_IMsiMemoryStream;
const GUID IID_IMsiStorage    = GUID_IID_IMsiStorage;

CMsiStream::CMsiStream(CMsiStorage& riStorage, IStream& riStream, Bool fWrite)
	: m_riStorage(riStorage)
	, m_riStream(riStream)
{  // m_cbBuffer and m_cbUsed initialized at first read/write
	m_fWrite = fWrite;
	if (fWrite)
	{
		m_cbLength = 0;
		riStorage.StreamCreated(*this);
	}
	else
	{
		STATSTG statstg;
		HRESULT hres = riStream.Stat(&statstg, STATFLAG_NONAME);
		m_cbLength = statstg.cbSize.LowPart;
	}
	m_riStorage.AddRef();
	Debug(m_Ref.m_pobj = this);
}

CMsiStream::~CMsiStream()
{
	m_riStream.Release();
}

HRESULT CMsiStream::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiStream)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiStream::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiStream::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	Flush();
	CMsiStorage& riStorage = m_riStorage;
	if (m_fWrite)
		riStorage.StreamReleased(*this);
	delete this;
	riStorage.Release();
	return 0;
}

const IMsiString& CMsiStream::GetMsiStringValue() const
{
	const IMsiString* piString;
	IStream* piClone;
	unsigned long cbRead;
	ICHAR* pch;
	if (m_cbLength == 0 || m_fWrite || m_riStream.Clone(&piClone) != NOERROR)
		return SRV::CreateString();
#ifdef UNICODE
	CTempBuffer<char, 1024> rgchBuf;
	rgchBuf.SetSize(m_cbLength);
	if ( ! (char *) rgchBuf )
		return SRV::CreateString();
	piClone->Read(rgchBuf, m_cbLength, &cbRead);
	piClone->Release();
	if (cbRead != m_cbLength)
		return SRV::CreateString();
	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, m_cbLength, 0, 0); //!! should use m_iCodepage from database, but how?
	pch = SRV::AllocateString(cch, fFalse, piString);
	if ( ! pch )
		return SRV::CreateString();
	WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, m_cbLength, pch, cch);
#else
	// stream could have DBCS chars -- we can't tell prior to copying the stream,
	// so instead we will default to fDBCS = fTrue in the ANSI build and take
	// the performance hit to guarantee DBCS is supported
	pch = SRV::AllocateString(m_cbLength, /*fDBCS=*/fTrue, piString);
	if ( ! pch )
		return SRV::CreateString();
	piClone->Read(pch, m_cbLength, &cbRead);
	piClone->Release();
	if (cbRead != m_cbLength)
	{
		piString->Release();
		return SRV::CreateString();
	}
#endif
	return *piString;
}

int CMsiStream::GetIntegerValue() const
{
	return m_cbLength;
}

unsigned int CMsiStream::Remaining() const
{
	return m_cbLength - m_cbCopied;
}

HRESULT CMsiStream::Read(void *pv, unsigned long cb, unsigned long *pcbRead)
{
	return m_riStream.Read(pv, cb, pcbRead);
}

LARGE_INTEGER liZero = {0,0};

void CMsiStream::Reset()
{
	Flush();
	m_riStream.Seek(liZero, STREAM_SEEK_SET, 0);
	m_cbCopied = 0;
	m_issState = issReset;
}

void CMsiStream::Seek(int position)
{
	LARGE_INTEGER liPos = {position,0};
	ULARGE_INTEGER liNewPos;
	Flush();
	if((m_riStream.Seek(liPos, STREAM_SEEK_SET, &liNewPos)) != S_OK)
	{
		m_issState = issError;
		return;
	}
	m_cbCopied = liNewPos.LowPart;
}

void CMsiStream::Flush()
{
	if (m_issState == issWrite && m_cbUsed != 0)
	{
		unsigned long cbWritten = 0;
		m_riStream.Write(m_rgbBuffer, m_cbUsed, &cbWritten);
		if (cbWritten != m_cbUsed)
			m_issState = issError;
		m_cbCopied += cbWritten;
		m_cbUsed = 0;
	}
	else if (m_issState == issRead)
		m_cbUsed = m_cbBuffer = sizeof(m_rgbBuffer);
}

IMsiStream* CMsiStream::Clone()
{
	IStream* piStream;
	if (m_riStream.Clone(&piStream) != NOERROR)
		return 0;
	if (piStream == 0)   // only fails if reverted above or out of memory
		return 0;
	piStream->Seek(liZero, STREAM_SEEK_SET, 0);
	return new CMsiStream(m_riStorage, *piStream, m_fWrite);
}

//____________________________________________________________________________
//
//  Implementation of CMsiStorage
//____________________________________________________________________________

static const ICHAR* rgszSysTableNames[] =  // list of system streams, null terminated
{
	szMsiInfo,
	szTableCatalog,
	szColumnCatalog,
	szStringPool,
	szStringData,
	0
};

// Create read-only storage on ILockBytes, which in turn is implemented on a stream
IMsiRecord* CreateMsiStorage(ILockBytes* piLockBytes, IMsiStorage*& rpiStorage)
{
	IStorage* piStorage;
	DWORD grfMode = STGM_READ | STGM_SHARE_EXCLUSIVE;
	HRESULT hres = OLE32::StgOpenStorageOnILockBytes(piLockBytes, (IStorage*)0, grfMode, (SNB)0, 0, &piStorage);
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbOpenStorage), TEXT("ILockBytes"), hres); //?? no name
	rpiStorage = new CMsiStorage(*piStorage, ismReadOnly, 0, false);
	piStorage->Release();
	return 0;
}

IMsiRecord* CreateMsiStorage(const char* pchMem, unsigned int iSize, IMsiStorage*& rpiStorage)
{
	CComPointer<ILockBytes> pLockBytes(new CMsiLockBytes(pchMem, iSize));
	return CreateMsiStorage(pLockBytes, rpiStorage);
};

// Create a storage on a stream, read-only
IMsiRecord* CreateMsiStorage(IMsiStream& riStream, IMsiStorage*& rpiStorage)
{
	CComPointer<ILockBytes> pLockBytes(new CMsiLockBytes(riStream));
	return CreateMsiStorage(pLockBytes, rpiStorage);
};

HRESULT OpenRootStorage(const ICHAR* szPath, ismEnum ismOpenMode, IStorage** ppiStorage)
{
	HRESULT hres = 0; //prevent warning
	const OLECHAR* pPathBuf;

	if (!szPath || IStrLen(szPath) > MAX_PATH)
		return STG_E_PATHNOTFOUND;

#ifdef UNICODE
	pPathBuf = szPath;
#else
	OLECHAR rgPathBuf[MAX_PATH];
	int cchWide = MultiByteToWideChar(CP_ACP, 0, szPath, -1, rgPathBuf, MAX_PATH);
	pPathBuf = rgPathBuf;
#endif

	
	// Even when STGM_SHARE_DENY_WRITE used with ismTransact, read permission is not granted

	// According to "8.3 Storage-related Functions and Interfaces" in "Specs: OLE 2.0 Design",
	// in the present Docfile implementation, direct mode on root level storage objects is
	// only supported with the simultaneous additional specification of:
	//
	// STGM_READ      | STGM_SHARE_DENY_WRITE, or
	// STGM_READWRITE | STGM_SHARE_EXCLUSIVE , or
	// STGM_PRIORITY  | STGM_READ

	DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE; // initialize for ismDirect
	int cRetry;
	switch (ismOpenMode)
	{
	case ismCreate:
		grfMode |= STGM_TRANSACTED;  // fall through to case ismCreateDirect
	case ismCreateDirect:
		hres = OLE32::StgCreateDocfile(pPathBuf, grfMode | STGM_CREATE, 0, ppiStorage);
		break;
	case ismReadOnly:
		grfMode  = STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READ;  // fall through, STGM_TRANSACTED and STGM_SHARE_EXCLUSIVE turned off below
	case ismTransact:
		grfMode ^= STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_SHARE_DENY_WRITE; // fall through, STGM_SHARE_EXCLUSIVE turned off below
	case ismDirect:
		cRetry = 0;
		do
		{
			if (cRetry)
				WIN::Sleep(cRetry);
			hres = OLE32::StgOpenStorage(pPathBuf, (IStorage*)0, grfMode, (SNB)0, 0, ppiStorage);
		} while (hres == STG_E_LOCKVIOLATION && (cRetry+=10) <= 200);  // keep adding time on each retry
		break;
	default: 
		Assert(0);
		hres = E_INVALIDARG;
	};
	return hres;
}

IMsiRecord* CreateMsiStorage(const ICHAR* szPath, ismEnum ismOpenMode, IMsiStorage*& rpiStorage)
{
	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(szPath) == fTrue) ? fTrue : fFalse;
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	IStorage* piStorage;
	HRESULT hres = OpenRootStorage(szPath, ismEnum(ismOpenMode & idoOpenModeMask), &piStorage);
	if(fImpersonate)
		StopImpersonating();
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbOpenStorage), szPath, hres);
	rpiStorage = new CMsiStorage(*piStorage, ismOpenMode, 0, true);
	piStorage->Release();
	return 0;
}

CMsiStorage::CMsiStorage(IStorage& riStorage, ismEnum ismOpenMode, CMsiStorage* piParent, bool fFile)
	: m_riStorage(riStorage), m_ismOpenMode(ismEnum(ismOpenMode & idoOpenModeMask)), m_piParent(piParent),
	  m_fCommit(fFalse), m_idorDeleteOnRelease(idorDontDelete), m_piStreams(0)
{
	m_fRawStreamNames = (ismOpenMode & ismRawStreamNames) != 0 || GetTestFlag('Z'); //!! temp option to force old storage name format
	riStorage.AddRef();
	g_cInstances++;
	AddRefAllocator();
	if (piParent)
		piParent->AddRef();  // hold parent until we're released
	Debug(m_Ref.m_pobj = this);

	m_fNetworkFile = false;
	
	if (fFile)
	{
		MsiString riString;

		AssertRecord(GetName(*&riString));
		// Is this open across a network?

		if (FIsNetworkVolume(riString))
		{
			LOC::SetNoPowerdown();
			m_fNetworkFile = true;
		}
	}

#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}

CMsiStorage::~CMsiStorage()
{
	MsiString strStorageName;
	IMsiRecord* piError = Commit();  // flush an uncommited data to storage, should rollback instead?
	if (piError)
		SRV::SetUnhandledError(piError);
	Assert(m_piStreams == 0);
	if (m_fNetworkFile)
	{
		ClearNoPowerdown();
	}
	if (m_idorDeleteOnRelease != idorDontDelete)
	{
		// attempt remove created file or substorage, no error if failure
		AssertRecord(this->GetName(*&strStorageName));
		m_riStorage.Release();  // must release before file or storage can be deleted
		if (m_piParent)
			m_piParent->m_riStorage.DestroyElement(CConvertString((const ICHAR*)strStorageName));
		else
		{
			CElevate(m_idorDeleteOnRelease == idorElevateAndDelete &&
						false == GetImpersonationFromPath(strStorageName));

			DWORD dwRes = WIN::DeleteFile((const ICHAR*)strStorageName);
			if (dwRes == 0)
				SRV::SetUnhandledError(LOC::PostError(Imsg(idbgStgDelete), *strStorageName, GetLastError()));
		}
	}
	else // root file, not rolled back
		m_riStorage.Release();

	if (m_piParent)
		m_piParent->Release();  // now we can release parent

	RemoveObjectData(m_iCacheId);
}

HRESULT CMsiStorage::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiStorage))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiStorage::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiStorage::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	delete this;
	
	// These two lines are needed since CMsiStorage is an object in
	// the services dll but is independant of services
	// We need to do this after the memory is released
	ReleaseAllocator();
	g_cInstances--;
	return 0;
}

const IMsiString& CMsiStorage::GetMsiStringValue() const
{
	return g_MsiStringNull;
}

int CMsiStorage::GetIntegerValue() const
{
	return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiStorage::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiStorage::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL


const int cchEncode = 64;  // count of set of characters that can be compressed
const int cx = cchEncode;  // character to indicate non-compressible
const int chDoubleCharBase = 0x3800;  // offset for double characters, abandoned Hangul Unicode block
const int chSingleCharBase = chDoubleCharBase + cchEncode*cchEncode;  // offset for single characters, just after double characters
const int chCatalogStream  = chSingleCharBase + cchEncode; // prefix character for system table streams
const int cchMaxStreamName = 31;  // current OLE docfile limit on stream names

const unsigned char rgDecode[cchEncode] = 
{ '0','1','2','3','4','5','6','7','8','9',
  'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
  'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
  '.' , '_' };

const unsigned char rgEncode[128] =
{ cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,62,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,
  cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,cx,62,cx, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,cx,cx,cx,cx,cx,cx,
//(sp)!  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?
  cx,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,cx,cx,cx,cx,63,
// @, A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _ 
  cx,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,cx,cx,cx,cx,cx};
// ` a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~ 0x7F

bool CompressStreamName(const OLECHAR* pchIn, OLECHAR* pchOut, int fSystem)  // pchOut must be cchMaxStreamName characters + 1
{
	unsigned int ch, ch1, ch2;
	unsigned int cchLimit = cchMaxStreamName;
	if (fSystem)
	{
		*pchOut++ = chCatalogStream;
		cchLimit--;
	}
	while ((ch = *pchIn++) != 0)
	{
		if (cchLimit-- == 0)  // need check to avoid 32-character stream name bug in OLE32
			return false;
		if (ch < sizeof(rgEncode) && (ch1 = rgEncode[ch]) != cx) // compressible character
		{
			ch = ch1 + chSingleCharBase;
			if ((ch2 = *pchIn) != 0 && ch2 < sizeof(rgEncode) && (ch2 = rgEncode[ch2]) != cx)
			{
				pchIn++;  // we'll take it, else let it go through the loop again
				ch += (ch2 * cchEncode + chDoubleCharBase - chSingleCharBase);
			}
		}
		*pchOut++ = (OLECHAR)ch;
	}
	*pchOut = 0;
	return true;
}

int UncompressStreamName(const OLECHAR* pchIn, OLECHAR* pchOut)  // pchOut must be cchMaxStreamName*2 characters + 1
{
	unsigned int ch;
	int cch = 0;
	while ((ch = *pchIn++) != 0)
	{
		if (ch >= chDoubleCharBase && ch < chCatalogStream) // chCatalogStream tested before calling this function
		{
			if (ch >= chSingleCharBase)
				ch = rgDecode[ch - chSingleCharBase];
			else
			{
				ch -= chDoubleCharBase;
				*pchOut++ = OLECHAR(rgDecode[ch % cchEncode]);
				cch++;
				ch = rgDecode[ch / cchEncode];
			}
		}
		*pchOut++ = OLECHAR(ch);
		cch++;
	}
	*pchOut = 0;
	return cch;
}

IMsiRecord* CMsiStorage::OpenStream(const ICHAR* szName, Bool fWrite,
												IMsiStream*& rpiStream)
{
	HRESULT hres;
	bool fStat;
	OLECHAR rgPathBuf[cchMaxStreamName*2 + 1 + 1];
	const OLECHAR* pchName;
#ifdef UNICODE
	if (m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = szName;
		fStat = lstrlenW(szName) <= cchMaxStreamName;
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(szName, rgPathBuf, fWrite & iCatalogStreamFlag);
	}
#else // !UNICODE
	int cch = MultiByteToWideChar(CP_ACP, 0, szName, -1, rgPathBuf + 1, cchMaxStreamName*2 + 1);
	if (m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = rgPathBuf + 1;
		fStat = (cch > 0);
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(rgPathBuf + 1, rgPathBuf, fWrite & iCatalogStreamFlag);
	}
#endif
	if (fStat == false)
		return LOC::PostError(Imsg(idbgStgInvalidStreamName), szName);

	IStream* piStream;
	if (fWrite & fTrue)
	{
		hres = m_riStorage.CreateStream(pchName,
						STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
						0, 0, &piStream);
	}
	else // open for read
	{
		hres = m_riStorage.OpenStream(pchName,0,
						STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &piStream);
	}
	if (hres != NOERROR)
	{
		rpiStream = 0;
		return LOC::PostError(hres == STG_E_FILENOTFOUND ? Imsg(idbgStgStreamMissing)
														 : Imsg(idbgStgOpenStream), szName, hres);
	}
	rpiStream = new CMsiStream(*this, *piStream, Bool(fWrite & fTrue));
	return 0;
}

IMsiRecord* CMsiStorage::RemoveElement(const ICHAR* szName, Bool fStorage)
{
	bool fStat;
	OLECHAR rgPathBuf[cchMaxStreamName*2 + 1 + 1];
	const OLECHAR* pchName;
#ifdef UNICODE
	if ((fStorage & fTrue) || m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = szName;
		fStat = lstrlenW(szName) <= cchMaxStreamName;
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(szName, rgPathBuf, fStorage & iCatalogStreamFlag);
	}
#else // !UNICODE
	int cch = MultiByteToWideChar(CP_ACP, 0, szName, -1, rgPathBuf + 1, cchMaxStreamName*2 + 1);
	if ((fStorage & fTrue) || m_fRawStreamNames || szName[0] == '\005')
	{
		pchName = rgPathBuf + 1;
		fStat = (cch > 0);
	}
	else
	{
		pchName = rgPathBuf;
		fStat = CompressStreamName(rgPathBuf + 1, rgPathBuf, fStorage & iCatalogStreamFlag);
	}
#endif
	if (fStat == false)
		return LOC::PostError(Imsg(idbgStgInvalidStreamName), szName);
	HRESULT hres = m_riStorage.DestroyElement(pchName);
	if (hres != NOERROR)
		return LOC::PostError(hres == STG_E_FILENOTFOUND ? Imsg(idbgStgStreamMissing)
														 : Imsg(idbgStgOpenStream), szName, hres);
	return 0;
}

IMsiRecord* CMsiStorage::RenameElement(const ICHAR* szOldName, const ICHAR* szNewName, Bool fStorage)
{
	bool fStat;
	OLECHAR rgOldBuf[cchMaxStreamName*2 + 1 + 1];
	OLECHAR rgNewBuf[cchMaxStreamName*2 + 1 + 1];
	const OLECHAR* pchOldName;
	const OLECHAR* pchNewName;
#ifdef UNICODE
	if ((fStorage & fTrue) || m_fRawStreamNames || szOldName[0] == '\005')
	{
		pchOldName = szOldName;
		fStat = lstrlenW(szOldName) <= cchMaxStreamName;
	}
	else
	{
		pchOldName = rgOldBuf;
		fStat = CompressStreamName(szOldName, rgOldBuf, fStorage & iCatalogStreamFlag);
	}
	if ((fStorage & fTrue) || m_fRawStreamNames || szNewName[0] == '\005')
	{
		pchNewName = szNewName;
		fStat = fStat && lstrlenW(szNewName) <= cchMaxStreamName;
	}
	else
	{
		pchNewName = rgNewBuf;
		fStat = fStat && CompressStreamName(szNewName, rgNewBuf, fStorage & iCatalogStreamFlag);
	}
#else // !UNICODE
	int cchOld = MultiByteToWideChar(CP_ACP, 0, szOldName, -1, rgOldBuf + 1, cchMaxStreamName*2 + 1);
	if ((fStorage & fTrue) || m_fRawStreamNames || szOldName[0] == '\005')
	{
		pchOldName = rgOldBuf + 1;
		fStat = (cchOld > 0);
	}
	else
	{
		pchOldName = rgOldBuf;
		fStat = CompressStreamName(rgOldBuf + 1, rgOldBuf, fStorage & iCatalogStreamFlag);
	}
	int cchNew = MultiByteToWideChar(CP_ACP, 0, szNewName, -1, rgNewBuf + 1, cchMaxStreamName*2 + 1);
	if ((fStorage & fTrue) || m_fRawStreamNames || szNewName[0] == '\005')
	{
		pchNewName = rgNewBuf + 1;
		fStat = fStat && (cchNew > 0);
	}
	else
	{
		pchNewName = rgNewBuf;
		fStat = fStat && CompressStreamName(rgNewBuf + 1, rgNewBuf, fStorage & iCatalogStreamFlag);
	}
#endif
	if (fStat == false)
		return LOC::PostError(Imsg(idbgStgInvalidStreamName), szNewName);
	HRESULT hres = m_riStorage.RenameElement(pchOldName, pchNewName);
	if (hres != NOERROR)
		return LOC::PostError(hres == STG_E_FILENOTFOUND ? Imsg(idbgStgStreamMissing)
														 : Imsg(idbgStgRenameElement), szOldName, hres);
	return 0;
}

Bool CMsiStorage::DeleteOnRelease(bool fElevateToDelete)
{
	m_idorDeleteOnRelease = fElevateToDelete ? idorElevateAndDelete : idorDelete;
	return fTrue;
}

IMsiRecord* CMsiStorage::OpenStorage(const ICHAR* szName, ismEnum ismOpenMode, IMsiStorage*& rpiStorage)
{
	HRESULT hres = 0; //prevent warning
	IStorage* piStorage = NULL;
	if (szName == 0) // null name, mechanism for setting open non-OLE attributes after open
	{
		if ((ismOpenMode & idoOpenModeMask) == 0)
		{
			m_fRawStreamNames = true;
			return 0;
		}
	}	// else allow to fail below

// STGM_SHARE_DENY_WRITE doesn't work, gives a grf flags wrong error
	DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
	switch (ismOpenMode)
	{
	case ismCreate:  // seems to be OK if child specifies transacted with direct mode parent
		grfMode |= STGM_TRANSACTED;  // fall through to case ismCreateDirect
	case ismCreateDirect:
		hres = m_riStorage.CreateStorage(CConvertString(szName), grfMode | STGM_CREATE, /*dwStgFmt*/0, 0, &piStorage);
		break;
	case ismReadOnly:
		grfMode ^= (STGM_TRANSACTED ^ STGM_READ ^ STGM_READWRITE); // fall through
	case ismTransact:
		grfMode ^= STGM_TRANSACTED;  // fall through
	case ismDirect:
		hres = m_riStorage.OpenStorage(CConvertString(szName), (IStorage*)0, grfMode, (SNB)0, 0, &piStorage);
		break;
	default: 
		Assert(0);
		hres = E_INVALIDARG;
	};
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbOpenStorage), szName, hres);
		
	rpiStorage = new CMsiStorage(*piStorage, ismOpenMode, this, false);
	piStorage->Release();
	
	return 0;
}

IMsiRecord* CMsiStorage::SetClass(const IID& riid)
{
	HRESULT hres = m_riStorage.SetClass(riid);
	if (hres != NOERROR)
		return LOC::PostError(Imsg(idbgDbCommitTables), 0, hres);
	return 0;
}

Bool CMsiStorage::GetClass(IID* piid)
{
	STATSTG statstg;
	HRESULT hres = m_riStorage.Stat(&statstg, STATFLAG_NONAME);
	if (hres != NOERROR)
		memcpy((void*)&statstg.clsid, &IID_NULL, sizeof(GUID));
	if (piid)
		memcpy(piid, &statstg.clsid, sizeof(GUID));
	return (memcmp(&statstg.clsid, &IID_NULL, sizeof(GUID)) ? fTrue : fFalse);
}

IMsiRecord* CMsiStorage::Rollback()
{
	if (m_ismOpenMode != ismReadOnly)
	{
		for (CMsiStream** ppPrev = &m_piStreams;
							  *ppPrev != 0;
								ppPrev = &((*ppPrev)->m_piNextStream))
			(*ppPrev)->Flush();
		HRESULT hres = m_riStorage.Revert();
		if (hres != NOERROR)
			return LOC::PostError(Imsg(idbgStgRollback), 0, hres);
	}
	if (!m_fCommit && m_ismOpenMode == ismCreate) // rollback created root file
		m_idorDeleteOnRelease = idorDelete;
	return 0;
}

IMsiRecord* CMsiStorage::Commit()
{
	if (m_ismOpenMode != ismReadOnly)
	{
		for (CMsiStream** ppPrev = &m_piStreams;
							  *ppPrev != 0;
								ppPrev = &((*ppPrev)->m_piNextStream))
			(*ppPrev)->Flush();
		HRESULT hres = m_riStorage.Commit(STGC_OVERWRITE);
		if (hres != NOERROR)
			return LOC::PostError(Imsg(idbgStgCommit), 0, hres);
	}
	m_fCommit = fTrue;
	return 0;
}

IMsiRecord* CMsiStorage::CreateSummaryInfo(unsigned int cMaxProperties,
														 IMsiSummaryInfo*& rpiSummary)
{
	return CMsiSummaryInfo::Create(*this, cMaxProperties, rpiSummary);
}

IMsiRecord* CMsiStorage::CopyTo(IMsiStorage& riDestStorage, IMsiRecord* piExcludedStreams) // could add another arg for excluded storages
{
	WCHAR** snbExclude = 0;
	CTempBuffer<WCHAR, MAX_PATH> SNB;

	if (piExcludedStreams)
	{
		// we need to create a String Name Block. See MSDN (under "SNB") for details

		unsigned int cString = piExcludedStreams->GetFieldCount();
		unsigned int cchStrings = 0;

		for (int c = 1; c <= cString; c++)
		{
			cchStrings += MsiString(piExcludedStreams->GetMsiString(c)).TextSize() + 1;
		}

		unsigned int cchSNB = (cString+1)*sizeof(WCHAR*)/sizeof(WCHAR) + cchStrings + 1; // extra char for compressions inplace
		if (SNB.GetSize() < cchSNB)
			SNB.SetSize(cchSNB);

		snbExclude = (WCHAR**)(WCHAR*)SNB; // do this _after_ we've resized the buffer
		
		WCHAR* psz = (WCHAR*)(((WCHAR**)(WCHAR*)SNB)+(cString+1)) + 1; // offset by 1 for compression inplace
		WCHAR** ppsz = (WCHAR**)(WCHAR*)SNB;

		for (c = 1; c <= cString; c++)
		{
			WCHAR* pch = psz;  // final location of processed stream name
			lstrcpyW(psz, CConvertString(piExcludedStreams->GetString(c)));
			if (!m_fRawStreamNames && psz[0] != '\005')
				CompressStreamName(psz, --pch, 0);  // never can exclude system streams
			*ppsz++ = pch;
			psz += (lstrlenW(pch) + 1);
		}
		*ppsz = 0;
	}

	HRESULT hRes = m_riStorage.CopyTo(0, 0, snbExclude, 
									   &(static_cast<CMsiStorage*>(&riDestStorage)->m_riStorage));
	if (hRes != NOERROR)
		return LOC::PostError(Imsg(idbgStgCopyTo), 0, hRes);

	return 0;
}

IMsiRecord* CMsiStorage::GetName(const IMsiString*& rpiName)
{
	STATSTG statstg;
	HRESULT hRes = m_riStorage.Stat(&statstg, STATFLAG_DEFAULT); // retrieve file name
	if (ERROR_SUCCESS != hRes)
		return LOC::PostError(Imsg(idbgStgStatFailed), 0, hRes);

	MsiString(CConvertString(statstg.pwcsName)).ReturnArg(rpiName);
	IMalloc* piMalloc;
	AssertZero(OLE32::CoGetMalloc(MEMCTX_TASK, &piMalloc));
	piMalloc->Free(statstg.pwcsName);
	piMalloc->Release();
	return 0;
}

IMsiRecord* CMsiStorage::GetSubStorageNameList(const IMsiString*& rpiTopParent, const IMsiString*& rpiSubStorageList)
{
	MsiString strName;

	IMsiRecord* piError = GetName(*&strName);
	if(piError)
		return piError;

	if(!m_piParent)
	{
		// top-level storage
		strName.ReturnArg(rpiTopParent);
		MsiString strNull;
		strNull.ReturnArg(rpiSubStorageList);
		return 0;
	}
	else
	{
		// sub-storage
		MsiString strTopParent, strSubStorageList;
		
		piError = m_piParent->GetSubStorageNameList(*&strTopParent, *&strSubStorageList);
		if(piError)
			return piError;

		AssertSz(strTopParent.TextSize(), "parent storage returned empty name");

		if(strSubStorageList.TextSize())
		{
			strSubStorageList += MsiChar(':');
		}

		strSubStorageList += strName;

		strTopParent.ReturnArg(rpiTopParent);
		strSubStorageList.ReturnArg(rpiSubStorageList);
		return 0;
	}
}

bool CMsiStorage::ValidateStorageClass(ivscEnum ivsc)
{
	return SRV::ValidateStorageClass(m_riStorage, ivsc);
}

//____________________________________________________________________________
//
//  CEnumStorage - stream/storage enumerator within storage
//____________________________________________________________________________

class CEnumStorage : public IEnumMsiString
{
 public:  // implemented virtuals
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched);
	HRESULT __stdcall Skip(unsigned long cSkip);
	HRESULT __stdcall Reset();
	HRESULT __stdcall Clone(IEnumMsiString** ppiEnum);
 public:  // construct/destructor
	CEnumStorage(IStorage& riStorage, bool fStorages, bool fRawStreamNames);
	CEnumStorage(IEnumSTATSTG* piEnum, IMalloc* piMalloc, bool fStorages, bool fRawStreamNames);
	void* ConstructedOK();
 protected:
	virtual ~CEnumStorage(void);  // protected to prevent creation on stack
	unsigned long    m_iRefCnt;      // reference count
	IEnumSTATSTG*    m_piEnum;       // OLE enumerator
	IMalloc*         m_piMalloc;     // OLE allocator
	bool             m_fStorages;    // fTrue: storages, fFalse: streams
	bool             m_fRawStreamNames;
};

IEnumMsiString* CMsiStorage::GetStorageEnumerator()
{
	CEnumStorage* piEnum = new CEnumStorage(m_riStorage, fTrue, fTrue);
	if (piEnum && !piEnum->ConstructedOK())
	{
		piEnum->Release();
		piEnum = 0;
	}
	return piEnum;
}

IEnumMsiString* CMsiStorage::GetStreamEnumerator()
{
	CEnumStorage* piEnum = new CEnumStorage(m_riStorage, fFalse, m_fRawStreamNames);
	if (piEnum && !piEnum->ConstructedOK())
	{
		piEnum->Release();
		piEnum = 0;
	}
	return piEnum;
}

CEnumStorage::CEnumStorage(IStorage& riStorage, bool fStorages, bool fRawStreamNames)
	: m_piEnum(0), m_piMalloc(0), m_fStorages(fStorages), m_fRawStreamNames(fRawStreamNames)
	, m_iRefCnt(1)
{
	if (OLE32::CoGetMalloc(MEMCTX_TASK, &m_piMalloc) != NOERROR)
		return;  // should never happen unless OLE messed up
	if (riStorage.EnumElements(0, 0, 0, &m_piEnum) != NOERROR)
		m_piMalloc->Release();
}

CEnumStorage::CEnumStorage(IEnumSTATSTG* piEnum, IMalloc* piMalloc, bool fStorages, bool fRawStreamNames)
	: m_piEnum(piEnum), m_piMalloc(piMalloc), m_iRefCnt(1), m_fStorages(fStorages), m_fRawStreamNames(fRawStreamNames)
{
}

void* CEnumStorage::ConstructedOK()
{
	return m_piEnum;
}

CEnumStorage::~CEnumStorage()
{
	if (m_piMalloc)
		m_piMalloc->Release();
	if (m_piEnum)
		m_piEnum->Release();
}

HRESULT CEnumStorage::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumMsiString)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumStorage::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumStorage::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CEnumStorage::Next(unsigned long cFetch, const IMsiString** rgpi, unsigned long* pcFetched)
{
	STATSTG statstg;
	if (!rgpi)
		return S_FALSE;
	int cFetched = 0;
	unsigned long cRequested = cFetch;
	int cch;
	OLECHAR rgchName[cchMaxStreamName * 2 + 1];
	OLECHAR* pch;
	while (cFetch)
	{
		if (m_piEnum->Next(1, &statstg, 0) != NOERROR)
			break;
		if (!statstg.pwcsName)
			continue;
		if ((statstg.type == STGTY_STREAM && !m_fStorages)
		 || (statstg.type == STGTY_STORAGE && m_fStorages))
		{
			const IMsiString* piStr = &SRV::g_MsiStringNull;
#ifdef UNICODE
			if (m_fStorages || m_fRawStreamNames)
				pch = statstg.pwcsName;
			else if (statstg.pwcsName[0] == chCatalogStream)
			{
				m_piMalloc->Free(statstg.pwcsName);
				continue;
			}
			else
				cch = UncompressStreamName(statstg.pwcsName, pch = rgchName);
			piStr->SetString(pch, piStr);
#else // !UNICODE
			if (m_fStorages || m_fRawStreamNames)
				cch = lstrlenW(pch = statstg.pwcsName);
			else if (statstg.pwcsName[0] == chCatalogStream)
			{
				m_piMalloc->Free(statstg.pwcsName);
				continue;
			}
			else
				cch = UncompressStreamName(statstg.pwcsName, pch = rgchName);
			int cb = WIN::WideCharToMultiByte(CP_ACP, 0, pch, cch, 0, 0, 0, 0);
			Bool fDBCS = (cb == cch ? fFalse : fTrue);
			ICHAR* pb = piStr->AllocateString(cb, fDBCS, piStr);
			BOOL fUsedDefault;
			WIN::WideCharToMultiByte(CP_ACP, 0, pch, cch, pb, cb, 0, &fUsedDefault);
#endif
			cFetch--;
			cFetched++;
			*rgpi++ = piStr;  // ref count transferred to caller
		}
		m_piMalloc->Free(statstg.pwcsName);
	}
	if (pcFetched)
		*pcFetched = cFetched;
	//return (cFetched == cFetch ? S_OK : S_FALSE);FIXmsh
	return (cFetched == cRequested ? S_OK : S_FALSE);
}


HRESULT CEnumStorage::Skip(unsigned long cSkip)
{
	return m_piEnum->Skip(cSkip);
}

HRESULT CEnumStorage::Reset()
{
	return m_piEnum->Reset();
}

HRESULT CEnumStorage::Clone(IEnumMsiString** ppiEnum)
{
	IEnumSTATSTG* piEnum;
	HRESULT hres = m_piEnum->Clone(&piEnum);
	if (hres != NOERROR)
		return hres;
	*ppiEnum = new CEnumStorage(piEnum, m_piMalloc, m_fStorages, m_fRawStreamNames);
	return *ppiEnum ? NOERROR: E_OUTOFMEMORY;
}

//____________________________________________________________________________
//
//  CMsiMemoryStream defintions
//____________________________________________________________________________

class CMsiMemoryStream : public IMsiMemoryStream
{
 public:  // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
#ifdef USE_OBJECT_POOL
	unsigned int  __stdcall GetUniqueId() const;
	void          __stdcall SetUniqueId(unsigned int id);
#endif //USE_OBJECT_POOL
	unsigned int  __stdcall Remaining() const;
	unsigned int  __stdcall GetData(void* pch, unsigned int cb);
	void          __stdcall PutData(const void* pch, unsigned int cb);
	short         __stdcall GetInt16();
	int           __stdcall GetInt32();
	void          __stdcall PutInt16(short i);
	void          __stdcall PutInt32(int i);
	Bool          __stdcall Error();
	void          __stdcall Reset();
	void          __stdcall Seek(int position);
	IMsiStream*   __stdcall Clone();
	void          __stdcall Flush();
	const char*   __stdcall GetMemory() { return m_rgbData; }
 public: // constructor, destructor
	CMsiMemoryStream(const char* rgbData, unsigned int cbSize, Bool fDelete, Bool fWrite);
 protected:
  ~CMsiMemoryStream();  // protected to prevent creation on stack
 private:
	int          m_iRefCnt;      // COM reference count
	Bool         m_fDelete;
	const char*  m_rgbData;
	Bool         m_fWrite;
	unsigned int m_cbLength;
	unsigned int m_cbRemaining;
	issEnum		 m_issState;
	Bool		 m_fReadOnly;
	unsigned int m_cbSize;
#ifdef USE_OBJECT_POOL
	unsigned int m_iCacheId;
#endif //USE_OBJECT_POOL
};

//____________________________________________________________________________
//
//  Implementation of CMsiMemoryStream
//____________________________________________________________________________

char* AllocateMemoryStream(unsigned int cbSize, IMsiStream*& rpiStream)
{
	CMsiMemoryStream* piStream = 0;
	char* rgbBuffer = new char[cbSize];
	if (rgbBuffer != 0 && (piStream = new CMsiMemoryStream(rgbBuffer, cbSize, fTrue, fTrue)) == 0)
	{
		delete rgbBuffer;
		rgbBuffer = 0;
	}
	rpiStream = piStream;
	return rgbBuffer;
}

IMsiStream* CreateStreamOnMemory(const char* pbReadOnly, unsigned int cbSize)
{
	return new CMsiMemoryStream(pbReadOnly, cbSize, fFalse, fFalse);
}

CMsiMemoryStream::CMsiMemoryStream(const char* rgbData, unsigned int cbSize, Bool fDelete, Bool fWrite)
	: m_rgbData(rgbData), m_cbLength(cbSize), m_cbRemaining(cbSize), m_fDelete(fDelete)
	, m_issState(issReset), m_fWrite(fWrite)
{
	m_iRefCnt = 1;
#ifdef USE_OBJECT_POOL
	m_iCacheId = 0;
#endif //USE_OBJECT_POOL
}

CMsiMemoryStream::~CMsiMemoryStream()
{
	RemoveObjectData(m_iCacheId);
	if (m_fDelete)
		delete const_cast<char*>(m_rgbData);
}

HRESULT CMsiMemoryStream::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiStream)
	 || MsGuidEqual(riid, IID_IMsiMemoryStream)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiMemoryStream::AddRef()
{
	return ++m_iRefCnt;
}
unsigned long CMsiMemoryStream::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiMemoryStream::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiMemoryStream::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

const IMsiString& CMsiMemoryStream::GetMsiStringValue() const
{
#ifdef UNICODE
	const IMsiString* piString;
	ICHAR* pch;
	
	if (m_cbLength == 0)
		return SRV::CreateString();

	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, m_rgbData, m_cbLength, 0, 0); //!! should use m_iCodepage from database, but how?
	pch = SRV::AllocateString(cch, fFalse, piString);
	if ( pch )
	{
		WIN::MultiByteToWideChar(CP_ACP, 0, m_rgbData, m_cbLength, pch, cch);
		return *piString;
	}
	else 
		return g_riMsiStringNull;
#else
	return SRV::CreateStringComRef(*m_rgbData, m_cbLength, *this);
#endif
}

int CMsiMemoryStream::GetIntegerValue() const
{
	return m_cbLength;
}

unsigned int CMsiMemoryStream::Remaining() const
{
	return m_cbRemaining;
}

unsigned int CMsiMemoryStream::GetData(void* pch, unsigned int cb)
{
	if (m_issState != issRead)	// first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbRemaining = m_cbLength;
	}
	
	if (cb > m_cbRemaining)
	{
		cb = m_cbRemaining;
		m_issState = issError;
	}
	memcpy(pch, m_rgbData+(m_cbLength-m_cbRemaining), cb);
	m_cbRemaining -= cb;
	return cb;
}

void CMsiMemoryStream::PutData(const void* pch, unsigned int cb)
{
	if (m_issState != issWrite) // first write
	{
		if (!m_fWrite || m_issState != issReset)
		{
			m_issState = issError;
			return;
		}
		m_issState = issWrite;
	}

	if (cb > m_cbRemaining)
	{
		// Need to allocate more space
		unsigned int cbNew;
		unsigned int cbSize = m_cbLength + (cbNew = (cb < 256 ? 256 : cb * 2));
		char* rgbBuffer = new char[cbSize];
		if (rgbBuffer == 0)
		{
			m_issState = issError;
			return;
		}
		memcpy(rgbBuffer, m_rgbData, m_cbLength - m_cbRemaining);
		m_cbRemaining += cbNew;
		m_cbLength = cbSize;
		const char *pchT = m_rgbData;
		m_rgbData = rgbBuffer;
		Assert(m_fDelete);
		delete const_cast<char*>(pchT);
	}
	memcpy((void *)(m_rgbData+(m_cbLength-m_cbRemaining)), pch, cb);
	m_cbRemaining -= cb;
	Assert(m_cbRemaining <= m_cbLength);
}

short CMsiMemoryStream::GetInt16()
{
	if (m_issState != issRead)	// first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbRemaining = m_cbLength;
	}
	
	if (m_cbRemaining < sizeof(short))
	{
		m_issState = issError;
		m_cbRemaining = 0;
		return 0;
	}
	unsigned int iOffset = m_cbLength-m_cbRemaining;
	m_cbRemaining -= sizeof(short);
	return *(short UNALIGNED *)(m_rgbData + iOffset);
}

int CMsiMemoryStream::GetInt32()
{
	if (m_issState != issRead)	// first read
	{
		if (m_issState != issReset)
		{
			m_issState = issError;
			return 0;
		}
		m_issState = issRead;
		m_cbRemaining = m_cbLength;
	}
	
	if (m_cbRemaining < sizeof(int))
	{
		m_issState = issError;
		return (m_cbRemaining = 0);
	}
	unsigned int iOffset = m_cbLength-m_cbRemaining;
	m_cbRemaining -= sizeof(int);
	return *(int UNALIGNED *)(m_rgbData + iOffset);
}

void CMsiMemoryStream::PutInt16(short i)
{
	PutData(&i, sizeof(i));
}

void CMsiMemoryStream::PutInt32(int i)
{
	PutData(&i, sizeof(i));
}

Bool CMsiMemoryStream::Error()
{
	return (m_issState == issError ? fTrue : fFalse);
}

void CMsiMemoryStream::Reset()
{
	m_issState = issReset;
	m_cbRemaining = m_cbLength;
}

void CMsiMemoryStream::Seek(int cbPosition)
{
	if(m_cbLength < cbPosition || cbPosition < 0)
	{
		m_issState = issError;
		return;
	}
	m_cbRemaining = m_cbLength - cbPosition;
}

IMsiStream* CMsiMemoryStream::Clone()
{
	//!! need to chain together to handle m_fDelete!!
	return new CMsiMemoryStream(m_rgbData, m_cbLength, m_fDelete, m_fWrite);
}

void CMsiMemoryStream::Flush()
{
}

//____________________________________________________________________________
//
//  Implementation for IMsiSummaryInfo
//____________________________________________________________________________

// NOTE: cannot access integers directory from stream buffer, byte order reversed on Mac

IMsiRecord* CMsiSummaryInfo::Create(CMsiStorage& riStorage, unsigned int cMaxProperties,
												IMsiSummaryInfo*& rpiSummary)
{
	rpiSummary=0; 
	CMsiSummaryInfo* This = 0;
	IMsiStream* piStream;
	IMsiRecord* piError = riStorage.OpenStream(szSummaryStream, fFalse, piStream);
	if (piError)
	{
		if (piError->GetInteger(1) != idbgStgStreamMissing)
			return piError;
		piError->Release();
	}
	int cbStream = piStream ? piStream->GetIntegerValue() : 0;
	Bool fError = fFalse;
	if (riStorage.GetOpenMode() == ismReadOnly)
		cMaxProperties = 0;  // no changes allowed
	if ((This = new(cbStream, cMaxProperties) CMsiSummaryInfo(cbStream, cMaxProperties)) == 0)
		fError = fTrue;
	else if (cbStream)
	{
		piStream->GetData(This->m_pvStream, cbStream);
		fError = piStream->Error();  // check FMTID also?
	}
	if (piStream)
		piStream->Release();
	if (fError)
	{
		if (This)
			This->Release();
		return LOC::PostError(Imsg(idbgStgOpenStream), szSummaryStream+1, E_OUTOFMEMORY);
	}
	if (cbStream)
	{
		int* pIndex = (int*)((char*)This->m_pvStream + cbSummaryHeader) - 1; // point to section offset
		int i = This->GetInt32(pIndex); // section offset
		Assert(i < cbStream);
		This->m_pbSection = (char*)This->m_pvStream + i; // start of section
		pIndex = (int*)This->m_pbSection;
		This->m_cbSection = This->GetInt32(pIndex++);
		Assert(This->m_cbSection <= cbStream - cbSummaryHeader); // section size
		This->m_cOldProp = This->GetInt32(pIndex++); // number of properties, skip over section size
		This->m_pPropertyIndex = pIndex;  // start of PID/offset pairs
		rpiSummary = This;
#ifdef UNICODE
		This->GetIntegerProperty(PID_CODEPAGE, This->m_iCodepage);
#endif
	}
	else
	{
		This->m_cOldProp = 0;
	}

	if (cMaxProperties != 0)
	{
		piError = riStorage.OpenStream(szSummaryStream, fTrue, piStream);
		if (piError)
		{
			This->Release();
			return piError;
		}
		This->m_piStream = piStream;
	}
	rpiSummary = This;
	return 0;
}

CMsiSummaryInfo::CMsiSummaryInfo(unsigned int cbStream, unsigned int cMaxProperties)
	: m_cbStream(cbStream), m_iCodepage(0), m_piStream(0)
	, m_cMaxProp(cMaxProperties), m_cNewProp(0), m_cOldProp(0), m_cDeleted(0)
{
	m_iRefCnt = 1;
	m_pvStream = (PropertyData*)(this + 1) + cMaxProperties;  // location of buffer for stream
}

CMsiSummaryInfo::~CMsiSummaryInfo()
{
	PropertyData* pData = GetPropertyData();
	for (int cProp = m_cNewProp; cProp--; pData++)
		if (pData->iType == VT_LPSTR)
			pData->piText->Release(); // release unprocessed strings
}

int CMsiSummaryInfo::GetPropertyCount()
{
	return m_cOldProp + m_cNewProp - m_cDeleted;
}

int CMsiSummaryInfo::GetPropertyType(int iPID)
{
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		if (iPID == PID_DICTIONARY)
			return VT_I4;  // type code missing, space used for count
		int i = GetInt32(pProp + 1); // offset to property data
		return GetInt32(pProp);
	}
	PropertyData* pData = FindNewProperty(iPID);
	if (pData)
		return pData->iType;
	return VT_EMPTY;
}

Bool CMsiSummaryInfo::RemoveProperty(int iPID)
{
	if (m_cMaxProp == 0)
		return fFalse;  // not updatable
	int* pIndex = m_pPropertyIndex;
	for (int cProp = m_cOldProp; cProp--; pIndex+=2)
		if (GetInt32(pIndex) == iPID)
		{
			*pIndex = PID_Deleted;
			m_cDeleted++;
			return fTrue;
		}
	PropertyData* pData = FindNewProperty(iPID);
	if (!pData)
		return fFalse;
	if (pData->iType == VT_LPSTR)
		pData->piText->Release();
	m_cNewProp--;
//	Assert(GetPropertyData() + m_cNewProp - pData <= INT_MAX);	//--merced: 64-bit ptr subtraction may theoretically lead to values too big for cb
	int cb = ((int)(INT_PTR)(GetPropertyData() + m_cNewProp - pData)) * sizeof(PropertyData);
	if (cb)
		memcpy(pData, pData + 1, cb);
	return fTrue;
}

HRESULT CMsiSummaryInfo::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown))  // No GUID for this guy yet
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiSummaryInfo::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiSummaryInfo::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	IMsiStream* piStream = m_piStream;
	delete this;
	if (piStream)  // release AFTER freeeing memory to avoid memory assert
		piStream->Release();
	return 0;
}

const IMsiString& CMsiSummaryInfo::GetStringProperty(int iPID)
{
	PropertyData* pData;
	const IMsiString* piStr = &SRV::CreateString();
	int iType, cbProp;
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		if (iPID != 0 && (iType = GetInt32(pProp++)) == VT_LPSTR
						  && (cbProp = GetInt32(pProp++)) > 1)
		{
				Assert(((char*)pProp)[cbProp-1] == 0);
#ifdef UNICODE
				int cch = WIN::MultiByteToWideChar(m_iCodepage, 0, (char*)pProp, cbProp-1, 0, 0);
				ICHAR* pch = SRV::AllocateString(cch, fFalse, piStr);
				if ( pch )
				    WIN::MultiByteToWideChar(m_iCodepage, 0, (char*)pProp, cbProp-1, pch, cch);
#else
				piStr->SetString((const ICHAR*)pProp, piStr);
#endif
		}
	}
	else if ((pData = FindNewProperty(iPID)) != 0)
	{
		if (pData->iType == VT_LPSTR)
			(piStr = pData->piText)->AddRef();
	}
	return *piStr;
}

Bool CMsiSummaryInfo::GetFileTimeProperty(int iPID, FILETIME& rftDateTime)
{
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		int iType = GetInt32(pProp++);
		if (iPID == 0 || iType != VT_FILETIME)
			return fFalse;
		rftDateTime.dwLowDateTime = GetInt32(pProp++);
		rftDateTime.dwHighDateTime = GetInt32(pProp);
	}
	else
	{
		PropertyData* pData = FindNewProperty(iPID);
		if (!pData || pData->iType != VT_FILETIME)
			return fFalse;
		rftDateTime.dwLowDateTime  = pData->iLow;
		rftDateTime.dwHighDateTime = pData->iHigh;
	}
	return fTrue;
}

Bool CMsiSummaryInfo::GetTimeProperty(int iPID, MsiDate& riDateTime)
{
	FILETIME ft;
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		int iType = GetInt32(pProp++);
		if (iPID == 0 || iType != VT_FILETIME)
			return fFalse;
		ft.dwLowDateTime = GetInt32(pProp++);
		ft.dwHighDateTime = GetInt32(pProp);
	}
	else
	{
		PropertyData* pData = FindNewProperty(iPID);
		if (!pData || pData->iType != VT_FILETIME)
			return fFalse;
		ft.dwLowDateTime  = pData->iLow;
		ft.dwHighDateTime = pData->iHigh;
	}
	unsigned short iDosOffset = 0;
	if (ft.dwHighDateTime <  iFileTimeOneDayHigh
	|| (ft.dwHighDateTime == iFileTimeOneDayHigh
	 && ft.dwLowDateTime  <  iFileTimeOneDayLow))
	{  // add 1/1/1980, then subtract it off again
		ft.dwLowDateTime  += iFileTimeDosBaseLow;
		ft.dwHighDateTime += iFileTimeDosBaseHigh;
		if(ft.dwLowDateTime < iFileTimeDosBaseLow)
			ft.dwHighDateTime++;
		iDosOffset = 0x0021;
	}
	unsigned short wDosDate, wDosTime;
	if (iDosOffset == 0 && !::FileTimeToLocalFileTime(&ft, &ft))
		return fFalse;
	if (!::FileTimeToDosDateTime(&ft, &wDosDate, &wDosTime))
		return fFalse;
//	wDosDate -= iDosOffset;  //!! could not elimnate warning
	wDosDate  = unsigned short(wDosDate - iDosOffset);
	riDateTime = (MsiDate)((wDosDate << 16) | wDosTime);
	return fTrue;
}

Bool CMsiSummaryInfo::GetIntegerProperty(int iPID, int& iValue)
{
	int* pProp = FindOldProperty(iPID);
	if (pProp)
	{
		int iType = GetInt32(pProp++);
		if (iPID == PID_DICTIONARY)
			iValue = iType;
		else if (iType == VT_I2)
			iValue = GetInt16(pProp);
		else if (iType == VT_I4)
			iValue = GetInt32(pProp);
		else
			return fFalse;
	}
	else
	{
		PropertyData* pData = FindNewProperty(iPID);
		if (!pData)
			return fFalse;
		int iType = pData->iType;
		if (iType == VT_I2 || iType == VT_I4)
			iValue = pData->iValue;
		else
			return fFalse;
	}
	return fTrue;
}

int* CMsiSummaryInfo::FindOldProperty(int iPID)
{
	int* pProp = m_pPropertyIndex;
	for (int cProp = m_cOldProp; cProp--; pProp++)
		if (GetInt32(pProp++) == iPID)
			return (int*)(m_pbSection + GetInt32(pProp));
	return 0;
}

PropertyData* CMsiSummaryInfo::FindNewProperty(int iPID)
{
	PropertyData* pData = GetPropertyData();
	for (int cProp = m_cNewProp; cProp--; pData++)
		if (pData->iPID == iPID)
			return pData;
	return 0;
}

int CMsiSummaryInfo::SetStringProperty(int iPID, const IMsiString& riText)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID = iPID;
	pData->iType = VT_LPSTR;
#ifdef UNICODE
	pData->cbText = WIN::WideCharToMultiByte(m_iCodepage, 0,
								riText.GetString(), -1, 0, 0, 0, 0);
#else
	pData->cbText = riText.TextSize() + 1;
#endif
	pData->piText = &riText;
	riText.AddRef();
	return ++m_cNewProp;
}

int CMsiSummaryInfo::SetFileTimeProperty(int iPID, FILETIME& rftDateTime)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID  = iPID;
	pData->iType = VT_FILETIME;
	pData->iLow  = rftDateTime.dwLowDateTime;
	pData->iHigh = rftDateTime.dwHighDateTime;
	return ++m_cNewProp;
}

int CMsiSummaryInfo::SetTimeProperty(int iPID, MsiDate iDateTime)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	FILETIME ft;
	int iDate = ((unsigned int)iDateTime)>>16;
	unsigned short usDate = (short)iDate;
	if (!iDate)
		usDate = 0x0021;  // offset to 1/1/80, lowest valid date

	if (!::DosDateTimeToFileTime(usDate, (short)iDateTime, &ft))
		return 0;
	if (!::LocalFileTimeToFileTime(&ft, &ft))
		return 0;
	if (!iDate)  // remove 1/1/80 if time only
	{
		if(ft.dwLowDateTime < iFileTimeDosBaseLow)
			ft.dwHighDateTime--;
		ft.dwLowDateTime  -= iFileTimeDosBaseLow;
		ft.dwHighDateTime -= iFileTimeDosBaseHigh;
	}
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID = iPID;
	pData->iType = VT_FILETIME;
	pData->iLow  = ft.dwLowDateTime;
	pData->iHigh = ft.dwHighDateTime;
	return ++m_cNewProp;
}

int CMsiSummaryInfo::SetIntegerProperty(int iPID, int iValue)
{
	RemoveProperty(iPID);
	if (m_cNewProp >= m_cMaxProp)
		return 0;
	PropertyData* pData = GetPropertyData() + m_cNewProp;
	pData->iPID = iPID;
	pData->iType = (iPID == PID_CODEPAGE ? VT_I2 : VT_I4);
	pData->iValue = (iPID == PID_CODEPAGE ? (unsigned short)iValue : iValue);
#ifdef UNICODE
	if (iPID == PID_CODEPAGE)
		m_iCodepage = iValue;
#endif
	return ++m_cNewProp;
}

int GetPropSize(int iPID, char* pbData)  // ID + data
{
	if (iPID == 0 || iPID == PID_Deleted)
		return 0;  // we don't do dictionaries
	int iType = *(int*)pbData;
	int	cb;
	switch (iType)
	{
	case VT_I2:
	case VT_I4:
		return 2 * sizeof(int);
	case VT_LPSTR:
	case VT_BSTR:
		pbData += sizeof(int);
		cb = *(int*)pbData;
		return 2 * sizeof(int) + ((cb+3) & ~3);
	case VT_FILETIME:
		return 3 * sizeof(int);
	default:  // bitmaps, blobs, arrays
		return 0;
	}
}

Bool CMsiSummaryInfo::WritePropertyStream()
{
	// note: we always write out the stream if it was opened read-write
	// this puts back the existing data even if no properties were written
	if (m_cMaxProp == 0)
		return fFalse;  // read-only

	// calculate section size for old properties.
	// we make the assumption that the properties are stored in the order
	// given in the index, otherwise we don't know how to calculate
	// the data sizes for dictionaries, arrays, blobs, etc.
	int cbSectionData = 0;
	int iPID, iOffset;
	int* pIndex = m_pPropertyIndex;
	int cProp = m_cOldProp;
	int cCopyProp = 0;
	while (cProp--)
	{
		iPID    = GetInt32(pIndex++);
		iOffset = GetInt32(pIndex++);
		int cb = GetPropSize(iPID, m_pbSection + iOffset);
		if (cb)
		{
			cCopyProp++;
			cbSectionData += GetPropSize(iPID, m_pbSection + iOffset);
		}
	}

	// calculate section size for new properties.
	PropertyData* pData = GetPropertyData();
	for (cProp = m_cNewProp; cProp--; pData++)
	{
		cbSectionData += 2 * sizeof(int);
		if (pData->iType == VT_FILETIME)
			cbSectionData += sizeof(int);
		else if (pData->iType == VT_LPSTR)
			cbSectionData += (pData->cbText + 3) & ~3;  // align
	}

	// output stream header and section header
	int cTotalProp = cCopyProp + m_cNewProp;
	int cbSectionIndex = cTotalProp * 2 * sizeof(int) + cbSectionHeader;
	IMsiStream* piStream = m_piStream; // for efficiency
	piStream->PutInt16((unsigned short)0xFFFE); // byte order, always little-endian
	piStream->PutInt16(0);       // property stream format, always 0
	piStream->PutInt16(short(g_iMinorVersion * 256 + g_iMajorVersion));
#ifdef WIN
	piStream->PutInt16(2);  // Win32 platform code
#else // MAC
	piStream->PutInt16(1);  // Mac platform code
#endif
	piStream->PutData(fmtidSourceClsid, sizeof(fmtidSourceClsid));
	piStream->PutInt32(1);        // section count
	piStream->PutData(fmtidSummaryStream, sizeof(fmtidSummaryStream));
	piStream->PutInt32(cbSummaryHeader); // offset to 1st section
	Assert(piStream->GetIntegerValue() == cbSummaryHeader);
	piStream->PutInt32(cbSectionIndex + cbSectionData);  // section size
	piStream->PutInt32(cTotalProp);  // property count

	// output property index
	int iSectionOffset = cbSectionIndex;  // start of section data offset
	for (pIndex = m_pPropertyIndex, cProp = m_cOldProp; cProp--; )
	{
		iPID    = GetInt32(pIndex++);
		iOffset = GetInt32(pIndex++);
		int cb = GetPropSize(iPID, m_pbSection + iOffset);
		if (cb)
		{
			piStream->PutInt32(iPID);
			piStream->PutInt32(iSectionOffset);
			iSectionOffset += cb;
		}
	}
	for (pData = GetPropertyData(), cProp = m_cNewProp; cProp--; pData++)
	{
		piStream->PutInt32(pData->iPID);
		piStream->PutInt32(iSectionOffset);
		iSectionOffset += 2 * sizeof(int);
		if (pData->iType == VT_FILETIME)
			iSectionOffset += sizeof(int);
		else if (pData->iType == VT_LPSTR)
			iSectionOffset += (pData->cbText + 3) & ~3;  // align
	}

	// output old properties
	for (pIndex = m_pPropertyIndex, cProp = m_cOldProp; cProp--; )
	{
		iPID    = GetInt32(pIndex++);
		iOffset = GetInt32(pIndex++);
		int cb = GetPropSize(iPID, m_pbSection + iOffset);
		if (cb)
			piStream->PutData(m_pbSection + iOffset, cb);
	}

	// output new properties
	static const char rgbNullPad[4] = {0,0,0,0}; // need from 0 to 3 pad bytes
	int cbText;   // string size, including null terminator
	for (pData = GetPropertyData(), cProp = m_cNewProp; cProp--; pData++)
	{
		piStream->PutInt32(pData->iType);
		switch(pData->iType)
		{
		case VT_I2:
		case VT_I4:
			piStream->PutInt32(pData->iValue);
			break;
		case VT_LPSTR:
		{
			cbText = pData->cbText; // includes null
			piStream->PutInt32(cbText);
#ifdef UNICODE
			CTempBuffer<char, 512> rgchBuf;
			rgchBuf.SetSize(cbText);
			if ( ! (char *) rgchBuf )
			{
				m_cMaxProp = m_cNewProp = 0;
				return fFalse;
			}
			int cbData = WIN::WideCharToMultiByte(m_iCodepage, 0,
								pData->piText->GetString(), -1, rgchBuf, cbText, "\177", 0);
			Assert(cbData == cbText);
			piStream->PutData(rgchBuf, cbText);
#else
			piStream->PutData(pData->piText->GetString(), cbText);
#endif
			if ((cbText &= 3) != 0)
				piStream->PutData(rgbNullPad, 4 - cbText);
			pData->piText->Release();
			break;
		}
		case VT_FILETIME:
			piStream->PutInt32(pData->iLow);
			piStream->PutInt32(pData->iHigh);
			break;
		default: Assert(0);
		};
	}
	Assert(piStream->GetIntegerValue() == cbSummaryHeader + cbSectionIndex + cbSectionData);
	Bool fError = piStream->Error();
	m_cMaxProp = m_cNewProp = 0;  // prevent further write
	return fError ? fFalse : fTrue;
}

//____________________________________________________________________________
//
// CFileRead CFileWrite implementation
//____________________________________________________________________________

char rgchCtrlMap[16]   = {21, 1, 2, 3, 4, 5, 6, 7,27,16,25,11,24,17,14,15};
// translate from:       NULL                     BS HT LF    FF CR

char rgchCtrlUnMap[16] = { 9,13,18,19,20, 0,22,23,12,10,26, 8,28,29,30,31};
// restore to:            HT CR         NULL      FF LF    BS

CFileWrite::CFileWrite(int iCodePage) : m_iCodePage(iCodePage)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileWrite::CFileWrite() : m_iCodePage(CP_ACP)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileWrite::~CFileWrite()
{
	Close();
}

Bool CFileWrite::Open(IMsiPath& riPath, const ICHAR* szFile)
{
	Close();
	if (!szFile || !szFile[0])
		return fFalse;
	MsiString istrFullPath;
	IMsiRecord* piError;
	if ((piError = riPath.GetFullFilePath(szFile, *&istrFullPath)) != 0)
	{
		piError->Release();
		return fFalse;
	}
	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(istrFullPath) == fTrue) ? fTrue : fFalse;
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	m_hFile = ::CreateFile(istrFullPath, GENERIC_WRITE, FILE_SHARE_READ, 0,
							CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if(fImpersonate)
		StopImpersonating();
	return (m_hFile == INVALID_HANDLE_VALUE) ? fFalse : fTrue;
}

Bool CFileWrite::Close()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	if (!::CloseHandle(m_hFile))
		return fFalse;
	m_hFile = INVALID_HANDLE_VALUE;
	return fTrue;
}

Bool CFileWrite::WriteString(const ICHAR* szData, int fNewLine)
{
	return CFileWrite::WriteText(szData, IStrLen(szData), fNewLine);
}

Bool CFileWrite::WriteMsiString(const IMsiString& riData, int fNewLine)
{
	return CFileWrite::WriteText(riData.GetString(), riData.TextSize(), fNewLine);
}

Bool CFileWrite::WriteInteger(int iData, int fNewLine)
{
	ICHAR rgchBuffer[20];
	if (iData == iMsiNullInteger)
		return CFileWrite::WriteText(rgchBuffer, 0, fNewLine);
	else
		return CFileWrite::WriteText(rgchBuffer, wsprintf(rgchBuffer, TEXT("%i"), iData), fNewLine);
}

Bool CFileWrite::WriteText(const ICHAR* szData, unsigned long cchData, int fNewLine)
{
	int iStatus;
	DWORD cbWritten;
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	char* szDelim = fNewLine ? "\r\n" : "\t";
	long cbDelim = fNewLine ? 2 : 1;
	if (cchData)
	{
		Bool fControlChars = fFalse;
		long cbData;
		char* pbBuffer;
#ifdef UNICODE
		BOOL fDefaultUsed = 0;
		DWORD dwFlags = 0; // WC_COMPOSITECHECK fails on Vietnamese
		const char* szDefault = "\177";
		BOOL* pfDefaultUsed = &fDefaultUsed;
		if (m_iCodePage >= CP_UTF7 || m_iCodePage >= CP_UTF8)
		{
			dwFlags = 0;    // flags must be 0 to avoid invalid argument errors
			szDefault = 0;
			pfDefaultUsed = 0;
		}
		cbData = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
									szData, cchData, m_rgbTemp, m_rgbTemp.GetSize(), szDefault, pfDefaultUsed);
		if (cbData == 0)   // can only happen on buffer overflow
		{
			cbData = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
									szData, cchData, 0, 0, 0, 0);
			m_rgbTemp.SetSize(cbData);
			if ( ! (char *) m_rgbTemp )
				return fFalse;
			cbData = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
									szData, cchData, m_rgbTemp, m_rgbTemp.GetSize(), szDefault, pfDefaultUsed);
			Assert(cbData);
		}
		pbBuffer = m_rgbTemp;
#else
		cbData  = cchData;
		pbBuffer = const_cast<char*>(szData);
#endif
		if (fNewLine != -1)
		{
			char* pchData = pbBuffer;
			for (int iData = cbData; iData; iData--, pchData++)
				if ((unsigned char)*pchData < 16) // check for control chars in string
				{
					*pchData = rgchCtrlMap[*pchData];
					fControlChars = fTrue;
				}
		}
		iStatus = ::WriteFile(m_hFile, pbBuffer, cbData, &cbWritten, 0);
#ifndef UNICODE
		if (fControlChars) // restore for control chars in string
		{
			char* pchData = pbBuffer;
			for (int iData = cbData; iData; iData--, pchData++)
				if ((unsigned char)*pchData < 32 && (unsigned char)*pchData >= 16)
					*pchData = rgchCtrlUnMap[*pchData-16];
		}
#endif
	}
	else
		iStatus = fTrue;
	if (iStatus && fNewLine != -1)
		iStatus = ::WriteFile(m_hFile, szDelim, cbDelim, &cbWritten, 0);
	if (iStatus)
		return fTrue;
	Close();  // forces immediate failure on close or subsequent writes
	return fFalse;
}

Bool CFileWrite::WriteBinary(char* rgchBuf, unsigned long cbBuf)
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	if (!::WriteFile(m_hFile, rgchBuf, cbBuf, &cbBuf, 0))
		return fFalse;
	return fTrue;
}

CFileRead::CFileRead(int iCodePage) : m_iCodePage(iCodePage)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileRead::CFileRead() : m_iCodePage(CP_ACP)
{
	m_hFile = INVALID_HANDLE_VALUE;  // indicate not open yet
}

CFileRead::~CFileRead()
{
	Close();
}

Bool CFileRead::Open(IMsiPath& riPath, const ICHAR* szFile)
{
	Close();
	if (!szFile || !szFile[0])
		return fFalse;
	m_cRead = m_iBuffer = cFileReadBuffer;
	MsiString istrFullPath;
	IMsiRecord* piError;
	if ((piError = riPath.GetFullFilePath(szFile, *&istrFullPath)) != 0)
	{
		piError->Release();
		return fFalse;
	}
	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(istrFullPath) == fTrue) ? fTrue : fFalse;
	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	m_hFile = ::CreateFile(istrFullPath, GENERIC_READ, FILE_SHARE_READ, 0,
									OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if(fImpersonate)
		StopImpersonating();
	return (m_hFile == INVALID_HANDLE_VALUE) ? fFalse : fTrue;
}

Bool CFileRead::Close()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return fFalse;
	if (!::CloseHandle(m_hFile))
		return fFalse;
	m_hFile = INVALID_HANDLE_VALUE;
	return fTrue;
}

unsigned long CFileRead::GetSize()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return 0;
	return ::GetFileSize(m_hFile, 0);
}

unsigned long CFileRead::ReadBinary(char* rgchBuf, unsigned long cbBuf)
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return 0;
	if (!::ReadFile(m_hFile, rgchBuf, cbBuf, &cbBuf, 0))
		return 0;
	return cbBuf;
}

ICHAR CFileRead::ReadString(const IMsiString*& rpiData)
{
	rpiData = &CreateString();
	if (m_hFile == INVALID_HANDLE_VALUE)
		return 0;
#ifdef UNICODE
	int cbTemp = 0;
	int cch;
#endif
	unsigned int iStart = m_iBuffer;
	char ch;
	for (;;)
	{
		if (m_iBuffer == m_cRead)  // end of buffer
		{
			ch = 0;
#ifndef UNICODE
			if (m_iBuffer != iStart)
				rpiData->AppendString(m_rgchBuf + iStart, rpiData);
#endif
			if (m_cRead != cFileReadBuffer)
			{
#ifdef UNICODE
				if (cbTemp != 0)
#else
				if (rpiData->TextSize() != 0)
#endif //UNICODE
				{
					ch = '\n';
				}
				break;
			}
			if (!(::ReadFile(m_hFile, m_rgchBuf, cFileReadBuffer, &m_cRead, 0))
				|| m_cRead == 0)
			{
				if (GetLastError() == ERROR_HANDLE_EOF && 
#ifdef UNICODE
				cbTemp != 0
#else
				rpiData->TextSize() != 0
#endif
				)
				{
					ch = '\n';
				}
				break;   
			}
			iStart = m_iBuffer = 0;
			m_rgchBuf[m_cRead] = 0;
		}
		ch = m_rgchBuf[m_iBuffer];
		if ((unsigned char)ch < 32)  // control char or end of string
		{
			if (ch == 0)
				ch = '\n';
			else if (ch == '\r')
			{
				m_rgchBuf[m_iBuffer++] = 0;  // ignore CR, wait for LF
				continue;
			}
			else if (ch == '\n' || ch == '\t')
			{
				m_rgchBuf[m_iBuffer++] = 0;
				
#ifndef UNICODE
				rpiData->AppendString(m_rgchBuf + iStart, rpiData);
#endif
				break;
			}
			else if ((unsigned char)ch >= 16) // translated control char
#ifdef UNICODE
				ch = rgchCtrlUnMap[ch-16]; // remapped control char
#else
				m_rgchBuf[m_iBuffer] = rgchCtrlUnMap[ch-16]; // restore control char
#endif
		}
#ifdef UNICODE
		if (cbTemp >= m_rgbTemp.GetSize())
			m_rgbTemp.Resize(cbTemp + 1024);  //!! need better algorithm
		m_rgbTemp[cbTemp++] = ch;
#endif // UNICODE
		m_iBuffer++;
	}
#ifdef UNICODE
	if (cbTemp)
	{
		// if DBCS enabled  // need extra call to find size of DBCS string
		cch = WIN::MultiByteToWideChar(m_iCodePage, 0, m_rgbTemp, cbTemp, 0, 0);
		ICHAR* pchStr = SRV::AllocateString(cch, fFalse, rpiData);
		if ( pchStr )
		    WIN::MultiByteToWideChar(m_iCodePage, 0, m_rgbTemp, cbTemp, pchStr, cch);
	}
	else
		rpiData = &SRV::g_MsiStringNull;
#endif
	return ch;
}

//____________________________________________________________________________
//
// CLockBytes implementation
//____________________________________________________________________________

HRESULT CMsiLockBytes::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_ILockBytes))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
	
}
unsigned long CMsiLockBytes::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiLockBytes::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

CMsiLockBytes::CMsiLockBytes(IMsiStream& riStream)	: m_piStream(&riStream)
{
	m_piStream->AddRef();
	m_iRefCnt = 1;
}

CMsiLockBytes::CMsiLockBytes(const char* pchMem, int iLength)
{
	CMsiLockBytes(*PMsiStream(new CMsiMemoryStream(pchMem, iLength, fFalse, fFalse)));
}

CMsiLockBytes::~CMsiLockBytes()
{
	m_piStream->Release();
}

HRESULT __stdcall CMsiLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void* pv, ULONG cb, ULONG* pcbRead)
{
	if (ulOffset.HighPart) // Our database shouldn't exceed 4 gigs
		return E_FAIL;

	m_piStream->Seek(ulOffset.LowPart);
	ULONG cbRead = m_piStream->GetData(pv, cb);
	if (pcbRead)
		*pcbRead = cbRead;
	return m_piStream->Error() ? E_FAIL : S_OK;
}

HRESULT __stdcall CMsiLockBytes::WriteAt(ULARGE_INTEGER /*ulOffset*/, const void* /*pv*/,
													  ULONG /*cb*/, ULONG* /*pcbWritten*/)
{
	return E_FAIL;
}

HRESULT __stdcall CMsiLockBytes::Flush()
{
	return S_OK;
}

HRESULT __stdcall CMsiLockBytes::SetSize(ULARGE_INTEGER /*cb*/)
{
	return E_FAIL;
}

HRESULT __stdcall CMsiLockBytes::LockRegion(ULARGE_INTEGER /*libOffset*/,
														  ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT __stdcall CMsiLockBytes::UnlockRegion(ULARGE_INTEGER /*libOffset*/,
											ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
{
	return STG_E_INVALIDFUNCTION;
}

HRESULT __stdcall CMsiLockBytes::Stat(STATSTG* pstatstg, DWORD /*grfStatFlag*/)
{
	memset (pstatstg, 0, sizeof(*pstatstg));
	pstatstg->type = STGTY_LOCKBYTES;
	pstatstg->cbSize.LowPart = m_piStream->GetIntegerValue();
	return S_OK;
}

//____________________________________________________________________________
//
// CMsiFileStream implementation
//____________________________________________________________________________

#ifdef WIN
typedef HANDLE MsiFileHandle;
#else
typedef short MsiFileHandle;
#endif

class CMsiFileStream;

class CFileStreamData  // common clone information
{
 public:
	CFileStreamData(MsiFileHandle hFile, unsigned int cbLength, Bool fWrite);
  ~CFileStreamData();
	int                 m_cStreams;
	CMsiFileStream*     m_piCurrentStream;
	const MsiFileHandle m_hFile;
	Bool                m_fWrite;
	unsigned int        m_cbLength;
	bool				m_fFirstWrite;
};

class CMsiFileStream : public CMsiStreamBuffer
{
 public:  // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	const IMsiString&   __stdcall GetMsiStringValue() const;
	int           __stdcall GetIntegerValue() const;
	unsigned int  __stdcall Remaining() const;
	void          __stdcall Reset();
	void          __stdcall Seek(int position);
	IMsiStream*   __stdcall Clone();
	HRESULT __stdcall Read(void *pv, unsigned long cb, unsigned long *pcbRead);
 public: // constructor
	CMsiFileStream(CFileStreamData& rStreamData);
	void operator =(CMsiFileStream&);
 protected:
  ~CMsiFileStream(){}; // protected to prevent creation on stack
   void __stdcall Flush();
 private:
	int               m_iRefCnt;   // COM reference count
	CFileStreamData&  m_rData;     // common clone information
};

extern bool RunningAsLocalSystem();

IMsiRecord* CreateFileStream(const ICHAR* szFile, Bool fWrite, IMsiStream*& rpiStream)
{
	Bool fImpersonate = RunningAsLocalSystem() && (GetImpersonationFromPath(szFile) == fTrue) ? fTrue : fFalse;
	MsiFileHandle hFile;

	if(fImpersonate)
		AssertNonZero(StartImpersonating());
	if (fWrite)
		hFile = WIN::CreateFile(szFile, GENERIC_WRITE, FILE_SHARE_READ, 0,
										CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	else
	{
		// Per Bug 9965/146155 (opening stream for reading) On WinNT, also specify FILE_SHARE_DELETE
		// so that callee can specify FILE_FLAG_DELETE_ON_CLOSE
		if (!g_fWin9X)
			hFile = WIN::CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, 0,
											OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		else // FILE_SHARE_DELETE is unsupported on Win9X (and is not required with FFDOC flag)
			hFile = WIN::CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, 0,
											OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	}
	if(fImpersonate)
		StopImpersonating();
	
	if (hFile == INVALID_HANDLE_VALUE)
		return LOC::PostError(Imsg(imsgOpenFileStream), szFile, WIN::GetLastError());

	unsigned int cbFileSize = WIN::GetFileSize(hFile, 0);
	Assert(cbFileSize != 0xFFFFFFFFL);
	CFileStreamData* pStreamData = new CFileStreamData(hFile, cbFileSize, fWrite);
	rpiStream = new CMsiFileStream(*pStreamData);
	return 0;
}

CFileStreamData::CFileStreamData(MsiFileHandle hFile, unsigned int cbLength, Bool fWrite)
	: m_cStreams(1)
	, m_hFile(hFile)
	, m_fWrite(fWrite)
	, m_cbLength(cbLength)
	, m_fFirstWrite(true)
{
}

CFileStreamData::~CFileStreamData()
{
	AssertNonZero(WIN::CloseHandle(m_hFile));
}

CMsiFileStream::CMsiFileStream(CFileStreamData& rStreamData)
 :  m_iRefCnt(1)
 ,  m_rData(rStreamData)
{
	m_rData.m_piCurrentStream = this;
	m_fWrite = m_rData.m_fWrite;
	m_cbLength = m_rData.m_cbLength;
}

HRESULT CMsiFileStream::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiStream)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiFileStream::AddRef()
{
	return ++m_iRefCnt;
}
unsigned long CMsiFileStream::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	Flush();
	if (--m_rData.m_cStreams == 0)
		delete &m_rData;
	delete this;
	return 0;
}

const IMsiString& CMsiFileStream::GetMsiStringValue() const
{
	return SRV::CreateString();
//	return SRV::CreateStringComRef(*m_rgbData, m_cbLength, *this);
}

int CMsiFileStream::GetIntegerValue() const
{
	return m_rData.m_cbLength;
}

unsigned int CMsiFileStream::Remaining() const
{
	return (m_issState == issRead || m_issState == issReset) ? m_rData.m_cbLength - m_cbCopied : 0;
}

HRESULT CMsiFileStream::Read(void* pb, unsigned long cb, unsigned long* pcbRead)
{
	if (m_rData.m_piCurrentStream != this)
	{
		AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, m_cbCopied, 0, FILE_BEGIN) - 0xFFFFFFFFL);
		m_rData.m_piCurrentStream = this;
	}
	if (!WIN::ReadFile(m_rData.m_hFile, pb, cb, pcbRead, 0) )
	{
		*pcbRead = 0;
		return E_FAIL;
	}
	return S_OK;
}

#ifdef OLD
void CMsiFileStream::PutData(const void* pb, unsigned int cb)
{
	if (m_issState != issWrite) // first write
	{
		if (!m_rData.m_fWrite || m_issState != issReset)
		{
			m_issState = issError;
			return;
		}
		m_issState = issWrite;
		m_rData.m_cbLength = 0;
	}
	else if (m_rData.m_piCurrentStream != this)
	{
		AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, 0, 0, FILE_END) - 0xFFFFFFFFL);
		m_rData.m_piCurrentStream = this;
	}

	unsigned long cbWrite;  //!! = 0; ?
	WIN::WriteFile(m_rData.m_hFile, pb, cb, &cbWrite, 0);
	m_rData.m_cbLength += cbWrite;
	if (cbWrite != cb)
		m_issState = issError;
}
#endif //OLD

void CMsiFileStream::Reset()
{
	Flush();
	AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, 0, 0, FILE_BEGIN) - 0xFFFFFFFFL);
	// if writing, do we need to flush the file out here?
	m_cbCopied = 0;
	m_issState = issReset;
	m_rData.m_piCurrentStream = this;  //!! needed?
	m_rData.m_fFirstWrite = true;
}

void CMsiFileStream::Seek(int cbPosition)
{
	Flush();
	unsigned long cbSeek;
	if(m_rData.m_cbLength < cbPosition || cbPosition < 0 ||
		(cbSeek = WIN::SetFilePointer(m_rData.m_hFile, cbPosition, 0, FILE_BEGIN)) == 0xFFFFFFFFL)
	{
		DWORD err = GetLastError();
		m_issState = issError;
		return;
	}
	m_cbCopied = cbSeek;
	m_rData.m_piCurrentStream = this;
}

void CMsiFileStream::Flush()
{
	if (m_issState == issWrite && m_cbUsed != 0)
	{
		if (m_rData.m_fFirstWrite)
		{
			m_rData.m_fFirstWrite = false;
			m_rData.m_cbLength = 0;
		}
		if (m_rData.m_piCurrentStream != this)
		{
			AssertNonZero(WIN::SetFilePointer(m_rData.m_hFile, 0, 0, FILE_END) - 0xFFFFFFFFL);
			m_rData.m_piCurrentStream = this;
		}

		unsigned long cbWritten = 0;
		WIN::WriteFile(m_rData.m_hFile, m_rgbBuffer, m_cbUsed, &cbWritten, 0);
		m_rData.m_cbLength += cbWritten;
		if (cbWritten != m_cbUsed)
			m_issState = issError;
		m_cbCopied += cbWritten;
		m_cbUsed = 0;
	}
	else if (m_issState == issRead)
		m_cbUsed = m_cbBuffer = sizeof(m_rgbBuffer);
}

IMsiStream* CMsiFileStream::Clone()
{
	if (m_rData.m_fWrite)
	{
		AssertSz(fFalse, "Cannot close a CMsiFileStream for writing");
		return 0;
	}
	++m_rData.m_cStreams;
	return new CMsiFileStream(m_rData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\dbview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbview.cpp
//
//--------------------------------------------------------------------------

/*____________________________________________________________________________

File:	dbview.cpp 
Purpose:CMsiView implementation  
Notes:	Need to optimise for strings not in the database
		Need to pass back the exact syntax error that occured in case of OpenView
		failure.

____________________________________________________________________________*/

/*____________________________________________________________________________
The Grammar supported by the Darwin for the SQL queries is described below. 
The grammar is the result of left-factoring and removing left-recursion. 
The non-terminals are denoted by words in bold and are in all capitals. 
The terminals are denoted by words in all small capitals. The grammar is LL(1) 
and corresponds to the implemented recursive descent parser. 
Null productions have only the symbol " /\ " on their right hand side. 

1.  SQL					--> STMT eos
2.  STMT				--> select DISTINCT-PHRASE COLUMN-LIST from TABLE-LIST PREDICATE ORDER
3.  COLUMN-LIST			--> COLUMN-ELEMENT COLUMN-LIST-TAIL
4.  COLUMN-ELEMENT		--> COLUMNID COLUMN-LIST-TAIL
5.  COLUMN-ELEMENT		--> LITERAL COLUMN-LIST-TAIL
6.  COLUMN-ELEMENT		--> starid COLUMN-LIST-TAIL
7.  COLUMN-ELEMENT		--> parameter
8.  COLUMN-ELEMENT		--> null  COLUMN-LIST-TAIL 
9.  COLUMNID			--> id COLUMNID-TAIL
10.  COLUMNID-TAIL		--> dotid id
11.  COLUMNID-TAIL		--> /\
12.  LITERAL			--> literal-string
13.  LITERAL			--> literal-integer
14.  COLUMN-LIST-TAIL	--> comma COLUMN-LIST
15.  COLUMN-LIST-TAIL	--> /\
16.  TABLE-LIST			--> id  TABLEID-TAIL TABLE-LIST-TAIL
17.  TABLEID-TAIL		--> as id
18.  TABLEID-TAIL		--> /\
19.  TABLE-LIST-TAIL	--> comma TABLE-LIST
20.  TABLE-LIST-TAIL	--> /\
21.  PREDICATE			--> where EXPRESSION
22.  PREDICATE			--> /\
23.  EXPRESSION			--> EXPR-1 EXPR-1-TAIL
24.  EXPR-1-TAIL		--> orop EXPR-1 EXPR-1-TAIL
25.  EXPR-1-TAIL		--> /\
26.  EXPR-1				--> EXPR-2 EXPR-2-TAIL
27.  EXPR-2-TAIL		--> andop EXPR-2 EXPR-2-TAIL
28.  EXPR-2-TAIL		--> /\
29.  EXPR-2				--> bopen EXPRESSION bclose
30.  EXPR-2				--> notop EXPR-2 //!! not supported
31.  EXPR-2				--> COLUMNID E2-TAIL
32.  E2-TAIL			--> RELOP COLM-OPERAND
33.  E2-TAIL			--> equal COLM-OPERAND1
34.  RELOP				--> not-equal
35.  RELOP				--> less-equal
36.  RELOP				--> greater-equal
37.  RELOP				--> greater
38.  RELOP				--> less
39.  COLM-OPERAND1		--> COLM-OPERAND
40.  COLM-OPERAND1		--> COLUMNID
41.  COLM-OPERAND		--> LITERAL
42.  COLM-OPERAND		--> null
43.  COLM-OPERAND		--> parameter
44.  EXPR-2				--> literal-string E2-TAIL1
45.  E2-TAIL1			--> equal STR-OPERAND
46.  E2-TAIL1			--> not-equal STR-OPERAND
47.  STR-OPERAND		--> literal-string
48.  STR-OPERAND		--> parameter
49.  STR-OPERAND		--> null
50.  STR-OPERAND		--> COLUMNID
51.  EXPR-2				--> literal-integer E2-TAIL2
52.  E2-TAIL2			--> RELOP INT-OPERAND
53.  E2-TAIL2			--> equal INT-OPERAND
54.  INT-OPERAND		--> literal-integer
55.  INT-OPERAND		--> parameter
56.  INT-OPERAND		--> null
57.  INT-OPERAND		--> COLUMNID
58.  EXPR-2				--> parameter E2-TAIL3
59.  E2-TAIL3			--> RELOP PAR-OPERAND
60.  E2-TAIL3			--> equal PAR-OPERAND
61.  PAR-OPERAND		--> LITERAL
62.  PAR-OPERAND		--> null
63.  PAR-OPERAND		--> COLUMNID
64.  EXPR-2				--> null E2-TAIL4
65.  E2-TAIL4			--> equal NUL- OPERAND
66.  E2-TAIL4			--> RELOP NUL- OPERAND
67.  NUL- OPERAND		--> LITERAL
68.  NUL- OPERAND		--> null
69.  NUL- OPERAND		--> COLUMID
70.  NUL- OPERAND		--> parameter
71.  ORDER				--> order by COLUMNID ORDER-TAIL
72.  ORDER				--> /\
73.  ORDER-TAIL			--> comma COLUMNID ORDER-TAIL
74.  ORDER-TAIL			--> /\
75.	 DISTINCT-PHRASE	--> distinct
76.	 DISTINCT-PHRASE	--> /\
____________________________________________________________________________*/

// includes
#include "precomp.h" 
#include "_databas.h" // local factories
#include "tables.h" // table and column name definitions
#ifdef MAC
#include "macutil.h"
#include <Folders.h>
#endif

// macro wrapper for IMsiRecord* errors
#define RETURN_ERROR_RECORD(function){							\
							IMsiRecord* piError;	\
							piError = function;		\
							if(piError)				\
								return piError;		\
						}

// defines used in the file
const unsigned int iMsiMissingString = ~(unsigned int)0; // max value, hopefully the database will never have these many strings
const unsigned int iMsiNullString = 0;
const unsigned int iopAND = 0x8000;
const unsigned int iopOR = 0x4000;
const unsigned int iopANDOR = iopAND | iopOR;


// reserved table and column names
const ICHAR* CATALOG_TABLE  = TEXT("_Tables");
const ICHAR* CATALOG_COLUMN = TEXT("_Columns");
const ICHAR* ROWSTATE_COLUMN = TEXT("_RowState");


// internal ivcEnum defines
static const int ivcCreate          = 16;
static const int ivcAlter           = 32;
static const int ivcDrop            = 64;
static const int ivcInsertTemporary = 128;

// charnext function - selectively calls WIN::CharNext

inline void Lex::CharNext(ICHAR*& rpchCur)
{
#ifdef UNICODE
	rpchCur ++;
#else
	if(!g_fDBCSEnabled)
		rpchCur ++;
	else
	{
		rpchCur = WIN::CharNext(rpchCur);
	}
#endif
}



const ICHAR STD_WHITE_SPACE = ' ';

// the string to ipqTok map
const TokenStringList Lex::m_rgTokenStringArray[] = {
	TokenStringList(TEXT("SELECT"), ipqTokSelect),
	TokenStringList(TEXT("FROM"), ipqTokFrom),
	TokenStringList(TEXT("AS"), ipqTokAs),
	TokenStringList(TEXT("WHERE"), ipqTokWhere),
	TokenStringList(TEXT("NULL"), ipqTokNull),
	TokenStringList(TEXT("OR"),ipqTokOrOp),
	TokenStringList(TEXT("AND"), ipqTokAndOp),
	TokenStringList(TEXT("NOT"), ipqTokNotop),
	TokenStringList(TEXT("ORDER"), ipqTokOrder),
	TokenStringList(TEXT("BY"), ipqTokBy),
	TokenStringList(TEXT("DISTINCT"), ipqTokDistinct),
	TokenStringList(TEXT("UPDATE"), ipqTokUpdate),
	TokenStringList(TEXT("DELETE"), ipqTokDelete),
	TokenStringList(TEXT("INSERT"), ipqTokInsert),
	TokenStringList(TEXT("INTO"), ipqTokInto),
	TokenStringList(TEXT("SET"), ipqTokSet),
	TokenStringList(TEXT("VALUES"), ipqTokValues),
	TokenStringList(TEXT("IS"),  ipqTokIs),
	TokenStringList(TEXT("CREATE"),  ipqTokCreate),
	TokenStringList(TEXT("DROP"),  ipqTokDrop),
	TokenStringList(TEXT("ALTER"),  ipqTokAlter),
	TokenStringList(TEXT("TABLE"),  ipqTokTable),
	TokenStringList(TEXT("ADD"),  ipqTokAdd),
	TokenStringList(TEXT("PRIMARY"),  ipqTokPrimary),
	TokenStringList(TEXT("KEY"),  ipqTokKey),
	TokenStringList(TEXT("CHAR"),  ipqTokChar),
	TokenStringList(TEXT("CHARACTER"),  ipqTokCharacter),
	TokenStringList(TEXT("VARCHAR"),  ipqTokVarChar),
	TokenStringList(TEXT("LONGCHAR"),  ipqTokLongChar),
	TokenStringList(TEXT("INT"),  ipqTokInt),
	TokenStringList(TEXT("INTEGER"),  ipqTokInteger),
	TokenStringList(TEXT("SHORT"),  ipqTokShort),
	TokenStringList(TEXT("LONG"),  ipqTokLong),
	TokenStringList(TEXT("OBJECT"),  ipqTokObject),
	TokenStringList(TEXT("TEMPORARY"),  ipqTokTemporary),
	TokenStringList(TEXT("HOLD"),  ipqTokHold),
	TokenStringList(TEXT("FREE"),  ipqTokFree),
	TokenStringList(TEXT("LOCALIZABLE"),  ipqTokLocalizable),
	TokenStringList(TEXT(""), ipqTokEnd) // end condition
};

// special characters understood by lex
const ICHAR Lex::m_chQuotes   = '\'';
const ICHAR Lex::m_chIdQuotes = STD_IDENTIFIER_QUOTE_CHAR;
const ICHAR Lex::m_chSpace    = STD_WHITE_SPACE;
const ICHAR Lex::m_chEnd      = 0;

// the ICHAR to ipqTok map
const TokenCharList Lex::m_rgTokenCharArray[] = {
	TokenCharList(Lex::m_chQuotes, ipqTokQuotes),
	TokenCharList(Lex::m_chIdQuotes, ipqTokIdQuotes),
	TokenCharList(Lex::m_chSpace, ipqTokWhiteSpace),
	TokenCharList('.', ipqTokDot),
	TokenCharList('(', ipqTokOpen),
	TokenCharList(')', ipqTokClose),
	TokenCharList(',', ipqTokComma),
	TokenCharList('=', ipqTokEqual),
	TokenCharList('>', ipqTokGreater),
	TokenCharList('<', ipqTokLess),
	TokenCharList('?', ipqTokParam),
	TokenCharList('*', ipqTokStar),
	TokenCharList(Lex::m_chEnd, ipqTokEnd) // end condition
};

// constructor
Lex::Lex(const ICHAR* szSQL):m_ipos(0)
{
	// need to copy string into own array, since we modify string in place for token identification

	//?? Is there a reason that we always resize the buffer w/o first checking whether it's big enough? -- malcolmh
	if(szSQL && *szSQL)
	{
		//!! AssertNonZero
		m_szBuffer.SetSize(IStrLen(szSQL) + 1);
		IStrCopy(m_szBuffer, szSQL);
	}
	else
	{
		// empty string
		//!! AssertNonZero
		m_szBuffer.SetSize(1);
		m_szBuffer[0] = 0;
	}
}

// destructor
Lex::~Lex()
{
}

Bool Lex::Skip(const ipqToken& rtokSkipUpto)
{
	for(;;)
	{
		const ipqToken& rtokTmp = GetNextToken(m_ipos, 0, 0);
		if(rtokTmp == rtokSkipUpto)
			return fTrue;
		if(rtokTmp == ipqTokEnd)
			return fFalse;
	}
}

Bool Lex::MatchNext(const ipqToken& rtokToMatch)
{
	INT_PTR inewPos = m_ipos; // store current pointer, forward only if matched		//--merced: changed int to INT_PTR
	const ipqToken& rtokTmp = GetNextToken(inewPos, &rtokToMatch, 0);
	if(rtokTmp == rtokToMatch)
	{
		m_ipos = inewPos;
		return fTrue;
	}
	else
		return fFalse;
}

Bool Lex::InspectNext(const ipqToken& rtokToInspect)
{
	INT_PTR inewPos = m_ipos;		//--merced: changed int to INT_PTR
	const ipqToken& rtokTmp = GetNextToken(inewPos, &rtokToInspect, 0);
	return (rtokTmp == rtokToInspect) ? fTrue : fFalse;
}

const ipqToken& Lex::GetNext(const IMsiString*& rpistrToken)
{	
	return GetNextToken(m_ipos, 0, &rpistrToken);
}

const ipqToken& Lex::GetNext()
{
	return GetNextToken(m_ipos, 0, 0);
}

int Lex::NumEntriesInList(const ipqToken& rtokEnds,const ipqToken& rtokDelimits)
{
	INT_PTR inewPos = m_ipos;		//--merced: changed int to INT_PTR
	int iEntries = 1;// we should be returning 0 if there is nothing in the list
	// ipqTokEnd token should always be one of the endTokens
	ipqToken tokEndsend = rtokEnds | ipqTokEnd;
	for(;;)
	{
		const ipqToken& rtokTmp = GetNextToken(inewPos, 0, 0);
		if(rtokTmp & rtokDelimits)
			iEntries ++;
		if(rtokTmp & tokEndsend) 
			return iEntries;
	}
}

const ipqToken& Lex::GetCharToken(ICHAR cCur)
{
	int nTmp = 0;
	do{
		if(m_rgTokenCharArray[nTmp].string == cCur)
			// ipqTok found
			return m_rgTokenCharArray[nTmp].ipqTok;
	}while(m_rgTokenCharArray[nTmp++].string);// we should be using ++nTmp here
	return ipqTokUnknown;
}

const ipqToken& Lex::GetStringToken(ICHAR* pcCur, const ipqToken* ptokHint)
{
	int nTmp = 0;
	if(ptokHint)
	{
		// is this a string token
		do{
			if(m_rgTokenStringArray[nTmp].ipqTok ==  *ptokHint)
			{
				// ipqTok found, try matching
				if(!IStrCompI(m_rgTokenStringArray[nTmp].string, pcCur))
					return m_rgTokenStringArray[nTmp].ipqTok;
				else
					break;
			}
		}while(m_rgTokenStringArray[nTmp++].ipqTok != ipqTokEnd);// we should be using ++nTmp here
	}
	nTmp = 0;
	do{
		if(!IStrCompI(m_rgTokenStringArray[nTmp].string, pcCur))
			// ipqTok found
			return m_rgTokenStringArray[nTmp].ipqTok;
	}while(*(m_rgTokenStringArray[nTmp++].string));
	return ipqTokUnknown;
}

// function to get the next ipqTok, the passed in current position is advanced
const ipqToken& Lex::GetNextToken(INT_PTR& currPos, const ipqToken* ptokHint, const IMsiString** ppistrRet)		//--merced: changed int to INT_PTR
{
	ICHAR* pchCur = &m_szBuffer[currPos];
	// get the ipqTok string, remove spaces

	while(*pchCur == m_chSpace)
		pchCur ++; //?? we dont need an CharNext here, do we?

	// beginning of the token
	ICHAR* pchBegin = pchCur;

	// check if ipqTok is char
	const ipqToken* ptokToRet = &GetCharToken(*pchBegin);
	if(*ptokToRet != ipqTokEnd)
	{
		// we are not at the end
		// increment to next pos
		Lex::CharNext(pchCur);
	}
	if(*ptokToRet == ipqTokUnknown) 
	{
		// ipqTok not found, not char, not literal string
		// skip till next delimiter
		while(GetCharToken(*pchCur) == ipqTokUnknown)
		{
			Lex::CharNext(pchCur);
		}
		// plant string terminator, temporarily 	
		ICHAR cTemp = *pchCur;
		*pchCur = 0;


		// which ipqTok is this?
		ptokToRet = &GetStringToken(pchBegin, ptokHint);

		// restore original char at temporary string terminator
		*pchCur = cTemp;

		if(*ptokToRet == ipqTokUnknown)
		{
			// check if literali or id
			ICHAR* pchTmp = pchBegin;
			if(*pchTmp == '-')
				pchTmp ++;//?? we dont need an CharNext here, do we?
			
			while((*pchTmp >= '0') && (*pchTmp <= '9'))
				pchTmp ++;//?? we dont need an CharNext here, do we?
			if(pchTmp == pchCur)
			{
				ptokToRet = &ipqTokLiteralI;
			}
			else
			{
				ptokToRet = &ipqTokId;
			}
		}
	}
	else if(*ptokToRet == ipqTokQuotes) 
	{
		// skip the quotes
		pchBegin ++;
		while((*pchCur != m_chQuotes) && (*pchCur != m_chEnd))
		{
			Lex::CharNext(pchCur);
		}
		if(*pchCur == m_chQuotes)
			ptokToRet = &ipqTokLiteralS;
		else
			ptokToRet = &ipqTokUnknown;
	}
	else if(*ptokToRet == ipqTokIdQuotes)
	{
		// skip the quotes
		pchBegin ++;
		while((*pchCur != m_chIdQuotes) && (*pchCur != m_chEnd))
		{
			Lex::CharNext(pchCur);
		}
		if(*pchCur == m_chIdQuotes)
			ptokToRet = &ipqTokId;
		else
			ptokToRet = &ipqTokUnknown;
	}
	else if(*ptokToRet == ipqTokLess)
	{
		//!! change to int inewPos = pchCur - m_szBuffer;
		INT_PTR inewPos = currPos + (pchCur - &m_szBuffer[currPos]);		//--merced: changed int to INT_PTR
		const ipqToken& rtokTmp =  GetNextToken(inewPos, 0, 0);
		if(rtokTmp == ipqTokEqual)
		{
			pchCur = &m_szBuffer[inewPos];
			ptokToRet = &ipqTokLessEq;
		}
		else if(rtokTmp == ipqTokGreater)
		{
			pchCur = &m_szBuffer[inewPos];
			ptokToRet = &ipqTokNotEq;
		}
	}
	else if(*ptokToRet == ipqTokGreater)
	{
		//!! change to int inewPos = pchCur - m_szBuffer;
		INT_PTR inewPos = currPos + (pchCur - &m_szBuffer[currPos]);		//--merced: changed int to INT_PTR
		const ipqToken& rtokTmp =  GetNextToken(inewPos, 0, 0);
		if(rtokTmp == ipqTokEqual)
		{
			pchCur = &m_szBuffer[inewPos];
			ptokToRet = &ipqTokGreaterEq;
		}
	}
	if(ppistrRet != 0)
	{
		// need to return the value of the token
		*ppistrRet = &CreateString();

		if((*ptokToRet != ipqTokEnd) && (*ptokToRet != ipqTokUnknown))
		{
			// plant string terminator, temporarily 	
			ICHAR cTemp = *pchCur;
			*pchCur = 0;
			(*ppistrRet)->SetString(pchBegin, *ppistrRet);
			*pchCur = cTemp;
		}
	}
	if((*ptokToRet == ipqTokLiteralS) || ((*ptokToRet == ipqTokId) && (*pchCur == m_chIdQuotes)))
		// skip the quotes
		pchCur++;//?? we dont need an CharNext here, do we?
	//!! change to currPos = pchCur - m_szBuffer;
//	Assert (pchCur - &m_szBuffer[currPos] <= INT_MAX);		//--merced: 64-bit ptr subtraction may lead to values too big for currPos
	currPos = currPos + (int)(INT_PTR)(pchCur - &m_szBuffer[currPos]);
	return *ptokToRet;
}

// derivation used exclusively by CMsiView
CMsiDCursor::CMsiDCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, CMsiView& cView, int iHandle)
:CMsiCursor(riTable, riDatabase, fFalse), m_cView(cView), m_iHandle(iHandle)
{
}

void CMsiDCursor::RowDeleted(unsigned int iRow, unsigned int iPrevNode)
{
	m_riDatabase.Block();
	CMsiCursor::RowDeleted(iRow, iPrevNode);
	m_riDatabase.Unblock();
	// notify the View
	m_cView.RowDeleted(iRow, m_iHandle);
}

void CMsiDCursor::RowInserted(unsigned int iRow)
{
	CMsiCursor::RowInserted(iRow);
	// notify the View
	m_cView.RowInserted(iRow, m_iHandle);
}

inline int CMsiDCursor::GetRow()
{
	return m_iRow;
}

inline void CMsiDCursor::SetRow(int iRow)
{
	m_iRow = iRow;
	m_riDatabase.Block();
	m_riTable.FetchRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
}





CScriptView::CScriptView(CScriptDatabase& riDatabase, IMsiServices& riServices):
m_riDatabase(riDatabase),
m_riServices(riServices),
m_piPrevRecord(0),
m_iScriptVersion(0),
m_pStream(0)
{
	m_riDatabase.AddRef();
	m_riServices.AddRef();
}

IMsiRecord* __stdcall CScriptView::Initialise(const ICHAR* szScriptFile) {
	return m_riServices.CreateFileStream(szScriptFile, fFalse, *&m_pStream);
}

IMsiRecord*  __stdcall CScriptView::Execute(IMsiRecord* /*piParams*/) {
	return 0;
}

#define MSIXA0()                             
#define MSIXA1(a)                              MSIXA0()                             TEXT( "{") TEXT(#a) TEXT("=[1]}")
#define MSIXA2(a,b)                            MSIXA1(a)                            TEXT(",{") TEXT(#b) TEXT("=[2]}")
#define MSIXA3(a,b,c)                          MSIXA2(a,b)                          TEXT(",{") TEXT(#c) TEXT("=[3]}")
#define MSIXA4(a,b,c,d)                        MSIXA3(a,b,c)                        TEXT(",{") TEXT(#d) TEXT("=[4]}")
#define MSIXA5(a,b,c,d,e)                      MSIXA4(a,b,c,d)                      TEXT(",{") TEXT(#e) TEXT("=[5]}")
#define MSIXA6(a,b,c,d,e,f)                    MSIXA5(a,b,c,d,e)                    TEXT(",{") TEXT(#f) TEXT("=[6]}")
#define MSIXA7(a,b,c,d,e,f,g)                  MSIXA6(a,b,c,d,e,f)                  TEXT(",{") TEXT(#g) TEXT("=[7]}")
#define MSIXA8(a,b,c,d,e,f,g,h)                MSIXA7(a,b,c,d,e,f,g)                TEXT(",{") TEXT(#h) TEXT("=[8]}")
#define MSIXA9(a,b,c,d,e,f,g,h,i)              MSIXA8(a,b,c,d,e,f,g,h)              TEXT(",{") TEXT(#i) TEXT("=[9]}")
#define MSIXA10(a,b,c,d,e,f,g,h,i,j)           MSIXA9(a,b,c,d,e,f,g,h,i)            TEXT(",{") TEXT(#j) TEXT("=[10]}")
#define MSIXA11(a,b,c,d,e,f,g,h,i,j,k)         MSIXA10(a,b,c,d,e,f,g,h,i,j)         TEXT(",{") TEXT(#k) TEXT("=[11]}")
#define MSIXA12(a,b,c,d,e,f,g,h,i,j,k,l)       MSIXA11(a,b,c,d,e,f,g,h,i,j,k)       TEXT(",{") TEXT(#l) TEXT("=[12]}")
#define MSIXA13(a,b,c,d,e,f,g,h,i,j,k,l,m)     MSIXA12(a,b,c,d,e,f,g,h,i,j,k,l)     TEXT(",{") TEXT(#m) TEXT("=[13]}")
#define MSIXA14(a,b,c,d,e,f,g,h,i,j,k,l,m,n)   MSIXA13(a,b,c,d,e,f,g,h,i,j,k,l,m)   TEXT(",{") TEXT(#n) TEXT("=[14]}")
#define MSIXA15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) MSIXA14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) TEXT(",{") TEXT(#o) TEXT("=[15]}")
#define MSIXA16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)           MSIXA15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)           TEXT(",{") TEXT(#p) TEXT("=[16]}")
#define MSIXA17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)         MSIXA16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)         TEXT(",{") TEXT(#q) TEXT("=[17]}")
#define MSIXA18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)       MSIXA17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)       TEXT(",{") TEXT(#r) TEXT("=[18]}")
#define MSIXA19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)     MSIXA18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)     TEXT(",{") TEXT(#s) TEXT("=[19]}")
#define MSIXA20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)   MSIXA19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)   TEXT(",{") TEXT(#t) TEXT("=[20]}")
#define MSIXA21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) MSIXA20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) TEXT(",{") TEXT(#u) TEXT("=[21]}")
#define MSIXA22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)   MSIXA21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)   TEXT(",{") TEXT(#v) TEXT("=[22]}")
#define MSIXA23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) MSIXA22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) TEXT(",{") TEXT(#w) TEXT("=[23]}")

const ICHAR* rgszixo[] = {
#define MSIXO(op,type,args) TEXT(#op) TEXT("(") args TEXT(")"),
#include "opcodes.h"
};

int GetScriptMajorVersionFromHeaderRecord(IMsiRecord* piRecord);

IMsiRecord*  __stdcall CScriptView::Fetch()
{
	if (m_piPrevRecord != 0)
		m_piPrevRecord->SetInteger(0, m_ixoPrev);
	IMsiRecord* piRecord = m_riServices.ReadScriptRecord(*m_pStream, *&m_piPrevRecord, m_iScriptVersion);
	if (piRecord)
	{
		m_ixoPrev = (ixoEnum)piRecord->GetInteger(0);
		piRecord->SetString(0, rgszixo[m_ixoPrev = (ixoEnum)piRecord->GetInteger(0)]);
		if (m_ixoPrev == ixoHeader)
		{
			m_iScriptVersion = GetScriptMajorVersionFromHeaderRecord(piRecord);
		}
	}			

	return piRecord;
}

IMsiRecord*  __stdcall CScriptView::Close() {
	return 0;
}



unsigned long CScriptView::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}


unsigned long CScriptView::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	PMsiServices piServices (&m_riServices); // release after delete
	delete this;
	return 0;
}



CScriptView::~CScriptView() {
	m_riDatabase.Release();
	if (m_piPrevRecord != 0)
	{
		m_piPrevRecord->Release();
		m_piPrevRecord = 0;
	}

}


// table name if failure on creating internal table
const ICHAR* szInternal = TEXT("Internal Table");

IMsiRecord* CMsiView::CheckSQL(const ICHAR* sqlquery)
{
	m_istrSqlQuery = sqlquery; // necessary for error messages
	// create the lex
	Lex lex(sqlquery);
	// we now support SELECT, UPDATE, INSERT and DELETE
	const ipqToken& rtok = lex.GetNext();
	if(rtok == ipqTokSelect)
	{
		m_ivcIntent = ivcEnum(m_ivcIntent | ivcFetch);
		/*
		if(!(m_ivcIntent & ivcFetch)) // have to Fetch in SELECT mode
			return m_riDatabase.PostError(Imsg(idbgDbIntentViolation));
		*/

		RETURN_ERROR_RECORD(ParseSelectSQL(lex));
	}
	else if(rtok == ipqTokUpdate)
	{
		//!! force to be only update mode
		// cannot make this a requirement to be set from outside as ODBC driver is transparant
		// to the actual sql query that is passed in
		m_ivcIntent = ivcUpdate;
		RETURN_ERROR_RECORD(ParseUpdateSQL(lex));
	}
	else if(rtok == ipqTokInsert)
	{
		//!! force to be only insert mode
		// cannot make this a requirement to be set from outside as ODBC driver is transparant
		// to the actual sql query that is passed in
		m_ivcIntent = ivcInsert; // may be changed to ivcInsertTemporary by ParseInsertSQL
		RETURN_ERROR_RECORD(ParseInsertSQL(lex));
	}
	else if(rtok == ipqTokDelete)
	{
		//!! force to be only delete mode
		// cannot make this a requirement to be set from outside as ODBC driver is transparant
		// to the actual sql query that is passed in
		m_ivcIntent = ivcDelete;
		RETURN_ERROR_RECORD(ParseDeleteSQL(lex));
	}
	else if(rtok == ipqTokCreate)
	{
		m_ivcIntent = (ivcEnum)ivcCreate;
		RETURN_ERROR_RECORD(ParseCreateSQL(lex));
	}
	else if(rtok == ipqTokAlter)
	{
		m_ivcIntent = (ivcEnum)ivcAlter;
		RETURN_ERROR_RECORD(ParseAlterSQL(lex));
	}
	else if(rtok == ipqTokDrop)
	{
		m_ivcIntent = (ivcEnum)ivcDrop;
		RETURN_ERROR_RECORD(ParseDropSQL(lex));
	}
	else
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseCreateSQL(Lex& lex)
{
	// table
	if(lex.MatchNext(ipqTokTable) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// <table name>
	MsiString tableName;
	const ipqToken& rtok = lex.GetNext(*&tableName);
		
	if (rtok != ipqTokId)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

	PMsiRecord piError = ResolveTable(lex, tableName);
	if((piError == 0) || (piError->GetInteger(1) != idbgDbQueryUnknownTable))
		return m_riDatabase.PostError(Imsg(idbgDbTableDefined), tableName, (const ICHAR*)m_istrSqlQuery);
	m_rgTableDefn[m_iTables].iTable = BindString(tableName);

	// (
	if(lex.MatchNext(ipqTokOpen) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// column definition
	RETURN_ERROR_RECORD(ParseCreateColumns(lex));

	// primary
	if(lex.MatchNext(ipqTokPrimary) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	

	// key
	if(lex.MatchNext(ipqTokKey) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	

	// primary columns
	RETURN_ERROR_RECORD(ParsePrimaryColumns(lex));

	// )
	if(lex.MatchNext(ipqTokClose) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// HOLD
	if(lex.MatchNext(ipqTokHold) != fFalse)
		m_fLock = fTrue;

	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}


IMsiRecord* CMsiView::ParseAlterSQL(Lex& lex)
{
	// table
	if(lex.MatchNext(ipqTokTable) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// <table name>
	MsiString tableName;
	const ipqToken& rtok = lex.GetNext(*&tableName);
		
	if (rtok != ipqTokId)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

	IMsiRecord* piError = ResolveTable(lex, tableName);
	if(piError != 0)
		return piError;

	if(lex.MatchNext(ipqTokFree) != fFalse)
		m_fLock = fFalse;
	else
	{
		// add 
		if(lex.MatchNext(ipqTokAdd) != fFalse)
		{
			// column definition
			RETURN_ERROR_RECORD(ParseCreateColumns(lex));
		}
		// HOLD
		if(lex.MatchNext(ipqTokHold) != fFalse)
			m_fLock = fTrue;
	}

	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseDropSQL(Lex& lex)
{
	// table
	if(lex.MatchNext(ipqTokTable) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

	// <table name>
	MsiString tableName;
	const ipqToken& rtok = lex.GetNext(*&tableName);
		
	if (rtok != ipqTokId)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

	PMsiRecord piError = ResolveTable(lex, tableName);
	if(piError != 0)
	{
		piError->AddRef();
		return piError;
	}

	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseCreateColumns(Lex & lex)
{
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokPrimary, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);

		// don't allow the RowState column to be created
		if((rtok == ipqTokId) && !(strColumn.Compare(iscExact, ROWSTATE_COLUMN)))
		{
			RETURN_ERROR_RECORD(ResolveCreateColumn(lex, strColumn, iColumnIndex++));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}while(lex.MatchNext(ipqTokComma) == fTrue);

	return 0;
}

IMsiRecord* CMsiView::ResolveCreateColumn(Lex& lex, MsiString& strColumn, int iColumnIndex)
{
	MsiStringId iColumnId = BindString(strColumn);
	// make sure the column is not repeated
	for (unsigned int iCol = iColumnIndex; iCol--;)
	{
		if(m_rgColumnDefn[iCol].iColumnIndex == iColumnId)
		{
			// repeat
			return m_riDatabase.PostError(Imsg(idbgDbQueryRepeatColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		}
	}
	if(m_ivcIntent == ivcAlter)
	{
		// make sure the column is not already on the table
		if(((m_rgTableDefn[m_iTables].piTable)->GetColumnIndex(iColumnId)) != 0)
		{
			// repeat
			return m_riDatabase.PostError(Imsg(idbgDbQueryRepeatColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		}
	}
	m_rgColumnDefn[iColumnIndex].iColumnIndex = iColumnId;
	m_rgColumnDefn[iColumnIndex].itdType = 0;
	// get the column type
	MsiString strTempToken;
	const ipqToken& rtok = lex.GetNext(*&strTempToken);
	if((rtok == ipqTokChar) || (rtok == ipqTokCharacter))
	{
		m_rgColumnDefn[iColumnIndex].itdType |= icdString;
		if(lex.MatchNext(ipqTokOpen) == fTrue)
		{
			MsiString strTextSize;
			const ipqToken& rtok1 = lex.GetNext(*&strTextSize);
			if((rtok1 != ipqTokLiteralI) || (strTextSize > icdSizeMask))//string literal
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
			m_rgColumnDefn[iColumnIndex].itdType |= (int)strTextSize;
			if(lex.MatchNext(ipqTokClose) == fFalse)
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
		}
	}
	else if(rtok == ipqTokLongChar)
	{
		m_rgColumnDefn[iColumnIndex].itdType |= icdString;
	}
	else if((rtok == ipqTokInt) || (rtok == ipqTokInteger) || (rtok == ipqTokShort))
	{
		m_rgColumnDefn[iColumnIndex].itdType |= (icdShort | 2);
	}
	else if(rtok == ipqTokLong)
	{
		m_rgColumnDefn[iColumnIndex].itdType |= (icdLong | 4);
	}
	else if(rtok == ipqTokObject)
	{
		m_rgColumnDefn[iColumnIndex].itdType |= icdObject;
	}
	else
	{
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidType), strTempToken, (const ICHAR*)m_istrSqlQuery);
	}

	RETURN_ERROR_RECORD(ParseColumnAttributes(lex, iColumnIndex));

	return 0;
}

struct ColAttrib
{
	const ipqToken* pTok;   // token 
	const ipqToken* pTok2;  // token required to follow pTok
	int icdIfMatch;         // attribute to be used if token(s) are matched
	int icdIfNoMatch;       // attribute to be used if token(s) are not matched
};

static const ColAttrib colAttribs[] = 
{
	{ &ipqTokNotop,       &ipqTokNull, icdNoNulls,     icdNullable    },
	{ &ipqTokTemporary,   0,           icdTemporary,   icdPersistent  },
	{ &ipqTokLocalizable, 0,           icdLocalizable, 0              },
	{ 0,                  0,           0,              0              },
};

IMsiRecord* CMsiView::ParseColumnAttributes(Lex& lex, int iColumnIndex)
{
	for (const ColAttrib* pColAttrib = colAttribs; pColAttrib->pTok; pColAttrib++)
	{
		if(lex.MatchNext(*(pColAttrib->pTok)) == fTrue)
		{
			if (pColAttrib->pTok2)
			{
				if (lex.MatchNext(*(pColAttrib->pTok2)) == fFalse)
				{
					return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
				}
			}
			m_rgColumnDefn[iColumnIndex].itdType |= pColAttrib->icdIfMatch;
		}
		else
		{
			// for Temporary databases (no storage), need to mark column as temporary & not persistent by default
			if (*(pColAttrib->pTok) == ipqTokTemporary && PMsiStorage(m_riDatabase.GetStorage(1)) == 0)
				m_rgColumnDefn[iColumnIndex].itdType |= icdTemporary;
			else
				m_rgColumnDefn[iColumnIndex].itdType |= pColAttrib->icdIfNoMatch;
		}
	}

	return 0;
}

IMsiRecord* CMsiView::ParsePrimaryColumns(Lex & lex)
{
	int iColumnIndex = 0;
	// get the number of primary columns
	if ((lex.NumEntriesInList(ipqTokEnd, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoPrimaryColumns), (const ICHAR*)m_istrSqlQuery);
	do
	{
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok == ipqTokId)
		{
			RETURN_ERROR_RECORD(ResolvePrimaryColumn(lex, strColumn, iColumnIndex++));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;

}

IMsiRecord* CMsiView::ResolvePrimaryColumn(Lex& /*lex*/, MsiString& strColumn, int iColumnIndex)
{
	MsiStringId iColumnId = BindString(strColumn);

	for (unsigned int iCol = m_iColumns; iCol--;)
	{
		if(m_rgColumnDefn[iCol].iColumnIndex == iColumnId)
		{
			if(m_rgColumnDefn[iCol].itdType & icdPrimaryKey)
			{
				// repeat
				return m_riDatabase.PostError(Imsg(idbgDbQueryRepeatColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
			}
			m_rgColumnDefn[iCol].itdType |= icdPrimaryKey;
			// swap with iColumnIndex
			ColumnDefn cdTemp = m_rgColumnDefn[iCol];
			m_rgColumnDefn[iCol] = m_rgColumnDefn[iColumnIndex];
			m_rgColumnDefn[iColumnIndex] = cdTemp;
			return 0;
		}
	}
	//error
	return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
}


IMsiRecord* CMsiView::ParseInsertSQL(Lex& lex)
{
	// into
	if(lex.MatchNext(ipqTokInto) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// open bracket
	if(lex.MatchNext(ipqTokOpen) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// column list
	RETURN_ERROR_RECORD(ParseInsertColumns(lex));
	// close bracket
	if(lex.MatchNext(ipqTokClose) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// values
	if(lex.MatchNext(ipqTokValues) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// open bracket
	if(lex.MatchNext(ipqTokOpen) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// values list
	RETURN_ERROR_RECORD(ParseInsertValues(lex));
	// close bracket
	if(lex.MatchNext(ipqTokClose) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);	
	// optional "TEMPORARY"
	if (lex.MatchNext(ipqTokTemporary) == fTrue)
		m_ivcIntent = (ivcEnum)ivcInsertTemporary;

	// no [where ....] clause allowed
	// no order by clause allowed
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseUpdateSQL(Lex& lex)
{
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// set
	if(lex.MatchNext(ipqTokSet) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	RETURN_ERROR_RECORD(ParseUpdateColumns(lex));
	// [where ....]
	if(lex.MatchNext(ipqTokWhere) == fTrue)
	{
		m_iExpressions = lex.NumEntriesInList(ipqTokOrder, ipqTokAndOp | ipqTokOrOp);
		if(m_iExpressions > sizeof(int)*8)
			return m_riDatabase.PostError(Imsg(idbgDbQueryExceedExpressionLimit), (const ICHAR*)m_istrSqlQuery);

		//!! AssertNonZero
		m_rgExpressionDefn.Resize(m_iExpressions + 1);
		//!! AssertNonZero
		m_rgOperationTree.Resize((m_iExpressions + 1)*2 + 1);
		unsigned int iPosInArray = 1;		
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, m_iOperations, m_iTreeParent));
	}
	// no order by clause allowed
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseDeleteSQL(Lex& lex)
{
	// first set up the tables
	if(lex.Skip(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbMissingFromClause), (const ICHAR*)m_istrSqlQuery);
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// [where ....]
	if(lex.MatchNext(ipqTokWhere) == fTrue)
	{
		m_iExpressions = lex.NumEntriesInList(ipqTokOrder, ipqTokAndOp | ipqTokOrOp);
		if(m_iExpressions > sizeof(int)*8)
			return m_riDatabase.PostError(Imsg(idbgDbQueryExceedExpressionLimit), (const ICHAR*)m_istrSqlQuery);

		//!! AssertNonZero
		m_rgExpressionDefn.Resize(m_iExpressions + 1);
		//!! AssertNonZero
		m_rgOperationTree.Resize((m_iExpressions + 1)*2 + 1);
		unsigned int iPosInArray = 1;		
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, m_iOperations, m_iTreeParent));
	}
	// no order by clause allowed
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// delete
	if(lex.MatchNext(ipqTokDelete) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// no distinct clause allowed
	// no columns allowed, m_iColumns (remains) = 0;
	// from
	if(lex.MatchNext(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseSelectSQL(Lex& lex)
{
	// first set up the tables
	if(lex.Skip(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbMissingFromClause), (const ICHAR*)m_istrSqlQuery);
	// tables
	RETURN_ERROR_RECORD(ParseTables(lex));
	// [where ....]
	if(lex.MatchNext(ipqTokWhere) == fTrue)
	{
		m_iExpressions = lex.NumEntriesInList(ipqTokOrder, ipqTokAndOp | ipqTokOrOp);
		if(m_iExpressions > sizeof(int)*8)
			return m_riDatabase.PostError(Imsg(idbgDbQueryExceedExpressionLimit), (const ICHAR*)m_istrSqlQuery);

		//!! AssertNonZero
		m_rgExpressionDefn.Resize(m_iExpressions + 1);
		//!! AssertNonZero
		m_rgOperationTree.Resize((m_iExpressions + 1)*2 + 1);
		unsigned int iPosInArray = 1;		
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, m_iOperations, m_iTreeParent));
	}
	// [order by...]
	if(lex.MatchNext(ipqTokOrder) == fTrue)
	{
		if(lex.MatchNext(ipqTokBy) == fFalse)
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
		RETURN_ERROR_RECORD(ParseOrderBy(lex));
	}
	// ensure end of ip
	if(lex.MatchNext(ipqTokEnd) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// reset and set up the columns
	lex.Reset();
	// select
	if(lex.MatchNext(ipqTokSelect) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// distinct
	if(lex.MatchNext(ipqTokDistinct) == fTrue)
		m_fDistinct = fTrue;
	// columns
	RETURN_ERROR_RECORD(ParseSelectColumns(lex));
	// from
	if(lex.MatchNext(ipqTokFrom) == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	// set up the independant expressions
	SetAndExpressions(m_iTreeParent);
	// now set up the joins
	if(SetupTableJoins() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	//!! AssertNonZero
	m_rgiTableSequence.Resize(m_iTables);
	int iBegin = m_iTables - 1;
	SetTableSequence(0, iBegin);
	if(InitialiseFilters() == fFalse)
		return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
	SetupSortTable();
	return 0;
}	

IMsiRecord* CMsiView::ParseInsertValues(Lex& lex)
{
	int iNumValues;
	// get the number of columns
	if ((iNumValues = lex.NumEntriesInList(ipqTokClose, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInsufficentValues), (const ICHAR*)m_istrSqlQuery);
	if (iNumValues != m_iColumns)
		return m_riDatabase.PostError(Imsg(idbgDbQueryInsufficentValues), (const ICHAR*)m_istrSqlQuery);
	m_piInsertUpdateRec = &m_riServices.CreateRecord(iNumValues);
	int iColumnIndex = 1;
	do
	{
		Assert(iColumnIndex <= iNumValues);
		// set up the columns
		MsiString strColumnValue;
		const ipqToken& rtok = lex.GetNext(*&strColumnValue);
		if(rtok == ipqTokLiteralS) //string literal
			m_piInsertUpdateRec->SetMsiString(iColumnIndex, *strColumnValue);
		else if(rtok == ipqTokLiteralI) //integer literal
			m_piInsertUpdateRec->SetInteger(iColumnIndex, strColumnValue.operator int());// calls operator int
		else if(rtok == ipqTokNull) //null literal
			m_piInsertUpdateRec->SetNull(iColumnIndex);
		else if(rtok == ipqTokParam)//param (?) literal
		{
			m_iParamInputs = m_iParamInputs | (0x1 << (iColumnIndex - 1));
			m_iParams ++;
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumnValue, (const ICHAR*)m_istrSqlQuery);
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ParseUpdateColumns(Lex& lex)
{
	int iColumnDef;
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokWhere, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoUpdateColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	m_piInsertUpdateRec = &m_riServices.CreateRecord(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strColumn, (const ICHAR*)m_istrSqlQuery);
		RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnDefn[iColumnIndex].iTableIndex,
											m_rgColumnDefn[iColumnIndex].iColumnIndex, iColumnDef));
		m_rgColumnDefn[iColumnIndex].itdType = iColumnDef & icdTypeMask; //!! remove mask and save all of def


		if(lex.MatchNext(ipqTokEqual) == fFalse)
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

		MsiString strColumnValue;
		const ipqToken& rtok1 = lex.GetNext(*&strColumnValue);
		if(rtok1 == ipqTokLiteralS) //string literal
			m_piInsertUpdateRec->SetMsiString(iColumnIndex + 1, *strColumnValue);
		else if(rtok1 == ipqTokLiteralI) //integer literal
			m_piInsertUpdateRec->SetInteger(iColumnIndex + 1, strColumnValue.operator int());// calls operator int
		else if(rtok1 == ipqTokNull) //null literal
			m_piInsertUpdateRec->SetNull(iColumnIndex + 1);
		else if(rtok1 == ipqTokParam)//param (?) literal
		{
			m_iParamInputs = m_iParamInputs | (0x1 << iColumnIndex);
			m_iParams ++;
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

// get the values to be inserted in the INSERT SQL stmt.
IMsiRecord* CMsiView::ParseInsertColumns(Lex& lex)
{
	int iColumnDef;
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokClose, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoInsertColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strColumn, (const ICHAR*)m_istrSqlQuery);
		RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnDefn[iColumnIndex].iTableIndex,
											m_rgColumnDefn[iColumnIndex].iColumnIndex, iColumnDef));
		m_rgColumnDefn[iColumnIndex].itdType = iColumnDef & icdTypeMask; //!! remove mask and save all of def
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ParseSelectColumns(Lex& lex)
{
	int iColumnDef;
	int iColumnIndex = 0;
	// get the number of columns
	if ((m_iColumns = lex.NumEntriesInList(ipqTokFrom, ipqTokComma)) == 0)
		return m_riDatabase.PostError(Imsg(idbgDbQueryNoSelectColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnDefn.Resize(m_iColumns);
	do
	{
		Assert(iColumnIndex < m_iColumns);
		// set up the columns
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok == ipqTokStar)//*
		{
			m_iColumns--; // we counted the *
			for(unsigned int iTmp = 1; iTmp <= m_iTables; iTmp++)
			{
				unsigned int iColCount = (m_rgTableDefn[iTmp].piTable)->GetColumnCount();
				m_iColumns += iColCount; 
				m_rgColumnDefn.Resize(m_iColumns);
				unsigned int cCount = 1;
				while(cCount <=  iColCount)
				{
					m_rgColumnDefn[iColumnIndex].iTableIndex = iTmp;
					m_rgColumnDefn[iColumnIndex++].iColumnIndex = cCount++;
				}
			}
			continue; // required to skip the end iColumnIndex ++;
		}
		else if(rtok == ipqTokLiteralS) //string literal
		{
			m_rgColumnDefn[iColumnIndex].iColumnIndex = BindString(strColumn);
			m_rgColumnDefn[iColumnIndex++].itdType = icdString;
		}
		else if(rtok == ipqTokLiteralI) //integer literal
		{
			m_rgColumnDefn[iColumnIndex].iColumnIndex = strColumn.operator int(); // calls operator int
			m_rgColumnDefn[iColumnIndex++].itdType = icdLong;
		}
		else if(rtok == ipqTokNull) //null literal
		{
			m_rgColumnDefn[iColumnIndex].iColumnIndex = 0;
			m_rgColumnDefn[iColumnIndex++].itdType = icdString;
		}
		else if(rtok == ipqTokParam)//param (?) literal
		{
			m_iParamOutputs = m_iParamOutputs | (0x1 << iColumnIndex);
			m_iParams ++;
		}
		else if(rtok == ipqTokId)
		{
			RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnDefn[iColumnIndex].iTableIndex,
											m_rgColumnDefn[iColumnIndex].iColumnIndex, iColumnDef));
			m_rgColumnDefn[iColumnIndex++].itdType = iColumnDef & icdTypeMask; //!! remove mask and save all of def
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ParseOrderBy(Lex& lex)
{
	int iColumnIndex = 0;
	// get the number of columns, ordered by
	if ((m_iSortColumns = lex.NumEntriesInList(ipqTokFrom, ipqTokComma)) == 0)
			return m_riDatabase.PostError(Imsg(idbgDbQueryNoOrderByColumns), (const ICHAR*)m_istrSqlQuery);
	m_rgColumnsortDefn.Resize(m_iSortColumns);
	do
	{
		// set up the columns
		Assert(iColumnIndex< m_iSortColumns);
		MsiString strColumn;
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
		int iDummy;
		RETURN_ERROR_RECORD(ResolveColumn(lex, strColumn, m_rgColumnsortDefn[iColumnIndex].iTableIndex,
													 m_rgColumnsortDefn[iColumnIndex].iColumnIndex, iDummy));
		iColumnIndex ++;
	}while(lex.MatchNext(ipqTokComma) == fTrue);
	return 0;
}

IMsiRecord* CMsiView::ResolveColumn(Lex& lex, MsiString& strColumn, unsigned int& iTableIndex, unsigned int& iColumnIndex, int& iColumnDef)
{
	iTableIndex = 0;
	iColumnIndex = 0;
	iColumnDef = 0;
	if(lex.InspectNext(ipqTokDot) == fTrue)
	{
		// column is fully specified, strColumn is table name
		// RETURN_ERROR_RECORD that the table is referenced in join
		MsiStringId tableId;
		if((tableId = m_riDatabase.EncodeString((const IMsiString& )*strColumn)) == 0)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownTable), strColumn, (const ICHAR*)m_istrSqlQuery);
		for((iTableIndex = m_iTables)++; (--iTableIndex != 0 && (m_rgTableDefn[iTableIndex].iTable != tableId)););
		if(!iTableIndex)
			// table not found
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownTable), strColumn, (const ICHAR*)m_istrSqlQuery);
		// we came in here because of the ipqTokDot
		AssertNonZero(lex.MatchNext(ipqTokDot));
		const ipqToken& rtok = lex.GetNext(*&strColumn);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), strColumn, (const ICHAR*)m_istrSqlQuery);
	}
	// set up the column
	if(strColumn.Compare(iscExact, ROWSTATE_COLUMN)) //!! possible optimization here
	{
		if(iTableIndex == 0)
		{
			if(m_iTables > 1)
				// _RowStatus part of all tables - ambiguous specification
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
			else
				iTableIndex = 1;
		}
		iColumnIndex = 0;
	}
	else
	{
		MsiStringId columnId = m_riDatabase.EncodeString((const IMsiString&)*strColumn);
		if(columnId == 0)
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		if(iTableIndex != 0)
		{
			// for fully specified columns
			if((iColumnIndex = (m_rgTableDefn[iTableIndex].piTable)->GetColumnIndex(columnId)) == 0)
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
			
		}
		else
		{
			// set up the table
			for(unsigned int iTmp = m_iTables + 1, iCnt = 0; --iTmp != 0;)
			{
				unsigned int iIndex = (m_rgTableDefn[iTmp].piTable)->GetColumnIndex(columnId);
				if(iIndex)
				{
					// column found
					iTableIndex = iTmp;
					iColumnIndex = iIndex;
					iCnt ++;
				}
			}
			if(iCnt != 1)
				// not present or ambiguous
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownColumn), strColumn, (const ICHAR*)m_istrSqlQuery);
		}
	}
	iColumnDef = m_rgTableDefn[iTableIndex].piTable->GetColumnType(iColumnIndex);
	return 0;
}

IMsiRecord* CMsiView::ParseTables(Lex& lex)
{

	do
	{	
		// set up the tables
		MsiString tableName;
		const ipqToken& rtok = lex.GetNext(*&tableName);
		
		if (rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery);

		RETURN_ERROR_RECORD(ResolveTable(lex, tableName));
//		fRet = ((ipqTok == ipqTokId) && (ResolveTable(lex, tableName) == fTrue)) ? fTrue : fFalse;

	}while(lex.MatchNext(ipqTokComma) == fTrue);
	
	return 0;
}

IMsiRecord* CMsiView::ResolveTable(Lex& lex, MsiString& tableName)
{
	// increase array size, 10 units at a time
	PMsiRecord piError(0);
	m_rgTableDefn.Resize(((++m_iTables)/10 + 1) * 10);
	// is the table one of the catalog tables
	if(tableName.Compare(iscExact, CATALOG_TABLE))//?? case sensitive
		m_rgTableDefn[m_iTables].piTable = m_riDatabase.GetCatalogTable(0);
	else if(tableName.Compare(iscExact, CATALOG_COLUMN))//?? case sensitive
		m_rgTableDefn[m_iTables].piTable = m_riDatabase.GetCatalogTable(1);
	else
	{
		piError = m_riDatabase.LoadTable(*tableName, 0, *&m_rgTableDefn[m_iTables].piTable);
		if (piError)
		{
			if (piError->GetInteger(1) == idbgDbTableUndefined)
				return m_riDatabase.PostError(Imsg(idbgDbQueryUnknownTable), tableName, (const ICHAR*)m_istrSqlQuery);
			else
				return m_riDatabase.PostError(Imsg(idbgDbQueryLoadTableFailed), tableName, (const ICHAR*)m_istrSqlQuery);
		}
	}	
	//?? ugly cast in following since CMsiCursor class constructor takes reference to CMsiTable class
	m_rgTableDefn[m_iTables].piCursor = new CMsiDCursor(*((CMsiTable* )(IMsiTable* )(m_rgTableDefn[m_iTables].piTable)), m_riDatabase, *this, m_iTables);
	if(lex.MatchNext(ipqTokAs) == fTrue)
	{
		// table alias
		const ipqToken& rtok = lex.GetNext(*&tableName);
		if(rtok != ipqTokId)
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidIdentifier), tableName, (const ICHAR*)m_istrSqlQuery );
	}
	// make sure the table is not repeated
	m_rgTableDefn[m_iTables].iTable = BindString(tableName);
	for(int iPrev = m_iTables; --iPrev != 0;)
		if(m_rgTableDefn[m_iTables].iTable == m_rgTableDefn[iPrev].iTable)
			return m_riDatabase.PostError(Imsg(idbgDbQueryTableRepeated), tableName, (const ICHAR*)m_istrSqlQuery);
	return 0;
}

IMsiRecord* CMsiView::ParseExpression(Lex& lex,unsigned int& iPosInArray,unsigned int& iPosInTree,unsigned int& iChild)
{
	// set expression tree
	RETURN_ERROR_RECORD(ParseExpr2(lex, iPosInArray, iPosInTree, iChild));
	if(lex.MatchNext(ipqTokOrOp) == fTrue)
	{
		m_rgOperationTree[iChild].iParentIndex = iPosInTree;
		m_rgOperationTree[iPosInTree].iValue = iopOR;
		int iToRet = iChild = iPosInTree;
		iPosInTree ++;
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, iPosInTree, iChild));
		m_rgOperationTree[iChild].iParentIndex = iToRet;
		iChild = iToRet;
	}
	return 0;
}

inline Bool CompatibleTypes(int icdLHS, int icdRHS)
{
	return (((icdLHS & icdTypeMask) == (icdRHS & icdTypeMask)) ||
		   (((icdLHS & icdTypeMask) == icdShort) && ((icdRHS & icdTypeMask) == icdLong)) ||
		   (((icdLHS & icdTypeMask) == icdLong)  && ((icdRHS & icdTypeMask) == icdShort))) ? fTrue : fFalse;
}

IMsiRecord* CMsiView::ParseExpr2(Lex& lex,unsigned int& iPosInArray,unsigned int& iPosInTree,unsigned int& iChild)
{
	if(lex.MatchNext(ipqTokOpen) == fTrue)
	{
		//(expression)
		RETURN_ERROR_RECORD(ParseExpression(lex, iPosInArray, iPosInTree, iChild));
		if (lex.MatchNext(ipqTokClose) == fFalse)
			return m_riDatabase.PostError(Imsg(idbgDbQueryMissingCloseParen), (const ICHAR*)m_istrSqlQuery);
	}
	else
	{
		//!! we do not support "NOT"
		// comparison
		MsiString strToken1;
		MsiString strToken2;
		const ipqToken* ptok1 = &lex.GetNext(*&strToken1);
		if(*ptok1 == ipqTokId)
		{
			int iDummy;
			RETURN_ERROR_RECORD(ResolveColumn(lex, strToken1, m_rgExpressionDefn[iPosInArray].iTableIndex1, 
					m_rgExpressionDefn[iPosInArray].iColumn1, iDummy));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken1, (const ICHAR*)m_istrSqlQuery);
		MsiString istrTempTok;
		const ipqToken* ptok2 = &lex.GetNext(*&istrTempTok);
		const ipqToken* ptok3 = &lex.GetNext(*&strToken2);
		if(*ptok2 == ipqTokIs)
		{
			if (*ptok3 == ipqTokNull)
			{
				ptok2 = &ipqTokEqual;
			}
			else if ((*ptok3 == ipqTokNotop) && (*(ptok3 = &lex.GetNext(*&istrTempTok)) == ipqTokNull))
			{
				ptok2 = &ipqTokNotEq;
			}
			else
			{
				return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidOperator), istrTempTok, (const ICHAR*)m_istrSqlQuery);
			}
		}
		m_rgExpressionDefn[iPosInArray].ptokOperation = ptok2;
		if((*ptok2 != ipqTokEqual) && (*ptok2 != ipqTokGreater)  && (*ptok2 != ipqTokLess) &&
			(*ptok2 != ipqTokGreaterEq) && (*ptok2 != ipqTokLessEq) && (*ptok2 != ipqTokNotEq))
			return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidOperator), istrTempTok, (const ICHAR*)m_istrSqlQuery);
		if(*ptok3 == ipqTokNull)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			m_rgExpressionDefn[iPosInArray].iColumn2 = 0;
		}
		else if(*ptok3 == ipqTokLiteralS)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			// !! need to optimise on missing strings
			m_rgExpressionDefn[iPosInArray].iColumn2 = BindString(strToken2);
		}
		else if(*ptok3 == ipqTokLiteralI)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			m_rgExpressionDefn[iPosInArray].iColumn2 = strToken2.operator int(); // calls operator int
		}
		else if(*ptok3 == ipqTokParam)
		{
			m_rgExpressionDefn[iPosInArray].iTableIndex2 = 0;
			m_rgExpressionDefn[iPosInArray].iColumn2 = 0;
			m_iParamExpressions = m_iParamExpressions | (0x1 << (iPosInArray - 1));
			m_iParams ++;
		}
		else if(*ptok3 == ipqTokId)
		{
			int iDummy;
			RETURN_ERROR_RECORD(ResolveColumn(lex, strToken2, m_rgExpressionDefn[iPosInArray].iTableIndex2, 
					m_rgExpressionDefn[iPosInArray].iColumn2, iDummy));
		}
		else
			return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2, (const ICHAR*)m_istrSqlQuery);
		// id ? id, only = op allowed
		if(	(*ptok1 == ipqTokId) && (*ptok3 == ipqTokId) && (*ptok2 != ipqTokEqual))
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);
		if(*ptok3 == ipqTokParam)
		{
			// set the type
			m_rgExpressionDefn[iPosInArray].itdType = (*ptok1 == ipqTokLiteralS) ? icdString : icdLong;
		}
		// also one string means compare either equal or not equal
		if( ((*ptok3 == ipqTokLiteralS)) &&
			 ((*ptok2 != ipqTokEqual)    && (*ptok2 != ipqTokNotEq)))
			return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);

		m_rgExpressionDefn[iPosInArray].ijtType = ijtNoJoin;

		Assert(m_rgExpressionDefn[iPosInArray].iTableIndex1);
		m_rgExpressionDefn[iPosInArray].itdType = m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex1].piTable->
																	GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn1) & icdTypeMask;
		// check the types
		if(m_rgExpressionDefn[iPosInArray].iTableIndex2)
		{
			// ipqTokId = ipqTokId, join
			if (!CompatibleTypes(m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex1].piTable->
					GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn1),
					m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex2].piTable->
					GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn2)))
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec), (const ICHAR*)m_istrSqlQuery);//!! is itdShort vs. itdLong OK??

			// set the join type
			if((m_rgExpressionDefn[iPosInArray].iColumn1 != 1) && (m_rgExpressionDefn[iPosInArray].iColumn2 != 1))
				m_rgExpressionDefn[iPosInArray].ijtType = ijtMToMJoin;
			else if ((m_rgExpressionDefn[iPosInArray].iColumn1 == 1) && (m_rgExpressionDefn[iPosInArray].iColumn2 == 1))
				m_rgExpressionDefn[iPosInArray].ijtType = ijt1To1Join;
			else
			{
				if(m_rgExpressionDefn[iPosInArray].iColumn2 == 1)
				{
					//switch 
					unsigned int iTable = m_rgExpressionDefn[iPosInArray].iTableIndex2;
					unsigned int iColumn = m_rgExpressionDefn[iPosInArray].iColumn2;

					m_rgExpressionDefn[iPosInArray].iTableIndex2 = m_rgExpressionDefn[iPosInArray].iTableIndex1;
					m_rgExpressionDefn[iPosInArray].iColumn2 = m_rgExpressionDefn[iPosInArray].iColumn1;
					m_rgExpressionDefn[iPosInArray].iTableIndex1 = iTable;
					m_rgExpressionDefn[iPosInArray].iColumn1 = iColumn;
				}
				m_rgExpressionDefn[iPosInArray].ijtType = ijt1ToMJoin;
			}
		}
		else
		{
			// ipqTokId = literal
			switch(m_rgTableDefn[m_rgExpressionDefn[iPosInArray].iTableIndex1].piTable->
					  GetColumnType(m_rgExpressionDefn[iPosInArray].iColumn1) & icdTypeMask)
			{
			case icdLong:
			case icdShort: //!!needed?
				if((*ptok3 == ipqTokParam) || (*ptok3 == ipqTokLiteralI))
					;
				else if(*ptok3 == ipqTokNull)
					m_rgExpressionDefn[iPosInArray].iColumn2 = (unsigned int)iMsiNullInteger;
				else
					return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2,(const ICHAR*)m_istrSqlQuery);
				break;
			case icdString:
				if((*ptok3 == ipqTokParam) || (*ptok3 == ipqTokLiteralS))
					;
				else if(*ptok3 == ipqTokNull)
					m_rgExpressionDefn[iPosInArray].iColumn2 = iMsiNullString;
				else
					return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2,(const ICHAR*)m_istrSqlQuery);
				break;
			case icdObject:
				if (*ptok3 == ipqTokNull)
					m_rgExpressionDefn[iPosInArray].iColumn2 = 0;
				else
					return m_riDatabase.PostError(Imsg(idbgDbQueryUnexpectedToken), strToken2,(const ICHAR*)m_istrSqlQuery);
				break;
			default:
				return m_riDatabase.PostError(Imsg(idbgDbQuerySpec));
			}
		}
		
		m_rgOperationTree[iPosInTree].iValue = iPosInArray;
		m_rgOperationTree[iPosInTree].iParentIndex = 0;
		iChild = iPosInTree;
		iPosInArray ++;
		iPosInTree ++;
	}
	if(lex.MatchNext(ipqTokAndOp) == fTrue)
	{
		m_rgOperationTree[iChild].iParentIndex = iPosInTree;
		m_rgOperationTree[iPosInTree].iValue = iopAND;
		int iToRet = iChild = iPosInTree;
		iPosInTree ++;
		RETURN_ERROR_RECORD(ParseExpr2(lex, iPosInArray, iPosInTree, iChild));
		m_rgOperationTree[iChild].iParentIndex = iToRet;
		iChild = iToRet;
	}
	return 0;
}

IMsiRecord* CMsiView::_Fetch()
{
	return FetchCore();
}

IMsiRecord* CMsiView::Fetch()
{
	if (!(m_ivcIntent & ivcFetch))
	{
		AssertSz(0, "Intent violation");
		return 0;
	}
	return FetchCore();
}

IMsiRecord* CMsiView::FetchCore()
{
	if (m_CursorState != dvcsFetched && m_CursorState != dvcsBound)
	{
		AssertSz(0, "Wrong database state.Did you forget to call Execute() before Fetch()?");
		return 0;
	}
	if (m_piRecord)  // row record from previous fetch
	{
		m_piRecord->AddRef(); // protect against self-destruction
		if (m_piRecord->Release() == 1) // no one else is holding on
			m_piRecord->ClearData();
		else  // too bad, must release it
		{
			m_piRecord = 0;
		}
	}
	Bool fRetCode;
	if(m_piFetchTable)
	{
		// records already fetched
		fRetCode = GetNextFetchRecord();
		m_CursorState = dvcsFetched;
	}
	else
	{
		do{
			if(m_CursorState == dvcsFetched)
			{
				fRetCode = FetchNext();
			}
			else if(m_CursorState == dvcsBound)
			{
				// fetch for the first time
				fRetCode = EvaluateConstExpressions();
				if(fRetCode == fTrue)
					fRetCode = FetchFirst();
				m_CursorState = dvcsFetched;
			}
			else
			{
				AssertSz(0, "Wrong database state");
				return 0;
			}
		}while((fRetCode == fTrue) && ((IsDistinct() == fFalse) || (FitCriteriaORExpr(m_iTreeParent) == fFalse)));
	}
	if (fRetCode != fTrue) 	
	{
		// last record fetched.
		m_piRecord = 0;
		m_CursorState = dvcsBound;
	}
	else
	{
		// add to row count if not prefetched
		if(!m_piFetchTable)
			m_lRowCount++;
		if (!m_piRecord)
			m_piRecord = &m_riServices.CreateRecord(m_iColumns);
		m_piRecord->AddRef(); // we keep a reference so we can reuse it
		FetchRecordInfoFromCursors();
		// stamp 0th field with this pointer
#ifdef _WIN64	// !merced
		m_piRecord->SetHandle(0, (HANDLE)(this));
#else
		m_piRecord->SetInteger(0, int(this));
#endif
	}
	return m_piRecord;    // client better do a Release()
}

void CMsiView::FetchRecordInfoFromCursors()
{
	for (unsigned int iCol = m_iColumns; iCol--;)
	{
		if(m_rgColumnDefn[iCol].iTableIndex == 0)
		{
			// literal
			if (m_rgColumnDefn[iCol].itdType & icdObject) // index to database string cache
			{
				MsiString strStr = m_riDatabase.DecodeString(m_rgColumnDefn[iCol].iColumnIndex);
				if(strStr.TextSize())
					m_piRecord->SetMsiString(iCol+1, *strStr);
				else
					m_piRecord->SetNull(iCol+1);
			}
			else // integer
			{
				if (m_rgColumnDefn[iCol].iColumnIndex == iMsiNullInteger)
					m_piRecord->SetNull(iCol+1);
				else
					m_piRecord->SetInteger(iCol+1, m_rgColumnDefn[iCol].iColumnIndex);
			}
		}
		else
		{
			switch((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->
					  GetColumnType(m_rgColumnDefn[iCol].iColumnIndex) & icdTypeMask)
			{
			case icdLong:// integer
			case icdShort: //!!needed?
			{
				int iTmp =	(m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetInteger(m_rgColumnDefn[iCol].iColumnIndex);
				if(iMsiNullInteger == iTmp)
					m_piRecord->SetNull(iCol+1);
				else
					m_piRecord->SetInteger(iCol+1, iTmp);
				break;
			}
			case icdString:// index to database string cache
			{
				// temp variable necessary for correct refcnt
				MsiString strString = (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetString(m_rgColumnDefn[iCol].iColumnIndex);
				if(strString.TextSize())
					m_piRecord->SetMsiString(iCol+1, *strString);
				else
					m_piRecord->SetNull(iCol+1);
				break;
			}
			case icdObject:
			{
				// IMsiData interface pointer (temp. columns or persisten streams, database code handles the difference transparantly)
				// temp variable necessary for correct refcnt
//					CComPointer<const IMsiData> piData = (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetMsiData(m_rgColumnDefn[iCol].iColumnIndex);

				// following line put in explicitly to release pointer to previously held stream.
				// this is essential in case we are holding to the same stream as the one we are 
				// attempting to read. (cannot obtain handle to OLE stream if already opened)
				m_piRecord->SetNull(iCol+1);
				PMsiData piData = (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetMsiData(m_rgColumnDefn[iCol].iColumnIndex);
				m_piRecord->SetMsiData(iCol+1, piData);
				break;
			}
			}
		}
	}
	m_piRecord->ClearUpdate();  // to detect changed fields for Update
}

// first fetch
Bool CMsiView::FetchFirst(unsigned int iTableSequence)
{
	int iRet = 0;
	Bool fContinue = fTrue;
	if(iTableSequence < (m_iTables - 1))
		fContinue = FetchFirst(iTableSequence + 1);
	while(fContinue == fTrue)
	{
		if(SetTableFilters(m_rgiTableSequence[iTableSequence]) == fTrue)
			while(((iRet = (m_rgTableDefn[m_rgiTableSequence[iTableSequence]].piCursor)->Next()) != 0) && !(FitCriteria(m_rgiTableSequence[iTableSequence])))
				;
		fContinue = ((iRet != 0) ? fFalse : FetchNext(iTableSequence + 1));
	}
	return iRet ? fTrue : fFalse;
}

// all subsequent fetches
Bool CMsiView::FetchNext(unsigned int iTableSequence)
{
	int iRet = 0;
	Bool fContinue = (iTableSequence >= m_iTables) ? fFalse : fTrue;
	while(fContinue == fTrue)
	{
		while(((iRet = (m_rgTableDefn[m_rgiTableSequence[iTableSequence]].piCursor)->Next()) != 0) && !(FitCriteria(m_rgiTableSequence[iTableSequence])))
			;
		do{
			fContinue = ((iRet != 0) ? fFalse : FetchNext(iTableSequence + 1));
				//we rerun through the table, set the filters again
		}while((fContinue != fFalse) && (SetTableFilters(m_rgiTableSequence[iTableSequence]) == fFalse));
	}
	return iRet ? fTrue : fFalse;
}

// prefetched row counts need to be updated due to a row being deleted
void CMsiView::RowDeleted(int iRow, int iTable)
{
	if(m_piFetchTable != 0)
	{
		PMsiCursor piCursor = m_piFetchTable->CreateCursor(fFalse);
		Assert(piCursor != 0);
		int fRet;
		while((fRet = piCursor->Next()) != 0)
		{
			int iRow1 = piCursor->GetInteger(m_iSortColumns + 1 + iTable);
			if(iRow1 > 0)
			{
				if(iRow1 > iRow)
				{
					AssertNonZero(piCursor->PutInteger(m_iSortColumns + 1 + iTable, iRow1 - 1) == fTrue);
					AssertNonZero(piCursor->Update() == fTrue);
				}
				else if(iRow1 == iRow)
				{
					AssertNonZero(piCursor->PutInteger(m_iSortColumns + 1 + iTable, -(iRow1 - 1)) == fTrue);
					AssertNonZero(piCursor->Update() == fTrue);
				}
			}
		}
	}
}

// prefetched row counts need to be updated due to a row being inserted
void CMsiView::RowInserted(int iRow, int iTable)
{
	if(m_piFetchTable != 0)
	{
		PMsiCursor piCursor = m_piFetchTable->CreateCursor(fFalse);
		Assert(piCursor != 0);
		int fRet;
		while((fRet = piCursor->Next()) != 0)
		{
			int iRow1 = piCursor->GetInteger(m_iSortColumns + 1 + iTable );
			if(iRow1 >= iRow)
			{
				AssertNonZero(piCursor->PutInteger(m_iSortColumns  + 1 + iTable, iRow1 + 1) == fTrue);
				AssertNonZero(piCursor->Update() == fTrue);
			}
		}
	}
}

Bool CMsiView::GetNextFetchRecord()
{
	if(m_piFetchCursor->Next())
	{
		for(unsigned int iTables = m_iTables + 1; --iTables != 0;)
		{
			// need to honour prefetched row count, hence return null cursor if row has been deleted
			int iRow = m_piFetchCursor->GetInteger(m_iSortColumns + iTables + 1);
			if(iRow <= 0)
				// row deleted
				(m_rgTableDefn[iTables].piCursor)->Reset();
			else
				(m_rgTableDefn[iTables].piCursor)->SetRow(iRow);
		}
		return fTrue;
	}
	else
		return fFalse;
}

void CMsiView::SetNextFetchRecord()
{
	int cCount = PMsiTable(&m_piFetchCursor->GetTable())->GetRowCount();
	for(unsigned int iTmp = m_iTables + 1; --iTmp != 0;)
		AssertNonZero(m_piFetchCursor->PutInteger(m_iSortColumns + 1 + iTmp, (m_rgTableDefn[iTmp].piCursor)->GetRow()) == fTrue);
	for((iTmp = m_iSortColumns)++; --iTmp != 0;)
		AssertNonZero(m_piFetchCursor->PutInteger(iTmp, (m_rgTableDefn[m_rgColumnsortDefn[iTmp - 1].iTableIndex].piCursor)->GetInteger(m_rgColumnsortDefn[iTmp - 1].iColumnIndex)) == fTrue);
	AssertNonZero(m_piFetchCursor->PutInteger(m_iSortColumns + 1, cCount) == fTrue);
	AssertNonZero(m_piFetchCursor->Insert());
}

// does the record fit all independant criteria for the table
Bool CMsiView::FitCriteria(unsigned int iTableIndex)
{
	Bool fRet = fTrue;
	int iExpression = 1;
	unsigned int iExpressions = m_rgTableDefn[iTableIndex].iExpressions;
	while((fRet == fTrue) && (iExpressions))
	{
		if(iExpressions & 0x1)
			// iExpression pertains to this table
			fRet = EvaluateExpression(iExpression);
		iExpressions = iExpressions >> 1;
		iExpression ++;
	}
	return fRet;
}

// function to evaluate an expression
Bool CMsiView::EvaluateExpression(unsigned int iExpression)
{
	int iOperand1;
	int iOperand2;
	Bool fResult = fFalse;
	// we support literal comparisons
	if(m_rgExpressionDefn[iExpression].iTableIndex1)
		iOperand1 = (m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn1);
	else
		iOperand1 = m_rgExpressionDefn[iExpression].iColumn1;
	if(m_rgExpressionDefn[iExpression].iTableIndex2)
		iOperand2 = (m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex2].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn2);
	else
		iOperand2 = m_rgExpressionDefn[iExpression].iColumn2;
	if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokEqual)
		fResult = (iOperand1 == iOperand2)?fTrue:fFalse;
	else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokNotEq)
		fResult = (iOperand1 != iOperand2)?fTrue:fFalse;
	else
	{
		// need to return false for null comparisons
		if((iOperand1 == iMsiNullInteger) || (iOperand2 == iMsiNullInteger))
			fResult = fFalse;
		else
		{
			if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokGreater)
				fResult = (iOperand1 > iOperand2)? fTrue:fFalse;
			else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokLess)
				fResult = (iOperand1 < iOperand2)? fTrue:fFalse;
			else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokGreaterEq)
				fResult = (iOperand1 >= iOperand2)? fTrue:fFalse;
			else if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokLessEq)
				fResult = (iOperand1 <= iOperand2)? fTrue:fFalse;
		}
	}
	return fResult;
}

// set up the values from the parent as a filter on the subsequent child gets
// also set up the independant filters
Bool CMsiView::SetTableFilters(unsigned int iTableIndex)
{
	int iExpression = 1;
	unsigned int iExpressions = m_rgTableDefn[iTableIndex].iExpressions;
	while(iExpressions)
	{
		if(iExpressions & 0x1)
		{
			// iOperation pertains to this table
			if(m_rgExpressionDefn[iExpression].fFlags == fTrue)
			{

				if(m_rgExpressionDefn[iExpression].iTableIndex2 == 0)
				{
					if(*m_rgExpressionDefn[iExpression].ptokOperation == ipqTokEqual)
						// set the data for the filtered columns
						if((m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->PutInteger(
						m_rgExpressionDefn[iExpression].iColumn1, m_rgExpressionDefn[iExpression].iColumn2) == fFalse)
							return fFalse;
				}
				else if(m_rgExpressionDefn[iExpression].iTableIndex1 == iTableIndex)
				{
					// set the data for the filtered columns
					if((m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->PutInteger(
						m_rgExpressionDefn[iExpression].iColumn1,
						(m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex2].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn2)) == fFalse)
						return fFalse;
				}
				else 
				{
					// set the data for the filtered columns
					if((m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex2].piCursor)->PutInteger(
							m_rgExpressionDefn[iExpression].iColumn2,
							(m_rgTableDefn[m_rgExpressionDefn[iExpression].iTableIndex1].piCursor)->GetInteger(m_rgExpressionDefn[iExpression].iColumn1)) == fFalse)
						return fFalse;

				}
			}
		}
		iExpressions = iExpressions >> 1;
		iExpression ++;
	}
	return fTrue;
}




// set up the hierarchy between the table for the joins
// the following maths holds true
// For a join between 2 tables T1, T2 of size S1, S2
// 1. the join involves 1 primary index (for T1), none for T2
// search takes S1 + S1 * S2/2 OR S2 + S2 * logS1
// hence go sequentially through T2 always

// 2. the join involves 2 primary indiices for the 2 tables
// search takes S1 + S1 * logS2 OR S2 + S2 * logS1
// hence sequentially go through the SMALLER of the 2 tables
// UNLESS filter on primary key of a table where go 
// from that table to the other table.

// 3. the join involves no primary indiices,
// search takes S1 + S1* S2/2 OR S2 + S2 * S1/2
// hence sequentially go through the SMALLER of the 2 tables

Bool CMsiView::SetupTableJoins()
{
	for(unsigned int iTmp = m_iExpressions + 1; --iTmp != 0;)
	{
		if((m_rgExpressionDefn[iTmp].fFlags == fTrue) && (m_rgExpressionDefn[iTmp].iTableIndex2))
		{
			// self join skipped
			if(m_rgExpressionDefn[iTmp].iTableIndex1 == m_rgExpressionDefn[iTmp].iTableIndex2)
				continue;

			// if we have already joined these 2 tables, skip
			if(	(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex1].iParentIndex == m_rgExpressionDefn[iTmp].iTableIndex2) ||
				(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex2].iParentIndex == m_rgExpressionDefn[iTmp].iTableIndex1))
				continue;

			// check which way will have least cost
			unsigned int iParent1, iParent2;
			int iCost1 = GetSearchReversingCost(m_rgExpressionDefn[iTmp].iTableIndex1, iParent1);
			int iCost2 = GetSearchReversingCost(m_rgExpressionDefn[iTmp].iTableIndex2, iParent2);
			if(m_rgExpressionDefn[iTmp].ijtType == ijt1ToMJoin)
				iCost2 ++;

			if((iCost1 < iCost2) || 
				((iCost1 == iCost2) && ((m_rgTableDefn[iParent2].piTable)->GetRowCount() <
					(m_rgTableDefn[iParent1].piTable)->GetRowCount())))
			{
				// do not reverse if already as desired
				if(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex1].iParentIndex != m_rgExpressionDefn[iTmp].iTableIndex2)
				{
					ReverseJoinLink(m_rgExpressionDefn[iTmp].iTableIndex1);
					m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex1].iParentIndex = m_rgExpressionDefn[iTmp].iTableIndex2;
				}
			}
			else
			{
				// do not reverse if already as desired
				if(m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex2].iParentIndex != m_rgExpressionDefn[iTmp].iTableIndex1)
				{
					ReverseJoinLink(m_rgExpressionDefn[iTmp].iTableIndex2);
					m_rgTableDefn[m_rgExpressionDefn[iTmp].iTableIndex2].iParentIndex = m_rgExpressionDefn[iTmp].iTableIndex1;
				}
			}
		}
	}


	unsigned int iParent = 0;
	for(iTmp = m_iTables + 1; --iTmp != 0;)
	{
		if(m_rgTableDefn[iTmp].iParentIndex == 0)
		{
			m_rgTableDefn[iTmp].iParentIndex = iParent;
			iParent = iTmp;
		}
	}

	// check if we have no root
	return (iParent == 0) ? fFalse : fTrue;
}


//?? Why does this function return a Bool? it never fails...this leaves dead error code at the calling end -- malcolmh

// Determine which expressions are to be associated with which tables
Bool CMsiView::InitialiseFilters()
{
	unsigned int iTable;
	unsigned int iColumn;

	for(int iTmp = m_iExpressions + 1; --iTmp != 0;)
	{
		if(m_rgExpressionDefn[iTmp].fFlags == fTrue)
		{
			iTable = m_rgExpressionDefn[iTmp].iTableIndex1;
			iColumn = m_rgExpressionDefn[iTmp].iColumn1;
			if(m_rgExpressionDefn[iTmp].iTableIndex2)
			{
				Assert(m_rgExpressionDefn[iTmp].iTableIndex1);

				for(unsigned int iTmp1 = m_iTables; iTmp1--;)
				{
					if(m_rgiTableSequence[iTmp1] == m_rgExpressionDefn[iTmp].iTableIndex2)
						break;
					if(m_rgiTableSequence[iTmp1] == m_rgExpressionDefn[iTmp].iTableIndex1)
					{
						iTable = m_rgExpressionDefn[iTmp].iTableIndex2;
						iColumn = m_rgExpressionDefn[iTmp].iColumn2;
						break;
					}
				}
			}
			m_rgTableDefn[iTable].iExpressions |= (1 << (iTmp - 1));
			if((*m_rgExpressionDefn[iTmp].ptokOperation == ipqTokEqual) &&
				(m_rgExpressionDefn[iTmp].iTableIndex1 != m_rgExpressionDefn[iTmp].iTableIndex2))
			{
				unsigned int prevFilter = m_rgTableDefn[iTable].piCursor->SetFilter(0);
				m_rgTableDefn[iTable].piCursor->SetFilter(prevFilter | (1 << (iColumn - 1)));
			}
		}
	}
	return fTrue;
}


// set up the sort table, if required
void CMsiView::SetupSortTable()
{
	// check if we need to have an explicit sort
	// we do not need one if the sort columns are
	// the keys of the tables in order of the joins, starting
	// at the root table AND w/o gaps.
	if(m_iSortColumns)
	{
		unsigned int iSortColumns = 0;
		unsigned int iTable = m_rgiTableSequence[m_iTables - 1];
		unsigned int iColumnIndex = 1;

		while(iSortColumns < m_iSortColumns)
		{
			if(m_rgColumnsortDefn[iSortColumns].iTableIndex != iTable ||
				m_rgColumnsortDefn[iSortColumns].iColumnIndex != iColumnIndex)
				return;

			if(iColumnIndex == (m_rgTableDefn[iTable].piTable)->GetPrimaryKeyCount())
			{
				iTable = m_rgTableDefn[iTable].iParentIndex;
				iColumnIndex = 1;
			}
			else
				iColumnIndex ++;

			iSortColumns ++;
		}
		m_iSortColumns = 0;
	}
}

void CMsiView::ReverseJoinLink(unsigned int iTable)
{
	unsigned int iTmp1 = iTable;
	unsigned int iTmp2 = m_rgTableDefn[iTable].iParentIndex;
	while (iTmp2)
	{
		unsigned int iTmp3 = m_rgTableDefn[iTmp2].iParentIndex;
		m_rgTableDefn[iTmp2].iParentIndex = iTmp1;
		iTmp1 = iTmp2;
		iTmp2 = iTmp3;
	}
}

int CMsiView::GetSearchReversingCost(unsigned int iTable, unsigned int& riParentTable)
{
	int iCost = 0;
	while(m_rgTableDefn[iTable].iParentIndex)
	{
		// check type of join
		for(unsigned int iTmp = m_iExpressions + 1; --iTmp != 0;)
		{
			if(m_rgExpressionDefn[iTmp].fFlags == fTrue)
			{
				if((m_rgExpressionDefn[iTmp].iTableIndex1 == iTable) &&
					(m_rgExpressionDefn[iTmp].iTableIndex2 == m_rgTableDefn[iTable].iParentIndex))
				{
					if(m_rgExpressionDefn[iTmp].ijtType == ijt1ToMJoin)
						iCost ++;
					break;
				}
				else if((m_rgExpressionDefn[iTmp].iTableIndex2 == iTable) &&
					(m_rgExpressionDefn[iTmp].iTableIndex1 == m_rgTableDefn[iTable].iParentIndex))
				{
					if(m_rgExpressionDefn[iTmp].ijtType == ijt1ToMJoin)
						iCost --;
					break;
				}
			}
		}
		iTable = m_rgTableDefn[iTable].iParentIndex;
	}
	riParentTable = iTable;
	return iCost;
}


// fn to get the order in which the tables need to be fetched
void CMsiView::SetTableSequence(int iParent, int& iPos)
{
	for(unsigned int iTmp = m_iTables + 1; --iTmp != 0;)
	{
		if(m_rgTableDefn[iTmp].iParentIndex == iParent)
		{
			m_rgiTableSequence[iPos--] = iTmp;
			SetTableSequence(iTmp, iPos);
		}
	}
}


// evaluate const. expressions
Bool CMsiView::EvaluateConstExpressions()
{
	Bool fRet = fTrue;

	for(unsigned int iTmp = m_iExpressions + 1; (--iTmp != 0 && fRet == fTrue);)
	{
		if((m_rgExpressionDefn[iTmp].fFlags == fTrue) && 
			(!m_rgExpressionDefn[iTmp].iTableIndex1) &&
			(!m_rgExpressionDefn[iTmp].iTableIndex2))
			fRet = EvaluateExpression(iTmp);
	}
	return fRet;
}

// find all the independant expressions (not rooted directly or indirectly to an OR operation
void CMsiView::SetAndExpressions(unsigned int iTreeRoot)
{
	if(!m_iOperations)
		return;
	if(m_rgOperationTree[iTreeRoot].iValue == iopOR)
		return;
	if(m_rgOperationTree[iTreeRoot].iValue == iopAND)
	{
		Bool bFirst = fTrue;
		unsigned int iChild1, iChild2;
		unsigned int iOperations = m_iOperations - 1;
		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild1 = iOperations;

		Assert((int)iOperations > 0);
		iOperations--;

		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild2 = iOperations;

		Assert((int)iOperations >= 0);

		SetAndExpressions(iChild1);
		SetAndExpressions(iChild2);

		return;
	}
	m_rgExpressionDefn[m_rgOperationTree[iTreeRoot].iValue].fFlags = fTrue;
	return;
}

// evaluate if the result is distinct
Bool CMsiView::IsDistinct()
{
	Bool fRet = fTrue;
	if(m_fDistinct != fFalse)
	{
		Assert(m_piDistinctTable);
		PMsiCursor piCursor = m_piDistinctTable->CreateCursor(fFalse);

		for (unsigned int iCol = m_iColumns; iCol--;)
		{
			if(m_rgColumnDefn[iCol].iTableIndex == 0)
				piCursor->PutInteger(iCol + 1, m_rgColumnDefn[iCol].iColumnIndex);
			else
				piCursor->PutInteger(iCol + 1, (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetInteger(m_rgColumnDefn[iCol].iColumnIndex));
		}
		fRet = piCursor->Insert(); // fTrue if no duplicate row (all columns are primary keys),
											// fFalse if a duplicate row - bench 11/22/96
	}
	return fRet;

}

// evaluate the auxiliary OR expression, we skip over the independant expressions
// which are evaluated to be true earlier.
Bool CMsiView::FitCriteriaORExpr(unsigned int iTreeRoot)
{
	if(!m_iOperations)
		return fTrue;

	if(m_rgOperationTree[iTreeRoot].iValue & iopANDOR)
	{
		unsigned int iChild1, iChild2;
		unsigned int iOperations = m_iOperations - 1;
		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild1 = iOperations;

		Assert((int)iOperations > 0);
		iOperations--;

		while(m_rgOperationTree[iOperations].iParentIndex != iTreeRoot)
			iOperations --;

		iChild2 = iOperations;

		Assert((int)iOperations >= 0);

		if(m_rgOperationTree[iTreeRoot].iValue == iopAND)
			// and operation
			return (((FitCriteriaORExpr(iChild1) == fTrue) && (FitCriteriaORExpr(iChild2) == fTrue))?fTrue:fFalse);
		else 
			// or operation
			return (((FitCriteriaORExpr(iChild1) == fTrue) || (FitCriteriaORExpr(iChild2) == fTrue))?fTrue:fFalse);
	}
	if(m_rgExpressionDefn[m_rgOperationTree[iTreeRoot].iValue].fFlags == fTrue)
		return fTrue;
	else
		return EvaluateExpression(m_rgOperationTree[iTreeRoot].iValue);
}


MsiStringId CMsiView::BindString(MsiString& rstr)
{
	Assert(m_piBindTableCursor);
	m_piBindTableCursor->Reset();
	m_piBindTableCursor->PutString(1, *rstr);
	AssertNonZero(m_piBindTableCursor->Assign());
	return m_piBindTableCursor->GetInteger(1);
}


CMsiView::CMsiView(CMsiDatabase& riDatabase, IMsiServices& riServices):
		m_riDatabase(riDatabase), m_riServices(riServices), 
		m_piRecord(0), m_piFetchTable(0), m_piFetchCursor(0),
		m_piBindTable(0),m_piBindTableCursor(0), m_piDistinctTable(0), m_fDistinct(fFalse),
		m_piInsertUpdateRec(0)
{
	m_iTables = 0;
	m_iColumns = 0;
	m_iSortColumns = 0;
	m_iExpressions = 0;
#if 0
	m_rgTableDefn = 0;
	m_rgiTableSequence = 0;
	m_rgExpressionDefn = 0;
	m_rgColumnDefn = 0;
	m_rgOperationTree = 0;
	m_rgColumnsortDefn = 0;
#endif
	m_CursorState = dvcsClosed;
	m_iParams = 0;
	m_iParamInputs = 0;
	m_iParamOutputs = 0;
	m_iParamExpressions = 0;
	m_iOperations = 0;
	m_iTreeParent = 0;
	m_lRowCount = 0;
	m_riDatabase.AddRef();
	m_riServices.AddRef();
	memset(m_rgchError, 0, 1+cMsiMaxTableColumns);
	m_fErrorRefreshed = fTrue;
	m_iFirstErrorIndex = 1;
	m_fLock = -1;
	Debug(m_Ref.m_pobj = this);
}



CMsiView::~CMsiView()
{
	m_CursorState = dvcsDestructor;
	Close();
}



IMsiRecord* CMsiView::GetColumnNames()
{
	int iNumCol = GetFieldCount();
	IMsiRecord* piRecord = &m_riServices.CreateRecord(iNumCol);
	for (unsigned int iCol = iNumCol; iCol--;)
	{

		if(m_rgColumnDefn[iCol].iTableIndex)
		{
			MsiString strCol = m_riDatabase.DecodeString((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->GetColumnName(m_rgColumnDefn[iCol].iColumnIndex));
			piRecord->SetMsiString(iCol+1, *strCol);
		}
		else
			piRecord->SetNull(iCol+1);
	}
	return piRecord;
}


unsigned int CMsiView::GetFieldCount()
{
	if (m_CursorState == dvcsClosed)
		return 0;
	else
		return m_iColumns;
}


IMsiRecord* CMsiView::GetColumnTypes()
{
	int iNumCol = GetFieldCount();
	IMsiRecord* piRecord = &m_riServices.CreateRecord(iNumCol);
	for (unsigned int iCol = iNumCol; iCol--;)
	{
		ICHAR chType = 0;
		int iLength = 0;
		int iColIndex = m_rgColumnDefn[iCol].iColumnIndex;
		int iTableIndex = m_rgColumnDefn[iCol].iTableIndex;
		if (iTableIndex == 0)  // constant
		{
			switch (m_rgColumnDefn[iCol].itdType)
			{
			case icdString:
				chType = 'f';
				iLength = MsiString(m_riDatabase.DecodeString(iColIndex)).TextSize();
				break;
			case icdLong:
				chType = 'h';
				iLength = 4;
				break;
			default:
				Assert(0);
			}
		}
		else // iTableIndex > 0
		{
			int iColumnDef = m_rgTableDefn[iTableIndex].piTable->GetColumnType(iColIndex);
			if (iColumnDef & icdObject)
			{
				if (iColumnDef & icdShort) // string index
				{
					if (iColumnDef & icdPersistent)
						chType = (iColumnDef & icdLocalizable) ? 'l' : 's';
					else
						chType = 'g';
					iLength = iColumnDef & icdSizeMask;
				}
				else if (iColumnDef & icdPersistent) // binary stream
				{
					chType =  'v';
					iLength = 0;
				}
				else // temporary object column
				{
					chType =  'o';
					iLength = 0;
				}
			}
			else // integer
			{
				chType = ((iColumnDef & icdPersistent) ? 'i' : 'j');
				iLength = (iColumnDef & icdShort) ? 2 : 4;
			}
			if (iColumnDef & icdNullable)
				chType -= ('a' - 'A');
		}
		ICHAR szTemp[20];
		wsprintf(szTemp, TEXT("%c%i"), chType, iLength);
		piRecord->SetString(iCol + 1, szTemp);
	}
	return piRecord;
}


IMsiRecord* CMsiView::Close()
{
	switch (m_CursorState)
	{
	case dvcsFetched:
	case dvcsBound:
	case dvcsExecuted:
	case dvcsPrepared:
		m_CursorState = dvcsPrepared;
		break;
	case dvcsClosed:
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
	case dvcsDestructor:
		break;
	}
	m_piFetchCursor = 0;
	m_piFetchTable = 0;
	m_piDistinctTable=0;
	m_piRecord = 0;
	m_lRowCount = 0;
	return 0;
}


/*-----------------------------------------------------------------------------------------------
CMsiView::Modify

-------------------------------------------------------------------------------------------------*/
// inline function to set irmEnum to Modify bit
inline unsigned int iModifyBit(irmEnum irmAction) { return 1 << (irmAction - (irmPrevEnum + 1)); }

// Actions that require that we prefetch the remaining result set
const int iPrefetchResultSet =    iModifyBit(irmInsert)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmAssign)
								| iModifyBit(irmReplace)
								| iModifyBit(irmMerge);

// Actions that require all record data to be copied
const int iCopyAll             =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmAssign)
								| iModifyBit(irmMerge)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField);

// Actions that require the cursor state to not be closed or destructed
const int iCheckCursorState    = iCopyAll;

// Actions that require record to have been fetched before
const int iFetchRequired       =iModifyBit(irmRefresh)
								| iModifyBit(irmReplace)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateDelete);

// Actions that are unsupported for joins
const int iDisallowJoins       =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmAssign)
								| iModifyBit(irmReplace)
								| iModifyBit(irmMerge)
								| iModifyBit(irmDelete)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField)
								| iModifyBit(irmValidateDelete);

// Actions that can occur with a fetched record OR a record that was just inserted OR seeked
const int iRequireStamp        =iModifyBit(irmUpdate)
								| iModifyBit(irmDelete);

// Actions that require stamping
const int iNeedStamp           =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmInsertTemporary);

// Actions where m_piRecord must match the passed in record
const int iRequireFetch        =iModifyBit(irmRefresh)
								| iModifyBit(irmReplace)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateDelete);

// Actions that only need to have primary key record data copied over to cursors
const int iKeysOnly            =iModifyBit(irmSeek);

// Actions that require transfer of data
const int iTransfer            =iModifyBit(irmSeek)
								| iModifyBit(irmInsert)
								| iModifyBit(irmAssign)
								| iModifyBit(irmUpdate)
								| iModifyBit(irmReplace)
								| iModifyBit(irmMerge)
								| iModifyBit(irmInsertTemporary)
								| iModifyBit(irmValidate)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField)
								| iModifyBit(irmValidateDelete);

// Fetch record info from cursors
const int iFetchRecInfo        =iModifyBit(irmSeek)
								| iModifyBit(irmRefresh);
	
// Validation actions
const int iValidation          =iModifyBit(irmValidate)
								| iModifyBit(irmValidateNew)
								| iModifyBit(irmValidateField)
								| iModifyBit(irmValidateDelete);

// Function pointer array to Cursor member functions
typedef Bool (__stdcall CMsiCursor::*FAction)(void);
static FAction s_rgAction[] ={                      //!! must be in this order 
						CMsiCursor::Seek,           // index = irmSeek + 1
						CMsiCursor::Refresh,        // index = irmRefresh + 1
						CMsiCursor::Insert,         // index = irmInsert + 1 
						CMsiCursor::Update,         // index = irmUpdate + 1
						CMsiCursor::Assign,         // index = irmAssign + 1
						CMsiCursor::Replace,        // index = irmReplace + 1
						CMsiCursor::Merge,          // index = irmMerge + 1
						CMsiCursor::Delete,         // index = irmDelete + 1
						CMsiCursor::InsertTemporary // index = irmInsertTemporary + 1
					};

IMsiRecord* __stdcall CMsiView::Modify(IMsiRecord& riRecord, irmEnum irmAction)
{
	// clear error array if not already clear
	if ( ! m_fErrorRefreshed )
	{
		memset(m_rgchError, 0, 1+cMsiMaxTableColumns);
		m_fErrorRefreshed = fTrue;
		m_iFirstErrorIndex = 1;
	}

	// Cannot truly validate intent here due to possible temporary columns and row
	// that are valid for read-only databases. Also need to support all validations.
	// Problem arises from the fact that intent is not exposed to external APIs.
	// cannot do this:	if ((irmAction != irmRefresh) && (irmAction != irmValidate) && (irmAction != irmValidateField) && (irmAction != irmInsertTemporary) && (!(m_ivcIntent & ivcModify)))
	// cannot do this:         return m_riDatabase.PostError(Imsg(idbgDbIntentViolation));
	int iModify = iModifyBit(irmAction);

	// check for correct states
	// --> whether joins allowed
	// --> whether require fetch
	// --> whether require 0th field to be stamped with the this pointer
	// --> whether cursor correct state
	if ((iModify & iDisallowJoins) && (m_iTables != 1))
		return m_riDatabase.PostError(Imsg(idbgDbQueryInvalidOperation), irmAction);
	if ((iModify & iRequireFetch) && (m_CursorState != dvcsFetched || m_piRecord == 0 || (m_piRecord != &riRecord &&  m_piInsertUpdateRec != &riRecord)))
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
#ifdef	_WIN64	// !merced
	if ((iModify & iRequireStamp) && (m_piRecord == 0 || (m_piRecord != &riRecord &&  m_piInsertUpdateRec != &riRecord) || (riRecord.GetHandle(0) != (HANDLE)this)))
#else
	if ((iModify & iRequireStamp) && (m_piRecord == 0 || (m_piRecord != &riRecord &&  m_piInsertUpdateRec != &riRecord) || (riRecord.GetInteger(0) != (int)this)))
#endif
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
//	if ((iModify & iCheckCursorState) && m_CursorState == dvcsClosed || m_CursorState == dvcsDestructor)
	//!! need to allow CAs (in office9) to be able to call ::Modify() on a SELECT query w/o
	//!! therefore the need to call Execute() implicitly, ourselves
	if((m_ivcIntent & ivcFetch) && (m_CursorState == dvcsPrepared))
	{
		RETURN_ERROR_RECORD(Execute(0));
	}

	if (m_CursorState != dvcsFetched && m_CursorState != dvcsBound)
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));


	if((iModify & iPrefetchResultSet) && !m_piFetchTable)// need to prefetch the result set, if not already done so
	{
		RETURN_ERROR_RECORD(GetResult());
	}

	// NOTE:  seek sets copy all from record, but also has the PrimaryKeyOnly which prevents complete copy of all
	Bool fCopyAllFromRecord = (iModify & iCopyAll) ? fTrue : fFalse;
	if (iModify & iTransfer)
	{
		if (fCopyAllFromRecord)
		{
			Assert(m_iTables == 1); // all these operations are allowed on 1 table only
			(m_rgTableDefn[1].piCursor)->Reset();
		}
		int iColType = 0;
		for (int iCol = m_iColumns; iCol--;)
		{

			if(fCopyAllFromRecord || riRecord.IsChanged(iCol + 1))
			{
				if(!m_rgColumnDefn[iCol].iTableIndex)
					// not a table column
					continue;			

				// set the cursors
				iColType = ((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->
						  GetColumnType(m_rgColumnDefn[iCol].iColumnIndex));
				
				if ((iModify & iKeysOnly) && ((iColType & icdPrimaryKey) != icdPrimaryKey))
					continue; // only want keys
				
				switch (iColType & icdTypeMask)
				{
				case icdLong:// integer
				case icdShort: //!!needed?
				{
					int iData = riRecord.GetInteger(iCol + 1);
					if(iData != (m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->GetInteger(m_rgColumnDefn[iCol].iColumnIndex))
					{
						if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->PutInteger(m_rgColumnDefn[iCol].iColumnIndex, iData) == fFalse)
							return m_riDatabase.PostError(Imsg(idbgDbUpdateBadType), iCol);
					}
					break;
				}
				case icdObject: 
				{
					// IMsiData interface pointer (temp. columns or persisten streams, database code handles the difference transparantly)
					// temp variable necessary for correct refcnt
					PMsiData piData = riRecord.GetMsiData(iCol + 1);
					if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->PutMsiData(m_rgColumnDefn[iCol].iColumnIndex, piData) != fTrue)
						return m_riDatabase.PostError(Imsg(idbgDbUpdateBadType), iCol);
					break;
				}
				case icdString:// index to database string cache
				{
					// temp variable necessary for correct refcnt
					MsiString strStr = riRecord.GetMsiString(iCol + 1);
					if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piCursor)->PutString(m_rgColumnDefn[iCol].iColumnIndex, *strStr) != fTrue)
						return m_riDatabase.PostError(Imsg(idbgDbUpdateBadType), iCol);
					break;
				}
				}
			}
		}
	}

	if (iModify & ~iValidation)
	{
		for(unsigned int iTable = 1; iTable <= m_iTables; iTable++)
		{
			if (iModify == iModifyBit(irmSeek) && riRecord.GetFieldCount() < m_iColumns)
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData)); //!! need new msg: Record too small

			// call correct fn
			Bool fSuccess = (((CMsiCursor*)(m_rgTableDefn[iTable].piCursor))->*(s_rgAction[(int(irmAction) + 1)]))();			
			if (iModify & iNeedStamp)
			{
				if (iModify == iModifyBit(irmInsertTemporary))
					AssertNonZero(m_riDatabase.LockIfNotPersisted(m_rgTableDefn[iTable].iTable));
				m_piRecord = &riRecord;
				m_piRecord->AddRef(); // we keep a reference so we can reuse it
#ifdef _WIN64	// !merced
				m_piRecord->SetHandle(0, (HANDLE)this); // stamp this record with the this pointer
#else
				m_piRecord->SetInteger(0, (int)this); // stamp this record with the this pointer
#endif
			}
			if (iModify & iFetchRecInfo)
				FetchRecordInfoFromCursors();
			
			if (fSuccess == fFalse)
				return m_riDatabase.PostError(Imsg(idbgDbUpdateFailed));
			if (iModify == iModifyBit(irmDelete))
				m_piRecord = 0; // last record fetched
		}
		return 0;
	}
	else
	{
		// Validation can't occur across joins so iTable always = 1
		Bool fValidate = (iModify == iModifyBit(irmValidate)) ? fTrue : fFalse;
		if (iModify == iModifyBit(irmValidate) || iModify == iModifyBit(irmValidateNew))
		{
			PMsiTable pValidationTable(0);
			IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(sztblValidation), 0, *&pValidationTable);
			if (piError)
				return piError;
			PMsiCursor pValidationCursor(pValidationTable->CreateCursor(fFalse));
			Assert(pValidationCursor);
			int iCol = (fValidate ? 0 : -1);
			piError = (m_rgTableDefn[1].piCursor)->Validate(*pValidationTable, *pValidationCursor, iCol);
			if (piError != 0 && piError->GetInteger(0) == 0)
			{
				piError->Release();
				return m_riDatabase.PostError(Imsg(idbgDbWrongState));
			}
			else if (piError != 0)
			{
				// Validation invalid data record. Error stored in index based on column in view, 
				// not column in underlying table.
				int iNumFields = GetFieldCount();
				bool fError = false;
				for (int i = 1; i <= iNumFields; i++)
				{
					char chError = (char)(piError->GetInteger(m_rgColumnDefn[i-1].iColumnIndex));
					if (chError != 0)
					{
						m_rgchError[i] = chError;
						m_fErrorRefreshed = fFalse;
						fError = true;
					}
				}
				piError->Release();

				// there was an error in the record, but not in any column visible by this view.
				// so return success
				if (!fError)
					return 0;
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData));
			}
			return 0;
		}
		else if (iModify == iModifyBit(irmValidateField))
		{	
			PMsiTable pValidationTable(0);
			IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(sztblValidation), 0, *&pValidationTable);
			if (piError)
				return piError;
			PMsiCursor pValidationCursor(pValidationTable->CreateCursor(fFalse));
			Assert(pValidationCursor);
			int cFields = GetFieldCount();
			for (int i = 0; i < cFields; i++)
			{
				piError = (m_rgTableDefn[1].piCursor)->Validate(*pValidationTable, *pValidationCursor, m_rgColumnDefn[i].iColumnIndex);
				if (piError != 0 && piError->GetInteger(0) == 0)
				{
					piError->Release();
					return m_riDatabase.PostError(Imsg(idbgDbWrongState));
				}
				else if (piError != 0)
				{
					// error stored in index based on column in view, not column in underlying table
					m_fErrorRefreshed = fFalse;
					m_rgchError[i+1] = (char)(piError->GetInteger(m_rgColumnDefn[i].iColumnIndex));
					piError->Release();
				}
			}
			if (!m_fErrorRefreshed)
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData));
			return 0;
		}
		else // irmValidateDelete
		{
			PMsiTable pValidationTable(0);
			IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(sztblValidation), 0, *&pValidationTable);
			if (piError)
				return piError;
			PMsiCursor pValidationCursor(pValidationTable->CreateCursor(fFalse));
			Assert(pValidationCursor);
			piError = (m_rgTableDefn[1].piCursor)->Validate(*pValidationTable, *pValidationCursor, -2 /*Validate preDelete*/);
			if (piError != 0 && piError->GetInteger(0) == 0)
			{
				piError->Release();
				return m_riDatabase.PostError(Imsg(idbgDbWrongState));
			}
			else if (piError != 0)
			{
				// Validation invalid data record. Error stored in index based on column in view, 
				// not column in underlying table.
				int iNumFields = GetFieldCount();
				bool fError = false;
				for (int i = 1; i <= iNumFields; i++)
				{
					char chError = (char)(piError->GetInteger(m_rgColumnDefn[i-1].iColumnIndex));
					if (chError != 0)
					{
						m_rgchError[i] = chError;
						m_fErrorRefreshed = fFalse;
						fError = true;
					}
				}
				piError->Release();

				// there was an error in the record, but not in any column visible by this view.
				// so return success
				if (!fError)
					return 0;
				return m_riDatabase.PostError(Imsg(idbgDbInvalidData));
			}
			return 0;
		}
	}
}

iveEnum __stdcall CMsiView::GetError(const IMsiString*& rpiColumnName)
{
	rpiColumnName = &CreateString();
	int cViewColumns = GetFieldCount();
	int iCol = m_iFirstErrorIndex - 1;
	for (int i = m_iFirstErrorIndex; i <= cViewColumns; i++, iCol++)
	{
		if (m_rgchError[i] != 0 && m_rgColumnDefn[iCol].iTableIndex) // for fully specified columns
		{
			MsiString strCol = m_riDatabase.DecodeString((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->GetColumnName(m_rgColumnDefn[iCol].iColumnIndex));
			rpiColumnName->SetString((const ICHAR*)strCol, rpiColumnName);
			m_iFirstErrorIndex = i + 1; // Update for next call of method
			return (iveEnum)m_rgchError[i];
		}
		else if (m_rgchError[i] != 0 && m_rgColumnDefn[iCol].iTableIndex == 0) // not fully specified column
		{
			rpiColumnName->SetString(TEXT("Unspecified Column"), rpiColumnName);
			m_iFirstErrorIndex = i + 1; // Update for next call of metod
			return (iveEnum)m_rgchError[i];
		}
	}
	m_iFirstErrorIndex = 1; // Reset
	return iveNoError;
}

HRESULT CMsiView::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiView))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiView::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiView::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	PMsiServices piServices (&m_riServices); // release after delete
	PMsiDatabase pDatabase (&m_riDatabase); // release after delete
	delete this;
	return 0;
}


IMsiRecord* CMsiView::OpenView(const ICHAR* szSQL, ivcEnum ivcIntent)
{
	m_ivcIntent = ivcIntent;
	// create the table for managing bindstring
	if ((m_piBindTable = new CMsiTable(m_riDatabase, 0, 0, 0))==0) // temporary, not a catalog table
		return m_riDatabase.PostError(Imsg(idbgDbTableCreate), szInternal);
	MsiString strNull;

	if(m_piBindTable->CreateColumn(icdString + icdPrimaryKey + icdNullable, *strNull) != 1)
		return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
		
	AssertNonZero(m_piBindTableCursor = m_piBindTable->CreateCursor(fFalse));

	RETURN_ERROR_RECORD(CheckSQL(szSQL));

	// check if any of the o/p tables are read only
	#if 0 //!! JD commented out test, we must be able to update non-persistent rows & columns! Maybe we don't want the intent?
	//!! JD the cursor functions will error if attempting to write persistent data on a read-only table
	if(m_ivcIntent & ivcModify)
	{
		for (unsigned int iCol = m_iColumns; iCol--;)
			if(m_rgColumnDefn[iCol].iTableIndex)
				if((m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].piTable)->IsReadOnly() == fTrue)
				{
					MsiString riTable = m_riDatabase.DecodeString(m_rgTableDefn[m_rgColumnDefn[iCol].iTableIndex].iTable);
					return m_riDatabase.PostError(Imsg(idbgDbTableReadOnly),(const IMsiString& )riTable);
				}
	}
	#endif //!! JD commented out
	m_CursorState = dvcsPrepared;
	return 0;
}

// function to prefetch the result set
IMsiRecord* CMsiView::GetResult()
{
	if(m_piFetchTable)
		return 0;; // already fetched

	MsiString strNull;
	// create a table for the result, maybe in the order of the sort (m_iSortColumns will be 0 otherwise) + index (to prevent reordering of the rows in case of deletion/insertion
	if ((m_piFetchTable = new CMsiTable(m_riDatabase, 0, 0, 0))==0) // temporary, not a catalog table
		return m_riDatabase.PostError(Imsg(idbgDbTableCreate), szInternal);
	for(unsigned int iTmp = m_iSortColumns; iTmp--;)
	{
		if(!m_piFetchTable->CreateColumn(icdLong + icdPrimaryKey + icdNullable, *strNull))
			return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
	}


	if(!m_piFetchTable->CreateColumn(icdLong + icdPrimaryKey + icdNullable, *strNull))
		return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);

	for(iTmp = m_iTables; iTmp--;)
	{
		if(!m_piFetchTable->CreateColumn(icdLong + icdNullable, *strNull))
			return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
	}


	//!! need to check return
	AssertNonZero(m_piFetchCursor = m_piFetchTable->CreateCursor(fFalse));
	// fill in the table
	Bool fRetCode;
	if(m_CursorState == dvcsFetched)
	{
		// already fetched part of the result set fetch the remaining part

		// get the existing fetch into the table, so that we can maintain
		// the existing cursor states after all the fetches
		SetNextFetchRecord();
		while(FetchNext())
		{
			// put the values into the table
			if((FitCriteriaORExpr(m_iTreeParent) != fFalse) && (IsDistinct() != fFalse))
				SetNextFetchRecord();
		}
		m_piFetchCursor->Reset();
		GetNextFetchRecord();
		// current m_lRowCount count denotes rows already fetched
		m_lRowCount += m_piFetchTable->GetRowCount() - 1; // subtract 1 since we existing row in table as well
	}
	else
	{
		fRetCode = EvaluateConstExpressions();
		if(fRetCode == fTrue)
		{
			fRetCode = FetchFirst();
			while(fRetCode == fTrue)
			{
				// put the values into the table
				if((FitCriteriaORExpr(m_iTreeParent) != fFalse) && (IsDistinct() != fFalse))
					SetNextFetchRecord();
				fRetCode = FetchNext();
			}
		}
		m_piFetchCursor->Reset();
		m_lRowCount += m_piFetchTable->GetRowCount();
	}
	return 0;
}

// function to bind parameters in the SQL string
// also used to preprocess and execute query if an
// external sort required
IMsiRecord* __stdcall CMsiView::Execute(IMsiRecord* piParams)
{
	// we implicitly close the view if we can
	if (m_CursorState == dvcsBound || m_CursorState == dvcsFetched)
	{
		RETURN_ERROR_RECORD(Close());
	}
	else if (m_CursorState != dvcsPrepared)
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));

	// check that the number of parameters matches the record field count
	if (m_iParams && (!piParams || piParams->GetFieldCount() < m_iParams))
			return m_riDatabase.PostError(Imsg(idbgDbParamCount));
	// bind the insert/update values	
	unsigned int iTmp1 = m_iParamInputs;
	unsigned int iTmp2 = 1;
	unsigned int iTmp3 = 1;
	while(iTmp1)
	{
		Assert(m_piInsertUpdateRec);
		if(iTmp1 & 0x1)
		{

			if(piParams->IsInteger(iTmp3))
				m_piInsertUpdateRec->SetInteger(iTmp2, piParams->GetInteger(iTmp3));
			else
				m_piInsertUpdateRec->SetMsiData(iTmp2, PMsiData(piParams->GetMsiData(iTmp3)));
			iTmp3 ++;
		}
		iTmp2 ++;
		iTmp1 = iTmp1 >> 1;
	}
	// bind o/p parameters
	iTmp1 = m_iParamOutputs;
	iTmp2 = 0;
	while(iTmp1)
	{
		Assert(m_piInsertUpdateRec == 0);
		if(iTmp1 & 0x1)
		{

			if(piParams->IsInteger(iTmp3))
			{
				m_rgColumnDefn[iTmp2].iColumnIndex = piParams->GetInteger(iTmp3);
				m_rgColumnDefn[iTmp2].itdType = icdLong;
			}
			else
			{
				MsiString aString = piParams->GetMsiString(iTmp3);
				m_rgColumnDefn[iTmp2].iColumnIndex = BindString(aString);
				m_rgColumnDefn[iTmp2].itdType = icdString;
			}
			iTmp3 ++;
		}
		iTmp2 ++;
		iTmp1 = iTmp1 >> 1;
	}
	// bind statement parameters
	iTmp1 = m_iParamExpressions;
	iTmp2 = 1;
	while(iTmp1)
	{
		if(iTmp1 & 0x1)
		{
			switch(m_rgExpressionDefn[iTmp2].itdType)
			{
			case icdLong:
			case icdShort: //!!needed?
				if(piParams->IsNull(iTmp3))
					m_rgExpressionDefn[iTmp2].iColumn2 = (unsigned int)iMsiNullInteger;
				else if (piParams->IsInteger(iTmp3))
					m_rgExpressionDefn[iTmp2].iColumn2 = piParams->GetInteger(iTmp3);
				else
					return m_riDatabase.PostError(Imsg(idbgParamMismatch), iTmp3);
				break;
			case icdString:
			{
				MsiString aString = piParams->GetMsiString(iTmp3);
				m_rgExpressionDefn[iTmp2].iColumn2 = BindString(aString);
				break;
			}
			default:
				return m_riDatabase.PostError(Imsg(idbgParamMismatch), iTmp3);
			}
			iTmp3 ++;
		}
		iTmp2 ++;
		iTmp1 = iTmp1 >> 1;
	}
	// reset all the cursors
	if((m_ivcIntent != ivcCreate) && (m_ivcIntent != ivcAlter))
	for(iTmp1 = m_iTables + 1; --iTmp1 != 0;)
		(m_rgTableDefn[iTmp1].piCursor)->Reset();
	m_CursorState = dvcsExecuted;
	if (m_ivcIntent == ivcNoData)
		return Close();    // all done, force close
	m_CursorState = dvcsBound;
	// need to set up distinct table, if required
	if(m_fDistinct != fFalse)
	{
		if ((m_piDistinctTable = new CMsiTable(m_riDatabase, 0, 0, 0))==0) // temporary, not a catalog table
			return m_riDatabase.PostError(Imsg(idbgDbTableCreate), szInternal);
		for (unsigned int iCol = 1; iCol <= m_iColumns; iCol++)
		{
			if(m_piDistinctTable->CreateColumn(icdPrimaryKey | icdLong | icdNullable, *MsiString(*TEXT(""))) != iCol)
				return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), szInternal, szInternal);
		}
	}
	// need to execute if sorting required or if we intend to modify the result set
	if((m_iSortColumns) || (m_ivcIntent & ivcModify))
		RETURN_ERROR_RECORD(GetResult());
	switch(m_ivcIntent)
	{
	case ivcDelete:
	{
		PMsiRecord piRecord(0);
		while((piRecord = _Fetch()) != 0)
		{
			RETURN_ERROR_RECORD(Modify(*piRecord, irmDelete));
		}
		return Close();
	}
	case ivcUpdate:
	{
		PMsiRecord piRecord(0);
		while((piRecord = _Fetch()) != 0)
		{
			Assert(m_piInsertUpdateRec != 0);

			for (int iCol = 1; iCol <= m_iColumns; iCol++)
			{
				if(m_piInsertUpdateRec->IsNull(iCol))
					piRecord->SetNull(iCol);
				else
				{
					if(m_piInsertUpdateRec->IsInteger(iCol))
						piRecord->SetInteger(iCol, m_piInsertUpdateRec->GetInteger(iCol));
					else
						piRecord->SetMsiData(iCol, PMsiData(m_piInsertUpdateRec->GetMsiData(iCol)));
				}
			}
			RETURN_ERROR_RECORD(Modify(*piRecord, irmUpdate));
		}
		return Close();
	}
	case ivcInsert:
	{
		Assert(m_piInsertUpdateRec != 0);
		RETURN_ERROR_RECORD(Modify(*m_piInsertUpdateRec, irmInsert));
		return Close();
	}
	case ivcInsertTemporary:
	{
		Assert(m_piInsertUpdateRec != 0);
		RETURN_ERROR_RECORD(Modify(*m_piInsertUpdateRec, irmInsertTemporary));
		return Close();
	}
	case ivcCreate:
	{
		RETURN_ERROR_RECORD(m_riDatabase.CreateTable(*MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable)), 0, *&m_rgTableDefn[m_iTables].piTable));
		// and fall through
	}
	case ivcAlter:
	{
		for (unsigned int iCol = 0; iCol < m_iColumns; iCol++)
		{
			MsiString strColumn = m_riDatabase.DecodeString(m_rgColumnDefn[iCol].iColumnIndex);
			if(!m_rgTableDefn[m_iTables].piTable->CreateColumn(m_rgColumnDefn[iCol].itdType, *strColumn))
				return m_riDatabase.PostError(Imsg(idbgDbColumnCreate), strColumn, (const ICHAR*)MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable)));
		}
		if(m_fLock != -1) // we need to lock/unlock the table
			m_riDatabase.LockTable(*MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable)), (Bool)m_fLock);
		return Close();
	}
	case ivcDrop:
	{
		RETURN_ERROR_RECORD(m_riDatabase.DropTable(MsiString(m_riDatabase.DecodeString(m_rgTableDefn[m_iTables].iTable))));
		return Close();
	}
	default:
		// ivcFetch is set, SELECT stmt
		break;
	}
	return 0;
}

// function to get the size of the result set
IMsiRecord* __stdcall CMsiView::GetRowCount(long& lRowCount)
{
	if (m_CursorState != dvcsFetched && m_CursorState != dvcsBound)
		return m_riDatabase.PostError(Imsg(idbgDbWrongState));
	if(!m_piFetchTable)
	{
		// rows have not been pre-fetched
		RETURN_ERROR_RECORD(GetResult());
	}
	lRowCount = m_lRowCount;
	return 0;
}

// local factory for IMsiView
IMsiRecord* CreateMsiView(CMsiDatabase& riDatabase, IMsiServices& riServices, const ICHAR* szQuery, ivcEnum ivcIntent,IMsiView*& rpiView)
{
	CMsiView* piView = new CMsiView(riDatabase, riServices);
	IMsiRecord* piError = piView->OpenView(szQuery, ivcIntent);
	if(piError)
	{
		// delete the object, 
		// the convention is to keep "rpiView" untouched
		// if error
		piView->Release();
	}
	else
		rpiView = piView;
	return piError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\engine\coreactn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       coreactn.cpp
//
//--------------------------------------------------------------------------

/* coreactn.cpp - core install actions
____________________________________________________________________________*/
#include "precomp.h" 
#include "_engine.h"
#include "path.h"
#include "_assert.h"
#include "_msinst.h"
#include "_msiutil.h"
#include "_srcmgmt.h"
#include "tables.h"

#ifdef MAC
#include "macutil.h"
#endif

# include "shlobj.h" // shell folder locations

//!! ugly hopefully temp code for feature publish
enum pfiStates{
	pfiRemove,// feature not known
	pfiAbsent,// feature known but absent
	pfiAvailable,// feature known and available
};
//____________________________________________________________________________
//
// General utility functions
//____________________________________________________________________________

MsiDate GetCurrentDateTime()
{
	unsigned short usDOSDate = 0x21, usDOSTime = 0;
	FILETIME ft;
	SYSTEMTIME st;
	::GetLocalTime(&st);
	::SystemTimeToFileTime(&st, &ft);
	::FileTimeToDosDateTime(&ft, &usDOSDate, &usDOSTime);
	return (MsiDate)((usDOSDate << 16) | usDOSTime);
}


// function that checks if we have only one feature in the product AND/ OR if we have only one component in the feature
int GetDarwinDescriptorOptimizationFlag(IMsiEngine& riEngine, const IMsiString& ristrFeature)
{
	int iOptimization = 0;// no optimization by default

	PMsiSelectionManager pSelectionManager(riEngine,IID_IMsiSelectionManager);
	PMsiTable pFeatureTable = pSelectionManager->GetFeatureTable();
	Assert(pFeatureTable);
	Assert(pFeatureTable->GetRowCount());
	if(pFeatureTable->GetRowCount() == 1)
	{
		// we have 1 feature
		iOptimization |= ofSingleFeature;
	}

	PMsiTable pFeatureComponentsTable = pSelectionManager->GetFeatureComponentsTable();
	Assert(pFeatureComponentsTable);
	PMsiCursor pFeatureComponentsCursor(pFeatureComponentsTable->CreateCursor(fFalse));
	pFeatureComponentsCursor->SetFilter(1); // on the Feature column
	pFeatureComponentsCursor->PutString(1, ristrFeature);
	AssertNonZero(pFeatureComponentsCursor->Next()); // we must have atleast 1 component
	if(!pFeatureComponentsCursor->Next())
	{
		// we have 1 component to that feature
		iOptimization |= ofSingleComponent;
	}
	return iOptimization;
}		

// function that gets the component string as possibly a multi_sz with optimizer bits as a string appended to
const IMsiString& GetComponentWithDarwinDescriptorOptimizationFlag(IMsiEngine& riEngine, const IMsiString& ristrFeature, const IMsiString&  ristrComponentId)
{
	MsiString strComponentId;
	ristrComponentId.AddRef();
	strComponentId = ristrComponentId; // default
	int iOptimization = GetDarwinDescriptorOptimizationFlag(riEngine, ristrFeature);
	if(iOptimization)
	{
		strComponentId = strComponentId + MsiString(MsiChar(0));
		strComponentId = strComponentId + MsiString(iOptimization);
	}
	return strComponentId.Return();

}

Bool GetClientInformation(IMsiServices& riServices, const ICHAR* szProduct, const ICHAR* szClient, const IMsiString*& rpiRelativePackagePath, const IMsiString*& rpiDiskId)
{
	MsiString strClients;
	AssertRecord(GetProductClients(riServices, szProduct, *&strClients));
	while (strClients.TextSize())
	{
		if(*(const ICHAR*)strClients)
		{
			MsiString strProduct = strClients.Extract(iseUpto, ';');

			if(strProduct.Compare(iscExactI, szClient))
			{
				strClients.Remove(iseIncluding, ';');
				strProduct = strClients.Extract(iseUpto, ';');
				strProduct.ReturnArg(rpiRelativePackagePath);
				strClients.Remove(iseIncluding, ';');
				strClients.ReturnArg(rpiDiskId);
				return fTrue;
			}
		}
		if (!strClients.Remove(iseIncluding, '\0'))
			break;
	}

	return fFalse;
}

Bool ProductHasBeenPublished(IMsiServices& riServices, const ICHAR* szProduct, const ICHAR* szClient = 0)
{
	ICHAR rgchBuf[2];
	DWORD cchBuf = sizeof(rgchBuf)/sizeof(ICHAR);
	int iRet = MSI::MsiGetProductInfo(szProduct, INSTALLPROPERTY_PRODUCTNAME, rgchBuf, &cchBuf);
	if (iRet == ERROR_UNKNOWN_PRODUCT)
		return fFalse;
	else if ((iRet == ERROR_SUCCESS) && (rgchBuf[0] == 0))
		return fFalse;
	else if(!szClient)
		return fTrue;

	// are we already registered as a client of the product
	MsiString strClients;
	if(!szClient[0]) // parent install
		szClient = szSelfClientToken;

	MsiString strDummy1, strDummy2;
	return GetClientInformation(riServices, szProduct, szClient, *&strDummy1, *&strDummy2);
}

//____________________________________________________________________________
//
// Top level actions, generally invoke MsiEngine::Sequence
//
//    Calling DoAction(0) uses the upper-cased value of the ACTION property
//    Therefore, only upper-case action names are accessible via command line
//____________________________________________________________________________

iesEnum RunUIOrExecuteSequence(IMsiEngine& riEngine, const ICHAR* szAction, 
												const ICHAR* szUISequence, const ICHAR* szExecuteSequence)
{
	iesEnum iesRet;
	INSTALLUILEVEL iui = (INSTALLUILEVEL)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_UILEVEL));

	if ((riEngine.GetMode() & iefSecondSequence) ||
		 (g_scServerContext != scClient))
	{
		DEBUGMSG("Running ExecuteSequence");
		iesRet = riEngine.Sequence(szExecuteSequence);
	}
	else 
	{
		// Determine whether we have a non-empty UI sequence table
		bool fPopulatedUISequence = false;
		PMsiDatabase pDatabase = riEngine.GetDatabase();
		PMsiTable pUISequenceTable(0);
		PMsiRecord pError = pDatabase->LoadTable(*MsiString(szUISequence), 0, *&pUISequenceTable);
		if (pError == 0)
		{
			if (pUISequenceTable->GetRowCount())
				fPopulatedUISequence = true;
		}
		else
			Assert(pError->GetInteger(1) == idbgDbTableUndefined);

		DEBUGMSG2(TEXT("UI Sequence table '%s' is %s."), szUISequence, fPopulatedUISequence ? TEXT("present and populated") : TEXT("missing or empty"));


		if(g_scServerContext == scClient && (iui == INSTALLUILEVEL_NONE || iui == INSTALLUILEVEL_BASIC || !fPopulatedUISequence))
		{
			if (g_fWin9X)
			{
				DEBUGMSG("Running ExecuteSequence from client");
				iesRet = riEngine.RunExecutionPhase(szExecuteSequence, true);
			}
			else
			{
				DEBUGMSG("In client but switching to server to run ExecuteSequence");
				iesRet = riEngine.RunExecutionPhase(szAction,false);
			}
		}
		else
		{
			DEBUGMSG("Running UISequence");
			AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_EXECUTEACTION), *MsiString(szAction)));
			Assert(iui == INSTALLUILEVEL_REDUCED || iui == INSTALLUILEVEL_FULL);
			Assert(g_scServerContext == scClient);
			iesRet = riEngine.Sequence(szUISequence);
		}
	}
	return iesRet;
}

/*---------------------------------------------------------------------------
	Install action
---------------------------------------------------------------------------*/

iesEnum Install(IMsiEngine& riEngine)
{
	return RunUIOrExecuteSequence(riEngine, IACTIONNAME_INSTALL, TEXT("InstallUISequence"), TEXT("InstallExecuteSequence"));
}


/*---------------------------------------------------------------------------
	Admin action
---------------------------------------------------------------------------*/

iesEnum Admin(IMsiEngine& riEngine)
{
	if((!riEngine.GetMode() & iefAdmin))
	{
		AssertSz(0,"Admin action called when iefAdmin mode bit not set");
		return iesNoAction;
	}

	return RunUIOrExecuteSequence(riEngine, IACTIONNAME_ADMIN, TEXT("AdminUISequence"), TEXT("AdminExecuteSequence"));
}

/*---------------------------------------------------------------------------
	Advertise action
---------------------------------------------------------------------------*/

iesEnum Advertise(IMsiEngine& riEngine)
{
	if(!(riEngine.GetMode() & iefAdvertise))
	{
		AssertSz(0,"Advertise action called when iefAdvertise mode bit not set");
		return iesNoAction;
	}
	return RunUIOrExecuteSequence(riEngine, IACTIONNAME_ADVERTISE, TEXT("AdvtUISequence"), TEXT("AdvtExecuteSequence"));
}

/*---------------------------------------------------------------------------
	Sequence action
---------------------------------------------------------------------------*/

iesEnum Sequence(IMsiEngine& riEngine)
{
	MsiString istrTable = riEngine.GetPropertyFromSz(IPROPNAME_SEQUENCE);
	if (istrTable.TextSize() == 0)
		return iesNoAction;
	return riEngine.Sequence(istrTable);
}

/*---------------------------------------------------------------------------
	Execute action
---------------------------------------------------------------------------*/
iesEnum ExecuteAction(IMsiEngine& riEngine)
{
	// drop fusion and mscoree, if loaded from client side
	// this will allow us to possibly replace/delete file in system32, in service
	FUSION::Unbind();
	MSCOREE::Unbind();

	// set iefSecondSequence in case execute sequence is run in THIS engine
	// set SECONDSEQUENCE property to communicate to server engine
	riEngine.SetMode(iefSecondSequence, fTrue); //?? Do we have to worry about nested Execute action calls here?
	AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_SECONDSEQUENCE),*MsiString(TEXT("1"))));

	MsiString strExecuteAction = riEngine.GetPropertyFromSz(IPROPNAME_EXECUTEACTION);
	iesEnum iesRet = riEngine.RunExecutionPhase(strExecuteAction,false);
	
	// reset second sequence indicators
	riEngine.SetMode(iefSecondSequence, fFalse);
	AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_SECONDSEQUENCE),g_MsiStringNull));
	return iesRet;
}

//____________________________________________________________________________
//
// Standard actions, generally called from MsiEngine::Sequence
//____________________________________________________________________________

/*---------------------------------------------------------------------------
	LaunchConditions action
---------------------------------------------------------------------------*/
static const ICHAR sqlLaunchCondition[] =
TEXT("SELECT `Condition`, `Description` FROM `LaunchCondition`");

iesEnum LaunchConditions(IMsiEngine& riEngine)
{
	enum lfnEnum
	{
		lfnCondition = 1,
		lfnDescription,
		lfnNextEnum
	};

	PMsiServices pServices(riEngine.GetServices());

	PMsiView View(0);
	PMsiRecord pRecErr(riEngine.OpenView(sqlLaunchCondition, ivcFetch, *&View));
	if (!pRecErr)
	{
		pRecErr = View->Execute(0);
		if (!pRecErr)
		{
			for(;;)
			{
				PMsiRecord Record(View->Fetch());
				if (!Record)
					break;
				Assert(Record->GetFieldCount() >= lfnNextEnum-1);
				iecEnum iec = riEngine.EvaluateCondition(Record->GetString(lfnCondition));
				if (iec == iecFalse)
				{
					pRecErr = &CreateRecord(2);
					AssertNonZero(pRecErr->SetMsiString(0, *MsiString(Record->GetMsiString(lfnDescription))));
					pRecErr->SetInteger(1, 0);
					riEngine.Message(imtEnum(imtError|imtSendToEventLog), *pRecErr);
					return iesFailure;

				}
				// We ignore iecError or iecNone - bad conditional statements are caught by validation
			}
		}
		else
			return riEngine.FatalError(*pRecErr);
	}
	else if(pRecErr->GetInteger(1) == idbgDbQueryUnknownTable)
		return iesNoAction;
	else
		return riEngine.FatalError(*pRecErr);

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	CostInitialize action
---------------------------------------------------------------------------*/
const ICHAR szFileTable[]             = TEXT("File");
const ICHAR szColFileState[]          = TEXT("State");
const ICHAR szColTempFileAttributes[] = TEXT("TempAttributes");

iesEnum CostInitialize(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping CostInitialize: action already run in this engine.");
		return iesNoAction;
	}

	PMsiRecord pError(0);
	PMsiServices pServices = riEngine.GetServices();
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	Assert(pDirectoryMgr != 0 && pSelectionMgr != 0);

	
	// Initialize DirectoryManager
	// ----------------------------

	// insure that ROOTDRIVE property exists
	MsiString istrRootDrive(riEngine.GetPropertyFromSz(IPROPNAME_ROOTDRIVE));
	PMsiPath pRootDrive(0);
	if (!istrRootDrive.TextSize())
	{
		PMsiVolume pVolume(0);
		Bool fWritable;
		for(int i = (riEngine.GetMode() & iefAdmin) ? 0 : 1;i<3;i++)
		{
			idtEnum idtType;
			if(i==0)
				idtType = idtRemote;
			else if(i==1)
				idtType = idtFixed;
			else
				idtType = idtRemovable;

			PEnumMsiVolume pVolEnum = &pServices->EnumDriveType(idtType);
			for (int iMax = 0; pVolEnum->Next(1, &pVolume, 0)==S_OK; )
			{
				// check if volume is writable
				PMsiPath pPath(0);
				AssertRecord(pServices->CreatePath(MsiString(pVolume->GetPath()),*&pPath));

				// test writability by creating a folder at the root of the drive
				// NOTE: we used to test writability by creating a file, but some drives may be acl'ed to allow
				// folder creation but not file creation.  Folder creation is good enough for us.
				if(pPath)
				{
					MsiString strFolderName;
					pError = pPath->CreateTempFolder(TEXT("MSI"), 0, fTrue, 0, *&strFolderName);

					// if we created the folder, try to remove it.  if we can't remove, consider the folder to be
					// unwritable
					if(pError == 0 && strFolderName.TextSize())
					{
						AssertRecord(pPath->AppendPiece(*strFolderName));
						pError = pPath->Remove(0);
						AssertRecord(pPath->ChopPiece());
						if(pError == 0)
						{
							int iSize;
							if(idtType == idtRemote)
							{
								pRootDrive = pPath;
								break; // pick first writable remote drive found
							}
							else if ((iSize = pVolume->FreeSpace()) > iMax)
							{
								pRootDrive = pPath;
								iMax = iSize;
							}
						}
					}
				}
			}
			if(pRootDrive)
				break;
		}
		if(pRootDrive == 0)
		{
			// set to drive containing windows folder
			if((pError = pServices->CreatePath(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_WINDOWS_VOLUME)), *&pRootDrive)) != 0)
				return riEngine.FatalError(*pError);
		}

		// Bug 6911 - changed from GetFullUNCFilePath to avoid problems with 3rd-party networks (PCNFS) that
		// can't handle UNC paths.  (Even for LANMAN paths, we didn't really want to be converting from 
		// drive letter to UNC).  Note that this is an issue only for Admin installs, since that's the
		// only time ROOTDRIVE defaults to a network volume.
		if((pError = pRootDrive->GetFullFilePath(0,*&istrRootDrive)) != 0)
			return riEngine.FatalError(*pError);

		riEngine.SetProperty(*MsiString(*IPROPNAME_ROOTDRIVE), *istrRootDrive);
	}
	else
	{
		if((pError = pServices->CreatePath(istrRootDrive, *&pRootDrive)) != 0)
			return riEngine.FatalError(*pError);
		istrRootDrive = pRootDrive->GetPath();
		riEngine.SetProperty(*MsiString(*IPROPNAME_ROOTDRIVE), *istrRootDrive);
	}

	if ((pError = pDirectoryMgr->LoadDirectoryTable(0)))
		return riEngine.FatalError(*pError);

	// resolve only source sub-paths.  full source paths aren't resolved
	// until someone calls GetSourcePath (at which point the user may be
	// prompted for the source)
	if ((pError = pDirectoryMgr->ResolveSourceSubPaths()))
	{
		if (pError->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pError);
	}

	// Initialize Selection Manager
	// -----------------------------
	if ((pError = pSelectionMgr->LoadSelectionTables()))
	{
		// OK if Feature or Component tables not present
		if (pError->GetInteger(1) != idbgDbTableUndefined)
			return riEngine.FatalError(*pError);
	}

	// Add the "State" column to the file table (if it exists), so we can
	// record the results of costing (e.g. version checking) for each file.
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	IMsiTable* piFileTable;
	pError = pDatabase->LoadTable(*MsiString(*szFileTable), 1, piFileTable);
	if (pError)
	{
		if (pError->GetInteger(1) != idbgDbTableUndefined)
			return riEngine.FatalError(*pError);
	}
	else
	{
		int colFileState = piFileTable->CreateColumn(icdLong + icdNullable, *MsiString(*szColFileState));
		int colTempFileAttributes = piFileTable->CreateColumn(icdLong + icdNullable, *MsiString(*szColTempFileAttributes));
		AssertNonZero(colFileState && colTempFileAttributes);
		AssertNonZero(pDatabase->LockTable(*MsiString(*szFileTable),fTrue));
		piFileTable->Release();
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	return iesSuccess;
}



/*---------------------------------------------------------------------------
	CostFinalize action
---------------------------------------------------------------------------*/
iesEnum CostFinalize(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping CostFinalize: action already run in this engine.");
		return iesNoAction;
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	Bool fAdmin = riEngine.GetMode() & iefAdmin ? fTrue : fFalse;
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(pDirectoryMgr != 0 && pSelectionMgr != 0);

	PMsiRecord pErrRec(0);
	Bool fSelectionManagerActive = fTrue;
	if ((pErrRec = pSelectionMgr->InitializeComponents()))
	{
		int iError = pErrRec->GetInteger(1);
		if (iError == idbgSelMgrNotInitialized)
			fSelectionManagerActive = fFalse;
		else if (iError == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pErrRec);
	}

	// Finish initialization of Directory Manager
	// ------------------------------------------
	if ((pErrRec = pDirectoryMgr->CreateTargetPaths()))
	{
		if (pErrRec->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pErrRec);
	}

	// Finish initialization of Selection Manager
	// ------------------------------------------
	if (fSelectionManagerActive)
	{
		// Used to call ProcessConditionTable here - now it is called
		// internally by InitializeComponents

		if(fAdmin)
		{
			if((pErrRec = pSelectionMgr->SetAllFeaturesLocal()))
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}
		}
		else
		{
			if ((pErrRec = pSelectionMgr->SetInstallLevel(0)))
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}
		}
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	return iesSuccess;
}


/*---------------------------------------------------------------------------
	ScheduleReboot action - sets the mode bit to indicate reboot at the end
---------------------------------------------------------------------------*/

iesEnum ScheduleReboot(IMsiEngine& riEngine)
{
	riEngine.SetMode(iefReboot, fTrue);
	return iesSuccess;
}


/*---------------------------------------------------------------------------
	ForceReboot action - sets the mode bits and the regkey to force reboot right away
---------------------------------------------------------------------------*/

iesEnum ForceReboot(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiRecord pRecErr(0);

	MsiString strProduct;          // package path or product code
	MsiString strRunOnceValueName; // packed product code or package name - must be < 32 chars (minus "!" prefix)
	
	MsiString strProductKey = riEngine.GetProductKey();
	
	if(strProductKey.TextSize())
	{
		// set strProduct
		if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PRODUCTTOBEREGISTERED)).TextSize())
		{
			// product is or will be registered when we reboot
			// use product code on RunOnce command line
			strProduct = strProductKey;
		}

		// set strRunOnceValueName
		strRunOnceValueName = MsiString(GetPackedGUID(strProductKey)).Extract(iseFirst,30);
	}

	if(strProduct.TextSize() == 0 || strRunOnceValueName.TextSize() == 0)
	{
		// product will not be registered when we reboot
		// use package path on RunOnce command line
		MsiString strDbFullFilePath = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
		if(PathType(strDbFullFilePath) != iptFull)
		{
			pRecErr = PostError(Imsg(idbgPropValueNotFullPath),*MsiString(*IPROPNAME_ORIGINALDATABASE),*strDbFullFilePath);
			return riEngine.FatalError(*pRecErr);
		}
		PMsiPath pDbPath(0);
		MsiString strDbName(0);
		pRecErr = pServices->CreateFilePath(strDbFullFilePath,*&pDbPath,*&strDbName);
		if(pRecErr)
			return riEngine.FatalError(*pRecErr);
		
		if(strProduct.TextSize() == 0)
		{
			// use UNC path to package
			pRecErr = pDbPath->GetFullUNCFilePath(strDbName,*&strProduct);
			if(pRecErr)
				return riEngine.FatalError(*pRecErr);
		}

		if(strRunOnceValueName.TextSize() == 0)
			strRunOnceValueName = strDbName.Extract(iseFirst,30);
	}

	Assert(strProduct.TextSize());
	Assert(strRunOnceValueName.TextSize());

	// pre-pend value name with "!" on Whistler
	// this is necessary for the Shell to run the RunOnce command as a non-admin
	if(MinimumPlatformWindowsNT51())
	{
		MsiString strTemp = strRunOnceValueName;
		strRunOnceValueName = TEXT("!");
		strRunOnceValueName += strTemp;
	}

	MsiString strTransforms         = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMS));
	MsiString strTransformsAtSource = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE));
	MsiString strTransformsSecure   = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMSSECURE));
	
	//!! all of these +='s are horribly inefficient - should do something else
	MsiString strCommandLine = TEXT("/");
	strCommandLine += MsiChar(INSTALL_PACKAGE_OPTION);
	strCommandLine += TEXT(" \"");
	strCommandLine += strProduct;
	strCommandLine += TEXT("\" ") IPROPNAME_AFTERREBOOT TEXT("=1 ") IPROPNAME_RUNONCEENTRY TEXT("=\"");
	strCommandLine += strRunOnceValueName;
	strCommandLine += TEXT("\" /");
	strCommandLine += MsiChar(QUIET_OPTION);
	
	ICHAR chUILevel = 0;
	iuiEnum iui;

	if (g_scServerContext == scClient)
		iui = g_MessageContext.GetUILevel();
	else
		iui = (iuiEnum)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_CLIENTUILEVEL)); 
	
	switch (iui)
	{
		case iuiNone:     chUILevel = 'N';   break;
		case iuiBasic:    chUILevel = 'B';   break;
		case iuiReduced:  chUILevel = 'R';   break;
		default:          // fall through
		case iuiFull:     chUILevel = 'F';   break;
	}

	strCommandLine += MsiChar(chUILevel);
	strCommandLine += TEXT(" ");

	if(strTransforms.TextSize())
	{
		strCommandLine += IPROPNAME_TRANSFORMS TEXT("=\"");
		strCommandLine += strTransforms;
		strCommandLine += TEXT("\" ");
	}
	if(strTransformsAtSource.TextSize())
	{
		strCommandLine += IPROPNAME_TRANSFORMSATSOURCE TEXT("=1 ");
	}
	
	if (strTransformsSecure.TextSize())
	{
		strCommandLine += IPROPNAME_TRANSFORMSSECURE TEXT("=1 ");
	}

	const ICHAR* szLogFile = 0;
	DWORD dwLogMode = 0;
	bool fFlushEachLine = false;
	if(g_szLogFile && *g_szLogFile)
	{
		// client side
		szLogFile = g_szLogFile;
		dwLogMode = g_dwLogMode;
		fFlushEachLine = g_fFlushEachLine;
	}
	else if(g_szClientLogFile && *g_szClientLogFile)
	{
		// server side
		szLogFile = g_szClientLogFile;
		dwLogMode = g_dwClientLogMode;
		fFlushEachLine = g_fClientFlushEachLine;
	}
	
	if(szLogFile && *szLogFile)
	{
		strCommandLine += TEXT("/");
		strCommandLine += MsiChar(LOG_OPTION);
		ICHAR rgchLogMode[sizeof(szLogChars)/sizeof(ICHAR) + 1];
		if(ModeBitsToString(dwLogMode, szLogChars, rgchLogMode) == ERROR_SUCCESS)
		{
			IStrCat(rgchLogMode, TEXT("+"));
			if (fFlushEachLine)
				IStrCat(rgchLogMode, TEXT("!"));
			strCommandLine += rgchLogMode;
			
		}
	
		strCommandLine += TEXT(" \"");
		strCommandLine += szLogFile;
		strCommandLine += TEXT("\"");
	}

	iesEnum iesRet = iesNoAction;
	PMsiRecord pParams = &pServices->CreateRecord(IxoRegAddRunOnceEntry::Args);
	AssertNonZero(pParams->SetMsiString(IxoRegAddRunOnceEntry::Name, *strRunOnceValueName));
	AssertNonZero(pParams->SetMsiString(IxoRegAddRunOnceEntry::Command,*strCommandLine));
	if((iesRet = riEngine.ExecuteRecord(ixoRegAddRunOnceEntry, *pParams)) != iesSuccess)
		return iesRet;

	// call RunScript to run any spooled operations now before we reboot
	iesRet = riEngine.RunScript(false);
	if(iesRet == iesSuccess || iesRet == iesNoAction || iesRet == iesFinished)
		iesRet = iesSuspend;

	// update the InProgress information to reflect that the in-progress install contained a ForceReboot
	// (we don't put this property in the RunOnce key because that value is volatile - the InProgress information is not)
	PMsiRecord pInProgressInfo = &(pServices->CreateRecord(ipiEnumCount));
	AssertNonZero(pInProgressInfo->SetString(ipiAfterReboot, IPROPNAME_AFTERREBOOT TEXT("=1")));
	pRecErr = UpdateInProgressInstallInfo(*pServices, *pInProgressInfo);
	if(pRecErr)
	{
		AssertRecordNR(pRecErr); // ignore failure
		pRecErr = 0;
	}
	
	riEngine.SetMode(iefReboot, fTrue);
	riEngine.SetMode(iefRebootNow, fTrue);

	// Sequence will end transaction - will not unlock server if iesRet == iesSuspend
	return iesRet;
}

//____________________________________________________________________________
//
// Product registration actions, will be move to another file after development
//____________________________________________________________________________

/*---------------------------------------------------------------------------
	CollectUserInfo action - puts up UI to collect user information on 
	first run, then registers this info
---------------------------------------------------------------------------*/

iesEnum CollectUserInfo(IMsiEngine& riEngine)
{
	iesEnum iesReturn = riEngine.DoAction(IACTIONNAME_FIRSTRUN);
	if (iesReturn != iesSuccess)
		return iesReturn;

	return riEngine.RegisterUser(true);
}

/*---------------------------------------------------------------------------
	ValidatePID action - validates the PIDKEY value agains the PIDTemplate
	value and sets the ProductID property appropriately
---------------------------------------------------------------------------*/

iesEnum ValidateProductID(IMsiEngine& riEngine)
{
	riEngine.ValidateProductID(false);
	// always return success from this action - true pid validation (and failure upon invalidation)
	// is performed in the UI or during first-run.  If this is to be done during the install, a custom
	// action can do it
	return iesSuccess;
}

enum iuoEnum
{
	iuoVersionGreater  = 0x1,
	iuoVersionLessThan = 0x2,
	iuoVersionEqual    = 0x4,
};

bool CompareUpgradeVersions(unsigned int iVersion1, unsigned int iVersion2, unsigned int iOperator)
{
	// iOperator & iuoVersionGreater:  hit if iVersion1 > iVersion2
	// iOperator & iuoVersionLessThan: hit if iVersion1 < iVersion2
	// iOperator & iuoVersionEqual:    hit if iVersion1 = iVersion2

	iuoEnum iuoVersionCompare;
	if(iVersion1 == iVersion2)
		iuoVersionCompare = iuoVersionEqual;
	else if(iVersion1 > iVersion2)
		iuoVersionCompare = iuoVersionGreater;
	else
		iuoVersionCompare = iuoVersionLessThan;

	return (iuoVersionCompare & iOperator) ? true : false;
}

#ifdef DEBUG
void DumpTable(IMsiEngine& riEngine, const ICHAR* szTable)
{
	PMsiRecord pError(0);
	
	DEBUGMSG1(TEXT("Beginning dump of table: %s"), szTable);
	
	ICHAR szQuery[256];
	wsprintf(szQuery, TEXT("SELECT * FROM `%s`"), szTable);
	
	PMsiView pView(0);
	pError = riEngine.OpenView(szQuery, ivcFetch, *&pView);

	if(!pError)
		pError = pView->Execute(0);

	if(!pError)
	{
		PMsiRecord pFetchRecord(0);

		while(pFetchRecord = pView->Fetch())
		{
			DEBUGMSG(MsiString(pFetchRecord->FormatText(fTrue)));
		}
	}

	DEBUGMSG1(TEXT("Ending dump of table: %s"), szTable);
}
#endif //DEBUG

/*---------------------------------------------------------------------------
	FindRelatedProducts action - searches for products specified in Upgrade
	table and sets appropriate properties
---------------------------------------------------------------------------*/

const ICHAR sqlFindRelatedProducts[] =
TEXT("SELECT `UpgradeCode`,`VersionMin`,`VersionMax`,`Language`,`Attributes`,`ActionProperty` FROM `Upgrade`");

const ICHAR sqlOldUpgradeTableSchema[] = 
TEXT("SELECT `UpgradeCode`, `ProductVersion`, `Operator`, `Features`, `Property` FROM `Upgrade`");

enum qfrpEnum
{
	qfrpUpgradeCode = 1,
	qfrpMinVersion,
	qfrpMaxVersion,
	qfrpLanguages,
	qfrpAttributes,
	qfrpActionProperty,
};

iesEnum FindRelatedProducts(IMsiEngine& riEngine)
{
	if(riEngine.GetMode() & iefSecondSequence)
	{
		DEBUGMSG(TEXT("Skipping FindRelatedProducts action: already done on client side"));
		return iesNoAction;
	}

	if(riEngine.GetMode() & iefMaintenance)
	{
		DEBUGMSG(TEXT("Skipping FindRelatedProducts action: not run in maintenance mode"));
		return iesNoAction;
	}

	if ( g_MessageContext.IsOEMInstall() )
	{
		DEBUGMSG(TEXT("Skipping FindRelatedProducts action: not run in OEM mode"));
		return iesNoAction;
	}

	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());

	PMsiView pUpgradeView(0);
	if((pError = riEngine.OpenView(sqlFindRelatedProducts, ivcFetch, *&pUpgradeView)) ||
		(pError = pUpgradeView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else if(pError->GetInteger(1) == idbgDbQueryUnknownColumn) // might be the older schema that we dont support
		{
			if(!PMsiRecord(riEngine.OpenView(sqlOldUpgradeTableSchema, ivcFetch, *&pUpgradeView)))
			{
				// matches old schema, noop
				DEBUGMSG(TEXT("Skipping FindRelatedProducts action: database does not support upgrade logic"));
				return iesNoAction;
			}
		}
		return riEngine.FatalError(*pError);
	}
	
	MsiString strProductCode = riEngine.GetProductKey();
	Assert(strProductCode.TextSize());
	MsiString strUpgradingProductCode = riEngine.GetPropertyFromSz(IPROPNAME_UPGRADINGPRODUCTCODE);
	
	bool fNewInstallPerMachine = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? true : false;
	
	PMsiRecord pActionData = &::CreateRecord(1);
	PMsiRecord pFetchRecord(0);
	while(pFetchRecord = pUpgradeView->Fetch())
	{
		const ICHAR* szUpgradeCode = pFetchRecord->GetString(qfrpUpgradeCode);
		int iOperator = pFetchRecord->GetInteger(qfrpAttributes);
		Assert(iOperator != iMsiStringBadInteger);

		const int cMaxLangs = 255;
		unsigned short rgwLangID[cMaxLangs];
		int iLangCount = 0;
		if(!pFetchRecord->IsNull(qfrpLanguages))
		{
			AssertNonZero(GetLangIDArrayFromIDString(pFetchRecord->GetString(qfrpLanguages), rgwLangID, cMaxLangs, iLangCount));
		}

		int iIndex = 0;
		ICHAR rgchProductKey[cchProductCode + 1];
		while(ERROR_SUCCESS == MsiEnumRelatedProducts(szUpgradeCode, 0, iIndex, rgchProductKey))
		{
			iIndex++;
			
			if(strProductCode.Compare(iscExactI, rgchProductKey) ||        // can't upgrade over same product code
				strUpgradingProductCode.Compare(iscExactI, rgchProductKey)) // can't upgrade over product that's upgrading over us
			{
				continue;
			}

			// check assignment type of existing app - only a "hit" if its the same as the current
			// per-user or per-machine install type
			// NOTE: we miss the case where we are installing per-machine and the existing install is both
			// per-machine and per-user.  in this case we don't detect a per-machine app.  this is a known
			// limitation
			CTempBuffer<ICHAR, 15> rgchAssignmentType;
			if((GetProductInfo(rgchProductKey, INSTALLPROPERTY_ASSIGNMENTTYPE, rgchAssignmentType)) == fFalse)
			{
				DEBUGMSG1(TEXT("FindRelatedProducts: could not read ASSIGNMENTTYPE info for product '%s'.  Skipping..."), rgchProductKey);
				continue;
			}

			// current assignment type should be same as existing assignment type
			bool fExistingInstallPerMachine = (MsiString(*(ICHAR* )rgchAssignmentType) == 1);
			if(fNewInstallPerMachine != fExistingInstallPerMachine)
			{
				DEBUGMSG3(TEXT("FindRelatedProducts: current install is per-%s.  Related install for product '%s' is per-%s.  Skipping..."),
							 fNewInstallPerMachine ? TEXT("machine") : TEXT("user"), rgchProductKey,
							 fExistingInstallPerMachine ? TEXT("machine") : TEXT("user"));
				continue;
			}

			CTempBuffer<ICHAR, 15> rgchProductVersion;
			if((GetProductInfo(rgchProductKey,INSTALLPROPERTY_VERSION,rgchProductVersion)) == fFalse)
			{
				DEBUGMSG1(TEXT("FindRelatedProducts: could not read VERSION info for product '%s'.  Skipping..."), rgchProductKey);
				continue;
			}

			CTempBuffer<ICHAR, 15> rgchProductLanguage;
			if((GetProductInfo(rgchProductKey,INSTALLPROPERTY_LANGUAGE,rgchProductLanguage)) == fFalse)
			{
				DEBUGMSG1(TEXT("FindRelatedProducts: could not read LANGUAGE info for product '%s'.  Skipping..."), rgchProductKey);
				continue;
			}

			unsigned int iProductVersion = MsiString((ICHAR*)rgchProductVersion);
			Assert((int)iProductVersion != (int)iMsiStringBadInteger);

			int iProductLanguage = MsiString((ICHAR*)rgchProductLanguage);
			Assert(iProductLanguage != iMsiStringBadInteger);

			bool fHit = true;
			
			// check min version
			if(pFetchRecord->IsNull(qfrpMinVersion) == fFalse)
			{
				MsiString strMinUpgradeVersion = pFetchRecord->GetString(qfrpMinVersion);
				unsigned int iLowerUpgradeVersion = ProductVersionStringToInt(strMinUpgradeVersion);
				int iLowerOperator = iuoVersionGreater | ((iOperator & msidbUpgradeAttributesVersionMinInclusive) ? iuoVersionEqual : 0);

				if(CompareUpgradeVersions(iProductVersion, iLowerUpgradeVersion, iLowerOperator) == false)
					fHit = false;
			}

			// check max version
			if(fHit && pFetchRecord->IsNull(qfrpMaxVersion) == fFalse)
			{
				MsiString strMaxUpgradeVersion = pFetchRecord->GetString(qfrpMaxVersion);
				unsigned int iUpperUpgradeVersion = ProductVersionStringToInt(strMaxUpgradeVersion);
				int iUpperOperator = iuoVersionLessThan | ((iOperator & msidbUpgradeAttributesVersionMaxInclusive) ? iuoVersionEqual : 0);

				if(CompareUpgradeVersions(iProductVersion, iUpperUpgradeVersion, iUpperOperator) == false)
					fHit = false;
			}

			// check language
			if(fHit && iLangCount)
			{
				if(iOperator & msidbUpgradeAttributesLanguagesExclusive)
				{
					// set from table defines languages that aren't a hit
					// so if this language is in the set, we don't have a hit
					fHit = true;
				}
				else
				{
					// set from table defines lanauges that are a hit
					// so if this language is in the set, we have a hit
					fHit = false;
				}

				for (int iLangIndex = 0; iLangIndex < iLangCount; iLangIndex++)
				{
					if (rgwLangID[iLangIndex] == iProductLanguage)
					{
						fHit = !fHit; // if inclusive, we found a hit lang, if exclusive we found a non-hit
						break;
					}
				}
			}

			if(fHit)
			{
				// send action data message for each product found
				AssertNonZero(pActionData->SetString(1, rgchProductKey)); //?? get product name instead?				
				if(riEngine.Message(imtActionData, *pActionData) == imsCancel)
					return iesUserExit;

				// set property to indicate a product was found
				MsiString strProperty = pFetchRecord->GetString(qfrpActionProperty);
				MsiString strPropValue = riEngine.GetProperty(*strProperty);
				if(strPropValue.TextSize())
					strPropValue += TEXT(";");
				strPropValue += rgchProductKey;
				AssertNonZero(riEngine.SetProperty(*strProperty, *strPropValue));

				if(iOperator & msidbUpgradeAttributesMigrateFeatures)
				{
					strPropValue = riEngine.GetPropertyFromSz(IPROPNAME_MIGRATE);
					if(strPropValue.TextSize())
						strPropValue += TEXT(";");
					strPropValue += rgchProductKey;
					AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_MIGRATE),*strPropValue));
				}
			}
		}
	}

	return iesSuccess;
}

const ICHAR sqlFeatures[] = TEXT("SELECT `Feature` FROM `Feature`");

iesEnum MigrateFeatureStates(IMsiEngine& riEngine)
{
	if(riEngine.GetMode() & iefSecondSequence)
	{
		DEBUGMSG(TEXT("Skipping MigrateFeatureStates action: already done on client side"));
		return iesNoAction;
	}
	
	if(riEngine.GetMode() & iefMaintenance)
	{
		DEBUGMSG(TEXT("Skipping MigrateFeatureStates action: not run in maintenance mode"));
		return iesNoAction;
	}

	if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PRESELECTED)).TextSize())
	{
		DEBUGMSG(TEXT("Skipping MigrateFeatureStates action: feature settings already made"));
		return iesNoAction;
	}

	MsiString strMigratePropName(*IPROPNAME_MIGRATE);
	MsiString strMigratePropValue = riEngine.GetProperty(*strMigratePropName);
	if(!strMigratePropValue.TextSize())
		return iesNoAction;

	DEBUGMSG1(TEXT("Migrating feature settings from product(s) '%s'"),strMigratePropValue);
	PMsiRecord pError(0);

	// might be multiple product codes in property value
	// set up "multi-sz" to process each quickly
	CTempBuffer<ICHAR, cchGUID + 2> rgchMigrateCodes;
	if(strMigratePropValue.TextSize() + 2 > rgchMigrateCodes.GetSize())
		rgchMigrateCodes.SetSize(strMigratePropValue.TextSize() + 2);

	IStrCopy(rgchMigrateCodes,(const ICHAR*)strMigratePropValue);
	int cCodes = 0;
	ICHAR* pch = rgchMigrateCodes;
	ICHAR* pchStart = pch; // pointer to start of product code
	for(; *pch; pch++)
	{
		if(*pch == ';')
		{
			if(pch - pchStart != cchGUID)
			{
				pError = PostError(Imsg(idbgInvalidPropValue),*strMigratePropName,*strMigratePropValue);
				return riEngine.FatalError(*pError);
			}
			*pch = 0;
			pchStart = pch+1;
		}
	}
	if(pch != pchStart && (pch - pchStart != cchGUID))
	{
		pError = PostError(Imsg(idbgInvalidPropValue),*strMigratePropName,*strMigratePropValue);
		return riEngine.FatalError(*pError);
	}
	*(pch+1) = 0; // end with double-null

	
	PMsiSelectionManager pSelectionManager(riEngine,IID_IMsiSelectionManager);
	PMsiTable pFeatureTable = pSelectionManager->GetFeatureTable();
	if(pFeatureTable == 0)
	{
		pError = PostError(Imsg(idbgNotInitializedToMigrateSettings));
		return riEngine.FatalError(*pError);
	}

	PMsiCursor pFeatureCursor = pFeatureTable->CreateCursor(fTrue); // feature table always tree-linked

	while(pFeatureCursor->Next())
	{
		MsiString strFeature = pFeatureCursor->GetString(1);

		const ICHAR *szProductCode = rgchMigrateCodes;
		iisEnum iisState = iisNextEnum;
		
		do
		{
			INSTALLSTATE isINSTALLSTATE = MsiQueryFeatureState(szProductCode,strFeature);
			
			switch(isINSTALLSTATE)
			{
			case INSTALLSTATE_LOCAL:
				iisState = iisLocal;
				break;

			case INSTALLSTATE_SOURCE:
				if(iisState == iisNextEnum || iisState == iisAbsent || iisState == iisAdvertise)
					iisState = iisSource;
				break;

			case INSTALLSTATE_ADVERTISED:
				if(iisState == iisNextEnum || iisState == iisAbsent)
					iisState = iisAdvertise;
				break;

			case INSTALLSTATE_ABSENT:
				if(iisState == iisNextEnum)
					iisState = iisAbsent;
				break;

			default:
	#ifdef DEBUG
				ICHAR rgchDebug[256];
				wsprintf(rgchDebug,TEXT("Unexpected return from MsiQueryFeatureState(%s,%s): %d"),
							szProductCode,(const ICHAR*)strFeature,isINSTALLSTATE);
				AssertSz(0,rgchDebug);
	#endif //DEBUG
				// fall through
			case INSTALLSTATE_UNKNOWN:
				break; // feature not in other product
			}
		}
		while(iisState != iisLocal && *(szProductCode += (cchGUID+1)) != 0);

		if(iisState != iisNextEnum)
		{
			const ICHAR szState[][12] = {TEXT("Absent"),TEXT("Local"),TEXT("Source"),TEXT("Reinstall"),
												 TEXT("Advertise"),TEXT("Current"),TEXT("FileAbsent"),TEXT("Null")};

			DEBUGMSGV2(TEXT("MigrateFeatureStates: based on existing product, setting feature '%s' to '%s' state."),
						  strFeature, szState[iisState]);
			pError = pSelectionManager->ConfigureFeature(*strFeature,iisState);
			if(pError)
				return riEngine.FatalError(*pError);
		}
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	RemoveExistingProducts action - Removes existing products
---------------------------------------------------------------------------*/

const ICHAR sqlUpgradeUninstall[] =
TEXT("SELECT `Attributes`, `ActionProperty`, `Remove` FROM `Upgrade`");

enum iqbiEnum
{
	iqbiAttributes = 1,
	iqbiActionProperty,
	iqbiRemove,
};

iesEnum ResolveSource(IMsiEngine& riEngine); // action used by RemoveExistingProducts
iesEnum GetForeignSourceList(IMsiEngine& riEngine, const IMsiString& ristrProduct,
									  const IMsiString*& rpistrForeignSourceList);

iesEnum RemoveExistingProducts(IMsiEngine& riEngine)
{
	if((riEngine.GetMode() & iefMaintenance) || !FFeaturesInstalled(riEngine))
	{
		// performing an uninstall, or not installing anything.  REP is a no-op in this case.
		DEBUGMSG(TEXT("Skipping RemoveExistingProducts action: current configuration is maintenance mode or an uninstall"));
		return iesNoAction;
	}

	if(riEngine.GetMode() & iefOperations)
	{
		// since each uninstall must run in its own script, REP may not be run while a script is currently
		// being spooled
		PMsiRecord pError = PostError(Imsg(idbgRemoveExistingProductsSequenceError));
		return riEngine.FatalError(*pError);
	}


	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());

	PMsiView pUpgradeView(0);
	if((pError = riEngine.OpenView(sqlUpgradeUninstall, ivcFetch, *&pUpgradeView)) ||
		(pError = pUpgradeView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else if(pError->GetInteger(1) == idbgDbQueryUnknownColumn) // might be the older schema that we dont support
		{
			if(!PMsiRecord(riEngine.OpenView(sqlOldUpgradeTableSchema, ivcFetch, *&pUpgradeView)))
			{
				// matches old schema, noop
				DEBUGMSG(TEXT("Skipping RemoveExistingProducts action: database does not support upgrade logic"));
				return iesNoAction;
			}
		}
		return riEngine.FatalError(*pError);
	}
	
	MsiString strNewProductKey = riEngine.GetProductKey();

	MsiString strPatchedProductCode = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);

	// don't return until end-of-function
	
	// set current message headers to those used during upgrade uninstalls
	AssertNonZero(riEngine.LoadUpgradeUninstallMessageHeaders(PMsiDatabase(riEngine.GetDatabase()),true) == ieiSuccess);

	PMsiRecord pActionData = &::CreateRecord(2);
	PMsiRecord pFetchRecord(0);
	iesEnum iesRet = iesSuccess;
	while((pFetchRecord = pUpgradeView->Fetch()) != 0 && (iesRet == iesSuccess || iesRet == iesNoAction))
	{
		int iOperator = pFetchRecord->GetInteger(iqbiAttributes);
		Assert(iOperator != iMsiStringBadInteger);
		if(iOperator & msidbUpgradeAttributesOnlyDetect)
			continue;
		
		MsiString strCommandLine;
		if(strNewProductKey.TextSize())
		{
			strCommandLine = IPROPNAME_UPGRADINGPRODUCTCODE TEXT("=");
			strCommandLine += strNewProductKey;
			strCommandLine += TEXT(" ");
		}

		MsiString strFeatures = pFetchRecord->GetMsiString(iqbiRemove);
		if(!strFeatures.TextSize())
		{
			// no authored string - default to ALL
			strFeatures = IPROPVALUE_FEATURE_ALL;
		}
		else
		{
			strFeatures = riEngine.FormatText(*strFeatures); // formatted column

			// if string formats to nothing, it means we don't want to remove anything
			// note that this is different than the case above when nothing in the column means remove everything
			if(!strFeatures.TextSize())
				continue;
		}

		strCommandLine += IPROPNAME_FEATUREREMOVE TEXT("=");
		strCommandLine += strFeatures;
		
		MsiString strPropValue = riEngine.GetProperty(*MsiString(pFetchRecord->GetMsiString(iqbiActionProperty)));
		if(!strPropValue.TextSize())
			continue;

		while(strPropValue.TextSize())
		{
			MsiString strProductKey = strPropValue.Extract(iseUpto,';');

			if(strProductKey.TextSize())
			{
				
				// if we are patching over this product we may need to do some source handling
				if(strProductKey.Compare(iscExactI, strPatchedProductCode))
				{
					// we may be removing the old product before the new product has been installed

					// need to make sure source is resolved for new product - call ResolveSource action to do this
					if((iesRet == ResolveSource(riEngine)) != iesSuccess)
						break;

					// need to save old source list to be registered for new product
					MsiString strPatchedProductSourceList = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTSOURCELIST);
					if(strPatchedProductSourceList.TextSize() == 0)
					{
						// source list not saved yet
						if ((iesRet = GetForeignSourceList(riEngine, *strProductKey, *&strPatchedProductSourceList)) != iesSuccess)
							break;
					
						AssertNonZero(riEngine.SetProperty(*MsiString(IPROPNAME_PATCHEDPRODUCTSOURCELIST),
																	  *strPatchedProductSourceList));
					}
				}
				
				// send action data message for each product found
				AssertNonZero(pActionData->SetMsiString(1, *strProductKey)); //?? get product name instead?				
				AssertNonZero(pActionData->SetMsiString(2, *strCommandLine));
				if(riEngine.Message(imtActionData, *pActionData) == imsCancel)
					break;

				bool fIgnoreFailure = (iOperator & msidbUpgradeAttributesIgnoreRemoveFailure) ? true : false;
				iesRet = riEngine.RunNestedInstall(*strProductKey,fTrue,0,*strCommandLine,iioUpgrade,fIgnoreFailure);
				Assert((riEngine.GetMode() & iefOperations) == 0); // uninstall shouldn't have merged script ops
				if(iesRet == iesUserExit)
					break;
			}

			strPropValue.Remove(iseFirst,strProductKey.TextSize());
			if((*(const ICHAR*)strPropValue == ';'))
				strPropValue.Remove(iseFirst, 1);
		}	
	}

	// reset current message headers
	AssertNonZero(riEngine.LoadUpgradeUninstallMessageHeaders(PMsiDatabase(riEngine.GetDatabase()),false) == ieiSuccess);

	return iesRet;
}

/*---------------------------------------------------------------------------
	RegisterProduct action - registers product with configuration managager
---------------------------------------------------------------------------*/

iesEnum RegisterProduct(IMsiEngine& riEngine)
{
	return riEngine.RegisterProduct();
}

/*---------------------------------------------------------------------------
	RegisterUser action - registers user info with configuration managager
---------------------------------------------------------------------------*/

iesEnum RegisterUser(IMsiEngine& riEngine)
{
	if (riEngine.GetMode() & iefMaintenance)
		return iesNoAction;
	// initialization of UserName and OrgName moved to Engine::Initialize
	return riEngine.RegisterUser(false);
}

/*---------------------------------------------------------------------------
	Install* actions - handle starting and stopping transactions, and
	running scripts.
---------------------------------------------------------------------------*/

iesEnum InstallFinalize(IMsiEngine& riEngine)
{
	iesEnum iesRet = riEngine.RunScript(false);
	if(iesRet == iesSuccess || iesRet == iesNoAction)
		AssertNonZero(riEngine.EndTransaction(iesRet) == iesSuccess); // rollback cleanup shouldn't fail
	// else we do it in Sequence
	return iesRet;
}

iesEnum InstallInitialize(IMsiEngine& riEngine)
{
	//  Adding the temporary BinaryType column into Component table
	//  NOTE: a better spot for this is the InstallValidate action
	//        but that action can be conditionalized out and this is critical work
	
	PMsiRecord pErrRec(0);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pTable(0);
	pErrRec = pDatabase->LoadTable(*MsiString(*sztblComponent), 1, *&pTable);
	if ( pErrRec )
	{
		Assert(0);
		return iesFailure;
	}
	pTable->CreateColumn(icdShort+icdTemporary, *MsiString(*sztblComponent_colBinaryType));
	int iColAttributes = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colAttributes));
	int iColBinaryType = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colBinaryType));
	PMsiCursor pCursor(pTable->CreateCursor(fFalse));
	pCursor->SetFilter(0);
	while ( pCursor->Next() )
	{
		int iAttrib = pCursor->GetInteger(iColAttributes);
		Assert(iAttrib != iMsiNullInteger);
		ibtBinaryType iType = (iAttrib & msidbComponentAttributes64bit) == msidbComponentAttributes64bit ? ibt64bit : ibt32bit;
		Debug(const ICHAR* pszDebug = (const ICHAR*)MsiString(pCursor->GetString(pTable->GetColumnIndex(pDatabase->EncodeStringSz(TEXT("Component")))));)
		AssertNonZero(pCursor->PutInteger(iColBinaryType, (int)iType));
		AssertNonZero(pCursor->Update());
	}
	
	// check if the product is being completely uninstalled, and if so whether that operation is safe
	if (!riEngine.FSafeForFullUninstall(iremThis))
	{
		pErrRec = PostError(Imsg(imsgUserUninstallDisallowed));
		return riEngine.FatalError(*pErrRec);
	}

	return riEngine.BeginTransaction();
}

iesEnum InstallExecute(IMsiEngine& riEngine)
{
	return riEngine.RunScript(true);
}

iesEnum InstallExecuteAgain(IMsiEngine& riEngine)
{
	return riEngine.RunScript(true);
}

iesEnum DisableRollback(IMsiEngine& riEngine)
{
	PMsiSelectionManager pSelectionManager(riEngine,IID_IMsiSelectionManager);
	pSelectionManager->EnableRollback(fFalse);

	return iesSuccess;
}

const ICHAR sqlRegisterClassInfo30[]             = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterClassInfoFirstAdvt30[]    = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterClassInfo30[]           = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterClassInfoGPT30[]          = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags` FROM `Class`, `Component`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Feature`.`Action` = 4");

const ICHAR sqlRegisterClassInfo[]             = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterClassInfoFirstAdvt[]    = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterClassInfo[]           = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterClassInfoGPT[]          = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags` FROM `Class`, `Component`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Feature`.`Action` = 4");

// Keyed off the foreign key from the Register/UnregisterClassInfo.   Same query for both register and unregister,
// choosing to do it is based on the Class conditions.
const ICHAR sqlAppIdInfo[]       = TEXT("SELECT `RemoteServerName`, `LocalService`, `ServiceParameters`, `DllSurrogate`, `ActivateAtStorage`, `RunAsInteractiveUser` FROM AppId WHERE AppId = ?");

const ICHAR sqlClassInfoVIProgId[]    = TEXT("SELECT `ProgId` FROM `ProgId` WHERE `ProgId_Parent` = ?");

iesEnum ProcessClassInfo(IMsiEngine& riEngine, int fRemove)
{
	enum cliClassInfo{
		cliBinaryType = 1,
		cliCLSID, 
		cliProgId,
		cliDescription, 
		cliContext,
		cliFeature,
		cliComponentId,
		cliComponent,
		cliInsertable,
		cliAttributes = cliInsertable,
		cliAppId,
		cliFileTypeMask,
		cliIconName,
		cliIconIndex,
		cliDefInprocHandler,
		cliArgument,
		cliComponentRuntimeFlags,
		cliFileName,
		cliDirectory,
		cliComponentAction,
		cliComponentInstalled,
		cliFeatureAction,
	};

	enum caiAppIdInfo{
		caiRemoteServerName = 1,
		caiLocalService,
		caiServiceParameters,
		caiDllSurrogate,
		caiActivateAtStorage,
		caiRunAsInteractiveUser,
	};

	using namespace IxoRegClassInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) ? false : true;
		}
	}

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlRegisterClassInfoGPT   : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterClassInfoFirstAdvt   : sqlRegisterClassInfo  ) : sqlUnregisterClassInfo;

	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else // possibly old database version without Attributes column
		{
			// compatibility with 0.30, 1.0, 1.01 databases
			szQuery = (fMode & iefAdvertise) ? sqlRegisterClassInfoGPT30 : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterClassInfoFirstAdvt30 : sqlRegisterClassInfo30) : sqlUnregisterClassInfo30;
			pError = riEngine.OpenView(szQuery, ivcFetch, *&piView);  // try again with old query
		}
	}
	if (pError != 0 || (pError = piView->Execute(0)))
		return riEngine.FatalError(*pError);
	
	PMsiView pView1(0);
	PMsiView piViewAppId(0);

	while(piRec = piView->Fetch())
	{
		Assert(piRec->GetInteger(cliComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(cliComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		MsiString strAssemblyName;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(cliComponent)), iatAssemblyType, &strAssemblyName, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping class registration for component %s as it is a Win32 assembly."), piRec->GetString(cliComponent));
			continue;// skip processing this component
		}

		PMsiRecord pClassInfoRec = &piServices->CreateRecord(Args);
		PMsiRecord pAppIdInfoRec(0);

		MsiString strCLSID(piRec->GetMsiString(cliCLSID));
		pClassInfoRec->SetMsiString(ClsId, *strCLSID);
		if(!piRec->IsNull(cliProgId))
		{
			pClassInfoRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(cliProgId)));

			// get the version independant progid, if any
			PMsiRecord pRecProgId = &piServices->CreateRecord(1);
			pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(cliProgId)));
			if (pView1 == 0)
			{
				if (pError = riEngine.OpenView(sqlClassInfoVIProgId, ivcFetch, *&pView1))
					return riEngine.FatalError(*pError);
			}
			
			if (pError = pView1->Execute(pRecProgId))
			{
				// did not find anything
				return riEngine.FatalError(*pError);
			}
			if(pRecProgId = pView1->Fetch())
			{
				// we have a VIProgId
				pClassInfoRec->SetMsiString(VIProgId, *MsiString(pRecProgId->GetMsiString(1)));
			}
		}

		pClassInfoRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(cliDescription)));
		pClassInfoRec->SetMsiString(Context, *MsiString(piRec->GetMsiString(cliContext)));
		if(((fMode & iefAdvertise) || !fRemove || piRec->GetInteger(cliFeatureAction) != iisAdvertise))
		{
			MsiString strFeature = piRec->GetMsiString(cliFeature);
			MsiString strComponentId = piRec->GetMsiString(cliComponentId);
			MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
			pClassInfoRec->SetMsiString(Feature, *strFeature);
			pClassInfoRec->SetMsiString(Component, *strComponentWithOptFlags);
		}
		int iAttributes = piRec->GetInteger(cliAttributes);  // was cliInsertable in versions <= 28
		iisEnum iisState = (iisEnum)piRec->GetInteger(cliComponentAction);
 
		// AppId 
		MsiString strAppId(piRec->GetMsiString(cliAppId));

		// We'll always let the Class info write the AppId info as well.  This gives us the CLSID\AppId link.
		pClassInfoRec->SetMsiString(AppID, *strAppId);

		{
			using namespace IxoRegAppIdInfoRegister;

			if (!(fMode & iefAdvertise) && (iisState != iMsiNullInteger) && strAppId.TextSize()) // don't advertise AppId info
			{
				PMsiRecord piAppIdFetch(0);

				if (piViewAppId == 0)
				{
					if((pError = riEngine.OpenView(sqlAppIdInfo, ivcFetch, *&piViewAppId)))
					{					
						// Ignore missing table error; continue with the rest of the class processing below
						if (pError->GetInteger(1) != idbgDbQueryUnknownTable)
							return riEngine.FatalError(*pError);
					}
				}
					
				if (piViewAppId != 0)
				{
					pAppIdInfoRec = &piServices->CreateRecord(IxoRegAppIdInfoRegister::Args);
					pAppIdInfoRec->SetMsiString(1, *strAppId);
										
					if((pError = piViewAppId->Execute(pAppIdInfoRec)))
						return riEngine.FatalError(*pError);

					piAppIdFetch = piViewAppId->Fetch();
					if (piAppIdFetch)
					{
						// fill in the record.

						//!! format text, check types, REG_MULTI_SZ...
						//YACC???
						pAppIdInfoRec->SetMsiString(AppId, *strAppId);
						pAppIdInfoRec->SetMsiString(IxoRegAppIdInfoRegister::ClsId, *strCLSID);
						pAppIdInfoRec->SetMsiString(RemoteServerName, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiRemoteServerName)))));
						pAppIdInfoRec->SetMsiString(LocalService, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiLocalService)))));
						pAppIdInfoRec->SetMsiString(ServiceParameters, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiServiceParameters)))));
						pAppIdInfoRec->SetMsiString(DllSurrogate, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiDllSurrogate)))));
						pAppIdInfoRec->SetInteger(ActivateAtStorage, piAppIdFetch->GetInteger(caiActivateAtStorage));
						pAppIdInfoRec->SetInteger(RunAsInteractiveUser, piAppIdFetch->GetInteger(caiRunAsInteractiveUser));
					}
				}
			}
		}

		pClassInfoRec->SetMsiString(FileTypeMask, *MsiString(piRec->GetMsiString(cliFileTypeMask)));
		if(!piRec->IsNull(cliIconName))
			pClassInfoRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(cliIconName)));
		if(!piRec->IsNull(cliIconIndex))
			pClassInfoRec->SetInteger(IconIndex, piRec->GetInteger(cliIconIndex));
		pClassInfoRec->SetMsiString(DefInprocHandler, *MsiString(piRec->GetMsiString(cliDefInprocHandler)));
		//YACC???
		pClassInfoRec->SetMsiString(Argument, *MsiString(riEngine.FormatText(*MsiString(piRec->GetMsiString(cliArgument)))));
		
		if(!(fMode & iefAdvertise))
		{
			if(fADVTFlag && iisState == iMsiNullInteger)
			{
				iisEnum iisStateInstalled = (iisEnum)piRec->GetInteger(cliComponentInstalled);
				if(iisStateInstalled == iisAbsent)
					iisStateInstalled = (iisEnum)iMsiNullInteger;
				iisState = iisStateInstalled;
			}

			if(iisState != iMsiNullInteger)
			{
				MsiString strFileName, strFullPath;
				PMsiPath piPath(0);
				Bool fLFN;
				if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent)
					strFullPath = *szNonEmptyPath; // token string to cause removal of the filename registration
				else 
				{
					// use key file
					if(iAttributes & msidbClassAttributesRelativePath)
						fLFN = (fMode & iefSuppressLFN) == 0 ? fTrue : fFalse;  // assume LFN support on PATH
					else if(iisState == iisSource)
					{
						if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(cliDirectory)), *&piPath))
						{
							if (pError->GetInteger(1) == imsgUser)
								return iesUserExit;
							else
								return riEngine.FatalError(*pError);
						}
						fLFN = (fMode & iefNoSourceLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
					}
					else 
					{
						Assert(iisState == iisLocal);
						if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(cliDirectory)), *&piPath))
						{
							return riEngine.FatalError(*pError);
						}
						fLFN = (fMode & iefSuppressLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
					}
					if(pError = piServices->ExtractFileName(piRec->GetString(cliFileName),fLFN,*&strFileName))
						return riEngine.FatalError(*pError);
					if (!piPath)  // relative path requested
						strFullPath = strFileName;
					else if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
					{
						return riEngine.FatalError(*pError);
					}
				}
				pClassInfoRec->SetMsiString(FileName, *strFullPath);
			}
		}

		if(iatAssemblyType == iatURTAssembly || iatAssemblyType == iatURTAssemblyPvt)
		{
			// COM classic <-> COM+ interop : register assembly name, codebase
			pClassInfoRec->SetMsiString(AssemblyName, *strAssemblyName);
			pClassInfoRec->SetInteger(AssemblyType, iatAssemblyType);

		}

		if ( (ibtBinaryType)piRec->GetInteger(cliBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegClassInfoRegister64 : ixoRegClassInfoUnregister64, *pClassInfoRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegClassInfoRegister : ixoRegClassInfoUnregister, *pClassInfoRec);
		if (iesRet != iesSuccess)
			return iesRet;

		if (pAppIdInfoRec)
		{
			if ( (ibtBinaryType)piRec->GetInteger(cliBinaryType) == ibt64bit )
				iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegAppIdInfoRegister64 : ixoRegAppIdInfoUnregister64, *pAppIdInfoRec);
			else
				iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegAppIdInfoRegister : ixoRegAppIdInfoUnregister, *pAppIdInfoRec);
			if (iesRet != iesSuccess)
				return iesRet;
		}

	}
	return iesSuccess;
}


const ICHAR sqlRegisterProgIdInfo[] =    TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterProgIdInfoFirstAdvt[] =    TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags` , `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterProgIdInfo[] =  TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags` , `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterProgIdInfoGPT[] = TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags` , `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND (`Feature`.`Action` = 4)");

const ICHAR sqlProgIdInfoVIProgId[] =    TEXT("SELECT `ProgId`, `Description` FROM `ProgId` WHERE `ProgId_Parent` = ?");
const ICHAR sqlProgIdInfoExtension[] =   TEXT("SELECT `Extension`.`Extension` FROM `Extension` WHERE `Extension`.`ProgId_` = ?");
iesEnum ProcessProgIdInfo(IMsiEngine& riEngine, int fRemove)
{
	enum piiProgIdInfo{
		piiBinaryType = 1,
		piiProgId,
		piiCLSID, 
		piiDescription,
		piiIcon,
		piiIconIndex,
		piiInsertable,
		piiComponentRuntimeFlags,
		piiComponent,
	};

	using namespace IxoRegProgIdInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = ((iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) && (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO))? false : true;
		}
	}

	const ICHAR* szQuery;
	szQuery = (fMode & iefAdvertise) ? sqlRegisterProgIdInfoGPT   : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterProgIdInfoFirstAdvt   : sqlRegisterProgIdInfo  ) : sqlUnregisterProgIdInfo  ;


	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	
	PMsiView pView1(0);
	PMsiView pViewExt(0);
	
	while(piRec = piView->Fetch())
	{

		Assert(piRec->GetInteger(piiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(piiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(piiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping progid registration for component %s as it is a Win32 assembly."), piRec->GetString(piiComponent));
			continue;// skip processing this component
		}


		PMsiRecord pProgIdInfoRec = &piServices->CreateRecord(Args);

		pProgIdInfoRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(piiProgId)));
		if(!piRec->IsNull(piiCLSID))
			pProgIdInfoRec->SetMsiString(ClsId, *MsiString(piRec->GetMsiString(piiCLSID)));
		pProgIdInfoRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(piiDescription)));
		if(!piRec->IsNull(piiIcon))
			pProgIdInfoRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(piiIcon)));
		if(!piRec->IsNull(piiIconIndex))
			pProgIdInfoRec->SetInteger(IconIndex, piRec->GetInteger(piiIconIndex));
		int iInsertable = piRec->GetInteger(piiInsertable);
		if(iInsertable != iMsiNullInteger)
			pProgIdInfoRec->SetInteger(Insertable, iInsertable);

		// get the version independant progid, if any
		PMsiRecord pRecProgId = &piServices->CreateRecord(1);
		pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(piiProgId)));
		if (pView1 == 0)
		{
			if (pError = riEngine.OpenView(sqlProgIdInfoVIProgId, ivcFetch, *&pView1))
				return riEngine.FatalError(*pError);
		}
				
		if(pError = pView1->Execute(pRecProgId))
		{
			return riEngine.FatalError(*pError);
		}
		if(pRecProgId = pView1->Fetch())
		{
			// we have a VIProgId
			pProgIdInfoRec->SetMsiString(VIProgId, *MsiString(pRecProgId->GetMsiString(1)));
			pProgIdInfoRec->SetMsiString(VIProgIdDescription, *MsiString(pRecProgId->GetMsiString(2)));
		}

		// get the extension association, if any
		pRecProgId = &piServices->CreateRecord(1);
		pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(piiProgId)));

		if (pViewExt == 0)
		{
			if (pError = riEngine.OpenView(sqlProgIdInfoExtension, ivcFetch, *&pViewExt))
				return riEngine.FatalError(*pError);
		}
			
		if(pError = pViewExt->Execute(pRecProgId))
		{
			return riEngine.FatalError(*pError);
		}
		if(pRecProgId = pViewExt->Fetch())
		{
			// we have a Extension
			pProgIdInfoRec->SetMsiString(Extension, *MsiString(pRecProgId->GetMsiString(1)));
		}

		if ( (ibtBinaryType)piRec->GetInteger(piiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister64 : ixoRegProgIdInfoUnregister64, *pProgIdInfoRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister : ixoRegProgIdInfoUnregister, *pProgIdInfoRec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}


const ICHAR sqlRegisterProgIdInfoExt[] =    TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterProgIdInfoExtFirstAdvt[] =    TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterProgIdInfoExt[] =  TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR  (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterProgIdInfoExtGPT[] = TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 4)");
const ICHAR sqlProgIdInfoExtVIProgId[] = TEXT("SELECT `ProgId`, `Description` FROM `ProgId` WHERE `ProgId_Parent` = ?");
iesEnum ProcessProgIdInfoExt(IMsiEngine& riEngine, int fRemove)
{
	enum piiProgIdInfo{
		piiBinaryType = 1,
		piiProgId,
		piiCLSID, 
		piiExtension,
		piiDescription,
		piiIcon,
		piiIconIndex,
		piiInsertable,
		piiComponentRuntimeFlags,
		piiComponent
	};

	using namespace IxoRegProgIdInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = ((iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) && (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO))? false : true;
		}
	}

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlRegisterProgIdInfoExtGPT : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterProgIdInfoExtFirstAdvt : sqlRegisterProgIdInfoExt) : sqlUnregisterProgIdInfoExt;
	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	PMsiView pView1(0);
	while(piRec = piView->Fetch())
	{

		Assert(piRec->GetInteger(piiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(piiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(piiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping progid registration for component %s as it is a Win32 assembly."), piRec->GetString(piiComponent));
			continue;// skip processing this component
		}

		PMsiRecord pProgIdInfoRec = &piServices->CreateRecord(Args);

		pProgIdInfoRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(piiProgId)));
		if(!piRec->IsNull(piiCLSID))
			pProgIdInfoRec->SetMsiString(ClsId, *MsiString(piRec->GetMsiString(piiCLSID)));
		if(!piRec->IsNull(piiExtension))
			pProgIdInfoRec->SetMsiString(Extension, *MsiString(piRec->GetMsiString(piiExtension)));
		pProgIdInfoRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(piiDescription)));
		if(!piRec->IsNull(piiIcon))
			pProgIdInfoRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(piiIcon)));
		if(!piRec->IsNull(piiIconIndex))
			pProgIdInfoRec->SetInteger(IconIndex, piRec->GetInteger(piiIconIndex));
		if(!piRec->IsNull(piiInsertable))
			pProgIdInfoRec->SetMsiString(Insertable, *MsiString(piRec->GetMsiString(piiInsertable)));

		// get the version independant progid, if any
		PMsiRecord pRecProgId = &piServices->CreateRecord(1);
		pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(piiProgId)));

		if (pView1 == 0)
		{
			if (pError = riEngine.OpenView(sqlProgIdInfoExtVIProgId, ivcFetch, *&pView1))
				return riEngine.FatalError(*pError);
		}
				
		if (pError = pView1->Execute(pRecProgId))
		{
			return riEngine.FatalError(*pError);
		}
		if(pRecProgId = pView1->Fetch())
		{
			// we have a VIProgId
			pProgIdInfoRec->SetMsiString(VIProgId, *MsiString(pRecProgId->GetMsiString(1)));
			pProgIdInfoRec->SetMsiString(VIProgIdDescription, *MsiString(pRecProgId->GetMsiString(2)));
		}

		if ( (ibtBinaryType)piRec->GetInteger(piiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister64 : ixoRegProgIdInfoUnregister64, *pProgIdInfoRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister : ixoRegProgIdInfoUnregister, *pProgIdInfoRec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

const ICHAR sqlRegisterTypeLibraryInfo[] =    TEXT("SELECT `LibID`, `TypeLib`.`Version`, `TypeLib`.`Language`, `TypeLib`.`Directory_`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `BinaryType`, `Component`.`Component` FROM `TypeLib`, `Component`, `File` WHERE `TypeLib`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Component`.`Action`=1 OR `Component`.`Action`=2)");
const ICHAR sqlUnregisterTypeLibraryInfo[] =  TEXT("SELECT `LibID`, `TypeLib`.`Version`, `TypeLib`.`Language`, `TypeLib`.`Directory_`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `BinaryType`, `Component`.`Component` FROM `TypeLib`, `Component`, `File` WHERE `TypeLib`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Component`.`Action`=0)");
iesEnum ProcessTypeLibraryInfo(IMsiEngine& riEngine, int fRemove)
{
	enum tliTypeLibInfo{
		tliLibID = 1,
		tliVersion,
		tliLanguage,
		tliHelpDirectory,
		tliFileName,
		tliDirectory,
		tliComponentAction,
		tliComponentInstalled,
		tliBinaryType,
		tliComponent,
	};

	using namespace IxoTypeLibraryRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiView piEnumExtView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;

	int fMode = riEngine.GetMode();

	if(fMode & iefAdvertise)
		return iesNoAction;// we dont do advertisement of type libraries any more

	const ICHAR* szQuery = (fRemove == fFalse) ? sqlRegisterTypeLibraryInfo : sqlUnregisterTypeLibraryInfo;
	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) != 0)
	{
		if(pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction; // no typelib table so no typelibs to register
		else
			return riEngine.FatalError(*pError);
	}
	if((pError= piView->Execute(0)) != 0)
	{
		return riEngine.FatalError(*pError);
	}
	while(piRec = piView->Fetch())
	{
		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(tliComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping type library registration for component %s as it is a Win32 assembly."), piRec->GetString(tliComponent));
			continue;// skip processing this component
		}

		PMsiRecord pTypeLibRec = &piServices->CreateRecord(Args);

		pTypeLibRec->SetMsiString(LibID, *MsiString(piRec->GetMsiString(tliLibID)));
		pTypeLibRec->SetInteger(Version, piRec->GetInteger(tliVersion));
		pTypeLibRec->SetInteger(Language, piRec->GetInteger(tliLanguage));
		if(!piRec->IsNull(tliHelpDirectory))
		{
			PMsiPath piHelpPath(0);
			PMsiRecord pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetMsiString(tliHelpDirectory)),*&piHelpPath);
			if(pError)
				return riEngine.FatalError(*pError);
			AssertNonZero(pTypeLibRec->SetMsiString(HelpPath, *MsiString(piHelpPath->GetPath())));
		}

		// use key file
		PMsiPath piPath(0);
		int iefLFN;
		iisEnum iisState = (iisEnum)piRec->GetInteger(tliComponentAction);
		if(iisState == iisAbsent)
			iisState = (iisEnum)piRec->GetInteger(tliComponentInstalled);
		if(iisState == iisSource)
		{
			if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(tliDirectory)), *&piPath))
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pError);
			}
			iefLFN = iefNoSourceLFN;
		}
		else
		{
			if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(tliDirectory)), *&piPath))
			{
				return riEngine.FatalError(*pError);
			}
			iefLFN = iefSuppressLFN;
		}
		MsiString strFileName, strFullPath;
		Bool fLFN = (fMode & iefLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
		if(pError = piServices->ExtractFileName(piRec->GetString(tliFileName),fLFN,*&strFileName))
			return riEngine.FatalError(*pError);
		if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
		{
			return riEngine.FatalError(*pError);
		}
		pTypeLibRec->SetMsiString(FilePath, *strFullPath);
		pTypeLibRec->SetInteger(BinaryType, piRec->GetInteger(tliBinaryType));
		if ((iesRet = riEngine.ExecuteRecord((fRemove == fFalse)?ixoTypeLibraryRegister:ixoTypeLibraryUnregister, *pTypeLibRec)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}


const ICHAR sqlRegisterMIMEInfoExtension[] =    TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterMIMEInfoExtensionFirstAdvt[] =    TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterMIMEInfoExtension[] =  TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterMIMEInfoExtensionGPT[] = TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Feature`.`Action` = 4");
iesEnum ProcessMIMEInfo(IMsiEngine& riEngine, int fRemove)
{
	enum rmiMimeInfo{
		rmiBinaryType = 1,
		rmiContentType,
		rmiExtension,
		rmiCLSID,
		rmiComponentRuntimeFlags,
		rmiComponent,
	};
	using namespace IxoRegMIMEInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();
	Bool fSuppressLFN = fMode & iefSuppressLFN ? fTrue : fFalse;

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = ((iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) && (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO))? false : true;
		}
	}

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlRegisterMIMEInfoExtensionGPT : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterMIMEInfoExtensionFirstAdvt : sqlRegisterMIMEInfoExtension) : sqlUnregisterMIMEInfoExtension;
	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	PMsiRecord piMIMERec = &piServices->CreateRecord(Args);
	while(piRec = piView->Fetch())
	{
		Assert(piRec->GetInteger(rmiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(rmiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(rmiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping MIME registration for component %s as it is a Win32 assembly."), piRec->GetString(rmiComponent));
			continue;// skip processing this component
		}

		piMIMERec->SetMsiString(ContentType, *MsiString(piRec->GetMsiString(rmiContentType)));
		piMIMERec->SetMsiString(Extension, *MsiString(piRec->GetMsiString(rmiExtension)));
		piMIMERec->SetMsiString(ClsId, *MsiString(piRec->GetMsiString(rmiCLSID)));
		if ( (ibtBinaryType)piRec->GetInteger(rmiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegMIMEInfoRegister64 : ixoRegMIMEInfoUnregister64, *piMIMERec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegMIMEInfoRegister : ixoRegMIMEInfoUnregister, *piMIMERec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}


const ICHAR sqlRegisterExtensionExInfo[] =  TEXT("SELECT `Verb`, `Command`, `Argument`, `Sequence` FROM `Verb` WHERE `Extension_` = ? ORDER BY `Sequence`");

const ICHAR sqlRegisterExtensionInfo[] =          TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterExtensionInfoFirstAdvt[] = TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterExtensionInfo[] =        TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterExtensionInfoGPT[] =       TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `Extension`, `Component`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Feature`.`Action` = 4");

iesEnum ProcessExtensionInfo(IMsiEngine& riEngine, int fRemove)
{
	enum reiExtensionInfo{
		reiExtension = 1,
		reiBinaryType,
		reiProgId,
		reiShellNew,
		reiShellNewValue,
		reiMIME,
		reiFeature,
		reiComponentId,
		reiComponentRuntimeFlags,
		reiComponent,
		reiFileName,
		reiDirectory,
		reiComponentAction,
		reiComponentInstalled,
		reiFeatureAction,
	};

	enum rviVerbInfo{
		rviVerb = 1,
		rviCommand,
		rviArgument,
		rviSequence,
	};

	using namespace IxoRegExtensionInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiView piEnumExtView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();
	Bool fSuppressLFN = fMode & iefSuppressLFN ? fTrue : fFalse;

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO)? false : true;
		}
	}

	const ICHAR* szQuery = 0;
	
	szQuery = (fMode & iefAdvertise) ? sqlRegisterExtensionInfoGPT   : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterExtensionInfoFirstAdvt   : sqlRegisterExtensionInfo)   : sqlUnregisterExtensionInfo;

	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piEnumExtView)) ||
		(pError= piEnumExtView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*pError);
	}
	PMsiRecord piExtensionRec(0);
	while(piRec = piEnumExtView->Fetch())
	{
		Assert(piRec->GetInteger(reiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(reiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(reiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping extension registration for component %s as it is a Win32 assembly."), piRec->GetString(reiComponent));
			continue;// skip processing this component
		}

		long lRowCount;

		if (piView == 0)
		{
			if (pError = riEngine.OpenView(sqlRegisterExtensionExInfo, ivcFetch, *&piView))
				return riEngine.FatalError(*pError);
		}

		if ((pError= piView->Execute(piRec)) ||
			(pError = piView->GetRowCount(lRowCount)))
		{
			return riEngine.FatalError(*pError);
		}
		piExtensionRec = &piServices->CreateRecord(lRowCount*3 + Args);
		piExtensionRec->SetMsiString(Extension, *MsiString(piRec->GetMsiString(reiExtension)));
		piExtensionRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(reiProgId)));
		piExtensionRec->SetMsiString(ShellNew, *MsiString(piRec->GetMsiString(reiShellNew)));
		piExtensionRec->SetMsiString(ShellNewValue, *MsiString(piRec->GetMsiString(reiShellNewValue)));
		piExtensionRec->SetMsiString(ContentType, *MsiString(piRec->GetMsiString(reiMIME)));

		if(((fMode & iefAdvertise) || !fRemove || piRec->GetInteger(reiFeatureAction) != iisAdvertise))
		{
			MsiString strFeature = piRec->GetMsiString(reiFeature);
			MsiString strComponentId = piRec->GetMsiString(reiComponentId);
			MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
			piExtensionRec->SetMsiString(Feature, *strFeature);
			piExtensionRec->SetMsiString(Component, *strComponentWithOptFlags);
		}
		iisEnum iisState = (iisEnum)piRec->GetInteger(reiComponentAction);

		if(!(fMode & iefAdvertise))
		{
			if(fADVTFlag && iisState == iMsiNullInteger)
			{
				iisEnum iisStateInstalled = (iisEnum)piRec->GetInteger(reiComponentInstalled);
				if(iisStateInstalled == iisAbsent)
					iisStateInstalled = (iisEnum)iMsiNullInteger;
				iisState = iisStateInstalled;
			}
			if(iisState != iMsiNullInteger)
			{
				MsiString strFileName, strFullPath;
				PMsiPath piPath(0);
				int iefLFN;
				if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent)
					strFullPath = *szNonEmptyPath; // token string to cause removal of the filename registration
				else
				{
					// use key file
					if(iisState == iisSource)
					{
						if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(reiDirectory)), *&piPath))
						{
							if (pError->GetInteger(1) == imsgUser)
								return iesUserExit;
							else
								return riEngine.FatalError(*pError);
						}
						iefLFN = iefNoSourceLFN;
					}
					else
					{
						if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(reiDirectory)), *&piPath))
						{
							return riEngine.FatalError(*pError);
						}
						iefLFN = iefSuppressLFN;
					}
					Bool fLFN = (fMode & iefLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
					if(pError = piServices->ExtractFileName(piRec->GetString(reiFileName),fLFN,*&strFileName))
						return riEngine.FatalError(*pError);
					if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
					{
						return riEngine.FatalError(*pError);
					}
				}
				piExtensionRec->SetMsiString(FileName, *strFullPath);
			}
		}
		int cCount = Args + 1;
		int iOrder = 0;
		PMsiRecord piExtensionExInfo(0);
		while(piExtensionExInfo = piView->Fetch())
		{
			piExtensionRec->SetMsiString(cCount++, *MsiString(piExtensionExInfo->GetMsiString(rviVerb)));
			piExtensionRec->SetMsiString(cCount++, *MsiString(piExtensionExInfo->GetMsiString(rviCommand)));
			//YACC???
			piExtensionRec->SetMsiString(cCount++, *MsiString(riEngine.FormatText(*MsiString(piExtensionExInfo->GetMsiString(rviArgument)))));
			if(!piExtensionExInfo->IsNull(rviSequence))
				iOrder ++;
		}
		if(iOrder)
			piExtensionRec->SetInteger(Order, iOrder);
		if ( (ibtBinaryType)piRec->GetInteger(reiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegExtensionInfoRegister64 : ixoRegExtensionInfoUnregister64, *piExtensionRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegExtensionInfoRegister : ixoRegExtensionInfoUnregister, *piExtensionRec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

IMsiRecord* FindMatchingShellFolder(IMsiEngine& riEngine, IMsiPath& riPath, Bool fAllUsers, bool& rfMatch, int& riFolderId, int& rcchShellFolder)
//------------------------------------------------------------------------------------------------------------------------------
{
	// initialize return args, 1st time value is for "match not found"
	rfMatch = false;
	riFolderId = -1;
	rcchShellFolder = 0;

	IMsiRecord* piError = 0;

	// loop thru the shell folders twice, once for ALL-USERS, 2nd for Per-User
	// we'll go by the AllUsers value first just to optimize this since it is rarer that
	// the folder locations have changed (via an ALLUSERS property value change in the UI sequence)
	const ShellFolder* pShellFolder = 0;
	for (int i=0; i<2; i++)
	{
		if (i == 0)
		{
			pShellFolder = fAllUsers ? rgAllUsersProfileShellFolders : rgPersonalProfileShellFolders;
		}
		else if (i == 1)
		{
			// use opposite shell folders of ALLUSERS property value
			pShellFolder = fAllUsers ? rgPersonalProfileShellFolders : rgAllUsersProfileShellFolders;
		}

		for (; pShellFolder->iFolderId >= 0; pShellFolder++)
		{
			//!! the folders need to be listed in the correct sequence for this to work
			PMsiPath piShellPath(0);

			// grap shell folder path from the FolderCache table
			if ((piError = riEngine.GetFolderCachePath(pShellFolder->iFolderId, *&piShellPath)) != 0)
			{
				if (idbgCacheFolderPropertyNotDefined == piError->GetInteger(1))
				{
					// that folder is not defined
					piError->Release();
					continue;
				}
				return piError;
			}

			ipcEnum ipc;
			if ((piError = piShellPath->Compare(riPath, ipc)) != 0)
				return piError;
			if((ipc == ipcEqual) || (ipc == ipcChild))
			{
				// we have a hit, if this is pass 0, then we are using the correct shell folder;
				// otherwise, we need to use the alternate folder matching the found folder
				rfMatch = true;
				riFolderId = (i==0) ? pShellFolder->iFolderId : pShellFolder->iAlternateFolderId;
				MsiString strShellPath = piShellPath->GetPath();
				rcchShellFolder = strShellPath.CharacterCount();
				return 0;
			}
		}
	}

	return 0;
}

const ICHAR sqlCreateShortcutsGPT[] = TEXT("SELECT `Name`, null, null, `Arguments`, `WkDir`, `Icon_`, `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, null, `Target`, `ComponentId` From `Shortcut`, `Feature`, `Component`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Feature`.`Action` = 4");
const ICHAR sqlCreateShortcuts[] =    TEXT("SELECT  `Name`, `FileName`, `Component`.`Directory_`, `Arguments`, `WkDir`, `Icon_`, `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, `Component`.`Action`, `Target`, `ComponentId`, `Feature`.`Action`, `Component`.`Installed` From `Shortcut`, `Feature`, `Component`, `File`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND")
TEXT(" ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlCreateShortcutsFirstAdvt[] =    TEXT("SELECT  `Name`, `FileName`, `Component`.`Directory_`, `Arguments`, `WkDir`, `Icon_`, `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, `Component`.`Action`, `Target`, `ComponentId`, `Feature`.`Action`, `Component`.`Installed` From `Shortcut`, `Feature`, `Component`, `File`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND")
TEXT(" ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3  OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlCreateShortcutsNonAdvt[] =    TEXT("SELECT  `Name`, `Target`, null, `Arguments`, `WkDir`, `Icon_`,")
TEXT(" `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags` From `Shortcut`, `Component` WHERE `Shortcut`.`Component_` = `Component`")
TEXT(" AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2)");
const ICHAR sqlRemoveShortcuts[] =    TEXT("SELECT  `Name`, null, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, `Feature`.`Action`, `Component`.`Action` From  `Shortcut`, `Feature`, `Component` WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRemoveShortcutsNonAdvt[] = TEXT("SELECT  `Name`, `Target`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`  From  `Shortcut`, `Component` WHERE `Shortcut`.`Component_` = `Component` AND `Component`.`Action` = 0");
iesEnum ProcessShortcutInfo(IMsiEngine& riEngine, int fRemove, Bool fAdvertisable = fTrue)
{
	enum irsShortcutInfo{
		irsName = 1,
		irsFileName,
		irsTargetDirectory,
		irsArguments,
		irsWkDir,
		irsIcon,
		irsIconIndex,
		irsHotkey,
		irsShowCmd,
		irsDescription,
		irsDirectory,
		irsComponentRuntimeFlags,
		irsComponentAction,
		irsFeature,
		irsComponent,
		irsFeatureAction,
		irsComponentInstalled,
	};

	enum iusShortcutInfo{
		iusName = 1,
		iusTarget,
		iusDirectory,
		iusComponentRuntimeFlags,
		iusFeatureAction,
		iusComponentAction,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
			fADVTFlag = (MsiString(*(ICHAR* )rgchADVTFlags) & SCRIPTFLAGS_SHORTCUTS) ? false : true;
	}

	MsiString strDisableAdvertiseShortcuts = riEngine.GetPropertyFromSz(IPROPNAME_DISABLEADVTSHORTCUTS);
	bool fCreateADVTShortcuts =  !strDisableAdvertiseShortcuts.TextSize() && ((fMode & iefGPTSupport) || g_fSmartShell == fTrue);

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlCreateShortcutsGPT : ((fAdvertisable == fTrue) ? ((fRemove == fFalse) ? (fADVTFlag ? sqlCreateShortcutsFirstAdvt : sqlCreateShortcuts) : sqlRemoveShortcuts) : ((fRemove == fFalse) ? sqlCreateShortcutsNonAdvt : sqlRemoveShortcutsNonAdvt));
	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*pError);
	}

	MsiString strPrevFolder;
	PMsiRecord piShortcutRec(0);
	while(piRec = piView->Fetch())
	{
		if(!fRemove && (piRec->GetInteger(irsComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components


		MsiString strFolder;
		if(fRemove == fFalse)
			strFolder = piRec->GetMsiString(irsDirectory);
		else
			strFolder = piRec->GetMsiString(iusDirectory);

		// is strFolder a folder or subfolder of one of the Shell Folders
		PMsiPath piPath(0);
		PMsiPath piShellPath(0);
		if((pError = piDirectoryMgr->GetTargetPath(*strFolder,*&piPath))!=0)
			return riEngine.FatalError(*pError);
		// set to the default
		strFolder = piPath->GetPath();


		// find correct ShellFolder
		Bool fAllUsers = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
		bool fMatchingShellFolderFound = false;
		int iShellFolderId = -1;
		int cchShellFolderPath = 0;
		if ((pError = FindMatchingShellFolder(riEngine, *piPath, fAllUsers, fMatchingShellFolderFound, iShellFolderId, cchShellFolderPath)) != 0)
			return riEngine.FatalError(*pError);

		if (fMatchingShellFolderFound)
		{
			strFolder = iShellFolderId;
			MsiString strPath = piPath->GetPath();
			strPath.Remove(iseFirst, cchShellFolderPath);
			if (strPath.TextSize())
			{
				strFolder += MsiChar(chDirSep);
				strFolder += strPath;
			}
		}
		else if (fMode & iefAdvertise)
		{
			continue;// we cannot advertise shortcuts that do not fall startmenu, desktop, ...
		}

		if(!strPrevFolder.Compare(iscExact, strFolder))
		{
			using namespace IxoSetTargetFolder;
			PMsiRecord pSTFParams = &piServices->CreateRecord(Args); 
			AssertNonZero(pSTFParams->SetMsiString(IxoSetTargetFolder::Folder, *strFolder));
			iesEnum iesRet;
			if((iesRet = riEngine.ExecuteRecord(ixoSetTargetFolder, *pSTFParams)) != iesSuccess)
				return iesRet;
			strPrevFolder = strFolder; 
		}

		// get shortcut name
		MsiString strShortcutName;
		if(riEngine.GetMode() & iefSuppressLFN)
		{
			if((pError = piServices->ExtractFileName(piRec->GetString(irsName),fFalse,*&strShortcutName)) != 0)
				return riEngine.FatalError(*pError);
		}
		else
		{
			strShortcutName = piRec->GetMsiString(irsName);
		}

		if(fRemove == fFalse)
		{
			using namespace IxoShortcutCreate;
			piShortcutRec= &piServices->CreateRecord(Args);
			piShortcutRec->SetMsiString(Name, *strShortcutName);
			if(fCreateADVTShortcuts && (fAdvertisable != fFalse))
			{
				// use darwin descriptor
				MsiString strFeature = piRec->GetMsiString(irsFeature);
				MsiString strComponentId = piRec->GetMsiString(irsComponent);
				MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
				piShortcutRec->SetMsiString(Feature, *strFeature);
				piShortcutRec->SetMsiString(Component, *strComponentWithOptFlags);
			}
			else
			{
				// if we are in the advertise mode
				if(fMode & iefAdvertise)
					continue;

				// use file name, if not purely advertising
				if(fAdvertisable != fFalse)
				{
 					// cannot create non-advertisable shortcuts for a feature in advertise state
 					if(piRec->GetInteger(irsFeatureAction) == iisAdvertise)
 						continue; 

					PMsiPath piTargetPath(0);
					int iefLFN;
					iisEnum iisState = (iisEnum)piRec->GetInteger(irsComponentAction);
					if(iisState == iMsiNullInteger)
						iisState = (iisEnum)piRec->GetInteger(irsComponentInstalled);

					if(iisState == iisSource)
					{
						if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(irsTargetDirectory)), *&piTargetPath))
						{
							if (pError->GetInteger(1) == imsgUser)
								return iesUserExit;
							else
								return riEngine.FatalError(*pError);
						}
						iefLFN = iefNoSourceLFN;
					}
					else
					{
						//!! we should assert that either iisState is local or iisState is null and the requested action state is local
						if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetMsiString(irsTargetDirectory)), *&piTargetPath))
						{
							return riEngine.FatalError(*pError);
						}
						iefLFN = iefSuppressLFN;
					}
					MsiString strFileName, strFullPath;
					Bool fLFN = (fMode & iefLFN) == 0 && piTargetPath->SupportsLFN() ? fTrue : fFalse;
					if(pError = piServices->ExtractFileName(piRec->GetString(irsFileName),fLFN,*&strFileName))
						return riEngine.FatalError(*pError);
					if(pError = piTargetPath->GetFullFilePath(strFileName, *&strFullPath))
					{
						return riEngine.FatalError(*pError);
					}
					piShortcutRec->SetMsiString(FileName, *strFullPath);
				}
				else
				{
					MsiString strTarget = piRec->GetMsiString(irsFileName);
					if(!strTarget.Compare(iscStart, TEXT("[")))
						continue;//!! Advertisable shortcut
					strTarget = riEngine.FormatText(*strTarget);
					if(!strTarget.TextSize())
						continue;// we are not installing the target or the target is absent
					piShortcutRec->SetMsiString(FileName, *strTarget);			
				}
			}
			if(!piRec->IsNull(irsArguments))
				piShortcutRec->SetMsiString(Arguments, *MsiString(riEngine.FormatText(*MsiString(piRec->GetMsiString(irsArguments)))));
			if(!piRec->IsNull(irsWkDir))
				piShortcutRec->SetMsiString(WorkingDir, *MsiString(riEngine.GetProperty(*MsiString(piRec->GetMsiString(irsWkDir)))));
			if(!piRec->IsNull(irsIcon))
				piShortcutRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(irsIcon)));
			if(!piRec->IsNull(irsIconIndex))
				piShortcutRec->SetInteger(IconIndex, piRec->GetInteger(irsIconIndex));
			if(!piRec->IsNull(irsHotkey))
				piShortcutRec->SetInteger(HotKey, piRec->GetInteger(irsHotkey));
			if(!piRec->IsNull(irsShowCmd))
				piShortcutRec->SetInteger(ShowCmd, piRec->GetInteger(irsShowCmd));
			if(!piRec->IsNull(irsDescription))
				piShortcutRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(irsDescription)));
		}
		else
		{
			using namespace IxoShortcutRemove;

			MsiString strTarget = piRec->GetMsiString(iusTarget);
			if (!fAdvertisable && !strTarget.Compare(iscStart, TEXT("[")))
				continue;  // skip shortcuts that are advertisable, for this phase we're handling non-advertisable shortcuts

			if(fCreateADVTShortcuts && fAdvertisable && (piRec->GetInteger(iusFeatureAction) == iisAdvertise))
				continue;// we do not delete the shortcut if we are in pure advertise state AND system supports DD shortcuts

			if(!fCreateADVTShortcuts && fAdvertisable &&  (piRec->GetInteger(iusComponentAction) != iisAbsent))
				continue; // skip removing shortcuts to components that are shared

			piShortcutRec= &piServices->CreateRecord(Args);
			piShortcutRec->SetMsiString(Name, *strShortcutName);
		}

		if ((iesRet = riEngine.ExecuteRecord((fRemove == fFalse)?ixoShortcutCreate:ixoShortcutRemove, *piShortcutRec)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

const ICHAR sqlGetFeatureInfo[] = TEXT("SELECT `ComponentId` FROM `FeatureComponents`, `Component` WHERE `Component` = `Component_` AND `Feature_` = ?");
const ICHAR sqlEnumeratePublishUnavailableFeatures[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE `Feature`.`Action` = 0 AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumeratePublishUnavailableFeaturesReinstall[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE (`Feature`.`Action` = 0 OR (`Feature`.`Action` = null AND `Feature`.`Installed` = 0)) AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumeratePublishUnavailableFeaturesFirstRun[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE (`Feature`.`Installed` = null OR `Feature`.`Installed` = 0) AND (`Feature`.`Action` = null OR `Feature`.`Action` = 0 OR `Feature`.`Action` = 3) AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumeratePublishAvailableFeatures[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlEnumeratePublishAvailableFeaturesGPT[]  = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE `Feature`.`Action` = 4");
const ICHAR sqlEnumeratePublishUnavailableFeaturesGPT[]= TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE (`Feature`.`Action` = null OR `Feature`.`Action` = 0) AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumerateUnPublishFeatures[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE `Feature`.`RuntimeLevel` > 0");


iesEnum ProcessFeaturesInfo(IMsiEngine& riEngine, pfiStates pfis)
{
	enum pfiFeatureInfo{
		pfiFeature = 1,
		pfiFeatureParent,
	};

	enum pfciFeatureComponentInfo{
		pfciComponent = 1,
	};


	PMsiServices piServices(riEngine.GetServices()); 
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();
	int iPublishFeatureFlags = 0;

	bool fQFEUpgrade = false;
	MsiString strQFEUpgrade = riEngine.GetPropertyFromSz(IPROPNAME_QFEUPGRADE);
	if(strQFEUpgrade.TextSize())
		fQFEUpgrade = true;


	const ICHAR* szQuery;
	switch(pfis)
	{
	case pfiAvailable:
		szQuery = (fMode & iefAdvertise) ? sqlEnumeratePublishAvailableFeaturesGPT : sqlEnumeratePublishAvailableFeatures;
		break;
	case pfiRemove:
		szQuery = sqlEnumerateUnPublishFeatures;
		break;
	case pfiAbsent:
	{
		iPublishFeatureFlags = iPublishFeatureAbsent;
		if(fMode & iefAdvertise)
			szQuery = sqlEnumeratePublishUnavailableFeaturesGPT;
		else
		{
			INSTALLSTATE is = MSI::MsiQueryProductState(MsiString(riEngine.GetProductKey()));
			szQuery = (is == INSTALLSTATE_UNKNOWN || is == INSTALLSTATE_ABSENT) ? sqlEnumeratePublishUnavailableFeaturesFirstRun : (fQFEUpgrade ? sqlEnumeratePublishUnavailableFeaturesReinstall : sqlEnumeratePublishUnavailableFeatures);
		}
		break;
	}
	default:
		Assert(0);// should never be here, this is our own private function can afford to assert
		szQuery = TEXT("");
		break;
	}


	if(!(fMode & iefAdvertise))
		iPublishFeatureFlags |= iPublishFeatureInstall;
	PMsiView piEnumFeatureView(0);
	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piEnumFeatureView)) ||
		(pError = piEnumFeatureView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	PMsiRecord piEnumRec(0);
	PMsiView piFeatureView(0);

	while(piEnumRec = piEnumFeatureView->Fetch())
	{
		using namespace IxoFeaturePublish;

		MsiString strFeature = piEnumRec->GetMsiString(pfiFeature);
		MsiString strFeatureParent = piEnumRec->GetMsiString(pfiFeatureParent);
		if(strFeatureParent.Compare(iscExact, strFeature))
			strFeatureParent = TEXT("");
		long lRowCount = 0;
		if (iPublishFeatureFlags & iPublishFeatureInstall)
		{
			if (piFeatureView == 0)
			{
				if(	(pError = riEngine.OpenView(sqlGetFeatureInfo, ivcFetch, *&piFeatureView)))
				{
					if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
						return riEngine.FatalError(*pError);
				}
			}
			else
				piFeatureView->Close();

			if((pError = piFeatureView->Execute(piEnumRec)) ||
			   (pError = piFeatureView->GetRowCount(lRowCount)))
			{
				return riEngine.FatalError(*pError);
			}
		}
		PMsiRecord piFeatureRec(0);
		int cCount = Args;
		piFeatureRec = &piServices->CreateRecord((lRowCount - 1) + Args);
		piFeatureRec->SetMsiString(Feature, *strFeature);
		piFeatureRec->SetMsiString(Parent, *strFeatureParent);
		piFeatureRec->SetInteger(Absent, iPublishFeatureFlags);
		if(lRowCount)
		{
			PMsiRecord piComponentRec(0);
			MsiString strComponentsList;
			while(piComponentRec = piFeatureView->Fetch())
			{
				if(!piComponentRec->IsNull(pfciComponent)) // skip components with null component id
				{
					// pack components on the client side into one string
					ICHAR szSQUID[cchComponentIdCompressed+1];
					AssertNonZero(PackGUID(piComponentRec->GetString(pfciComponent), szSQUID, ipgCompressed));
					strComponentsList += szSQUID;
				}
			}
			piFeatureRec->SetMsiString(cCount++, *strComponentsList);
		}
		if ((iesRet = riEngine.ExecuteRecord((pfis == pfiRemove)?ixoFeatureUnpublish :ixoFeaturePublish, *piFeatureRec)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

const ICHAR sqlUnpublishComponents[] = TEXT("SELECT `PublishComponent`.`ComponentId`, `PublishComponent`.`Qualifier`, `PublishComponent`.`AppData`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND (`Feature`.`Action` = 0 OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlPublishComponents[]   = TEXT("SELECT `PublishComponent`.`ComponentId`, `PublishComponent`.`Qualifier`, `PublishComponent`.`AppData`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlPublishComponentsGPT[]= TEXT("SELECT `PublishComponent`.`ComponentId`, `PublishComponent`.`Qualifier`, `PublishComponent`.`AppData`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND `Feature`.`Action` = 4");

iesEnum ProcessComponentsInfo(IMsiEngine& riEngine, int fRemove)
{
	enum pciEnum
	{
		pciComponentId = 1,
		pciQualifier,
		pciAppData,
		pciFeature,
		pciComponent,
		pciComponentRuntimeFlags,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();

	// advertise the component factories for cross-product usage
	PMsiView piView(0);
	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlPublishComponentsGPT: (fRemove == fFalse) ? sqlPublishComponents : sqlUnpublishComponents;

	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if (pError)
		{
			if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
				return riEngine.FatalError(*pError);
			else
				return iesNoAction;
		}
	}
	PMsiRecord piRec(0);
	while(piRec = piView->Fetch())
	{
		using namespace IxoComponentPublish;

		Assert(piRec->GetInteger(pciComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(pciComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		PMsiRecord piComponentRec = &piServices->CreateRecord(Args);
		piComponentRec->SetMsiString(ComponentId, *MsiString(piRec->GetMsiString(pciComponentId)));
		if(!piRec->IsNull(pciQualifier))
			piComponentRec->SetMsiString(Qualifier, *MsiString(piRec->GetMsiString(pciQualifier)));
		if(!piRec->IsNull(pciAppData))
			piComponentRec->SetMsiString(AppData, *MsiString(piRec->GetMsiString(pciAppData)));			

		MsiString strFeature = piRec->GetMsiString(pciFeature);
		MsiString strComponentId = piRec->GetMsiString(pciComponent);
		MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
		piComponentRec->SetMsiString(Feature, *strFeature);
		piComponentRec->SetMsiString(Component, *strComponentWithOptFlags);
		if ((iesRet = riEngine.ExecuteRecord((fRemove == fFalse)?ixoComponentPublish:ixoComponentUnpublish, *piComponentRec)) != iesSuccess)
			return iesRet;
	}
	return iesRet;
}


// fn: remove assembly registration corr. to a component
// used during qfe upgrades when assembly names might have potentially changed
iesEnum UnpublishPreviousAssembly(IMsiEngine& riEngine, iatAssemblyType iatAssemblyType, const IMsiString& ristrAppCtx, const IMsiString& riFeature, const IMsiString& riComponent, const IMsiString & ristrDescriptor)
{
	CTempBuffer<ICHAR, MAX_PATH> rgchAppCtxWOBS;
	if(ristrAppCtx.TextSize())
	{
		// we need to replace the backslashes in the AppCtx with something else, since registry keys cannot
		// have backslashes
		DWORD cchLen = ristrAppCtx.TextSize() + 1;
		rgchAppCtxWOBS.SetSize(cchLen);
		memcpy((ICHAR*)rgchAppCtxWOBS, (const ICHAR*)ristrAppCtx.GetString(), cchLen*sizeof(ICHAR));
		ICHAR* lpTmp = rgchAppCtxWOBS;
		while(*lpTmp)
		{
			if(*lpTmp == '\\')
				*lpTmp = '|';
			lpTmp = ICharNext(lpTmp);
		}
	}

	DWORD iIndex = 0;
	ICHAR rgchAssemblyName[MAX_PATH];
	DWORD cchAssemblyName = MAX_PATH;
	ICHAR rgchDescriptorList[1024];
	DWORD cchDescriptorList = 1024;

	DWORD dwAssemblyInfo = (iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType) ? MSIASSEMBLYINFO_WIN32ASSEMBLY : MSIASSEMBLYINFO_NETASSEMBLY;
	extern UINT EnumAssemblies(DWORD dwAssemblyInfo,const ICHAR* szAppCtx, DWORD iIndex, ICHAR* lpAssemblyNameBuf, DWORD *pcchAssemblyBuf, ICHAR* lpDescriptorBuf, DWORD *pcchDescriptorBuf);// from msinst.cpp

	while(EnumAssemblies(dwAssemblyInfo, ristrAppCtx.TextSize() ? (const ICHAR*)rgchAppCtxWOBS : szGlobalAssembliesCtx, iIndex++, rgchAssemblyName, &cchAssemblyName, rgchDescriptorList, &cchDescriptorList) == ERROR_SUCCESS)
	{
		// is our descriptor in this 
		const ICHAR* szDescriptorList = rgchDescriptorList;
		while(*szDescriptorList)
		{
			if(ristrDescriptor.Compare(iscExactI, szDescriptorList))
			{
				// set up the assembly registration for removal
				using namespace IxoAssemblyUnpublish;
				PMsiServices piServices(riEngine.GetServices()); 
				PMsiRecord piAssemblyRec = &piServices->CreateRecord(Args);
				piAssemblyRec->SetInteger(AssemblyType,(int)iatAssemblyType);
				piAssemblyRec->SetString(AssemblyName, rgchAssemblyName);
				if(ristrAppCtx.TextSize())
					piAssemblyRec->SetMsiString(AppCtx, ristrAppCtx);

				piAssemblyRec->SetMsiString(Feature, riFeature);
				piAssemblyRec->SetMsiString(Component, riComponent);

				iesEnum iesRet;
				if ((iesRet = riEngine.ExecuteRecord(ixoAssemblyUnpublish, *piAssemblyRec)) != iesSuccess)
					return iesRet;
			}
			// continue on to the next descriptor in the list
			szDescriptorList = szDescriptorList + lstrlen(szDescriptorList) + 1;
		}
		// reset the buffer sizes
		cchAssemblyName = MAX_PATH;
		cchDescriptorList = 1024;
	}
	return iesSuccess;
}

const ICHAR sqlPublishPvtAssemblies[]   = TEXT("SELECT `File`.`FileName`, `Component_Parent`.`Directory_`, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`, `File`, `Component` AS `Component_Parent` WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = `File`.`File` AND `File`.`Component_` =  `Component_Parent`.`Component` AND ")
										  TEXT("(`Component_Parent`.`ActionRequest` = 1 OR `Component_Parent`.`ActionRequest` = 2 OR (`Component_Parent`.`ActionRequest` = null AND (`Component_Parent`.`Action`= 1 OR `Component_Parent`.`Action`= 2))) ");

const ICHAR sqlUnpublishPvtAssemblies[] = TEXT("SELECT `File`.`FileName`, `Component_Parent`.`Directory_`, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`, `File`, `Component`  AS `Component_Parent` WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = `File`.`File` AND `File`.`Component_` =  `Component_Parent`.`Component` AND ")
										  TEXT("`Component_Parent`.`ActionRequest` = 0");

const ICHAR sqlPublishAssembliesGPT[]   = TEXT("SELECT null, null, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`  WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = null AND ")
										  TEXT("`Feature`.`Action` = 4");
const ICHAR sqlPublishAssemblies[]      = TEXT("SELECT null, null, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`  WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = null AND ")
										  TEXT("((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlUnpublishAssemblies[]    = TEXT("SELECT null, null, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`  WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = null AND ")
										  TEXT("(`Feature`.`Action` = 0 OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");

iesEnum ProcessAssembliesInfo(IMsiEngine& riEngine, int fRemove)
{
	enum pciEnum
	{
		paiAppCtx = 1,
		paiAppDirectory,
		paiComponent,
		paiFeature,
		paiComponentId,
		paiComponentRuntimeFlags,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();

	// advertise the assemblies
	for(int cCount = 0 ; cCount < 2; cCount++) // loop to advertise global and pvt assemblies
	{
		PMsiView piView(0);
		const ICHAR* szQuery;
		if(!cCount)
			szQuery = (fMode & iefAdvertise) ? sqlPublishAssembliesGPT: (fRemove == fFalse) ? sqlPublishAssemblies : sqlUnpublishAssemblies;
		else
			szQuery = (fRemove == fFalse) ? sqlPublishPvtAssemblies : sqlUnpublishPvtAssemblies;

		if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
			(pError = piView->Execute(0)))
		{
			if (pError)
			{
				if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
					return riEngine.FatalError(*pError);
				else
					return iesNoAction;
			}
		}
		PMsiRecord piRec(0);
		while(piRec = piView->Fetch())
		{
			using namespace IxoAssemblyPublish;

			Assert(piRec->GetInteger(paiComponentRuntimeFlags) != iMsiNullInteger);
			if(!fRemove && (piRec->GetInteger(paiComponentRuntimeFlags) & bfComponentDisabled))
				continue; // skip publishing for disabled "primary" components

			PMsiRecord piAssemblyRec = &piServices->CreateRecord(Args);

			// get the assembly name
			iatAssemblyType iatAssemblyType;
			MsiString strAssemblyName;
			if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(paiComponent)), iatAssemblyType, &strAssemblyName, 0)) != 0)
				return riEngine.FatalError(*pError);

			MsiString strAppCtx;
			if(!piRec->IsNull(paiAppCtx))
			{
				// advertising/unadvertising pvt assemblies
				// get the full file path that represents the parent's context
				PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
				PMsiPath pPath(0);
				if((pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetMsiString(paiAppDirectory)),*&pPath)) != 0)
					return riEngine.FatalError(*pError);

				Bool fLFN = (fMode & iefSuppressLFN) == 0 && pPath->SupportsLFN() ? fTrue : fFalse;

				MsiString strFile;
				if((pError = piServices->ExtractFileName(piRec->GetString(paiAppCtx),fLFN,*&strFile)) != 0)
					return riEngine.FatalError(*pError);

				if((pError = pPath->GetFullFilePath(strFile, *&strAppCtx)) != 0)
					return riEngine.FatalError(*pError);			
			}

			piAssemblyRec->SetInteger(AssemblyType,(int)iatAssemblyType);
			piAssemblyRec->SetMsiString(AssemblyName, *strAssemblyName);
			if(strAppCtx.TextSize())
				piAssemblyRec->SetMsiString(AppCtx, *strAppCtx);

			MsiString strFeature = piRec->GetMsiString(paiFeature);
			MsiString strComponentId = piRec->GetMsiString(paiComponentId);
			MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
			piAssemblyRec->SetMsiString(Feature, *strFeature);
			piAssemblyRec->SetMsiString(Component, *strComponentWithOptFlags);

			// set up removal of previous registration
			extern const IMsiString& ComposeDescriptor(const IMsiString& riProductCode, const IMsiString& riFeature, const IMsiString& riComponent, bool fComClassicInteropForAssembly);
			MsiString strDescriptor = ComposeDescriptor(*MsiString(riEngine.GetProductKey()), *strFeature, *strComponentWithOptFlags, false);

			// we need to accomodate the possibility of the assembly name order having changed
			// hence we seek out the previous registration associated with this product, feature, component and explicitly 
			// delete the same
			if((iesRet = UnpublishPreviousAssembly(riEngine, iatAssemblyType, *strAppCtx, *strFeature, *strComponentWithOptFlags, *strDescriptor)) != iesSuccess)
				return iesRet;
			if(!fRemove) // (re)register 
			{
				if ((iesRet = riEngine.ExecuteRecord(ixoAssemblyPublish, *piAssemblyRec)) != iesSuccess)
					return iesRet;
			}
		}
	}
	return iesRet;
}

/*---------------------------------------------------------------------------
	MsiPublishAssemblies action - 
---------------------------------------------------------------------------*/
iesEnum MsiPublishAssemblies(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessAssembliesInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	MsiUnpublishAssemblies action - 
---------------------------------------------------------------------------*/
iesEnum MsiUnpublishAssemblies(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessAssembliesInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	PublishSourceList action - 
---------------------------------------------------------------------------*/
const ICHAR sqlMediaInformation[] = TEXT("SELECT `DiskPrompt`, `VolumeLabel`, `DiskId` FROM `Media` ORDER BY `DiskId`");
const ICHAR sqlPatchMediaInformation[] = TEXT("SELECT `DiskPrompt`, `VolumeLabel`, `DiskId` FROM `Media`, `PatchPackage` WHERE `PatchPackage`.`Media_` = `DiskId`");


enum slmiEnum
{
	slmiDiskPrompt  = 1,
	slmiVolumeLabel,
	slmiDiskId,
};

const int ciMaxOpCodeSize = 254;
class CSourceListPublisher 
{
public:
	CSourceListPublisher(IMsiEngine& riEngine);
	iesEnum AddPatchInfo(const ICHAR *szPatchCode, const ICHAR* szPatchPackageName);
	
	iesEnum AddMediaSource(int iDiskId, const IMsiString &riVolumeLabel, const IMsiString &riDiskPrompt);
	iesEnum AddSource(const IMsiString &riSource);
	iesEnum Flush();

	inline void CSourceListPublisher::AddMediaPrompt(const IMsiString &riDiskPromptTemplate)
	{
		Assert(m_fFirst);
		if (!pSourceListRec)
			return;
		pSourceListRec->SetMsiString(IxoSourceListPublish::DiskPromptTemplate, riDiskPromptTemplate);
	}

	inline void CSourceListPublisher::AddMediaPath(const IMsiString &riMediaRelativePath)
	{
		Assert(m_fFirst);
		if (!pSourceListRec)
			return;
		pSourceListRec->SetMsiString(IxoSourceListPublish::PackagePath, riMediaRelativePath);
	}

private:
	IMsiEngine& m_riEngine;
	bool m_fFirst;
	int m_cArg;
	PMsiRecord pSourceListRec;
	MsiString m_strPatchCode;
	PMsiServices m_pServices;
};

CSourceListPublisher::CSourceListPublisher(IMsiEngine& riEngine) : m_fFirst(true), m_cArg(IxoSourceListPublish::NumberOfDisks+1), pSourceListRec(0), 
	m_riEngine(riEngine), m_pServices(riEngine.GetServices()), m_strPatchCode(TEXT(""))
{
	pSourceListRec = &m_pServices->CreateRecord(ciMaxOpCodeSize);
	if (pSourceListRec)
		pSourceListRec->SetInteger(IxoSourceListPublish::NumberOfDisks, 0);
}

iesEnum CSourceListPublisher::AddPatchInfo(const ICHAR *szPatchCode, const ICHAR* szPatchPackageName)
{
	if (!pSourceListRec)
		return iesFailure;
		
	using namespace IxoSourceListPublish;
	// full patch information is passed only in the ixoSourceListPublish opcode, so this 
	// must be our initial record. Only the patch code is passed in additional Append calls
	Assert(m_fFirst);
	if (szPatchCode)
	{
		m_strPatchCode = szPatchCode;
		pSourceListRec->SetString(PatchCode, szPatchCode);
	}

	if (szPatchPackageName)
		pSourceListRec->SetString(PatchPackageName, szPatchPackageName);

	return iesSuccess;
}

iesEnum CSourceListPublisher::AddMediaSource(int iDiskId, const IMsiString &riVolumeLabel, const IMsiString &riDiskPrompt)
{
	if (!pSourceListRec)
		return iesFailure;
		
	// if adding this media source to the record would push us over the limit,
	// execute this record and create a new one. The maximum we can fill is
	// max-2, max-1, and max.
	if (m_cArg > ciMaxOpCodeSize-2)
	{
		iesEnum iesRet = Flush();
		if (iesSuccess != iesRet)
			return iesRet;
	}

	// add the info for this media source to the end of the record
	pSourceListRec->SetInteger(m_cArg++, iDiskId);
	pSourceListRec->SetMsiString(m_cArg++, riVolumeLabel);
	pSourceListRec->SetMsiString(m_cArg++, riDiskPrompt);

	// increment the number of media entries in this record
	int iField = m_fFirst ? (int)IxoSourceListPublish::NumberOfDisks : (int)IxoSourceListAppend::NumberOfMedia;
	pSourceListRec->SetInteger(iField, pSourceListRec->GetInteger(iField)+1);
	return iesSuccess;
}

iesEnum CSourceListPublisher::AddSource(const IMsiString &riSource)
{
	if (!pSourceListRec)
		return iesFailure;

	// if we're over the limit for this record,
	if (m_cArg > ciMaxOpCodeSize)
	{
		iesEnum iesRet = Flush();
		if (iesSuccess != iesRet)
			return iesRet;
	}

	// add the info for this media source to the end of the record
	pSourceListRec->SetMsiString(m_cArg++, riSource);

	return iesSuccess;
}

iesEnum CSourceListPublisher::Flush()
{
	if (!pSourceListRec)
		return iesFailure;
		
	iesEnum iesRet = iesSuccess;
	// we only need to execute and flush this record if it has data.
	if (m_cArg != IxoSourceListAppend::NumberOfMedia+1)
	{
		if (m_fFirst)
		{
			m_fFirst = false;
			if (iesSuccess != (iesRet = m_riEngine.ExecuteRecord(ixoSourceListPublish, *pSourceListRec)))
				return iesRet;
		}
		else
		{
			if (iesSuccess != (iesRet = m_riEngine.ExecuteRecord(ixoSourceListAppend, *pSourceListRec)))
				return iesRet;
		}
		m_cArg = IxoSourceListAppend::NumberOfMedia+1;
		
		// writing the script record strips trailing null fields, so we can be generous instead of
		// re-allocating every time we run off the end of a record.
		for (int i=0; i <= ciMaxOpCodeSize; i++)
			pSourceListRec->SetNull(i);
//		pSourceListRec = &m_pServices->CreateRecord(ciMaxOpCodeSize);
		pSourceListRec->SetInteger(IxoSourceListAppend::NumberOfMedia, 0);
		pSourceListRec->SetString(IxoSourceListAppend::PatchCode, m_strPatchCode);
	}
	
	return iesRet;
}

iesEnum PublishSourceList(IMsiEngine& riEngine, const IMsiString& riSourceList, const ICHAR* szPatchCode, const ICHAR* sqlMedia, const ICHAR* szSourceDir, const ICHAR* szPatchPackageName=0)
{
	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());
	
	MsiString strSourceList = riSourceList; 
	riSourceList.AddRef();

	CSourceListPublisher ListPublisher(riEngine);
	
	// determine patch information and add it to the initial record
	// patch code and patch package must both be NULL or both set
	Assert(!szPatchCode == !szPatchPackageName);
	if (szPatchCode)
	{
		ListPublisher.AddPatchInfo(szPatchCode, szPatchPackageName);
	}

	unsigned int iSourceArg = 0;
	unsigned int cDisks = 0;
	bool fAddLaunchedSource = false;

	// determine the media-relative package path
	MsiString strSourceDir = szSourceDir;
	MsiString strMediaRelativePath;
	if(strSourceDir.TextSize())
	{
		// If our current source is media then we'll use it to determine our media package path, if
		// the media package path property isn't already set.
		
		PMsiPath pPath(0);
		if ((pError = pServices->CreatePath(strSourceDir, *&pPath)) != 0)
			return riEngine.FatalError(*pError);

		idtEnum idt = PMsiVolume(&pPath->GetVolume())->DriveType();
		if (idt == idtCDROM || idt == idtFloppy || idt == idtRemovable)
		{
			strMediaRelativePath = pPath->GetRelativePath();
		}
		else 
		{
			if (!szPatchCode)
				strMediaRelativePath = riEngine.GetPropertyFromSz(IPROPNAME_MEDIAPACKAGEPATH);

			if ( !g_MessageContext.IsOEMInstall() )
			{
				// if we're not running from media then we need to add the source we were launched from as a 
				// source for the product
				fAddLaunchedSource = true;
			}
		}

		if (strMediaRelativePath.TextSize())
			ListPublisher.AddMediaPath(*strMediaRelativePath);
	}

	// Add the media source information if we're not prohibited from doing so
	if (!MsiString(riEngine.GetPropertyFromSz(IPROPNAME_DISABLEMEDIA)).TextSize())
	{
		PMsiRecord pFetchRecord(0);
		PMsiView pView(0);
		long lRowCount;
		if((pError = riEngine.OpenView(sqlMedia, ivcFetch, *&pView)) ||
			(pError = pView->Execute(0)) || 
			(pError = pView->GetRowCount(lRowCount)))
			return riEngine.FatalError(*pError); //?? is this a fatal error
		
		MsiString strFirstVolumeLabel;
		ListPublisher.AddMediaPrompt(*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_DISKPROMPT)));

		// fetch every record from the media table, adding it to the list. 
		while ((pFetchRecord = pView->Fetch()) != 0)
		{
			MsiString strVolumeLabel = pFetchRecord->GetMsiString(slmiVolumeLabel);
			if (cDisks == 0)
			{
				strFirstVolumeLabel = strVolumeLabel;
			}
			
			// check if this is the first media disk
			// if so, we may need to replace the volume label from the Media table
			// NOTE: assumes that all Media table entries with same VolumeLabel as first entry
			//       represent the same (first) disk
			if (cDisks == 0 || strVolumeLabel.Compare(iscExact, strFirstVolumeLabel))
			{
				MsiString strCurrentLabel = riEngine.GetPropertyFromSz(IPROPNAME_CURRENTMEDIAVOLUMELABEL);

				// we are looking at a record representing the first media label
				// we allow the first disk's volume label to not match the real volume label
				// this is for authoring simplicity with single-volume installs
				
				//!! need to make sure proper label is used when migrating source list during a patch
				if (strCurrentLabel.TextSize())
				{
					if (strCurrentLabel.Compare(iscExact, szBlankVolumeLabelToken))
						strCurrentLabel = g_MsiStringNull;
					
					strVolumeLabel = strCurrentLabel;
				}
			}
			else if (pFetchRecord->IsNull(slmiVolumeLabel)) // if we're at disk 2 or higher then if we must not have any volume labels; if one's NULL then they all are
				break;

			cDisks++;
			iesEnum iesRet = ListPublisher.AddMediaSource(pFetchRecord->GetInteger(slmiDiskId), 
				*strVolumeLabel, *MsiString(pFetchRecord->GetMsiString(slmiDiskPrompt)));	
			if (iesRet != iesSuccess)
				return iesRet;
		} 
	}

	// add the launched-from source if not media (determined above)
	if (fAddLaunchedSource)
		ListPublisher.AddSource(*strSourceDir);
	
	// Add all sources that are in the SOURCELIST property

	if (strSourceDir.Compare(iscEnd, szRegSep))
		strSourceDir.Remove(iseLast, 1);

	strSourceList += TEXT(";"); // helps our loop

	while(strSourceList.TextSize())
	{
		MsiString strSource = strSourceList.Extract(iseUpto, ';');
		if (strSource.Compare(iscEnd, szRegSep))
			strSource.Remove(iseLast, 1);

		if (!strSource.Compare(iscExactI, strSourceDir))
		{
			if(strSource.TextSize())
			{
				ListPublisher.AddSource(*strSource);
			}
		}
		//?? else error??
		strSourceList.Remove(iseIncluding, ';');
	}
	
	return ListPublisher.Flush();
}

iesEnum GetForeignSourceList(IMsiEngine& riEngine, const IMsiString& ristrProduct,
									  const IMsiString*& rpistrForeignSourceList)
// reads source list for another product and returns SOURCELIST-like string
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiRecord pError(0);
	LONG lResult = 0;
	
	CRegHandle HKey;
	if ((lResult = OpenSourceListKey(ristrProduct.GetString(), fFalse, HKey, fFalse, false)) != ERROR_SUCCESS)
	{
		pError = PostError(Imsg(idbgSrcOpenSourceListKey), (int)lResult);
		return riEngine.FatalError(*pError);
	}

	PMsiRegKey pSourceListKey = &pServices->GetRootKey((rrkEnum)(int)HKey, ibtCommon);

	PEnumMsiString pEnumString(0);
	MsiString strSourceList;
	MsiString strSource;

	for(int i=0;i<2;i++) // i == 0: net key; i == 1: url key
	{
		PMsiRegKey pSourceListSubKey = &pSourceListKey->CreateChild((i == 0 ? szSourceListNetSubKey : szSourceListURLSubKey));

		if ((pError = pSourceListSubKey->GetValueEnumerator(*&pEnumString)) != 0)
		{
			return riEngine.FatalError(*pError);
		}

		MsiString strIndex;
		while (pEnumString->Next(1, &strIndex, 0) == S_OK)
		{
			if ((pError = pSourceListSubKey->GetValue(strIndex, *&strSource)) != 0)
				return riEngine.FatalError(*pError);

			if (strSource.Compare(iscStart, TEXT("#%"))) 
				strSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token
			
			strSourceList += strSource;
			strSourceList += MsiChar(';');
		}
	}
	
	strSourceList.ReturnArg(rpistrForeignSourceList);
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	PublishProduct action - 
---------------------------------------------------------------------------*/
// we advertise information that needs to be placed with the configuration manager
const ICHAR sqlAdvertiseIcons[] = TEXT("SELECT `Name`, `Data` FROM `Icon`");
const ICHAR sqlEnumerateInstalledFeatures[] = TEXT("SELECT `Feature` FROM `Feature` WHERE `Feature`.`Action` = 1 OR `Feature`.`Action` = 2 OR `Feature`.`Action` = 4");

const ICHAR sqlRegisterPatchPackages[] = TEXT("SELECT `PatchId`, `PackageName`, `SourceList`, `TransformList`, `TempCopy`, `Existing`, `Unregister`, `SourcePath` FROM `#_PatchCache` ORDER BY `Sequence`");
const ICHAR sqlUnregisterPatchPackages[] = TEXT("SELECT `PatchId` FROM `#_PatchCache`");

enum sppEnum
{
	sppPatchId = 1,
	sppPackageName,
	sppSourceList,
	sppTransformList,
	sppTempCopy,
	sppExisting,
	sppUnregister,
	sppSourcePath,
};

// local function that returns the source path for a child install, relative to the parent's
IMsiRecord* GetProductSourcePathRelativeToParent(IMsiEngine& riEngine, const IMsiString*& rpistrRelativePath)
{
	MsiString istrDatabase = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	if (*(const ICHAR*)istrDatabase == ':')  // substorage
	{
		istrDatabase.ReturnArg(rpistrRelativePath);  // return prefixed substorage name
		return 0;
	}

	PMsiServices pServices(riEngine.GetServices());

	MsiString strParent = riEngine.GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);
	MsiString strProduct = riEngine.GetProductKey();
	MsiString strDummy;

	if (ProductHasBeenPublished(*pServices, strProduct, strParent))
	{
		AssertNonZero(GetClientInformation(*pServices, strProduct, strParent, rpistrRelativePath, *&strDummy));
		return 0;
	}
	else
	{
		IMsiRecord* piErrRec;
		PMsiServices piServices(riEngine.GetServices()); 
		PMsiPath pPath(0), pParentPath(0);
		MsiString istrFileName;
		if (((piErrRec =  piServices->CreateFilePath(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PARENTORIGINALDATABASE)),*&pParentPath,*&istrFileName)) != 0) ||
			 ((piErrRec = piServices->CreateFilePath(istrDatabase, *&pPath, *&istrFileName)) != 0))
		{
			return piErrRec;
		}

		//!! validation needs to ensure that the child package locations is in the same directory or a subdir of the one that the parent is in
	#ifdef DEBUG
		ipcEnum ipc;
		AssertRecord(pParentPath->Compare(*pPath, ipc));
		AssertSz(ipc == ipcChild || ipc == ipcEqual, "Child package must be in the same directory, or in a subdirectory, as the parent package");
	#endif	

		return piErrRec = pPath->Child(*pParentPath, rpistrRelativePath);
	}
}


iesEnum CreatePublishProductRecord(IMsiEngine& riEngine, bool fUnpublish, IMsiRecord*& pPublishRecord)
{
	iesEnum iesRet = iesSuccess;
	PMsiServices piServices(riEngine.GetServices()); 
	PMsiRecord pError(0);

	Assert(IxoProductPublish::PackageKey == IxoProductUnpublish::PackageKey);

	// ixoProductPublish
	// Record description
	// package key
	// transform name1
	// transform data1 (if file transform)
	// transform name2
	// transform data2 (if file transform)
	// ...
	// ...
	
	MsiString strTransformList(riEngine.GetPropertyFromSz(IPROPNAME_TRANSFORMS));

	// Create a record large enough to hold all of the transforms that are in our list.
	const ICHAR* pchTransformList = strTransformList;
	int cCount = 0;
	while(*pchTransformList != 0)
	{
		cCount++;
		while((*pchTransformList != 0) && (*pchTransformList++ != ';'));
	}
	pPublishRecord = &piServices->CreateRecord(IxoProductPublish::PackageKey+cCount*2); // max possible record size

	AssertNonZero(pPublishRecord->SetMsiString(IxoProductPublish::PackageKey,*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PACKAGECODE))));

	// There's nothing more to do if we're unpublishing. We rely on the transforms
	// information that's in the registry to unpublish. We'll grab the info out
	// of the registry in the executor. Why not here? Because when we unpublish
	// a product during app deployment we'll need to be able to grab the transforms
	// list from the registry to unpublish the product. Therefore it needs to be in 
	// the executor.
	
	if (!fUnpublish)
	{
		cCount = IxoProductPublish::PackageKey + 1;
		
		bool fTransformsSecure = false;

		while(strTransformList.TextSize() != 0)
		{
			MsiString strTransform = strTransformList.Extract(iseUpto, ';');
			
			ICHAR chFirst = *(const ICHAR*)strTransform;
			
			if (cCount == IxoProductPublish::PackageKey + 1) // first transform
			{
				// The token preceding the first transform tells us whether
				// we're dealing with secure transforms or not.
				if (chFirst == SECURE_RELATIVE_TOKEN || 
					 chFirst == SECURE_ABSOLUTE_TOKEN)
				{
					fTransformsSecure = true;
				}
			}

			// For the purposes of this code we have two kinds of transforms:
			// Those that we store just the name, and those that we store
			// the name plus the data. Secure and storage transforms are of the
			// first kind and regular cached file transforms are of the second 
			// kind. We store the data for cached file transforms in the script
			// so that the transforms can be spit onto the machine during
			// app deployment. Although we also cache secure transforms, we
			// do not do so at advertise time and therefore do not need
			// to put them into the script.

			if((chFirst == STORAGE_TOKEN) ||
				(fTransformsSecure))
			{
				// unless we're publishing the product for the 2nd time
				// (which we never should be) we should never see a 
				// ShellFolder token here.
				Assert(chFirst != SHELLFOLDER_TOKEN); 
																	
				pPublishRecord->SetMsiString(cCount++, *strTransform);
			}
			else // transform is a cached file transform
			{
				// need to see if the transform is a URL, and if so, get it's actual location
				// in the URL cache (should already have been downloaded by Engine.InitializeTransforms
				bool fNet = false;

				MsiString strActualTransform(strTransform);

				if ((fNet = FIsNetworkVolume(strTransform)) == true)
					MsiDisableTimeout();

				INTERNET_SCHEME isType;
				Bool fUrl = fFalse;
				if (IsURL(strTransform, &isType))
				{
					MsiString strCache;
					
					DWORD dwRet = DownloadUrlFile(strTransform, *&strCache, fUrl);

					// if the file isn't found, we'll simply let this fall through to the piServices->CreateFileStream.
					// it will create an appropriate error.

					if (fUrl && (ERROR_SUCCESS == dwRet))
						strActualTransform = strCache;
				}

				if (fNet)
					MsiEnableTimeout();

				pPublishRecord->SetMsiString(cCount++, *strTransform);

				// stick the transform into the script
				PMsiStream pStream(0);
				if(pError = piServices->CreateFileStream(strActualTransform, fFalse, *&pStream))
				{
					Assert(0); // we should have already found the transform in Engine.Initialize.
					return riEngine.FatalError(*pError);
				}

				pPublishRecord->SetMsiData(cCount++, pStream);
			}

			strTransformList.Remove(iseFirst, strTransform.CharacterCount());
			if((*(const ICHAR*)strTransformList == ';'))
				strTransformList.Remove(iseFirst, 1);
		}
	}
	return iesRet;
}

iesEnum PublishProduct(IMsiEngine& riEngine)
{
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();
	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiView piView(0);
	PMsiRecord pExecuteRecord(0);
	PMsiRecord pFetchRecord(0);
	PMsiRecord pError(0);
	Bool fFeaturesInstalled = FFeaturesInstalled(riEngine);
	Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()));

	// write the AdvtFlags
	if(fProductHasBeenPublished && !(riEngine.GetMode() & iefAdvertise) && fFeaturesInstalled && ((fMode & iefInstallShortcuts) || (fMode & iefInstallMachineData)))
	{
		// get the AdvtFlags
		int iADVTFlagsExisting = 0;
		int iADVTFlags = 0;
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		if(GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
			iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

		//!! backward compatibility 
		if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
			iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

		if((fMode & iefInstallShortcuts) && !(iADVTFlagsExisting & SCRIPTFLAGS_SHORTCUTS))
			iADVTFlags |= SCRIPTFLAGS_SHORTCUTS;

		if((fMode & iefInstallMachineData) && (!(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) || !(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO)))
			iADVTFlags |= SCRIPTFLAGS_REGDATA_APPINFO;

		if(iADVTFlags)
		{
			// need to write the updated AdvtFlags
			using namespace IxoAdvtFlagsUpdate;
			PMsiRecord pExecuteRecord = &piServices->CreateRecord(Args);
			pExecuteRecord->SetInteger(Flags, iADVTFlags | iADVTFlagsExisting);
			if ((iesRet = riEngine.ExecuteRecord(ixoAdvtFlagsUpdate, *pExecuteRecord)) != iesSuccess)
				return iesRet;
		}
	}
	bool fPublishProduct = ((riEngine.GetMode() & iefAdvertise) || ((!fProductHasBeenPublished) && (fFeaturesInstalled)));

	MsiString strReinstall = riEngine.GetPropertyFromSz(IPROPNAME_REINSTALL);

	if (((fMode & iefInstallShortcuts) || (fMode & iefInstallMachineData)) && (strReinstall.TextSize() || fPublishProduct))
	{
		// do icons
		// ixoIconCreate
		// Record description
		// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
		// 2 = IconData

		pError = riEngine.OpenView(sqlAdvertiseIcons, ivcFetch, *&piView);
		if (!pError)
		{
			if (!(pError = piView->Execute(0)))
			{
				while (pFetchRecord = piView->Fetch())
				{
					PMsiData pData = pFetchRecord->GetMsiData(2);
					if(!pData)
					{
						pError = PostError(Imsg(idbgStreamNotFoundInRecord),
										  *MsiString(TEXT("Icon.Data")),
										  *MsiString(pFetchRecord->GetMsiString(1)));
						return riEngine.FatalError(*pError);
					}
					
					using namespace IxoIconCreate;
					pExecuteRecord = &piServices->CreateRecord(Args);
					pExecuteRecord->SetMsiString(Icon, *MsiString(pFetchRecord->GetMsiString(1)));
					pExecuteRecord->SetMsiData(Data, pData);
					if ((iesRet = riEngine.ExecuteRecord(ixoIconCreate, *pExecuteRecord)) != iesSuccess)
						return iesRet;
				}
			}
			else
			{
				return riEngine.FatalError(*pError);
			}

		}
		else // pError != 0
		{
			if (pError->GetInteger(1) != idbgDbQueryUnknownTable)
			{
				return riEngine.FatalError(*pError);
			}
		}
	}

	if(fFeaturesInstalled && (fMode & iefRecachePackage))
	{
		if (MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PACKAGECODE_CHANGING)).TextSize() != 0)
		{
			using namespace IxoPackageCodePublish;
			MsiString strPackageCode = riEngine.GetPropertyFromSz(IPROPNAME_PACKAGECODE);

			pExecuteRecord = &piServices->CreateRecord(Args);
			pExecuteRecord->SetMsiString(PackageKey, *strPackageCode);		

			if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
				return iesRet;
		}
	}

	if(!(fMode & iefInstallMachineData))
		return iesSuccess;

	// register and cache any patches that need it
	// now we are safe to try to open the view
	if(fPublishProduct || fFeaturesInstalled)
	{
		if((pError = riEngine.OpenView(sqlRegisterPatchPackages, ivcFetch, *&piView)) == 0 &&
			(pError = piView->Execute(0)) == 0)
		{		
			while((pFetchRecord = piView->Fetch()) != 0)
			{
				MsiString strPatchId = pFetchRecord->GetMsiString(sppPatchId);
				MsiString strPackageName = pFetchRecord->GetMsiString(sppPackageName);
				Assert(strPatchId.TextSize());
				if(pFetchRecord->GetInteger(sppUnregister) == 1) // Unregister column
				{
					// need to unregister this patch
					pExecuteRecord = &piServices->CreateRecord(2); // for ixoPatchUnregister and ixoSourceListUnpublish
					AssertNonZero(pExecuteRecord->SetMsiString(1,*strPatchId));
					AssertNonZero(pExecuteRecord->SetMsiString(2,*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_UPGRADINGPRODUCTCODE))));
					if((iesRet = riEngine.ExecuteRecord(ixoPatchUnregister,*pExecuteRecord)) != iesSuccess)
						return iesRet;
					if((iesRet = riEngine.ExecuteRecord(ixoSourceListUnpublish,*pExecuteRecord)) != iesSuccess)
						return iesRet;

				}
				else
				{
					bool fExisting = pFetchRecord->GetInteger(sppExisting) == 1;
					// need to register this patch if this is a new patch (!fExisting)
					// or this product hasn't been published yet and existing patches must be added
					// in the latter case we won't register the source list since it is already registered
					if(!fExisting || fPublishProduct)
					{
						// need to register this patch
						Assert(strPatchId.TextSize());
						Assert(!pFetchRecord->IsNull(sppTransformList));
						pExecuteRecord = &piServices->CreateRecord(IxoPatchRegister::Args);
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchRegister::PatchId,*strPatchId));
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchRegister::TransformList,*MsiString(pFetchRecord->GetMsiString(sppTransformList))));

						if((iesRet = riEngine.ExecuteRecord(ixoPatchRegister,*pExecuteRecord)) != iesSuccess)
							return iesRet;

						if(!fExisting)
						{
							// new patch - register source list
							MsiString strSourceList = pFetchRecord->GetMsiString(sppSourceList);
							MsiString strPackagePath = pFetchRecord->GetMsiString(sppSourcePath);
							MsiString strFileName;
							
							PMsiPath pPatchPath(0);
							if ((pError = piServices->CreateFilePath(strPackagePath, *&pPatchPath, *&strFileName)) == 0)
							{
								strPackagePath.Remove(iseLast, strFileName.CharacterCount());
							}

							if ((iesRet = PublishSourceList(riEngine, *strSourceList, strPatchId, sqlPatchMediaInformation, strPackagePath, strPackageName)) != iesSuccess)
								return iesRet;
						}
					}

					MsiString strTempCopy = pFetchRecord->GetMsiString(sppTempCopy);
					if(strTempCopy.TextSize())
					{
						// need to cache this patch
						pExecuteRecord = &piServices->CreateRecord(IxoPatchCache::Args);
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchCache::PatchId,*strPatchId));
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchCache::PatchPath,*strTempCopy));

						if((iesRet = riEngine.ExecuteRecord(ixoPatchCache,*pExecuteRecord)) != iesSuccess)
							return iesRet;
					}
				}
			}	
		}
		else if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
		{
			return riEngine.FatalError(*pError);
		}
		// else no error
	}

	if (fPublishProduct)
	{
		// advertise product
		// we advertise product and output the icons if
		// 1. we are operating in the advertise mode OR
		// 2. we have not advertised on this m/c.

		
		if ((iesRet = CreatePublishProductRecord(riEngine, false, *&pExecuteRecord)) != iesSuccess)
			return iesRet;

		if((iesRet = riEngine.ExecuteRecord(ixoProductPublish, *pExecuteRecord)) != iesSuccess)
			return iesRet;// error

		MsiString strUpgradeCode = riEngine.GetPropertyFromSz(IPROPNAME_UPGRADECODE);
		if(strUpgradeCode.TextSize())
		{
			pExecuteRecord = &piServices->CreateRecord(IxoUpgradeCodePublish::Args);
			AssertNonZero(pExecuteRecord->SetMsiString(IxoUpgradeCodePublish::UpgradeCode, *strUpgradeCode));

			if((iesRet = riEngine.ExecuteRecord(ixoUpgradeCodePublish, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}
	}
	else if (fFeaturesInstalled) // we're not publishing or unpublishing the product
										  // but may need to do some extra stuff anyway
	{

		if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_QFEUPGRADE)).TextSize() != 0)
		{
			// we didn't publish the product above, but we are patching or installing from a new package
			// so we use ixoProductPublishUpdate to register the new product name or version if
			// necessary

			DEBUGMSG(TEXT("Re-publishing product - installing new package with existing product code."));

			Assert(fProductHasBeenPublished);
			pExecuteRecord = &piServices->CreateRecord(0);
			if((iesRet = riEngine.ExecuteRecord(ixoProductPublishUpdate, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}
	}

	if (fFeaturesInstalled)
	{
		// we might have some transforms that need to be cached again. this happens
		// if someone deletes his cached transform. we need to copy it back
		// down from the source. we'll cheat and use ixoIconCreate because
		// it does what we want to do

		MsiString strRecache = riEngine.GetPropertyFromSz(IPROPNAME_RECACHETRANSFORMS);

		bool fTransformsSecure = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_TRANSFORMSSECURE)).TextSize() != 0;
		strRecache += TEXT(";"); // helps our loop
		while(strRecache.TextSize())
		{
			MsiString strTransform = strRecache.Extract(iseUpto, ';');
			if(strTransform.TextSize())
			{
				ixoEnum ixo = ixoNoop;
				PMsiRecord pExecuteRecord(0);

				if (fTransformsSecure)
				{
					using namespace IxoSecureTransformCache;
					pExecuteRecord = &piServices->CreateRecord(Args);

					ixo = ixoSecureTransformCache;
					pExecuteRecord->SetString(Transform, strTransform);

					// are the transforms full path or "at source" (relative)
					MsiString strTransforms = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMS));
					if(*(const ICHAR*)strTransforms == SECURE_RELATIVE_TOKEN)
						pExecuteRecord->SetInteger(AtSource, 1);

					DEBUGMSG1(TEXT("Recaching secure transform: %s"), strTransform);
				}
				else
				{
					PMsiPath pPath(0);
					MsiString strFileName;
					
					ixo = ixoIconCreate;
					if ((pError = piServices->CreateFilePath(strTransform, *&pPath, *&strFileName)))
					{
						riEngine.Message(imtInfo, *pError);
					}
					else
					{
						using namespace IxoIconCreate;
						pExecuteRecord = &piServices->CreateRecord(Args);

						// pass on only the file name
						pExecuteRecord->SetString(Icon, strFileName);

						// cache the transform
						PMsiStream pStream(0);
						if(pError = piServices->CreateFileStream(strTransform, fFalse, *&pStream))
						{
							return riEngine.FatalError(*pError);
						}

						DEBUGMSG1(TEXT("Recaching cached transform: %s"), strTransform);

						pExecuteRecord->SetMsiData(Data, pStream);
					}
				}

				if((iesRet = riEngine.ExecuteRecord(ixo, *pExecuteRecord)) != iesSuccess)
					return iesRet;
				
			}
			strRecache.Remove(iseIncluding, ';');
		}
	}

	MsiString strSource;
	MsiString strParent = riEngine.GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);

	MsiString strProductCode = riEngine.GetProductKey();

	bool fPublishClientInfo   = ((riEngine.GetMode() & iefAdvertise) || (!ProductHasBeenPublished(*piServices, strProductCode, strParent) && (fFeaturesInstalled)));

	if (fPublishClientInfo)
	{
		if ((strParent.TextSize() == 0) && fPublishClientInfo) // don't publish source lists for child installs
		{
			MsiString strSourceDir  = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIR);
			if (!strSourceDir.TextSize())
			{
				riEngine.ResolveFolderProperty(*MsiString(*IPROPNAME_SOURCEDIR));
				strSourceDir  = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIR);
			}
			riEngine.SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSourceDir);

			MsiString strPatchedProduct = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);
			MsiString strSourceList;
			if(strPatchedProduct.TextSize())
			{
				// need to migrate source list from another product - may have been saved already
				strSourceList = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTSOURCELIST);
				if(strSourceList.TextSize() == 0)
				{
					// source list not saved yet
					if ((iesRet = GetForeignSourceList(riEngine, *strPatchedProduct, *&strSourceList)) != iesSuccess)
						return iesRet;

					AssertNonZero(riEngine.SetProperty(*MsiString(IPROPNAME_PATCHEDPRODUCTSOURCELIST),
																  *strSourceList));
				}
			}
			else
			{
				strSourceList = riEngine.GetPropertyFromSz(IPROPNAME_SOURCELIST);
			}

			if ((iesRet = PublishSourceList(riEngine, *strSourceList, 0, sqlMediaInformation, strSourceDir)) != iesSuccess)
				return iesRet;
		}

		if (fPublishClientInfo)
		{
			{ // block for ProductPublishClient op
			// add client from client list
			using namespace IxoProductPublishClient;

			pExecuteRecord = &piServices->CreateRecord(Args);
			MsiString strRelativePath;
			if (strParent.TextSize())
			{
				if((pError = GetProductSourcePathRelativeToParent(riEngine, *&strRelativePath)) != 0)
					return riEngine.FatalError(*pError);
			}

			pExecuteRecord->SetMsiString(ChildPackagePath, *strRelativePath);
			pExecuteRecord->SetMsiString(Parent, *strParent);		
			//!! shouldn't we be passing DiskId here as well?

			if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
			}// end ProductPublishClient block
		}
	}

	if(!(riEngine.GetMode() & iefAdvertise) && fFeaturesInstalled && /*!! temporary check - BENCH !!*/ strParent.TextSize() == 0 /*!!*/)
	{
		// Force source resolution if our original package is not a cached package.
		// If the original package is not a cached package then there's a chance
		// that it's a package path representing a source that's not in our source
		// list, thereby requiring addition to our source list. We don't want
		// to always resolve the source because source resolution is expensive if
		// our original package is the cached package -- we have to hit the source list
		// in this case.
		//
		// Note: we've already verified in Engine.Initialize that this new source is
		// allowed. Also, SetLastUsedSource will verify this again.

		MsiString strOriginalDbPath = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);

		if(!IsCachedPackage(riEngine, *strOriginalDbPath))
		{
			if((iesRet == ResolveSource(riEngine)) != iesSuccess)
					return iesRet;
		}

		// Set the last used source for the product. This must be done after PublishSourceList
		MsiString strSource = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIR);
		MsiString strSourceProduct;
		if(strParent.TextSize())
			strSourceProduct = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIRPRODUCT);
		else
			strSourceProduct = riEngine.GetProductKey();

		if (!g_MessageContext.IsOEMInstall() && strSource.TextSize() && strSourceProduct.TextSize())
		{
			using namespace IxoSourceListRegisterLastUsed;
			PMsiRecord pLastUsedInfo(&CreateRecord(Args));
			pLastUsedInfo->SetMsiString(SourceProduct, *strSourceProduct);
			pLastUsedInfo->SetMsiString(LastUsedSource, *strSource);
			
			if ((iesRet = riEngine.ExecuteRecord(Op, *pLastUsedInfo)) != iesSuccess)
				return iesRet;
		}

		if (!g_MessageContext.IsOEMInstall() && strSource.TextSize() && strSourceProduct.TextSize() && IsURL(strSource))
		{
			// register source type for URLs so that we don't have to download the package repeatedly to determine its source
			int iSourceType = riEngine.GetDeterminedPackageSourceType();
			if (iSourceType != -1)
			{
				using namespace IxoURLSourceTypeRegister;
				PMsiRecord pURLSourceTypeInfo(&CreateRecord(Args));
				pURLSourceTypeInfo->SetMsiString(ProductCode, *strSourceProduct);
				pURLSourceTypeInfo->SetInteger(SourceType, iSourceType);
				
				if ((iesRet = riEngine.ExecuteRecord(Op, *pURLSourceTypeInfo)) != iesSuccess)
					return iesRet;
			}
		}
	}

	return iesRet;
}


/*---------------------------------------------------------------------------
	PublishFeatures action - 
---------------------------------------------------------------------------*/
iesEnum PublishFeatures(IMsiEngine& riEngine)
{
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesRet;
	// publish the available and unavailable features
	if(((iesRet = ProcessFeaturesInfo(riEngine, pfiAvailable)) != iesSuccess))
		return iesRet;
	if((fMode & iefAdvertise) || FFeaturesInstalled(riEngine))
		iesRet = ProcessFeaturesInfo(riEngine, pfiAbsent);
	return iesRet;
}


/*---------------------------------------------------------------------------
	UnpublishFeatures action - 
---------------------------------------------------------------------------*/
iesEnum UnpublishFeatures(IMsiEngine& riEngine)
{
	// unpublish all features, available or not
	PMsiServices piServices(riEngine.GetServices()); 
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData) || (fMode & iefAdvertise) || (!ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()))) || FFeaturesInstalled(riEngine))
		return iesSuccess;
	return ProcessFeaturesInfo(riEngine, pfiRemove);
}

/*---------------------------------------------------------------------------
	PublishComponents action - 
---------------------------------------------------------------------------*/
iesEnum PublishComponents(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessComponentsInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnpublishComponents action - 
---------------------------------------------------------------------------*/
iesEnum UnpublishComponents(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessComponentsInfo(riEngine, fTrue);
}


/*---------------------------------------------------------------------------
	UnpublishProduct action - 
---------------------------------------------------------------------------*/
// we unadvertise information from the configuration manager
iesEnum UnpublishProduct(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;

	PMsiServices piServices(riEngine.GetServices());
	PMsiView piView(0);
	PMsiRecord pFetchRecord(0);
	PMsiRecord pExecuteRecord(0);
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	// unregister all patches, if last client going away
	Bool fFeaturesInstalled = FFeaturesInstalled(riEngine);
	Bool fProductPublished  = ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()), 0);
	if(!fFeaturesInstalled && fProductPublished)
	{
		if((pError = riEngine.OpenView(sqlUnregisterPatchPackages, ivcFetch, *&piView)) == 0 &&
			(pError = piView->Execute(0)) == 0)
		{
			while((pFetchRecord = piView->Fetch()) != 0)
			{
				MsiString strPatchId = pFetchRecord->GetMsiString(1); //!!
				// need to unregister this patch
				pExecuteRecord = &piServices->CreateRecord(2); // for ixoPatchUnregister and ixoSourceListUnpublish
				AssertNonZero(pExecuteRecord->SetMsiString(1,*strPatchId));
				AssertNonZero(pExecuteRecord->SetMsiString(2,*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_UPGRADINGPRODUCTCODE))));
				if((iesRet = riEngine.ExecuteRecord(ixoPatchUnregister,*pExecuteRecord)) != iesSuccess)
					return iesRet;
				if((iesRet = riEngine.ExecuteRecord(ixoSourceListUnpublish,*pExecuteRecord)) != iesSuccess)
					return iesRet;
			}
		}
		else if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);

		// Unadvertise product

		if ((iesRet = CreatePublishProductRecord(riEngine, true, *&pExecuteRecord)) != iesSuccess)
			return iesRet;

		if((iesRet = riEngine.ExecuteRecord(ixoProductUnpublish, *pExecuteRecord)) != iesSuccess)
			return iesRet;// error

		MsiString strUpgradeCode = riEngine.GetPropertyFromSz(IPROPNAME_UPGRADECODE);
		if(strUpgradeCode.TextSize())
		{
			pExecuteRecord = &piServices->CreateRecord(IxoUpgradeCodeUnpublish::Args);
			AssertNonZero(pExecuteRecord->SetMsiString(IxoUpgradeCodeUnpublish::UpgradeCode, *strUpgradeCode));

			if((iesRet = riEngine.ExecuteRecord(ixoUpgradeCodeUnpublish, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}

		// ixoIconCreate
		// Record description
		// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
		// 2 = IconData

		pError = riEngine.OpenView(sqlAdvertiseIcons, ivcFetch, *&piView);
		if (!pError)
		{
			if (!(pError = piView->Execute(0)))
			{
				const ICHAR sqlPermanentClass[] = 
						TEXT("SELECT `CLSID` FROM `Class` WHERE ")
						TEXT("`Icon_`=? AND `Class`.`Attributes`=1");
#define COMPONENT_PRESENT	TEXT(" (`Component`.`Installed` <> 0 AND `Component`.`Action` <> 0)")
				const ICHAR sqlComponentViaShortcut[] = 
						TEXT("SELECT `Component`,`Shortcut`,`Target` FROM `Component`,`Shortcut` WHERE ")
						TEXT("`Component`=`Component_` AND `Icon_`=? AND ")
						COMPONENT_PRESENT;
				const ICHAR sqlComponentViaClass[] = 
						TEXT("SELECT `Component`,`CLSID` FROM `Component`,`Class` WHERE ")
						TEXT("`Component`=`Component_` AND `Icon_`=? AND ")
						COMPONENT_PRESENT;
				const ICHAR sqlComponentViaExtension[] = 
						TEXT("SELECT `Component`,`Extension` FROM `Component`,`Extension`,`ProgId` WHERE ")
						TEXT("`Component`.`Component`=`Extension`.`Component_` AND ")
						TEXT("`ProgId`.`ProgId`=`Extension`.`ProgId_` AND ")
						TEXT("`ProgId`.`Icon_`=? AND ")
						COMPONENT_PRESENT;
#undef COMPONENT_PRESENT
				PMsiView piClassView1(0);
				pError = riEngine.OpenView(sqlPermanentClass, ivcFetch, *&piClassView1);
				if ( pError )
				{
					int iError = pError->GetInteger(1);
					if ( iError != idbgDbQueryUnknownColumn &&
						  iError != idbgDbQueryUnknownTable )
						//  we're dealing with a database that does not have either
						//  the Class.Attributes column or the Class table.
						return riEngine.FatalError(*pError);  // is this the right thing to to?
				}

				PMsiView piShortcutView(0);
				pError = riEngine.OpenView(sqlComponentViaShortcut, ivcFetch, *&piShortcutView);
				if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
					return riEngine.FatalError(*pError);  // is this the right thing to to?

				PMsiView piClassView2(0);
				pError = riEngine.OpenView(sqlComponentViaClass, ivcFetch, *&piClassView2);
				if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
					return riEngine.FatalError(*pError);  // is this the right thing to to?

				PMsiView piExtensionView(0);
				pError = riEngine.OpenView(sqlComponentViaExtension, ivcFetch, *&piExtensionView);
				if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
					return riEngine.FatalError(*pError);  // is this the right thing to to?

				PMsiView piFeatureView(0);
				MsiString strTemp = riEngine.GetPropertyFromSz(IPROPNAME_DISABLEADVTSHORTCUTS);
				if ( IsDarwinDescriptorSupported(iddShell) &&
					  (strTemp.TextSize() == 0) )
				{
					//  advertised shortcuts are supported.
					const ICHAR sqlGetFeature[] = 
						TEXT("SELECT `Feature` FROM `Feature` WHERE `Feature`=?");
					pError = riEngine.OpenView(sqlGetFeature, ivcFetch, *&piFeatureView);
					if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
						return riEngine.FatalError(*pError);  // is this the right thing to to?
				}

				PMsiRecord pParamRec = &piServices->CreateRecord(1);

				while (pFetchRecord = piView->Fetch())
				{
					//  check first if we should leave the icon file behind.
					MsiString strIconName(pFetchRecord->GetMsiString(1));
					pParamRec->SetMsiString(1, *strIconName);

					if ( piClassView1 &&
						  (pError = piClassView1->Execute(pParamRec)) == 0 &&
						  (pError = piClassView1->Fetch()) != 0 )
						//  the class stays => the icon should stay too.
					{
						DEBUGMSG2(TEXT("'%s' class is marked permanent, so that ")
									 TEXT("'%s' icon will not be removed."),
									 pError->GetString(1), strIconName);
						continue;
					}
					if ( piClassView2 &&
						  (pError = piClassView2->Execute(pParamRec)) == 0 &&
						  (pError = piClassView2->Fetch()) != 0 )
						//  the component stays => the icon should stay too.
					{
						DEBUGMSG3(TEXT("'%s' class', '%s' component will not be removed, ")
									 TEXT("so that '%s' icon will not be removed."),
									 pError->GetString(2), pError->GetString(1), strIconName);
						continue;
					}
					if ( piExtensionView &&
						  (pError = piExtensionView->Execute(pParamRec)) == 0 &&
						  (pError = piExtensionView->Fetch()) != 0 )
						//  the component stays => the icon should stay too.
					{
						DEBUGMSG3(TEXT("'%s' extension's, '%s' component will not be ")
									 TEXT("removed, so that '%s' icon will not be removed."),
									 pError->GetString(2), pError->GetString(1), strIconName);
						continue;
					}
					if ( piShortcutView &&
						  (pError = piShortcutView->Execute(pParamRec)) == 0 &&
						  (pError = piShortcutView->Fetch()) != 0 )
					{
						//  shortcuts need one more check before deciding if the
						//  icon should stay: if it is authored as an advertised
						//  shortcut then the icon will go.
						bool fIconStays = true;
						if ( piFeatureView )
						{
							// advertised shortcuts are supported.
							pParamRec->SetMsiString(1, *MsiString(pError->GetMsiString(3)));
							PMsiRecord pRec = piFeatureView->Execute(pParamRec);
							if ( pRec == 0 && (pRec = piFeatureView->Fetch()) != 0 )
								//  it's an advertised shortcut => the icon goes
								fIconStays = false;
						}
						if ( fIconStays )
						{
							DEBUGMSG3(TEXT("'%s' shortcut's, '%s' component will not be ")
										 TEXT("removed, so that '%s' icon will not be removed."),
										 pError->GetString(2), pError->GetString(1), strIconName);
							continue;
						}
						else
							DEBUGMSG2(TEXT("'%s' shortcut is advertised, so that '%s' ")
										 TEXT("icon will be removed."),
										 pError->GetString(2), strIconName);
					}
					else
						DEBUGMSG1(TEXT("'%s' icon will be removed."), strIconName);

					using namespace IxoIconRemove;
					pExecuteRecord = &piServices->CreateRecord(Args);
					pExecuteRecord->SetMsiString(Icon, *strIconName);
					// following may be passed as blank.
					// piIconRec->SetMsiData(Data, PMsiData(pFetchRecord->GetMsiData(2)));
					if ((iesRet = riEngine.ExecuteRecord(ixoIconRemove, *pExecuteRecord)) != iesSuccess)
						return iesRet;				
				}
			}
			else
			{
				return riEngine.FatalError(*pError);
			}

		}
		else // pError != 0
		{
			if (pError->GetInteger(1) != idbgDbQueryUnknownTable)
			{
				return riEngine.FatalError(*pError);
			}
		}

	} 
	
	MsiString strParent = riEngine.GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);
	Bool fFeaturesInstalled2 = FFeaturesInstalled(riEngine, fFalse);
	Bool fProductPublished2  = ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()), strParent);
	if(!fFeaturesInstalled2 && fProductPublished2)
	{
		{ // block for ProductUnpublishClient op
		// remove client from client list
		using namespace IxoProductUnpublishClient;
		pExecuteRecord = &piServices->CreateRecord(Args);

		MsiString strRelativePath;
		if (strParent.TextSize())
		{
			if((pError = GetProductSourcePathRelativeToParent(riEngine, *&strRelativePath)) != 0)
				return riEngine.FatalError(*pError);
		}

		pExecuteRecord->SetMsiString(ChildPackagePath, *strRelativePath);
		pExecuteRecord->SetMsiString(Parent, *strParent);		
		if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
			return iesRet;// error
		}// end block for ProductUnpublishClient op

		if(!strParent.TextSize()) // the source list goes away when the standalone instance of the product is being removed
		{
			using namespace IxoSourceListUnpublish;
			AssertNonZero(pExecuteRecord->ClearData());
			if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}
	}
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	RegisterClassInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterClassInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessClassInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterClassInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterClassInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessClassInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	RegisterProgIdInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterProgIdInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	iesEnum iesRet = ProcessProgIdInfo(riEngine, fFalse);
	if(iesRet != iesSuccess)
		return iesRet;
	return ProcessProgIdInfoExt(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterProgIdInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterProgIdInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	iesEnum iesRet = ProcessProgIdInfo(riEngine, fTrue);
	if(iesRet != iesSuccess)
		return iesRet;
		return ProcessProgIdInfoExt(riEngine, fTrue);
}


/*---------------------------------------------------------------------------
	RegisterMIMEInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterMIMEInfo(IMsiEngine& riEngine)
{
	int fMode = r