DA_TYPE_FILETIME == pItem->dwType )
    {
        // value itself is of required type
        ftTemp = *( ( FILETIME* ) pItem->pValue );
    }
    else
    {
        // need to do conversions
        stTemp = *( ( SYSTEMTIME* ) pItem->pValue );
        // Intentionally return value is not checked.
        SystemTimeToFileTime( &stTemp, &ftTemp );
    }

    // now return the contents of the __TITEM structure
    return ftTemp;
}


DWORD
DynArrayItemAsStringEx(
    TARRAY pArray,
    DWORD dwIndex,
    LPWSTR szBuffer,
    DWORD dwLength
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array in string format.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.
     [ in ] szBuffer         - buffer to hold the string
     [ in ] dwlength         - string length.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    __MAX_SIZE_STRING szTemp = NULL_STRING;

    // check the length specified
    if ( 0 == dwLength )
    {
        return 0;
    }
    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return 0;                   // index / array is not valid
    }
    // give the value based on the type of the current item
    StringCopy( szBuffer, NULL_STRING, dwLength );       // clear the existing contents

    // convert and get the values in string format
    switch( pItem->dwType )
    {
    case DA_TYPE_STRING:
        StringCopy( szBuffer, ( LPCWSTR ) pItem->pValue, dwLength );
        break;

    case DA_TYPE_LONG:
        //FORMAT_STRING( szTemp, _T( "%ld" ), *( LONG* ) pItem->pValue );
        StringCchPrintfW( szTemp, MAX_STRING_LENGTH, _T( "%ld" ), *( LONG* ) pItem->pValue );
        StringCopy( szBuffer, szTemp, dwLength );
        break;

    case DA_TYPE_DWORD:
        //FORMAT_STRING( szTemp, _T( "%lu" ), *( DWORD* ) pItem->pValue );
        StringCchPrintfW( szTemp, MAX_STRING_LENGTH, _T( "%lu" ), *( DWORD* ) pItem->pValue );
        StringCopy( szBuffer, szTemp, dwLength );
        break;

    case DA_TYPE_FLOAT:
        //FORMAT_STRING( szTemp, _T( "%f" ), *( float* ) pItem->pValue );
        StringCchPrintfW( szTemp, MAX_STRING_LENGTH, _T( "%f" ), *( float* ) pItem->pValue );
        StringCopy( szBuffer, szTemp, dwLength );
        break;

    case DA_TYPE_DOUBLE:
        //FORMAT_STRING( szTemp, _T( "%f" ), *( double* ) pItem->pValue );
        StringCchPrintfW( szTemp, MAX_STRING_LENGTH, _T( "%f" ), *( double* ) pItem->pValue );
        StringCopy( szBuffer, szTemp, dwLength );
        break;

    case DA_TYPE_BOOL:
    case DA_TYPE_ARRAY:
    case DA_TYPE_HANDLE:
    case DA_TYPE_SYSTEMTIME:
    case DA_TYPE_FILETIME:
    case DA_TYPE_GENERAL:
    case _TYPE_NEEDINIT:
    default:
        break;      // no value can be set
    }

    // return
    return lstrlen( szBuffer );
}


LPVOID
DynArrayItem2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     This function retreives the item from a 2-dimensional dynamic array.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - The number of rows
     [ in ] dwColumn         - The number of columns

Return Value:
     pointer to the item.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return NULL; // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItem( pItem->pValue, dwColumn );
}


LPCWSTR
DynArrayItemAsString2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a string.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     pointer to the the constant string.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return NULL; // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsString( pItem->pValue, dwColumn );
}



LONG
DynArrayItemAsLong2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a long variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type Long
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsLong( pItem->pValue, dwColumn );
}


DWORD
DynArrayItemAsDWORD2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     This function retreives the item from a dynamic array as a DWORD variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type DWORD
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return 0;   // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsDWORD( pItem->pValue, dwColumn );
}


BOOL
DynArrayItemAsBOOL2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     This function retreives the item from a dynamic array as a BOOL variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type BOOL.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsBOOL( pItem->pValue, dwColumn );
}


float
DynArrayItemAsFloat2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a float variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type float.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1.0f;   // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsFloat( pItem->pValue, dwColumn );
}


double
DynArrayItemAsDouble2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a double variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type double.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1.0;    // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsDouble( pItem->pValue, dwColumn );
}


HANDLE
DynArrayItemAsHandle2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     This function retreives the item from a dynamic array as a HANDLE variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type HANDLE.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return NULL;    // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsHandle( pItem->pValue, dwColumn );
}


SYSTEMTIME
DynArrayItemAsSystemTime2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a SYSTEMTIME type variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type SYSTEMTIME.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    SYSTEMTIME stTemp;           // dummy

    ZeroMemory( &stTemp, sizeof( SYSTEMTIME ) );

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return stTemp;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsSystemTime( pItem->pValue, dwColumn );
}


DWORD
DynArrayItemAsStringEx2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    LPWSTR szBuffer,
    DWORD dwLength
    )
/*++
Routine Description:
     this function retreives the item from a 2 dimensional dynamic array as
      a string type variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column
     [ in ] szBuffer         - String buffer
     [ in ] dwLength         -  length of the string.

Return Value:
      TRUE on success.
      FALSE on failure.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return 0;   // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsStringEx( pItem->pValue, dwColumn, szBuffer, dwLength );
}


FILETIME
DynArrayItemAsFileTime2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     this function retreives the item from a 2 dimensional dynamic array as
      a FILETIME type variable.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row .
     [ in ] dwColumn         - column

Return Value:
     The variable of type FILETIME.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    FILETIME ftTemp;         // dummy

    ZeroMemory( &ftTemp, sizeof( FILETIME ) );

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return ftTemp;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayItemAsFileTime( pItem->pValue, dwColumn );
}


BOOL
DynArraySet(
    TARRAY pArray,
    DWORD dwIndex,
    LPVOID pValue
    )
/*++
Routine Description:
     general function which inserts an item into a 1-dimensional array.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - row .
     [ in ] pValue           - column

Return Value:
     TRUE : if successfully inserted the item into the array.
     FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // validate the pointer value
    if ( NULL == pValue )
    {
        return FALSE;           // invalid memory address passed
    }
    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;       // item not found / invalid array pointer
    }
    // check the data type ... it should of string type
    if ( DA_TYPE_GENERAL != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }
    // if the item is being initialized now ... change the type
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        pItem->dwType = DA_TYPE_GENERAL;
    }

    // set the value of the current item
    pItem->pValue = pValue;

    // return the result
    return TRUE;
}


BOOL
DynArraySetString(
    TARRAY pArray,
    DWORD dwIndex,
    LPCWSTR szValue,
    DWORD dwLength
    )
/*++
// Routine Description:
//      This function  inserts an string variable into a 1-dimensional array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] szValue          - string to be inserted.
//      [ in ] dwLength         - length of the string to be insertes
//
// Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_STRING != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }
    // determine the length of string ( memory ) that has to be allocated
    if ( 0 == dwLength )
    {
        dwLength = lstrlen( szValue );
    }

    // accomodate space for storing NULL character
    dwLength += 1;

    // memory has to adjusted based on the exisiting memory size and new contents size
    // before that, we need to check whether the current is initialized or not
    // if not yet initialized, we have to initialize it now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // memory has to be initialized now
        pItem->pValue = AllocateMemory( dwLength * sizeof( WCHAR ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in allocation
        }
        // set the type and size information
        pItem->dwType = DA_TYPE_STRING;
        pItem->dwSize = dwLength * sizeof( WCHAR );
    }
    else
    {
        if ( pItem->dwSize < dwLength * sizeof( WCHAR ) )
        {
            // release the existing memory pointer/location
            FreeMemory( &( pItem->pValue ) );

            // now allocate the needed memory
            pItem->pValue = NULL;
            pItem->pValue = AllocateMemory( dwLength * sizeof( WCHAR ) );
            if ( NULL == pItem->pValue )
            {
                // failed in re-allocation
                return FALSE;
            }

            // update the size of the buffer
            pItem->dwSize = dwLength * sizeof( WCHAR );
        }
    }
    // copy the contents of the string ( copy should be based on the length )
    StringCopy( ( LPWSTR ) pItem->pValue, szValue, dwLength );

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetLong(
    TARRAY pArray,
    DWORD dwIndex,
    LONG lValue
    )
/*++
// Routine Description:
//      This function  inserts an long type variable into a 1-dimensional array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] lValue           - long value to be inserted.
//
// Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_LONG != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }
    // if item is not yet allocated memory, we have to allocate now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( LONG ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }

        // set the type
        pItem->dwType = DA_TYPE_LONG;
        pItem->dwSize = sizeof( LONG );
    }

    // set the new value
    *( ( LONG* ) pItem->pValue ) = lValue;

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetDWORD(
    TARRAY pArray,
    DWORD dwIndex,
    DWORD dwValue
    )
/*++
Routine Description:
     This function  inserts an DWORD type variable into a 1-dimensional array.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - position  .
     [ in ] dwValue          - DWORD value to be inserted.

Return Value:
     TRUE : if successfully inserted the item into the array.
     FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }

    // check the data type ...
    if ( DA_TYPE_DWORD != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }

    // if item is not yet allocated memory, we have to allocate now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( DWORD ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }

        // set the type
        pItem->dwType = DA_TYPE_DWORD;
        pItem->dwSize = sizeof( DWORD );
    }

    // set the new value
    *( ( DWORD* ) pItem->pValue ) = dwValue;

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetBOOL(
    TARRAY pArray,
    DWORD dwIndex,
    BOOL bValue
    )
/*++
// Routine Description:
//      This function  inserts an BOOL type variable into a 1-dimensional  dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] bValue           - BOOL value to be inserted.
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_BOOL != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }
    // if item is not yet allocated memory, we have to allocate now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( BOOL ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }
        // set the type
        pItem->dwType = DA_TYPE_BOOL;
        pItem->dwSize = sizeof( DWORD );
    }

    // set the new value
    *( ( BOOL* ) pItem->pValue ) = bValue;

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetFloat(
    TARRAY pArray,
    DWORD dwIndex,
    float fValue
    )
/*++
// Routine Description:
//      This function  inserts an Float type variable into a 1-dimensional  dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] fValue           -  float type value to be inserted.
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_FLOAT != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }
    // if item is not yet allocated memory, we have to allocate now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( float ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }
        // set the type
        pItem->dwType = DA_TYPE_FLOAT;
        pItem->dwSize = sizeof( float );
    }

    // set the new value
    *( ( float* ) pItem->pValue ) = fValue;

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetDouble(
    TARRAY pArray,
    DWORD dwIndex,
    double dblValue
    )
/*++
// Routine Description:
//      This function inserts an double type variable into a 1-dimensional  dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] dblValue         - double type value to be inserted.
//
// Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
//
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_DOUBLE != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }
    // if item is not yet allocated memory, we have to allocate now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( double ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }
        // set the type
        pItem->dwType = DA_TYPE_DOUBLE;
        pItem->dwSize = sizeof( double );
    }

    // set the new value
    *( ( double* ) pItem->pValue ) = dblValue;

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetHandle(
    TARRAY pArray,
    DWORD dwIndex,
    HANDLE hValue
    )
/*++
// Routine Description:
//      This function  inserts an Handle type variable into a 1-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] hValue           - Handle type value to be inserted.
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_HANDLE != pItem->dwType && _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }
    // if item is not yet allocated memory, we have to allocate now
    if ( pItem->dwType == _TYPE_NEEDINIT )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( HANDLE ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }
        // set the type
        pItem->dwType = DA_TYPE_HANDLE;
        pItem->dwSize = sizeof( HANDLE );
    }

    // set the new value
    *( ( HANDLE* ) pItem->pValue ) = hValue;

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetSystemTime(
    TARRAY pArray,
    DWORD dwIndex,
    SYSTEMTIME stValue
    )
/*++
// Routine Description:
//      This function inserts an SYSTEMTIME type variable into a 1-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] stValue          - SYSTEMTIME type value to be inserted.
//
// Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    FILETIME ftTemp;     // dummy

    ZeroMemory( &ftTemp, sizeof( FILETIME ) );

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_SYSTEMTIME != pItem->dwType &&
         DA_TYPE_FILETIME != pItem->dwType &&
         _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }

    // if item is not yet allocated memory, we have to allocate now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( SYSTEMTIME ) );
        if ( NULL == pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }
        // set the type
        pItem->dwType = DA_TYPE_SYSTEMTIME;
        pItem->dwSize = sizeof( SYSTEMTIME );
    }

    // depending on the type set the value
    if ( DA_TYPE_FILETIME == pItem->dwType )
    {
        // do the needed conversions and then set
        SystemTimeToFileTime( &stValue, &ftTemp );
        *( ( FILETIME* ) pItem->pValue ) = ftTemp;
    }
    else
    {
        // set the new value as it is
        *( ( SYSTEMTIME* ) pItem->pValue ) = stValue;
    }

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySetFileTime(
    TARRAY pArray,
    DWORD dwIndex,
    FILETIME ftValue
    )
/*++
// Routine Description:
//      This function  inserts an FILETIME type variable into a 1-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - position  .
//      [ in ] ftValue          - FILETIME type value to be inserted.
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    SYSTEMTIME stTemp;           // dummy

    ZeroMemory( &stTemp, sizeof( SYSTEMTIME ) );
    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;               // item not found / invalid array pointer
    }
    // check the data type ...
    if ( DA_TYPE_FILETIME != pItem->dwType &&
         DA_TYPE_SYSTEMTIME != pItem->dwType &&
         _TYPE_NEEDINIT != pItem->dwType )
    {
        return FALSE;
    }

    // if item is not yet allocated memory, we have to allocate now
    if ( _TYPE_NEEDINIT == pItem->dwType )
    {
        // allocate memory
        pItem->pValue = AllocateMemory( sizeof( FILETIME ) );
        if ( NULL ==pItem->pValue )
        {
            return FALSE;       // failed in memory allocation
        }
        // set the type
        pItem->dwType = DA_TYPE_FILETIME;
        pItem->dwSize = sizeof( FILETIME );
    }

    // depending on the type set the value
    if ( DA_TYPE_SYSTEMTIME ==pItem->dwType )
    {
        // do the needed conversions and then set
        FileTimeToSystemTime( &ftValue, &stTemp );
        *( ( SYSTEMTIME* ) pItem->pValue ) = stTemp;
    }
    else
    {
        // set the new value as it is
        *( ( FILETIME* ) pItem->pValue ) = ftValue;
    }

    // copied ... value set successfully
    return TRUE;
}


BOOL
DynArraySet2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    LPVOID pValue
    )
/*++
// Routine Description:
//      This function is a general function to insert an variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] pValue           - value to be inserted.
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArraySet( pItem->pValue, dwColumn, pValue );
}


BOOL
DynArraySetString2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    LPCWSTR szValue,
    DWORD dwLength
    )
/*++
// Routine Description:
//      This function inserts a string variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] szValue          - Pointer to the string
//      [ in ] dwlength         - length of the string to be inserted
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;           // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArraySetString( pItem->pValue, dwColumn, szValue, dwLength );
}


BOOL
DynArraySetLong2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    LONG lValue
    )
/*++
// Routine Description:
//      This function inserts a Long variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] lValue           - value to be inserted.
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArraySetLong( pItem->pValue, dwColumn, lValue );
}


BOOL
DynArraySetDWORD2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    DWORD dwValue
    )
/*++
// Routine Description:
//      This function inserts a DWORD variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] dwValue          -  DWORD value to be inserted.
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArraySetDWORD( pItem->pValue, dwColumn, dwValue );
}


BOOL
DynArraySetBOOL2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    BOOL bValue
    )
/*++
// Routine Description:
//      This function inserts a BOOL variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] bValue           -  BOOL value to be inserted.
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArraySetBOOL( pItem->pValue, dwColumn, bValue );
}


BOOL
DynArraySetFloat2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    float fValue
    )
/*++
// Routine Description:
//      This function inserts a float variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] fValue           -  float type value to be inserted.
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArraySetFloat( pItem->pValue, dwColumn, fValue );
}


BOOL
DynArraySetDouble2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    double dblValue
    )
/*++
// Routine Description:
//      This function inserts a Double variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] dblValue         -  Double type value to be inserted.
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the vale to the sub array and return the result to the caller
    return DynArraySetDouble( pItem->pValue, dwColumn, dblValue );
}


BOOL
DynArraySetHandle2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    HANDLE hValue
    )
/*++
// Routine Description:
//      This function inserts a HANDLE variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] hValue           -  HANDLE type value to be inserted.
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the vale to the sub array and return the result to the caller
    return DynArraySetHandle( pItem->pValue, dwColumn, hValue );
}


BOOL
DynArraySetFileTime2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    FILETIME ftValue
    )
/*++
// Routine Description:
//      This function inserts a FILETIME variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] ftValue          - FILETIME type value to be inserted.
//
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the vale to the sub array and return the result to the caller
    return DynArraySetFileTime( pItem->pValue, dwColumn, ftValue );
}


BOOL
DynArraySetSystemTime2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    SYSTEMTIME stValue
    )
/*++
// Routine Description:
//      This function inserts a SYSTEMTIME variable into a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwcolumn         - column at which the element is to be inserted.
//      [ in ] stValue          - SYSTEMTIME type value to be inserted.
//  Return Value:
//      TRUE : if successfully inserted the item into the array.
//      FALSE : if Unsuccessfull .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the vale to the sub array and return the result to the caller
    return DynArraySetSystemTime( pItem->pValue, dwColumn, stValue );
}


DWORD
DynArrayGetItemType(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
// Routine Description:
//      This function retreives the type of a element in a 1-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - row position  .
//
//  Return Value:
//      the type of array.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return DA_TYPE_NONE;                // item not found / invalid array pointer
    }
    // return the type of the array
    return pItem->dwType;
}


DWORD
DynArrayGetItemType2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
// Routine Description:
//      This function retreives the type of a element in a 2-dimensional dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position  .
//      [ in ] dwColumn         - column position
//
//  Return Value:
//      the type of array.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }
    // now add the vale to the sub array and return the result to the caller
    return DynArrayGetItemType( pItem->pValue, dwColumn );
}


LONG
DynArrayFindLong(
    TARRAY pArray,
    LONG lValue
    )
/*++
// Routine Description:
//      This function returns the index of the Long variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] lValue           - the item to be searched. .
//
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_LONG, &lValue, FALSE, 0 );
}


LONG
DynArrayFindDWORD(
    TARRAY pArray,
    DWORD dwValue
    )
/*++
// Routine Description:
//      This function returns the index of the DWORD variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwValue          - value to be searched.
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_DWORD, &dwValue, FALSE, 0 );
}


LONG
DynArrayFindFloat(
    TARRAY pArray,
    float fValue
    )
/*++
// Routine Description:
//      This function returns the index of the float variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] fValue           - the item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_FLOAT, &fValue, FALSE, 0 );
}


LONG
DynArrayFindDouble(
    TARRAY pArray,
    double dblValue
    )
/*++
// Routine Description:
//      This function returns the index of the double type variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dblValue         - the item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_DOUBLE, &dblValue, FALSE, 0 );
}


LONG
DynArrayFindHandle(
    TARRAY pArray,
    HANDLE hValue
    )
/*++
// Routine Description:
//      This function returns the index of the HANDLE type variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] hValue           - the HANDLE type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_HANDLE, &hValue, FALSE, 0 );
}


LONG
DynArrayFindString(
    TARRAY pArray,
    LPCWSTR szValue,
    BOOL bIgnoreCase,
    DWORD dwCount
    )
/*++
// Routine Description:
//      This function returns the index of the String type variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array.
//      [ in ] szValue          - pointer to the string.
//      [ in ] bIgnoreCase      - boolean indicating if to perform
//                                case sensitive search or not.
//      [ in ] dwCount          - string length.
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_STRING, ( LPVOID ) szValue, bIgnoreCase, dwCount );
}


LONG
DynArrayFindSystemTime(
    TARRAY pArray,
    SYSTEMTIME stValue
    )
/*++
// Routine Description:
//      This function returns the index of the SYSTEMTIME type variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] stValue          - the SYSTEMTIME item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_SYSTEMTIME, &stValue, FALSE, 0 );
}


LONG
DynArrayFindFileTime(
    TARRAY pArray,
    FILETIME ftValue
    )
/*++
// Routine Description:
//      This function returns the index of the FILETIME type variable.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] ftValue          - the item of type FILETIME to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFind( pArray, DA_TYPE_FILETIME, &ftValue, FALSE, 0 );
}


LONG
DynArrayFindLong2(
    TARRAY pArray,
    DWORD dwRow,
    LONG lValue
    )
/*++
// Routine Description:
//      This function returns the index of the LONG type variable from a 2-d dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row
//      [ in ] lValue           - the item of type LONG to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
        return -1;  // no item exists at the specified row or item is not of type array

    // return the value
    return DynArrayFindLong( pItem->pValue, lValue );
}


LONG
DynArrayFindDWORD2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwValue
    )
/*++
// Routine Description:
//      This function returns the index of the DWORD type variable from a 2-d dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row
//      [ in ] dwValue          - the item of type DWORD to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayFindDWORD( pItem->pValue, dwValue );
}


LONG
DynArrayFindString2(
    TARRAY pArray,
    DWORD dwRow,
    LPCWSTR szValue,
    BOOL bIgnoreCase,
    DWORD dwCount
    )
/*++
// Routine Description:
//      This function returns the index of the DWORD type variable from a 2-d dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row
//      [ in ] szValue          - pointer to the string.
//      [ in ] bIgnoreCase      - boolean for case sensitive search.
//      [ in ] dwCount          - string length. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayFindString( pItem->pValue, szValue, bIgnoreCase, dwCount );
}

LONG
DynArrayFindFloat2(
    TARRAY pArray,
    DWORD dwRow,
    float fValue
    )
/*++
// Routine Description:
//      This function returns the index of the float type variable from a 2-d dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row
//      [ in ] fValue           - float value.
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayFindFloat( pItem->pValue, fValue );
}


LONG
DynArrayFindDouble2(
    TARRAY pArray,
    DWORD dwRow,
    double dblValue
    )
/*++
// Routine Description:
//      This function returns the index of the double type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row posn
//      [ in ] dblValue         - the item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayFindDouble( pItem->pValue, dblValue );
}


LONG
DynArrayFindHandle2(
    TARRAY pArray,
    DWORD dwRow,
    HANDLE hValue
    )
/*++
// Routine Description:
//      This function returns the index of the HANDLE type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row posn
//      [ in ] hValue           - the HANDLE type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayFindHandle( pItem->pValue, hValue );
}


LONG
DynArrayFindSystemTime2(
    TARRAY pArray,
    DWORD dwRow,
    SYSTEMTIME stValue
    )
/*++
// Routine Description:
//      This function returns the index of the SYSTEMTIME type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row posn
//      [ in ] stValue          - the SYSTEMTIME type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayFindSystemTime( pItem->pValue, stValue );
}


LONG
DynArrayFindFileTime2(
    TARRAY pArray,
    DWORD dwRow,
    FILETIME ftValue
    )
/*++
// Routine Description:
//      This function returns the index of the FILETIME type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row posn
//      [ in ] ftValue          - the FILETIME type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayFindFileTime( pItem->pValue, ftValue );
}


LONG
DynArrayFindLongEx(
    TARRAY pArray,
    DWORD dwColumn,
    LONG lValue
    )
/*++
// Routine Description:
//      This function returns the index of the LONG type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] lValue           - the LONG type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_LONG, &lValue, FALSE, 0 );
}


LONG
DynArrayFindDWORDEx(
    TARRAY pArray,
    DWORD dwColumn,
    DWORD dwValue
    )
/*++
// Routine Description:
//      This function returns the index of the DWORD type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] dwValue          - the DWORD type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_DWORD, &dwValue, FALSE, 0 );
}


LONG
DynArrayFindFloatEx(
    TARRAY pArray,
    DWORD dwColumn,
    float fValue
    )
/*++
// Routine Description:
//      This function returns the index of the fValue type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] fValue           - the float type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_FLOAT, &fValue, FALSE, 0 );
}


LONG
DynArrayFindDoubleEx(
    TARRAY pArray,
    DWORD dwColumn,
    double dblValue
    )
/*++
// Routine Description:
//      This function returns the index of the double type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] dblValue         - the double type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_DOUBLE, &dblValue, FALSE, 0 );
}


LONG
DynArrayFindHandleEx(
    TARRAY pArray,
    DWORD dwColumn,
    HANDLE hValue
    )
/*++
// Routine Description:
//      This function returns the index of the HANDLE type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] hValue           - the HANDLE type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_HANDLE, &hValue, FALSE, 0 );
}


LONG
DynArrayFindSystemTimeEx(
    TARRAY pArray,
    DWORD dwColumn,
    SYSTEMTIME stValue
    )
/*++
// Routine Description:
//      This function returns the index of the SYSTEMTIME type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] stValue          - the SYSTEMTIME type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_SYSTEMTIME, &stValue, FALSE, 0 );
}


LONG
DynArrayFindFileTimeEx(
    TARRAY pArray,
    DWORD dwColumn,
    FILETIME ftValue
    )
/*++
// Routine Description:
//      This function returns the index of the FILETIME type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] ftValue          - the FILETIME type item to be searched. .
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_FILETIME, &ftValue, FALSE, 0 );
}


LONG
DynArrayFindStringEx(
    TARRAY pArray,
    DWORD dwColumn,
    LPCWSTR szValue,
    BOOL bIgnoreCase,
    DWORD dwCount
    )
/*++
// Routine Description:
//      This function returns the index of the string type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwColumn         - column posn
//      [ in ] szValue          - pointer to the string
//      [ in ] bIgnorecase      - boolean for case sensitive search.
//      [ in ] dwCount          - string length
//
//  Return Value:
//      the index of the element .
--*/
{
    // return the value
    return __DynArrayFindEx( pArray, dwColumn,
        DA_TYPE_STRING, (LPVOID) szValue, bIgnoreCase, dwCount );
}


LONG
DynArrayAppendEx(
    TARRAY pArray,
    TARRAY pArrItem
    )
/*++
// Routine Description:
//      This function returns the index of the FILETIME type variable from a 2-d array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] pArrItem         - Dynamic Array to be appended.
//
//  Return Value:
//      the pointer to the array.
--*/
{
    // validate the array
    if ( ( FALSE == IsValidArray( pArray ) ) ||
         ( FALSE == IsValidArray( pArrItem ) ) )
    {
        return -1;              // array is not valid
    }
    // now add this sub array to the main array and return the result
    return __DynArrayAppend( pArray, DA_TYPE_ARRAY, sizeof( TARRAY ), pArrItem );
}


LONG
DynArrayInsertEx(
    TARRAY pArray,
    DWORD dwIndex,
    TARRAY pArrItem
    )
/*++
// Routine Description:
//      replaces  a element with an dynamic array.
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - Dynamic Array to be appended.
//      [ in ] pArrItem         - pointer to the TARRAY.
//
//  Return Value:
//      the pointer to the array..
--*/
{
    // validate the array
    if ( ( FALSE == IsValidArray( pArray ) ) ||
         ( FALSE == IsValidArray( pArrItem ) ) )
    {
        return -1;              // array is not valid
    }
    // now insert this sub array to the main array and check the result
    return __DynArrayInsert( pArray, dwIndex, DA_TYPE_ARRAY, sizeof( TARRAY ), pArrItem );
}


BOOL
DynArraySetEx(
    TARRAY pArray,
    DWORD dwIndex,
    TARRAY pArrItem
    )
/*++
// Routine Description:
//      inserts  a dynamic array at the specified posn..
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwIndex          - Dynamic Array to be appended.
//      [ in ] pArrItem         - pointer to the TARRAY.
//
//  Return Value:
//      the pointer to the array..
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // validate the array
    if ( FALSE == IsValidArray( pArray ) ||
         FALSE == IsValidArray( pArrItem ) )
    {
        return FALSE;
    }
    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;       // item not found / invalid array pointer
    }
    // check the data type ... it should not be initialized yet or of array type
    if ( ( DA_TYPE_ARRAY != pItem->dwType ) && ( _TYPE_NEEDINIT != pItem->dwType ) )
    {
        return FALSE;
    }
    // set the value of the current item
    pItem->pValue = pArrItem;
    pItem->dwType = DA_TYPE_ARRAY;

    // return the result
    return TRUE;
}


LONG
DynArrayAppendEx2(
    TARRAY pArray,
    DWORD dwRow,
    TARRAY pArrItem
    )
/*++
// Routine Description:
//      appends  a dynamic array at the specified posn..
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row no
//      [ in ] pArrItem         - pointer to the TARRAY.
//
//  Return Value:
//      the pointer to the array..
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayAppendEx( pItem->pValue, pArrItem );
}


LONG
DynArrayInsertEx2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    TARRAY pArrItem
    )
/*++
// Routine Description:
//      inserts  a dynamic array at the specified posn..
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row value
//      [ in ] dwColIndex       - column posn.
//      [ in ] pArrItem         - pointer to the TARRAY.
//
//  Return Value:
//      the pointer to the array..
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArrayInsertEx( pItem->pValue, dwColIndex, pArrItem );
}


BOOL
DynArraySetEx2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn,
    TARRAY pArrItem
    )
/*++
// Routine Description:
//      creates  a dynamic array at the specified posn of the 2-d array
//
// Arguments:
//      [ in ] pArray           - Dynamic Array
//      [ in ] dwRow            - row position
//      [ in ] dwColIndex       - column posn.
//      [ in ] pArrItem         - pointer to the TARRAY.
//
//  Return Value:
//      the pointer to the array..
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // return the value
    return DynArraySetEx( pItem->pValue, dwColumn, pArrItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\lib\showresults.c ===
// *********************************************************************************
//
// Copyright (c) Microsoft Corporation
//
// Module Name:
//
//      ShowResults.c
//
// Abstract:
//
//      This modules  has functions which are  to shoow formatted Results on screen.
//
// Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
// Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 01-Sep-2000 : Created It.
//
// *********************************************************************************

#include "pch.h"
#include "cmdline.h"
#include "cmdlineres.h"

/******************************************/
/*** CONSTANTS / DEFINES / ENUMERATIONS ***/
/******************************************/

// VAL1 = Buffer length ; VAL2 = Number of characters to copy.
#define MIN_VALUE( VAL1, VAL2 )     ( ( VAL1 > VAL2 ) ? VAL2 : VAL1 )

// Indexes for buffers to store strings
#define INDEX_TEMP_FORMAT_STRING           0
#define INDEX_TEMP_DYNARRAY_STRING         1
#define INDEX_TEMP_BUFFER                  2
#define INDEX_TEMP_BUFFER_LEN4096          3


/********************************************************/
/*** Private functions ... used only within this file ***/
/********************************************************/

__inline
LPWSTR
GetSRTempBuffer(  IN DWORD dwIndexNumber,
                  IN LPCWSTR pwszText,
                  IN DWORD dwLength,
                  IN BOOL bNullify )
/*++
 Routine Description:

    Since every file will need the temporary buffers -- in order to see
    that their buffers wont be override with other functions, seperate
    buffer space are created for each file.
    This function will provide an access to internal buffers and also
    safe guards the file buffer boundaries.

 Arguments:

    [ IN ] dwIndexNumber    -   File specific index number.

    [ IN ] pwszText         -   Default text that needs to be copied into
                                temporary buffer.

    [ IN ] dwLength         -   Length of the temporary buffer that is required.
                                Ignored when 'pwszText' is specified.

    [ IN ] bNullify         -   Informs whether to clear the buffer or not
                                before giving the temporary buffer.
                                Set to 'TRUE' to clear buffer else FALSE.

 Return Value:

    NULL        -   When any failure occurs.
                    NOTE: do not rely on GetLastError to know the reason
                          for the failure.

    success     -   Return memory address of the requested size.

    NOTE:
    ----
    If 'pwszText' and 'dwLength' both are NULL, then we treat that the caller
    is asking for the reference of the buffer and we return the buffer address.
    In this call, there wont be any memory allocations -- if the requested index
    doesn't exist, failure is returned.

    Also, the buffer returned by this function need not released by the caller.
    While exiting from the tool, all the memory will be freed automatically by
    the 'ReleaseGlobals' function.

    Value contained by 'dwLength' parameter should be number of characters to
    store. EX: Buffer requested is "abcd\0" then 'dwLength' should be 5 instead
    of 10 ( 5 * sizeof( WCHAR ) ).

    To get the size of a buffer, get a buffer pointer and pass it as argument to
    'GetBufferSize' function.
--*/
{
    if( TEMP_SHOWRESULTS_C_COUNT <= dwIndexNumber )
    {
        return NULL;
    }

    // Check if caller is requesting existing buffer contents
    if( ( NULL == pwszText ) &&
        ( 0 == dwLength )    &&
        ( FALSE == bNullify ) )
    {
        // yes -- we need to pass the existing buffer contents
        return GetInternalTemporaryBufferRef(
            dwIndexNumber + INDEX_TEMP_SHOWRESULTS_C );
    }

    // ...
    return GetInternalTemporaryBuffer(
        dwIndexNumber + INDEX_TEMP_SHOWRESULTS_C, pwszText, dwLength, bNullify );
}


VOID
PrepareString(
    TARRAY arrValues,
    DWORD dwLength,
    LPCWSTR szFormat,
    LPCWSTR szSeperator
    )
/*++
Routine Description:
     Prepares the pszBuffer string by taking values from arrValues and
     formate these values as per szFormat string.

Arguments:
     [ in ] arrValues    : values to be formated.
     [ out ] pszBuffer   : output string
     [ in ] dwLength     : string length.
     [ in ] szFormat     : format
     [ in ] szSeperator  : Seperator string

Return Value:
      NONE
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwCount = 0;
    DWORD dwTemp = 0;
    LPWSTR pszTemp = NULL;
    LPWSTR pszValue = NULL;
    LPWSTR pszBuffer = NULL;

    // Get temporary memory.
    pszBuffer = GetSRTempBuffer( INDEX_TEMP_BUFFER_LEN4096, NULL, 0 , FALSE );
    //
    // kick off
    if( ( NULL == pszBuffer ) || ( NULL == szFormat ) )
    {
        return;
    }

    // init
    StringCopy( pszBuffer, NULL_STRING, ( GetBufferSize( pszBuffer )/ sizeof( WCHAR ) ) );
    dwCount = DynArrayGetCount( arrValues );

    // allocate memory for buffers
    pszTemp  = GetSRTempBuffer( INDEX_TEMP_FORMAT_STRING, NULL, ( dwLength + 5 ) , TRUE );
    pszValue = GetSRTempBuffer( INDEX_TEMP_DYNARRAY_STRING, NULL, ( dwLength + 5 ), TRUE );
    if ( NULL == pszTemp || NULL == pszValue )
    {
        // release memories
        return;
    }

    dwTemp = ( DWORD ) StringLengthInBytes( szSeperator );
    //
    // traverse thru the list of the values and concatenate them
    // to the destination buffer
    for( dw = 0; dw < dwCount; dw++ )
    {
        // get the current value into the temporary string buffer
        DynArrayItemAsStringEx( arrValues, dw, pszValue, dwLength );

        // concatenate the temporary string to the original buffer
        StringCchPrintfW( pszTemp, (GetBufferSize(pszTemp)/sizeof(WCHAR)) - 1 ,
                          szFormat, _X( pszValue ) );
        StringConcat( pszBuffer, pszTemp, ( GetBufferSize( pszBuffer )/ sizeof( WCHAR ) ) );

        // check whether this is the last value or not
        if ( dw + 1 < dwCount )
        {
            // there are some more values
            // check whether is space for adding the seperator or not
            if ( dwLength < dwTemp )
            {
                // no more space available ... break
                break;
            }
            else
            {
                // add the seperator and update the length accordingly
                StringConcat( pszBuffer, szSeperator, ( GetBufferSize( pszBuffer )/ sizeof( WCHAR ) ) );
                dwLength -= dwTemp;
            }
        }
    }
    return;
}


VOID
GetValue(
    PTCOLUMNS pColumn,
    DWORD dwColumn,
    TARRAY arrRecord,
    LPCWSTR szArraySeperator
    )
/*++
Routine Description:
     Gets the value from arrRecord and copies it to pszValue using
     proper format.

Arguments:
     [ in ] pColumn          :  format info.
     [ in ] dwColumn         :  no of columns
     [ in ] arrRecord        : value to be formatted
     [ out ] pszValue        : output string
     [ in ] szArraySeperator : seperator used.

Return Value:
     NONE
--*/
{
    // local variables
    LPVOID pData = NULL;           // data to be passed to formatter function
    TARRAY arrTemp = NULL;
    LPCWSTR pszTemp = NULL;
    const TCHAR cszString[] = _T( "%s" );
    const TCHAR cszDecimal[] = _T( "%d" );
    const TCHAR cszFloat[] = _T( "%f" );
    LPCWSTR pszFormat = NULL;                   // format
    LPWSTR pszValue = NULL; 

    // variables used in formatting time
    DWORD dwReturn = 0;
    SYSTEMTIME systime;

    pszValue = GetSRTempBuffer( INDEX_TEMP_BUFFER_LEN4096, NULL, 0 , FALSE );

    if( ( NULL == pColumn ) ||
        ( NULL == pszValue ) )
    {
        return;
    }

    ZeroMemory( &systime, sizeof( SYSTEMTIME ) );
    // init first
    StringCopy( pszValue, NULL_STRING, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) );

    // get the column value and do formatting appropriately
    switch( pColumn->dwFlags & SR_TYPE_MASK )
    {
    case SR_TYPE_STRING:
        {
            // identify the format to be used
            if ( pColumn->dwFlags & SR_VALUEFORMAT )
            {
                pszFormat = pColumn->szFormat;
            }
            else
            {
                pszFormat = cszString;      // default format
            }

            // copy the value to the temporary buffer based on the flags specified
            if ( pColumn->dwFlags & SR_ARRAY )
            {
                // get the value into buffer first - AVOIDING PREFIX BUGS
                arrTemp = DynArrayItem( arrRecord, dwColumn );
                if ( NULL == arrTemp )
                {
                    return;
                }
                // form the array of values into one single string with ',' seperated
                PrepareString( arrTemp, pColumn->dwWidth,
                                 pszFormat, szArraySeperator );
            }
            else
            {
                // get the value into buffer first - AVOIDING PREFIX BUGS
                pszTemp = DynArrayItemAsString( arrRecord, dwColumn );
                if ( NULL == pszTemp )
                {
                    return;
                }
                // now copy the value into buffer
                StringCchPrintfW( pszValue, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) - 1, pszFormat, pszTemp );
            }

            // switch case completed
            break;
        }

    case SR_TYPE_NUMERIC:
        {
            // identify the format to be used
            if ( pColumn->dwFlags & SR_VALUEFORMAT )
            {
                pszFormat = pColumn->szFormat;
            }
            else
            {
                pszFormat = cszDecimal;     // default format
            }

            // copy the value to the temporary buffer based on the flags specified
            if ( pColumn->dwFlags & SR_ARRAY )
            {
                // get the value into buffer first - AVOIDING PREFIX BUGS
                arrTemp = DynArrayItem( arrRecord, dwColumn );
                if ( NULL == arrTemp )
                {
                    return;
                }
                // form the array of values into one single string with ',' seperated
                PrepareString( arrTemp, pColumn->dwWidth,
                                 pszFormat, szArraySeperator );
            }
            else
            {
                // get the value using format specified
                StringCchPrintfW( pszValue, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) - 1, pszFormat,
                                  DynArrayItemAsDWORD( arrRecord, dwColumn ) );
            }

            // switch case completed
            break;
        }

    case SR_TYPE_FLOAT:
        {
            // identify the format to be used
            // NOTE: for this type, format needs to be specified
            // if not, value displayed is unpredictable
            if ( pColumn->dwFlags & SR_VALUEFORMAT )
            {
                pszFormat = pColumn->szFormat;
            }
            else
            {
                pszFormat = cszFloat;       // default format
            }

            // copy the value to the temporary buffer based on the flags specified
            if ( pColumn->dwFlags & SR_ARRAY )
            {
                // get the value into buffer first - AVOIDING PREFIX BUGS
                arrTemp = DynArrayItem( arrRecord, dwColumn );
                if ( NULL == arrTemp )
                {
                    return;
                }
                // form the array of values into one single string with ',' seperated
                PrepareString( arrTemp,
                                 pColumn->dwWidth, pszFormat, szArraySeperator );
            }
            else
            {
                // get the value using format specified
                StringCchPrintfW( pszValue, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) - 1, pszFormat,
                                  DynArrayItemAsFloat( arrRecord, dwColumn ) );
            }

            // switch case completed
            break;
        }

    case SR_TYPE_DOUBLE:
        {
            // identify the format to be used
            // NOTE: for this type, format needs to be specified
            // if not, value displayed is unpredictable
            if ( pColumn->dwFlags & SR_VALUEFORMAT )
            {
                pszFormat = pColumn->szFormat;
            }
            else
            {
                pszFormat = cszFloat;       // default format
            }

            // copy the value to the temporary buffer based on the flags specified
            if ( pColumn->dwFlags & SR_ARRAY )
            {
                // get the value into buffer first - AVOIDING PREFIX BUGS
                arrTemp = DynArrayItem( arrRecord, dwColumn );
                if ( NULL == arrTemp )
                {
                    return;
                }
                // form the array of values into one single string with ',' seperated
                PrepareString( arrTemp, pColumn->dwWidth,
                                 pszFormat, szArraySeperator );
            }
            else
            {
                // get the value using format specified
                StringCchPrintfW( pszValue, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) - 1, pszFormat,
                                  DynArrayItemAsDouble( arrRecord, dwColumn ) );
            }

            // switch case completed
            break;
        }

    case SR_TYPE_TIME:
        {
            // get the time in the required format
            systime = DynArrayItemAsSystemTime( arrRecord, dwColumn );

            // get the time in current locale format
            dwReturn = GetTimeFormat( LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE,
                &systime, NULL, pszValue, MAX_STRING_LENGTH );

            // check the result
            if ( 0 == dwReturn )
            {
                // save the error info that has occurred
                SaveLastError();
                StringCopy( pszValue, GetReason(), ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) );
            }

            // switch case completed
            break;
        }

    case SR_TYPE_CUSTOM:
        {
            // check whether function pointer is specified or not
            // if not specified, error
            if ( NULL == pColumn->pFunction )
            {
                return;         // function ptr not specified ... error
            }
            // determine the data to be passed to the formatter function
            pData = pColumn->pFunctionData;
            if ( NULL == pData ) // function data is not defined
            {
                pData = pColumn;        // the current column info itself as data
            }
            // call the custom function
            ( *pColumn->pFunction)( dwColumn, arrRecord, pData, pszValue );

            // switch case completed
            break;
        }

    case SR_TYPE_DATE:
    case SR_TYPE_DATETIME:
    default:
        {
            // this should not occur ... still
            StringCopy( pszValue, NULL_STRING, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) );

            // switch case completed
            break;
        }
    }

    // user wants to display "N/A", when the value is empty, copy that
    if ( 0 == lstrlen( pszValue ) && pColumn->dwFlags & SR_SHOW_NA_WHEN_BLANK )
    {
        // copy N/A
        StringCopy( pszValue, V_NOT_AVAILABLE, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) );
    }
}


VOID
__DisplayTextWrapped(
    FILE* fp,
    LPWSTR pszValue,
    LPCWSTR pszSeperator,
    DWORD dwWidth
    )
/*++
Routine Description:
    Data is written to file depending upon the number of
    bytes ( width ) to be displayed.

    If number of bytes to be displayed is greater than
    max bytes ( width ) then text is wrapped to max bytes
    length.

Arguments:
    [ in ] fp -            File such as stdout, stderr
                           etc. on to which data needs
                           to be written.
    [ in ] pszValue -      Contains data to be displayed.
    [ in ] pszSeperator -  Contains data seperator.
    [ in ] dwWidth -       Max bytes that can be displyed.

Return Value:
    None.
--*/

{
    // local variables
    LPWSTR pszBuffer = NULL;
    LPCWSTR pszRestValue = NULL;
    DWORD dwTemp = 0;
    DWORD dwLength = 0;
    DWORD dwSepLength = 0;
    DWORD dwLenMemAlloc = 0;

    // check the input
    if ( NULL == pszValue || 0 == dwWidth || NULL == fp )
    {
        return;
    }
    // allocate buffer
    dwLenMemAlloc = StringLengthInBytes( pszValue );
    if ( dwLenMemAlloc < dwWidth )
    {
        dwLenMemAlloc = dwWidth;
    }
    // ...
    pszBuffer = GetSRTempBuffer( INDEX_TEMP_BUFFER, NULL, ( dwLenMemAlloc + 5 ), TRUE );
    if ( NULL == pszBuffer )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        // null-ify the remaining text
        StringCopy( pszValue, NULL_STRING, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) );
        return;
    }

    // determine the length of the seperator
    dwSepLength = 0;
    if ( NULL != pszSeperator )
    {
        dwSepLength = StringLengthInBytes( pszSeperator );
    }
    // determine the length of the data that can be displayed in this row
    dwTemp = 0;
    dwLength = 0;
    for( ;; )
    {
        pszRestValue = NULL;
        if ( NULL != pszSeperator )
        {
            pszRestValue = FindString( pszValue, pszSeperator, dwLength );
        }
        // check whether seperator is found or not
        if ( NULL != pszRestValue )
        {
            // determine the position
            dwTemp = StringLengthInBytes( pszValue ) -
                     StringLengthInBytes( pszRestValue ) + dwSepLength;

            // check the length
            if ( dwTemp >= dwWidth )
            {
                // string position exceed the max. width
                if ( 0 == dwLength || dwTemp == dwWidth )
                {
                    dwLength = dwWidth;
                }
                // break from the loop
                break;
            }

            // store the current position
            dwLength = dwTemp;
        }
        else
        {
            // check if length is determined or not .. if not required width itself is length
            if ( 0 == dwLength || ((StringLengthInBytes( pszValue ) - dwLength) > dwWidth) )
            {
                dwLength = dwWidth;
            }
            else
            {
                if ( StringLengthInBytes( pszValue ) <= (LONG) dwWidth )
                {
                    dwLength = StringLengthInBytes( pszValue );
                }
            }

            // break the loop
            break;
        }
    }

    // get the partial value that has to be displayed
    StringCopy( pszBuffer, pszValue,
                MIN_VALUE( dwLenMemAlloc, ( dwLength + 1 ) ) ); // +1 for NULL character
    AdjustStringLength( pszBuffer, dwWidth, FALSE );        // adjust the string
    ShowMessage( fp, _X( pszBuffer ) );                           // display the value

    // change the buffer contents so that it contains rest of the undisplayed text
    StringCopy( pszBuffer, pszValue, ( GetBufferSize( pszBuffer )/ sizeof( WCHAR ) ) );
    if ( StringLengthInBytes( pszValue ) > (LONG) dwLength )
    {
        StringCopy( pszValue, pszBuffer + dwLength, ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) );
    }
    else
    {
        StringCopy( pszValue, _T( "" ), ( GetBufferSize( pszValue )/ sizeof( WCHAR ) ) );
    }
}


VOID
__ShowAsTable(
    FILE* fp,
    DWORD dwColumns,
    PTCOLUMNS pColumns,
    DWORD dwFlags,
    TARRAY arrData
    )
/*++
Routine Description:
     Displays the arrData in Tabular form.

Arguments:
     [ in ] fp           : Output Device
     [ in ] dwColumns    : no. of columns
     [ in ] pColumns     : Header strings
     [ in ] dwFlags      : flags
     [ in ] arrData      : data to be shown

Return Value:
     NONE
--*/
{
    // local variables
    DWORD dwCount = 0;                          // holds the count of the records
    DWORD i = 0;                  // looping variables
    DWORD j = 0;                  // looping variables
    DWORD k = 0;                  // looping variables
    DWORD dwColumn = 0;
    LONG lLastColumn = 0;
    DWORD dwMultiLineColumns = 0;
    BOOL bNeedSpace = FALSE;
    BOOL bPadLeft = FALSE;
    TARRAY arrRecord = NULL;
    TARRAY arrMultiLine = NULL;
    LPCWSTR pszData = NULL;
    LPCWSTR pszSeperator = NULL;
    LPWSTR szValue = NULL_STRING;    // custom value formatter

    // constants
    const DWORD cdwColumn = 0;
    const DWORD cdwSeperator = 1;
    const DWORD cdwData = 2;

    if( ( NULL == fp ) || ( NULL == pColumns ) )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return ;
    }

    // Allocate temporary memory.
    szValue = GetSRTempBuffer( INDEX_TEMP_BUFFER_LEN4096, NULL, 4096 , TRUE );
    // create an multi-line data display helper array
    arrMultiLine = CreateDynamicArray();
    if ( ( NULL == arrMultiLine ) || ( NULL == szValue ) )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        return;
    }

    // check whether header has to be displayed or not
    if ( ! ( dwFlags & SR_NOHEADER ) )
    {
        //
        // header needs to be displayed

        // traverse thru the column headers and display
        bNeedSpace = FALSE;
        for ( i = 0; i < dwColumns; i++ )
        {
            //  check whether user wants to display this column or not
            if ( pColumns[ i ].dwFlags & SR_HIDECOLUMN )
            {
                continue;       // user doesn't want this column to be displayed .. skip
            }
            // determine the padding direction
            bPadLeft = FALSE;
            if ( pColumns[ i ].dwFlags & SR_ALIGN_LEFT )
            {
                bPadLeft = TRUE;
            }
            else
            {
                switch( pColumns[ i ].dwFlags & SR_TYPE_MASK )
                {
                case SR_TYPE_NUMERIC:
                case SR_TYPE_FLOAT:
                case SR_TYPE_DOUBLE:
                    bPadLeft = TRUE;
                    break;
                }
            }

            // check if column header seperator is needed or not and based on that show
            if ( TRUE == bNeedSpace )
            {
                // show space as column header seperator
                ShowMessage( fp, _T( " " ) );
            }

            // print the column heading
            // NOTE: column will be displayed either by expanding or shrinking
            //       based on the length of the column heading as well as width of the column
            StringCopy( szValue, pColumns[ i ].szColumn, ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) );
            AdjustStringLength( szValue, pColumns[ i ].dwWidth, bPadLeft );
            ShowMessage( fp, szValue ); // column heading

            // inform that from next time onward display column header separator
            bNeedSpace = TRUE;
        }

        // display the new line character ... seperation b/w headings and separator line
        ShowMessage( fp, _T( "\n" ) );

        //  display the seperator chars under each column header
        bNeedSpace = FALSE;
        for ( i = 0; i < dwColumns; i++ )
        {
            //  check whether user wants to display this column or not
            if ( pColumns[ i ].dwFlags & SR_HIDECOLUMN )
            {
                continue;       // user doesn't want this column to be displayed .. skip
            }
            // check if column header seperator is needed or not and based on that show
            if ( TRUE == bNeedSpace )
            {
                // show space as column header seperator
                ShowMessage( fp, _T( " " ) );
            }

            //  display seperator based on the required column width
            Replicate( szValue, _T( "=" ), pColumns[ i ].dwWidth, pColumns[ i ].dwWidth + 1 );
            ShowMessage( fp, szValue );

            // inform that from next time onward display column header separator
            bNeedSpace = TRUE;
        }

        // display the new line character ... seperation b/w headings and actual data
        ShowMessage( fp, _T( "\n" ) );
    }

    //
    // start displaying

    // get the total no. of records available
    dwCount = DynArrayGetCount( arrData );

    // traverse thru the records one-by-one
    for( i = 0; i < dwCount; i++ )
    {
        // clear the existing value
        StringCopy( szValue, NULL_STRING, ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) );

        // get the pointer to the current record
        arrRecord = DynArrayItem( arrData, i );
        if ( NULL == arrRecord )
        {
            continue;
        }
        // traverse thru the columns and display the values
        bNeedSpace = FALSE;
        for ( j = 0; j < dwColumns; j++ )
        {
            // sub-local variables used in this loop
            DWORD dwTempWidth = 0;
            BOOL bTruncation = FALSE;

            //  check whether user wants to display this column or not
            if ( pColumns[ j ].dwFlags & SR_HIDECOLUMN )
            {
                continue;       // user doesn't want this column to be displayed .. skip
            }
            // get the value of the column
            // NOTE: CHECK IF USER ASKED NOT TO TRUNCATE THE DATA OR NOT
            if ( pColumns[ j ].dwFlags & SR_NO_TRUNCATION )
            {
                bTruncation = TRUE;
                dwTempWidth = pColumns[ j ].dwWidth;
                pColumns[ j ].dwWidth = ( GetBufferSize( szValue )/ sizeof( WCHAR ) );
            }

            // prepare the value
            GetValue( &pColumns[ j ], j, arrRecord, _T( ", " ) );

            // determine the padding direction
            bPadLeft = FALSE;
            if ( FALSE == bTruncation )
            {
                if ( pColumns[ j ].dwFlags & SR_ALIGN_LEFT )
                {
                    bPadLeft = TRUE;
                }
                else
                {
                    switch( pColumns[ j ].dwFlags & SR_TYPE_MASK )
                    {
                    case SR_TYPE_NUMERIC:
                    case SR_TYPE_FLOAT:
                    case SR_TYPE_DOUBLE:
                        bPadLeft = TRUE;
                        break;
                    }
                }

                // adjust ...
                AdjustStringLength( szValue, pColumns[ j ].dwWidth, bPadLeft );
            }

            // reset the width of the current column if it is modified
            if ( TRUE == bTruncation )
            {
                pColumns[ j ].dwWidth = dwTempWidth;
            }
            // check if column header seperator is needed or not and based on that show
            if ( TRUE == bNeedSpace )
            {
                // show space as column header seperator
                ShowMessage( fp, _T( " " ) );
            }

            // now display the value
            if ( pColumns[ j ].dwFlags & SR_WORDWRAP )
            {
                // display the text ( might be partial )
                __DisplayTextWrapped( fp, szValue, _T( ", " ), pColumns[ j ].dwWidth );

                // check if any info is left to be displayed
                if ( 0 != StringLengthInBytes( szValue ) )
                {
                    LONG lIndex = 0;
                    lIndex = DynArrayAppendRow( arrMultiLine, 3 );
                    if ( -1 != lIndex )
                    {
                        DynArraySetDWORD2( arrMultiLine, lIndex, cdwColumn, j );
                        DynArraySetString2( arrMultiLine, lIndex, cdwData, szValue, 0 );
                        DynArraySetString2( arrMultiLine, lIndex,
                                            cdwSeperator, _T( ", " ), 0 );
                    }
                }
            }
            else
            {
                ShowMessage( fp, _X( szValue ) );
            }

            // inform that from next time onward display column header separator
            bNeedSpace = TRUE;
        }

        // display the new line character ... seperation b/w two record
        ShowMessage( fp, _T( "\n" ) );

        // now display the multi-line column values
        dwMultiLineColumns = DynArrayGetCount( arrMultiLine );
        while( 0 != dwMultiLineColumns )
        {
            // reset
            dwColumn = 0;
            lLastColumn = -1;
            bNeedSpace = FALSE;

            // ...
            for( j = 0; j < dwMultiLineColumns; j++ )
            {
                // ge the column number
                dwColumn = DynArrayItemAsDWORD2( arrMultiLine, j, cdwColumn );

                // show spaces till the current column from the last column
                for( k = lLastColumn + 1; k < dwColumn; k++ )
                {
                    //  check whether user wants to display this column or not
                    if ( pColumns[ k ].dwFlags & SR_HIDECOLUMN )
                    {
                        continue;   // user doesn't want this column to be displayed .. skip
                    }
                    // check if column header seperator is needed or not and based on that show
                    if ( TRUE == bNeedSpace )
                    {
                        // show space as column header seperator
                        ShowMessage( fp, _T( " " ) );
                    }

                    //  display seperator based on the required column width
                    Replicate( szValue, _T( " " ), pColumns[ k ].dwWidth,
                               pColumns[ k ].dwWidth + 1 );
                    ShowMessage( fp, szValue );

                    // inform that from next time onward display column header separator
                    bNeedSpace = TRUE;
                }

                // update the last column
                lLastColumn = dwColumn;

                // check if column header seperator is needed or not and based on that show
                if ( TRUE == bNeedSpace )
                {
                    // show space as column header seperator
                    ShowMessage( fp, _T( " " ) );
                }

                // get the seperator and data
                pszData = DynArrayItemAsString2( arrMultiLine, j, cdwData );
                pszSeperator = DynArrayItemAsString2( arrMultiLine, j, cdwSeperator );
                if ( NULL == pszData || NULL == pszSeperator )
                {
                    continue;
                }
                // display the information
                StringCopy( szValue, pszData, ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) );
                __DisplayTextWrapped( fp, szValue, pszSeperator,
                                      pColumns[ dwColumn ].dwWidth );

                // update the multi-line array with rest of the line
                if ( 0 == StringLengthInBytes( szValue ) )
                {
                    // data in this column is completely displayed ... remove it
                    DynArrayRemove( arrMultiLine, j );

                    // update the indexes
                    j--;
                    dwMultiLineColumns--;
                }
                else
                {
                    // update the multi-line array with the remaining value
                    DynArraySetString2( arrMultiLine, j, cdwData, szValue, 0 );
                }
            }

            // display the new line character ... seperation b/w two lines
            ShowMessage( fp, _T( "\n" ) );
        }
    }

    // destroy the array
    DestroyDynamicArray( &arrMultiLine );
}


VOID
__ShowAsList(
    FILE* fp,
    DWORD dwColumns,
    PTCOLUMNS pColumns,
    DWORD dwFlags,
    TARRAY arrData
    )
/*++
Routine Description:
     Displays the  in List format

Arguments:
     [ in ] fp           : Output Device
     [ in ] dwColumns    : no. of columns
     [ in ] pColumns     : Header strings
     [ in ] dwFlags      : flags
     [ in ] arrData      : data to be shown

Return Value:
     NONE
--*/
{
    // local variables
    DWORD dwCount = 0;          // holds the count of all records
    DWORD i  = 0, j = 0;        // looping variables
    DWORD dwTempWidth = 0;
    DWORD dwMaxColumnLen = 0;   // holds the length of the which max. among all the columns
    LPWSTR pszTemp = NULL;
    TARRAY arrRecord = NULL;
    __STRING_64 szBuffer = NULL_STRING;
    LPWSTR szValue = NULL_STRING;    // custom value formatter

    UNREFERENCED_PARAMETER( dwFlags );

    if( ( NULL == fp ) || ( NULL == pColumns ) )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return ;
    }

    // Allocate temporary memory.
    szValue = GetSRTempBuffer( INDEX_TEMP_BUFFER_LEN4096, NULL, 4096 , TRUE );
    if( NULL == szValue )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        return;
    }

    // find out the max. length among all the column headers
    dwMaxColumnLen = 0;
    for ( i = 0; i < dwColumns; i++ )
    {
        dwTempWidth = ( DWORD ) StringLengthInBytes( pColumns[ i ].szColumn );
        if ( dwMaxColumnLen < dwTempWidth )
        {
            dwMaxColumnLen = dwTempWidth;
        }
    }

    // start displaying the data

    // get the total no. of records available
    dwCount = DynArrayGetCount( arrData );

    // get the total no. of records available
    for( i = 0; i < dwCount; i++ )
    {
        // get the pointer to the current record
        arrRecord = DynArrayItem( arrData, i );
        if ( NULL == arrRecord )
        {
            continue;
        }
        // traverse thru the columns and display the values
        for ( j = 0; j < dwColumns; j++)
        {
            // clear the existing value
            StringCopy( szValue, NULL_STRING, ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) );

            //  check whether user wants to display this column or not
            if ( pColumns[ j ].dwFlags & SR_HIDECOLUMN )
            {
                continue;       // user doesn't want this column to be displayed .. skip
            }
            // display the column heading and its value
            // ( heading will be displayed based on the max. column length )
            StringCchPrintfW( szValue, ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) - 1,
                              _T( "%s:" ), pColumns[ j ].szColumn);
            AdjustStringLength( szValue, dwMaxColumnLen + 2, FALSE );

            ShowMessage( fp, szValue );

            // get the value of the column
            dwTempWidth = pColumns[ j ].dwWidth;                // save the current width
            pColumns[ j ].dwWidth = ( GetBufferSize( szValue )/ sizeof( WCHAR ) );   // change the width
            GetValue( &pColumns[ j ], j, arrRecord, _T( "\n" ) );
            pColumns[ j ].dwWidth = dwTempWidth;        // restore the original width

            // display the [ list of ] values
            pszTemp = _tcstok( szValue, _T( "\n" ) );
            while ( NULL != pszTemp )
            {
                // display the value
                ShowMessage( fp, _X( pszTemp ) );
                pszTemp = _tcstok( NULL, _T( "\n" ) );
                if ( NULL != pszTemp )
                {
                    // prepare the next line
                    StringCopy( szBuffer, _T( " " ), ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) );
                    AdjustStringLength( szBuffer, dwMaxColumnLen + 2, FALSE );
                    ShowMessage( fp, _T( "\n" ) );
                    ShowMessage( fp, _X( szBuffer ) );
                }
            }

            // display the next line character seperation b/w two fields
            ShowMessage( fp, _T( "\n" ) );
        }

        // display the new line character ... seperation b/w two records
        // NOTE: do this only if there are some more records
        if ( i + 1 < dwCount )
        {
            ShowMessage( fp, _T( "\n" ) );
        }
    }
}


VOID
__ShowAsCSV(
    FILE* fp,
    DWORD dwColumns,
    PTCOLUMNS pColumns,
    DWORD dwFlags,
    TARRAY arrData
    )
/*++
Routine Description:
    Displays the arrData in CSV form.

Arguments:
     [ in ] fp           : Output Device
     [ in ] dwColumns    : no. of columns
     [ in ] pColumns     : Header strings
     [ in ] dwFlags      : flags
     [ in ] arrData      : data to be shown

Return Value:
     NONE
--*/
{
    // local variables
    DWORD dwCount = 0;          // holds the count of all records
    DWORD i  = 0;       // looping variables
    DWORD j = 0;        // looping variables
    DWORD dwTempWidth = 0;
    BOOL bNeedComma = FALSE;
    TARRAY arrRecord = NULL;
    LPWSTR szValue = NULL_STRING;

    if( ( NULL == fp ) || ( NULL == pColumns ) )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return ;
    }

    // Allocate temporary memory.
    szValue = GetSRTempBuffer( INDEX_TEMP_BUFFER_LEN4096, NULL, 4096 , TRUE );
    if( NULL == szValue )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        return;
    }

    // check whether header has to be displayed or not
    if ( ! ( dwFlags & SR_NOHEADER ) )
    {
        //
        // header needs to be displayed

        // first display the columns ... with comma seperated
        bNeedComma = FALSE;
        for ( i = 0; i < dwColumns; i++ )
        {
            //  check whether user wants to display this column or not
            if ( pColumns[ i ].dwFlags & SR_HIDECOLUMN )
                continue;       // user doesn't want this column to be displayed .. skip

            // check whether we need to display ',' or not and then display
            if ( TRUE == bNeedComma )
            {
                // ',' has to be displayed
                ShowMessage( fp, _T( "," ) );
            }

            // display the column heading
            StringCchPrintfW( szValue, ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) - 1,
                              _T( "\"%s\"" ), pColumns[ i ].szColumn );
            DISPLAY_MESSAGE ( fp, szValue );

            // inform that from next time onwards we need to display comma before data
            bNeedComma = TRUE;
        }

        // new line character
        ShowMessage( fp, _T( "\n" ) );
    }

    //
    // start displaying the data

    // get the total no. of records available
    dwCount = DynArrayGetCount( arrData );

    // get the total no. of records available
    for( i = 0; i < dwCount; i++ )
    {
        // get the pointer to the current record
        arrRecord = DynArrayItem( arrData, i );
        if ( NULL == arrRecord )
            continue;

        // traverse thru the columns and display the values
        bNeedComma = FALSE;
        for ( j = 0; j < dwColumns; j++ )
        {
            // clear the existing value
            StringCopy( szValue, NULL_STRING, ( GetBufferSize( szValue )/ sizeof( WCHAR ) ) );

            //  check whether user wants to display this column or not
            if ( pColumns[ j ].dwFlags & SR_HIDECOLUMN )
                continue;       // user doesn't want this column to be displayed .. skip

            // get the value of the column
            dwTempWidth = pColumns[ j ].dwWidth;            // save the current width
            pColumns[ j ].dwWidth = ( GetBufferSize( szValue )/ sizeof( WCHAR ) ); // change the width
            GetValue( &pColumns[ j ], j, arrRecord, _T( "," ) );
            pColumns[ j ].dwWidth = dwTempWidth;        // restore the original width

            // check whether we need to display ',' or not and then display
            if ( TRUE == bNeedComma )
            {
                // ',' has to be displayed
                ShowMessage( fp, _T( "," ) );
            }

            // print the value
            ShowMessage( fp, _T( "\"" ) );
            ShowMessage( fp, _X( szValue ) );
            ShowMessage( fp, _T( "\"" ) );

            // inform that from next time onwards we need to display comma before data
            bNeedComma = TRUE;
        }

        // new line character
        ShowMessage( fp, _T( "\n" ) );
    }
}

//
// public functions ... exposed to external world
//

VOID
ShowResults(
    DWORD dwColumns,
    PTCOLUMNS pColumns,
    DWORD dwFlags,
    TARRAY arrData
    )
/*++
Routine Description:
    Wrapper function to ShowResults2.

Arguments:
     [ in ] dwColumns    : No. of Columns to be shown
     [ in ] pColumns     : Columns header
     [ in ] dwFlags      : Required format
     [ in ] arrData      : Data to be displayed.

Return Value:
    None.
--*/
{
    // just call the main function ... with stdout
    ShowResults2( stdout, dwColumns, pColumns, dwFlags, arrData );
}


VOID
ShowResults2(
    FILE* fp,
    DWORD dwColumns,
    PTCOLUMNS pColumns,
    DWORD dwFlags,
    TARRAY arrData
    )
/*++
Routine Description:
     Show the resuls (arrData) on the screen.

Arguments:
     [ in ] fp           : File on to which data is to be displayed.
     [ in ] dwColumns    : No. of Columns to be shown
     [ in ] pColumns     : Columns header
     [ in ] dwFlags      : Required format
     [ in ] arrData      : Data to be displayed.

Return Value:
     NONE
--*/
{
    // local variables

    if( ( NULL == fp ) || ( NULL == pColumns ) )
    {
        return ;
    }

    //
    //  Display the information in the format specified
    //
    switch( dwFlags & SR_FORMAT_MASK )
    {
    case SR_FORMAT_TABLE:
        {
            // show the data in table format
            __ShowAsTable( fp, dwColumns, pColumns, dwFlags, arrData );

            // switch case completed
            break;
        }

    case SR_FORMAT_LIST:
        {
            // show the data in table format
            __ShowAsList( fp, dwColumns, pColumns, dwFlags, arrData );

            // switch case completed
            break;
        }

    case SR_FORMAT_CSV:
        {
            // show the data in table format
            __ShowAsCSV( fp, dwColumns, pColumns, dwFlags, arrData );

            // switch case completed
            break;
        }

    default:
        {
            // invalid format requested by the user
            break;
        }
    }

    // flush the memory onto the file buffer
    fflush( fp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\lib\rmtconnectivity.c ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//    RmtConnectivity.c
//
//  Abstract:
//
//    This modules implements remote connectivity functionality for all the
//    command line tools.
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 13-Nov-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 13-Sep-2000 : Created It.
//
// *********************************************************************************
#include "pch.h"
#include "cmdline.h"
#include "cmdlineres.h"

//
// constants / defines / enumerations
//
#define STR_INPUT_PASSWORD          GetResString( IDS_STR_INPUT_PASSWORD )
#define ERROR_LOCAL_CREDENTIALS     GetResString( IDS_ERROR_LOCAL_CREDENTIALS )

// share names
#define SHARE_IPC           L"IPC$"
#define SHARE_ADMIN         L"ADMIN$"


// permanent indexes to the temporary buffers
#define INDEX_TEMP_TARGETVERSION        0
#define INDEX_TEMP_COMPUTERNAME         1
#define INDEX_TEMP_HOSTNAME             2
#define INDEX_TEMP_IPVALIDATION         3
#define INDEX_TEMP_HOSTBYADDR           4
#define INDEX_TEMP_CONNECTSERVER        5

// externs
extern BOOL g_bWinsockLoaded;

//
// implementation
//

__inline 
LPWSTR 
GetRmtTempBuffer( IN DWORD dwIndexNumber,
                  IN LPCWSTR pwszText,
                  IN DWORD dwLength, 
                  IN BOOL bNullify )
/*++
 Routine Description:

    since every file will need the temporary buffers -- in order to see
    that their buffers wont be override with other functions, we are
    creating seperate buffer space a for each file
    this function will provide an access to those internal buffers and also
    safe guards the file buffer boundaries

 Arguments: 
 
    [ in ] dwIndexNumber    -   file specific index number

    [ in ] pwszText         -   default text that needs to be copied into 
                                temporary buffer

    [ in ] dwLength         -   Length of the temporary buffer that is required
                                Ignored when pwszText is specified

    [ in ] bNullify         -   Informs whether to clear the buffer or not
                                before giving the temporary buffer

 Return Value:

    NULL        -   when any failure occurs
                    NOTE: do not rely on GetLastError to know the reason
                          for the failure.

    success     -   return memory address of the requested size

    NOTE:
    ----
    if pwszText and dwLength both are NULL, then we treat that the caller
    is asking for the reference of the buffer and we return the buffer address.
    In this call, there wont be any memory allocations -- if the requested index
    doesn't exist, we return as failure

    Also, the buffer returned by this function need not released by the caller.
    While exiting from the tool, all the memory will be freed automatically by
    the ReleaseGlobals functions.

--*/
{
    if ( dwIndexNumber >= TEMP_RMTCONNECTIVITY_C_COUNT )
    {
        return NULL;
    }

    // check if caller is requesting existing buffer contents
    if ( pwszText == NULL && dwLength == 0 && bNullify == FALSE )
    {
        // yes -- we need to pass the existing buffer contents
        return GetInternalTemporaryBufferRef( 
            dwIndexNumber + INDEX_TEMP_RMTCONNECTIVITY_C );
    }

    // ...
    return GetInternalTemporaryBuffer(
        dwIndexNumber + INDEX_TEMP_RMTCONNECTIVITY_C, pwszText, dwLength, bNullify );
}



BOOL
IsUserAdmin( VOID )
/*++
 Routine Description:
    Checks the user associated with the current process is Administrator or not
 Arguments:

 Return Value:
    Returns TRUE if user is Administrator or FALSE otherwise
--*/
{
    // local variables
    PSID pSid = NULL;
    BOOL bMember = FALSE;
    BOOL bResult = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    // prepare universal administrators group SID
    bResult = AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pSid );

    if ( bResult == TRUE )
    {
        bResult = CheckTokenMembership( NULL, pSid, &bMember );
        if ( bResult == TRUE && bMember == TRUE )
        {
            // current user is a member of administrators group
            bResult = TRUE;
        }
        else if ( bResult == FALSE )
        {
            // some error has occured -- need use GetLastError to know the reason
            bResult = FALSE;
        }
        else
        {
            // the user is not an administrator
            bResult = FALSE;
        }

        // free the allocated SID
        FreeSid( pSid );
    }
    else
    {
        // error has occured -- user GetLastError to know the reason
    }

    // return the result
    return bResult;
}


BOOL
IsUNCFormat( IN LPCWSTR pwszServer )
/*++
 Routine Description:
    Determines whether server name is specified in UNC format or not

 Arguments:
    [ in ] pwszServer    : server name

 Return Value:
    TRUE    : if specified in UNC format
    FALSE   : if not specified in UNC format
--*/

{
    // check the input
    if ( pwszServer == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // check the length -- it should be more that 2 characters
    if ( StringLength( pwszServer, 0 ) <= 2 )
    {
        // server name cannot be in UNC format
        return FALSE;
    }

    // now compare and return the result
    return ( StringCompare( pwszServer, _T( "\\\\" ), TRUE, 2 ) == 0 );
}

BOOL
IsLocalSystem( IN LPCWSTR pwszServer )
/*++
 Routine Description:
    Determines whether server is referring to the local or remote system

 Arguments:
    [ in ] pwszServer    : server name

 Return Value:
    TRUE    : for local system
    FALSE   : for remote system
--*/
{
    // local variables
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszHostName = NULL;
    LPWSTR pwszComputerName = NULL;

    // clear the last error
    CLEAR_LAST_ERROR();

    // if the server name is empty, it is a local system
    if ( pwszServer == NULL || lstrlen( pwszServer ) == 0 )
    {
        return TRUE;
    }

    // get the buffer that is required to the get the machine name
    GetComputerNameEx( ComputerNamePhysicalNetBIOS, NULL, &dwSize );
    if ( GetLastError() != ERROR_MORE_DATA )
    {
        return FALSE;
    }

    // now get the temporary buffer for getting the computer name
    pwszComputerName = GetRmtTempBuffer( INDEX_TEMP_COMPUTERNAME, NULL, dwSize, TRUE );
    if ( pwszComputerName == NULL )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    // get the computer name -- and check the result
    bResult = GetComputerNameEx( ComputerNamePhysicalNetBIOS, pwszComputerName, &dwSize );
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    // now do the comparision
    if ( StringCompare( pwszComputerName, pwszServer, TRUE, 0 ) == 0 )
    {
        // server name passed by the caller is local system name
        return TRUE;
    }

    // check pwszSever having IP address
    if( IsValidIPAddress( pwszServer ) == TRUE )
    {
        //
        // resolve the ipaddress to host name
        
        dwSize = 0;
        // first get the length of the buffer required to store 
        // the resolved ip address
        bResult = GetHostByIPAddr( pwszServer, NULL, &dwSize, FALSE );
        if ( bResult == FALSE )
        {
            return FALSE;
        }

        // allocate buffer of the required length
        pwszHostName = GetRmtTempBuffer( INDEX_TEMP_HOSTNAME, NULL, dwSize, TRUE );
        if ( pwszHostName == NULL )
        {
            return FALSE;
        }

        // now get the resolved ip address
        bResult = GetHostByIPAddr( pwszServer, pwszHostName, &dwSize, FALSE );
        if ( bResult == FALSE )
        {
            return FALSE;
        }

        // check if resolved ipaddress matches with the current host name
        if ( StringCompare( pwszComputerName, pwszHostName, TRUE, 0 ) == 0 )
        {
            return TRUE;            // local system
        }
        else
        {
            //if it is 127.0.0.1, then it is local host, check for that 
            if ( StringCompare( pwszHostName, L"localhost", TRUE, 0 ) == 0 )
            {
                return TRUE;
            }
            else
            {
                    return FALSE;           // not a local system
            }
        }
    }

    // get the local system fully qualified name and check
    dwSize = 0;
    GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified, NULL, &dwSize );
    if ( GetLastError() != ERROR_MORE_DATA )
    {
        return FALSE;
    }

    // now get the temporary buffer for getting the computer name
    pwszComputerName = GetRmtTempBuffer( INDEX_TEMP_COMPUTERNAME, NULL, dwSize, TRUE );
    if ( pwszComputerName == NULL )
    {
        return FALSE;
    }

    // get the FQDN name
    bResult = GetComputerNameEx( 
        ComputerNamePhysicalDnsFullyQualified, pwszComputerName, &dwSize );
    if ( bResult == FALSE )
    {
        return FALSE;
    }

    // check the FQDN with server name passed by the caller
    if ( StringCompare( pwszComputerName, pwszServer, TRUE, 0 ) == 0 )
    {
        return TRUE;
    }

    // finally ... it might not be local system name
    // NOTE: there are chances for us to not be able to identify whether
    //       the system name specified is a local system or remote system
    return FALSE;
}


BOOL
IsValidServer( IN LPCWSTR pwszServer )
/*++
 Routine Description:
    Validates the server name

 Arguments:
    [ in ] pszServer        : server name

 Return Value:
    TRUE if valid, FALSE if not valid
--*/
{
    // local variables
    const WCHAR pwszInvalidChars[] = L" \\/[]:|<>+=;,?$#()!@^\"`{}*%";
    LPWSTR pwszHostName = NULL;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;

    // check for NULL or length... if so return
    if ( pwszServer == NULL || lstrlen( pwszServer ) == 0 )
    {
        return TRUE;
    }

    // check whether this is a valid ip address or not
    if ( IsValidIPAddress( pwszServer ) == TRUE )
    {
         //
        // resolve the ipaddress to host name
        
        dwSize = 0;
        // first get the length of the buffer required to store 
        // the resolved ip address
        bResult = GetHostByIPAddr( pwszServer, NULL, &dwSize, FALSE );
        if ( bResult == FALSE )
        {
            return FALSE;
        }

        // allocate buffer of the required length
        pwszHostName = GetRmtTempBuffer( INDEX_TEMP_HOSTNAME, NULL, dwSize, TRUE );
        if ( pwszHostName == NULL )
        {
            return FALSE;
        }

        // now get the resolved ip address
        bResult = GetHostByIPAddr( pwszServer, pwszHostName, &dwSize, FALSE );
        if ( bResult == FALSE )
        {
            return FALSE;
        }
              
        return TRUE;            // it's valid ip address ... so is valid server name
    }

    // now check the server name for invalid characters
    //                      \/[]:|<>+=;,?$#()!@^"`{}*%

    // copy the contents into the internal buffer and check for the invalid characters
    if ( FindOneOf2( pwszServer, pwszInvalidChars, TRUE, 0 ) != -1 )
    {
        SetLastError( ERROR_BAD_NETPATH );
        return FALSE;
    }

    // passed all the conditions -- valid system name
    return TRUE;
}


BOOL
IsValidIPAddress( IN LPCWSTR pwszAddress )
/*++
 Routine Description:
    Validates the server name

 Arguments:
    [ in ] pszAddress        : server name in the form of IP Address

 Return Value:
    TRUE if valid, 
    FALSE if not valid
--*/
{
    // local variables
    DWORD dw = 0;
    LONG lValue = 0;
    LPWSTR pwszTemp = NULL;
    LPWSTR pwszBuffer = NULL;
    DWORD dwOctets[ 4 ] = { 0, 0, 0, 0 };

    // check the buffer
    if ( pwszAddress == NULL || lstrlen( pwszAddress ) == 0 )
    {
        SetLastError( DNS_ERROR_INVALID_TYPE );
        return FALSE;
    }

    // get the temporary buffer for IP validation
    pwszBuffer = GetRmtTempBuffer( INDEX_TEMP_IPVALIDATION, pwszAddress, 0, FALSE );
    if ( pwszBuffer == NULL )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    // parse and get the octet values
    pwszTemp = wcstok( pwszBuffer, L"." );
    while ( pwszTemp != NULL )
    {
        // check whether the current octet is numeric or not
        if ( IsNumeric( pwszTemp, 10, FALSE ) == FALSE )
        {
            return FALSE;
        }

        // get the value of the octet and check the range
        lValue = AsLong( pwszTemp, 10 );
        if ( lValue < 0 || lValue > 255 )
        {
            return FALSE;
        }

        // fetch next octet and store first four octates only
        if( dw < 4 )
        {
            dwOctets[ dw++ ] = lValue;
        }
        else
        {
            dw++;
        }

        // ...
        pwszTemp = wcstok( NULL, L"." );
    }

    // check and return
    if ( dw != 4 )
    {
        SetLastError( DNS_ERROR_INVALID_TYPE );
        return FALSE;
    }

    // now check the special condition
    // ?? time being this is not implemented ??

    // return the validity of the ip address
    return TRUE;
}


BOOL
GetHostByIPAddr( IN     LPCWSTR pwszServer,
                 OUT    LPWSTR pwszHostName,
                 IN OUT DWORD* pdwHostNameLength,
                 IN     BOOL bNeedFQDN )
/*++
 Routine Description:
    Get HostName  from ipaddress.

 Arguments:
    pszServer       : Server name in IP address format
    pszHostName     : Host name for given IP address which returns back
    bNeedFQDN       : Boolean variable tells about

 Return Value:
--*/
{
    // local variables
    WSADATA wsaData;
    DWORD dwErr = 0;
    DWORD dwLength = 0;
    ULONG ulInetAddr  = 0;
    BOOL bReturnValue = FALSE;
    LPSTR pszTemp = NULL;
    WORD wVersionRequested = 0;
    BOOL bNeedToResolve = FALSE;

    //
    // this function might be called too many times with the same server name
    // again and again at different stages of the tool -- so, in order to
    // optimize the network traffic, we store the information returned by
    // gethostbyaddr for the life time of the tool quits
    // we also store the current server name in global data structure so that
    // we can determine whether the server name being asked to resolve this
    // time is same as the one that is passed earlier.
    LPCWSTR pwszSavedName = NULL;
    static HOSTENT* pHostEnt = NULL;

    // check the input
    if ( pwszServer == NULL || pdwHostNameLength == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // check the length argument
    if ( *pdwHostNameLength != 0 && 
         ( *pdwHostNameLength < 2 || pwszHostName == NULL ) )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // check whether winsock module is loaded into process memory or not
    // if not load it now
    if ( g_bWinsockLoaded == FALSE )
    {
        // initiate the use of Ws2_32.dll by a process ( VERSION: 2.2 )
        wVersionRequested = MAKEWORD( 2, 2 );
        dwErr = WSAStartup( wVersionRequested, &wsaData );
        if ( dwErr != 0 )
        {
            SetLastError( WSAGetLastError() );
            return FALSE;
        }

        // remember that winsock library is loaded
        g_bWinsockLoaded = TRUE;
    }

    // check whether we need to resolve or not
    bNeedToResolve = TRUE;
    /////////////////////////////////////////////////////////////////////////////
    // because of weird behavior of this optimization, we are commenting out this
    /////////////////////////////////////////////////////////////////////////////
    // pwszSavedName = GetRmtTempBuffer( INDEX_TEMP_HOSTBYADDR, NULL, 0, FALSE );
    // if ( pwszSavedName != NULL )
    // {
    //    if ( StringCompare( pwszServer, pwszSavedName, TRUE, 0 ) == 0 )
    //    {
    //        bNeedToResolve = FALSE;
    //    }
    // }
    /////////////////////////////////////////////////////////////////////////////

    // proceed with the resolving only if needed
    if ( bNeedToResolve == TRUE || pHostEnt == NULL )
    {
        // allocate a buffer to store the server name in multibyte format
        dwLength = lstrlen( pwszServer ) + 5;
        pszTemp = ( LPSTR ) AllocateMemory( dwLength * sizeof( CHAR ) );
        if ( pszTemp == NULL )
        {
            OUT_OF_MEMORY();
            return FALSE;
        }

        // convert the server name into multibyte string. this is because 
        // current winsock implementation works only with multibyte 
        // string and there is no support for unicode
        bReturnValue = GetAsMultiByteString2( pwszServer, pszTemp, &dwLength );
        if ( bReturnValue == FALSE )
        {
            return FALSE;
        }

        // inet_addr function converts a string containing an Internet Protocol (Ipv4)
        // dotted address into a proper address for the IN_ADDR structure.
        ulInetAddr  = inet_addr( pszTemp );
        if ( ulInetAddr == INADDR_NONE )
        {
            FreeMemory( &pszTemp );
            UNEXPECTED_ERROR();
            return FALSE;
        }

        // gethostbyaddr function retrieves the host information 
        // corresponding to a network address.
        pHostEnt = gethostbyaddr( (LPSTR) &ulInetAddr, sizeof( ulInetAddr ), PF_INET );
        if ( pHostEnt == NULL )
        {
            // ?? DONT KNOW WHAT TO DO IF THIS FUNCTION FAILS ??
            // ?? CURRENTLY SIMPLY RETURNS FALSE              ??
            UNEXPECTED_ERROR();
            return FALSE;
        }

        // release the memory allocated so far
        FreeMemory( &pszTemp );

        // save the server name for which we just resolved the IP address
        pwszSavedName = GetRmtTempBuffer( INDEX_TEMP_HOSTBYADDR, pwszServer, 0, FALSE );
        if ( pwszSavedName == NULL )
        {
            OUT_OF_MEMORY();
            return FALSE;
        }
    }

    // check whether user wants the FQDN name or NetBIOS name
    // if NetBIOS name is required, then remove the domain name
    if ( pHostEnt != NULL )
    {
        pszTemp = pHostEnt->h_name;
        if ( bNeedFQDN == FALSE && pszTemp != NULL )
        {
            pszTemp = strtok( pHostEnt->h_name, "." );
        }

        // we got info in char type ... convert it into UNICODE string
        if ( pszTemp != NULL )
        {
            bReturnValue = GetAsUnicodeString2( pszTemp, pwszHostName, pdwHostNameLength );
            if ( bReturnValue == FALSE )
            {
                return FALSE;
            }
        }

        // return
        return TRUE;
    }
    else
    {
        // failed case
        return FALSE;
    }
}


DWORD
GetTargetVersion(
                  LPCWSTR pwszServer
                )
/*++
 Routine Description:
    It returns the version of OS of the specified system

 Arguments:
    [ in ] pszServer    Server name for which the Version of OS
                                to be known

 Return Value:
    DWORD       A DWORD value represents the version of OS.
--*/
{
    // local variables
    DWORD dwVersion = 0;
    LPWSTR pwszUNCPath = NULL;
    NET_API_STATUS netstatus;
    SERVER_INFO_101* pSrvInfo = NULL;

    // check the inputs
    if ( pwszServer == NULL || StringLength( pwszServer, 0 ) == 0 )
    {
        return 0;
    }

    // prepare the server name in UNC format
    if ( IsUNCFormat( pwszServer ) == FALSE )
    {
        if ( SetReason2( 1, L"\\\\%s", pwszServer ) == FALSE )
        {
            OUT_OF_MEMORY();
            SaveLastError();
            return 0;
        }
    }
    else
    {
        if ( SetReason( pwszServer ) == FALSE )
        {
            OUT_OF_MEMORY();
            SaveLastError();
            return 0;
        }
    }

    // now get the server name which is saved via 'failure' buffer
    pwszUNCPath = GetRmtTempBuffer( 
        INDEX_TEMP_TARGETVERSION, GetReason(), 0, FALSE );
    if ( pwszUNCPath == NULL )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        return 0;
    }

    // get the version info
    netstatus = NetServerGetInfo( pwszUNCPath, 101, (LPBYTE*) &pSrvInfo );

    // check the result .. if not success return
    if ( netstatus != NERR_Success )
    {
        return 0;
    }

    // prepare the version
    dwVersion = 0;
    if ( ( pSrvInfo->sv101_type & SV_TYPE_NT ) )
    {
        //  --> "sv101_version_major" least significant 4 bits of the byte,
        //      the major release version number of the operating system.
        //  --> "sv101_version_minor"  the minor release version number of 
        //      the operating system
        dwVersion = (pSrvInfo->sv101_version_major & MAJOR_VERSION_MASK) * 1000;
        dwVersion += pSrvInfo->sv101_version_minor;
    }

    // release the buffer allocated by network api
    NetApiBufferFree( pSrvInfo );

    // return
    return dwVersion;
}


DWORD
ConnectServer( IN  LPCWSTR pwszServer,
               IN  LPCWSTR pwszUser,
               IN  LPCWSTR pwszPassword )
/*++
 Routine Description:
    Connects to the remote Server. This is stub function.

 Arguments:
    [ in ] pwszServer    : server name
    [ in ] pwszUser      : user
    [ in ] pwszPassword  : password

 Return Value:
    NO_ERROR if succeeds other appropriate error code if failed
--*/
{
    // invoke the original function and return the result
    return ConnectServer2( pwszServer, pwszUser, pwszPassword, L"IPC$" );
}


DWORD
ConnectServer2( IN LPCWSTR pwszServer,
                IN LPCWSTR pwszUser,
                IN LPCWSTR pwszPassword,
                IN LPCWSTR pwszShare )
/*++
 Routine Description:
    Connects to the remote Server

 Arguments:
    [ in ] pwszServer    : server name
    [ in ] pwszUser      : user
    [ in ] pwszPassword  : password
    [ in ] pwszShare     : share name to connect to

 Return Value:
    NO_ERROR if succeeds other appropriate error code if failed
--*/
{
    // local variables
    DWORD dwConnect = 0;
    NETRESOURCE resource;
    LPWSTR pwszUNCPath = NULL;
    LPCWSTR pwszMachine = NULL;

    // if the server name refers to the local system,
    // and also, if user credentials were not supplied, then treat
    // connection is successfull
    // if user credentials information is passed for local system,
    // return ERROR_LOCAL_CREDENTIALS
    if ( pwszServer == NULL || IsLocalSystem( pwszServer ) == TRUE )
    {
        if ( pwszUser == NULL || lstrlen( pwszUser ) == 0 )
        {
            return NO_ERROR;            // local sustem
        }
        else
        {
            SetReason( ERROR_LOCAL_CREDENTIALS );
            SetLastError( E_LOCAL_CREDENTIALS );
            return E_LOCAL_CREDENTIALS;
        }
    }

    // check whether the server name is in UNC format or not
    // if yes, extract the server name
    pwszMachine = pwszServer;            // assume server is not in UNC format
    if ( IsUNCFormat( pwszServer ) == TRUE )
    {
        pwszMachine = pwszServer + 2;
    }

    // validate the server name
    if ( IsValidServer( pwszMachine ) == FALSE )
    {
        SaveLastError();
        return GetLastError();
    }

    //
    // prepare the machine name into UNC format
    if ( pwszShare == NULL || lstrlen( pwszShare ) == 0 )
    {
        // we will make use of the 'failure' buffer to format the string
        if ( SetReason2( 1, L"\\\\%s", pwszMachine ) == FALSE )
        {
            OUT_OF_MEMORY();
            SaveLastError();
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        // we will make use of the 'failure' buffer to format the string
        if ( SetReason2( 2, L"\\\\%s\\%s", pwszMachine, pwszShare ) == FALSE )
        {
            OUT_OF_MEMORY();
            SaveLastError();
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    // get the formatted buffer from the 'failure'
    pwszUNCPath = GetRmtTempBuffer( INDEX_TEMP_CONNECTSERVER, GetReason(), 0, FALSE );
    if ( pwszUNCPath == NULL )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // initialize the resource structure with null
    ZeroMemory( &resource, sizeof( resource ) );
    resource.dwType = RESOURCETYPE_ANY;
    resource.lpProvider = NULL;
    resource.lpLocalName = NULL;
    resource.lpRemoteName = pwszUNCPath;

    // try establishing connection to the remote server
    dwConnect = WNetAddConnection2( &resource, pwszPassword, pwszUser, 0 );

    // check the result
    // and if error has occured, get the appropriate message
    switch( dwConnect )
    {
    case NO_ERROR:
        {
            dwConnect = 0;
            CLEAR_LAST_ERROR();

            // check for the OS compatibilty
            if ( IsCompatibleOperatingSystem( GetTargetVersion( pwszMachine ) ) == FALSE )
            {
                // since the connection already established close the connection
                CloseConnection( pwszMachine );

                // set the error text
                SetReason( ERROR_REMOTE_INCOMPATIBLE );
                dwConnect = ERROR_EXTENDED_ERROR;
            }

            // ...
            break;
        }

    case ERROR_EXTENDED_ERROR:
        WNetSaveLastError();        // save the extended error
        break;

    default:
        // set the last error
        SetLastError( dwConnect );
        SaveLastError();
        break;
    }

    // return the result of the connection establishment
    return dwConnect;
}


DWORD
CloseConnection( IN LPCWSTR pwszServer )
/*++
 Routine Description:
    Closes the remote connection.

 Arguments:
    [in] szServer        -- remote machine to close the connection

 Return Value:
    DWORD                -- NO_ERROR if succeeds.
                         -- Possible error codes.
--*/
{
    // forcibly close the connection
    return CloseConnection2( pwszServer, NULL, CI_CLOSE_BY_FORCE | CI_SHARE_IPC );
}


DWORD
CloseConnection2( IN LPCWSTR pwszServer,
                  IN LPCWSTR pwszShare,
                  IN DWORD dwFlags )
/*++
 Routine Description:
      Closes the established connection on the remote system.

 Arguments:
      [ in ] szServer     -   Null terminated string that specifies the remote
                              system name. NULL specifie the local system.
      [ in ] pszShare     -   Share name of remote system to be closed, it is null in this case.
      [ in ] dwFlags     -    Flags specifies how and what connection should be closed.

 Return Value:
--*/
{
    // local variables
    DWORD dwCancel = 0;
    BOOL bForce = FALSE;
    LPCWSTR pwszMachine = NULL;
    LPCWSTR pwszUNCPath = NULL;

    // check the server contents ... it might be referring to the local system
    if ( pwszServer == NULL || lstrlen( pwszServer ) == 0 )
    {
        return NO_ERROR;
    }

    // check whether the server name is in UNC format or not
    // if yes, extract the server name
    pwszMachine = pwszServer;         // assume server is not in UNC format
    if ( IsUNCFormat( pwszServer ) == TRUE )
    {
        pwszMachine = pwszServer + 2;
    }

    // determine if share name has to appended or not for this server name
    if ( dwFlags & CI_SHARE_IPC )
    {
        // --> \\server\ipc$
        if ( SetReason2( 2, L"\\\\%s\\%s", pwszMachine, SHARE_IPC ) == FALSE )
        {
            OUT_OF_MEMORY();
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else if ( dwFlags & CI_SHARE_ADMIN )
    {
        // --> \\server\admin$
        if ( SetReason2( 2, L"\\\\%s\\%s", pwszMachine, SHARE_ADMIN ) == FALSE )
        {
            OUT_OF_MEMORY();
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else if ( dwFlags & CI_SHARE_CUSTOM && pwszShare != NULL )
    {
        // --> \\server\share
        if ( SetReason2( 2, L"\\\\%s\\%s", pwszMachine, pwszShare ) == FALSE )
        {
            OUT_OF_MEMORY();
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        // --> \\server
        if ( SetReason2( 1, L"\\\\%s", pwszMachine ) == FALSE )
        {
            OUT_OF_MEMORY();
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    // get the formatted unc path via failure string
    pwszUNCPath = GetRmtTempBuffer( 
        INDEX_TEMP_CONNECTSERVER, GetReason(), 0, FALSE );
    if ( pwszUNCPath == NULL )
    {
        OUT_OF_MEMORY();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // determine whether to close this connection forcibly or not
    if ( dwFlags & CI_CLOSE_BY_FORCE )
    {
        bForce = TRUE;
    }

    //
    // cancel the connection
    dwCancel = WNetCancelConnection2( pwszUNCPath, 0, bForce );

    // check the result
    // and if error has occured, get the appropriate message
    switch( dwCancel )
    {
    case NO_ERROR:
        dwCancel = 0;
        CLEAR_LAST_ERROR();
        break;

    case ERROR_EXTENDED_ERROR:
        WNetSaveLastError();        // save the extended error
        break;

    default:
        // set the last error
        SaveLastError();
        break;
    }

    // return the result of the cancelling the connection
    return dwCancel;
}


BOOL
EstablishConnection( IN LPCWSTR pwszServer,
                     IN LPWSTR pwszUserName,
                     IN DWORD dwUserLength,
                     IN LPWSTR pwszPassword,
                     IN DWORD dwPasswordLength,
                     IN BOOL bNeedPassword )
/*++
 Routine Description:

     Establishes a connection to the remote system.

 Arguments:

     [in] szServer                --Nullterminated string to establish the conection.
                                  --NULL connects to the local system.
     [in] szUserName              --Null terminated string that specifies the user name.
                                  --NULL takes the default user name.
     [in] dwUserLength            --Length of the username.
     [in] szPassword              --Null terminated string that specifies the password
                                  --NULL takes the default user name's password.
     [in] dwPasswordLength        --Length of the password.
     [in] bNeedPassword           --True if password is required to establish the connection.
                                  --False if it is not required.

 Return Value:
     BOOL                         -- True if it establishes
                                  -- False if it fails.
--*/
{
    // local variables
    BOOL bDefault = FALSE;
    DWORD dwConnectResult = 0;
    LPCWSTR pwszMachine = NULL;

    // clear the error .. if any
    CLEAR_LAST_ERROR();

    // check the input
    if ( pwszServer == NULL || StringLength( pwszServer, 0 ) == 0 )
    {
        // we assume user wants to connect to the local machine
        // simply return success
        return TRUE;
    }

    // ...
    if ( bNeedPassword == TRUE &&
         ( pwszUserName == NULL || dwUserLength < 2 ||
           pwszPassword == NULL || dwPasswordLength < 2) )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    // check whether the server name is in UNC format or not
    // if yes, extract the server name
    pwszMachine = pwszServer;            // assume server is not in UNC format
    if ( IsUNCFormat( pwszServer ) == TRUE )
    {
        pwszMachine = pwszServer + 2;
    }


    // sometime users want the utility to prompt for the password
    // check what user wants the utility to do
    if ( bNeedPassword == TRUE && 
         pwszPassword != NULL && 
         StringCompare( pwszPassword, L"*", TRUE, 0 ) == 0 )
    {
        
        // user wants the utility to prompt for the password..
        // But, before that we have to make sure whether the specified server is valid or not. 
        // If the server is valid let the flow directly jump to the password acceptance part
        // else return failure..
        
        // validate the server name
        if ( IsValidServer( pwszMachine ) == FALSE )
        {
            SaveLastError();
            return FALSE;
        }
        
    }
    else
    {
        // try to establish connection to the remote system with the credentials supplied
        bDefault = FALSE;

        // validate the server name
        if ( IsValidServer( pwszMachine ) == FALSE )
        {
            SaveLastError();
            return FALSE;
        }

        if ( pwszUserName == NULL || lstrlen( pwszUserName ) == 0 )
        {
            // user name is empty
            // so, it is obvious that password will also be empty
            // even if password is specified, we have to ignore that
            bDefault = TRUE;
            dwConnectResult = ConnectServer( pwszServer, NULL, NULL );
        }
        else
        {
            // credentials were supplied
            // but password might not be specified ... so check and act accordingly
            dwConnectResult = ConnectServer( pwszServer,
                pwszUserName, ( bNeedPassword == FALSE ? pwszPassword : NULL ) );

            // determine whether to close the connection or retain the connection
            if ( bNeedPassword == TRUE )
            {
                // connection might have already established .. so to be on safer side
                // we inform the caller not to close the connection
                bDefault = TRUE;
            }
        }

        // check the result ... if successful in establishing connection ... return
        if ( ERROR_ALREADY_ASSIGNED == dwConnectResult )
        {
            SetLastError( I_NO_CLOSE_CONNECTION );
            return TRUE;
        }

        // check the result ... if successful in establishing connection ... return
        else if ( dwConnectResult == NO_ERROR )
        {
            if ( bDefault == TRUE )
            {
                SetLastError( I_NO_CLOSE_CONNECTION );
            }
            else
            {
                SetLastError( NO_ERROR );
            }

            // ...
            return TRUE;
        }

        // now check the kind of error occurred
        switch( dwConnectResult )
        {
        case ERROR_LOGON_FAILURE:
        case ERROR_INVALID_PASSWORD:
            break;

        case ERROR_SESSION_CREDENTIAL_CONFLICT:
            // user credentials conflict ... client has to handle this situation
            // wrt to this module, connection to the remote system is success
            SetLastError( dwConnectResult );
            return TRUE;

        case E_LOCAL_CREDENTIALS:
            // user credentials not accepted for local system
            SetReason( ERROR_LOCAL_CREDENTIALS );
            SetLastError( E_LOCAL_CREDENTIALS );
            return TRUE;

        case ERROR_DUP_NAME:
        case ERROR_NETWORK_UNREACHABLE:
        case ERROR_HOST_UNREACHABLE:
        case ERROR_PROTOCOL_UNREACHABLE:
        case ERROR_INVALID_NETNAME:
            // change the error code so that user gets correct message
            SetLastError( ERROR_NO_NETWORK );
            SaveLastError();
            SetLastError( dwConnectResult );        // reset the error code
            return FALSE;

        default:
            SaveLastError();
            return FALSE;       // no use of accepting the password .. return failure
            break;
        }

        // if failed in establishing connection to the remote terminal
        // even if the password is specifed, then there is nothing to do ... simply return failure
        if ( bNeedPassword == FALSE )
        {
            return FALSE;
        }
    }

    // check whether user name is specified or not
    // if not, get the local system's current user name under whose credentials, the process
    // is running
    if ( lstrlen( pwszUserName ) == 0 )
    {
        // get the user name
        if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
        {
            // error occured while trying to get the current user info
            SaveLastError();
            return FALSE;
        }
    }

    // display message on the screen which says "Type Password for ..."
    ShowMessageEx( stdout, 1, TRUE, STR_INPUT_PASSWORD, pwszUserName );

    // accept the password from the user
    GetPassword( pwszPassword, dwPasswordLength );

    // now again try to establish the connection using the currently
    // supplied credentials
    dwConnectResult = ConnectServer( pwszServer, pwszUserName, pwszPassword );
    if ( dwConnectResult == NO_ERROR )
    {
        return TRUE;            // connection established successfully
    }

    // now check the kind of error occurred
    switch( dwConnectResult )
    {
    case ERROR_SESSION_CREDENTIAL_CONFLICT:
        // user credentials conflict ... client has to handle this situation
        // wrt to this module, connection to the remote system is success
        SetLastError( dwConnectResult );
        return TRUE;

    case E_LOCAL_CREDENTIALS:
        // user credentials not accepted for local system
        SetReason( ERROR_LOCAL_CREDENTIALS );
        SetLastError( E_LOCAL_CREDENTIALS );
        return TRUE;

    case ERROR_DUP_NAME:
    case ERROR_NETWORK_UNREACHABLE:
    case ERROR_HOST_UNREACHABLE:
    case ERROR_PROTOCOL_UNREACHABLE:
    case ERROR_INVALID_NETNAME:
        // change the error code so that user gets correct message
        SetLastError( ERROR_NO_NETWORK );
        SaveLastError();
        SetLastError( dwConnectResult );        // reset the error code
        return FALSE;
    default:
        SaveLastError();
        return FALSE;       // no use of accepting the password .. return failure
        break;
    }
}


BOOL
EstablishConnection2( IN PTCONNECTIONINFO pci )
/*++
 Routine Description:
    Establishes a connection to the remote system.

 Arguments:
    [in] pci       :  A pointer to TCONNECTIONINFO structure which contains
                      connection information needed for establishing connection
 Return Value:
--*/
{
    UNREFERENCED_PARAMETER( pci );

    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    SaveLastError();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\powercfg\powercfg.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation
 
Module Name:
 
    powercfg.c
 
Abstract:
 
    Allows users to view and modify power schemes and system power settings
    from the command line.  May be useful in unattended configuration and
    for headless systems.
 
Author:
 
    Ben Hertzberg (t-benher) 1-Jun-2001
 
Revision History:
 
    Ben Hertzberg (t-benher) 15-Jun-2001   - CPU throttle added
    Ben Hertzberg (t-benher)  4-Jun-2001   - import/export added
    Ben Hertzberg (t-benher)  1-Jun-2001   - created it.
 
--*/

// app-specific includes
#include <initguid.h>
#include "powercfg.h"
#include "cmdline.h"
#include "cmdlineres.h"
#include "resource.h"

// app-specific structures

// structure to manage the scheme list information.
// note that descriptions are currently not visible in the
// GUI tool (as of 6-1-2001), so they are not visible in this
// app either, although the framework is already there if
// someone decides to add the descriptions at a later date.
typedef struct _SCHEME_LIST
{
    LIST_ENTRY                      le;
    UINT                            uiID;
    LPTSTR                          lpszName;
    LPTSTR                          lpszDesc;
    PPOWER_POLICY                   ppp;
    PMACHINE_PROCESSOR_POWER_POLICY pmppp;
} SCHEME_LIST, *PSCHEME_LIST;

// structure to manage the change parameters
typedef struct _CHANGE_PARAM
{
    BOOL   bVideoTimeoutAc;
    ULONG  ulVideoTimeoutAc;
    BOOL   bVideoTimeoutDc;
    ULONG  ulVideoTimeoutDc;
    BOOL   bSpindownTimeoutAc;
    ULONG  ulSpindownTimeoutAc;
    BOOL   bSpindownTimeoutDc;
    ULONG  ulSpindownTimeoutDc;
    BOOL   bIdleTimeoutAc;
    ULONG  ulIdleTimeoutAc;
    BOOL   bIdleTimeoutDc;
    ULONG  ulIdleTimeoutDc;
    BOOL   bDozeS4TimeoutAc;
    ULONG  ulDozeS4TimeoutAc;
    BOOL   bDozeS4TimeoutDc;
    ULONG  ulDozeS4TimeoutDc;
    BOOL   bDynamicThrottleAc;
    LPTSTR lpszDynamicThrottleAc;
    BOOL  bDynamicThrottleDc;
    LPTSTR lpszDynamicThrottleDc;    
} CHANGE_PARAM, *PCHANGE_PARAM;

//
// This structure is defined to allow the usage to be stored in
// non-consecutive resource IDs so lines can be inserted without renumbering
// the resources, which makes a lot of work for localization.
//

typedef struct _USAGE_ORDER
{
    UINT InsertAfter;
    UINT FirstResource;
    UINT LastResource;
} USAGE_ORDER, *PUSAGE_ORDER;

// function types
typedef BOOLEAN (*PWRITEPWRSCHEME_PROC)(PUINT,LPTSTR,LPTSTR,PPOWER_POLICY);
typedef BOOLEAN (*PDELETEPWRSCHEME_PROC)(UINT);
typedef BOOLEAN (*PGETACTIVEPWRSCHEME_PROC)(PUINT);
typedef BOOLEAN (*PSETACTIVEPWRSCHEME_PROC)(UINT,PGLOBAL_POWER_POLICY,PPOWER_POLICY);
typedef BOOLEAN (*PREADPROCESSORPWRSCHEME_PROC)(UINT,PMACHINE_PROCESSOR_POWER_POLICY);
typedef BOOLEAN (*PWRITEPROCESSORPWRSCHEME_PROC)(UINT,PMACHINE_PROCESSOR_POWER_POLICY);
typedef BOOLEAN (*PENUMPWRSCHEMES_PROC)(PWRSCHEMESENUMPROC,LPARAM);
typedef BOOLEAN (*PGETPWRCAPABILITIES_PROC)(PSYSTEM_POWER_CAPABILITIES);
typedef BOOLEAN (*PGETGLOBALPWRPOLICY_PROC)(PGLOBAL_POWER_POLICY);
typedef BOOLEAN (*PGETCURRENTPOWERPOLICIES_PROC)(PGLOBAL_POWER_POLICY, PPOWER_POLICY);
typedef BOOLEAN (*PWRITEGLOBALPWRPOLICY_PROC)(PGLOBAL_POWER_POLICY);
typedef NTSTATUS (*PCALLNTPOWERINFORMATION_PROC)(POWER_INFORMATION_LEVEL, PVOID, ULONG, PVOID, ULONG);

// forward decl's

BOOL
DoList();

BOOL 
DoQuery(
    LPCTSTR lpszName,
    BOOL bNameSpecified,
    BOOL bNumerical
    );

BOOL 
DoCreate(
    LPTSTR lpszName
    );

BOOL 
DoDelete(
    LPCTSTR lpszName,
    BOOL bNumerical
    );

BOOL 
DoSetActive(
    LPCTSTR lpszName,
    BOOL bNumerical
    );

BOOL 
DoChange(
    LPCTSTR lpszName,
    BOOL bNumerical,
    PCHANGE_PARAM pcp
    );

BOOL
DoHibernate(
    LPCTSTR lpszBoolStr
    );

BOOL
DoGetSupportedSStates(
    VOID
    );

BOOL
DoGlobalFlag(
    LPCTSTR lpszBoolStr,
    LPCTSTR lpszGlobalFlagOption
    );


BOOL 
DoExport(
    LPCTSTR lpszName,
    BOOL bNumerical,
    LPCTSTR lpszFile
    );

BOOL 
DoImport(
    LPCTSTR lpszName,
    BOOL bNumerical,
    LPCTSTR lpszFile
    );

BOOL
DoBatteryAlarm(
    LPTSTR  lpszName,
    LPTSTR  lpszBoolStr,
    DWORD   dwLevel,
    LPTSTR  lpszAlarmTextBoolStr,
    LPTSTR  lpszAlarmSoundBoolStr,
    LPTSTR  lpszAlarmActionStr,
    LPTSTR  lpszAlarmForceBoolStr,
    LPTSTR  lpszAlarmProgramBoolStr
    );

BOOL
DoUsage();

VOID 
SyncRegPPM();

// global data

LPCTSTR    g_lpszErr = NULL_STRING; // string holding const error description
LPTSTR     g_lpszErr2 = NULL;       // string holding dyn-alloc error msg
TCHAR      g_lpszBuf[256];          // formatting buffer
BOOL       g_bHiberFileSupported = FALSE; // true iff hiberfile supported
BOOL       g_bHiberTimerSupported = FALSE; // true iff hibertimer supported
BOOL       g_bHiberFilePresent = FALSE; // true if hibernate is enabled
BOOL       g_bStandbySupported = FALSE; // true iff standby supported
BOOL       g_bMonitorPowerSupported = FALSE; // true iff has power support
BOOL       g_bDiskPowerSupported = FALSE; // true iff has power support
BOOL       g_bThrottleSupported = FALSE; // true iff has throttle support
BOOL       g_bProcessorPwrSchemeSupported = FALSE; // true iff XP or later

CONST LPTSTR g_szAlarmTaskName [NUM_DISCHARGE_POLICIES] = {
    _T("Critical Battery Alarm Program"),
    _T("Low Battery Alarm Program"),
    NULL,
    NULL
};

//
// This global data is defined to allow the usage to be stored in
// non-consecutive resource IDs so lines can be inserted without renumbering
// the resources, which makes a lot of work for localization.
//

USAGE_ORDER gUsageOrder [] = {
    {IDS_USAGE_04, IDS_USAGE_04_1, IDS_USAGE_04_1},
    {IDS_USAGE_60, IDS_USAGE_60_01, IDS_USAGE_60_09},
    {IDS_USAGE_END+1, 0, 0}
};

// global function pointers from POWRPROF.DLL
PWRITEPWRSCHEME_PROC fWritePwrScheme;
PDELETEPWRSCHEME_PROC fDeletePwrScheme;
PGETACTIVEPWRSCHEME_PROC fGetActivePwrScheme;
PSETACTIVEPWRSCHEME_PROC fSetActivePwrScheme;
PREADPROCESSORPWRSCHEME_PROC fReadProcessorPwrScheme;
PWRITEPROCESSORPWRSCHEME_PROC fWriteProcessorPwrScheme;
PENUMPWRSCHEMES_PROC fEnumPwrSchemes;
PGETPWRCAPABILITIES_PROC fGetPwrCapabilities;
PGETGLOBALPWRPOLICY_PROC fGetGlobalPwrPolicy;
PWRITEGLOBALPWRPOLICY_PROC fWriteGlobalPwrPolicy;
PCALLNTPOWERINFORMATION_PROC fCallNtPowerInformation;
PGETCURRENTPOWERPOLICIES_PROC fGetCurrentPowerPolicies;

// functions

DWORD _cdecl 
_tmain(
    DWORD     argc,
    LPCTSTR   argv[]
)
/*++
 
Routine Description:
 
    This routine is the main function.  It parses parameters and takes 
    apprpriate action.
 
Arguments:
 
    argc - indicates the number of arguments
    argv - array of null terminated strings indicating arguments.  See usage
           for actual meaning of arguments.
 
Return Value:
 
    EXIT_SUCCESS if successful
    EXIT_FAILURE if something goes wrong
 
--*/
{

    // command line flags
    BOOL     bList      = FALSE;
    BOOL     bQuery     = FALSE;
    BOOL     bCreate    = FALSE;
    BOOL     bDelete    = FALSE;
    BOOL     bSetActive = FALSE;
    BOOL     bChange    = FALSE;
    BOOL     bHibernate = FALSE;
    BOOL     bImport    = FALSE;
    BOOL     bExport    = FALSE;
    BOOL     bFile      = FALSE;
    BOOL     bUsage     = FALSE;
    BOOL     bNumerical = FALSE;
    BOOL     bGlobalFlag = FALSE;
    BOOL     bGetSupporedSStates = FALSE;
    BOOL     bBatteryAlarm = FALSE;
    
    // error status
    BOOL     bFail      = FALSE;
    
    // dummy
    INT      iDummy     = 1;

    // DLL handle
    HINSTANCE hLib = NULL;

    // parse result value vars
    LPTSTR   lpszName = NULL;
    LPTSTR   lpszBoolStr = NULL;
    LPTSTR   lpszFile = NULL;
    LPTSTR   lpszThrottleAcStr = NULL;
    LPTSTR   lpszThrottleDcStr = NULL;
    LPTSTR   lpszGlobalFlagOption = NULL;
    DWORD    dwAlarmLevel = 0xffffffff;
    LPTSTR   lpszAlarmTextBoolStr = NULL;
    LPTSTR   lpszAlarmSoundBoolStr = NULL;
    LPTSTR   lpszAlarmActionStr = NULL;
    LPTSTR   lpszAlarmForceBoolStr = NULL;
    LPTSTR   lpszAlarmProgramBoolStr = NULL;

    CHANGE_PARAM tChangeParam;
    
    // parser info struct
    TCMDPARSER cmdOptions[NUM_CMDS];
  
    // system power caps struct
    SYSTEM_POWER_CAPABILITIES SysPwrCapabilities;

    // determine upper bound on input string length
    UINT     uiMaxInLen = 0;
    DWORD    dwIdx;
    for(dwIdx=1; dwIdx<argc; dwIdx++)
    {
        UINT uiCurLen = lstrlen(argv[dwIdx]);
        if (uiCurLen > uiMaxInLen)
        {
            uiMaxInLen = uiCurLen;
        }
    }

    // load POWRPROF.DLL
    hLib = LoadLibrary(_T("POWRPROF.DLL"));
    if(!hLib) {
        DISPLAY_MESSAGE(stderr,GetResString(IDS_DLL_LOAD_ERROR));
        return EXIT_FAILURE;
    }
    fWritePwrScheme = (PWRITEPWRSCHEME_PROC)GetProcAddress(hLib,"WritePwrScheme");
    fWriteProcessorPwrScheme = (PWRITEPROCESSORPWRSCHEME_PROC)GetProcAddress(hLib,"WriteProcessorPwrScheme");
    fReadProcessorPwrScheme = (PREADPROCESSORPWRSCHEME_PROC)GetProcAddress(hLib,"ReadProcessorPwrScheme");
    fEnumPwrSchemes = (PENUMPWRSCHEMES_PROC)GetProcAddress(hLib,"EnumPwrSchemes");
    fDeletePwrScheme = (PDELETEPWRSCHEME_PROC)GetProcAddress(hLib,"DeletePwrScheme");
    fGetActivePwrScheme = (PGETACTIVEPWRSCHEME_PROC)GetProcAddress(hLib,"GetActivePwrScheme");
    fSetActivePwrScheme = (PSETACTIVEPWRSCHEME_PROC)GetProcAddress(hLib,"SetActivePwrScheme");
    fGetPwrCapabilities = (PGETPWRCAPABILITIES_PROC)GetProcAddress(hLib,"GetPwrCapabilities");
    fGetGlobalPwrPolicy = (PGETGLOBALPWRPOLICY_PROC)GetProcAddress(hLib,"ReadGlobalPwrPolicy");
    fWriteGlobalPwrPolicy = (PWRITEGLOBALPWRPOLICY_PROC)GetProcAddress(hLib,"WriteGlobalPwrPolicy");
    fCallNtPowerInformation = (PCALLNTPOWERINFORMATION_PROC)GetProcAddress(hLib,"CallNtPowerInformation");
    fGetCurrentPowerPolicies = (PGETCURRENTPOWERPOLICIES_PROC)GetProcAddress(hLib,"GetCurrentPowerPolicies");
    if((!fWritePwrScheme) || 
       (!fEnumPwrSchemes) ||
       (!fDeletePwrScheme) ||
       (!fGetActivePwrScheme) ||
       (!fSetActivePwrScheme) ||
       (!fGetGlobalPwrPolicy) ||
       (!fWriteGlobalPwrPolicy) ||
       (!fGetPwrCapabilities) ||
       (!fCallNtPowerInformation) ||
       (!fGetCurrentPowerPolicies))
    {
        DISPLAY_MESSAGE(stderr,GetResString(IDS_DLL_PROC_ERROR));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }
    g_bProcessorPwrSchemeSupported = fWriteProcessorPwrScheme && fReadProcessorPwrScheme;
    
    // Syncronize the data in the registry with the actual power policy.
    SyncRegPPM();

    // hook into cmdline.lib to allow Win2k operation
    SetOsVersion(5,0,0);

    // allocate space for scheme name and boolean string, and others strings
    lpszName = (LPTSTR)LocalAlloc(
        LPTR,
        (uiMaxInLen+1)*sizeof(TCHAR)
        );
    if (!lpszName)
    {
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }
    lpszBoolStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszBoolStr)
    {
        LocalFree(lpszName);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }
    if (uiMaxInLen < (UINT)lstrlen(GetResString(IDS_DEFAULT_FILENAME)))
    {
        lpszFile = (LPTSTR)LocalAlloc(
            LPTR,
            (lstrlen(GetResString(IDS_DEFAULT_FILENAME))+1)*sizeof(TCHAR)
            );
    }
    else
    {
        lpszFile = (LPTSTR)LocalAlloc(
            LPTR,
            (uiMaxInLen+1)*sizeof(TCHAR)
            );
    }
    if (!lpszFile)
    {
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }
    lpszThrottleAcStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszThrottleAcStr)
    {
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }
    lpszThrottleDcStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszThrottleDcStr)
    {
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }

    lpszGlobalFlagOption = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszGlobalFlagOption)
    {
        LocalFree(lpszThrottleDcStr);
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }

    lpszAlarmTextBoolStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszAlarmTextBoolStr)
    {
        LocalFree(lpszGlobalFlagOption);
        LocalFree(lpszThrottleDcStr);
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }

    lpszAlarmSoundBoolStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszAlarmTextBoolStr)
    {
        LocalFree(lpszAlarmTextBoolStr);
        LocalFree(lpszGlobalFlagOption);
        LocalFree(lpszThrottleDcStr);
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }

    lpszAlarmActionStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszAlarmActionStr)
    {
        LocalFree(lpszAlarmSoundBoolStr);
        LocalFree(lpszAlarmTextBoolStr);
        LocalFree(lpszGlobalFlagOption);
        LocalFree(lpszThrottleDcStr);
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }

    lpszAlarmForceBoolStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszAlarmForceBoolStr)
    {
        LocalFree(lpszAlarmActionStr);
        LocalFree(lpszAlarmSoundBoolStr);
        LocalFree(lpszAlarmTextBoolStr);
        LocalFree(lpszGlobalFlagOption);
        LocalFree(lpszThrottleDcStr);
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }

    lpszAlarmProgramBoolStr = (LPTSTR)LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszAlarmProgramBoolStr)
    {
        LocalFree(lpszAlarmForceBoolStr);
        LocalFree(lpszAlarmActionStr);
        LocalFree(lpszAlarmSoundBoolStr);
        LocalFree(lpszAlarmTextBoolStr);
        LocalFree(lpszGlobalFlagOption);
        LocalFree(lpszThrottleDcStr);
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }

    // initialize the allocated strings
    lstrcpy(lpszName,NULL_STRING);
    lstrcpy(lpszFile,GetResString(IDS_DEFAULT_FILENAME));
    lstrcpy(lpszThrottleAcStr,NULL_STRING);
    lstrcpy(lpszThrottleAcStr,NULL_STRING);
    lstrcpy(lpszThrottleDcStr,NULL_STRING);
    lstrcpy(lpszGlobalFlagOption,NULL_STRING);
    lstrcpy(lpszAlarmTextBoolStr,NULL_STRING);
    lstrcpy(lpszAlarmSoundBoolStr,NULL_STRING);
    lstrcpy(lpszAlarmActionStr,NULL_STRING);
    lstrcpy(lpszAlarmForceBoolStr,NULL_STRING);
    lstrcpy(lpszAlarmProgramBoolStr,NULL_STRING);
    

    // determine system capabilities
    if (fGetPwrCapabilities(&SysPwrCapabilities)) 
    {
        g_bHiberFileSupported = SysPwrCapabilities.SystemS4;
        g_bHiberTimerSupported = 
            (SysPwrCapabilities.RtcWake >= PowerSystemHibernate);
        g_bHiberFilePresent = SysPwrCapabilities.HiberFilePresent;
        g_bStandbySupported = SysPwrCapabilities.SystemS1 | 
            SysPwrCapabilities.SystemS2 | 
            SysPwrCapabilities.SystemS3;
        g_bDiskPowerSupported = SysPwrCapabilities.DiskSpinDown;
        g_bThrottleSupported = SysPwrCapabilities.ProcessorThrottle;
        g_bMonitorPowerSupported  = SystemParametersInfo(
            SPI_GETLOWPOWERACTIVE,
            0, 
            &iDummy, 
            0
            );
        if (!g_bMonitorPowerSupported ) {
            g_bMonitorPowerSupported  = SystemParametersInfo(
                SPI_GETPOWEROFFACTIVE,
                0, 
                &iDummy, 
                0
                );
        }
    } 
    else 
    {
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
        LocalFree(lpszAlarmProgramBoolStr);
        LocalFree(lpszAlarmForceBoolStr);
        LocalFree(lpszAlarmActionStr);
        LocalFree(lpszAlarmSoundBoolStr);
        LocalFree(lpszAlarmTextBoolStr);
        LocalFree(lpszGlobalFlagOption);
        LocalFree(lpszThrottleDcStr);
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        FreeLibrary(hLib);
        return EXIT_FAILURE;
    }
    
    
    //fill in the TCMDPARSER array
    
    // option 'list'
    cmdOptions[CMDINDEX_LIST].dwFlags       = CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_LIST].dwCount       = 1;
    cmdOptions[CMDINDEX_LIST].dwActuals     = 0;
    cmdOptions[CMDINDEX_LIST].pValue        = &bList;
    cmdOptions[CMDINDEX_LIST].pFunction     = NULL;
    cmdOptions[CMDINDEX_LIST].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_LIST].szOption,
        CMDOPTION_LIST
        );
    lstrcpy(
        cmdOptions[CMDINDEX_LIST].szValues,
        NULL_STRING
        );
    
    // option 'query'
    cmdOptions[CMDINDEX_QUERY].dwFlags       = CP_TYPE_TEXT | 
                                               CP_VALUE_OPTIONAL | 
                                               CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_QUERY].dwCount       = 1;
    cmdOptions[CMDINDEX_QUERY].dwActuals     = 0;
    cmdOptions[CMDINDEX_QUERY].pValue        = lpszName;
    cmdOptions[CMDINDEX_QUERY].pFunction     = NULL;
    cmdOptions[CMDINDEX_QUERY].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_QUERY].szOption,
        CMDOPTION_QUERY
        );
    lstrcpy(
        cmdOptions[CMDINDEX_QUERY].szValues,
        NULL_STRING
        );
    
    // option 'create'
    cmdOptions[CMDINDEX_CREATE].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_CREATE].dwCount       = 1;
    cmdOptions[CMDINDEX_CREATE].dwActuals     = 0;
    cmdOptions[CMDINDEX_CREATE].pValue        = lpszName;
    cmdOptions[CMDINDEX_CREATE].pFunction     = NULL;
    cmdOptions[CMDINDEX_CREATE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_CREATE].szOption,
        CMDOPTION_CREATE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_CREATE].szValues,
        NULL_STRING
        );
    
    // option 'delete'
    cmdOptions[CMDINDEX_DELETE].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_DELETE].dwCount       = 1;
    cmdOptions[CMDINDEX_DELETE].dwActuals     = 0;
    cmdOptions[CMDINDEX_DELETE].pValue        = lpszName;
    cmdOptions[CMDINDEX_DELETE].pFunction     = NULL;
    cmdOptions[CMDINDEX_DELETE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_DELETE].szOption,
        CMDOPTION_DELETE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_DELETE].szValues,
        NULL_STRING
        );
    
    // option 'setactive'
    cmdOptions[CMDINDEX_SETACTIVE].dwFlags       = CP_TYPE_TEXT | 
                                                   CP_VALUE_MANDATORY | 
                                                   CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_SETACTIVE].dwCount       = 1;
    cmdOptions[CMDINDEX_SETACTIVE].dwActuals     = 0;
    cmdOptions[CMDINDEX_SETACTIVE].pValue        = lpszName;
    cmdOptions[CMDINDEX_SETACTIVE].pFunction     = NULL;
    cmdOptions[CMDINDEX_SETACTIVE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_SETACTIVE].szOption,
        CMDOPTION_SETACTIVE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_SETACTIVE].szValues,
        NULL_STRING
        );
    
    // option 'change'
    cmdOptions[CMDINDEX_CHANGE].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_CHANGE].dwCount       = 1;
    cmdOptions[CMDINDEX_CHANGE].dwActuals     = 0;
    cmdOptions[CMDINDEX_CHANGE].pValue        = lpszName;
    cmdOptions[CMDINDEX_CHANGE].pFunction     = NULL;
    cmdOptions[CMDINDEX_CHANGE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_CHANGE].szOption,
        CMDOPTION_CHANGE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_CHANGE].szValues,
        NULL_STRING
        );
    
    // option 'hibernate'
    cmdOptions[CMDINDEX_HIBERNATE].dwFlags       = CP_TYPE_TEXT | 
                                                   CP_VALUE_MANDATORY | 
                                                   CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_HIBERNATE].dwCount       = 1;
    cmdOptions[CMDINDEX_HIBERNATE].dwActuals     = 0;
    cmdOptions[CMDINDEX_HIBERNATE].pValue        = lpszBoolStr;
    cmdOptions[CMDINDEX_HIBERNATE].pFunction     = NULL;
    cmdOptions[CMDINDEX_HIBERNATE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_HIBERNATE].szOption,
        CMDOPTION_HIBERNATE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_HIBERNATE].szValues,
        NULL_STRING
        );  

    // option 'getsstates'
    cmdOptions[CMDINDEX_SSTATES].dwFlags       = CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_SSTATES].dwCount       = 1;
    cmdOptions[CMDINDEX_SSTATES].dwActuals     = 0;
    cmdOptions[CMDINDEX_SSTATES].pValue        = &bGetSupporedSStates;
    cmdOptions[CMDINDEX_SSTATES].pFunction     = NULL;
    cmdOptions[CMDINDEX_SSTATES].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_SSTATES].szOption,
        CMDOPTION_SSTATES
        );
    lstrcpy(
        cmdOptions[CMDINDEX_SSTATES].szValues,
        NULL_STRING
        );
    
    // option 'export'
    cmdOptions[CMDINDEX_EXPORT].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_EXPORT].dwCount       = 1;
    cmdOptions[CMDINDEX_EXPORT].dwActuals     = 0;
    cmdOptions[CMDINDEX_EXPORT].pValue        = lpszName;
    cmdOptions[CMDINDEX_EXPORT].pFunction     = NULL;
    cmdOptions[CMDINDEX_EXPORT].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_EXPORT].szOption,
        CMDOPTION_EXPORT
        );
    lstrcpy(
        cmdOptions[CMDINDEX_EXPORT].szValues,
        NULL_STRING
        );  

    // option 'import'
    cmdOptions[CMDINDEX_IMPORT].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_IMPORT].dwCount       = 1;
    cmdOptions[CMDINDEX_IMPORT].dwActuals     = 0;
    cmdOptions[CMDINDEX_IMPORT].pValue        = lpszName;
    cmdOptions[CMDINDEX_IMPORT].pFunction     = NULL;
    cmdOptions[CMDINDEX_IMPORT].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_IMPORT].szOption,
        CMDOPTION_IMPORT
        );
    lstrcpy(
        cmdOptions[CMDINDEX_IMPORT].szValues,
        NULL_STRING
        );  

    // option 'usage'
    cmdOptions[CMDINDEX_USAGE].dwFlags       = CP_USAGE | 
                                               CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_USAGE].dwCount       = 1;
    cmdOptions[CMDINDEX_USAGE].dwActuals     = 0;
    cmdOptions[CMDINDEX_USAGE].pValue        = &bUsage;
    cmdOptions[CMDINDEX_USAGE].pFunction     = NULL;
    cmdOptions[CMDINDEX_USAGE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_USAGE].szOption,
        CMDOPTION_USAGE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_USAGE].szValues,
        NULL_STRING
        );

    // sub-option 'numerical'
    cmdOptions[CMDINDEX_NUMERICAL].dwFlags       = 0;
    cmdOptions[CMDINDEX_NUMERICAL].dwCount       = 1;
    cmdOptions[CMDINDEX_NUMERICAL].dwActuals     = 0;
    cmdOptions[CMDINDEX_NUMERICAL].pValue        = &bNumerical;
    cmdOptions[CMDINDEX_NUMERICAL].pFunction     = NULL;
    cmdOptions[CMDINDEX_NUMERICAL].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_NUMERICAL].szOption,
        CMDOPTION_NUMERICAL
        );
    lstrcpy(
        cmdOptions[CMDINDEX_NUMERICAL].szValues,
        NULL_STRING
        );

    // sub-option 'monitor-timeout-ac'
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                        CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].pValue        = 
        &tChangeParam.ulVideoTimeoutAc;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_AC].szOption,
        CMDOPTION_MONITOR_OFF_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'monitor-timeout-dc'
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                        CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].pValue        = 
        &tChangeParam.ulVideoTimeoutDc;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_DC].szOption,
        CMDOPTION_MONITOR_OFF_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'disk-timeout-ac'
    cmdOptions[CMDINDEX_DISK_OFF_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_DISK_OFF_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_DISK_OFF_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_DISK_OFF_AC].pValue        = 
        &tChangeParam.ulSpindownTimeoutAc;
    cmdOptions[CMDINDEX_DISK_OFF_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_DISK_OFF_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_AC].szOption,
        CMDOPTION_DISK_OFF_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'disk-timeout-dc'
    cmdOptions[CMDINDEX_DISK_OFF_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_DISK_OFF_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_DISK_OFF_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_DISK_OFF_DC].pValue        = 
        &tChangeParam.ulSpindownTimeoutDc;
    cmdOptions[CMDINDEX_DISK_OFF_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_DISK_OFF_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_DC].szOption,
        CMDOPTION_DISK_OFF_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'standby-timeout-ac'
    cmdOptions[CMDINDEX_STANDBY_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_STANDBY_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_STANDBY_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_STANDBY_AC].pValue        = 
        &tChangeParam.ulIdleTimeoutAc;
    cmdOptions[CMDINDEX_STANDBY_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_STANDBY_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_AC].szOption,
        CMDOPTION_STANDBY_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'standby-timeout-dc'
    cmdOptions[CMDINDEX_STANDBY_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_STANDBY_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_STANDBY_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_STANDBY_DC].pValue        = 
        &tChangeParam.ulIdleTimeoutDc;
    cmdOptions[CMDINDEX_STANDBY_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_STANDBY_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_DC].szOption,
        CMDOPTION_STANDBY_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'hibernate-timeout-ac'
    cmdOptions[CMDINDEX_HIBER_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                  CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_HIBER_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_HIBER_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_HIBER_AC].pValue        = 
        &tChangeParam.ulDozeS4TimeoutAc;
    cmdOptions[CMDINDEX_HIBER_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_HIBER_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_AC].szOption,
        CMDOPTION_HIBER_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'hibernate-timeout-dc'
    cmdOptions[CMDINDEX_HIBER_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                  CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_HIBER_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_HIBER_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_HIBER_DC].pValue        = 
        &tChangeParam.ulDozeS4TimeoutDc;
    cmdOptions[CMDINDEX_HIBER_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_HIBER_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_DC].szOption,
        CMDOPTION_HIBER_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'processor-throttle-ac'
    cmdOptions[CMDINDEX_THROTTLE_AC].dwFlags       = CP_TYPE_TEXT | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_THROTTLE_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_THROTTLE_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_THROTTLE_AC].pValue        = lpszThrottleAcStr;
    cmdOptions[CMDINDEX_THROTTLE_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_THROTTLE_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_AC].szOption,
        CMDOPTION_THROTTLE_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_AC].szValues,
        NULL_STRING
        );

    // sub-option 'processor-throttle-dc'
    cmdOptions[CMDINDEX_THROTTLE_DC].dwFlags       = CP_TYPE_TEXT | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_THROTTLE_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_THROTTLE_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_THROTTLE_DC].pValue        = lpszThrottleDcStr;
    cmdOptions[CMDINDEX_THROTTLE_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_THROTTLE_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_DC].szOption,
        CMDOPTION_THROTTLE_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'file'
    cmdOptions[CMDINDEX_FILE].dwFlags       = CP_TYPE_TEXT |
                                              CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_FILE].dwCount       = 1;
    cmdOptions[CMDINDEX_FILE].dwActuals     = 0;
    cmdOptions[CMDINDEX_FILE].pValue        = lpszFile;
    cmdOptions[CMDINDEX_FILE].pFunction     = NULL;
    cmdOptions[CMDINDEX_FILE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_FILE].szOption,
        CMDOPTION_FILE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_FILE].szValues,
        NULL_STRING
        );
    
    // option 'globalpowerflag'
    cmdOptions[CMDINDEX_GLOBALFLAG].dwFlags      = CP_TYPE_TEXT | 
                                                   CP_VALUE_MANDATORY | 
                                                   CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_GLOBALFLAG].dwCount      = 1;
    cmdOptions[CMDINDEX_GLOBALFLAG].dwActuals     = 0;
    cmdOptions[CMDINDEX_GLOBALFLAG].pValue        = lpszBoolStr;
    cmdOptions[CMDINDEX_GLOBALFLAG].pFunction     = NULL;
    cmdOptions[CMDINDEX_GLOBALFLAG].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_GLOBALFLAG].szOption,
        CMDOPTION_GLOBALFLAG
        );
    lstrcpy(
        cmdOptions[CMDINDEX_GLOBALFLAG].szValues,
        NULL_STRING
        );

    // globalflag sub-option 'OPTION'
    cmdOptions[CMDINDEX_POWEROPTION].dwFlags       = CP_TYPE_TEXT | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_POWEROPTION].dwCount       = 1;
    cmdOptions[CMDINDEX_POWEROPTION].dwActuals     = 0;
    cmdOptions[CMDINDEX_POWEROPTION].pValue        = lpszGlobalFlagOption;
    cmdOptions[CMDINDEX_POWEROPTION].pFunction     = NULL;
    cmdOptions[CMDINDEX_POWEROPTION].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_POWEROPTION].szOption,
        CMDOPTION_POWEROPTION
        );
    lstrcpy(
        cmdOptions[CMDINDEX_POWEROPTION].szValues,
        NULL_STRING
        );

    // option 'batteryalarm'
    cmdOptions[CMDINDEX_BATTERYALARM].dwFlags       = CP_TYPE_TEXT | 
                                                      CP_VALUE_MANDATORY | 
                                                      CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_BATTERYALARM].dwCount       = 1;
    cmdOptions[CMDINDEX_BATTERYALARM].dwActuals     = 0;
    cmdOptions[CMDINDEX_BATTERYALARM].pValue        = lpszName;
    cmdOptions[CMDINDEX_BATTERYALARM].pFunction     = NULL;
    cmdOptions[CMDINDEX_BATTERYALARM].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_BATTERYALARM].szOption,
        CMDOPTION_BATTERYALARM
        );
    lstrcpy(
        cmdOptions[CMDINDEX_BATTERYALARM].szValues,
        NULL_STRING
        );

    // batteryalarm sub-option 'ACTIVATE'
    cmdOptions[CMDINDEX_ALARMACTIVE].dwFlags       = CP_TYPE_TEXT | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_ALARMACTIVE].dwCount       = 1;
    cmdOptions[CMDINDEX_ALARMACTIVE].dwActuals     = 0;
    cmdOptions[CMDINDEX_ALARMACTIVE].pValue        = lpszBoolStr;
    cmdOptions[CMDINDEX_ALARMACTIVE].pFunction     = NULL;
    cmdOptions[CMDINDEX_ALARMACTIVE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMACTIVE].szOption,
        CMDOPTION_ALARMACTIVE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMACTIVE].szValues,
        NULL_STRING
        );

    // batteryalarm sub-option 'LEVEL'
    cmdOptions[CMDINDEX_ALARMLEVEL].dwFlags       = CP_TYPE_UNUMERIC | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_ALARMLEVEL].dwCount       = 1;
    cmdOptions[CMDINDEX_ALARMLEVEL].dwActuals     = 0;
    cmdOptions[CMDINDEX_ALARMLEVEL].pValue        = &dwAlarmLevel;
    cmdOptions[CMDINDEX_ALARMLEVEL].pFunction     = NULL;
    cmdOptions[CMDINDEX_ALARMLEVEL].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMLEVEL].szOption,
        CMDOPTION_ALARMLEVEL
        );
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMLEVEL].szValues,
        NULL_STRING
        );

    // batteryalarm sub-option 'TEXT'
    cmdOptions[CMDINDEX_ALARMTEXT].dwFlags        = CP_TYPE_TEXT | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_ALARMTEXT].dwCount        = 1;
    cmdOptions[CMDINDEX_ALARMTEXT].dwActuals      = 0;
    cmdOptions[CMDINDEX_ALARMTEXT].pValue         = lpszAlarmTextBoolStr;
    cmdOptions[CMDINDEX_ALARMTEXT].pFunction      = NULL;
    cmdOptions[CMDINDEX_ALARMTEXT].pFunctionData  = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMTEXT].szOption,
        CMDOPTION_ALARMTEXT
        );
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMTEXT].szValues,
        NULL_STRING
        );

    // batteryalarm sub-option 'SOUND'
    cmdOptions[CMDINDEX_ALARMSOUND].dwFlags       = CP_TYPE_TEXT | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_ALARMSOUND].dwCount       = 1;
    cmdOptions[CMDINDEX_ALARMSOUND].dwActuals     = 0;
    cmdOptions[CMDINDEX_ALARMSOUND].pValue        = lpszAlarmSoundBoolStr;
    cmdOptions[CMDINDEX_ALARMSOUND].pFunction     = NULL;
    cmdOptions[CMDINDEX_ALARMSOUND].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMSOUND].szOption,
        CMDOPTION_ALARMSOUND
        );
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMSOUND].szValues,
        NULL_STRING
        );

    // batteryalarm sub-option 'ACTION'
    cmdOptions[CMDINDEX_ALARMACTION].dwFlags       = CP_TYPE_TEXT | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_ALARMACTION].dwCount       = 1;
    cmdOptions[CMDINDEX_ALARMACTION].dwActuals     = 0;
    cmdOptions[CMDINDEX_ALARMACTION].pValue        = lpszAlarmActionStr;
    cmdOptions[CMDINDEX_ALARMACTION].pFunction     = NULL;
    cmdOptions[CMDINDEX_ALARMACTION].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMACTION].szOption,
        CMDOPTION_ALARMACTION
        );
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMACTION].szValues,
        NULL_STRING
        );

    // batteryalarm sub-option 'FORCE'
    cmdOptions[CMDINDEX_ALARMFORCE].dwFlags       = CP_TYPE_TEXT | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_ALARMFORCE].dwCount       = 1;
    cmdOptions[CMDINDEX_ALARMFORCE].dwActuals     = 0;
    cmdOptions[CMDINDEX_ALARMFORCE].pValue        = lpszAlarmForceBoolStr;
    cmdOptions[CMDINDEX_ALARMFORCE].pFunction     = NULL;
    cmdOptions[CMDINDEX_ALARMFORCE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMFORCE].szOption,
        CMDOPTION_ALARMFORCE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMFORCE].szValues,
        NULL_STRING
        );

    // batteryalarm sub-option 'PROGRAM'
    cmdOptions[CMDINDEX_ALARMPROGRAM].dwFlags       = CP_TYPE_TEXT | 
                                                      CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_ALARMPROGRAM].dwCount       = 1;
    cmdOptions[CMDINDEX_ALARMPROGRAM].dwActuals     = 0;
    cmdOptions[CMDINDEX_ALARMPROGRAM].pValue        = lpszAlarmProgramBoolStr;
    cmdOptions[CMDINDEX_ALARMPROGRAM].pFunction     = NULL;
    cmdOptions[CMDINDEX_ALARMPROGRAM].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMPROGRAM].szOption,
        CMDOPTION_ALARMPROGRAM
        );
    lstrcpy(
        cmdOptions[CMDINDEX_ALARMPROGRAM].szValues,
        NULL_STRING
        );


    // parse parameters, take appropriate action
    if(DoParseParam(argc,argv,NUM_CMDS,cmdOptions))
    {
        
        // make sure only one command issued
        DWORD dwCmdCount = 0;
        DWORD dwParamCount = 0;
        for(dwIdx=0;dwIdx<NUM_CMDS;dwIdx++)
        {
            if (dwIdx < NUM_MAIN_CMDS)
            {
                dwCmdCount += cmdOptions[dwIdx].dwActuals;
            }
            else if (dwIdx != CMDINDEX_NUMERICAL)
            {
                dwParamCount += cmdOptions[dwIdx].dwActuals;
            }
        }        
        
        // determine other flags
        bQuery     = (cmdOptions[CMDINDEX_QUERY].dwActuals != 0);
        bCreate    = (cmdOptions[CMDINDEX_CREATE].dwActuals != 0);
        bDelete    = (cmdOptions[CMDINDEX_DELETE].dwActuals != 0);
        bSetActive = (cmdOptions[CMDINDEX_SETACTIVE].dwActuals != 0);
        bChange    = (cmdOptions[CMDINDEX_CHANGE].dwActuals != 0);   
        bHibernate = (cmdOptions[CMDINDEX_HIBERNATE].dwActuals != 0);
        bGlobalFlag = (cmdOptions[CMDINDEX_GLOBALFLAG].dwActuals != 0);
        bGetSupporedSStates = (cmdOptions[CMDINDEX_SSTATES].dwActuals != 0);
        bExport    = (cmdOptions[CMDINDEX_EXPORT].dwActuals != 0);
        bImport    = (cmdOptions[CMDINDEX_IMPORT].dwActuals != 0);
        bFile      = (cmdOptions[CMDINDEX_FILE].dwActuals != 0);
        tChangeParam.bVideoTimeoutAc = 
            (cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwActuals != 0);
        tChangeParam.bVideoTimeoutDc = 
            (cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwActuals != 0);
        tChangeParam.bSpindownTimeoutAc = 
            (cmdOptions[CMDINDEX_DISK_OFF_AC].dwActuals != 0);
        tChangeParam.bSpindownTimeoutDc = 
            (cmdOptions[CMDINDEX_DISK_OFF_DC].dwActuals != 0);
        tChangeParam.bIdleTimeoutAc = 
            (cmdOptions[CMDINDEX_STANDBY_AC].dwActuals != 0);
        tChangeParam.bIdleTimeoutDc = 
            (cmdOptions[CMDINDEX_STANDBY_DC].dwActuals != 0);
        tChangeParam.bDozeS4TimeoutAc = 
            (cmdOptions[CMDINDEX_HIBER_AC].dwActuals != 0);
        tChangeParam.bDozeS4TimeoutDc = 
            (cmdOptions[CMDINDEX_HIBER_DC].dwActuals != 0);
        tChangeParam.bDynamicThrottleAc =
            (cmdOptions[CMDINDEX_THROTTLE_AC].dwActuals != 0);
        tChangeParam.bDynamicThrottleDc =
            (cmdOptions[CMDINDEX_THROTTLE_DC].dwActuals != 0);
        tChangeParam.lpszDynamicThrottleAc = lpszThrottleAcStr;
        tChangeParam.lpszDynamicThrottleDc = lpszThrottleDcStr;
        bBatteryAlarm = (cmdOptions[CMDINDEX_BATTERYALARM].dwActuals != 0);

        // verify number
        if(bNumerical)
        {
            for(dwIdx=0; lpszName[dwIdx] != 0; dwIdx++) 
            {
                if((lpszName[dwIdx] < _T('0')) || 
                   (lpszName[dwIdx] > _T('9')))
                {
                    bFail = TRUE;
                    g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
                    break;
                }
            }
        }      

        //
        // parameter count validation
        //
        if ((dwCmdCount == 1) && 
            ((dwParamCount == 0) || 
             (bChange && (dwParamCount > 0) && (!bFile)) ||
             ((bImport || bExport) && bFile && (dwParamCount == 1)) ||
             (bGlobalFlag && (dwParamCount == 1)) ||
             ((bBatteryAlarm) && (dwParamCount <= 7))) &&
            ((!bNumerical) || ((lstrlen(lpszName) != 0) && (!bCreate))) &&
            (!bFail))
        {
            
            // check flags, take appropriate action
            if(bList)
            {
                DoList();
            }
            else if (bQuery)
            {
                bFail = !DoQuery(
                    lpszName,
                    (lstrlen(lpszName) != 0),
                    bNumerical
                    );
            }
            else if (bCreate)
            {
                bFail = !DoCreate(
                    lpszName
                    );
            }
            else if (bDelete)
            {
                bFail = !DoDelete(
                    lpszName,
                    bNumerical
                    );
            }
            else if (bSetActive)
            {
                bFail = !DoSetActive(
                    lpszName,
                    bNumerical
                    );
            }
            else if (bChange)
            {
                bFail = !DoChange(
                    lpszName,
                    bNumerical,
                    &tChangeParam
                    );
            }
            else if (bHibernate)
            {
                bFail = !DoHibernate(lpszBoolStr);
            } 
            else if (bGlobalFlag)
            {
                bFail = !DoGlobalFlag(lpszBoolStr,lpszGlobalFlagOption);
            } 
            else if (bGetSupporedSStates) 
            {
                bFail = !DoGetSupportedSStates();
            }
            else if (bExport)
            {
                bFail = !DoExport(
                    lpszName,
                    bNumerical,
                    lpszFile
                    );
            }
            else if (bImport)
            {
                bFail = !DoImport(
                    lpszName,
                    bNumerical,
                    lpszFile
                    );
            }
            else if (bBatteryAlarm) 
            {
                bFail = !DoBatteryAlarm(
                    lpszName, 
                    (cmdOptions[CMDINDEX_ALARMACTIVE].dwActuals!=0) ? 
                        lpszBoolStr : NULL,
                    dwAlarmLevel,
                    (cmdOptions[CMDINDEX_ALARMTEXT].dwActuals!=0) ? 
                        lpszAlarmTextBoolStr : NULL,
                    (cmdOptions[CMDINDEX_ALARMSOUND].dwActuals!=0) ? 
                        lpszAlarmSoundBoolStr : NULL,
                    (cmdOptions[CMDINDEX_ALARMACTION].dwActuals!=0) ? 
                        lpszAlarmActionStr : NULL,
                    (cmdOptions[CMDINDEX_ALARMFORCE].dwActuals!=0) ? 
                        lpszAlarmForceBoolStr : NULL,
                    (cmdOptions[CMDINDEX_ALARMPROGRAM].dwActuals!=0) ? 
                        lpszAlarmProgramBoolStr : NULL
                    );
            }
            else if (bUsage)
            {
                DoUsage();
            }
            else 
            {
                if(lstrlen(g_lpszErr) == 0)
                {
                    g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
                }
                bFail = TRUE;
            }
        } 
        else 
        {
            // handle error conditions
            if(lstrlen(g_lpszErr) == 0)
            {
                g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
            }
            bFail = TRUE;
        }
    } 
    else
    {
        g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
        bFail = TRUE;
    }
    
    // check error status, display msg if needed
    if(bFail)
    {
        if(g_lpszErr2)
        {
            DISPLAY_MESSAGE(stderr,g_lpszErr2);
        }
        else
        {
            DISPLAY_MESSAGE(stderr,g_lpszErr);
        }
    }

    // clean up allocs
    LocalFree(lpszBoolStr);
    LocalFree(lpszName);
    LocalFree(lpszFile);
    LocalFree(lpszThrottleAcStr);
    LocalFree(lpszThrottleDcStr);
    LocalFree(lpszGlobalFlagOption);
    LocalFree(lpszAlarmTextBoolStr);
    LocalFree(lpszAlarmSoundBoolStr);
    LocalFree(lpszAlarmActionStr);
    LocalFree(lpszAlarmForceBoolStr);
    LocalFree(lpszAlarmProgramBoolStr);
    if (g_lpszErr2)
    {
        LocalFree(g_lpszErr2);
    }
    FreeLibrary(hLib);

    // return appropriate result code
    if(bFail)
    {
        return EXIT_FAILURE;
    }
    else
    {
        return EXIT_SUCCESS;
    }
}


BOOL
FreeScheme(
    PSCHEME_LIST psl
)
/*++
 
Routine Description:
 
    Frees the memory associated with a scheme list entry.
 
Arguments:
 
    psl - the PSCHEME_LIST to be freed
    
Return Value:

    Always returns TRUE, indicating success.
 
--*/
{
    LocalFree(psl->lpszName);
    LocalFree(psl->lpszDesc);
    LocalFree(psl->ppp);
    LocalFree(psl->pmppp);
    LocalFree(psl);
    return TRUE;
}


BOOL 
FreeSchemeList(
    PSCHEME_LIST psl, 
    PSCHEME_LIST pslExcept
)
/*++
 
Routine Description:
 
    Deallocates all power schemes in a linked-list of power schemes, except
    for the one pointed to by pslExcept
 
Arguments:
 
    psl - the power scheme list to deallocate
    pslExcept - a scheme not to deallocate (null to deallocate all)
    
Return Value:
 
    Always returns TRUE, indicating success.
 
--*/
{
    PSCHEME_LIST cur = psl;
    PSCHEME_LIST next;
    while (cur != NULL)
    {
        next = CONTAINING_RECORD(
            cur->le.Flink,
            SCHEME_LIST,
            le
            );
        if (cur != pslExcept)
        {
            FreeScheme(cur);
        }
        else
        {
            cur->le.Flink = NULL;
            cur->le.Blink = NULL;
        }
        cur = next;
    }
    return TRUE;
}


PSCHEME_LIST 
CreateScheme(
    UINT                    uiID,
    DWORD                   dwNameSize,
    LPCTSTR                 lpszName,
    DWORD                   dwDescSize,
    LPCTSTR                 lpszDesc,
    PPOWER_POLICY           ppp
)
/*++
 
Routine Description:
 
    Builds a policy list entry.  Note that the scheme is allocated and must
    be freed when done.
 
Arguments:
 
    uiID - the numerical ID of the scheme
    dwNameSize - the number of bytes needed to store lpszName
    lpszName - the name of the scheme
    dwDescSize - the number of bytes needed to store lpszDesc
    lpszDesc - the description of the scheme
    ppp - the power policy for this scheme, may be NULL
    
Return Value:
 
    A PSCHEME_LIST entry containing the specified values, with the next
    entry field set to NULL
 
--*/
{
    
    PSCHEME_LIST psl = (PSCHEME_LIST)LocalAlloc(LPTR,sizeof(SCHEME_LIST));
    
    if (psl)
    {    
        // deal with potentially null input strings
        if(lpszName == NULL)
        {
            lpszName = NULL_STRING;
        }
        if(lpszDesc == NULL)
        {
            lpszDesc = NULL_STRING;
        }

        // allocate fields
        psl->ppp = (PPOWER_POLICY)LocalAlloc(LPTR,sizeof(POWER_POLICY));
        if (!psl->ppp)
        {
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        psl->pmppp = (PMACHINE_PROCESSOR_POWER_POLICY)LocalAlloc(
            LPTR,
            sizeof(MACHINE_PROCESSOR_POWER_POLICY)
            );
        if (!psl->pmppp)
        {
            LocalFree(psl->ppp);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        psl->lpszName = (LPTSTR)LocalAlloc(LPTR,dwNameSize);
        if (!psl->lpszName)
        {
            LocalFree(psl->ppp);
            LocalFree(psl->pmppp);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        psl->lpszDesc = (LPTSTR)LocalAlloc(LPTR,dwDescSize);
        if (!psl->lpszDesc)
        {
            LocalFree(psl->ppp);
            LocalFree(psl->pmppp);
            LocalFree(psl->lpszName);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        
        // initialize structure
        psl->uiID = uiID;
        memcpy(psl->lpszName,lpszName,dwNameSize);
        memcpy(psl->lpszDesc,lpszDesc,dwDescSize);
        if (ppp)
        {
            memcpy(psl->ppp,ppp,sizeof(POWER_POLICY));
        }
        psl->le.Flink = NULL;
        psl->le.Blink = NULL;

    } 
    else
    {
        g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
    }
    return psl;
}


BOOLEAN CALLBACK 
PowerSchemeEnumProc(
    UINT                    uiID,
    DWORD                   dwNameSize,
    LPTSTR                  lpszName,
    DWORD                   dwDescSize,
    LPTSTR                  lpszDesc,
    PPOWER_POLICY           ppp,
    LPARAM                  lParam
)
/*++
 
Routine Description:
 
    This is a callback used in retrieving the policy list.
 
Arguments:
 
    uiID - the numerical ID of the scheme
    dwNameSize - the number of bytes needed to store lpszName
    lpszName - the name of the scheme
    dwDescSize - the number of bytes needed to store lpszDesc
    lpszDesc - the description of the scheme
    ppp - the power policy for this scheme
    lParam - used to hold a pointer to the head-of-list pointer, allowing
             for insertions at the head of the list
    
Return Value:
 
    TRUE to continue enumeration
    FALSE to abort enumeration
 
--*/
{
    PSCHEME_LIST psl;
    
    // Allocate and initalize a policies element.
    if ((psl = CreateScheme(
            uiID, 
            dwNameSize, 
            lpszName, 
            dwDescSize, 
            lpszDesc, 
            ppp
            )) != NULL)
    {
        // add the element to the head of the linked list
        psl->le.Flink = *((PLIST_ENTRY *)lParam);
        if(*((PLIST_ENTRY *)lParam))
        {
            (*((PLIST_ENTRY *)lParam))->Blink = &(psl->le);
        }
        (*(PLIST_ENTRY *)lParam) = &(psl->le);
        return TRUE;
    }
    return FALSE;
}


PSCHEME_LIST 
CreateSchemeList() 
/*++
 
Routine Description:
 
    Creates a linked list of existing power schemes.
 
Arguments:
 
    None
    
Return Value:
 
    A pointer to the head of the list.  
    NULL would correspond to an empty list.
 
--*/
{
    PLIST_ENTRY ple = NULL;
    PSCHEME_LIST psl;
    fEnumPwrSchemes(PowerSchemeEnumProc, (LPARAM)(&ple));
    if(ple)
    {
        PSCHEME_LIST res = CONTAINING_RECORD(
            ple,
            SCHEME_LIST,
            le
            );
        psl = res;
        if(g_bProcessorPwrSchemeSupported) {
            while(psl != NULL)
            {
                if(!fReadProcessorPwrScheme(psl->uiID,psl->pmppp))
                {
                    FreeSchemeList(res,NULL);
                    g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
                    return NULL;
                }
                psl = CONTAINING_RECORD(
                    psl->le.Flink,
                    SCHEME_LIST,
                    le
                    );
            }
        }
        return res;
    }
    else
    {
        return NULL;
    }
}


PSCHEME_LIST 
FindScheme(
    LPCTSTR lpszName,
    UINT    uiID,
    BOOL    bNumerical
)
/*++
 
Routine Description:
 
    Finds the policy with the matching name.  If lpszName is NULL,
    the scheme is found by uiID instead.  If bNumerical is TRUE,
    lpszName will be interpreted as a numerical identifier instead.
 
Arguments:
 
    lpszName - the name of the scheme to find
    uiID - the numerical identifier of the scheme
    bNumerical - causes lpszName to be interpreted as a numerical identifier
    
Return Value:
 
    the matching scheme list entry, null if none
 
--*/
{
    PSCHEME_LIST psl = CreateSchemeList();
    PSCHEME_LIST pslRes = NULL;

    // process bNumerical option
    if(bNumerical && lpszName) {
        uiID = _ttoi(lpszName);
        lpszName = NULL;
    }

    // find scheme entry
    while(psl != NULL)
    {
        // check for match
        if (((lpszName != NULL) && (!lstrcmpi(lpszName, psl->lpszName))) ||
            ((lpszName == NULL) && (uiID == psl->uiID)))
        { 
            pslRes = psl;
            break;
        }
        // traverse list
        psl = CONTAINING_RECORD(
            psl->le.Flink,
            SCHEME_LIST,
            le
            );
    }
    FreeSchemeList(psl,pslRes); // all except for pslRes
    if (pslRes == NULL)
        g_lpszErr = GetResString(IDS_SCHEME_NOT_FOUND);
    return pslRes;
}

BOOL 
MyWriteScheme(
    PSCHEME_LIST psl
)
/*++

Routine Description:
 
    Writes a power scheme -- both user/machine power policies and
    processor power policy.  The underlying powrprof.dll does not
    treat the processor power policy as part of the power policy
    because the processor power policies were added at a later
    date and backwards compatibility must be maintained.
 
Arguments:
 
    psl - The  scheme list entry to write
    
Return Value:
 
    TRUE if successful, otherwise FALSE
 
--*/
{
    g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
    if(fWritePwrScheme(
        &psl->uiID,
        psl->lpszName,
        psl->lpszDesc,
        psl->ppp))
    {
        if(g_bProcessorPwrSchemeSupported) {
            return fWriteProcessorPwrScheme(
                psl->uiID,
                psl->pmppp
                );
        }
        else
        {
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }
}


BOOL 
MapIdleValue(
    ULONG           ulVal, 
    PULONG          pulIdle, 
    PULONG          pulHiber,
    PPOWER_ACTION   ppapIdle
)
/*++
 
Routine Description:
 
    Modifies Idle and Hibernation settings to reflect the desired idle
    timeout. See GUI tool's PWRSCHEM.C MapHiberTimer for logic.
 
Arguments:
 
    ulVal - the new idle timeout
    pulIdle - the idle timeout variable to be updated
    pulHiber - the hiber timeout variable to be updated
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    // if previously, hiber was enabled and standby wasn't, standby timer
    // takes over the hibernation timer's role
    if (*ppapIdle == PowerActionHibernate)
    {
        if (ulVal > 0)
        { // enable standby
            *pulHiber = *pulIdle + ulVal;
            *pulIdle = ulVal;
            *ppapIdle = PowerActionSleep;
        }
        else { // standby already disabled, no change
        }
    } 
    else // standby timer actually being used for standby (not hiber)
    {
        if (ulVal > 0)
        { // enable standby
            if ((*pulHiber) != 0)
            {
                *pulHiber = *pulHiber + ulVal - *pulIdle;
            }
            *pulIdle = ulVal;
            if (ulVal > 0)
            {
                *ppapIdle = PowerActionSleep;
            }
            else
            {
                *ppapIdle = PowerActionNone;
            }
        } 
        else 
        { // disable standby
            if ((*pulHiber) != 0) 
            {
                *pulIdle = *pulHiber;
                *pulHiber = 0;
                *ppapIdle = PowerActionHibernate;
            } 
            else 
            {
                *pulIdle = 0;
                *ppapIdle = PowerActionNone;
            }      
        }
    }
    return TRUE;
}


BOOL 
MapHiberValue(
    ULONG           NewHibernateTimeout, 
    PULONG           pExistingStandbyTimeout,
    PULONG          pHIbernateTimeoutVariable,
    PPOWER_ACTION   pIdlePowerAction

)
/*++
 
Routine Description:
 
    Modifies Idle and Hibernation settings to reflect the desired hibernation
    timeout. See GUI tool's PWRSCHEM.C MapHiberTimer for logic.
 
Arguments:
 
    NewHibernateTimeout - the new hibernation timeout the user is
                          asking us to apply.
                          
    pExistingStandbyTimeout - existing standby timeout.
                           
    pHIbernateTimeoutVariable - existing hibernate timeout variable which will
                                be updated with the new value being sent in.
    
    pIdlePowerAction - existing power action to take after specified idle timeout.

Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/

{
    //
    // check valid input
    //
    if( (NewHibernateTimeout != 0) &&
        (NewHibernateTimeout < *pExistingStandbyTimeout) ) {
        //
        // He's asking us to set the hibernate timeout
        // to be less than the standby timer.  We disallow this.
        //
        g_lpszErr = GetResString(IDS_HIBER_OUT_OF_RANGE);
        return FALSE;
    }


    //
    // check to see if we can even enable hibernation.
    //
    if( (NewHibernateTimeout != 0) &&
        (!g_bHiberFileSupported) ) {

        g_lpszErr = GetResString(IDS_HIBER_UNSUPPORTED);
        return FALSE;

    }

    //
    // We're ready to update our timeout value.
    //
    if( NewHibernateTimeout == 0 ) {

        //
        // He's asking us to set the timeout to zero, which
        // is synonymous with simply disabling hibernate.
        //
        *pHIbernateTimeoutVariable = NewHibernateTimeout;


        //
        // Now fix up our idle PowerAction.  It can no longer
        // be set to hibernate, so our choices are either sleep
        // or nothing.  Set it according to whether sleep is even
        // supported on this machine.
        //
        *pIdlePowerAction = g_bStandbySupported ? PowerActionSleep : PowerActionNone; 

        //
        // Care here.  if we just set our idle PowerAction to do nothing,
        // make sure our standby idle timeout is set to zero.
        //
        *pExistingStandbyTimeout = 0;

    } else {

        //
        // He wants to set some timeout.  But the standby and
        // hibernate timeouts are somewhat related.  If he
        // wants the system to hibernate after 60 minutes of
        // idle time, but the standby is set to 20, then what
        // he's really asking is for us to set the hibernate to
        // 40.  This means that after 20 minutes of idle, the system
        // will go to standby and we'll set a 40 minute timer to
        // tell the system to go to hibernate.  If we set that timer
        // to 60 minutes, then the system wouldn't actually hibernate
        // until after 20+60=80 minutes.  Therefore, set the timeout
        // to what he's asking for, minus the existing standby timeout.
        //
        *pHIbernateTimeoutVariable = NewHibernateTimeout - *pExistingStandbyTimeout;


        //
        // Now fix up our idle PowerAction.  If we don't support sleep on this
        // machine, then we need to set the idle PowerAction to hibernate.
        //
        *pIdlePowerAction = g_bStandbySupported ? PowerActionSleep : PowerActionHibernate; 
    }
    return TRUE;
}


BOOL 
DoList() 
/*++
 
Routine Description:
 
    Lists the existing power schemes on stdout
 
Arguments:
 
    none
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    PSCHEME_LIST psl = CreateSchemeList();
    if (psl != NULL) 
    {
        DISPLAY_MESSAGE(stdout,GetResString(IDS_LIST_HEADER1));
        DISPLAY_MESSAGE(stdout,GetResString(IDS_LIST_HEADER2));
    } 
    else
    {
      return FALSE;
    }
    while(psl != NULL) 
    {
        DISPLAY_MESSAGE(stdout, psl->lpszName);
        DISPLAY_MESSAGE(stdout, L"\n");
        psl = CONTAINING_RECORD(
            psl->le.Flink,
            SCHEME_LIST,
            le
            );
    }
    FreeSchemeList(psl,NULL); // free all entries
    return TRUE;
}


BOOL 
DoQuery(
    LPCTSTR lpszName, 
    BOOL bNameSpecified,
    BOOL bNumerical
)
/*++
 
Routine Description:
 
    Show details of an existing scheme
 
Arguments:
 
    lpszName - the name of the scheme
    bNameSpecified - if TRUE, lpszName ignored and shows details
                     of active power scheme instead
    bNumerical - if TRUE, lpszName interpreted as numerical identifier
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    
    PSCHEME_LIST psl;

    // check if querying specific scheme or active scheme and deal w/it
    if (bNameSpecified) 
    {
        psl = FindScheme(
            lpszName,
            0,
            bNumerical
            );
    } 
    else  // fetch the active scheme
    {
        UINT uiID;
        if (fGetActivePwrScheme(&uiID)) 
        {
            psl = FindScheme(NULL,uiID,FALSE);
        } 
        else 
        {
            g_lpszErr = GetResString(IDS_ACTIVE_SCHEME_INVALID);
            return FALSE;
        }
    }
    
    // display info
    if (psl) 
    {
        
        // header
        DISPLAY_MESSAGE(stdout, GetResString(IDS_QUERY_HEADER1));
        DISPLAY_MESSAGE(stdout, GetResString(IDS_QUERY_HEADER2));
        
        // name
        DISPLAY_MESSAGE1(
            stdout,
            g_lpszBuf,
            GetResString(IDS_SCHEME_NAME),
            psl->lpszName
            );
        
        // id
        DISPLAY_MESSAGE1(
            stdout,
            g_lpszBuf,
            GetResString(IDS_SCHEME_ID),
            psl->uiID
            );

        // monitor timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_MONITOR_TIMEOUT_AC));
        if (!g_bMonitorPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.VideoTimeoutAc == 0) {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.VideoTimeoutAc/60
                );
        }

        // monitor timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_MONITOR_TIMEOUT_DC));
        if (!g_bMonitorPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.VideoTimeoutDc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.VideoTimeoutDc/60
                );
        }

        // disk timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_DISK_TIMEOUT_AC));
        if (!g_bDiskPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.SpindownTimeoutAc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.SpindownTimeoutAc/60
                );
        }
        
        // disk timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_DISK_TIMEOUT_DC));
        if (!g_bDiskPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.SpindownTimeoutDc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.SpindownTimeoutDc/60
                );
        }

        // standby timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_STANDBY_TIMEOUT_AC));
        if (!g_bStandbySupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if ((psl->ppp->user.IdleAc.Action != PowerActionSleep) ||
                 (psl->ppp->user.IdleTimeoutAc == 0))
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }         
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.IdleTimeoutAc/60
                );
        }

        // standby timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_STANDBY_TIMEOUT_DC));
        if (!g_bStandbySupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if ((psl->ppp->user.IdleDc.Action != PowerActionSleep) ||
                 (psl->ppp->user.IdleTimeoutDc == 0))
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }         
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.IdleTimeoutDc/60
                );
        }

        // hibernate timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_HIBER_TIMEOUT_AC));
        if (!g_bHiberFileSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->mach.DozeS4TimeoutAc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
             DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                (psl->ppp->mach.DozeS4TimeoutAc + 
                 psl->ppp->user.IdleTimeoutAc)/60
                );
        }

        // hibernate timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_HIBER_TIMEOUT_DC));
        if (!g_bHiberFileSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->mach.DozeS4TimeoutDc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
             DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                (psl->ppp->mach.DozeS4TimeoutDc + 
                 psl->ppp->user.IdleTimeoutDc)/60
                );
        }

        // throttle policy AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_AC));
        if (!g_bThrottleSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else 
        {
            switch(psl->pmppp->ProcessorPolicyAc.DynamicThrottle) 
            {
                case PO_THROTTLE_NONE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_NONE));
                    break;
                case PO_THROTTLE_CONSTANT:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_CONSTANT));
                    break;
                case PO_THROTTLE_DEGRADE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_DEGRADE));
                    break;
                case PO_THROTTLE_ADAPTIVE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_ADAPTIVE));
                    break;
                default:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_UNKNOWN));
                    break;
            }
        }

        // throttle policy DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_DC));
        if (!g_bThrottleSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else 
        {
            switch(psl->pmppp->ProcessorPolicyDc.DynamicThrottle) {
                case PO_THROTTLE_NONE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_NONE));
                    break;
                case PO_THROTTLE_CONSTANT:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_CONSTANT));
                    break;
                case PO_THROTTLE_DEGRADE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_DEGRADE));
                    break;
                case PO_THROTTLE_ADAPTIVE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_ADAPTIVE));
                    break;
                default:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_UNKNOWN));
                    break;
            }
        }


        FreeScheme(psl);
        return TRUE;
  } 
  else 
  {
      return FALSE;
  }
}


BOOL DoCreate(
    LPTSTR lpszName
)
/*++
 
Routine Description:
 
    Adds a new power scheme
    The description will match the name
    All other details are copied from the active power scheme
    Fails if scheme already exists
 
Arguments:
 
    lpszName - the name of the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    PSCHEME_LIST psl = FindScheme(
        lpszName,
        0,
        FALSE
        );
    UINT uiID;
    BOOL bRes;
    LPTSTR lpszNewName;
    LPTSTR lpszNewDesc;
    if(psl)  // already existed -> fail
    {
        FreeScheme(psl);
        g_lpszErr = GetResString(IDS_SCHEME_ALREADY_EXISTS);
        return FALSE;
    }
    
    // create a new scheme
    if(fGetActivePwrScheme(&uiID))
    {
        psl = FindScheme(NULL,uiID,FALSE);
        if(!psl) 
        {
            g_lpszErr = GetResString(IDS_SCHEME_CREATE_FAIL);
            return FALSE;
        }
        lpszNewName = (LPTSTR)LocalAlloc(LPTR,(lstrlen(lpszName)+1)*sizeof(TCHAR));
        if(!lpszNewName) 
        {
            FreeScheme(psl);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return FALSE;
        }
        lpszNewDesc = (LPTSTR)LocalAlloc(LPTR,(lstrlen(lpszName)+1)*sizeof(TCHAR));
        if(!lpszNewDesc) 
        {
            LocalFree(lpszNewName);
            FreeScheme(psl);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return FALSE;
        }
        lstrcpy(lpszNewName,lpszName);
        lstrcpy(lpszNewDesc,lpszName);
        LocalFree(psl->lpszName);
        LocalFree(psl->lpszDesc);
        psl->lpszName = lpszNewName;
        psl->lpszDesc = lpszNewDesc;
        psl->uiID = NEWSCHEME;
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);            
        bRes = MyWriteScheme(psl);
        FreeScheme(psl);
        return bRes;
    }
    
    g_lpszErr = GetResString(IDS_SCHEME_CREATE_FAIL);
    
    return FALSE;
    
}


BOOL DoDelete(
    LPCTSTR lpszName,
    BOOL bNumerical
)
/*++
 
Routine Description:
 
    Deletes an existing scheme
 
Arguments:
 
    lpszName - the name of the scheme
    bNumerical - if TRUE, lpszName interpreted as numerical identifier
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    PSCHEME_LIST psl = FindScheme(
        lpszName,
        0,
        bNumerical
        );
    
    if (psl) 
    {
        BOOL bRes = fDeletePwrScheme(psl->uiID);
        FreeScheme(psl);
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
        return bRes;
    } 
    else 
    {
        return FALSE;
    }
}


BOOL DoSetActive(
    LPCTSTR lpszName,
    BOOL bNumerical
)
/*++
 
Routine Description:
 
    Sets the active scheme
 
Arguments:
 
    lpszName - the name of the scheme
    bNumerical - if TRUE, lpszName interpreted as numerical identifier
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    
    PSCHEME_LIST psl = FindScheme(
        lpszName,
        0,
        bNumerical
        );
    
    if (psl) 
    {
        BOOL bRes = fSetActivePwrScheme(
            psl->uiID,
            NULL,
            NULL
            );
        FreeScheme(psl);
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
        return bRes;
    } 
    else 
    {
        return FALSE;
    }
}


BOOL 
DoChange(
    LPCTSTR lpszName, 
    BOOL bNumerical,
    PCHANGE_PARAM pcp
)
/*++
 
Routine Description:
 
    Modifies an existing scheme
 
Arguments:
 
    lpszName - the name of the scheme
    bNumerical - if TRUE, lpszName interpreted as numerical identifier
    pcp - PCHANGE_PARAM pointing to the parameter structure,
          indicates which variable(s) to change
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    BOOL bRes = TRUE;
    PSCHEME_LIST psl = FindScheme(
        lpszName,
        0,
        bNumerical
        );
    
    if (psl) 
    {
        // check for feature support
        if ((pcp->bIdleTimeoutAc || 
             pcp->bIdleTimeoutDc) && 
            !g_bStandbySupported) 
        {
            DISPLAY_MESSAGE(stderr, GetResString(IDS_STANDBY_WARNING));
        }
        if ((pcp->bDozeS4TimeoutAc || 
             pcp->bDozeS4TimeoutDc) &&
             g_bStandbySupported &&
            !g_bHiberTimerSupported) 
        {
            //
            // The wake from realtime clock in order to hibernate
            // the system may not work.  Warn the user.
            //
            DISPLAY_MESSAGE(stderr, GetResString(IDS_HIBER_WARNING));
        }
        if ((pcp->bVideoTimeoutAc || 
             pcp->bVideoTimeoutDc) && 
            !g_bMonitorPowerSupported)
        {
            DISPLAY_MESSAGE(stderr, GetResString(IDS_MONITOR_WARNING));
        }
        if ((pcp->bSpindownTimeoutAc || 
             pcp->bSpindownTimeoutDc) && 
            !g_bDiskPowerSupported)
        {
            DISPLAY_MESSAGE(stderr, GetResString(IDS_DISK_WARNING));
        }


        // change params
        if (pcp->bVideoTimeoutAc)
        {
            psl->ppp->user.VideoTimeoutAc = pcp->ulVideoTimeoutAc*60;
        }
        if (pcp->bVideoTimeoutDc)
        {
            psl->ppp->user.VideoTimeoutDc = pcp->ulVideoTimeoutDc*60;
        }
        if (pcp->bSpindownTimeoutAc)
        {
            psl->ppp->user.SpindownTimeoutAc = pcp->ulSpindownTimeoutAc*60;
        }
        if (pcp->bSpindownTimeoutDc)
        {
            psl->ppp->user.SpindownTimeoutDc = pcp->ulSpindownTimeoutDc*60;
        }
        if (pcp->bIdleTimeoutAc)
        {
            bRes = bRes & MapIdleValue(
                pcp->ulIdleTimeoutAc*60,
                &psl->ppp->user.IdleTimeoutAc,
                &psl->ppp->mach.DozeS4TimeoutAc,
                &psl->ppp->user.IdleAc.Action
                );
        }
        if (pcp->bIdleTimeoutDc)
        {
            bRes = bRes & MapIdleValue(
                pcp->ulIdleTimeoutDc*60,
                &psl->ppp->user.IdleTimeoutDc,
                &psl->ppp->mach.DozeS4TimeoutDc,
                &psl->ppp->user.IdleDc.Action
                );
        }
        if (pcp->bDozeS4TimeoutAc)
        {
            bRes = bRes & MapHiberValue(
                pcp->ulDozeS4TimeoutAc*60,
                &psl->ppp->user.IdleTimeoutAc,
                &psl->ppp->mach.DozeS4TimeoutAc,
                &psl->ppp->user.IdleAc.Action
                );
        }
        if (pcp->bDozeS4TimeoutDc)
        {
            bRes = bRes & MapHiberValue(
                pcp->ulDozeS4TimeoutDc*60,
                &psl->ppp->user.IdleTimeoutDc,
                &psl->ppp->mach.DozeS4TimeoutDc,
                &psl->ppp->user.IdleDc.Action
                );
        }
        if (pcp->bDynamicThrottleAc)
        {
            if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("NONE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_NONE;
            } 
            else if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("CONSTANT")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_CONSTANT;
            } 
            else if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("DEGRADE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_DEGRADE;
            } 
            else if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("ADAPTIVE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_ADAPTIVE;
            } 
            else 
            {
                g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
                bRes = FALSE;
            }
        }
        if (pcp->bDynamicThrottleDc)
        {

            if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("NONE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_NONE;
            } 
            else if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("CONSTANT")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_CONSTANT;
            } 
            else if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("DEGRADE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_DEGRADE;
            } 
            else if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("ADAPTIVE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_ADAPTIVE;
            } 
            else 
            {
                g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
                bRes = FALSE;
            }
        }

        if (bRes)
        {
            // attempt to update power scheme
            g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
            
            bRes = MyWriteScheme(psl);
            
            // keep active power scheme consistent
            if (bRes)
            {
                UINT uiIDactive;

                if (fGetActivePwrScheme(&uiIDactive) && 
                    (psl->uiID == uiIDactive))
                {
                  bRes = fSetActivePwrScheme(psl->uiID,NULL,NULL);
                }
            }

            FreeScheme(psl);
            return bRes;
        } 
        else
        {
            return FALSE;
        }
    } 
    else
    {
        return FALSE;
    }
}


BOOL 
DoExport(
  LPCTSTR lpszName,
  BOOL bNumerical,
  LPCTSTR lpszFile
)
/*++
 
Routine Description:
 
    Exports a power scheme
 
Arguments:
 
    lpszName - the name of the scheme
    bNumerical - if TRUE, lpszName interpreted as numerical identifier
    lpszFile - the file to hold the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    DWORD res; // write result value
    HANDLE f; // file handle

    // find scheme
    PSCHEME_LIST psl = FindScheme(
        lpszName,
        0,
        bNumerical
        );
    if(!psl) {
        return FALSE;
    }

    // write to file
    f = CreateFile(
        lpszFile,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (f == INVALID_HANDLE_VALUE) 
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        FreeScheme(psl);
        return FALSE;
    }
    if (!WriteFile(
        f,
        psl->ppp,
        sizeof(POWER_POLICY),
        &res,
        NULL
        ))
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        CloseHandle(f);
        FreeScheme(psl);
        return FALSE;
    }
    if (g_bProcessorPwrSchemeSupported)
    {
        if (!WriteFile(
            f,
            psl->pmppp,
            sizeof(MACHINE_PROCESSOR_POWER_POLICY),
            &res,
            NULL
            ))
        {
            FormatMessage( 
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                    FORMAT_MESSAGE_FROM_SYSTEM | 
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    GetLastError(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR)&g_lpszErr2,
                    0,
                    NULL 
                    );
            CloseHandle(f);
            FreeScheme(psl);
            return FALSE;
        }
    }
    CloseHandle(f);
    FreeScheme(psl);
    return TRUE;
}


BOOL 
DoImport(
  LPCTSTR lpszName,
  BOOL bNumerical,
  LPCTSTR lpszFile
)
/*++
 
Routine Description:
 
    Imports a power scheme
    If the scheme already exists, overwrites it
 
Arguments:
 
    lpszName - the name of the scheme
    bNumerical - if TRUE, lpszName interpreted as numerical identifier
    lpszFile - the file that holds the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    DWORD res; // write result value
    HANDLE f; // file handle
    UINT uiIDactive; // active ID

    PSCHEME_LIST psl;
    
    // check for pre-existing scheme
    psl = FindScheme(
        lpszName,
        0,
        bNumerical
        );

    // if didn't exist, create it (if actual name given)
    if (!psl)
    {
        if (!bNumerical)
        {
            psl = CreateScheme(
                NEWSCHEME,
                (lstrlen(lpszName)+1)*sizeof(TCHAR),
                lpszName,
                (lstrlen(lpszName)+1)*sizeof(TCHAR),
                lpszName,
                NULL // psl->ppp will be allocated but uninitialized
                );
            // check for successful alloc
            if(!psl) 
            {
                return FALSE;
            }
        } 
        else 
        {
            g_lpszErr = GetResString(IDS_INVALID_NUMERICAL_IMPORT);
            return FALSE;
        }
    }

    // open file
    f = CreateFile(
        lpszFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (f == INVALID_HANDLE_VALUE) 
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        FreeScheme(psl);
        return FALSE;
    }

    // read scheme
    if (!ReadFile(
        f,
        psl->ppp,
        sizeof(POWER_POLICY),
        &res,
        NULL
        ))
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        CloseHandle(f);
        FreeScheme(psl);
        return FALSE;
    }
    if (g_bProcessorPwrSchemeSupported)
    {
        if (!ReadFile(
            f,
            psl->pmppp,
            sizeof(MACHINE_PROCESSOR_POWER_POLICY),
            &res,
            NULL
            ))
        {
            // copy processor profile from the active scheme, 
            // thus supporting Win2k->WinXP imports
            if(fGetActivePwrScheme(&uiIDactive))
            {
                PSCHEME_LIST pslActive = FindScheme(
                    NULL,
                    uiIDactive,
                    FALSE
                    );
                if(!pslActive) 
                {
                    g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
                    CloseHandle(f);
                    FreeScheme(psl);
                    return FALSE;
                }
                memcpy(
                    psl->pmppp,
                    pslActive->pmppp,
                    sizeof(MACHINE_PROCESSOR_POWER_POLICY)
                    );
                FreeScheme(pslActive);
            } 
            else 
            {
                g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
                CloseHandle(f);
                FreeScheme(psl);
                return FALSE;
            }
        }
    }

    CloseHandle(f);
    g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);

    // save scheme
    if (!MyWriteScheme(psl))
    {
        FreeScheme(psl);        
        return FALSE;
    }

    // check against active scheme
    if (!fGetActivePwrScheme(&uiIDactive))
    {
        return FALSE;
    }
    if (uiIDactive == psl->uiID)
    {
        if (!fSetActivePwrScheme(psl->uiID,NULL,NULL))
        {
            return FALSE;
        }
    }
    
    FreeScheme(psl);
    return TRUE;
}


PowerLoggingMessage*
GetLoggingMessage(
    PSYSTEM_POWER_STATE_DISABLE_REASON LoggingInfo,
    DWORD BaseMessage,
    HINSTANCE hInst
    )
/*++
 
Routine Description:
 
    Wrapper to instantiate the appropriate PowerLoggingMessage based on 
    the passed in LoggingInfo data.

    
Arguments:
 
    LoggingInfo - reason code structure.
    BaseMessage - base resource ID for this power failure.  used to lookup
                  the correct resource.
    hInst       - module handle for looking up resource.
    
Return Value:
 
    returns a newly instantiated PowerLoggingMessage object or NULL if this
    fails.
 
--*/
{
    PowerLoggingMessage *LoggingMessage = NULL;

    //
    // these classes can throw if they hit an allocation error.
    // catch it.
    //
    try {
        switch (LoggingInfo->PowerReasonCode) {
        case SPSD_REASON_LEGACYDRIVER:    
            LoggingMessage = new SubstituteMultiSzPowerLoggingMessage(
                                                    LoggingInfo,
                                                    BaseMessage,
                                                    hInst);    
            break;
        case SPSD_REASON_HIBERFILE:
        case SPSD_REASON_POINTERNAL:
            LoggingMessage = new SubstituteNtStatusPowerLoggingMessage(
                                                    LoggingInfo,
                                                    BaseMessage,
                                                    hInst);
            break;
#ifdef IA64
        //
        // on IA64 we want a slightly different message for this
        // reason -- IA64 OS doesn't support these standby states
        // today, but on IA32 this means you are not in ACPI mode.
        //
        // So we have this IA64 message arbitrarily offset by 50.
        case SPSD_REASON_NOOSPM:
            LoggingMessage = new SubstituteNtStatusPowerLoggingMessage(
                                                    LoggingInfo,            
                                                    BaseMessage+50,
                                                    hInst);
            break;
#endif
        case SPSD_REASON_DRIVERDOWNGRADE:
        default:
            LoggingMessage = new NoSubstitutionPowerLoggingMessage(
                                                    LoggingInfo,
                                                    BaseMessage,
                                                    hInst);
            break;        
        }

        ASSERT(LoggingMessage!= NULL);
    } catch (...) {
    }

    return(LoggingMessage);

}

BOOL
GetAndAppendDescriptiveLoggingText(
    NTSTATUS HiberStatus,
    LPTSTR   *CurrentErrorText,
    PSYSTEM_POWER_STATE_DISABLE_REASON LoggingInfo)
/*++
 
Routine Description:
 
    given a failed hibernation, this routine retrieves some descriptive text
    for why hibernate isn't available.

    
Arguments:
 
    HiberStatus - status code from enabling hibernate.
    CurrentErrorText - pointer to the current error code text.
    LoggingInfo - pointer to logging code with one reason one for failed 
                  
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    PWSTR ReasonString = NULL;
    PCWSTR pRootString;
    PCWSTR pRootHiberFailedString = NULL;
    DWORD Length = 0;
    PowerLoggingMessage *LoggingMessage = NULL;
    PWSTR FinalString;
    BOOL RetVal = FALSE;

    //
    // if we don't have any error text yet, then we need to look up
    // a header error message as the base of the message.  otherwise
    // we just append.
    //
    if (!*CurrentErrorText) {
        
        pRootString = GetResString(IDS_HIBER_FAILED_DESCRIPTION_HEADER);

        if (!pRootString) {
            return(FALSE);
        }

        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                RtlNtStatusToDosError(HiberStatus),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&pRootHiberFailedString,
                0,
                NULL                 
                );
        
        Length += wcslen(pRootString);
        
        if (pRootHiberFailedString) {
            Length += wcslen(pRootHiberFailedString);
        }

    } else {
        Length += wcslen(*CurrentErrorText);
    }

    
    //
    // get the logging reason text.
    //
    LoggingMessage = GetLoggingMessage(LoggingInfo,
                                       IDS_BASE_HIBER_REASON_CODE,
                                       GetModuleHandle(NULL));
    
    ASSERT(LoggingMessage!= NULL);

    if (!LoggingMessage->GetString(&ReasonString)) {
        RetVal = FALSE;
        goto exit;
    }

    Length += wcslen(ReasonString);

    //
    // now that we have the length for everything, allocate space,
    // and fill it in with our text, either the prior text, or the
    // header.
    //
    FinalString = (LPTSTR)LocalAlloc(LPTR,(Length+1)*sizeof(WCHAR));
    if (!FinalString) {
        RetVal = FALSE;
        goto exit;        
    }
    
    if (!*CurrentErrorText) {
        wsprintf(FinalString,pRootString,pRootHiberFailedString);
    } else {
        wcscpy(FinalString,*CurrentErrorText);
    }

    wcscat(FinalString,ReasonString);

    //
    // if we appended onto existing text, we can free the old text
    // and replace it with our new string.
    //
    if (*CurrentErrorText) {
        LocalFree(*CurrentErrorText);
    }

    *CurrentErrorText = FinalString;


    RetVal = TRUE;

exit:
    if (pRootHiberFailedString) {
        LocalFree((PWSTR)pRootHiberFailedString);
    }
    if (ReasonString) {
        LocalFree(ReasonString);        
    }

    if (LoggingMessage) {
        delete LoggingMessage;
    }


    return (RetVal);

}



BOOL 
DoHibernate(
  LPCTSTR lpszBoolStr
)
/*++
 
Routine Description:
 
    Enables/Disables hibernation

    NOTE: this functionality pretty much taken verbatim from the test program
          "base\ntos\po\tests\ehib\ehib.c"
 
Arguments:
 
    lpszBoolStr - "on" or "off"
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    GLOBAL_POWER_POLICY       PowerPolicy;
    DWORD                     uiIDactive;
    BOOL                      bChangePolicy = FALSE;
    BOOLEAN                   bEnable; // doesn't work with a BOOL, apparently
    NTSTATUS Status;
    
    // parse enable/disable state
    if (!lstrcmpi(lpszBoolStr,GetResString(IDS_ON))) 
    {
        bEnable = TRUE;
    } 
    else if (!lstrcmpi(lpszBoolStr,GetResString(IDS_OFF))) 
    {
        bEnable = FALSE;
        if (fGetGlobalPwrPolicy(&PowerPolicy)) {
            if (PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_LOW].
                            PowerPolicy.Action == PowerActionHibernate) {
                PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_LOW].
                            PowerPolicy.Action = PowerActionNone;
                bChangePolicy = TRUE;
            }
            if (PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].
                            PowerPolicy.Action == PowerActionHibernate) {
                PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].
                            PowerPolicy.Action = PowerActionNone;
                bChangePolicy = TRUE;
            }
            if (bChangePolicy) {
                if (fWriteGlobalPwrPolicy(&PowerPolicy) &&
                    fGetActivePwrScheme((PUINT)&uiIDactive) &&
                    fSetActivePwrScheme(uiIDactive,&PowerPolicy,NULL)){
                    DISPLAY_MESSAGE(stderr, GetResString(IDS_HIBERNATE_ALARM_DISABLED));
                }
                else
                {
                    DISPLAY_MESSAGE(stderr, GetResString(IDS_HIBERNATE_ALARM_DISABLE_FAILED));
                }
            }
        }
    } 
    else 
    {
        g_lpszErr = GetResString(IDS_HIBER_INVALID_STATE);
        return FALSE;
    }
    
    // enable/disable hibernation
    if (!g_bHiberFileSupported) 
    {
        g_lpszErr = GetResString(IDS_HIBER_UNSUPPORTED);
        Status = STATUS_NOT_SUPPORTED;
    } 
    else  {
        //
        // do the actual hibernate enable/disable operation.
        // 
        Status = fCallNtPowerInformation(
                            SystemReserveHiberFile, 
                            &bEnable, 
                            sizeof(bEnable), 
                            NULL, 
                            0
                            );
    }

    //
    // print out an error message.  if we can, we use the verbose error
    // message, otherwise we just fall back on the error code coming back
    // from NtPowerInformation.
    //
    if (!NT_SUCCESS(Status)) {
        //
        // remember the specific error message
        //
        PVOID LoggingInfoBuffer = NULL;
        PSYSTEM_POWER_STATE_DISABLE_REASON LoggingInfo;
        ULONG size,LoggingInfoSize;
        NTSTATUS HiberStatus = Status;
        
        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            RtlNtStatusToDosError(Status),
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR)&g_lpszErr2,
            0,
            NULL 
            );
                  
        //
        // try to get the verbose reason why hibernate fails.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
        size = 1024;
        LoggingInfoBuffer = LocalAlloc(LPTR,size);
        if (!LoggingInfoBuffer) {
            return(FALSE);
        }
        
        while (Status != STATUS_SUCCESS) {
        
            Status = fCallNtPowerInformation(
                        SystemPowerStateLogging,
                        NULL,
                        0,
                        LoggingInfoBuffer,
                        size);

            if (!NT_SUCCESS(Status)) {
                if (Status != STATUS_INSUFFICIENT_RESOURCES) {
                    LocalFree(LoggingInfoBuffer);
                    return(FALSE);
                } else {
                    size += 1024;
                    LocalFree(LoggingInfoBuffer);
                    LoggingInfoBuffer = LocalAlloc(LPTR,size);
                    if (!LoggingInfoBuffer) {
                       return(FALSE);
                    }
                }
            }
        }

        ASSERT(Status == STATUS_SUCCESS);

        LoggingInfoSize = (ULONG)*(PULONG)LoggingInfoBuffer;
        LoggingInfo = (PSYSTEM_POWER_STATE_DISABLE_REASON)(PCHAR)((PCHAR)LoggingInfoBuffer+sizeof(ULONG));
        //
        // we have a more verbose error available so let's use that.  don't need
        // the less verbose error.
        //
        if (g_lpszErr2) {
            LocalFree(g_lpszErr2);
            g_lpszErr2 = NULL;
        }
        
        //
        // walk through the list of reasons and print out the ones related to 
        // hibernate.
        //
        while((PCHAR)LoggingInfo <= (PCHAR)((PCHAR)LoggingInfoBuffer + LoggingInfoSize)) {
        
            if (LoggingInfo->AffectedState[PowerStateSleeping4] == TRUE) {
                //
                // need to remember the reason
                //
                GetAndAppendDescriptiveLoggingText(
                                        HiberStatus,
                                        &g_lpszErr2,
                                        LoggingInfo);
            }

            LoggingInfo = (PSYSTEM_POWER_STATE_DISABLE_REASON)(PCHAR)((PCHAR)LoggingInfo+sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)+LoggingInfo->PowerReasonLength);

        }

        return FALSE;
    }    
    
    return TRUE;
}

BOOL
DoGetSupportedSStates(
    VOID
)
/*++
 
Routine Description:
 
    Lists the available S-States on a machine.    
 
Arguments:
 
    None.
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    NTSTATUS Status;
    SYSTEM_POWER_CAPABILITIES Capabilities;
    BOOL StandbyAvailable = FALSE;
    BOOL HibernateAvailable = FALSE;
    PVOID LoggingInfoBuffer = NULL;
    PSYSTEM_POWER_STATE_DISABLE_REASON LoggingInfo;
    ULONG size,LoggingInfoSize;
    PowerLoggingMessage *LoggingMessage;
    PWSTR ReasonString;
    DWORD i;
    BOOL ExitLoop;
    BOOL LoggingApiAvailable;
    

    //
    // call the power state logging API if it's available.  on older systems
    // this API isn't avaialable and that should not be a problem.
    //
    Status = STATUS_INSUFFICIENT_RESOURCES;
    size = 1024;
    LoggingInfoBuffer = LocalAlloc(LPTR,size);
    if (!LoggingInfoBuffer) {
        LoggingApiAvailable = FALSE;
        goto GetStaticStates;
    }
    
    while (Status != STATUS_SUCCESS) {
    
        Status = fCallNtPowerInformation(
                    SystemPowerStateLogging,
                    NULL,
                    0,
                    LoggingInfoBuffer,
                    size);
    
        if (!NT_SUCCESS(Status)) {
            if (Status != STATUS_INSUFFICIENT_RESOURCES) {
                LocalFree(LoggingInfoBuffer);
                LoggingInfoBuffer = NULL;
                LoggingApiAvailable = FALSE;
                goto GetStaticStates;
            } else {
                size += 1024;
                LocalFree(LoggingInfoBuffer);
                LoggingInfoBuffer = LocalAlloc(LPTR,size);
                if (!LoggingInfoBuffer) {
                    LoggingApiAvailable = FALSE;
                    goto GetStaticStates;
                }
            }
        }
    }
    
    //
    // we have the verbose logging structure.  remember that for later on.
    //
    LoggingApiAvailable = TRUE;
    LoggingInfoSize = (ULONG)*(PULONG)LoggingInfoBuffer;
        
        
GetStaticStates:
    //
    // get the current power capabilities of the system.
    //
    Status = fCallNtPowerInformation(
                            SystemPowerCapabilities, 
                            NULL, 
                            0,
                            &Capabilities, 
                            sizeof(SYSTEM_POWER_CAPABILITIES)
                            );
    if (!NT_SUCCESS(Status)) {
        //
        // print out failure message
        // 
        g_lpszErr = GetResString(IDS_CANTGETSLEEPSTATES);
        return(FALSE);
    }

    //
    // if the logging API is available, it may tell us that
    // one of the S states isn't really available.  Process
    // that "override" data here so that we're sure to print 
    // out the correct list of supported states on this system.
    //
    if (LoggingApiAvailable) {
        LoggingInfo = (PSYSTEM_POWER_STATE_DISABLE_REASON)(PCHAR)((PCHAR)LoggingInfoBuffer+sizeof(ULONG));
        while((PCHAR)LoggingInfo <= (PCHAR)((PCHAR)LoggingInfoBuffer + LoggingInfoSize)) {
            if (LoggingInfo->PowerReasonCode != SPSD_REASON_NONE) {
                
                if (LoggingInfo->AffectedState[PowerStateSleeping1] == TRUE) {
                    Capabilities.SystemS1 = FALSE;
                }
                
                if (LoggingInfo->AffectedState[PowerStateSleeping2] == TRUE) {
                    Capabilities.SystemS2 = FALSE;
                }
    
                if (LoggingInfo->AffectedState[PowerStateSleeping3] == TRUE) {
                    Capabilities.SystemS3 = FALSE;
                }
    
                if (LoggingInfo->AffectedState[PowerStateSleeping4] == TRUE) {
                    Capabilities.SystemS4 = FALSE;
                }
            }
            LoggingInfo = (PSYSTEM_POWER_STATE_DISABLE_REASON)(PCHAR)((PCHAR)LoggingInfo+sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)+LoggingInfo->PowerReasonLength);
        }
    }

    //
    // print out the list of supported s states.
    //
    if (Capabilities.SystemS1 || 
        Capabilities.SystemS2 || 
        Capabilities.SystemS3) {
        StandbyAvailable = TRUE;        
    }

    if (Capabilities.SystemS4) {
        HibernateAvailable = TRUE;
    }

    if (StandbyAvailable || HibernateAvailable) {
        //
        // "the following sleep states are available on this machine: "
        //
        DISPLAY_MESSAGE(stdout,GetResString(IDS_SLEEPSTATES_AVAILABLE));
        DISPLAY_MESSAGE(stdout,L" ");

        if (StandbyAvailable) {
            //" Standby ("
            // IDS_STANDBY " " IDS_LEFTPAREN
            DISPLAY_MESSAGE(stdout,GetResString(IDS_STANDBY));
            DISPLAY_MESSAGE(stdout,L" ");
            DISPLAY_MESSAGE(stdout,GetResString(IDS_LEFTPAREN));
            DISPLAY_MESSAGE(stdout,L" ");
            
            
            if (Capabilities.SystemS1) {
                //"S1 "
                //IDS_S1
                DISPLAY_MESSAGE(stdout,GetResString(IDS_S1));
                DISPLAY_MESSAGE(stdout,L" ");
            }
            if (Capabilities.SystemS2) {
                //"S2 "
                //IDS_S2
                DISPLAY_MESSAGE(stdout,GetResString(IDS_S2));
                DISPLAY_MESSAGE(stdout,L" ");
            }

            if (Capabilities.SystemS3) {
                //"S3"
                //IDS_S3
                DISPLAY_MESSAGE(stdout,GetResString(IDS_S3));
                DISPLAY_MESSAGE(stdout,L" ");
            }
            //")"
            //IDS_RIGHTPAREN
            DISPLAY_MESSAGE(stdout,GetResString(IDS_RIGHTPAREN));
            DISPLAY_MESSAGE(stdout,L" ");
        }

        if (HibernateAvailable) {
            //" Hibernate"
            //IDS_HIBERNATE
            DISPLAY_MESSAGE(stdout,GetResString(IDS_HIBERNATE));
            DISPLAY_MESSAGE(stdout,L" ");
        }

        DISPLAY_MESSAGE(stdout,L"\n");
    }
        
    //
    // if one or more capabilities are missing then find out why and 
    // print it out.
    //
    if (!Capabilities.SystemS1 || 
        !Capabilities.SystemS2 || 
        !Capabilities.SystemS3 || 
        !Capabilities.SystemS4) {
        
        //
        // "the following sleep states are not available on this machine:"
        //
        //IDS_SLEEPSTATES_UNAVAILABLE
        DISPLAY_MESSAGE(stdout,GetResString(IDS_SLEEPSTATES_UNAVAILABLE));
        DISPLAY_MESSAGE(stdout,L"\n");
        
        i = 0;
        ExitLoop = FALSE;
        while (1) {
            BOOL NotSupported;
            DWORD BaseMessage;
            DWORD HeaderMessage;
            POWER_STATE_HANDLER_TYPE SystemPowerState;

            //
            // remember some resource ids for the S state we're 
            // currently considering
            //
            switch (i) {
            case 0:
                BaseMessage = IDS_BASE_SX_REASON_CODE;
                HeaderMessage = IDS_BASE_S1_HEADER;
                SystemPowerState = PowerStateSleeping1;
                NotSupported = !Capabilities.SystemS1;
                break;
            case 1:
                BaseMessage = IDS_BASE_SX_REASON_CODE;
                HeaderMessage = IDS_BASE_S2_HEADER;
                SystemPowerState = PowerStateSleeping2;
                NotSupported = !Capabilities.SystemS2;
                break;
            case 2:
                BaseMessage = IDS_BASE_SX_REASON_CODE;
                HeaderMessage = IDS_BASE_S3_HEADER;
                SystemPowerState = PowerStateSleeping3;
                NotSupported = !Capabilities.SystemS3;
                break;
            case 3:
                BaseMessage = IDS_BASE_HIBER_REASON_CODE;
                HeaderMessage = IDS_HIBERNATE;
                SystemPowerState = PowerStateSleeping4;
                NotSupported = !Capabilities.SystemS4;
                break;
            default:
                ExitLoop = TRUE;

            }

            if (ExitLoop) {
                break;
            }

            if (NotSupported) {
                //"Standby (S1)" BaseMessage...
                DISPLAY_MESSAGE(stdout,GetResString(HeaderMessage));
                DISPLAY_MESSAGE(stdout,L"\n");

                if (LoggingApiAvailable) {
                
                    LoggingInfo = (PSYSTEM_POWER_STATE_DISABLE_REASON)(PCHAR)((PCHAR)LoggingInfoBuffer+sizeof(ULONG));
                    while((PCHAR)LoggingInfo <= (PCHAR)((PCHAR)LoggingInfoBuffer + LoggingInfoSize)) {
                        if (LoggingInfo->AffectedState[SystemPowerState]) {
                            //
                            // get reason, print it out.
                            //
                            LoggingMessage = GetLoggingMessage(
                                                        LoggingInfo,
                                                        BaseMessage,
                                                        GetModuleHandle(NULL));
        
                            if (!LoggingMessage ||
                                !LoggingMessage->GetString(&ReasonString)) {
                                // oops
                                // IDS_CANTGETSSTATEREASONS
                                g_lpszErr = GetResString(IDS_CANTGETSSTATEREASONS);
                                LocalFree(LoggingInfoBuffer);
                                return(FALSE);
                            }
    
                            DISPLAY_MESSAGE(stdout,ReasonString);
                            LocalFree(ReasonString);
                            delete LoggingMessage;                    
                        }
        
                        LoggingInfo = (PSYSTEM_POWER_STATE_DISABLE_REASON)(PCHAR)((PCHAR)LoggingInfo+sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)+LoggingInfo->PowerReasonLength);
                    }
                }
            }

            i += 1;
        }
        
        if (LoggingInfoBuffer) {
            LocalFree(LoggingInfoBuffer);
        }

    }

    return(TRUE);

}


BOOL 
DoGlobalFlag(
  LPCTSTR lpszBoolStr,
  LPCTSTR lpszGlobalFlagOption
)
/*++
 
Routine Description:
 
    Enables/Disables a global flag    
 
Arguments:
 
    lpszBoolStr - "on" or "off"
    lpszGlobalFlagOption - one of several flags.
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    BOOLEAN                   bEnable; // doesn't work with a BOOL, apparently
    BOOL                      RetVal;
    GLOBAL_POWER_POLICY       PowerPolicy;
    DWORD                     GlobalFlag = 0;
    DWORD                     uiIDactive;
    
    // parse enable/disable state
    if (!lstrcmpi(lpszBoolStr,GetResString(IDS_ON))) 
    {
        bEnable = TRUE;
    } 
    else if (!lstrcmpi(lpszBoolStr,GetResString(IDS_OFF))) 
    {
        bEnable = FALSE;
    } 
    else 
    {
        g_lpszErr = GetResString(IDS_GLOBAL_FLAG_INVALID_STATE);
        RetVal = FALSE;
        goto exit;
    }

    // parse which global flag we are changing
    if (!lstrcmpi(lpszGlobalFlagOption,CMDOPTION_BATTERYICON)) {
        GlobalFlag |= EnableSysTrayBatteryMeter;
    } else if (!lstrcmpi(lpszGlobalFlagOption,CMDOPTION_MULTIBATTERY)) {
        GlobalFlag |= EnableMultiBatteryDisplay;
    } else if (!lstrcmpi(lpszGlobalFlagOption,CMDOPTION_RESUMEPASSWORD)) {
        GlobalFlag |= EnablePasswordLogon;
    } else if (!lstrcmpi(lpszGlobalFlagOption,CMDOPTION_WAKEONRING)) {
        GlobalFlag |= EnableWakeOnRing;
    } else if (!lstrcmpi(lpszGlobalFlagOption,CMDOPTION_VIDEODIM)) {
        GlobalFlag |= EnableVideoDimDisplay;
    } else {
        g_lpszErr = GetResString(IDS_GLOBAL_FLAG_INVALID_FLAG);
        RetVal = FALSE;
        goto exit;
    }
    
    //
    // now get the current state, set or clear the flags, and then save the
    // changed settings back.
    //
    RetVal = FALSE;
    if (fGetGlobalPwrPolicy(&PowerPolicy)) {
        if (bEnable) {
            PowerPolicy.user.GlobalFlags |= GlobalFlag;
        } else {
            PowerPolicy.user.GlobalFlags &= ~(GlobalFlag);
        }

        if (fWriteGlobalPwrPolicy(&PowerPolicy) &&
            fGetActivePwrScheme((PUINT)&uiIDactive) &&
            fSetActivePwrScheme(uiIDactive,&PowerPolicy,NULL)){
            RetVal = TRUE;    
        }
    }
            
    //
    // save off the error if we had issues
    //
    if (!RetVal) {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
            return FALSE;
    }    
    
exit:
    return(RetVal);
}



LPTSTR
FileNameOnly(
    LPTSTR sz
)
/*++
 
Routine Description:
 
    Returns a pointer to the first character after the last backslash in a string    
 
Arguments:
 
    sz - full file name.
    
Return Value:
 
    pointer ot file name without path.
     
--*/
{
    LPTSTR lpszFileName = NULL;


    if ( sz )
    {
        lpszFileName = wcsrchr( sz, L'\\' );
        if ( lpszFileName ) {
            lpszFileName++;
        }
        else {
            lpszFileName = sz;
        }
    }

    return lpszFileName;
}

BOOL
DoBatteryAlarm(
    LPTSTR  lpszName,
    LPTSTR  lpszBoolStr,
    DWORD   dwLevel,
    LPTSTR  lpszAlarmTextBoolStr,
    LPTSTR  lpszAlarmSoundBoolStr,
    LPTSTR  lpszAlarmActionStr,
    LPTSTR  lpszAlarmForceBoolStr,
    LPTSTR  lpszAlarmProgramBoolStr
)
/*++
 
Routine Description:
 
    Configures battery alarms    
 
Arguments:
 
    lpszName - "Low" or "Critical" on checked builds: ("0", "1", "2", "3")
    lpszBoolStr - "on", or "off"
    dwLevel - alarm level (0-100)
    lpszAlarmTextBoolStr - NULL, "on", or "off".
    lpszAlarmSoundBoolStr - NULL, "on", or "off".
    lpszAlarmActionStr - NULL, "none", "standby", "hibernate", "shutdown"
    lpszAlarmForceBoolStr - NULL, "on", or "off".
    lpszAlarmProgramBoolStr - NULL, "on", or "off".
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    BOOL                    bShowSetting = TRUE;
    BOOL                    RetVal;
    GLOBAL_POWER_POLICY     PowerPolicy;
    DWORD                   GlobalFlag = 0;
    DWORD                   uiIDactive;
    DWORD                   uiDefaultAlert1;
    DWORD                   uiAlarmIndex;
    PSYSTEM_POWER_LEVEL     lpDischargePolicy;
    ITaskScheduler          *pISchedAgent = NULL;
    ITask                   *pITask;
    IPersistFile            *pIPersistFile;
    LPTSTR                  lpszRunProg = NULL;
    SYSTEM_BATTERY_STATE    sbsBatteryState;
    HRESULT                 hr;
    LPTSTR                  lpszProgramName;
    
    //
    // now get the current state, set or clear the flags, and then save the
    // changed settings back.
    //
    
    RetVal = FALSE;
    if (fGetGlobalPwrPolicy(&PowerPolicy)) {

        // parse name
        if (!lstrcmpi(lpszName,GetResString(IDS_CRITICAL))) {
            lstrcpy((LPWSTR) lpszName, GetResString(IDS_CRITICAL));
            uiAlarmIndex = DISCHARGE_POLICY_CRITICAL;
        }
        else if (!lstrcmpi(lpszName,GetResString(IDS_LOW))) 
        {
            lstrcpy((LPWSTR) lpszName,GetResString(IDS_LOW));
            uiAlarmIndex = DISCHARGE_POLICY_LOW;
        } 
        else 
        {
            g_lpszErr = GetResString(IDS_ALARM_INVALID_ALARM);
            RetVal = FALSE;
            goto exit;
        }
        lpDischargePolicy = &PowerPolicy.user.DischargePolicy[uiAlarmIndex];


        // parse activate state
        if (lpszBoolStr) {
            bShowSetting = FALSE;
            if (!lstrcmpi(lpszBoolStr,GetResString(IDS_ON))) 
            {
                lpDischargePolicy->Enable = TRUE;
            } 
            else if (!lstrcmpi(lpszBoolStr,GetResString(IDS_OFF))) 
            {
                lpDischargePolicy->Enable = FALSE;
            } 
            else 
            {
                g_lpszErr = GetResString(IDS_ALARM_INVALID_ACTIVATE);
                RetVal = FALSE;
                goto exit;
            }
        }

        // Set Level
        if (dwLevel != 0xffffffff) {
            bShowSetting = FALSE;
            if (dwLevel <= 100) {
                // Read DefaultAlert1 from composite battery 
                NtPowerInformation (SystemBatteryState, NULL, 0, &sbsBatteryState, sizeof(sbsBatteryState));
                if (sbsBatteryState.MaxCapacity == 0) {
                    uiDefaultAlert1 = 0;
                } else {
                    uiDefaultAlert1 = (100 * sbsBatteryState.DefaultAlert1)/sbsBatteryState.MaxCapacity;
                }

                if (dwLevel < uiDefaultAlert1) {
                    dwLevel = uiDefaultAlert1;
                    DISPLAY_MESSAGE1(stderr, g_lpszBuf, GetResString(IDS_ALARM_LEVEL_MINIMUM), dwLevel);
                }

                lpDischargePolicy->BatteryLevel = dwLevel;

                if (PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel < 
                    PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel) {
                    PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel = dwLevel;
                    PowerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel = dwLevel;
                    DISPLAY_MESSAGE1(stderr, g_lpszBuf, GetResString(IDS_ALARM_LEVEL_EQUAL), dwLevel);
                }
            } else {
                g_lpszErr = GetResString(IDS_ALARM_INVALID_LEVEL);
                RetVal = FALSE;
                goto exit;
            }
        }

        // parse and set "text" on/off
        if (lpszAlarmTextBoolStr) { // NULL indicates this option wasn't specified
            bShowSetting = FALSE;
            if (!lstrcmpi(lpszAlarmTextBoolStr,GetResString(IDS_ON))) 
            {
                lpDischargePolicy->PowerPolicy.EventCode |= POWER_LEVEL_USER_NOTIFY_TEXT;
            } 
            else if (!lstrcmpi(lpszAlarmTextBoolStr,GetResString(IDS_OFF))) 
            {
                lpDischargePolicy->PowerPolicy.EventCode &= ~POWER_LEVEL_USER_NOTIFY_TEXT;
            } 
            else
            {
                g_lpszErr = GetResString(IDS_ALARM_INVALID_TEXT);
                RetVal = FALSE;
                goto exit;
            }
        }

        // parse and set "sound" on/off
        if (lpszAlarmSoundBoolStr) { // NULL indicates this option wasn't specified
            bShowSetting = FALSE;
            if (!lstrcmpi(lpszAlarmSoundBoolStr,GetResString(IDS_ON))) 
            {
                lpDischargePolicy->PowerPolicy.EventCode |= POWER_LEVEL_USER_NOTIFY_SOUND;
            } 
            else if (!lstrcmpi(lpszAlarmSoundBoolStr,GetResString(IDS_OFF))) 
            {
                lpDischargePolicy->PowerPolicy.EventCode &= ~POWER_LEVEL_USER_NOTIFY_SOUND;
            } 
            else
            {
                g_lpszErr = GetResString(IDS_ALARM_INVALID_SOUND);
                RetVal = FALSE;
                goto exit;
            }
        }

        // parse and set "action" none/shutdown/hibernate/standby
        if (lpszAlarmActionStr) { // NULL indicates this option wasn't specified
            bShowSetting = FALSE;
            if (!lstrcmpi(lpszAlarmActionStr,GetResString(IDS_NONE))) 
            {
                lpDischargePolicy->PowerPolicy.Action = PowerActionNone;
            } 
            else if (!lstrcmpi(lpszAlarmActionStr,GetResString(IDS_STANDBY))) 
            {
                if (g_bStandbySupported) {
                    lpDischargePolicy->PowerPolicy.Action = PowerActionSleep;
                }
                else
                {
                    g_lpszErr = GetResString(IDS_ALARM_STANDBY_UNSUPPORTED);
                    RetVal = FALSE;
                    goto exit;
                }
            } 
            else if (!lstrcmpi(lpszAlarmActionStr,GetResString(IDS_HIBERNATE))) 
            {
                if (g_bHiberFilePresent) {
                    lpDischargePolicy->PowerPolicy.Action = PowerActionHibernate;
                }
                else
                {
                    g_lpszErr = GetResString(IDS_ALARM_HIBERNATE_DISABLED);
                    RetVal = FALSE;
                    goto exit;
                }
            } 
            else if (!lstrcmpi(lpszAlarmActionStr,GetResString(IDS_SHUTDOWN))) 
            {
                lpDischargePolicy->PowerPolicy.Action = PowerActionShutdownOff;
            } 
            else
            {
                g_lpszErr = GetResString(IDS_ALARM_INVALID_ACTION);
                RetVal = FALSE;
                goto exit;
            }
        }

        // parse and set "forceaction" on/off
        if (lpszAlarmForceBoolStr) { // NULL indicates this option wasn't specified
            bShowSetting = FALSE;
            if (!lstrcmpi(lpszAlarmForceBoolStr,GetResString(IDS_ON))) 
            {
                lpDischargePolicy->PowerPolicy.Flags |= POWER_ACTION_OVERRIDE_APPS;
            } 
            else if (!lstrcmpi(lpszAlarmForceBoolStr,GetResString(IDS_OFF))) 
            {
                if (uiAlarmIndex == DISCHARGE_POLICY_CRITICAL) {
                    DISPLAY_MESSAGE(stderr, GetResString(IDS_ALARM_FORCE_CRITICAL));
                }
                lpDischargePolicy->PowerPolicy.Flags &= ~POWER_ACTION_OVERRIDE_APPS;
            } 
            else
            {
                g_lpszErr = GetResString(IDS_ALARM_INVALID_FORCE);
                RetVal = FALSE;
                goto exit;
            }
        }

        // parse and set "program" on/off
        if (lpszAlarmProgramBoolStr) { // NULL indicates this option wasn't specified
            bShowSetting = FALSE;
            if (!lstrcmpi(lpszAlarmProgramBoolStr,GetResString(IDS_ON))) 
            {
                hr = CoInitialize(NULL);

                if (SUCCEEDED(hr)) {
                    hr = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                                           IID_ITaskScheduler,(LPVOID*) &pISchedAgent );

                    if (SUCCEEDED(hr)) {

                        hr = pISchedAgent->Activate(g_szAlarmTaskName[uiAlarmIndex],
                                                    IID_ITask,
                                                    (IUnknown **) &pITask);

                        if (SUCCEEDED(hr)) {
                            //
                            // It already exists.  No work needed.
                            //
                            pITask->Release();
                        }
                        else if (HRESULT_CODE (hr) == ERROR_FILE_NOT_FOUND){
                            hr = pISchedAgent->NewWorkItem(
                                    g_szAlarmTaskName[uiAlarmIndex],
                                    CLSID_CTask,
                                    IID_ITask,
                                    (IUnknown **) &pITask);

                            if (SUCCEEDED(hr)) {
                                hr = pITask->QueryInterface(IID_IPersistFile,
                                                (void **)&pIPersistFile);

                                if (SUCCEEDED(hr)) {
                                    hr = pIPersistFile->Save(NULL, TRUE);

                                    if (SUCCEEDED(hr)) {
                                        // No work to do.  The task has been created and saved and can be edited using schtasks.exe
                                        //pITask->lpVtbl->EditWorkItem(pITask, hWnd, 0);
                                    }
                                    else {
                                        #if DBG
                                        DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: Save failed hr = %08x\n"), hr);
                                        #endif
                                    }
                                    pIPersistFile->Release();
                                }
                                else {
                                    #if DBG
                                    DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: QueryInterface for IPersistFile hr = %08x\n"), hr);
                                    #endif
                                }
                                pITask->Release();

                            }
                            else {
                                #if DBG
                                DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: NewWorkItem returned hr = %08x\n"), hr);
                                #endif
                            }
                        }
                        else {
                            #if DBG
                            DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: Activate returned hr = %08x\n"), hr);
                            #endif
                        }

                        pISchedAgent->Release();
                    }
                    else {
                        #if DBG
                        DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: CoCreateInstance returned hr = %08x\n"), hr);
                        #endif
                    }
                
                    CoUninitialize();
                
                } else {
                    #if DBG
                    DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: CoInitialize returned hr = %08x\n"), hr);
                    #endif
                }

                if (SUCCEEDED(hr)) {
                    DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("\"%s\""), g_szAlarmTaskName[uiAlarmIndex]);
                } else {
                    DISPLAY_MESSAGE1(
                        stdout, 
                        g_lpszBuf,
                        GetResString(IDS_ALARM_PROGRAM_FAILED), 
                        g_szAlarmTaskName[uiAlarmIndex]);
                }
                
                lpDischargePolicy->PowerPolicy.EventCode |= POWER_LEVEL_USER_NOTIFY_EXEC;
            
            } 
            else if (!lstrcmpi(lpszAlarmProgramBoolStr,GetResString(IDS_OFF))) 
            {
                lpDischargePolicy->PowerPolicy.EventCode &= ~POWER_LEVEL_USER_NOTIFY_EXEC;
            } 
            else
            {
                g_lpszErr = GetResString(IDS_ALARM_INVALID_PROGRAM);
                RetVal = FALSE;
                goto exit;
            }
        }

        if (bShowSetting) {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_ALARM_HEADER1));
            DISPLAY_MESSAGE(stdout, GetResString(IDS_ALARM_HEADER2));
            
            // Which alarm
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_NAME),
                lpszName
                );
            
            // Active
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_ACTIVE),
                GetResString(lpDischargePolicy->Enable ? IDS_ON : IDS_OFF)
                );
            
            // Level
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_LEVEL),
                lpDischargePolicy->BatteryLevel
                );
            
            // Text
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_TEXT),
                GetResString((lpDischargePolicy->PowerPolicy.EventCode & 
                              POWER_LEVEL_USER_NOTIFY_TEXT) ? IDS_ON : IDS_OFF)
                );
            
            // Sound
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_SOUND),
                GetResString((lpDischargePolicy->PowerPolicy.EventCode & 
                              POWER_LEVEL_USER_NOTIFY_SOUND) ? IDS_ON : IDS_OFF)
                );
            
            // Action
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_ACTION),
                GetResString((lpDischargePolicy->PowerPolicy.Action == PowerActionNone) ? IDS_NONE :
                             (lpDischargePolicy->PowerPolicy.Action == PowerActionSleep) ? IDS_STANDBY :
                             (lpDischargePolicy->PowerPolicy.Action == PowerActionHibernate) ? IDS_HIBERNATE :
                             (lpDischargePolicy->PowerPolicy.Action == PowerActionShutdownOff) ? IDS_SHUTDOWN : IDS_INVALID
                             )
                );
            
            // Force
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_FORCE),
                GetResString((lpDischargePolicy->PowerPolicy.Flags & 
                              POWER_ACTION_OVERRIDE_APPS) ? IDS_ON : IDS_OFF)
                );
            
            // Program
            DISPLAY_MESSAGE1(
                stdout,
                g_lpszBuf,
                GetResString(IDS_ALARM_PROGRAM),
                GetResString((lpDischargePolicy->PowerPolicy.EventCode & 
                              POWER_LEVEL_USER_NOTIFY_EXEC) ? IDS_ON : IDS_OFF)
                );
            
            hr = CoInitialize(NULL);

            if (SUCCEEDED(hr)) {
                hr = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                                       IID_ITaskScheduler,(LPVOID*) &pISchedAgent );

                if (SUCCEEDED(hr)) {

                    hr = pISchedAgent->Activate(g_szAlarmTaskName[uiAlarmIndex],
                                                IID_ITask,
                                                (IUnknown **) &pITask);

                    if (SUCCEEDED(hr)) {
                        pITask->GetApplicationName(&lpszRunProg);
                        pITask->Release();
                    } else {
                        #if DBG
                        DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: Activate returned hr = %08x\n"), hr);
                        #endif

                    }

                    pISchedAgent->Release();
                }
                else {
                    #if DBG
                    DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: CoCreateInstance returned hr = %08x\n"), hr);
                    #endif
                }


            } else {
                #if DBG
                DISPLAY_MESSAGE1(stdout, g_lpszBuf, _T("DoBatteryAlarm: CoInitialize returned hr = %08x\n"), hr);
                #endif
            }


            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_ALARM_PROGRAM_NAME),
                lpszRunProg ? FileNameOnly(lpszRunProg) : GetResString(IDS_NONE));

            if (lpszRunProg) {
                CoTaskMemFree (lpszRunProg);
                lpszRunProg = NULL;
            }
            
            CoUninitialize();

            RetVal = TRUE;
            goto exit;
        }

        if (fWriteGlobalPwrPolicy(&PowerPolicy) &&
            fGetActivePwrScheme((PUINT)&uiIDactive) &&
            fSetActivePwrScheme(uiIDactive,&PowerPolicy,NULL)){
            RetVal = TRUE;    
        }
    }
    RetVal = TRUE;    
            
    //
    // save off the error if we had issues
    //
    if (!RetVal) {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
            return FALSE;
    }    
    
exit:
    return(RetVal);
}


BOOL 
DoUsage()
/*++
 
Routine Description:
 
    Displays usage information
 
Arguments:

    none
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    ULONG ulIdx;
    ULONG ulOrderIndex = 0;
    for(ulIdx=IDS_USAGE_START;ulIdx<=IDS_USAGE_END;ulIdx++)
    {
        DISPLAY_MESSAGE(stdout, GetResString(ulIdx));
        if (ulIdx == gUsageOrder [ulOrderIndex].InsertAfter) {
            for (ulIdx = gUsageOrder [ulOrderIndex].FirstResource;
                 ulIdx <= gUsageOrder [ulOrderIndex].LastResource;
                 ulIdx++) {
                DISPLAY_MESSAGE(stdout, GetResString(ulIdx));
            }
            ulIdx = gUsageOrder [ulOrderIndex].InsertAfter;
            ulOrderIndex++;
        }
    }
    return TRUE;
}


VOID
SyncRegPPM(VOID)
/*++
 
Routine Description:
 
    Call down to the PPM to get the current power policies and write them
    to the registry. This is done in case the PPM is out of sync with the
    PowerCfg registry settings. Requested by JVert.
 
Arguments:
 
Return Value:
     
--*/
{
   GLOBAL_POWER_POLICY  gpp;
   POWER_POLICY         pp;
   UINT                 uiID, uiFlags = 0;

   if (fGetGlobalPwrPolicy(&gpp)) {
       uiFlags = gpp.user.GlobalFlags;
   }

   if (fGetActivePwrScheme(&uiID)) {
      // Get the current PPM settings.
      if (fGetCurrentPowerPolicies(&gpp, &pp)) {
         fSetActivePwrScheme(uiID, &gpp, &pp);
      }
   }

   gpp.user.GlobalFlags |= uiFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\powercfg\powercfg.h ===
#ifndef __POWERCFG_H
#define __POWERCFG_H

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*++

Copyright (c) 2001  Microsoft Corporation
 
Module Name:
 
    powercfg.h
 
Abstract:
 
    Allows users to view and modify power schemes and system power settings
    from the command line.  May be useful in unattended configuration and
    for headless systems.
 
Author:
 
    Ben Hertzberg (t-benher) 1-Jun-2001
 
Revision History:
 
    Ben Hertzberg (t-benher) 4-Jun-2001   - import/export added
    Ben Hertzberg (t-benher) 1-Jun-2001   - created it.
 
--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <powrprof.h>
#include <mstask.h>


// main options
#define CMDOPTION_LIST           _T( "l|list" )
#define CMDOPTION_QUERY          _T( "q|query" )
#define CMDOPTION_CREATE         _T( "c|create" )
#define CMDOPTION_DELETE         _T( "d|delete" )
#define CMDOPTION_SETACTIVE      _T( "s|setactive" )
#define CMDOPTION_CHANGE         _T( "x|change" )
#define CMDOPTION_HIBERNATE      _T( "h|hibernate" )
#define CMDOPTION_EXPORT         _T( "e|export" )
#define CMDOPTION_IMPORT         _T( "i|import" )
#define CMDOPTION_GLOBALFLAG     _T( "g|globalpowerflag" )
#define CMDOPTION_SSTATES        _T( "a|availablesleepstates" )
#define CMDOPTION_BATTERYALARM   _T( "b|batteryalarm" )
#define CMDOPTION_USAGE          _T( "?|help" )

// 'numerical' sub-option for query, create, delete, setactive, change, export, import
#define CMDOPTION_NUMERICAL      _T( "n|numerical" )

// 'change' sub-options
#define CMDOPTION_MONITOR_OFF_AC _T( "monitor-timeout-ac" )
#define CMDOPTION_MONITOR_OFF_DC _T( "monitor-timeout-dc" )
#define CMDOPTION_DISK_OFF_AC    _T( "disk-timeout-ac" )
#define CMDOPTION_DISK_OFF_DC    _T( "disk-timeout-dc" )
#define CMDOPTION_STANDBY_AC     _T( "standby-timeout-ac" )
#define CMDOPTION_STANDBY_DC     _T( "standby-timeout-dc" )
#define CMDOPTION_HIBER_AC       _T( "hibernate-timeout-ac" )
#define CMDOPTION_HIBER_DC       _T( "hibernate-timeout-dc" )
#define CMDOPTION_THROTTLE_AC    _T( "processor-throttle-ac" )
#define CMDOPTION_THROTTLE_DC    _T( "processor-throttle-dc" )

// 'import' / 'export' sub-options
#define CMDOPTION_FILE           _T( "f|file" )

// globalpowerflag sub-options
#define CMDOPTION_POWEROPTION    _T( "option" )

#define CMDOPTION_BATTERYICON    _T( "batteryicon" )
#define CMDOPTION_MULTIBATTERY   _T( "multibattery" )
#define CMDOPTION_RESUMEPASSWORD _T( "resumepassword" )
#define CMDOPTION_WAKEONRING     _T( "wakeonring" )
#define CMDOPTION_VIDEODIM       _T( "videodim" )

// lowbattery and criticalbattery sub-options
#define CMDOPTION_ALARMACTIVE  _T( "activate" )
#define CMDOPTION_ALARMLEVEL   _T( "level" )
#define CMDOPTION_ALARMTEXT    _T( "text" )
#define CMDOPTION_ALARMSOUND   _T( "sound" )
#define CMDOPTION_ALARMACTION  _T( "action" )
#define CMDOPTION_ALARMFORCE   _T( "forceaction" )
#define CMDOPTION_ALARMPROGRAM _T( "program" )

// main option indicies
#define CMDINDEX_LIST            0
#define CMDINDEX_QUERY           1
#define CMDINDEX_CREATE          2
#define CMDINDEX_DELETE          3
#define CMDINDEX_SETACTIVE       4
#define CMDINDEX_CHANGE          5
#define CMDINDEX_HIBERNATE       6
#define CMDINDEX_EXPORT          7
#define CMDINDEX_IMPORT          8
#define CMDINDEX_GLOBALFLAG      9
#define CMDINDEX_SSTATES         10
#define CMDINDEX_BATTERYALARM    11

#define CMDINDEX_USAGE           12

#define NUM_MAIN_CMDS            13 // max(main option CMDINDEX_xxx) + 1

#define CMDINDEX_NUMERICAL       13

// sub-option indices
#define CMDINDEX_MONITOR_OFF_AC  14
#define CMDINDEX_MONITOR_OFF_DC  15
#define CMDINDEX_DISK_OFF_AC     16
#define CMDINDEX_DISK_OFF_DC     17
#define CMDINDEX_STANDBY_AC      18
#define CMDINDEX_STANDBY_DC      19
#define CMDINDEX_HIBER_AC        20
#define CMDINDEX_HIBER_DC        21
#define CMDINDEX_THROTTLE_AC     22
#define CMDINDEX_THROTTLE_DC     23
#define CMDINDEX_FILE            24
#define CMDINDEX_POWEROPTION     25
#define CMDINDEX_ALARMACTIVE     26
#define CMDINDEX_ALARMLEVEL      27
#define CMDINDEX_ALARMTEXT       28
#define CMDINDEX_ALARMSOUND      29
#define CMDINDEX_ALARMACTION     30
#define CMDINDEX_ALARMFORCE      31
#define CMDINDEX_ALARMPROGRAM    32

#define NUM_CMDS                 33 // max(any CMDINDEX_xxx) + 1



// Other constants


// Exit values
#define EXIT_SUCCESS        0
#define EXIT_FAILURE        1  

#ifdef __cplusplus
class
PowerLoggingMessage
{
    protected: // data
        DWORD _MessageResourceId;
        PSYSTEM_POWER_STATE_DISABLE_REASON _LoggingReason;
        PWSTR _MessageResourceString;
        HINSTANCE _hInst;
    public: // methods
        PowerLoggingMessage(
            IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
            IN DWORD SStateBaseMessageIndex,
            IN HINSTANCE hInstance
            );            
        virtual ~PowerLoggingMessage(VOID);
        virtual BOOL GetString(PWSTR *String) = 0;

    protected:
        PWSTR 
            DuplicateString(
                IN PWSTR String
                );
        BOOL 
            GetResourceString(
                OUT PWSTR *String
                );

};

class
NoSubstitutionPowerLoggingMessage :
    public PowerLoggingMessage
{
    public:
    NoSubstitutionPowerLoggingMessage(
        IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
        IN DWORD SStateBaseMessageIndex,
        IN HINSTANCE hInstance
        );            
    BOOL GetString(PWSTR *String);
};

class
SubstituteNtStatusPowerLoggingMessage :
    public PowerLoggingMessage
{   
    public:
    SubstituteNtStatusPowerLoggingMessage(
        IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
        IN DWORD SStateBaseMessageIndex,
        IN HINSTANCE hInstance
        );            
    BOOL GetString(PWSTR *String);
};       

class
SubstituteMultiSzPowerLoggingMessage :
    public PowerLoggingMessage
{          
    public:
    SubstituteMultiSzPowerLoggingMessage(
        IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
        IN DWORD SStateBaseMessageIndex,
        IN HINSTANCE hInstance
        );            
    BOOL GetString(PWSTR *String);
};       

}
#endif  /* __cplusplus */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\powercfg\powermsg.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation
 
Module Name:
 
    powermsg.c
 
Abstract:
 
    Classes for manipulating power logging error messages.
 
Author:
 
    Andrew Ritz (andrewr) 1-May-2002
 
Revision History:
 
    
    Andrew Ritz (andrewr) 1-May-2002   - created it.
 
--*/


#include "powercfg.h"
#include "resource.h"


PowerLoggingMessage::PowerLoggingMessage(
    IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
    IN DWORD SStateBaseMessageIndex,
    IN HINSTANCE hInstance
    )
/*++
 
Routine Description:
 
    Base PowerLoggingMessage class constructor.
 
Arguments:
 
    LoggingReason - structure containing the reason data we're wrapping.
    SStateBaseMessageIndex - base message id we use for looking up a resource
                    string associated with this problem.
    hInstance - module handle for looking up resource associated with this 
                    problem.
    
Return Value:
    
    none.
    
--*/

{
    //
    // save off the logging reason data.
    //
    _LoggingReason = (PSYSTEM_POWER_STATE_DISABLE_REASON) LocalAlloc(LPTR, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)+LoggingReason->PowerReasonLength);

    if (!_LoggingReason) {
        throw(HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
    }

    CopyMemory(_LoggingReason,LoggingReason, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON)+LoggingReason->PowerReasonLength);

    //
    // the message resource is offset from the supplied base index.
    //
    if (_LoggingReason->PowerReasonCode == SPSD_REASON_UNKNOWN) {
        _MessageResourceId = SStateBaseMessageIndex + MAX_REASON_OFFSET;
    } else {
        _MessageResourceId = SStateBaseMessageIndex + _LoggingReason->PowerReasonCode;
    }

    ASSERT(_MessageResourceId <= SStateBaseMessageIndex + MAX_REASON_OFFSET);
    
    _hInst = hInstance;
    //
    // this is a cache of the reason, initialized to NULL, filled in when we
    // call GetString
    //
    _MessageResourceString = NULL;

}
                    
PowerLoggingMessage::~PowerLoggingMessage(
    VOID
    )
/*++
 
Routine Description:
 
    Base PowerLoggingMessage class destructor.  deletes some member data.
 
Arguments:
 
    none.
    
Return Value:
    
    none.
    
--*/

{
    //
    // delete member data.
    //
    if (_LoggingReason) {
        LocalFree(_LoggingReason);
    }

    if (_MessageResourceString) {
        LocalFree(_MessageResourceString);
    }    
}

PWSTR
PowerLoggingMessage::DuplicateString(
    IN PWSTR String
    )
/*++
 
Routine Description:
 
    PowerLoggingMessage helper for copying a string to a newly allocated
    heap buffer.
 
Arguments:
 
    String - null terminated unicode string to duplicate.
    
Return Value:
    
    pointer to new heap buffer with copy of string if successful, else NULL.
    
--*/
{
    PWSTR MyString;
    DWORD StringLength;

    StringLength = (wcslen(String)+1);
    MyString = (PWSTR)LocalAlloc(LPTR, StringLength*sizeof(WCHAR));
    if (MyString) {
        CopyMemory(MyString,String,StringLength*sizeof(WCHAR));
    }

    return(MyString);
}


BOOL
PowerLoggingMessage::GetResourceString(
    OUT PWSTR *pString
    )
/*++
 
Routine Description:
 
    PowerLoggingMessage wrapper for LoadString.
 
Arguments:
 
    pString - receives a pointer to a string with the resource.    
    
Return Value:
    
    TRUE inidicates success.
    
--*/
{
    PWSTR MyString;
    DWORD StringLength,RetVal;

    ASSERT(pString != NULL);

    //
    // arbitrary string length of 200 should hopefully be enough for any
    // resource string.
    //
    StringLength = 200;
    RetVal = 0;
    MyString = (PWSTR)LocalAlloc(LPTR, StringLength*sizeof(WCHAR));
    if (MyString) {
        RetVal = ::LoadString(
                        _hInst,
                        _MessageResourceId,
                        MyString,
                        StringLength);
    }

    if (RetVal != 0) {
        *pString = MyString;
    }

    return(*pString != NULL);
}

SubstituteNtStatusPowerLoggingMessage::SubstituteNtStatusPowerLoggingMessage(
    IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
    IN DWORD SStateBaseMessageIndex,
    IN HINSTANCE hInstance
    ) : PowerLoggingMessage(LoggingReason,SStateBaseMessageIndex,hInstance)
/*++
 
Routine Description:
 
    specialized class constructor.  
 
Arguments:
 
    LoggingReason - structure containing the reason data we're wrapping.
    SStateBaseMessageIndex - base message id we use for looking up a resource
                    string associated with this problem.
    hInstance - module handle for looking up resource associated with this 
                    problem.
    
Return Value:
    
    none.
    
--*/
{    
    //
    //We just inherit the base case behavior.
    //
}

NoSubstitutionPowerLoggingMessage::NoSubstitutionPowerLoggingMessage(
    IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
    IN DWORD SStateBaseMessageIndex,
    IN HINSTANCE hInstance
    ) : PowerLoggingMessage(LoggingReason,SStateBaseMessageIndex,hInstance)
/*++
 
Routine Description:
 
    specialized class constructor.  
 
Arguments:
 
    LoggingReason - structure containing the reason data we're wrapping.
    SStateBaseMessageIndex - base message id we use for looking up a resource
                    string associated with this problem.
    hInstance - module handle for looking up resource associated with this 
                    problem.
    
Return Value:
    
    none.
    
--*/
{    
    //
    //We just inherit the base case behavior.
    //
}

SubstituteMultiSzPowerLoggingMessage::SubstituteMultiSzPowerLoggingMessage(
    IN PSYSTEM_POWER_STATE_DISABLE_REASON LoggingReason,
    IN DWORD SStateBaseMessageIndex,
    IN HINSTANCE hInstance
    ) : PowerLoggingMessage(LoggingReason,SStateBaseMessageIndex,hInstance)
/*++
 
Routine Description:
 
    specialized class constructor.  
 
Arguments:
 
    LoggingReason - structure containing the reason data we're wrapping.
    SStateBaseMessageIndex - base message id we use for looking up a resource
                    string associated with this problem.
    hInstance - module handle for looking up resource associated with this 
                    problem.
    
Return Value:
    
    none.
    
--*/
{    
    //
    //We just inherit the base case behavior.
    //
}

BOOL
NoSubstitutionPowerLoggingMessage::GetString(
    PWSTR *String
    )
/*++
 
Routine Description:
 
    specialized GetString method, gets a string appropriate for display to
    the end user.  This one is just looking up a resource string.
 
Arguments:
 
    String - receives a pointer to a heap allocated string.  must be freed
             with LocalFree() when complete.
Return Value:
    
    BOOL indicating outcome.
    
--*/
{

    ASSERT(String != NULL);

    //
    // lookup and cache the message.
    //
    if (!_MessageResourceString) {
        if (!GetResourceString(&_MessageResourceString)) {
            _MessageResourceString = NULL;
            return(FALSE);
        }    
    }

    ASSERT(_MessageResourceString != NULL);

    //
    // dup the cached string and return to caller.
    //
    *String = DuplicateString(_MessageResourceString);
    return(*String != NULL);
       
}


BOOL
SubstituteNtStatusPowerLoggingMessage::GetString(
    PWSTR *String
    )
/*++
 
Routine Description:
 
    specialized GetString method, gets a string appropriate for display to
    the end user.  this one takes a string with a %d in it and returns a 
    formatted string.
 
Arguments:
 
    String - receives a pointer to a heap allocated string.  must be freed
             with LocalFree() when complete.
Return Value:
    
    BOOL indicating outcome.
    
--*/
{
    PWSTR MyString;
    PDWORD NtStatusCode = (PDWORD)(PCHAR)((PCHAR)_LoggingReason + sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
    
    if (!_MessageResourceString) {
        if (!GetResourceString(&MyString)) {
            _MessageResourceString = NULL;
            return(FALSE);
        }

        //
        // 10 is the maximum # of digits for the substituted NTSTATUS code.
        // 1 for the NULL.
        //
        _MessageResourceString = (PWSTR)LocalAlloc(LPTR,(wcslen(MyString)+10+1)*sizeof(WCHAR));
        if (!_MessageResourceString) {
            LocalFree(MyString);
            return(FALSE);
        }

        wsprintf(_MessageResourceString,MyString,*NtStatusCode);

        LocalFree(MyString);

    }

    ASSERT(_MessageResourceString != NULL);

    //
    // dup the cached string and return to caller.
    //
    *String = DuplicateString(_MessageResourceString);
    return(*String != NULL);
    
}

BOOL
SubstituteMultiSzPowerLoggingMessage::GetString(
    PWSTR *String
    )
/*++
 
Routine Description:
 
    specialized GetString method, gets a string appropriate for display to
    the end user.  this one massages a multi-sz string and substitutes that
    into the resource.
 
Arguments:
 
    String - receives a pointer to a heap allocated string.  must be freed
             with LocalFree() when complete.
Return Value:
    
    BOOL indicating outcome.
    
--*/
{
    PWSTR MyString;
    PWSTR SubstitutionString;          
    DWORD NumberOfStrings;
    DWORD StringSize;
    PWSTR CurrentString;
    DWORD CurrentStringLength;
    PWSTR BaseOfString = (PWSTR)(PCHAR)((PCHAR)_LoggingReason + sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));

    PWSTR SeparatorString = L"\n\t\t";
    DWORD SeparatorLength = wcslen(SeparatorString);
    
    if (!_MessageResourceString) {
        //
        // get the resource
        //
        if (!GetResourceString(&MyString)) {
            _MessageResourceString = NULL;
            return(FALSE);
        }

        //
        // get the multi-sz into a prettier format
        // first figure out the size, then alloc space and print it out into
        // a buffer.
        //
        NumberOfStrings = 0;
        StringSize = 0;
        CurrentString = BaseOfString;
        CurrentStringLength = 0;
        while (*CurrentString) {
            CurrentStringLength = wcslen(CurrentString)+1;
            StringSize +=CurrentStringLength;
            CurrentString += CurrentStringLength;
            NumberOfStrings += 1;
        }

        SubstitutionString = (PWSTR)LocalAlloc(LPTR,(StringSize+1+(NumberOfStrings*SeparatorLength))*sizeof(WCHAR));
        if (!SubstitutionString) {
            LocalFree(MyString);
            return(FALSE);
        }

        CurrentString = BaseOfString;
        do {
            CurrentStringLength = wcslen(CurrentString)+1;

            wcscat(SubstitutionString,SeparatorString);
            wcscat(SubstitutionString,CurrentString);

            CurrentString += CurrentStringLength;
            NumberOfStrings -= 1;

        } while (NumberOfStrings != 0);

        //
        // alloc space for the substitution string PLUS the base message.
        //
        _MessageResourceString = (PWSTR)LocalAlloc(
                                            LPTR,
                                              (wcslen(SubstitutionString) +
                                              wcslen(MyString) + 1)
                                              *sizeof(WCHAR));
        if (!_MessageResourceString) {
            LocalFree(SubstitutionString);
            LocalFree(MyString);
            return(FALSE);
        }

        //
        // finally "sprintf" them together to get the final string.
        // free the strings we allocated along the way.
        //
        wsprintf(_MessageResourceString,MyString,SubstitutionString);

        LocalFree(SubstitutionString);
        LocalFree(MyString);

    }

    ASSERT(_MessageResourceString != NULL);

    //
    // dup the cached string and return to caller.
    //
    *String = DuplicateString(_MessageResourceString);
    return(*String != NULL);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\powercfg\resource.h ===
#define IDS_ON                          1
#define IDS_OFF                         2
#define IDS_HIBER_INVALID_STATE         3
#define IDS_HIBER_UNSUPPORTED           4
#define IDS_HIBER_CONFIG_FAIL           5
#define IDS_SYSCAP_FAIL                 6
#define IDS_INVALID_CMDLINE_PARAM       7
#define IDS_OUT_OF_MEMORY               8
#define IDS_SCHEME_NOT_FOUND            9
#define IDS_ACTIVE_SCHEME_INVALID       10
#define IDS_SCHEME_ALREADY_EXISTS       11
#define IDS_SCHEME_CREATE_FAIL          12
#define IDS_INVALID_NUMERICAL_IMPORT    13

#define IDS_SCHEME_NAME                 14
#define IDS_SCHEME_DESCRIPTION          15
#define IDS_MONITOR_TIMEOUT_AC          16
#define IDS_MONITOR_TIMEOUT_DC          17
#define IDS_DISK_TIMEOUT_AC             18
#define IDS_DISK_TIMEOUT_DC             19
#define IDS_STANDBY_TIMEOUT_AC          20
#define IDS_STANDBY_TIMEOUT_DC          21
#define IDS_HIBER_TIMEOUT_AC            22
#define IDS_HIBER_TIMEOUT_DC            23

//
// The indexes for the usage has gaps to allow easier insertion of new options.
// This means that the code that prints the usage will occationally call 
// GetResString with an invalid ID.  This simply returns a NULL string.
//

//Usage: command format
#define IDS_USAGE_START                 24
#define IDS_USAGE_01                    25
#define IDS_USAGE_02                    26
#define IDS_USAGE_03                    27
#define IDS_USAGE_04                    28
#define IDS_USAGE_04_1                      700
#define IDS_USAGE_05                    29
#define IDS_USAGE_06                    30
#define IDS_USAGE_07                    31
#define IDS_USAGE_08                    32
#define IDS_USAGE_09                    33
#define IDS_USAGE_10                    34
#define IDS_USAGE_11                    35
#define IDS_USAGE_12                    36
#define IDS_USAGE_13                    37
#define IDS_USAGE_14                    38
#define IDS_USAGE_15                    39
#define IDS_USAGE_16                    40
#define IDS_USAGE_17                    41
#define IDS_USAGE_18                    42
#define IDS_USAGE_19                    43
#define IDS_USAGE_20                    44
#define IDS_USAGE_21                    45
#define IDS_USAGE_22                    46
#define IDS_USAGE_23                    47
#define IDS_USAGE_24                    48
#define IDS_USAGE_25                    49
#define IDS_USAGE_26                    50
#define IDS_USAGE_27                    51
#define IDS_USAGE_28                    52
#define IDS_USAGE_29                    53
#define IDS_USAGE_30                    54
#define IDS_USAGE_31                    55
#define IDS_USAGE_32                    56
#define IDS_USAGE_33                    57
#define IDS_USAGE_34                    58
#define IDS_USAGE_35                    59
#define IDS_USAGE_36                    60
#define IDS_USAGE_37                    61
#define IDS_USAGE_38                    62
#define IDS_USAGE_39                    63
#define IDS_USAGE_40                    64
#define IDS_USAGE_41                    65
#define IDS_USAGE_42                    66
#define IDS_USAGE_43                    67
#define IDS_USAGE_44                    68
#define IDS_USAGE_45                    69
#define IDS_USAGE_46                    70
#define IDS_USAGE_47                    71
#define IDS_USAGE_48                    72
#define IDS_USAGE_49                    73
#define IDS_USAGE_50                    74
#define IDS_USAGE_51                    75
#define IDS_USAGE_52                    76
#define IDS_USAGE_53                    77
#define IDS_USAGE_54                    78
#define IDS_USAGE_55                    79
#define IDS_USAGE_56                    80
#define IDS_USAGE_57                    81
#define IDS_USAGE_58                    82
#define IDS_USAGE_59                    83
#define IDS_USAGE_60                    84
#define IDS_USAGE_60_01                     701
#define IDS_USAGE_60_02                     702
#define IDS_USAGE_60_03                     703
#define IDS_USAGE_60_04                     704
#define IDS_USAGE_60_05                     705
#define IDS_USAGE_60_06                     706
#define IDS_USAGE_60_07                     707
#define IDS_USAGE_60_08                     708
#define IDS_USAGE_60_09                     709
#define IDS_USAGE_61                    85    
#define IDS_USAGE_62                    86
#define IDS_USAGE_63                    87
#define IDS_USAGE_64                    88
#define IDS_USAGE_65                    89
#define IDS_USAGE_66                    90
#define IDS_USAGE_67                    91
#define IDS_USAGE_68                    92
#define IDS_USAGE_69                    93
#define IDS_USAGE_70                    94
#define IDS_USAGE_71                    95
#define IDS_USAGE_72                    96
#define IDS_USAGE_73                    97
#define IDS_USAGE_74                    98
#define IDS_USAGE_75                    99
#define IDS_USAGE_76                   100
#define IDS_USAGE_77                   101
#define IDS_USAGE_78                   102
#define IDS_USAGE_END                  103

                                         
#define IDS_LIST_HEADER1               194
#define IDS_LIST_HEADER2               195
#define IDS_QUERY_HEADER1              196
#define IDS_QUERY_HEADER2              197
#define IDS_QUERY_FOOTER               198
#define IDS_UNEXPECTED_ERROR           199
#define IDS_HIBER_OUT_OF_RANGE         200
#define IDS_MINUTES                    201
#define IDS_DISABLED                   202
#define IDS_UNSUPPORTED                203
#define IDS_STANDBY_WARNING            204
#define IDS_HIBER_WARNING              205
#define IDS_MONITOR_WARNING            206
#define IDS_DISK_WARNING               207
#define IDS_HIBER_PRIVILEGE            208
#define IDS_DEFAULT_FILENAME           209
#define IDS_GLOBAL_FLAG_INVALID_STATE  210
#define IDS_GLOBAL_FLAG_INVALID_FLAG   211

#define IDS_THROTTLE_AC                310
#define IDS_THROTTLE_DC                311
#define IDS_THROTTLE_NONE              312
#define IDS_THROTTLE_CONSTANT          313
#define IDS_THROTTLE_DEGRADE           314
#define IDS_THROTTLE_ADAPTIVE          315
#define IDS_THROTTLE_UNKNOWN           316
#define IDS_DLL_LOAD_ERROR             317
#define IDS_DLL_PROC_ERROR             318
#define IDS_SCHEME_ID                  319

//
// Be sure to leave some room after these constants for more reasons in the 
// future.
//
#define IDS_HIBER_FAILED_DESCRIPTION_HEADER 400
#define IDS_BASE_HIBER_REASON_CODE          401
#define IDS_HIBER_REASON_NONE               401
#define IDS_HIBER_REASON_NOBIOS             402
#define IDS_HIBER_REASON_BIOSINCOMPAT       403
#define IDS_HIBER_REASON_NOOSPM             404
#define IDS_HIBER_REASON_LEGDRV             405
#define IDS_HIBER_REASON_HIBERSTACK         406
#define IDS_HIBER_REASON_HIBERFILE          407
#define IDS_HIBER_REASON_POINTERAL          408
#define IDS_HIBER_REASON_PAEMODE            409
#define IDS_HIBER_REASON_MPOVERRIDE         410
#define IDS_HIBER_REASON_DRIVERDOWNGRADE    411
#define IDS_HIBER_REASON_UNKNOWN            412

#define IDS_HIBER_REASON_NOOSPM_IA64        450

#define MAX_REASON_OFFSET IDS_HIBER_REASON_UNKNOWN - IDS_BASE_HIBER_REASON_CODE
//
// Be sure to leave some room after these constants for more reasons in the 
// future.
//
#define IDS_BASE_SX_REASON_CODE             501
#define IDS_SX_REASON_NONE                  501
#define IDS_SX_REASON_NOBIOS                502
#define IDS_SX_REASON_BIOSINCOMPAT          503
#define IDS_SX_REASON_NOOSPM                504
#define IDS_SX_REASON_LEGDRV                505
#define IDS_SX_REASON_HIBERSTACK            506
#define IDS_SX_REASON_HIBERFILE             507
#define IDS_SX_REASON_POINTERAL             508
#define IDS_SX_REASON_PAEMODE               509
#define IDS_SX_REASON_MPOVERRIDE            510
#define IDS_SX_REASON_DRIVERDOWNGRADE       511
#define IDS_SX_REASON_UNKNOWN               512

#define IDS_SX_REASON_NOOSPM_IA64           550
                                            
#define IDS_BASE_S1_HEADER                  600
#define IDS_BASE_S2_HEADER                  601
#define IDS_BASE_S3_HEADER                  602
                                            
#define IDS_CANTGETSLEEPSTATES              610
#define IDS_CANTGETSSTATEREASONS            611
#define IDS_SLEEPSTATES_AVAILABLE           612
#define IDS_SLEEPSTATES_UNAVAILABLE         613
                                            
#define IDS_STANDBY                         620
#define IDS_LEFTPAREN                       621
#define IDS_S1                              622
#define IDS_S2                              623
#define IDS_S3                              624
#define IDS_RIGHTPAREN                      625
#define IDS_HIBERNATE                       626                                            
#define IDS_SHUTDOWN                        627

#define IDS_ALARM_HEADER1                   630
#define IDS_ALARM_HEADER2                   631
#define IDS_ALARM_NAME                      632
#define IDS_LOW                             633
#define IDS_CRITICAL                        634
#define IDS_ALARM_ACTIVE                    635
#define IDS_ALARM_LEVEL                     636
#define IDS_ALARM_TEXT                      637
#define IDS_ALARM_SOUND                     638
#define IDS_ALARM_ACTION                    639
#define IDS_NONE                            640
#define IDS_INVALID                         641
#define IDS_ALARM_FORCE                     642
#define IDS_ALARM_PROGRAM                   643
#define IDS_ALARM_PROGRAM_NAME              644
#define IDS_ALARM_INVALID_ALARM             645
#define IDS_ALARM_INVALID_ACTIVATE          646
#define IDS_ALARM_INVALID_LEVEL             647
#define IDS_ALARM_INVALID_TEXT              648
#define IDS_ALARM_INVALID_SOUND             649
#define IDS_ALARM_INVALID_ACTION            650
#define IDS_ALARM_INVALID_FORCE             651
#define IDS_ALARM_INVALID_PROGRAM           652
#define IDS_ALARM_PROGRAM_FAILED            653
#define IDS_ALARM_STANDBY_UNSUPPORTED       654
#define IDS_ALARM_HIBERNATE_DISABLED        655
#define IDS_HIBERNATE_ALARM_DISABLED        656
#define IDS_HIBERNATE_ALARM_DISABLE_FAILED  657
#define IDS_ALARM_LEVEL_MINIMUM             658
#define IDS_ALARM_LEVEL_EQUAL               659
#define IDS_ALARM_FORCE_CRITICAL            660
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\change.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        change.h

    Abstract:

        This module contains the macros, user defined structures & function
        definitions needed by change.cpp

    Author:

        Venu Gopal Choudary   01-Mar-2001

    Revision History:

        Venu Gopal Choudary   01-Mar-2001  : Created it


******************************************************************************/

#ifndef __CHANGE_H
#define __CHANGE_H

#pragma once
#define MAX_CHANGE_OPTIONS        20

#define OI_CHANGE_OPTION           0 // Index of -create option in cmdOptions structure.
#define OI_CHANGE_USAGE            1 // Index of -? option in cmdOptions structure.
#define OI_CHANGE_SERVER           2 // Index of -s option in cmdOptions structure.
#define OI_CHANGE_USERNAME         3 // Index of -u option in cmdOptions structure.
#define OI_CHANGE_PASSWORD         4 // Index of -p option in cmdOptions structure.
#define OI_CHANGE_RUNASUSER        5 // Index of -ru option in cmdOptions structure.
#define OI_CHANGE_RUNASPASSWORD    6 // Index of -rp option in cmdOptions structure.
#define OI_CHANGE_TASKNAME         7 // Index of -taskname option in cmdOptions structure.
#define OI_CHANGE_TASKRUN          8 // Index of -taskrun option in cmdOptions structure.
#define OI_CHANGE_STARTTIME        9 // Index of -starttime option in cmdOptions structure.
#define OI_CHANGE_STARTDATE        10 // Index of -startdate option in cmdOptions structure.
#define OI_CHANGE_ENDDATE          11 // Index of -enddate option in cmdOptions structure.
#define OI_CHANGE_IT               12 // Index of -it option in cmdOptions structure.
#define OI_CHANGE_ENDTIME          13 // Index of -endtime option in cmdOptions structure.
#define OI_CHANGE_DUR_END          14 // Index of -k option in cmdOptions structure.
#define OI_CHANGE_DURATION         15 // Index of -du option in cmdOptions structure.
#define OI_CHANGE_ENABLE           16 // Index of -enable option in cmdOptions structure.
#define OI_CHANGE_DISABLE          17 // Index of -disable option in cmdOptions structure.
#define OI_CHANGE_DELNOSCHED       18 // Index of -n option in cmdOptions structure.
#define OI_CHANGE_REPEAT_INTERVAL  19 // Index of -ri option in cmdOptions structure.
//#define OI_CHANGE_REPEAT_TASK      20 // Index of -rt option in cmdOptions structure.


typedef struct __tagChangeSubOps
{
    WCHAR   *szServer ;        // Server Name
    WCHAR   *szRunAsUserName ;     //Run As User Name
    WCHAR   *szRunAsPassword;  // Run As Password
    WCHAR   *szUserName ;      // User Name
    WCHAR   *szPassword ;  // Password
    WCHAR   szTaskName [ MAX_JOB_LEN];        // Task Name
    WCHAR   szStartTime[MAX_STRING_LENGTH] ;  // Task start time
    WCHAR   szEndTime [MAX_STRING_LENGTH];    // Task end time
    WCHAR   szStartDate [MAX_STRING_LENGTH];  // Task start date
    WCHAR   szEndDate [MAX_STRING_LENGTH];    // End Date of the Task
    WCHAR   szTaskRun [MAX_TASK_LEN];         // executable name of task
    WCHAR   szDuration [MAX_STRING_LENGTH];   //duration
    WCHAR   szRepeat [MAX_STRING_LENGTH];   //Repetition Interval
    BOOL    bChange; // /Change option
    BOOL    bUsage;  // /? option.
    BOOL    bInteractive; // /it option
    BOOL    bIsDurEnd; // /du option
    BOOL    bEnable; // /enable option
    BOOL    bDisable; // /disable option
    BOOL    bDelIfNotSched; // /n option
    BOOL    bIsRepeatTask ; // /rt option

} TCHANGESUBOPTS, *PTCHANGESUBOPTS;


typedef struct __tagChangeOptVals
{
    //BOOL    bSetStartDateToCurDate; // Is start date to be set to current date
    //BOOL    bSetStartTimeToCurTime; // Is start date to be set to current date
    BOOL    bPassword;
    BOOL    bRunAsPassword;
    BOOL    bNeedPassword;
    BOOL    bFlag;

} TCHANGEOPVALS;

DWORD ValidateChangeOptions(DWORD argc, TCMDPARSER2 cmdChangeParser[], 
      TCHANGESUBOPTS &tchgsubops, TCHANGEOPVALS &tchgoptvals );

BOOL
ReleaseChangeMemory(
              IN PTCHANGESUBOPTS pParams
              );

DWORD
ValidateChangeSuboptVal(
                  OUT TCHANGESUBOPTS& tchgsubops,
                  OUT TCHANGEOPVALS &tchgoptvals,
                  IN TCMDPARSER2 cmdOptions[],
                  IN DWORD dwScheduleType
                  );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\commonheaderfiles.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        CommonHeaderFiles.h

    Abstract:

        This module includes the common files needed for all the source files
        in this project.

    Author:

        G.Surender Reddy  30-oct-2000

    Revision History:

        G.Surender Reddy  30-oct-2000 : Created it
        Venu Gopal Choudary 12-Mar-2001 : Added run.h and end.h

******************************************************************************/

#ifndef __COMHEADERFILES_H
#define __COMHEADERFILES_H

//common include files needed for all other cpp files in this project

#include "scheduledtasks.h"
#include "resource.h"
#include "create.h"
#include "query.h"
#include "change.h"
#include "run.h"
#include "end.h"

#endif //__COMHEADERFILES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\change.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        change.cpp

    Abstract:

        This module changes the parameters of task(s) present in the system

    Author:

        Venu Gopal Choudary 01-Mar-2001

    Revision History:

        Venu Gopal Choudary  01-Mar-2001 : Created it


******************************************************************************/


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


// Function declaration for the Usage function.
DWORD DisplayChangeUsage();
BOOL GetTheUserName( LPWSTR pszUserName, DWORD dwMaxUserNameSize );

/*****************************************************************************

    Routine Description:

    This routine  Changes the paraemters of a specified scheduled task(s)

    Arguments:

        [ in ] argc :  Number of command line arguments
        [ in ] argv :  Array containing command line arguments

    Return Value :
        A DWORD value indicating EXIT_SUCCESS on success else
        EXIT_FAILURE on failure

*****************************************************************************/

DWORD
ChangeScheduledTaskParams(
                            IN DWORD argc,
                            IN LPCTSTR argv[]
                            )
{
    // Variables used to find whether Change option, Usage option
    // are specified or not
    //BOOL bChange = FALSE;
    //BOOL bUsage = FALSE;

    // Set the TaskSchduler object as NULL
    ITaskScheduler *pITaskScheduler = NULL;

    // Return value
    HRESULT hr  = S_OK;

    // Declarations related to Task name
    LPWSTR   wszUserName = NULL;
    LPWSTR   wszPassword = NULL;
    WCHAR   wszApplName[_MAX_FNAME] ;

    // Dynamic Array contaning array of jobs
    TARRAY arrJobs = NULL;

    //buffer for displaying error message
    WCHAR   szMessage[ 2 * MAX_JOB_LEN ] = L"\0";
    BOOL bUserName = TRUE;
    BOOL bPassWord = TRUE;
    BOOL bSystemStatus = FALSE;
    //BOOL  bNeedPassword = FALSE;
    BOOL  bResult = FALSE;
    BOOL  bCloseConnection = TRUE;
    DWORD dwPolicy = 0;

    TCMDPARSER2 cmdChangeOptions[MAX_CHANGE_OPTIONS];
    //BOOL bReturn = FALSE;

    SecureZeroMemory ( wszApplName, SIZE_OF_ARRAY(wszApplName));

    // declarations of structures
    TCHANGESUBOPTS tchgsubops;
    TCHANGEOPVALS tchgoptvals;

    //Initialize structures to neutral values.
    //SecureZeroMemory( &cmdChangeOptions, sizeof( TCMDPARSER2 ) * MAX_CHANGE_OPTIONS);
    SecureZeroMemory( &tchgsubops, sizeof( TCHANGESUBOPTS ) );
    SecureZeroMemory( &tchgoptvals, sizeof( TCHANGEOPVALS ) );

    BOOL bReturn = FALSE;

    // /change sub-options
    const WCHAR szChangeOpt[]           = L"change";
    const WCHAR szChangeHelpOpt[]       = L"?";
    const WCHAR szChangeServerOpt[]     = L"s";
    const WCHAR szChangeUserOpt[]       = L"u";
    const WCHAR szChangePwdOpt[]        = L"p";
    const WCHAR szChangeRunAsUserOpt[]  = L"ru";
    const WCHAR szChangeRunAsPwdOpt[]   = L"rp";
    const WCHAR szChangeTaskNameOpt[]   = L"tn";
    const WCHAR szChangeTaskRunOpt[]    = L"tr";
    const WCHAR szChangeStartTimeOpt[]  = L"st";
    const WCHAR szChangeEndTimeOpt[]    = L"et";
    const WCHAR szChangeStartDateOpt[]  = L"sd";
    const WCHAR szChangeEndDateOpt[]    = L"ed";
    const WCHAR szChangeKillAtDurOpt[]  = L"k";
    const WCHAR szChangeDurationOpt[]    = L"du";
    const WCHAR szChangeInteractiveOpt[] = L"it";
    const WCHAR szChangeStatusOn[]       = L"enable";
    const WCHAR szChangeStatusOff[]      = L"disable";
    const WCHAR szChangeDelIfNotSchedOpt[] = L"z";
    const WCHAR szChangeRepeatIntervalOpt[] = L"ri";

    //
    // fill the commandline parser
    //

   // set all the fields to 0
    SecureZeroMemory( cmdChangeOptions, sizeof( TCMDPARSER2 ) * MAX_CHANGE_OPTIONS );

    //  /change option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_OPTION ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_OPTION ].dwType       = CP_TYPE_BOOLEAN;
    cmdChangeOptions[ OI_CHANGE_OPTION ].pwszOptions  = szChangeOpt;
    cmdChangeOptions[ OI_CHANGE_OPTION ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_OPTION ].dwFlags = 0;
    cmdChangeOptions[ OI_CHANGE_OPTION ].pValue = &tchgsubops.bChange;

    //  /? option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdChangeOptions[ OI_CHANGE_USAGE ].pwszOptions  = szChangeHelpOpt;
    cmdChangeOptions[ OI_CHANGE_USAGE ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_USAGE ].dwFlags = CP2_USAGE;
    cmdChangeOptions[ OI_CHANGE_USAGE ].pValue = &tchgsubops.bUsage;

    //  /s option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_SERVER ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_SERVER ].pwszOptions  = szChangeServerOpt;
    cmdChangeOptions[ OI_CHANGE_SERVER ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_SERVER ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /u option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_USERNAME ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_USERNAME ].pwszOptions  = szChangeUserOpt;
    cmdChangeOptions[ OI_CHANGE_USERNAME ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_USERNAME ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /p option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_PASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_PASSWORD ].pwszOptions  = szChangePwdOpt;
    cmdChangeOptions[ OI_CHANGE_PASSWORD ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_PASSWORD ].dwActuals = 0;
    cmdChangeOptions[ OI_CHANGE_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL ;

    //  /ru option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_RUNASUSER ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_RUNASUSER ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_RUNASUSER ].pwszOptions  = szChangeRunAsUserOpt;
    cmdChangeOptions[ OI_CHANGE_RUNASUSER ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_RUNASUSER ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT;

    //  /rp option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_RUNASPASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_RUNASPASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_RUNASPASSWORD ].pwszOptions  = szChangeRunAsPwdOpt;
    cmdChangeOptions[ OI_CHANGE_RUNASPASSWORD ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_RUNASPASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;

    //  /st option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_STARTTIME ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_STARTTIME ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_STARTTIME ].pwszOptions  = szChangeStartTimeOpt;
    cmdChangeOptions[ OI_CHANGE_STARTTIME ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_STARTTIME ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdChangeOptions[ OI_CHANGE_STARTTIME ].pValue = tchgsubops.szStartTime;
    cmdChangeOptions[ OI_CHANGE_STARTTIME ].dwLength = MAX_STRING_LENGTH;

     //  /sd option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_STARTDATE ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_STARTDATE ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_STARTDATE ].pwszOptions  = szChangeStartDateOpt;
    cmdChangeOptions[ OI_CHANGE_STARTDATE ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_STARTDATE ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdChangeOptions[ OI_CHANGE_STARTDATE ].pValue = tchgsubops.szStartDate;
    cmdChangeOptions[ OI_CHANGE_STARTDATE ].dwLength = MAX_STRING_LENGTH;

      //  /ed option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_ENDDATE ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_ENDDATE ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_ENDDATE ].pwszOptions  = szChangeEndDateOpt;
    cmdChangeOptions[ OI_CHANGE_ENDDATE ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_ENDDATE ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdChangeOptions[ OI_CHANGE_ENDDATE ].pValue = tchgsubops.szEndDate;
    cmdChangeOptions[ OI_CHANGE_ENDDATE ].dwLength = MAX_STRING_LENGTH;

    //  /et option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_ENDTIME ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_ENDTIME ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_ENDTIME ].pwszOptions  = szChangeEndTimeOpt;
    cmdChangeOptions[ OI_CHANGE_ENDTIME ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_ENDTIME ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdChangeOptions[ OI_CHANGE_ENDTIME ].pValue = &tchgsubops.szEndTime;
    cmdChangeOptions[ OI_CHANGE_ENDTIME ].dwLength = MAX_STRING_LENGTH;

      //  /k option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_DUR_END ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_DUR_END ].dwType       = CP_TYPE_BOOLEAN ;
    cmdChangeOptions[ OI_CHANGE_DUR_END ].pwszOptions  = szChangeKillAtDurOpt ;
    cmdChangeOptions[ OI_CHANGE_DUR_END ].dwCount = 1 ;
    cmdChangeOptions[ OI_CHANGE_DUR_END ].pValue = &tchgsubops.bIsDurEnd;

    //  /du option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_DURATION ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_DURATION ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_DURATION ].pwszOptions  = szChangeDurationOpt;
    cmdChangeOptions[ OI_CHANGE_DURATION ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_DURATION ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdChangeOptions[ OI_CHANGE_DURATION ].pValue = tchgsubops.szDuration;
    cmdChangeOptions[ OI_CHANGE_DURATION ].dwLength = MAX_STRING_LENGTH;

     //  /tn option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_TASKNAME ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_TASKNAME ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_TASKNAME ].pwszOptions  = szChangeTaskNameOpt;
    cmdChangeOptions[ OI_CHANGE_TASKNAME ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_TASKNAME ].dwFlags = CP2_MANDATORY;
    cmdChangeOptions[ OI_CHANGE_TASKNAME ].pValue = tchgsubops.szTaskName;
    cmdChangeOptions[ OI_CHANGE_TASKNAME ].dwLength = MAX_JOB_LEN;

     //  /tr option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_TASKRUN ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_TASKRUN ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_TASKRUN ].pwszOptions  = szChangeTaskRunOpt;
    cmdChangeOptions[ OI_CHANGE_TASKRUN ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_TASKRUN ].dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;
    cmdChangeOptions[ OI_CHANGE_TASKRUN ].pValue = tchgsubops.szTaskRun;
    cmdChangeOptions[ OI_CHANGE_TASKRUN ].dwLength = MAX_TASK_LEN;

     //  /it option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_IT ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_IT ].dwType       = CP_TYPE_BOOLEAN;
    cmdChangeOptions[ OI_CHANGE_IT ].pwszOptions  = szChangeInteractiveOpt;
    cmdChangeOptions[ OI_CHANGE_IT ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_IT ].dwFlags = 0;
    cmdChangeOptions[ OI_CHANGE_IT ].pValue = &tchgsubops.bInteractive;

    //  /enable option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_ENABLE ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_ENABLE ].dwType       = CP_TYPE_BOOLEAN;
    cmdChangeOptions[ OI_CHANGE_ENABLE ].pwszOptions  = szChangeStatusOn;
    cmdChangeOptions[ OI_CHANGE_ENABLE ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_ENABLE ].pValue = &tchgsubops.bEnable;

    //  /disable option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_DISABLE ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_DISABLE ].dwType       = CP_TYPE_BOOLEAN;
    cmdChangeOptions[ OI_CHANGE_DISABLE ].pwszOptions  = szChangeStatusOff;
    cmdChangeOptions[ OI_CHANGE_DISABLE ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_DISABLE ].pValue = &tchgsubops.bDisable;

    //  /z option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_DELNOSCHED ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_DELNOSCHED ].dwType       = CP_TYPE_BOOLEAN;
    cmdChangeOptions[ OI_CHANGE_DELNOSCHED ].pwszOptions  = szChangeDelIfNotSchedOpt;
    cmdChangeOptions[ OI_CHANGE_DELNOSCHED ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_DELNOSCHED ].pValue = &tchgsubops.bDelIfNotSched;

    //  /ri option
    StringCopyA( cmdChangeOptions[ OI_CHANGE_REPEAT_INTERVAL ].szSignature, "PARSER2\0", 8 );
    cmdChangeOptions[ OI_CHANGE_REPEAT_INTERVAL ].dwType       = CP_TYPE_TEXT;
    cmdChangeOptions[ OI_CHANGE_REPEAT_INTERVAL ].pwszOptions  = szChangeRepeatIntervalOpt;
    cmdChangeOptions[ OI_CHANGE_REPEAT_INTERVAL ].dwCount = 1;
    cmdChangeOptions[ OI_CHANGE_REPEAT_INTERVAL ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdChangeOptions[ OI_CHANGE_REPEAT_INTERVAL ].pValue = tchgsubops.szRepeat;
    cmdChangeOptions[ OI_CHANGE_REPEAT_INTERVAL ].dwLength = MAX_STRING_LENGTH;

    //parse command line arguments
    bReturn = DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdChangeOptions), cmdChangeOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // get the buffer pointers allocated by command line parser
    tchgsubops.szServer = (LPWSTR)cmdChangeOptions[ OI_CHANGE_SERVER ].pValue;
    tchgsubops.szUserName = (LPWSTR)cmdChangeOptions[ OI_CHANGE_USERNAME ].pValue;
    tchgsubops.szPassword = (LPWSTR)cmdChangeOptions[ OI_CHANGE_PASSWORD ].pValue;
    tchgsubops.szRunAsUserName = (LPWSTR)cmdChangeOptions[ OI_CHANGE_RUNASUSER ].pValue;
    tchgsubops.szRunAsPassword = (LPWSTR)cmdChangeOptions[ OI_CHANGE_RUNASPASSWORD ].pValue;

    // process the options for -change option
    if( EXIT_FAILURE == ValidateChangeOptions ( argc, cmdChangeOptions, tchgsubops, tchgoptvals ) )
    {
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }

    // Displaying change usage if user specified -? with -change option
    if( tchgsubops.bUsage == TRUE )
    {
        DisplayChangeUsage();
        //release memory
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_SUCCESS;
    }

    // check whether server (-s) and username (-u) only specified along with the command or not
    if( ( IsLocalSystem( tchgsubops.szServer ) == FALSE ) || ( cmdChangeOptions[OI_CHANGE_USERNAME].dwActuals == 1 ) )
    {
        // Establish the connection on a remote machine
        bResult = EstablishConnection(tchgsubops.szServer,tchgsubops.szUserName,GetBufferSize(tchgsubops.szUserName)/sizeof(WCHAR),tchgsubops.szPassword,GetBufferSize(tchgsubops.szPassword)/sizeof(WCHAR), tchgoptvals.bNeedPassword );
        if (bResult == FALSE)
        {
            // displays the appropriate error message
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR| SLE_INTERNAL );
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                    bCloseConnection = FALSE;
                    break;

            // check for mismatched credentials
            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowLastErrorEx ( stderr, SLE_TYPE_ERROR| SLE_INTERNAL );
                    ReleaseChangeMemory(&tchgsubops);
                    return EXIT_FAILURE;
                }
              default :
                 bCloseConnection = TRUE;
            }
        }

        //release memory for password
        FreeMemory((LPVOID*) &tchgsubops.szPassword);
    }

    // Get the task Scheduler object for the system.
    pITaskScheduler = GetTaskScheduler( tchgsubops.szServer );

    // If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {
        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }

    // Validate the Given Task and get as TARRAY in case of taskname
    arrJobs = ValidateAndGetTasks( pITaskScheduler, tchgsubops.szTaskName);
    if( arrJobs == NULL )
    {
        StringCchPrintf( szMessage , SIZE_OF_ARRAY(szMessage), GetResString(IDS_TASKNAME_NOTEXIST), _X( tchgsubops.szTaskName ));
        ShowMessage(stderr, szMessage );

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;

    }

    // check whether the group policy prevented user from changing the 
    // properties of a task or not.
    if ( FALSE == GetGroupPolicy( tchgsubops.szServer, tchgsubops.szUserName, TS_KEYPOLICY_DENY_PROPERTIES, &dwPolicy ) )
    {
        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }
    
    if ( dwPolicy > 0 )
    {
        ShowMessage ( stdout, GetResString (IDS_PREVENT_CHANGE));
        
        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_SUCCESS;
    }

    IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;
    ITaskTrigger *pITaskTrig = NULL;
    WORD wTrigNumber = 0;

    TASK_TRIGGER TaskTrig;
    SecureZeroMemory(&TaskTrig, sizeof (TASK_TRIGGER));
    TaskTrig.cbTriggerSize = sizeof (TASK_TRIGGER);
    TaskTrig.Reserved1 = 0; // reserved field and must be set to 0.
    TaskTrig.Reserved2 = 0; // reserved field and must be set to 0.

    //sub-variabes
    WORD  wStartDay     = 0;
    WORD  wStartMonth   = 0;
    WORD  wStartYear    = 0;
    WORD  wStartHour    = 0;
    WORD  wStartMin     = 0;
    WORD  wEndHour      = 0;
    WORD  wEndMin       = 0;
    WORD  wEndDay       = 0;
    WORD  wEndYear      = 0;
    WORD  wEndMonth     = 0;


    StringConcat ( tchgsubops.szTaskName, JOB, SIZE_OF_ARRAY(tchgsubops.szTaskName) );

    // returns an pITask inteface for szTaskName
    hr = pITaskScheduler->Activate(tchgsubops.szTaskName,IID_ITask,
                                       (IUnknown**) &pITask);

    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);

        ReleaseChangeMemory(&tchgsubops);

        return EXIT_FAILURE;
    }

    //if the user name is not specifed set the current logged on user settings
    DWORD dwTaskFlags = 0;
    BOOL  bFlag = FALSE;
    //WCHAR szBuffer[2 * MAX_STRING_LENGTH] = L"\0";
    WCHAR szRunAsUser[MAX_STRING_LENGTH];
    WCHAR* szValues[2] = {NULL};//To pass to FormatMessage() API

    StringCopy ( szRunAsUser, L"", SIZE_OF_ARRAY(szRunAsUser));

    if ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 )
    {
            wszUserName = tchgsubops.szRunAsUserName;
            bUserName = TRUE;
    }
    else
    {
        // get the run as user name for a specified scheduled task
        hr = GetRunAsUser(pITask, szRunAsUser);
        if (FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            ReleaseChangeMemory(&tchgsubops);

            return EXIT_FAILURE;
        }
    }

    // System account is not applicable with /IT option
    if ( (StringLength (szRunAsUser, 0) == 0) && (tchgsubops.bInteractive == TRUE ) &&
                        ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 0 ))
    {
        ShowMessage ( stderr, GetResString (IDS_IT_NO_SYSTEM) );

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        ReleaseChangeMemory(&tchgsubops);

        return EXIT_FAILURE;
    }

    //check whether /TR option is specified or not
    if( cmdChangeOptions[OI_CHANGE_TASKRUN].dwActuals == 1 )
    {
        // check for .exe substring string in the given task to run string

        wchar_t wcszParam[MAX_RES_STRING] = L"\0";

        DWORD dwProcessCode = 0 ;
        dwProcessCode = ProcessFilePath(tchgsubops.szTaskRun,wszApplName,wcszParam);

        if(dwProcessCode == EXIT_FAILURE)
        {
            if( pIPF )
                pIPF->Release();

            if( pITask )
                pITask->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);

            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;

        }


        // Set command name with ITask::SetApplicationName
        hr = pITask->SetApplicationName(wszApplName);
        if (FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            if( pIPF )
                pIPF->Release();

            if( pITask )
                pITask->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }


        //[Working directory =  exe pathname - exe name]
        wchar_t* wcszStartIn = wcsrchr(wszApplName,_T('\\'));
        if(wcszStartIn != NULL)
            *( wcszStartIn ) = _T('\0');

        // set the working directory of command
        hr = pITask->SetWorkingDirectory(wszApplName);

        if (FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            if( pIPF )
                pIPF->Release();

            if( pITask )
                pITask->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }

        // set the command line parameters for the task
        hr = pITask->SetParameters(wcszParam);
        if (FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            if( pIPF )
            {
                pIPF->Release();
            }

            if( pITask )
            {
                pITask->Release();
            }

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }
    }

    // get the flags
    hr = pITask->GetFlags(&dwTaskFlags);
    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }
    
    // set flag to run the task interactively
    if ( TRUE == tchgsubops.bInteractive )
    {
        dwTaskFlags |= TASK_FLAG_RUN_ONLY_IF_LOGGED_ON;
    }

    // remove the .job extension from the taskname
    if ( ParseTaskName( tchgsubops.szTaskName ) )
    {
        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }
    
    // if /enable is specified
    if ( TRUE == tchgsubops.bEnable )
    {
        // check if task has already been enabled or not
        if ( !((dwTaskFlags & TASK_FLAG_DISABLED) == TASK_FLAG_DISABLED ) )
        {
            StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_ALREADY_ENABLED), _X(tchgsubops.szTaskName));
            // display message as .. task has already been enabled
            ShowMessage ( stdout, _X(szMessage));

            // if /Enable optional parameter is only specified to change..if the specified
            // task has already been enabled.. then return with success
            if( TRUE == tchgoptvals.bFlag )
            {
                if( pIPF )
                    pIPF->Release();

                if( pITask )
                    pITask->Release();

                // close the connection that was established by the utility
                if ( bCloseConnection == TRUE )
                    CloseConnection( tchgsubops.szServer );

                Cleanup(pITaskScheduler);
                ReleaseChangeMemory(&tchgsubops);
                return EXIT_SUCCESS;
            }
        }
        else
        {
            dwTaskFlags &= ~(TASK_FLAG_DISABLED);
        }
    }
    else if (TRUE == tchgsubops.bDisable ) // if /disable is specified
    {
        // check if task is already been disabled or not
        if ( (dwTaskFlags & TASK_FLAG_DISABLED) == TASK_FLAG_DISABLED )
        {
            StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_ALREADY_DISABLED), _X(tchgsubops.szTaskName));
            // display message as .. task has already been disabled
            ShowMessage ( stdout, _X(szMessage));

            // if /Disable optional parameter is only specified to change..if the specified
            // task has already been disabled.. then return with success
            if( TRUE == tchgoptvals.bFlag )
            {
                if( pIPF )
                    pIPF->Release();

                if( pITask )
                    pITask->Release();

                // close the connection that was established by the utility
                if ( bCloseConnection == TRUE )
                    CloseConnection( tchgsubops.szServer );

                Cleanup(pITaskScheduler);
                ReleaseChangeMemory(&tchgsubops);
                return EXIT_SUCCESS;
            }
        }
        else
        {
            dwTaskFlags |= TASK_FLAG_DISABLED;
        }
    }

    // if /n is specified .. enables the falg to delete the task if not scheduled to
    // run again...
    if ( TRUE ==  tchgsubops.bDelIfNotSched)
    {
        dwTaskFlags |= TASK_FLAG_DELETE_WHEN_DONE;
    }

    // set the flags
    hr = pITask->SetFlags(dwTaskFlags);
    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }

   
    if ( bSystemStatus == TRUE )
    {
        //szValues[0] = (WCHAR*) (tchgsubops.szTaskName);

        StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_NTAUTH_SYSTEM_CHANGE_INFO), _X(tchgsubops.szTaskName));
        ShowMessage ( stdout, _X(szMessage));

    }

    if( (cmdChangeOptions[OI_CHANGE_RUNASPASSWORD].dwActuals == 1) && ( bSystemStatus == TRUE ) &&
            (StringLength( tchgsubops.szRunAsPassword, 0 ) != 0) )
    {
        ShowMessage( stdout, GetResString( IDS_PASSWORD_NOEFFECT ) );
    }

    //get the trigger for the corresponding task
    hr = pITask->GetTrigger(wTrigNumber, &pITaskTrig);
    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();

        if( pITaskTrig )
            pITaskTrig->Release();
        

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }


    //Get the current task trigger
    hr = pITaskTrig->GetTrigger(&TaskTrig);
    if (hr != S_OK)
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();

        if( pITaskTrig )
            pITaskTrig->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }
   
    //sub-variables
    DWORD dwRepeat = 0;
    DWORD dwEndTimeInMin = 0;
    DWORD dwStartTimeInMin = 0;
    DWORD dwDuration = 0;
    DWORD dwModifierVal = 0;
    LPWSTR  pszStopString = NULL;

    // check whether /SD o /ED is specified for the scheduled type ONETIME
    if( ( TaskTrig.TriggerType == TASK_TIME_TRIGGER_ONCE) && (( cmdChangeOptions[OI_CHANGE_STARTDATE].dwActuals == 1 ) || 
        ( cmdChangeOptions[OI_CHANGE_ENDDATE].dwActuals == 1 )  ) )
    {
        // display an error message as.. /SD or /ED is not allowed for ONCE
        ShowMessage(stderr, GetResString(IDS_CHANGE_ONCE_NA));
        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();
        
        if( pITaskTrig )
                pITaskTrig->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }
    
    //check whether either /Rt or /Et or /Ri or /Du is specified for the existing scheduled types
    // onstart, onlogon and onstart..
    if ( ( ( cmdChangeOptions[OI_CHANGE_REPEAT_INTERVAL].dwActuals == 1) || 
          ( cmdChangeOptions[OI_CHANGE_DURATION].dwActuals == 1) || ( cmdChangeOptions[OI_CHANGE_ENDTIME].dwActuals == 1) ||
        ( cmdChangeOptions[OI_CHANGE_ENDDATE].dwActuals == 1) || ( cmdChangeOptions[OI_CHANGE_STARTTIME].dwActuals == 1) ||
        ( cmdChangeOptions[OI_CHANGE_STARTDATE].dwActuals == 1) || ( cmdChangeOptions[OI_CHANGE_DUR_END].dwActuals == 1) ) && 
        ( (TaskTrig.TriggerType == TASK_EVENT_TRIGGER_ON_IDLE) || 
         (TaskTrig.TriggerType == TASK_EVENT_TRIGGER_AT_SYSTEMSTART ) || ( TaskTrig.TriggerType == TASK_EVENT_TRIGGER_AT_LOGON ) ) )
    {
        
        ShowMessage (stderr, GetResString (IDS_SCTYPE_NA) );

        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();
        
        if( pITaskTrig )
                pITaskTrig->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;

    }

    //If either /DU or /ET is specified and /RI is not specified..
    // then set dwRepeat-> actual repetition value 
    if( (cmdChangeOptions[OI_CHANGE_REPEAT_INTERVAL].dwActuals == 0) && 
        ( (cmdChangeOptions[OI_CHANGE_DURATION].dwActuals == 1) ||
        (cmdChangeOptions[OI_CHANGE_ENDTIME].dwActuals == 1) ) )   
    {
        if ( 0 != TaskTrig.MinutesInterval )
        {
            dwRepeat = TaskTrig.MinutesInterval;
        }
        else
        {
            //repetition interval defaults to 10 minutes
            dwRepeat = 10;
        }
    }
    
    //If either /DU or /ET is not specified and /RI is specified..
    // then set dwDuration-> actual duration value 
    if( ( cmdChangeOptions[OI_CHANGE_DURATION].dwActuals == 0 ) && ( cmdChangeOptions[OI_CHANGE_ENDTIME].dwActuals == 0 ) &&
        (cmdChangeOptions[OI_CHANGE_REPEAT_INTERVAL].dwActuals == 1) ) 
    {
        if ( 0 != TaskTrig.MinutesDuration )
        {
            dwDuration = TaskTrig.MinutesDuration;
        }
        else
        {
            //duration defaults to 10 minutes
            dwDuration = 60;
        }
    }

    
    if( cmdChangeOptions[OI_CHANGE_REPEAT_INTERVAL].dwActuals == 1)
    {
        // get the repetition value
        dwRepeat =  wcstol(tchgsubops.szRepeat, &pszStopString, BASE_TEN);
        
        if ((errno == ERANGE) ||
            ((pszStopString != NULL) && (StringLength (pszStopString, 0) != 0) ) ||
            ( (dwRepeat < MIN_REPETITION_INTERVAL ) || ( dwRepeat > MAX_REPETITION_INTERVAL) ) )
        {
            // display an error message as .. invalid value specified for /RT
            ShowMessage ( stderr, GetResString (IDS_INVALID_RT_VALUE) );
            
            if(pIPF)
            pIPF->Release();

            if(pITask)
                pITask->Release();

            if( pITaskTrig )
                pITaskTrig->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }

        //check whether the specified repetition interval is greater than 9999..
        // if so, set the maximum repetition interval as 9999.
        if ( (dwRepeat > 9999) && ( (dwRepeat % 60) !=  0) )
        {
            //display some warning message as.. max value (less than the specified interval)
            // divisible by 60.
            ShowMessage ( stderr, GetResString (IDS_WARN_VALUE) );
            dwRepeat -= (dwRepeat % 60);
        }
    }


    // if the start time is specified..set the specified values to the current trigger 
    if (cmdChangeOptions[ OI_CHANGE_STARTTIME ].dwActuals == 1)
    {
        // get the Start time in terms of hours, minutes and seconds
        GetTimeFieldEntities(tchgsubops.szStartTime, &wStartHour, &wStartMin );

        // set the start time
        TaskTrig.wStartHour = wStartHour;
        TaskTrig.wStartMinute = wStartMin;
    }
    else
    {
        // get the values for start time
        wStartHour = TaskTrig.wStartHour;
        wStartMin = TaskTrig.wStartMinute;
    }

    //check whether /ET is specified or not 
    if (cmdChangeOptions[OI_CHANGE_ENDTIME].dwActuals == 1)
    {
        // get the Start time in terms of hours, minutes and seconds
        GetTimeFieldEntities(tchgsubops.szEndTime, &wEndHour, &wEndMin );
        
        // calculate start time in minutes
        dwStartTimeInMin = (DWORD) ( wStartHour * MINUTES_PER_HOUR * SECS_PER_MINUTE + wStartMin * SECS_PER_MINUTE )/ SECS_PER_MINUTE ;

        // calculate end time in minutes
        dwEndTimeInMin = (DWORD) ( wEndHour * MINUTES_PER_HOUR * SECS_PER_MINUTE + wEndMin * SECS_PER_MINUTE ) / SECS_PER_MINUTE ;

        // check whether end time is later than start time
        if ( dwEndTimeInMin >= dwStartTimeInMin )
        {
            // if the end and start time in the same day..
            // get the duration between end and start time (in minutes)
            dwDuration = dwEndTimeInMin - dwStartTimeInMin ;
        }
        else
        {
            // if the start and end time not in the same day..
            // get the duration between start and end time (in minutes)
            // and subtract that duration by 1440(max value in minutes)..
            dwDuration = 1440 - (dwStartTimeInMin - dwEndTimeInMin ) ;
        }

        dwModifierVal = TaskTrig.MinutesInterval ;

        //check whether The duration is greater than the repetition interval or not.
        if ( dwDuration <= dwModifierVal || dwDuration <= dwRepeat)
        {
            ShowMessage ( stderr, GetResString (IDS_INVALID_DURATION1) );
            
            if(pIPF)
            pIPF->Release();

            if(pITask)
                pITask->Release();

            if( pITaskTrig )
                pITaskTrig->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }
    }
    else if(cmdChangeOptions[OI_CHANGE_DURATION].dwActuals == 1)
    {
        //sub-variables
        WCHAR tHours[MAX_RES_STRING];
        WCHAR tMins[MAX_RES_STRING];
        DWORD  dwDurationHours = 0;
        DWORD  dwDurationMin = 0;

        //initialize the variables
        SecureZeroMemory (tHours, SIZE_OF_ARRAY(tHours));
        SecureZeroMemory (tMins, SIZE_OF_ARRAY(tMins));

        if ( ( StringLength (tchgsubops.szDuration, 0) != 7 ) || (tchgsubops.szDuration[4] != TIME_SEPARATOR_CHAR) )
        {
            ShowMessage ( stderr, GetResString (IDS_INVALIDDURATION_FORMAT) );
            
            if(pIPF)
                pIPF->Release();

            if(pITask)
                pITask->Release();

            if( pITaskTrig )
                pITaskTrig->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }

        StringCopy(tHours, wcstok(tchgsubops.szDuration,TIME_SEPARATOR_STR), SIZE_OF_ARRAY(tHours)); // Get the Hours field.
        if(StringLength(tHours, 0) > 0)
        {
            StringCopy(tMins, wcstok(NULL,TIME_SEPARATOR_STR), SIZE_OF_ARRAY(tMins)); // Get the Minutes field.
        }

        dwDurationHours =  wcstol(tHours, &pszStopString, BASE_TEN);
        if ((errno == ERANGE) ||
            ((pszStopString != NULL) && (StringLength (pszStopString, 0) != 0) ) )
        {
            ShowMessage ( stderr, GetResString (IDS_INVALID_DU_VALUE) );

            if(pIPF)
                pIPF->Release();

            if(pITask)
                pITask->Release();

            if( pITaskTrig )
                pITaskTrig->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }

        dwDurationHours = dwDurationHours * MINUTES_PER_HOUR;

        dwDurationMin =  wcstol(tMins, &pszStopString, BASE_TEN);
        if ((errno == ERANGE) ||
            ((pszStopString != NULL) && (StringLength (pszStopString, 0) != 0) ) )
        {
            ShowMessage ( stderr, GetResString (IDS_INVALID_DU_VALUE) );
            
            if(pIPF)
                pIPF->Release();

            if(pITask)
                pITask->Release();

            if( pITaskTrig )
                pITaskTrig->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }

        // sum the hours and minutes into minutes
        dwDuration = dwDurationHours + dwDurationMin ;

        dwModifierVal = TaskTrig.MinutesInterval ;

        //check whether The duration is greater than the repetition interval or not.
        if ( dwDuration <= dwModifierVal || dwDuration <= dwRepeat)
        {
            ShowMessage ( stderr, GetResString (IDS_INVALID_DURATION2) );
            
            if(pIPF)
                pIPF->Release();

            if(pITask)
                pITask->Release();

            if( pITaskTrig )
                pITaskTrig->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }
    }
    

    // set the repetition interval and duration values
    {
        // if repetition interval is not 0.. then set actual value of /RI
        if ( 0 != dwRepeat )
        {
            // set the MinutesInterval
            TaskTrig.MinutesInterval = dwRepeat;
        }

        // if duration is not 0.. set the actual value of /DU 
        if ( 0 != dwDuration )
        {
            // set the duration value
            TaskTrig.MinutesDuration = dwDuration ;
        }
    }

    //check whether The duration is greater than the repetition interval or not.
    if ( (0 != dwRepeat) && ( dwDuration <= dwRepeat ) )
    {
        ShowMessage ( stderr, GetResString (IDS_INVALID_DURATION2) );
        
        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();

        if( pITaskTrig )
            pITaskTrig->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }

    // if the start date is specified..set the specified values to the current trigger 
    if (cmdChangeOptions[OI_CHANGE_STARTDATE].dwActuals == 1)
    {
        // get the Start date in terms of day, month and year
        GetDateFieldEntities(tchgsubops.szStartDate, &wStartDay, &wStartMonth, &wStartYear);

        // set the start time
        TaskTrig.wBeginDay = wStartDay;
        TaskTrig.wBeginMonth = wStartMonth;
        TaskTrig.wBeginYear = wStartYear;
    }
    else
    {
        // get the esisting start time
        wStartDay = TaskTrig.wBeginDay  ;
        wStartMonth = TaskTrig.wBeginMonth ;
        wStartYear = TaskTrig.wBeginYear ;
    }

    
    //check whether /K is specified or not
    if ( TRUE == tchgsubops.bIsDurEnd )
    {
          // set the flag to terminate the task at the end of lifetime.
          TaskTrig.rgFlags |= TASK_TRIGGER_FLAG_KILL_AT_DURATION_END ;
    }
    
    // if the start time is specified..set the specified values to the current trigger  
    if (cmdChangeOptions[OI_CHANGE_ENDDATE].dwActuals == 1)
    {
        // Now set the end date entities.
        GetDateFieldEntities(tchgsubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);

        // Make end date valid; otherwise the enddate parameter is ignored.
        TaskTrig.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
        
        TaskTrig.wEndDay = wEndDay;
        TaskTrig.wEndMonth = wEndMonth;
        TaskTrig.wEndYear = wEndYear;
    }
    else
    {
        // get the esisting end date
        wEndDay = TaskTrig.wEndDay ;
        wEndMonth = TaskTrig.wEndMonth ;
        wEndYear = TaskTrig.wEndYear ;
    }

    if ( (0 != wStartYear) && (0 != wEndYear) )
    {
        //check whether end date is earlier than start date or not
        if( ( wEndYear == wStartYear ) )
        {
            // For same years if the end month is less than start month or for same years and same months
            // if the endday is less than the startday.
            if ( ( wEndMonth < wStartMonth ) || ( ( wEndMonth == wStartMonth ) && ( wEndDay < wStartDay ) ) )
            {
                ShowMessage(stderr, GetResString(IDS_ENDATE_INVALID));
                return RETVAL_FAIL;
            }
        }
        else if ( wEndYear < wStartYear )
        {
            ShowMessage(stderr, GetResString(IDS_ENDATE_INVALID));
            return RETVAL_FAIL;

        }
    }

    // set the task trigger
    hr = pITaskTrig->SetTrigger(&TaskTrig);
    if (hr != S_OK)
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();

        if( pITaskTrig )
            pITaskTrig->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }

    /////////////////////////////////////////
    //check for user creentials
    ////////////////////////////////////////

    // Check whether /ru "" or "System" or "Nt Authority\System" for system account
    if ( ( ((tchgsubops.bInteractive == TRUE ) && (StringLength (szRunAsUser, 0) == 0)) || (cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) ) &&
        ( (StringLength( tchgsubops.szRunAsUserName, 0) == 0) || ( StringCompare(tchgsubops.szRunAsUserName, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) ||
        (StringCompare(tchgsubops.szRunAsUserName, SYSTEM_USER, TRUE, 0 ) == 0 ) ) )
    {
        bSystemStatus = TRUE;
        bFlag = TRUE;
    }
    else if ( FAILED (hr) )
    {
        bFlag = TRUE;
    }

    // flag to check whether run as user name is "NT AUTHORITY\SYSTEM" or not
    if ( bFlag == FALSE )
    {
        // check for "NT AUTHORITY\SYSTEM" username
        if( ( ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) && ( StringLength( tchgsubops.szRunAsUserName, 0) == 0 ) ) ||
        ( ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) && ( StringLength( tchgsubops.szRunAsUserName, 0) == 0 ) && ( StringLength(tchgsubops.szRunAsPassword, 0 ) == 0 ) ) ||
        ( ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) && ( StringCompare(tchgsubops.szRunAsUserName, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) && ( StringLength(tchgsubops.szRunAsPassword, 0 ) == 0 )) ||
        ( ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) && ( StringCompare(tchgsubops.szRunAsUserName, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) ) ||
        ( ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) && ( StringCompare(tchgsubops.szRunAsUserName, SYSTEM_USER, TRUE, 0) == 0 ) && ( StringLength(tchgsubops.szRunAsPassword, 0 ) == 0 ) ) ||
        ( ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) && ( StringCompare(tchgsubops.szRunAsUserName, SYSTEM_USER, TRUE, 0 ) == 0 ) ) )
        {
            bSystemStatus = TRUE;
        }
    }

    if ( bSystemStatus == FALSE )
    {
        //check the length of run as user name
        if ( (StringLength( tchgsubops.szRunAsUserName, 0 ) != 0 ))
        {
            wszUserName = tchgsubops.szRunAsUserName;
        }
        else if (( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 0 ))
        {
            wszUserName = szRunAsUser;
            bUserName = TRUE;
        }
        else
        {
            bUserName = FALSE;
        }

        //check for the null password
        if ( ( StringLength( tchgsubops.szRunAsPassword, 0 ) != 0 ) && ( StringCompare ( tchgsubops.szRunAsPassword, ASTERIX, TRUE, 0) != 0 ) )
        {
            wszPassword = tchgsubops.szRunAsPassword;

            bPassWord = TRUE;
        }
        else
        {
            // check whether -rp is specified or not
            if (cmdChangeOptions[OI_CHANGE_RUNASPASSWORD].dwActuals == 1)
            {
                if( ( StringCompare( tchgsubops.szRunAsPassword , L"\0", TRUE, 0 ) != 0 ) && ( StringCompare ( tchgsubops.szRunAsPassword, ASTERIX, TRUE, 0) != 0 ) )
                {
                    bPassWord = TRUE;
                }
                else if ( ( bSystemStatus == FALSE ) && ( StringLength (tchgsubops.szRunAsPassword, 0) == 0 ) )
                {
                    ShowMessage (stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                }
                else if ( StringCompare ( tchgsubops.szRunAsPassword, ASTERIX, TRUE, 0) == 0 )
                {
                    bPassWord = FALSE;
                }
            }
            else if ( bSystemStatus == FALSE )
            {
                bPassWord = FALSE;
            }

        }
    }

    // check for the status of username and password
    if( ( bUserName == TRUE ) && ( bPassWord == FALSE ) )
    {
            szValues[0] = (WCHAR*) (wszUserName);

            ShowMessageEx ( stderr, 1, FALSE, GetResString(IDS_PROMPT_CHGPASSWD), _X(wszUserName));

            // Get the password from the command line
            if (GetPassword( tchgsubops.szRunAsPassword, GetBufferSize(tchgsubops.szRunAsPassword)/sizeof(WCHAR) ) == FALSE )
            {
                // close the connection that was established by the utility
                if ( bCloseConnection == TRUE )
                {
                    CloseConnection( tchgsubops.szServer );
                }

                ReleaseChangeMemory(&tchgsubops);

                return EXIT_FAILURE;
            }


            //check for the null password
            if( StringCompare( tchgsubops.szRunAsPassword , L"\0", TRUE, 0 ) == 0 )
            {
                ShowMessage (stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
            }

            // check for the password length > 0
            wszPassword = tchgsubops.szRunAsPassword;
    }
    // check for the status of user name and password
    else if( ( bUserName == FALSE ) && ( bPassWord == TRUE ) )
    {
           if ( (bFlag == TRUE ) && ( bSystemStatus == FALSE ) )
            {
                ShowMessage(stdout, GetResString(IDS_PROMPT_USERNAME));

                if ( GetTheUserName( tchgsubops.szRunAsUserName, GetBufferSize(tchgsubops.szRunAsUserName)/sizeof(WCHAR)) == FALSE )
                {
                    ShowMessage(stderr, GetResString( IDS_FAILED_TOGET_USER ) );
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                        CloseConnection( tchgsubops.szServer );

                    ReleaseChangeMemory(&tchgsubops);

                    return EXIT_FAILURE;
                }

                // check for the length of username
                if( StringLength(tchgsubops.szRunAsUserName, 0) > MAX_RES_STRING )
                {
                    ShowMessage(stderr,GetResString(IDS_INVALID_UNAME  ));
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                        CloseConnection( tchgsubops.szServer );

                    ReleaseChangeMemory(&tchgsubops);

                    return EXIT_FAILURE;
                }

                if ( (StringLength( tchgsubops.szRunAsUserName, 0) == 0) || ( StringCompare(tchgsubops.szRunAsUserName, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) ||
                    (StringCompare(tchgsubops.szRunAsUserName, SYSTEM_USER, TRUE, 0 ) == 0 ) )
                {
                    bSystemStatus = TRUE;
                    bFlag = TRUE;
                }
                else
                {
                    // check for the length of run as user name
                    if(StringLength(tchgsubops.szRunAsUserName, 0))
                    {
                        wszUserName = tchgsubops.szRunAsUserName;
                    }
                }

            }
            else
            {
                  wszUserName = szRunAsUser;
            }

            // check for the length of password > 0
            wszPassword = tchgsubops.szRunAsPassword;

    }
    // check for the user name and password are not specified
    else if( ( bUserName == FALSE ) && ( bPassWord == FALSE ) )
    {
            if ( (bFlag == TRUE ) && ( bSystemStatus == FALSE ) )
            {
                ShowMessage(stdout, GetResString(IDS_PROMPT_USERNAME));

                if ( GetTheUserName( tchgsubops.szRunAsUserName, GetBufferSize(tchgsubops.szRunAsUserName)/sizeof(WCHAR) ) == FALSE )
                {
                    ShowMessage(stderr, GetResString( IDS_FAILED_TOGET_USER ) );
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                        CloseConnection( tchgsubops.szServer );

                    ReleaseChangeMemory(&tchgsubops);

                    return EXIT_FAILURE;
                }

                // check for the length of username
                if( StringLength(tchgsubops.szRunAsUserName, 0) > MAX_RES_STRING )
                {
                    ShowMessage(stderr,GetResString(IDS_INVALID_UNAME  ));
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                        CloseConnection( tchgsubops.szServer );

                    ReleaseChangeMemory(&tchgsubops);

                    return EXIT_FAILURE;
                }

                if ( (StringLength( tchgsubops.szRunAsUserName, 0) == 0) || ( StringCompare(tchgsubops.szRunAsUserName, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) ||
                    (StringCompare(tchgsubops.szRunAsUserName, SYSTEM_USER, TRUE, 0 ) == 0 ) )
                {
                    bSystemStatus = TRUE;
                    bFlag = TRUE;
                }
                else
                {
                    if(StringLength(tchgsubops.szRunAsUserName, 0))
                    {
                         wszUserName = tchgsubops.szRunAsUserName;
                    }
                }

            }
            else
            {
                  wszUserName = szRunAsUser;
            }

            if ( StringLength ( wszUserName, 0 ) != 0 )
            {
                szValues[0] = (WCHAR*) (wszUserName);


                ShowMessageEx ( stderr, 1, FALSE, GetResString(IDS_PROMPT_CHGPASSWD), _X(wszUserName));

                // Get the run as user password from the command line
                if ( GetPassword( tchgsubops.szRunAsPassword, GetBufferSize(tchgsubops.szRunAsPassword)/sizeof(WCHAR) ) == FALSE )
                {
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                        CloseConnection( tchgsubops.szServer );

                    ReleaseChangeMemory(&tchgsubops);

                    return EXIT_FAILURE;
                }


                //check for the null password
                if( StringCompare( tchgsubops.szRunAsPassword , L"\0", TRUE, 0 ) == 0 )
                {
                    ShowMessage (stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                }

                wszPassword = tchgsubops.szRunAsPassword;
            }

    }

    //check for null password
    if ( NULL == wszPassword )
    {
        wszPassword = L"\0";
    }

    // Return a pointer to a specified interface on an object
    hr = pITask->QueryInterface(IID_IPersistFile, (void **) &pIPF);

    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);

        ReleaseChangeMemory(&tchgsubops);

        return EXIT_FAILURE;
    }

    //set account information..
    if( bSystemStatus == TRUE )
    {
        // Change the account information to "NT AUTHORITY\SYSTEM" user
        hr = pITask->SetAccountInformation(L"",NULL);
        if ( FAILED(hr) )
        {
            ShowMessage(stderr, GetResString(IDS_NTAUTH_SYSTEM_ERROR));

            if( pIPF )
                pIPF->Release();

            if( pITask )
                pITask->Release();

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tchgsubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseChangeMemory(&tchgsubops);
            return EXIT_FAILURE;
        }
    }
    else
    {
        // set the account information with the user name and password
        hr = pITask->SetAccountInformation(wszUserName,wszPassword);
    }

    if ((FAILED(hr)) && (hr != SCHED_E_NO_SECURITY_SERVICES))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }

    ////////////////////////////////////////
    ///  Save all the parameters
    ////////////////////////////////////////

    // save the copy of an object
    hr = pIPF->Save(NULL,TRUE);

    if( E_FAIL == hr )
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();

        if( pITaskTrig )
            pITaskTrig->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }

    if (FAILED (hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        if(pIPF)
            pIPF->Release();

        if(pITask)
            pITask->Release();

        if( pITaskTrig )
             pITaskTrig->Release();

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tchgsubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }
    else
    {
        // to display a success message
        //szValues[0] = (WCHAR*) (tchgsubops.szTaskName);

        StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_CHANGE_SUCCESSFUL), _X(tchgsubops.szTaskName));
        ShowMessage ( stdout, _X(szMessage));

    }

    if( pIPF )
        pIPF->Release();

    if( pITask )
        pITask->Release();

    if( pITaskTrig )
        pITaskTrig->Release();

    // close the connection that was established by the utility
    if ( bCloseConnection == TRUE )
        CloseConnection( tchgsubops.szServer );

    Cleanup(pITaskScheduler);
    ReleaseChangeMemory(&tchgsubops);

    return EXIT_SUCCESS;
}

/******************************************************************************
    Routine Description:

        This routine  displays the create option usage

    Arguments:

        None

    Return Value :
        DWORD
******************************************************************************/

DWORD
DisplayChangeUsage()
{
    WCHAR szTmpBuffer[ 2 * MAX_STRING_LENGTH];
    WCHAR szBuffer[ 2 * MAX_STRING_LENGTH];
    WCHAR szFormat[MAX_DATE_STR_LEN];

    // initialize to zero
    SecureZeroMemory ( szTmpBuffer, SIZE_OF_ARRAY(szTmpBuffer));
    SecureZeroMemory ( szBuffer, SIZE_OF_ARRAY(szBuffer));
    SecureZeroMemory ( szFormat, SIZE_OF_ARRAY(szFormat));

    // get the date format
    if ( GetDateFormatString( szFormat) )
    {
         return EXIT_FAILURE;
    }

    // Displaying Create usage
    for( DWORD dw = IDS_CHANGE_HLP1; dw <= IDS_CHANGE_HLP38; dw++ )
    {
        switch (dw)
        {

         case IDS_CHANGE_HLP30:

            StringCchPrintf ( szTmpBuffer, SIZE_OF_ARRAY(szTmpBuffer), GetResString(IDS_CHANGE_HLP30), _X(szFormat) );
            ShowMessage ( stdout, _X(szTmpBuffer) );
            dw = IDS_CHANGE_HLP30;
            break;

        case IDS_CHANGE_HLP31:

            StringCchPrintf ( szTmpBuffer, SIZE_OF_ARRAY(szTmpBuffer), GetResString(IDS_CHANGE_HLP31), _X(szFormat) );
            ShowMessage ( stdout, _X(szTmpBuffer) );
            dw = IDS_CHANGE_HLP31;
            break;

          default :
                ShowMessage(stdout, GetResString(dw));
                break;

        }

    }

    return EXIT_SUCCESS;
}

// ***************************************************************************
// Routine Description:
//
// Takes the user name from the keyboard.While entering the user name
//  it displays the user name as it is.
//
// Arguments:
//
// [in] pszUserName         -- String to store user name
// [in] dwMaxUserNameSize   -- Maximun size of the user name.
//
// Return Value:
//
// BOOL             --If this function succeds returns TRUE otherwise returns FALSE.
//
// ***************************************************************************
BOOL
GetTheUserName(
                IN LPWSTR pszUserName,
                IN DWORD dwMaxUserNameSize
                )
{
    // local variables
    WCHAR ch;
    DWORD dwIndex = 0;
    DWORD dwCharsRead = 0;
    DWORD dwCharsWritten = 0;
    DWORD dwPrevConsoleMode = 0;
    HANDLE hInputConsole = NULL;
    WCHAR szBuffer[ 10 ] = L"\0";
    BOOL  bFlag = TRUE;


    // check the input value
    if ( pszUserName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return FALSE;
    }

    // Get the handle for the standard input
    hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
    if ( hInputConsole == NULL )
    {
        // could not get the handle so return failure
        return FALSE;
    }

    // Get the current input mode of the input buffer
    GetConsoleMode( hInputConsole, &dwPrevConsoleMode );

    // Set the mode such that the control keys are processed by the system
    if ( SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) == 0 )
    {
        // could not set the mode, return failure
        return FALSE;
    }

    //  Read the characters until a carriage return is hit
    do
    {

        if ( ReadConsole( hInputConsole, &ch, 1, &dwCharsRead, NULL ) == 0 )
        {
            // Set the original console settings
            SetConsoleMode( hInputConsole, dwPrevConsoleMode );

            // return failure
            return FALSE;
        }

        // Check for carraige return
        if ( ch == CARRIAGE_RETURN )
        {
            ShowMessage(stdout, _T("\n"));
            bFlag = FALSE;
            // break from the loop
            break;
        }

            // Check id back space is hit
        if ( ch == BACK_SPACE )
        {
            if ( dwIndex != 0 )
            {
                // move the cursor one character back
                StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), _T( "%c" ), BACK_SPACE );
                WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                    &dwCharsWritten, NULL );

                // replace the existing character with space
                StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), _T( "%c" ), BLANK_CHAR );
                WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                    &dwCharsWritten, NULL );

                // now set the cursor at back position
                StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), _T( "%c" ), BACK_SPACE );
                WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                    &dwCharsWritten, NULL );

                // decrement the index
                dwIndex--;
            }

            // process the next character
            continue;
        }

        // if the max user name length has been reached then sound a beep
        if ( dwIndex == ( dwMaxUserNameSize - 1 ) )
        {
            WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), BEEP_SOUND, 1,
                &dwCharsRead, NULL );
        }
        else
        {
            // store the input character
            *( pszUserName + dwIndex ) = ch;

            // display asterix onto the console
            WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), ( pszUserName + dwIndex ) , 1,
                &dwCharsWritten, NULL );

            dwIndex++;

        }
    } while (TRUE == bFlag);

    // Add the NULL terminator
    *( pszUserName + dwIndex ) = L'\0';

    //  Return success
    return TRUE;
}


/******************************************************************************
    Routine Description:

        This routine parses and validates the options specified by the user & 
        determines the type of a scheduled task

    Arguments:

        [ in ]  argc           : The count of arguments given by the user.
        [ out ]  tchgsubops    : Structure containing Scheduled task's properties.
        [ out ]  tchgoptvals   : Structure containing optional properties to set for a
                                 scheduledtask      .
        [ out ] pdwRetScheType : pointer to the type of a schedule task
                                 [Daily,once,weekly etc].
        [ out ] pbUserStatus   : pointer to check whether the -ru is given in
                                 the command line or not.

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else EXIT_FAILURE
        on failure
******************************************************************************/

DWORD
ValidateChangeOptions(
                     IN DWORD argc,
                     OUT TCMDPARSER2 cmdChangeOptions[],
                     IN OUT TCHANGESUBOPTS &tchgsubops,
                     IN OUT TCHANGEOPVALS &tchgoptvals
                     )
{
    DWORD dwScheduleType = 0;

    // If -ru is not specified allocate the memory
    if ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 0 )
    {
        // password
        if ( tchgsubops.szRunAsUserName == NULL )
        {
            tchgsubops.szRunAsUserName = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tchgsubops.szRunAsUserName == NULL )
            {
                SaveLastError();
                return EXIT_FAILURE;
            }
        }

    }

    // If -rp is not specified allocate the memory
    if ( cmdChangeOptions[OI_CHANGE_RUNASPASSWORD].dwActuals == 0 )
    {
        // password
        if ( tchgsubops.szRunAsPassword == NULL )
        {
            tchgsubops.szRunAsPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tchgsubops.szRunAsPassword == NULL )
            {
                SaveLastError();
                return EXIT_FAILURE;
            }
        }

    }
    else
    {
        if ( cmdChangeOptions[ OI_CHANGE_RUNASPASSWORD ].pValue == NULL )
        {

            tchgsubops.szRunAsPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( NULL == tchgsubops.szRunAsPassword)
            {
                SaveLastError();
                return EXIT_FAILURE;
            }
            StringCopy( tchgsubops.szRunAsPassword, L"*", GetBufferSize(tchgsubops.szRunAsPassword)/sizeof(WCHAR));
        }
    }

    //check for /? (usage)
    if ( tchgsubops.bUsage  == TRUE )
    {
        if (argc > 3)
        {
            ShowMessage ( stderr, GetResString (IDS_ERROR_CHANGEPARAM) );
            return EXIT_FAILURE;
        }
        else if ( 3 == argc )
        {
            return EXIT_SUCCESS;
        }
    }

    //check whether any optional parameters are specified or not.
    if( ( 0 == cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_RUNASPASSWORD].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_TASKRUN].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_STARTTIME].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_STARTDATE].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_ENDDATE].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_IT].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_ENDTIME].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_DUR_END].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_DURATION].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_DELNOSCHED].dwActuals ) &&
        ( 0 == cmdChangeOptions[OI_CHANGE_REPEAT_INTERVAL].dwActuals ) )
    {
        if ( ( 0 == cmdChangeOptions[OI_CHANGE_ENABLE].dwActuals ) &&
            ( 0 == cmdChangeOptions[OI_CHANGE_DISABLE].dwActuals ) )
        {
            ShowMessage(stderr,GetResString(IDS_NO_CHANGE_OPTIONS));
            return EXIT_FAILURE;
        }
        else
        {
            tchgoptvals.bFlag = TRUE;
        }
    }


    // check whether -u or -ru options specified respectively with -p or -rp options or not
    if ( cmdChangeOptions[ OI_CHANGE_USERNAME ].dwActuals == 0 && cmdChangeOptions[ OI_CHANGE_PASSWORD ].dwActuals == 1 )
    {
        // invalid syntax
        ShowMessage(stderr, GetResString(IDS_CHPASSWORD_BUT_NOUSERNAME));
        return EXIT_FAILURE;         // indicate failure
    }


    // check for invalid user name
    if( ( cmdChangeOptions[OI_CHANGE_SERVER].dwActuals == 0 ) && ( cmdChangeOptions[OI_CHANGE_USERNAME].dwActuals == 1 )  )
    {
        ShowMessage(stderr, GetResString(IDS_CHANGE_USER_BUT_NOMACHINE));
        return EXIT_FAILURE;
    }

    
    // check for /IT switch is not applicable with "NT AUTHORITY\SYSTEM" account
    if ( ( cmdChangeOptions[OI_CHANGE_RUNASUSER].dwActuals == 1 ) && ( ( StringLength ( tchgsubops.szRunAsUserName, 0 ) == 0 ) ||
           ( StringCompare( tchgsubops.szRunAsUserName, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) ||
           ( StringCompare( tchgsubops.szRunAsUserName, SYSTEM_USER, TRUE, 0 ) == 0 ) ) &&
           ( TRUE == tchgsubops.bInteractive ) )
    {
        ShowMessage ( stderr, GetResString (IDS_IT_SWITCH_NA) );
        return EXIT_FAILURE;
    }

    // If -rp is not specified allocate the memory
    if ( cmdChangeOptions[OI_CHANGE_RUNASPASSWORD].dwActuals == 0 )
    {
        // password
        if ( tchgsubops.szRunAsPassword == NULL )
        {
            tchgsubops.szRunAsPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tchgsubops.szRunAsPassword == NULL )
            {
                SaveLastError();
                return EXIT_FAILURE;
            }
        }

    }

    //
    //check for INVALID SYNTAX
    //

    // check for invalid user name
    if( ( cmdChangeOptions[OI_CHANGE_SERVER].dwActuals == 0 ) && ( cmdChangeOptions[OI_CHANGE_USERNAME].dwActuals == 1 )  )
    {
        ShowMessage(stderr, GetResString(IDS_CHANGE_USER_BUT_NOMACHINE));
        //release memory
        ReleaseChangeMemory(&tchgsubops);
        return EXIT_FAILURE;
    }


    // check whether /ET and /DU specified.. 
    if( ( cmdChangeOptions[OI_CHANGE_DURATION].dwActuals == 1 ) && ( cmdChangeOptions[OI_CHANGE_ENDTIME].dwActuals == 1 )  )
    {
        // display an error message as.. /ET and /DU are mutual exclusive
        ShowMessage(stderr, GetResString(IDS_DURATION_NOT_ENDTIME));
        return EXIT_FAILURE;
    }

    if ( ( cmdChangeOptions[OI_CHANGE_DUR_END].dwActuals == 1 ) && 
        ( cmdChangeOptions[OI_CHANGE_DURATION].dwActuals == 0 ) && ( cmdChangeOptions[OI_CHANGE_ENDTIME].dwActuals == 0 ) )
    {
        ShowMessage(stderr, GetResString(IDS_NO_CHANGE_K_OR_RT));
        return EXIT_FAILURE;
    }

    // check whether /enable and /disable options are specified..
    if ( ( TRUE == tchgsubops.bEnable )&&  (TRUE == tchgsubops.bDisable ) )
    {
         // display an error message as.. /Enable and /Disable are mutual exclusive
        ShowMessage(stderr, GetResString(IDS_ENABLE_AND_DISABLE));
        return EXIT_FAILURE;
    }

    // Start validations for the sub-options
    if( EXIT_FAILURE == ValidateChangeSuboptVal(tchgsubops, tchgoptvals, cmdChangeOptions, dwScheduleType) )
    {
        return(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;

}


/******************************************************************************
    Routine Description:

        This routine validates the sub options specified by the user  reg.create option
        & determines the type of a scheduled task.

    Arguments:

        [ out ] tchgsubops     : Structure containing the task's properties
        [ out ] tchgoptvals    : Structure containing optional values to set
        [ in ] cmdOptions[]   : Array of type TCMDPARSER
        [ in ] dwScheduleType : Type of schedule[Daily,once,weekly etc]

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else EXIT_FAILURE
        on failure
******************************************************************************/

DWORD
ValidateChangeSuboptVal(
                  OUT TCHANGESUBOPTS& tchgsubops,
                  OUT TCHANGEOPVALS &tchgoptvals,
                  IN TCMDPARSER2 cmdOptions[],
                  IN DWORD dwScheduleType
                  )
{
    DWORD   dwRetval = RETVAL_SUCCESS;
    BOOL    bIsStDtCurDt = FALSE;

    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( tchgsubops.szServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( tchgsubops.szUserName == NULL )
        {
            tchgsubops.szUserName = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tchgsubops.szUserName == NULL )
            {
                SaveLastError();
                return EXIT_FAILURE;
            }
        }

        // password
        if ( tchgsubops.szPassword == NULL )
        {
            tchgoptvals.bNeedPassword = TRUE;
            tchgsubops.szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tchgsubops.szPassword == NULL )
            {
                SaveLastError();
                return EXIT_FAILURE;
            }
        }

        // case 1
        if ( cmdOptions[ OI_CHANGE_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ OI_CHANGE_PASSWORD ].pValue == NULL )
        {
            StringCopy( tchgsubops.szPassword, L"*", GetBufferSize(tchgsubops.szPassword)/sizeof(WCHAR));
        }

        // case 3
        else if ( StringCompareEx( tchgsubops.szPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&tchgsubops.szPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                return EXIT_FAILURE;
            }

            // ...
            tchgoptvals.bNeedPassword = TRUE;
        }
    }


    // validate start date
    if ( 1 == cmdOptions[OI_CHANGE_STARTDATE].dwActuals)
    {
        // Validate Start Date value.
        dwRetval = ValidateStartDate( tchgsubops.szStartDate, dwScheduleType,
                                          cmdOptions[OI_CHANGE_STARTDATE].dwActuals,
                                          bIsStDtCurDt);
        if(EXIT_FAILURE == dwRetval )
        {
            return dwRetval; // Error in Day/Month string.
        }
    }
    

    // validate end date
    if ( 1 == cmdOptions[OI_CHANGE_ENDDATE].dwActuals )
    {
        // Validate End Date value.
        dwRetval = ValidateEndDate( tchgsubops.szEndDate, dwScheduleType,
                                        cmdOptions[OI_CHANGE_ENDDATE].dwActuals);
        if(EXIT_FAILURE == dwRetval )
        {
            return dwRetval; // Error in Day/Month string.
        }
    }

    //Check Whether end date should be greater than startdate

    WORD wEndDay = 0;
    WORD wEndMonth = 0;
    WORD wEndYear = 0;
    WORD wStartDay = 0;
    WORD wStartMonth = 0;
    WORD wStartYear = 0;

    if( cmdOptions[OI_CHANGE_ENDDATE].dwActuals != 0 )
    {
        if( EXIT_FAILURE == GetDateFieldEntities( tchgsubops.szEndDate,&wEndDay,
                                                &wEndMonth,&wEndYear))
        {
            return EXIT_FAILURE;
        }
    }

    // get the date fields
    if( ( cmdOptions[OI_CHANGE_STARTDATE].dwActuals != 0 ) &&
        (EXIT_FAILURE == GetDateFieldEntities(tchgsubops.szStartDate,
                                                 &wStartDay,&wStartMonth,
                                                 &wStartYear)))
    {
        ShowMessage(stderr, GetResString(IDS_INVALID_STARTDATE) );
        return EXIT_FAILURE;
    }

    // validate date format
    if( (cmdOptions[OI_CHANGE_ENDDATE].dwActuals != 0) )
    {
        if( ( wEndYear == wStartYear ) )
        {
            // For same years if the end month is less than start month or for same years and same months
            // if the endday is less than the startday.
            if ( ( wEndMonth < wStartMonth ) || ( ( wEndMonth == wStartMonth ) && ( wEndDay < wStartDay ) ) )
            {
                ShowMessage(stderr, GetResString(IDS_ENDATE_INVALID));
                return EXIT_FAILURE;
            }


        }
        else if ( wEndYear < wStartYear )
        {
            ShowMessage(stderr, GetResString(IDS_ENDATE_INVALID));
            return EXIT_FAILURE;

        }
    }

    // validate start time format
    if (1 == cmdOptions[OI_CHANGE_STARTTIME].dwActuals)
    {
        // Validate Start Time value.
        dwRetval = ValidateTimeString(tchgsubops.szStartTime);

        if(EXIT_FAILURE == dwRetval)
        {
          // Error. Invalid date string.
          ShowMessage(stderr,GetResString(IDS_INVALIDFORMAT_STARTTIME));
          return dwRetval;
        }
    }
    

    // validate end time format
    if (1 == cmdOptions[OI_CHANGE_ENDTIME].dwActuals)
    {
        // Validate Start Time value.
        dwRetval = ValidateTimeString(tchgsubops.szEndTime);

        if(EXIT_FAILURE == dwRetval)
        {
          // Error. Invalid date string.
          ShowMessage(stderr,GetResString(IDS_INVALIDFORMAT_ENDTIME));
          return dwRetval;
        }
    }

    return RETVAL_SUCCESS;
}


/******************************************************************************
    Routine Description:

        Release memory

    Arguments:

        [ in ]  pParam           : cmdOptions structure

    Return Value :
         TRUE on success
******************************************************************************/
BOOL
ReleaseChangeMemory(
              IN PTCHANGESUBOPTS pParams
              )
{

    // release memory
    FreeMemory((LPVOID *) &pParams->szServer);
    FreeMemory((LPVOID *) &pParams->szUserName);
    FreeMemory((LPVOID *) &pParams->szPassword);
    FreeMemory((LPVOID *) &pParams->szRunAsUserName);
    FreeMemory((LPVOID *) &pParams->szRunAsPassword);

    //reset all fields to 0
    SecureZeroMemory( &pParams, sizeof( PTCHANGESUBOPTS ) );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\create.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        create.cpp

    Abstract:

        This module validates the options specied by the user & if correct creates
        a scheduled task.

    Author:

        Raghu babu  10-oct-2000

    Revision History:

        Raghu babu        10-Oct-2000 : Created it
        G.Surender Reddy  25-oct-2000 : Modified it
        G.Surender Reddy  27-oct-2000 : Modified it
        G.Surender Reddy  30-oct-2000 : Modified it


******************************************************************************/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

/******************************************************************************
    Routine Description:

        This routine  initialises the variables to neutral values ,helps in
        creating a new scheduled task

    Arguments:

        [ in ] argc : The count of arguments specified in the command line
        [ in ] argv : Array of command line arguments

    Return Value :
        A HRESULT value indicating S_OK on success else S_FALSE on failure

******************************************************************************/

HRESULT
CreateScheduledTask(
                    IN DWORD argc ,
                    IN LPCTSTR argv[]
                    )
{
    // declarations of structures
    TCREATESUBOPTS tcresubops;
    TCREATEOPVALS tcreoptvals;
    DWORD dwScheduleType = 0;
    WORD wUserStatus = FALSE;

    //Initialize structures to neutral values.
    SecureZeroMemory( &tcresubops, sizeof( TCREATESUBOPTS ) );
    SecureZeroMemory( &tcreoptvals, sizeof( TCREATEOPVALS ) );

    // process the options for -create option
    if( ProcessCreateOptions ( argc, argv, tcresubops, tcreoptvals, &dwScheduleType, &wUserStatus  ) )
    {
        ReleaseMemory(&tcresubops);
        if(tcresubops.bUsage == TRUE)
        {
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }

    // calls the function to create a scheduled task
    return CreateTask(tcresubops,tcreoptvals,dwScheduleType, wUserStatus );
}


/******************************************************************************
    Routine Description:

    This routine  creates a new scheduled task according to the user
    specified format

    Arguments:

        [ in ]  tcresubops     : Structure containing the task's properties
        [ out ] tcreoptvals    : Structure containing optional values to set
        [ in ]  dwScheduleType : Type of schedule[Daily,once,weekly etc]
        [ in ]  bUserStatus    : bUserStatus will be TRUE when -ru given else FALSE

    Return Value :
        A HRESULT value indicating S_OK on success else S_FALSE on failure
******************************************************************************/

HRESULT
CreateTask(
            IN TCREATESUBOPTS tcresubops,
            IN OUT TCREATEOPVALS &tcreoptvals,
            IN DWORD dwScheduleType,
            IN WORD wUserStatus
            )
{
    // Declarations related to the system time
    WORD  wStartDay     = 0;
    WORD  wStartMonth   = 0;
    WORD  wStartYear    = 0;
    WORD  wStartHour    = 0;
    WORD  wStartMin     = 0;
    WORD  wEndHour      = 0;
    WORD  wEndMin       = 0;
    WORD  wEndDay       = 0;
    WORD  wEndYear      = 0;
    WORD  wEndMonth     = 0;
    WORD  wIdleTime     = 0;

    WORD  wCurrentHour   = 0;
    WORD  wCurrentMin    = 0;
    DWORD  dwCurrentTimeInMin = 0;

    WORD  wCurrentYear   = 0;
    WORD  wCurrentMonth    = 0;
    WORD  wCurrentDay    = 0;

    SYSTEMTIME systime = {0,0,0,0,0,0,0,0};

    // Declarations related to the new task
    LPWSTR   wszUserName = NULL;
    LPWSTR   wszPassword = NULL;
    WCHAR   wszTaskName[MAX_JOB_LEN];
    WCHAR   wszApplName[_MAX_FNAME];
    WCHAR   szRPassword[MAX_STRING_LENGTH];

    HRESULT hr = S_OK;
    IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;
    ITaskTrigger *pITaskTrig = NULL;
    ITaskScheduler *pITaskScheduler = NULL;
    WORD wTrigNumber = 0;

    TASK_TRIGGER TaskTrig;
    SecureZeroMemory(&TaskTrig, sizeof (TASK_TRIGGER));
    TaskTrig.cbTriggerSize = sizeof (TASK_TRIGGER);
    TaskTrig.Reserved1 = 0; // reserved field and must be set to 0.
    TaskTrig.Reserved2 = 0; // reserved field and must be set to 0.
    WCHAR* szValues[2] = {NULL};//To pass to FormatMessage() API


    // Buffer to store the string obtained from the string table
    WCHAR szBuffer[2 * MAX_STRING_LENGTH];

    BOOL bPassWord = FALSE;
    BOOL bUserName = FALSE;
    BOOL bRet = FALSE;
    BOOL bResult = FALSE;
    BOOL bCloseConnection = TRUE;
    ULONG ulLong = MAX_STRING_LENGTH;
    BOOL bVal = FALSE;
    DWORD dwStartTimeInMin = 0;
    DWORD dwEndTimeInMin = 0;
    DWORD dwDuration = 0;
    DWORD dwModifierVal = 0;
    DWORD dwRepeat = 0;

    BOOL  bCancel = FALSE;
    BOOL  bReplace = FALSE;
    BOOL  bScOnce = FALSE;
    BOOL  bStartDate = FALSE;
    LPWSTR  pszStopString = NULL;
    DWORD dwPolicy = 0;

    //initialize the variables
    SecureZeroMemory (wszTaskName, SIZE_OF_ARRAY(wszTaskName));
    SecureZeroMemory (wszApplName, SIZE_OF_ARRAY(wszApplName));
    SecureZeroMemory (szRPassword, SIZE_OF_ARRAY(szRPassword));
    SecureZeroMemory (szBuffer, SIZE_OF_ARRAY(szBuffer));

    // check whether the taskname contains the characters such
    // as '<','>',':','/','\\','|'
    bRet = VerifyJobName(tcresubops.szTaskName);
    if(bRet == FALSE)
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_TASKNAME1));
        ShowMessage(stderr,GetResString(IDS_INVALID_TASKNAME2));
        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return E_FAIL;
    }

    // check for the length of taskname
    if( ( StringLength(tcresubops.szTaskName, 0) > MAX_JOB_LEN ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_TASKLENGTH));
        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return E_FAIL;
    }

    // check for the length of taskrun
    if(( StringLength(tcresubops.szTaskRun, 0) > MAX_TASK_LEN ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_TASKRUN));
        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return E_FAIL;

    }

    StringCopy ( wszTaskName, tcresubops.szTaskName, SIZE_OF_ARRAY(wszTaskName));


    // check whether /IT is specified with /RU "NT AUTHORITY\SYSTEM" or not
    if ( ( ( TRUE == tcresubops.bActive) && ( wUserStatus == OI_CREATE_RUNASUSERNAME )) &&
         ( ( StringLength ( tcresubops.szRunAsUser, 0 ) == 0 ) ||
           ( StringCompare( tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) ||
           ( StringCompare( tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) == 0 ) ) )
    {
        ShowMessage ( stderr, GetResString (IDS_IT_SWITCH_NA) );
        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return E_FAIL;
    }

    // check for empty password
    if( ( tcreoptvals.bRunAsPassword == TRUE ) && ( StringLength(tcresubops.szRunAsPassword, 0) == 0 ) &&
        ( StringLength ( tcresubops.szRunAsUser, 0 ) != 0 ) &&
        ( StringCompare(tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) != 0 ) &&
        ( StringCompare(tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) != 0 ) )
    {
        ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
    }

    //Assign start time
    if(tcreoptvals.bSetStartTimeToCurTime && (dwScheduleType != SCHED_TYPE_ONIDLE) )
    {
        GetLocalTime(&systime);
        wStartHour = systime.wHour;
        wStartMin = systime.wMinute;
    }
    else if(StringLength(tcresubops.szStartTime, 0) > 0)
    {
        // get the Start time in terms of hours, minutes and seconds
        GetTimeFieldEntities(tcresubops.szStartTime, &wStartHour, &wStartMin );
    }

    // get the End time in terms of hours, minutes and seconds
    if(StringLength(tcresubops.szEndTime, 0) > 0)
    {
        GetTimeFieldEntities(tcresubops.szEndTime, &wEndHour, &wEndMin );
    }

     // default repetition interval-> 10 mins and duration ->60 mins
     dwRepeat = 10;
     dwDuration = 60;

    if(StringLength(tcresubops.szRepeat, 0) > 0)
    {
        // get the repetition value
        dwRepeat =  wcstol(tcresubops.szRepeat, &pszStopString, BASE_TEN);
        if ((errno == ERANGE) ||
            ((pszStopString != NULL) && (StringLength (pszStopString, 0) != 0) ) ||
            ( (dwRepeat < MIN_REPETITION_INTERVAL ) || ( dwRepeat > MAX_REPETITION_INTERVAL) ) )
        {
            // display an error message as .. invalid value specified for /RT
            ShowMessage ( stderr, GetResString (IDS_INVALID_RT_VALUE) );
            ReleaseMemory(&tcresubops);
            return E_FAIL;
        }

        //check whether the specified repetition interval is greater than 9999..
        // if so, set the maximum repetition interval as 9999.
        if ( (dwRepeat > 9999) && ( (dwRepeat % 60) !=  0) )
        {
            //display some warning message as.. max value (less than the specified interval)
            // divisible by 60.
            ShowMessage ( stderr, GetResString (IDS_WARN_VALUE) );
            dwRepeat -= (dwRepeat % 60);
        }
    }
    

    if ( ( dwScheduleType != SCHED_TYPE_ONSTART ) && ( dwScheduleType != SCHED_TYPE_ONLOGON ) && ( dwScheduleType != SCHED_TYPE_ONIDLE ))
    {
        if(( StringLength(tcresubops.szEndTime, 0) > 0) && ( StringLength(tcresubops.szDuration, 0) == 0) )
        {
            // calculate start time in minutes
            dwStartTimeInMin = (DWORD) ( wStartHour * MINUTES_PER_HOUR * SECS_PER_MINUTE + wStartMin * SECS_PER_MINUTE )/ SECS_PER_MINUTE ;

            // calculate end time in minutes
            dwEndTimeInMin = (DWORD) ( wEndHour * MINUTES_PER_HOUR * SECS_PER_MINUTE + wEndMin * SECS_PER_MINUTE ) / SECS_PER_MINUTE ;

            // check whether end time is later than start time
            if ( dwEndTimeInMin >= dwStartTimeInMin )
            {
                // if the end and start time in the same day..
                // get the duration between end and start time (in minutes)
                dwDuration = dwEndTimeInMin - dwStartTimeInMin ;
            }
            else
            {
                // if the start and end time not in the same day..
                // get the duration between start and end time (in minutes)
                // and subtract that duration by 1440(max value in minutes)..
                dwDuration = 1440 - (dwStartTimeInMin - dwEndTimeInMin ) ;
            }

            if ( dwScheduleType == SCHED_TYPE_MINUTE )
            {
                dwModifierVal = AsLong(tcresubops.szModifier, BASE_TEN) ;
            }
            else if (dwScheduleType == SCHED_TYPE_HOURLY)
            {
                dwModifierVal = AsLong(tcresubops.szModifier, BASE_TEN) * MINUTES_PER_HOUR;
            }

            //check whether The duration is greater than the repetition interval or not.
            if ( (dwDuration <= dwModifierVal) || (  ( dwScheduleType != SCHED_TYPE_MINUTE ) &&
                ( dwScheduleType != SCHED_TYPE_HOURLY ) && (dwDuration <= dwRepeat) ) )
            {
                ShowMessage ( stderr, GetResString (IDS_INVALID_DURATION1) );
                Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                return E_FAIL;
            }
        }
        else if(( StringLength(tcresubops.szEndTime, 0) == 0) && ( StringLength(tcresubops.szDuration, 0) > 0) )
        {
            WCHAR tHours[MAX_RES_STRING];
            WCHAR tMins[MAX_RES_STRING];
            DWORD  dwDurationHours = 0;
            DWORD  dwDurationMin = 0;

            //initializes the arrays
            SecureZeroMemory ( tHours, SIZE_OF_ARRAY(tHours));
            SecureZeroMemory ( tMins, SIZE_OF_ARRAY(tMins));

            if ( ( StringLength (tcresubops.szDuration, 0) != 7 ) || (tcresubops.szDuration[4] != TIME_SEPARATOR_CHAR) )
            {
                ShowMessage ( stderr, GetResString (IDS_INVALIDDURATION_FORMAT) );
                Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                return E_FAIL;
            }

            StringCopy(tHours, wcstok(tcresubops.szDuration,TIME_SEPARATOR_STR), SIZE_OF_ARRAY(tHours)); // Get the Hours field.
            if(StringLength(tHours, 0) > 0)
            {
                StringCopy(tMins, wcstok(NULL,TIME_SEPARATOR_STR), SIZE_OF_ARRAY(tMins)); // Get the Minutes field.
            }

            dwDurationHours =  wcstol(tHours, &pszStopString, BASE_TEN);
            if ((errno == ERANGE) ||
                ((pszStopString != NULL) && (StringLength (pszStopString, 0) != 0) ) )
            {
                ShowMessage ( stderr, GetResString (IDS_INVALID_DU_VALUE) );
                Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                return E_FAIL;
            }

            // Get the duration in hours
            dwDurationHours = dwDurationHours * MINUTES_PER_HOUR;

            // Get the duration in minutes
            dwDurationMin =  wcstol(tMins, &pszStopString, BASE_TEN);
            if ((errno == ERANGE) || ( dwDurationMin > 59 ) ||
                ((pszStopString != NULL) && (StringLength (pszStopString, 0) != 0) ) )
            {
                ShowMessage ( stderr, GetResString (IDS_INVALID_DU_VALUE) );
                Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                return E_FAIL;
            }

            // Get the total duration in minutes
            dwDuration = dwDurationHours + dwDurationMin ;

            if ( dwScheduleType == SCHED_TYPE_MINUTE )
            {
                dwModifierVal = AsLong(tcresubops.szModifier, BASE_TEN) ;
            }
            else if (dwScheduleType == SCHED_TYPE_HOURLY)
            {
                dwModifierVal = AsLong(tcresubops.szModifier, BASE_TEN) * MINUTES_PER_HOUR;
            }

            //check whether The duration is greater than the repetition interval or not.
            if ( dwDuration <= dwModifierVal || ( ( dwScheduleType != SCHED_TYPE_MINUTE ) &&
                ( dwScheduleType != SCHED_TYPE_HOURLY ) && (dwDuration <= dwRepeat) ) )
            {
                ShowMessage ( stderr, GetResString (IDS_INVALID_DURATION2) );
                Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                return E_FAIL;
            }
        }
    }

    // check whether the group policy prevented user from creating new tasks or not.
    if ( FALSE == GetGroupPolicy( tcresubops.szServer, tcresubops.szUser, TS_KEYPOLICY_DENY_CREATE_TASK, &dwPolicy ) )
    {
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return EXIT_FAILURE;
    }
    
    if ( dwPolicy > 0 )
    {
        ShowMessage ( stdout, GetResString (IDS_PREVENT_CREATE));
        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return EXIT_SUCCESS;
    }

    // check for the local system
    if ( ( IsLocalSystem( tcresubops.szServer ) == TRUE ) &&
        ( StringLength ( tcresubops.szRunAsUser, 0 ) != 0 ) &&
        ( StringCompare(tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) != 0 ) &&
        ( StringCompare(tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) != 0 ) )

    {
        // Establish the connection on a remote machine
        bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,GetBufferSize(tcresubops.szUser)/sizeof(WCHAR),tcresubops.szPassword,GetBufferSize(tcresubops.szPassword)/sizeof(WCHAR), tcreoptvals.bPassword);
        if (bResult == FALSE)
        {
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                bCloseConnection = FALSE;
                break;

            // check for mismatched credentials
            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );

                    Cleanup(pITaskScheduler);
                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }
             default :
                 bCloseConnection = TRUE;

            }
        }


        if ( StringLength (tcresubops.szRunAsUser, 0) != 0 )
        {

            wszUserName = tcresubops.szRunAsUser;

            bUserName = TRUE;

            if ( tcreoptvals.bRunAsPassword == FALSE )
            {
                szValues[0] = (WCHAR*) (wszUserName);
                //Display that the task will be created under logged in user name,ask for password
                MessageBeep(MB_ICONEXCLAMATION);

                ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                // getting the password
                if (GetPassword(szRPassword, MAX_STRING_LENGTH) == FALSE )
                {
                    Cleanup(pITaskScheduler);
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                    {
                        CloseConnection( tcresubops.szServer );
                    }

                    ReleaseMemory(&tcresubops);

                    return E_FAIL;
                }

                // check for empty password
                if( StringLength ( szRPassword, 0 ) == 0 )
                {
                    ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                }

                wszPassword = szRPassword;

                bPassWord = TRUE;
            }
            else
            {
                wszPassword = tcresubops.szRunAsPassword;

                bPassWord = TRUE;
            }

        }
    }
    // check whether -s option only specified in the cmd line or not
    else if( ( IsLocalSystem( tcresubops.szServer ) == FALSE ) && ( wUserStatus == OI_CREATE_SERVER ) )
    {
        // Establish the connection on a remote machine
        bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,GetBufferSize(tcresubops.szUser)/sizeof(WCHAR),tcresubops.szPassword,GetBufferSize(tcresubops.szPassword)/sizeof(WCHAR), tcreoptvals.bPassword);
        if (bResult == FALSE)
        {
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                bCloseConnection = FALSE;
                break;

            // check for mismatched credentials
            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                    Cleanup(pITaskScheduler);
                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }

            default :
                 bCloseConnection = TRUE;
            }
        }

        if ( ( StringLength (tcresubops.szUser, 0) == 0 ) )
        {
            //get the current logged on username
            if ( GetUserNameEx ( NameSamCompatible, tcresubops.szUser , &ulLong) == FALSE )
            {
                ShowMessage( stderr, GetResString( IDS_LOGGED_USER_ERR ) );
                Cleanup(pITaskScheduler);
                // close the connection that was established by the utility
                if ( bCloseConnection == TRUE )
                {
                    CloseConnection( tcresubops.szServer );
                }
                ReleaseMemory(&tcresubops);
                return E_FAIL;
            }

            bUserName = TRUE;

            wszUserName = tcresubops.szUser;

            szValues[0] = (WCHAR*) (wszUserName);
            //Display that the task will be created under logged in user name,ask for password
            MessageBeep(MB_ICONEXCLAMATION);


            ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_TASK_INFO), _X(wszUserName));

            ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

            if (GetPassword(tcresubops.szRunAsPassword, GetBufferSize(tcresubops.szRunAsPassword)/sizeof(WCHAR)) == FALSE )
            {
                Cleanup(pITaskScheduler);
                // close the connection that was established by the utility
                if ( bCloseConnection == TRUE )
                {
                    CloseConnection( tcresubops.szServer );
                }

                ReleaseMemory(&tcresubops);

                return E_FAIL;
            }

            // check for empty password
            if( StringLength ( tcresubops.szRunAsPassword, 0 ) == 0 )
            {
                ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
            }


            // check for the length of the password
            wszPassword = tcresubops.szRunAsPassword;


            bPassWord = TRUE;

        }

        wszUserName = tcresubops.szUser;

        // check whether the run as password is specified in the cmdline or not
        if ( tcreoptvals.bRunAsPassword == TRUE )
        {
            // check for -rp "*" or -rp " " to prompt for password
            if ( StringCompare( tcresubops.szRunAsPassword, ASTERIX, TRUE, 0 ) == 0 )
            {
                // format the message for getting the password
                szValues[0] = (WCHAR*) (wszUserName);


                ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                 //re-alloc the memory for /rp
                 if ( ReallocateMemory( (LPVOID*)&tcresubops.szRunAsPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
                    {
                        SaveLastError();
                        // close the connection that was established by the utility
                        if ( bCloseConnection == TRUE )
                        {
                            CloseConnection( tcresubops.szServer );
                        }
                        return E_FAIL;
                    }

                // Get the run as password from the command line
                if ( GetPassword(tcresubops.szRunAsPassword, GetBufferSize(tcresubops.szRunAsPassword)/sizeof(WCHAR) ) == FALSE )
                {
                    Cleanup(pITaskScheduler);
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                    {
                        CloseConnection( tcresubops.szServer );
                    }

                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }

                // check for empty password
                if( StringLength ( tcresubops.szRunAsPassword, 0 ) == 0 )
                {
                    ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                }


                 wszPassword = tcresubops.szRunAsPassword;
            }
        }
        else
        {
             wszPassword = tcresubops.szPassword;
        }
        // set the BOOL variables to TRUE
        bUserName = TRUE;
        bPassWord = TRUE;

    }
    // check for -s and -u options only specified in the cmd line or not
    else if ( wUserStatus == OI_CREATE_USERNAME )
    {

        // Establish the connection on a remote machine
        bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,GetBufferSize(tcresubops.szUser)/sizeof(WCHAR),tcresubops.szPassword,GetBufferSize(tcresubops.szPassword)/sizeof(WCHAR), tcreoptvals.bPassword);
        if (bResult == FALSE)
        {
            ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
            ShowMessage( stderr, GetReason());
            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                bCloseConnection = FALSE;
                break;

            // for mismatched credentials
            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
                    ShowMessage( stderr, GetReason());

                    Cleanup(pITaskScheduler);
                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }

             default :
                 bCloseConnection = TRUE;

            }

        }

        wszUserName = tcresubops.szUser;

        // check whether run as password is specified in the command line or not
        if ( tcreoptvals.bRunAsPassword == TRUE )
        {
            // check for -rp "*" or -rp " " to prompt for password
            if ( StringCompare( tcresubops.szRunAsPassword, ASTERIX, TRUE, 0 ) == 0 )
            {
                // format the message for getting the password from console
                szValues[0] = (WCHAR*) (wszUserName);

                ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                //re-alloc the memory for /rp
                 if ( ReallocateMemory( (LPVOID*)&tcresubops.szRunAsPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
                    {
                        SaveLastError();
                        if ( bCloseConnection == TRUE )
                            CloseConnection( tcresubops.szServer );
                        //release memory for password
                        ReleaseMemory(&tcresubops);
                        return E_FAIL;
                    }

                // Get the password from the command line
                if ( GetPassword(tcresubops.szRunAsPassword, GetBufferSize(tcresubops.szRunAsPassword)/sizeof(WCHAR) ) == FALSE )
                {
                    Cleanup(pITaskScheduler);
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                    {
                        CloseConnection( tcresubops.szServer );
                    }

                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }

                // check for empty password
                if( StringLength ( tcresubops.szRunAsPassword, 0 ) == 0 )
                {
                    ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                }


                wszPassword = tcresubops.szRunAsPassword;
            }
            else
            {
                wszPassword = tcresubops.szRunAsPassword;

                bPassWord = TRUE;
            }
        }
        else
        {
            if ( StringLength(tcresubops.szPassword, 0) != 0 )
            {
                wszPassword = tcresubops.szPassword;
            }
            else
            {
                // format the message for getting the password from console
                szValues[0] = (WCHAR*) (wszUserName);


                ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                // Get the password from the command line
                if ( GetPassword(tcresubops.szRunAsPassword, GetBufferSize(tcresubops.szRunAsPassword)/sizeof(WCHAR) ) == FALSE )
                {
                    Cleanup(pITaskScheduler);
                    // close the connection that was established by the utility
                    if ( bCloseConnection == TRUE )
                    {
                        CloseConnection( tcresubops.szServer );
                    }

                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }

                // check for empty password
                if( StringLength ( tcresubops.szRunAsPassword, 0 ) == 0 )
                {
                    ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                }


                wszPassword = tcresubops.szRunAsPassword;
            }

        }

        bUserName = TRUE;
        bPassWord = TRUE;

    }
    // check for -s, -ru or -u options specified in the cmd line or not
    else if ( ( StringLength (tcresubops.szServer, 0) != 0 ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER ) )
    {
        // Establish the connection on a remote machine
        bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,GetBufferSize(tcresubops.szUser)/sizeof(WCHAR),tcresubops.szPassword,GetBufferSize(tcresubops.szPassword)/sizeof(WCHAR), tcreoptvals.bPassword);
        if (bResult == FALSE)
        {
            ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
            ShowMessage( stderr, GetReason());
            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                bCloseConnection = FALSE;
                break;

            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
                    ShowMessage( stderr, GetReason());
                    Cleanup(pITaskScheduler);
                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }

             default :
                 bCloseConnection = TRUE;
            }

        }

        if ( ( ( StringLength ( tcresubops.szRunAsUser, 0 ) == 0 ) ||
              ( StringCompare( tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) ||
              ( StringCompare( tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) == 0 ) ) )
        {

            wszUserName = tcresubops.szRunAsUser;

            szValues[0] = (WCHAR*) (tcresubops.szTaskName);


            //ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_NTAUTH_SYSTEM_INFO), _X(wszTaskName));
            StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_NTAUTH_SYSTEM_INFO), _X(wszTaskName));
            ShowMessage ( stdout, _X(szBuffer));

            if ( ( tcreoptvals.bRunAsPassword == TRUE ) &&
                ( StringLength (tcresubops.szRunAsPassword, 0) != 0 ) )
            {
                ShowMessage( stderr, GetResString( IDS_PASSWORD_NOEFFECT ) );
            }
            bUserName = TRUE;
            bPassWord = TRUE;
            bVal = TRUE;
        }
        else
        {
            // check for the length of password
            if ( StringLength ( tcresubops.szRunAsUser, 0 ) != 0 )
            {
                wszUserName = tcresubops.szRunAsUser;

                bUserName = TRUE;
            }
        }

        // check whether -u and -ru are the same or not. if they are same, we need to
        // prompt for the run as password. otherwise, will consoder -rp as -p
        if ( StringCompare( tcresubops.szRunAsUser, tcresubops.szUser, TRUE, 0 ) != 0)
        {
            if ( tcreoptvals.bRunAsPassword == TRUE )
            {
                if ( (StringLength(tcresubops.szRunAsUser, 0) != 0) && (StringCompare( tcresubops.szRunAsPassword, ASTERIX, TRUE, 0 ) == 0 ) &&
                     ( StringCompare( tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) != 0 ) &&
                     ( StringCompare( tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) != 0 ) )
                {
                    szValues[0] = (WCHAR*) (wszUserName);



                    ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                    // prompt for the run as password
                    if ( GetPassword(szRPassword, MAX_STRING_LENGTH ) == FALSE )
                    {
                        Cleanup(pITaskScheduler);
                        // close the connection that was established by the utility
                        if ( bCloseConnection == TRUE )
                        {
                            CloseConnection( tcresubops.szServer );
                        }

                        ReleaseMemory(&tcresubops);
                        return E_FAIL;
                    }

                    // check for empty password
                    if( StringLength ( szRPassword, 0 ) == 0 )
                    {
                        ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                    }


                    wszPassword = szRPassword;

                    bUserName = TRUE;
                    bPassWord = TRUE;
                }
                else
                {
                    wszPassword = tcresubops.szRunAsPassword;

                    bUserName = TRUE;
                    bPassWord = TRUE;
                }
            }
            else
            {
                // check for the length of password
                if ( ( bVal == FALSE ) && ( StringLength(tcresubops.szRunAsUser, 0) != 0) )
                {
                    // format the message for getting the password from console
                    szValues[0] = (WCHAR*) (wszUserName);


                    ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                    // prompt for the run as password
                    if ( GetPassword(szRPassword, MAX_STRING_LENGTH ) == FALSE )
                    {
                        Cleanup(pITaskScheduler);
                        // close the connection that was established by the utility
                        if ( bCloseConnection == TRUE )
                        {
                            CloseConnection( tcresubops.szServer );
                        }

                        ReleaseMemory(&tcresubops);
                        return E_FAIL;
                    }

                    // check for empty password
                    if( StringLength ( szRPassword, 0 ) == 0 )
                    {
                        ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                    }


                    wszPassword = szRPassword;
                }
                bUserName = TRUE;
                bPassWord = TRUE;
            }
        }
        else
        {
            // check whether run as password is specified in the cmdline or not
            if ( tcreoptvals.bRunAsPassword == TRUE )
            {
                if ( ( StringLength ( tcresubops.szRunAsUser, 0 ) != 0 ) && ( StringCompare( tcresubops.szRunAsPassword, ASTERIX, TRUE, 0 ) == 0 ) )
                {
                    szValues[0] = (WCHAR*) (wszUserName);


                    ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                    // prompt for the run as password
                    if ( GetPassword(szRPassword, MAX_STRING_LENGTH ) == FALSE )
                    {
                        Cleanup(pITaskScheduler);
                        // close the connection that was established by the utility
                        if ( bCloseConnection == TRUE )
                        {
                            CloseConnection( tcresubops.szServer );
                        }

                        ReleaseMemory(&tcresubops);
                        return E_FAIL;
                    }

                    // check for empty password
                    if( StringLength ( szRPassword, 0 ) == 0 )
                    {
                        ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                    }


                    wszPassword = szRPassword;

                }
                else
                {
                    wszPassword = tcresubops.szRunAsPassword;
                }

            }
            else
            {
                if ( StringLength (tcresubops.szPassword, 0) )
                {

                    wszPassword = tcresubops.szPassword;
                }
                else
                {
                    if (( StringLength ( tcresubops.szRunAsUser, 0 ) != 0 ) &&
                        ( StringCompare(tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) != 0 ) &&
                        ( StringCompare(tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) != 0 ) )
                    {
                        szValues[0] = (WCHAR*) (wszUserName);


                        ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                        // prompt for the run as password
                        if ( GetPassword(szRPassword, MAX_STRING_LENGTH ) == FALSE )
                        {
                            Cleanup(pITaskScheduler);
                            // close the connection that was established by the utility
                            if ( bCloseConnection == TRUE )
                            {
                                CloseConnection( tcresubops.szServer );
                            }

                            ReleaseMemory(&tcresubops);
                            return E_FAIL;
                        }

                        // check for empty password
                        if( StringLength ( szRPassword, 0 ) == 0 )
                        {
                            ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                        }


                        wszPassword = szRPassword;

                    }
                }
            }

            bUserName = TRUE;
            bPassWord = TRUE;
        }

    }


    // To check for the -ru values "", "NT AUTHORITY\SYSTEM", "SYSTEM"
    if( ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME ) && ( StringLength( tcresubops.szRunAsUser, 0) == 0 ) && ( tcreoptvals.bRunAsPassword == FALSE ) ) ||
        ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME ) && ( StringLength( tcresubops.szRunAsUser, 0) == 0 ) && ( StringLength(tcresubops.szRunAsPassword, 0 ) == 0 ) ) ||
        ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME ) && ( StringCompare(tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) && ( tcreoptvals.bRunAsPassword == FALSE ) ) ||
        ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME ) && ( StringCompare(tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) && ( StringLength( tcresubops.szRunAsPassword, 0) == 0 ) ) ||
        ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME ) && ( StringCompare(tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) == 0 ) && ( tcreoptvals.bRunAsPassword == FALSE ) ) ||
        ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME ) && ( StringCompare(tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) == 0 ) && ( StringLength(tcresubops.szRunAsPassword, 0) == 0 ) ) )
    {
        //format the message to display the taskname will be created under "NT AUTHORITY\SYSTEM"
        szValues[0] = (WCHAR*) (tcresubops.szTaskName);

        //ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_NTAUTH_SYSTEM_INFO), _X(wszTaskName));
        StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_NTAUTH_SYSTEM_INFO), _X(wszTaskName));
        ShowMessage ( stdout, _X(szBuffer));

        bUserName = TRUE;
        bPassWord = TRUE;
        bVal = TRUE;
    }
    // check whether the -rp value is given with the -ru "", "NT AUTHORITY\SYSTEM",
    // "SYSTEM" or not
    else if( ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER) && ( StringLength(tcresubops.szRunAsUser, 0) == 0 ) && ( StringLength(tcresubops.szRunAsPassword, 0) != 0 ) ) ||
        ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER) && ( StringCompare( tcresubops.szRunAsUser, NTAUTHORITY_USER, TRUE, 0 ) == 0 ) && ( tcreoptvals.bRunAsPassword == TRUE ) ) ||
        ( ( bVal == FALSE ) && ( wUserStatus == OI_CREATE_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER) && ( StringCompare( tcresubops.szRunAsUser, SYSTEM_USER, TRUE, 0 ) == 0 ) && ( tcreoptvals.bRunAsPassword == TRUE ) ) )
    {
        szValues[0] = (WCHAR*) (tcresubops.szTaskName);

        //ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_NTAUTH_SYSTEM_INFO), _X(wszTaskName));
        StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_NTAUTH_SYSTEM_INFO), _X(wszTaskName));
        ShowMessage ( stdout, _X(szBuffer));

        // to display a warning message as password will not effect for the system account
        ShowMessage( stderr, GetResString( IDS_PASSWORD_NOEFFECT ) );
        bUserName = TRUE;
        bPassWord = TRUE;
        bVal = TRUE;
    }
    // check whether -s, -u, -ru options are given in the cmdline or not
    else if( ( wUserStatus != OI_CREATE_SERVER ) && ( wUserStatus != OI_CREATE_USERNAME ) &&
        ( wUserStatus != OI_CREATE_RUNASUSERNAME ) && ( wUserStatus != OI_RUNANDUSER ) &&
        ( StringCompare( tcresubops.szRunAsPassword , L"\0", TRUE, 0 ) == 0 ) )
    {
            if (tcreoptvals.bRunAsPassword == TRUE)
            {
                bPassWord = TRUE;
            }
            else
            {
                bPassWord = FALSE;
            }
    }
    else if ( ( StringLength(tcresubops.szServer, 0) == 0 ) && (StringLength ( tcresubops.szRunAsUser, 0 ) != 0 ) )
    {

        wszUserName = tcresubops.szRunAsUser;

        bUserName = TRUE;

        if ( StringLength ( tcresubops.szRunAsPassword, 0 ) == 0 )
        {
            bPassWord = TRUE;
        }
        else
        {
            // check whether "*" or NULL value is given for -rp or not
            if ( StringCompare ( tcresubops.szRunAsPassword , ASTERIX, TRUE, 0 ) == 0 )
            {
                // format a message for getting the password from the console
                szValues[0] = (WCHAR*) (wszUserName);


                ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

                // Get the password from the command line
                if (GetPassword(szRPassword, MAX_STRING_LENGTH ) == FALSE )
                {
                    Cleanup(pITaskScheduler);
                    ReleaseMemory(&tcresubops);
                    return E_FAIL;
                }

                // check for empty password
                if( StringLength ( szRPassword, 0 ) == 0 )
                {
                    ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
                }

                wszPassword = szRPassword;

            }
            else
            {
                   wszPassword = tcresubops.szRunAsPassword;
            }

            bPassWord = TRUE;
        }

    }

    // check whether -ru or -u values are specified in the cmdline or not
    if ( wUserStatus == OI_CREATE_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER )
    {
        if( ( bUserName == TRUE ) && ( bPassWord == FALSE ) )
        {
            szValues[0] = (WCHAR*) (wszUserName);


            ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

            // getting the password from the console
            if ( GetPassword(tcresubops.szRunAsPassword, GetBufferSize(tcresubops.szRunAsPassword)/sizeof(WCHAR) ) == FALSE )
            {
                Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                return E_FAIL;
            }

            // check for empty password
            if( StringLength ( tcresubops.szRunAsPassword, 0 ) == 0 )
            {
                ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
            }


            wszPassword = tcresubops.szRunAsPassword;

        }
    }

    //if the user name is not specifed set the current logged on user settings
    WCHAR  szUserName[MAX_STRING_LENGTH];
    DWORD dwCheck = 0;

    if( ( bUserName == FALSE ) )
    {
        //get the current logged on username
        if ( GetUserNameEx ( NameSamCompatible, szUserName , &ulLong) == FALSE )
        {
            ShowMessage( stderr, GetResString( IDS_LOGGED_USER_ERR ) );
            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL;
        }


        wszUserName = szUserName;

        szValues[0] = (WCHAR*) (wszUserName);
        //Display that the task will be created under logged in user name,ask for password
        MessageBeep(MB_ICONEXCLAMATION);



        ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_TASK_INFO), _X(wszUserName));


        ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_PROMPT_PASSWD), _X(wszUserName));

        // getting the password
        if (GetPassword(szRPassword, MAX_STRING_LENGTH) == FALSE )
        {
            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL;
        }


        // check for empty password
        if( StringLength ( szRPassword, 0 ) == 0 )
        {
            ShowMessage(stderr, GetResString(IDS_WARN_EMPTY_PASSWORD));
        }


         wszPassword = szRPassword;

    }


    // Get the task Scheduler object for the machine.
    pITaskScheduler = GetTaskScheduler( tcresubops.szServer );

    // If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {
        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return E_FAIL;
    }

        //check whether service is running or not
    if ((FALSE == CheckServiceStatus ( tcresubops.szServer , &dwCheck, TRUE)) && (0 != dwCheck) && ( GetLastError () != ERROR_ACCESS_DENIED)) 
    {
         // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);

        if ( 1 == dwCheck )
        {
            ShowMessage ( stderr, GetResString (IDS_NOT_START_SERVICE));
            return EXIT_FAILURE;
        }
        else if (2 == dwCheck )
        {
            return E_FAIL;
        }
        else if (3 == dwCheck )
        {
            return EXIT_SUCCESS;
        }
        
    }

    StringConcat ( tcresubops.szTaskName, JOB, SIZE_OF_ARRAY(tcresubops.szTaskName) );

    // create a work item tcresubops.szTaskName
    hr = pITaskScheduler->NewWorkItem(tcresubops.szTaskName,CLSID_CTask,IID_ITask,
                                      (IUnknown**)&pITask);

    // check whether the specified scheduled task is created under
    // some other user. If so, display an error message as unable to create a
    // specified taskname as it is already exists.
    // If the taskname created under some other user return value
    // of above API must 0x80070005.
    if( hr == 0x80070005 )
    {
        ShowMessage(stderr,GetResString(IDS_SYSTEM_TASK_EXISTS));

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    // check whether task is exists in the system or not.
    if( hr == HRESULT_FROM_WIN32 (ERROR_FILE_EXISTS))
    {
        // flag to specify .. need to replace exisitng task..
        bReplace = TRUE;

        szValues[0] = (WCHAR*) (tcresubops.szTaskName);

        // check whether /F option is specified or not..
        // if /F option is specified .. then suppress the warning message..
        if ( FALSE == tcresubops.bForce )
        {
             StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_CREATE_TASK_EXISTS), _X(wszTaskName));
             ShowMessage ( stdout, _X(szBuffer));
            
            if ( EXIT_FAILURE == ConfirmInput(&bCancel))
            {
                if ( bCloseConnection == TRUE )
                    CloseConnection( tcresubops.szServer );

				Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                
                // invalid input entered.. return failure..
                return E_FAIL;
            }

            if ( TRUE == bCancel )
            {
                if ( bCloseConnection == TRUE )
                    CloseConnection( tcresubops.szServer );

				Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                
                // operation cancelled.. return with success..
                return EXIT_SUCCESS;
            }
        }

        //reset to NULL
        pITask = NULL;

        //StringConcat ( tcresubops.szTaskName, JOB, SIZE_OF_ARRAY(tcresubops.szTaskName) );

        // Gets an active interface for a specified szTaskName
        hr = pITaskScheduler->Activate(tcresubops.szTaskName,IID_ITask,
                                       (IUnknown**) &pITask);

         //check whether the job file os corrupted or not..
         if ( (hr == 0x8007000D) || (hr == SCHED_E_UNKNOWN_OBJECT_VERSION) || (hr == E_INVALIDARG))
          {
            //set the variable to FALSE..
            bReplace = FALSE;

            //Since the job file is corrupted.. delete a work item
            hr = pITaskScheduler->Delete(tcresubops.szTaskName);

            if ( FAILED(hr))
            {
                SetLastError ((DWORD) hr);
                ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

                // close the connection that was established by the utility
                if ( bCloseConnection == TRUE )
                    CloseConnection( tcresubops.szServer );

                Cleanup(pITaskScheduler);
                ReleaseMemory(&tcresubops);
                return hr;
            }

            // create a work item tcresubops.szTaskName
            hr = pITaskScheduler->NewWorkItem(tcresubops.szTaskName,CLSID_CTask,IID_ITask,
                                      (IUnknown**)&pITask);
          }

        // check for failure..
        if ( FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tcresubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return hr;
        }


    }
    else if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    // Return a pointer to a specified interface on an object
    hr = pITask->QueryInterface(IID_IPersistFile, (void **) &pIPF);

    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);

        ReleaseMemory(&tcresubops);

        return hr;
    }

    // declaration for parameter arguments
    wchar_t wcszParam[MAX_RES_STRING] = L"\0";

    DWORD dwProcessCode = 0 ;

    dwProcessCode = ProcessFilePath(tcresubops.szTaskRun,wszApplName,wcszParam);

    if(dwProcessCode == RETVAL_FAIL)
    {

        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;

    }

    // check for .exe substring string in the given task to run string

    // Set command name with ITask::SetApplicationName
    hr = pITask->SetApplicationName(wszApplName);
    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    //[Working directory =  exe pathname - exe name]

    wchar_t* wcszStartIn = wcsrchr(wszApplName,_T('\\'));
    if(wcszStartIn != NULL)
        *( wcszStartIn ) = _T('\0');

    // set the command working directory
    hr = pITask->SetWorkingDirectory(wszApplName);

    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    // set the command line parameters for the task
    hr = pITask->SetParameters(wcszParam);
    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    // sub-variable declaration
    DWORD dwTaskFlags = 0;

    // set flag to run the task interactively
    if ( ( FALSE == bVal ) && ( TRUE == tcresubops.bActive) )
    {
        dwTaskFlags = TASK_FLAG_RUN_ONLY_IF_LOGGED_ON | TASK_FLAG_DONT_START_IF_ON_BATTERIES | TASK_FLAG_KILL_IF_GOING_ON_BATTERIES ;
    }
    else
    {
        dwTaskFlags = TASK_FLAG_DONT_START_IF_ON_BATTERIES | TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;
    }

    // if /z is specified .. enables the falg to delete the task if not scheduled to
    // run again...
    if ( TRUE ==  tcresubops.bIsDeleteNoSched )
    {
        dwTaskFlags |= TASK_FLAG_DELETE_WHEN_DONE;
    }

    hr = pITask->SetFlags(dwTaskFlags);
    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    if ( bVal == TRUE )
    {
        // Set account information for "NT AUTHORITY\SYSTEM" user
        hr = pITask->SetAccountInformation(L"",NULL);
    }
    else
    {
        // set the account information with the user name and password
        hr = pITask->SetAccountInformation(wszUserName,wszPassword);
    }

    if ((FAILED(hr)) && (hr != SCHED_E_NO_SECURITY_SERVICES))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        ShowMessage ( stdout, _T("\n") );
        ShowMessage ( stdout, GetResString( IDS_ACCNAME_ERR ) );


        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    //Assign start date
    if(tcreoptvals.bSetStartDateToCurDate )
    {
        GetLocalTime(&systime);
        wStartDay = systime.wDay;
        wStartMonth = systime.wMonth;
        wStartYear = systime.wYear;
    }
    else if(StringLength(tcresubops.szStartDate, 0) > 0)
    {
        GetDateFieldEntities(tcresubops.szStartDate, &wStartDay, &wStartMonth, &wStartYear);
    }

    //Set the flags specific to ONIDLE
    if(dwScheduleType == SCHED_TYPE_ONIDLE)
    {
        pITask->SetFlags(TASK_FLAG_START_ONLY_IF_IDLE);

        wIdleTime = (WORD)AsLong(tcresubops.szIdleTime, BASE_TEN);

        pITask->SetIdleWait(wIdleTime, 0);
    }

    //if specified task already exists... we need to replace the task..
    if ( TRUE == bReplace )
    {
        //create trigger for the corresponding task
        hr = pITask->GetTrigger(wTrigNumber, &pITaskTrig);
        if (FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            if( pIPF )
            {
                pIPF->Release();
            }

            if( pITaskTrig )
            {
                pITaskTrig->Release();
            }

            if( pITask )
            {
                pITask->Release();
            }

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tcresubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return hr;
        }

        // get the current logged-on user name
        WCHAR wszLogonUser [MAX_STRING_LENGTH + 20] = L"";
        DWORD dwLogonUserLen = SIZE_OF_ARRAY(wszLogonUser);
        if ( FALSE == GetUserName (wszLogonUser, &dwLogonUserLen) )
        {
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            if( pIPF )
            {
                pIPF->Release();
            }

            if( pITaskTrig )
            {
                pITaskTrig->Release();
            }

            if( pITask )
            {
                pITask->Release();
            }

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tcresubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return hr;
        }

        //set the creator name i.e logged-on user name
        hr = pITask->SetCreator(wszLogonUser);
        if (FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            if( pIPF )
            {
                pIPF->Release();
            }

            if( pITaskTrig )
            {
                pITaskTrig->Release();
            }

            if( pITask )
            {
                pITask->Release();
            }

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tcresubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return hr;
        }
    }
    else
    {
        //create trigger for the corresponding task
        hr = pITask->CreateTrigger(&wTrigNumber, &pITaskTrig);
        if (FAILED(hr))
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

            if( pIPF )
            {
                pIPF->Release();
            }

            if( pITaskTrig )
            {
                pITaskTrig->Release();
            }

            if( pITask )
            {
                pITask->Release();
            }

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tcresubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return hr;
        }
    }

    WORD wWhichWeek = 0;
    LONG lMonthlyModifier = 0;
    DWORD dwDays = 1;

    //check whether /K is specified or not
    if ( TRUE == tcresubops.bIsDurEnd )
    {
          // set the flag to terminate the task at the end of lifetime.
          TaskTrig.rgFlags = TASK_TRIGGER_FLAG_KILL_AT_DURATION_END ;
    }

    if( ( StringLength(tcresubops.szEndTime, 0) == 0) && (StringLength(tcresubops.szDuration, 0) == 0) &&
        (StringLength(tcresubops.szRepeat, 0) == 0))
    {
        TaskTrig.MinutesInterval = 0;
        TaskTrig.MinutesDuration = 0;
    }
    else
    {
        // if repetition interval is not 0.. then set actual value of /RI
        if ( 0 != dwRepeat )
        {
            // set the MinutesInterval
            TaskTrig.MinutesInterval = dwRepeat;
        }

        // if duration is not 0.. set the actual value of /DU 
        if ( 0 != dwDuration )
        {
            // set the duration value
            TaskTrig.MinutesDuration = dwDuration ;
        }
    }

    //check whether The duration is greater than the repetition interval or not.
    if ( ( dwScheduleType != SCHED_TYPE_MINUTE ) &&
                ( dwScheduleType != SCHED_TYPE_HOURLY ) && (dwDuration <= dwRepeat) )
    {
        ShowMessage ( stderr, GetResString (IDS_INVALID_DURATION2) );
        
        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITaskTrig )
        {
            pITaskTrig->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return EXIT_FAILURE;
    }

    switch( dwScheduleType )
    {

        case SCHED_TYPE_MINUTE:
            TaskTrig.TriggerType = TASK_TIME_TRIGGER_DAILY;
            TaskTrig.Type.Daily.DaysInterval = 1;

            if (StringLength ( tcresubops.szModifier, 0 ) > 0)
            {
                TaskTrig.MinutesInterval = AsLong(tcresubops.szModifier, BASE_TEN);
            }

            if(( StringLength(tcresubops.szEndTime, 0) > 0) || (StringLength(tcresubops.szDuration, 0) > 0) )
            {
                // calculate start time in minutes
                TaskTrig.MinutesDuration = dwDuration ;
            }
            else
            {
                TaskTrig.MinutesDuration = (WORD)(HOURS_PER_DAY*MINUTES_PER_HOUR);
            }
            
            TaskTrig.wStartHour = wStartHour;
            TaskTrig.wStartMinute = wStartMin;

            TaskTrig.wBeginDay = wStartDay;
            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;

            if(StringLength(tcresubops.szEndDate, 0) > 0)
            {
                // Make end date valid; otherwise the enddate parameter is ignored.
                TaskTrig.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
                // Now set the end date entities.
                GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
                TaskTrig.wEndDay = wEndDay;
                TaskTrig.wEndMonth = wEndMonth;
                TaskTrig.wEndYear = wEndYear;
            }

            break;

        case SCHED_TYPE_HOURLY:
            TaskTrig.TriggerType = TASK_TIME_TRIGGER_DAILY;
            TaskTrig.Type.Daily.DaysInterval = 1;

            if (StringLength ( tcresubops.szModifier, 0 ) > 0)
            {
            //set the  MinutesInterval 
            TaskTrig.MinutesInterval = (AsLong(tcresubops.szModifier, BASE_TEN)
                                                * MINUTES_PER_HOUR);
            }

            if ( (StringLength(tcresubops.szEndTime, 0) > 0) || (StringLength(tcresubops.szDuration, 0) > 0) )
            {
                //set the duration value
                TaskTrig.MinutesDuration = dwDuration ;
            }
            else
            {
                TaskTrig.MinutesDuration = (WORD)(HOURS_PER_DAY*MINUTES_PER_HOUR);
            }
            
            TaskTrig.wStartHour = wStartHour;
            TaskTrig.wStartMinute = wStartMin;

            TaskTrig.wBeginDay = wStartDay;
            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;

            // Now set end date parameters, if the enddate is specified.
            if(StringLength(tcresubops.szEndDate, 0) > 0)
            {
                // Make end date valid; otherwise the enddate parameter is ignored.
                TaskTrig.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
                // Now set the end date entities.
                GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
                TaskTrig.wEndDay = wEndDay;
                TaskTrig.wEndMonth = wEndMonth;
                TaskTrig.wEndYear = wEndYear;
            }

            break;

        // Schedule type is Daily
        case SCHED_TYPE_DAILY:
            TaskTrig.TriggerType = TASK_TIME_TRIGGER_DAILY;
            
            TaskTrig.wBeginDay = wStartDay;
            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;

            TaskTrig.wStartHour = wStartHour;
            TaskTrig.wStartMinute = wStartMin;

            if( StringLength(tcresubops.szModifier, 0) > 0 )
            {
                // Set the duration between days to the modifier value specified, if the modifier is specified.
                TaskTrig.Type.Daily.DaysInterval = (WORD) AsLong(tcresubops.szModifier,
                                                                 BASE_TEN);
            }
            else
            {
                // Set value for on which day of the week?
                TaskTrig.Type.Weekly.rgfDaysOfTheWeek = GetTaskTrigwDayForDay(tcresubops.szDays);
                TaskTrig.Type.Weekly.WeeksInterval = 1;
            }

            // Now set end date parameters, if the enddate is specified.
            if(StringLength(tcresubops.szEndDate, 0) > 0)
            {
                // Make end date valid; otherwise the enddate parameter is ignored.
                TaskTrig.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
                // Now set the end date entities.
                GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
                TaskTrig.wEndDay = wEndDay;
                TaskTrig.wEndMonth = wEndMonth;
                TaskTrig.wEndYear = wEndYear;
            }
            // No more settings for a Daily type scheduled item.

            break;

        // Schedule type is Weekly
        case SCHED_TYPE_WEEKLY:
            TaskTrig.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
           
            TaskTrig.Type.Weekly.WeeksInterval = (WORD)AsLong(tcresubops.szModifier, BASE_TEN);

            // Set value for on which day of the week?
            TaskTrig.Type.Weekly.rgfDaysOfTheWeek = GetTaskTrigwDayForDay(tcresubops.szDays);

            TaskTrig.wStartHour = wStartHour;
            TaskTrig.wStartMinute = wStartMin;

            TaskTrig.wBeginDay = wStartDay;
            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;

            // Now set end date parameters, if the enddate is specified.
            if(StringLength(tcresubops.szEndDate, 0) > 0)
            {
                // Make end date valid; otherwise the enddate parameter is ignored.
                TaskTrig.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
                // Now set the end date entities.
                GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
                TaskTrig.wEndDay = wEndDay;
                TaskTrig.wEndMonth = wEndMonth;
                TaskTrig.wEndYear = wEndYear;
            }
            break;

        // Schedule type is Monthly
        case SCHED_TYPE_MONTHLY:

            TaskTrig.wStartHour = wStartHour;
            TaskTrig.wStartMinute = wStartMin;
            TaskTrig.wBeginDay = wStartDay;
            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;

            // Now set end date parameters, if the enddate is specified.
            if(StringLength(tcresubops.szEndDate, 0) > 0)
            {
                // Make end date valid; otherwise the enddate parameter is ignored.
                TaskTrig.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
                // Set the end date entities.
                GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
                TaskTrig.wEndDay = wEndDay;
                TaskTrig.wEndMonth = wEndMonth;
                TaskTrig.wEndYear = wEndYear;
            }
            //Find out from modifier which option like 1 - 12 days
            //or FIRST,SECOND ,THIRD ,.... LAST.
            if(StringLength(tcresubops.szModifier, 0) > 0)
            {
                lMonthlyModifier = AsLong(tcresubops.szModifier, BASE_TEN);

                if(lMonthlyModifier >= 1 && lMonthlyModifier <= 12)
                {
                    if(StringLength(tcresubops.szDays, 0) == 0 )
                    {
                        dwDays  = 1;//default value for days
                    }
                    else
                    {
                        dwDays  = (WORD)AsLong(tcresubops.szDays, BASE_TEN);
                    }

                    TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
                    //set the appropriate day bit in rgfDays
                    TaskTrig.Type.MonthlyDate.rgfDays = (1 << (dwDays -1)) ;
                    TaskTrig.Type.MonthlyDate.rgfMonths = GetMonthId(lMonthlyModifier);
                }
                else
                {

                    if( StringCompare( tcresubops.szModifier , GetResString( IDS_DAY_MODIFIER_LASTDAY ), TRUE, 0 ) == 0)
                    {
                        TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
                        //set the appropriate day bit in rgfDays
                        TaskTrig.Type.MonthlyDate.rgfDays =
                                    (1 << (GetNumDaysInaMonth(tcresubops.szMonths, wStartYear ) -1));
                        TaskTrig.Type.MonthlyDate.rgfMonths = GetTaskTrigwMonthForMonth(
                                                                      tcresubops.szMonths);
                        break;

                    }

                    if( StringCompare(tcresubops.szModifier,
                                 GetResString( IDS_TASK_FIRSTWEEK ), TRUE, 0 ) == 0 )
                    {
                        wWhichWeek = TASK_FIRST_WEEK;
                    }
                    else if( StringCompare(tcresubops.szModifier,
                                      GetResString( IDS_TASK_SECONDWEEK ), TRUE, 0) == 0 )
                    {
                        wWhichWeek = TASK_SECOND_WEEK;
                    }
                    else if( StringCompare(tcresubops.szModifier,
                                      GetResString( IDS_TASK_THIRDWEEK ), TRUE, 0) == 0 )
                    {
                        wWhichWeek = TASK_THIRD_WEEK;
                    }
                    else if( StringCompare(tcresubops.szModifier,
                                      GetResString( IDS_TASK_FOURTHWEEK ), TRUE, 0) == 0 )
                    {
                        wWhichWeek = TASK_FOURTH_WEEK;
                    }
                    else if( StringCompare(tcresubops.szModifier,
                                      GetResString( IDS_TASK_LASTWEEK ), TRUE, 0) == 0 )
                    {
                        wWhichWeek = TASK_LAST_WEEK;
                    }

                    TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;
                    TaskTrig.Type.MonthlyDOW.wWhichWeek = wWhichWeek;
                    TaskTrig.Type.MonthlyDOW.rgfDaysOfTheWeek = GetTaskTrigwDayForDay(
                                                                    tcresubops.szDays);
                    TaskTrig.Type.MonthlyDOW.rgfMonths = GetTaskTrigwMonthForMonth(
                                                                tcresubops.szMonths);

                }
        }
        else
        {
            TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
            TaskTrig.Type.MonthlyDate.rgfMonths = GetTaskTrigwMonthForMonth(
                                                   tcresubops.szMonths);

            dwDays  = (WORD)AsLong(tcresubops.szDays, BASE_TEN);
            if(dwDays > 1)
            {
                //set the appropriate day bit in rgfDays
                TaskTrig.Type.MonthlyDate.rgfDays = (1 << (dwDays -1));
            }
            else
            {
            TaskTrig.Type.MonthlyDate.rgfDays = 1;
            }

        }


        break;

        // Schedule type is Onetime
        case SCHED_TYPE_ONETIME:
            //
            //display a WARNING message if start time is earlier than current time
            //
            //get current time
            GetLocalTime(&systime);
            wCurrentHour = systime.wHour;
            wCurrentMin = systime.wMinute;
            wCurrentYear = systime.wYear;
            wCurrentMonth = systime.wMonth;
            wCurrentDay = systime.wDay;

            if( (FALSE == tcreoptvals.bSetStartDateToCurDate) )
            {
                if( ( wCurrentYear == wStartYear ) )
                {
                    // For same years if the end month is less than start month or for same years and same months
                    // if the endday is less than the startday.
                    if ( ( wStartMonth < wCurrentMonth ) || ( ( wCurrentMonth == wStartMonth ) && ( wStartDay < wCurrentDay ) ) )
                    {
                        bScOnce = TRUE;
                    }
                    else if ( ( wStartMonth > wCurrentMonth ) || ( ( wCurrentMonth == wStartMonth ) && ( wStartDay > wCurrentDay ) ) )
                    {
                        bStartDate = TRUE;
                    }

                }
                else if ( wStartYear < wCurrentYear )
                {
                    bScOnce = TRUE;

                }
                else
                {
                    bStartDate = TRUE;
                }
            }

            // calculate current time in minutes
            // calculate start time in minutes
            dwCurrentTimeInMin = (DWORD) ( wCurrentHour * MINUTES_PER_HOUR * SECS_PER_MINUTE + wCurrentMin * SECS_PER_MINUTE )/ SECS_PER_MINUTE ;

            // calculate start time in minutes
            dwStartTimeInMin = (DWORD) ( wStartHour * MINUTES_PER_HOUR * SECS_PER_MINUTE + wStartMin * SECS_PER_MINUTE )/ SECS_PER_MINUTE ;

            if ( (FALSE == bStartDate ) && ((dwStartTimeInMin < dwCurrentTimeInMin) || (TRUE == bScOnce) ))
            {
                ShowMessage ( stderr, GetResString (IDS_WARN_ST_LESS_CT) );
            }
                    

            TaskTrig.TriggerType = TASK_TIME_TRIGGER_ONCE;
            TaskTrig.wStartHour = wStartHour;
            TaskTrig.wStartMinute = wStartMin;
            TaskTrig.wBeginDay = wStartDay;
            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;
            break;


        // Schedule type is Onlogon
        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:
            if(dwScheduleType == SCHED_TYPE_ONLOGON )
                TaskTrig.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON;
            if(dwScheduleType == SCHED_TYPE_ONSTART )
                TaskTrig.TriggerType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART;

            TaskTrig.wBeginDay = wStartDay;
            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;
            break;

        // Schedule type is Onidle
        case SCHED_TYPE_ONIDLE:

            TaskTrig.TriggerType = TASK_EVENT_TRIGGER_ON_IDLE;
            TaskTrig.wBeginDay = wStartDay;

            TaskTrig.wBeginMonth = wStartMonth;
            TaskTrig.wBeginYear = wStartYear;

            break;

        default:

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tcresubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL;

    }


    if(tcresubops.szTaskName != NULL)
    {
        //remove the .job extension from the task name
        if (ParseTaskName(tcresubops.szTaskName))
        {
            if( pIPF )
            {
                pIPF->Release();
            }

            if( pITaskTrig )
            {
                pITaskTrig->Release();
            }

            if( pITask )
            {
                pITask->Release();
            }

            // close the connection that was established by the utility
            if ( bCloseConnection == TRUE )
                CloseConnection( tcresubops.szServer );

            Cleanup(pITaskScheduler);
            ReleaseMemory(&tcresubops);
            return E_FAIL;
        }
    }

    szValues[0] = (WCHAR*) (tcresubops.szTaskName);

    // set the task trigger
    hr = pITaskTrig->SetTrigger(&TaskTrig);
    if (hr != S_OK)
    {
        ShowMessageEx ( stderr, 1, FALSE, GetResString(IDS_CREATEFAIL_INVALIDARGS), _X(tcresubops.szTaskName));

        if( pIPF )
        {
            pIPF->Release();
        }

        if( pITaskTrig )
        {
            pITaskTrig->Release();
        }

        if( pITask )
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return hr;
    }

    // save the copy of an object
    hr = pIPF->Save(NULL,TRUE);

    if( FAILED(hr) )
    {
        szValues[0] = (WCHAR*) (tcresubops.szTaskName);

        if ( hr == SCHEDULER_NOT_RUNNING_ERROR_CODE )
        {

            StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_SCHEDULER_NOT_RUNNING), _X(tcresubops.szTaskName));
            ShowMessage ( stderr, _X(szBuffer));

        }
        else if ( hr == RPC_SERVER_NOT_AVAILABLE )
        {
            szValues[1] = (WCHAR*) (tcresubops.szServer);

            StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_RPC_SERVER_NOT_AVAIL), _X(tcresubops.szTaskName), _X(tcresubops.szServer));
            ShowMessage ( stderr, _X(szBuffer));

        }
        else
        {

         StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_INVALID_USER), _X(tcresubops.szTaskName));
         ShowMessage ( stderr, _X(szBuffer));
        }

        if(pIPF)
        {
            pIPF->Release();
        }
        if(pITaskTrig)
        {
            pITaskTrig->Release();
        }
        if(pITask)
        {
            pITask->Release();
        }

        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( tcresubops.szServer );

        Cleanup(pITaskScheduler);
        ReleaseMemory(&tcresubops);
        return EXIT_SUCCESS;
    }


    StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), GetResString(IDS_CREATE_SUCCESSFUL), _X(tcresubops.szTaskName));
    ShowMessage ( stdout, _X(szBuffer));

    // Release interface pointers

    if(pIPF)
    {
        pIPF->Release();
    }

    if(pITask)
    {
        pITask->Release();
    }

    if(pITaskTrig)
    {
        pITaskTrig->Release();
    }

    // close the connection that was established by the utility
    if ( bCloseConnection == TRUE )
        CloseConnection( tcresubops.szServer );

    Cleanup(pITaskScheduler);

    //release memory
    ReleaseMemory(&tcresubops);

    return hr;

}

/******************************************************************************
    Routine Description:

        This routine  displays the create option usage

    Arguments:

        None

    Return Value :
        DWORD
******************************************************************************/

DWORD
DisplayCreateUsage()
{
    WCHAR szTmpBuffer[ 2 * MAX_STRING_LENGTH];
    WCHAR szBuffer[ 2 * MAX_STRING_LENGTH];
    WCHAR szFormat[MAX_DATE_STR_LEN];
    WORD    wFormatID = 0;

    // initialize to zero
    SecureZeroMemory ( szTmpBuffer, SIZE_OF_ARRAY(szTmpBuffer));
    SecureZeroMemory ( szBuffer, SIZE_OF_ARRAY(szBuffer));
    SecureZeroMemory ( szFormat, SIZE_OF_ARRAY(szFormat));

    // get the date format
    if ( GetDateFormatString( szFormat) )
    {
         return RETVAL_FAIL;
    }

    // Displaying Create usage
    for( DWORD dw = IDS_CREATE_HLP1; dw <= IDS_CREATE_HLP141; dw++ )
    {
        switch (dw)
        {

         case IDS_CREATE_HLP78:

            StringCchPrintf ( szTmpBuffer, SIZE_OF_ARRAY(szTmpBuffer), GetResString(IDS_CREATE_HLP79), _X(szFormat) );
            StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%s%s%s", GetResString(IDS_CREATE_HLP78), _X(szTmpBuffer), GetResString(IDS_CREATE_HLP80) );
            ShowMessage ( stdout, _X(szBuffer) );
            dw = IDS_CREATE_HLP80;
            break;

        case IDS_CREATE_HLP81:

            StringCchPrintf ( szTmpBuffer, SIZE_OF_ARRAY(szTmpBuffer), GetResString(IDS_CREATE_HLP82), _X(szFormat) );
            StringCchPrintf ( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%s%s", GetResString(IDS_CREATE_HLP81), _X(szTmpBuffer) );
            ShowMessage ( stdout, _X(szBuffer) );
            dw = IDS_CREATE_HLP82;
            break;

         case IDS_CREATE_HLP115:

            // get the date format
            if ( RETVAL_FAIL == GetDateFieldFormat( &wFormatID ))
            {
                return RETVAL_FAIL;
            }

            if ( wFormatID == 0)
            {
                StringCopy (szFormat, GetResString (IDS_MMDDYY_VALUE), SIZE_OF_ARRAY(szFormat) );
            }
            else if ( wFormatID == 1)
            {
                StringCopy (szFormat, GetResString (IDS_DDMMYY_VALUE), SIZE_OF_ARRAY(szFormat));
            }
            else
            {
                StringCopy (szFormat, GetResString (IDS_YYMMDD_VALUE), SIZE_OF_ARRAY(szFormat));
            }

            ShowMessageEx ( stdout, 1, FALSE, GetResString(IDS_CREATE_HLP115), _X(szFormat));

            break;

        default :
                ShowMessage(stdout, GetResString(dw));
                break;

        }

    }

    return EXIT_SUCCESS;
}

/******************************************************************************
    Routine Description:

        This routine validates the options specified by the user & determines
        the type of a scheduled task

    Arguments:

        [ in ]  argc           : The count of arguments given by the user.
        [ in ]  argv           : Array containing the command line arguments.
        [ out ]  tcresubops     : Structure containing Scheduled task's properties.
        [ out ]  tcreoptvals    : Structure containing optional properties to set for a
                                 scheduledtask      .
        [ out ] pdwRetScheType : pointer to the type of a schedule task
                                 [Daily,once,weekly etc].
        [ out ] pbUserStatus   : pointer to check whether the -ru is given in
                                 the command line or not.

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else E_FAIL
        on failure
******************************************************************************/

DWORD
ProcessCreateOptions(
                     IN DWORD argc,
                     IN LPCTSTR argv[],
                     IN OUT TCREATESUBOPTS &tcresubops,
                     IN OUT TCREATEOPVALS &tcreoptvals,
                     OUT DWORD* pdwRetScheType,
                     OUT WORD *pwUserStatus
                     )
{

    DWORD dwScheduleType = 0;
    TCMDPARSER2 cmdCreateOptions[MAX_CREATE_OPTIONS];
    BOOL bReturn = FALSE;

    // /create sub-options
    const WCHAR szCreateOpt[]           = L"create";
    const WCHAR szCreateHelpOpt[]       = L"?";
    const WCHAR szCreateServerOpt[]     = L"s";
    const WCHAR szCreateRunAsUserOpt[]  = L"ru";
    const WCHAR szCreateRunAsPwd[]      = L"rp";
    const WCHAR szCreateUserOpt[]       = L"u";
    const WCHAR szCreatePwdOpt[]        = L"p";
    const WCHAR szCreateSCTypeOpt[]     = L"sc";
    const WCHAR szCreateModifierOpt[]   = L"mo";
    const WCHAR szCreateDayOpt[]        = L"d";
    const WCHAR szCreateMonthsOpt[]     = L"m";
    const WCHAR szCreateIdleTimeOpt[]   = L"i";
    const WCHAR szCreateTaskNameOpt[]   = L"tn";
    const WCHAR szCreateTaskRunOpt[]    = L"tr";
    const WCHAR szCreateStartTimeOpt[]  = L"st";
    const WCHAR szCreateEndTimeOpt[]    = L"et";
    const WCHAR szCreateStartDateOpt[]  = L"sd";
    const WCHAR szCreateEndDateOpt[]    = L"ed";
    const WCHAR szCreateInteractiveOpt[] = L"it";
    const WCHAR szCreateKillAtDurOpt[]   = L"k";
    const WCHAR szCreateDurationOpt[]    = L"du";
    const WCHAR szCreateRepeatOpt[]      = L"ri";
    const WCHAR szCreateDeleteNoSchedOpt[]  = L"z";
    const WCHAR szCreateForceOpt[] = L"f" ;

    // set all the fields to 0
    SecureZeroMemory( cmdCreateOptions, sizeof( TCMDPARSER2 ) * MAX_CREATE_OPTIONS );

    //
    // fill the commandline parser
    //

    //  /create option
    StringCopyA( cmdCreateOptions[ OI_CREATE_OPTION ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_OPTION ].dwType       = CP_TYPE_BOOLEAN;
    cmdCreateOptions[ OI_CREATE_OPTION ].pwszOptions  = szCreateOpt;
    cmdCreateOptions[ OI_CREATE_OPTION ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_OPTION ].dwFlags = 0;
    cmdCreateOptions[ OI_CREATE_OPTION ].pValue = &tcresubops.bCreate;

    //  /? option
    StringCopyA( cmdCreateOptions[ OI_CREATE_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdCreateOptions[ OI_CREATE_USAGE ].pwszOptions  = szCreateHelpOpt;
    cmdCreateOptions[ OI_CREATE_USAGE ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_USAGE ].dwFlags = CP2_USAGE;
    cmdCreateOptions[ OI_CREATE_USAGE ].pValue = &tcresubops.bUsage;

    //  /s option
    StringCopyA( cmdCreateOptions[ OI_CREATE_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_SERVER ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_SERVER ].pwszOptions  = szCreateServerOpt;
    cmdCreateOptions[ OI_CREATE_SERVER ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_SERVER ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /u option
    StringCopyA( cmdCreateOptions[ OI_CREATE_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_USERNAME ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_USERNAME ].pwszOptions  = szCreateUserOpt;
    cmdCreateOptions[ OI_CREATE_USERNAME ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_USERNAME ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /p option
    StringCopyA( cmdCreateOptions[ OI_CREATE_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_PASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_PASSWORD ].pwszOptions  = szCreatePwdOpt;
    cmdCreateOptions[ OI_CREATE_PASSWORD ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_PASSWORD ].dwActuals = 0;
    cmdCreateOptions[ OI_CREATE_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL ;

    //  /ru option
    StringCopyA( cmdCreateOptions[ OI_CREATE_RUNASUSERNAME ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_RUNASUSERNAME ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_RUNASUSERNAME ].pwszOptions  = szCreateRunAsUserOpt;
    cmdCreateOptions[ OI_CREATE_RUNASUSERNAME ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_RUNASUSERNAME ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT ;

    //  /rp option
    StringCopyA( cmdCreateOptions[ OI_CREATE_RUNASPASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_RUNASPASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_RUNASPASSWORD ].pwszOptions  = szCreateRunAsPwd;
    cmdCreateOptions[ OI_CREATE_RUNASPASSWORD ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_RUNASPASSWORD ].dwActuals = 0;
    cmdCreateOptions[ OI_CREATE_RUNASPASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;

    //  /sc option
    StringCopyA( cmdCreateOptions[ OI_CREATE_SCHEDTYPE ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_SCHEDTYPE ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_SCHEDTYPE ].pwszOptions  = szCreateSCTypeOpt;
    cmdCreateOptions[ OI_CREATE_SCHEDTYPE ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_SCHEDTYPE ].dwFlags = CP2_MANDATORY| CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_SCHEDTYPE ].pValue = tcresubops.szSchedType;
    cmdCreateOptions[ OI_CREATE_SCHEDTYPE ].dwLength = MAX_STRING_LENGTH;

     //  /mo option
    StringCopyA( cmdCreateOptions[ OI_CREATE_MODIFIER ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_MODIFIER ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_MODIFIER ].pwszOptions  = szCreateModifierOpt;
    cmdCreateOptions[ OI_CREATE_MODIFIER ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_MODIFIER ].dwFlags =  CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_MODIFIER ].pValue = tcresubops.szModifier;
    cmdCreateOptions[ OI_CREATE_MODIFIER ].dwLength = MAX_STRING_LENGTH;

     //  /d option
    StringCopyA( cmdCreateOptions[ OI_CREATE_DAY ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_DAY ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_DAY ].pwszOptions  = szCreateDayOpt;
    cmdCreateOptions[ OI_CREATE_DAY ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_DAY ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_DAY ].pValue = tcresubops.szDays;
    cmdCreateOptions[ OI_CREATE_DAY ].dwLength = MAX_STRING_LENGTH;

     //  /m option
    StringCopyA( cmdCreateOptions[ OI_CREATE_MONTHS ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_MONTHS ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_MONTHS ].pwszOptions  = szCreateMonthsOpt;
    cmdCreateOptions[ OI_CREATE_MONTHS ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_MONTHS ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_MONTHS ].pValue = tcresubops.szMonths;
    cmdCreateOptions[ OI_CREATE_MONTHS ].dwLength = MAX_STRING_LENGTH;

      //  /i option
    StringCopyA( cmdCreateOptions[ OI_CREATE_IDLETIME ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_IDLETIME ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_IDLETIME ].pwszOptions  = szCreateIdleTimeOpt;
    cmdCreateOptions[ OI_CREATE_IDLETIME ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_IDLETIME ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_IDLETIME ].pValue = tcresubops.szIdleTime;
    cmdCreateOptions[ OI_CREATE_IDLETIME ].dwLength = MAX_STRING_LENGTH;

     //  /tn option
    StringCopyA( cmdCreateOptions[ OI_CREATE_TASKNAME ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_TASKNAME ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_TASKNAME ].pwszOptions  = szCreateTaskNameOpt;
    cmdCreateOptions[ OI_CREATE_TASKNAME ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_TASKNAME ].dwFlags = CP2_MANDATORY;
    cmdCreateOptions[ OI_CREATE_TASKNAME ].pValue = tcresubops.szTaskName;
    cmdCreateOptions[ OI_CREATE_TASKNAME ].dwLength = MAX_JOB_LEN;

     //  /tr option
    StringCopyA( cmdCreateOptions[ OI_CREATE_TASKRUN ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_TASKRUN ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_TASKRUN ].pwszOptions  = szCreateTaskRunOpt;
    cmdCreateOptions[ OI_CREATE_TASKRUN ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_TASKRUN ].dwFlags = CP2_MANDATORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;
    cmdCreateOptions[ OI_CREATE_TASKRUN ].pValue = tcresubops.szTaskRun;
    cmdCreateOptions[ OI_CREATE_TASKRUN ].dwLength = MAX_TASK_LEN;

    //  /st option
    StringCopyA( cmdCreateOptions[ OI_CREATE_STARTTIME ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_STARTTIME ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_STARTTIME ].pwszOptions  = szCreateStartTimeOpt;
    cmdCreateOptions[ OI_CREATE_STARTTIME ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_STARTTIME ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_STARTTIME ].pValue = tcresubops.szStartTime;
    cmdCreateOptions[ OI_CREATE_STARTTIME ].dwLength = MAX_STRING_LENGTH;

     //  /sd option
    StringCopyA( cmdCreateOptions[ OI_CREATE_STARTDATE ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_STARTDATE ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_STARTDATE ].pwszOptions  = szCreateStartDateOpt;
    cmdCreateOptions[ OI_CREATE_STARTDATE ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_STARTDATE ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_STARTDATE ].pValue = tcresubops.szStartDate;
    cmdCreateOptions[ OI_CREATE_STARTDATE ].dwLength = MAX_STRING_LENGTH;

      //  /ed option
    StringCopyA( cmdCreateOptions[ OI_CREATE_ENDDATE ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_ENDDATE ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_ENDDATE ].pwszOptions  = szCreateEndDateOpt;
    cmdCreateOptions[ OI_CREATE_ENDDATE ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_ENDDATE ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_ENDDATE ].pValue = tcresubops.szEndDate;
    cmdCreateOptions[ OI_CREATE_ENDDATE ].dwLength = MAX_STRING_LENGTH;

      //  /it option
    StringCopyA( cmdCreateOptions[ OI_CREATE_LOGON_ACTIVE ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_LOGON_ACTIVE ].dwType       = CP_TYPE_BOOLEAN;
    cmdCreateOptions[ OI_CREATE_LOGON_ACTIVE ].pwszOptions  = szCreateInteractiveOpt;
    cmdCreateOptions[ OI_CREATE_LOGON_ACTIVE ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_LOGON_ACTIVE ].pValue = &tcresubops.bActive;

    //  /et option
    StringCopyA( cmdCreateOptions[ OI_CREATE_ENDTIME ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_ENDTIME ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_ENDTIME ].pwszOptions  = szCreateEndTimeOpt;
    cmdCreateOptions[ OI_CREATE_ENDTIME ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_ENDTIME ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_ENDTIME ].pValue = &tcresubops.szEndTime;
    cmdCreateOptions[ OI_CREATE_ENDTIME ].dwLength = MAX_STRING_LENGTH;

      //  /k option
    StringCopyA( cmdCreateOptions[ OI_CREATE_DUR_END ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_DUR_END ].dwType       = CP_TYPE_BOOLEAN ;
    cmdCreateOptions[ OI_CREATE_DUR_END ].pwszOptions  = szCreateKillAtDurOpt ;
    cmdCreateOptions[ OI_CREATE_DUR_END ].dwCount = 1 ;
    cmdCreateOptions[ OI_CREATE_DUR_END ].pValue = &tcresubops.bIsDurEnd;

    //  /du option
    StringCopyA( cmdCreateOptions[ OI_CREATE_DURATION ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_DURATION ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_DURATION ].pwszOptions  = szCreateDurationOpt;
    cmdCreateOptions[ OI_CREATE_DURATION ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_DURATION ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_DURATION ].pValue = tcresubops.szDuration;
    cmdCreateOptions[ OI_CREATE_DURATION ].dwLength = MAX_STRING_LENGTH;

    //  /ri option
    StringCopyA( cmdCreateOptions[ OI_CREATE_REPEAT_INTERVAL ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_REPEAT_INTERVAL ].dwType       = CP_TYPE_TEXT;
    cmdCreateOptions[ OI_CREATE_REPEAT_INTERVAL ].pwszOptions  = szCreateRepeatOpt;
    cmdCreateOptions[ OI_CREATE_REPEAT_INTERVAL ].dwCount = 1;
    cmdCreateOptions[ OI_CREATE_REPEAT_INTERVAL ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdCreateOptions[ OI_CREATE_REPEAT_INTERVAL ].pValue = tcresubops.szRepeat;
    cmdCreateOptions[ OI_CREATE_REPEAT_INTERVAL ].dwLength = MAX_STRING_LENGTH;

    //  /z option
    StringCopyA( cmdCreateOptions[ OI_CREATE_DELNOSCHED ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_DELNOSCHED ].dwType       = CP_TYPE_BOOLEAN ;
    cmdCreateOptions[ OI_CREATE_DELNOSCHED ].pwszOptions  = szCreateDeleteNoSchedOpt ;
    cmdCreateOptions[ OI_CREATE_DELNOSCHED ].dwCount = 1 ;
    cmdCreateOptions[ OI_CREATE_DELNOSCHED ].pValue = &tcresubops.bIsDeleteNoSched;

    //  /f option
    StringCopyA( cmdCreateOptions[ OI_CREATE_FORCE ].szSignature, "PARSER2\0", 8 );
    cmdCreateOptions[ OI_CREATE_FORCE ].dwType       = CP_TYPE_BOOLEAN ;
    cmdCreateOptions[ OI_CREATE_FORCE ].pwszOptions  = szCreateForceOpt ;
    cmdCreateOptions[ OI_CREATE_FORCE ].dwCount = 1 ;
    cmdCreateOptions[ OI_CREATE_FORCE ].pValue = &tcresubops.bForce;


    //parse command line arguments
    bReturn = DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdCreateOptions), cmdCreateOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        //release memory
        ReleaseMemory(&tcresubops);
        return EXIT_FAILURE;
    }


    // get the buffer pointers allocated by command line parser
    tcresubops.szServer = (LPWSTR)cmdCreateOptions[ OI_CREATE_SERVER ].pValue;
    tcresubops.szUser = (LPWSTR)cmdCreateOptions[ OI_CREATE_USERNAME ].pValue;
    tcresubops.szPassword = (LPWSTR)cmdCreateOptions[ OI_CREATE_PASSWORD ].pValue;
    tcresubops.szRunAsUser = (LPWSTR)cmdCreateOptions[ OI_CREATE_RUNASUSERNAME ].pValue;
    tcresubops.szRunAsPassword = (LPWSTR)cmdCreateOptions[ OI_CREATE_RUNASPASSWORD ].pValue;

    // If -rp is not specified allocate the memory
    if ( cmdCreateOptions[OI_CREATE_RUNASPASSWORD].dwActuals == 0 )
    {
        // password
        if ( tcresubops.szRunAsPassword == NULL )
        {
            tcresubops.szRunAsPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tcresubops.szRunAsPassword == NULL )
            {
                SaveLastError();
                //release memory
                ReleaseMemory(&tcresubops);
                return EXIT_FAILURE;
            }
        }

    }

    if ( (argc > 3) && (tcresubops.bUsage  == TRUE) )
    {
        ShowMessage ( stderr, GetResString (IDS_ERROR_CREATEPARAM) );
        //release memory
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    // Display create usage if user specified -create  -? option
    if( tcresubops.bUsage  == TRUE)
    {
        DisplayCreateUsage();
        //release memory
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    //
    //check for INVALID SYNTAX
    //

    // check for invalid user name
    if( ( cmdCreateOptions[OI_CREATE_SERVER].dwActuals == 0 ) && ( cmdCreateOptions[OI_CREATE_USERNAME].dwActuals == 1 )  )
    {
        ShowMessage(stderr, GetResString(IDS_CREATE_USER_BUT_NOMACHINE));
        //release memory
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    //Determine scheduled type
    if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_MINUTE), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_MINUTE;
    }
    else if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_HOUR), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_HOURLY;
    }
    else if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_DAILY), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_DAILY;
    }
    else if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_WEEK), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_WEEKLY;
    }
    else if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_MONTHLY), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_MONTHLY;
    }
    else if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_ONCE), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_ONETIME;
    }
    else if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_STARTUP), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_ONSTART;
    }
    else if( StringCompare(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_LOGON), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_ONLOGON;
    }
    else if( StringCompare( tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_IDLE), TRUE, 0) == 0 )
    {
        dwScheduleType = SCHED_TYPE_ONIDLE;
    }
    else
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SCHEDTYPE));
        //release memory
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    // check whether /RT is specified for the schedule type minute or hourly
    if ( ( ( dwScheduleType == SCHED_TYPE_MINUTE) || ( dwScheduleType == SCHED_TYPE_HOURLY) ) &&
         ( ( cmdCreateOptions[OI_CREATE_REPEAT_INTERVAL].dwActuals == 1 ) ) )
    {
        // display an error message as .. /RT is not applicable for minute or hourly types..
        ShowMessage ( stderr, GetResString (IDS_REPEAT_NA) );
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    // check whether the options  /RI, /DU, /ST, /SD, /ET, /ED and /K are specified for 
    // the schedule type ONSTRAT, ONIDLE and ONLOGON
    if ( ( ( dwScheduleType == SCHED_TYPE_ONSTART) || ( dwScheduleType == SCHED_TYPE_ONLOGON) || 
           ( dwScheduleType == SCHED_TYPE_ONIDLE) ) && 
         ( ( cmdCreateOptions[OI_CREATE_REPEAT_INTERVAL].dwActuals == 1 ) || 
           ( cmdCreateOptions[OI_CREATE_STARTTIME].dwActuals == 1 ) || ( cmdCreateOptions[OI_CREATE_STARTDATE].dwActuals == 1 ) || 
           ( cmdCreateOptions[OI_CREATE_ENDTIME].dwActuals == 1 ) || ( cmdCreateOptions[OI_CREATE_ENDDATE].dwActuals == 1 ) || 
           ( cmdCreateOptions[OI_CREATE_DURATION].dwActuals == 1 ) || ( cmdCreateOptions[OI_CREATE_DUR_END].dwActuals == 1 ) )
           )
    {
        // display an error message as .. /RT is not applicable for minute or hourly types..
        ShowMessage ( stderr, GetResString (IDS_OPTIONS_NA) );
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    // check whether /SD o /ED is specified for the scheduled type ONETIME
    if( ( dwScheduleType == SCHED_TYPE_ONETIME) && ( cmdCreateOptions[OI_CREATE_ENDDATE].dwActuals == 1 ) )
    {
        // display an error message as.. /SD or /ED is not allowed for ONCE
        ShowMessage(stderr, GetResString(IDS_ONCE_NA_OPTIONS));
        //release memory
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    // check whether /K is specified without specifying either /RT
    if ( (( dwScheduleType != SCHED_TYPE_MINUTE) && ( dwScheduleType != SCHED_TYPE_HOURLY)) && 
        (( cmdCreateOptions[OI_CREATE_ENDTIME].dwActuals == 0 ) && ( cmdCreateOptions[OI_CREATE_DURATION].dwActuals == 0 ) ) &&
        ( cmdCreateOptions[OI_CREATE_DUR_END].dwActuals == 1 ) )
    {
        // display an erroe message as .. /K cannot be specified without specifying either /ET or /DU
        ShowMessage(stderr, GetResString(IDS_NO_ENDTIME));
        //release memory
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    // check whether /ET and /DU specified.. 
    if( ( cmdCreateOptions[OI_CREATE_DURATION].dwActuals == 1 ) && ( cmdCreateOptions[OI_CREATE_ENDTIME].dwActuals == 1 )  )
    {
        // display an error message as.. /ET and /DU are mutual exclusive
        ShowMessage(stderr, GetResString(IDS_DURATION_NOT_ENDTIME));
        //release memory
        ReleaseMemory(&tcresubops);
        return RETVAL_FAIL;
    }

    // Assign the scheduled type to the out parameter.
    *pdwRetScheType = dwScheduleType;

    // To find whether run as user name is given in the cmd line or not

    if( ( cmdCreateOptions[OI_CREATE_SERVER].dwActuals == 1 ) &&
        ( (cmdCreateOptions[OI_CREATE_RUNASUSERNAME].dwActuals == 0) && (cmdCreateOptions[OI_CREATE_USERNAME].dwActuals == 0) ) )
    {
        *pwUserStatus = OI_CREATE_SERVER;
    }
    else if( (cmdCreateOptions[OI_CREATE_RUNASUSERNAME].dwActuals == 1) && (cmdCreateOptions[OI_CREATE_USERNAME].dwActuals == 1) )
    {
        *pwUserStatus = OI_RUNANDUSER;
    }
    else if( cmdCreateOptions[OI_CREATE_RUNASUSERNAME].dwActuals == 1 )
    {
        *pwUserStatus = OI_CREATE_RUNASUSERNAME;
    }
    else if ( cmdCreateOptions[OI_CREATE_USERNAME].dwActuals == 1 )
    {
        *pwUserStatus = OI_CREATE_USERNAME;
    }

    // Start validations for the sub-options
    if( RETVAL_FAIL == ValidateSuboptVal(tcresubops, tcreoptvals, cmdCreateOptions, dwScheduleType) )
    {
        //release memory
        ReleaseMemory(&tcresubops);
        return(RETVAL_FAIL);
    }

    return RETVAL_SUCCESS;

}



/******************************************************************************
    Routine Description:

        This routine splits the input parameters into 2 substrings and returns it.

    Arguments:

        [ in ]  szInput           : Input string.
        [ out ]  szFirstString     : First Output string containing the path of the
                                    file.
        [ out ]  szSecondString     : The second  output containing the paramters.

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else E_FAIL
        on failure
******************************************************************************/

DWORD
ProcessFilePath(
                  IN LPWSTR szInput,
                  OUT LPWSTR szFirstString,
                  OUT LPWSTR szSecondString
                  )
{

    WCHAR *pszSep = NULL ;

    WCHAR szTmpString[MAX_RES_STRING] = L"\0";
    WCHAR szTmpInStr[MAX_RES_STRING] = L"\0";
    WCHAR szTmpOutStr[MAX_RES_STRING] = L"\0";
    WCHAR szTmpString1[MAX_RES_STRING] = L"\0";
    DWORD dwCnt = 0 ;
    DWORD dwLen = 0 ;

#ifdef _WIN64
    INT64 dwPos ;
#else
    DWORD dwPos ;
#endif

    //checking if the input parameters are NULL and if so
    // return FAILURE. This condition will not come
    // but checking for safety sake.

    if( (szInput == NULL) || (StringLength(szInput, 0)==0))
    {
        return RETVAL_FAIL ;
    }

    StringCopy(szTmpString, szInput, SIZE_OF_ARRAY(szTmpString));
    StringCopy(szTmpString1, szInput, SIZE_OF_ARRAY(szTmpString1));
    StringCopy(szTmpInStr, szInput, SIZE_OF_ARRAY(szTmpInStr));

    // check for first double quote (")
    if ( szTmpInStr[0] == _T('\"') )
    {
        // trim the first double quote
        TrimString2( szTmpInStr, _T("\""), TRIM_ALL);

        // check for end double quote
        pszSep  = (LPWSTR)FindChar(szTmpInStr,_T('\"'), 0) ;

        // get the position
        dwPos = pszSep - szTmpInStr + 1;
    }
    else
    {
        // check for the space
        pszSep  = (LPWSTR)FindChar(szTmpInStr, _T(' '), 0) ;

        // get the position
        dwPos = pszSep - szTmpInStr;

    }

    if ( pszSep != NULL )
    {
        szTmpInStr[dwPos] =  _T('\0');
    }
    else
    {
        StringCopy(szFirstString, szTmpString, MAX_RES_STRING);
        StringCopy(szSecondString, L"\0", MAX_RES_STRING);
        return RETVAL_SUCCESS;
    }

    // intialize the variable
    dwCnt = 0 ;

    // get the length of the string
    dwLen = StringLength ( szTmpString, 0 );

    // check for end of string
    while ( ( dwPos <= dwLen )  && szTmpString[dwPos++] != _T('\0') )
    {
        szTmpOutStr[dwCnt++] = szTmpString[dwPos];
    }

    // trim the executable and arguments
    TrimString2( szTmpInStr, _T("\""), TRIM_ALL);
    TrimString2( szTmpInStr, _T(" "), TRIM_ALL);

    StringCopy(szFirstString, szTmpInStr, MAX_RES_STRING);
    StringCopy(szSecondString, szTmpOutStr, MAX_RES_STRING);

    // return success
    return RETVAL_SUCCESS;
}


/******************************************************************************
    Routine Description:

        Release memory

    Arguments:

        [ in ]  pParam           : cmdOptions structure

    Return Value :
         TRUE on success
******************************************************************************/
BOOL
ReleaseMemory(
              IN PTCREATESUBOPTS pParams
              )
{

    // release memory
    FreeMemory((LPVOID *) &pParams->szServer);
    FreeMemory((LPVOID *) &pParams->szUser);
    FreeMemory((LPVOID *) &pParams->szPassword);
    FreeMemory((LPVOID *) &pParams->szRunAsUser);
    FreeMemory((LPVOID *) &pParams->szRunAsPassword);

    //reset all fields to 0
    SecureZeroMemory( &pParams, sizeof( PTCREATESUBOPTS ) );

    return TRUE;

}


DWORD
ConfirmInput (
               OUT BOOL *pbCancel
               )
/*++
   Routine Description:
    This function validates the input given by user.

   Arguments:
        None

   Return Value:
         EXIT_FAILURE :   On failure
         EXIT_SUCCESS  :   On success
--*/

{
    // sub-local variables
    DWORD   dwCharsRead = 0;
    DWORD   dwPrevConsoleMode = 0;
    HANDLE  hInputConsole = NULL;
    BOOL    bIndirectionInput   = FALSE;
    CHAR chAnsi = '\0';
    CHAR szAnsiBuf[ 10 ] = "\0";
    WCHAR chTmp = L'\0';
    WCHAR wch = L'\0';
    DWORD dwCharsWritten = 0;
    WCHAR szBuffer[MAX_RES_STRING];
    WCHAR szBackup[MAX_RES_STRING];
    WCHAR szTmpBuf[MAX_RES_STRING];
    DWORD dwIndex = 0 ;
    BOOL  bNoBreak = TRUE;

    SecureZeroMemory ( szBuffer, SIZE_OF_ARRAY(szBuffer));
    SecureZeroMemory ( szTmpBuf, SIZE_OF_ARRAY(szTmpBuf));
    SecureZeroMemory ( szBackup, SIZE_OF_ARRAY(szBackup));

    // Get the handle for the standard input
    hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
    if ( hInputConsole == INVALID_HANDLE_VALUE  )
    {
        SaveLastError();
        // could not get the handle so return failure
        return EXIT_FAILURE;
    }

    MessageBeep(MB_ICONEXCLAMATION);

    // display the message .. Do you want to continue? ...
    //DISPLAY_MESSAGE ( stdout, GetResString ( IDS_INPUT_DATA ) );

    // Check for the input redirect
    if( ( hInputConsole != (HANDLE)0x0000000F ) &&
        ( hInputConsole != (HANDLE)0x00000003 ) &&
        ( hInputConsole != INVALID_HANDLE_VALUE ) )
    {
        bIndirectionInput   = TRUE;
    }

    // if there is no redirection
    if ( bIndirectionInput == FALSE )
    {
        // Get the current input mode of the input buffer
        if ( FALSE == GetConsoleMode( hInputConsole, &dwPrevConsoleMode ))
        {
            SaveLastError();
            // could not set the mode, return failure
            return EXIT_FAILURE;
        }

        // Set the mode such that the control keys are processed by the system
        if ( FALSE == SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) )
        {
            SaveLastError();
            // could not set the mode, return failure
            return EXIT_FAILURE;
        }
    }

   
    // redirect the data into the console
    if ( bIndirectionInput  == TRUE )
    {
        do {
            //read the contents of file
            if ( ReadFile(hInputConsole, &chAnsi, 1, &dwCharsRead, NULL) == FALSE )
            {
                SaveLastError();
                // could not get the handle so return failure
                return EXIT_FAILURE;
            }

            // check if number of characters read were zero.. or
            // any carriage return pressed..
            if ( dwCharsRead == 0 || chTmp == CARRIAGE_RETURN || chTmp == L'\n' || chTmp == L'\t')
            {
                bNoBreak = FALSE;
                // exit from the loop
                break;
            }
            else
            {
                // convert the ANSI character into UNICODE character
                szAnsiBuf[ 0 ] = chAnsi;
                dwCharsRead = SIZE_OF_ARRAY( szBuffer );
                GetAsUnicodeString2( szAnsiBuf, szBuffer, &dwCharsRead );
                chTmp = szBuffer[ 0 ];
            }

            // write the contents to the console
            if ( FALSE == WriteFile ( GetStdHandle( STD_OUTPUT_HANDLE ), &chTmp, 1, &dwCharsRead, NULL ) )
            {
                SaveLastError();
                // could not get the handle so return failure
                return EXIT_FAILURE;
            }

            // copy the character
            wch = chTmp;

            StringCchPrintf ( szBackup, SIZE_OF_ARRAY(szBackup), L"%c" , wch );

            // increment the index
            dwIndex++;

        } while (TRUE == bNoBreak);

    }
    else
    {
        do {
            // Get the Character and loop accordingly.
            if ( ReadConsole( hInputConsole, &chTmp, 1, &dwCharsRead, NULL ) == FALSE )
            {
                SaveLastError();

                // Set the original console settings
                if ( FALSE == SetConsoleMode( hInputConsole, dwPrevConsoleMode ) )
                {
                    SaveLastError();
                }
                // return failure
                return EXIT_FAILURE;
            }

            // check if number of chars read were zero..if so, continue...
            if ( dwCharsRead == 0 )
            {
                continue;
            }

            // check if any carriage return pressed...
            if ( chTmp == CARRIAGE_RETURN )
            {
                bNoBreak = FALSE;
                // exit from the loop
                break;
            }

            wch = chTmp;

            if ( wch != BACK_SPACE )
            {
                StringCchPrintf ( szTmpBuf, SIZE_OF_ARRAY(szTmpBuf), L"%c" , wch );
                StringConcat ( szBackup, szTmpBuf , SIZE_OF_ARRAY(szBackup));
            }

            // Check id back space is hit
            if ( wch == BACK_SPACE )
            {
                if ( dwIndex != 0 )
                {
                    //
                    // Remove a asterix from the console

                    // move the cursor one character back
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BACK_SPACE );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ) )
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }


                    // replace the existing character with space
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BLANK_CHAR );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ))
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }

                    // now set the cursor at back position
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BACK_SPACE );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ))
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }

                    szBackup [StringLength(szBackup, 0) - 1] = L'\0';
                    // decrement the index
                    dwIndex--;
                }

                // process the next character
                continue;
            }

            // write the contents onto console
            if ( FALSE == WriteFile ( GetStdHandle( STD_OUTPUT_HANDLE ), &wch, 1, &dwCharsRead, NULL ) )
            {
                SaveLastError();
                // return failure
                return EXIT_FAILURE;
            }

            // increment the index value
            dwIndex++;

        } while (TRUE == bNoBreak);

    }

    DISPLAY_MESSAGE(stdout, _T("\n") );

    // check if 'Y' or 'y' is pressed
    if ( ( dwIndex == 1 ) &&
         ( StringCompare ( szBackup, GetResString (IDS_UPPER_YES), TRUE, 0 ) == 0 ) )
    {
        return EXIT_SUCCESS;
    }
    // check if 'N' or 'n' is pressed
    else if ( ( dwIndex == 1 ) &&
              ( StringCompare ( szBackup, GetResString(IDS_UPPER_NO), TRUE, 0 ) == 0 ) )
    {
        *pbCancel = TRUE;
        // display a message as .. operation has been cancelled...
        DISPLAY_MESSAGE ( stdout, GetResString (IDS_OPERATION_CANCELLED ) );
        return EXIT_SUCCESS;
    }
    else
    {
        // display an error message as .. wrong input specified...
        DISPLAY_MESSAGE(stderr, GetResString( IDS_WRONG_INPUT ));
        // Already displayed the ERROR message as above...There is no need to display any
        // success message now.. thats why assigning EXIT_ON_ERROR flag to g_dwRetVal
        return EXIT_FAILURE;
    }

    // return success
    //return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\create.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        create.h

    Abstract:

        This module contains the macros, user defined structures & function
        definitions needed by create.cpp , createvalidations.cpp files.

    Author:

        B.Raghu Babu  10-oct-2000

    Revision History:

        B.Raghu Babu     10-oct-2000 : Created it
        G.Surender Reddy 25-oct-2000 : Modified it
                                       [ Added macro constants,Function
                                        definitions ]

******************************************************************************/

#ifndef __CREATE_H
#define __CREATE_H

#pragma once


// Constants declarations
#define MAX_TASKNAME_LEN    512
#define MAX_USERNAME_LEN    300
#define MAX_TIMESTR_LEN     32
#define MAX_SCHEDTYPE_LEN   32
#define MAX_DATESTR_LEN     32
#define MAX_JOB_LEN         238 //Maximum length of task name
#define MAX_TASK_LEN        262 //Max.length of task run
#define MAX_BUF_SIZE        128 //Maximum buffer size for format message


#define MINUTES_PER_HOUR    60 // Minutes per hour
#define SECS_PER_MINUTE     60 // Minutes per hour
#define HOURS_PER_DAY       24 // Minutes per hour
#define HOURS_PER_DAY_MINUS_ONE  23 // Minutes per hour minus one
#define MAX_MONTH_STR_LEN   60 // Maximum length of months

#define MIN_YEAR        1752 // Minimum year
#define MAX_YEAR        9999 // Maximum year

#define CASE_SENSITIVE_VAL  0  // case sensitive.
#define BASE_TEN            10 // Base value for AsLong ()function.
#define MAX_DATE_STR_LEN    50
#define MAX_TIME_STR_LEN    5
#define MAX_ERROR_STRLEN    2056  // max string len for error messages.

#define OPTION_COUNT        1 // No of times an option can be repeated.(Max)
#define DEFAULT_MODIFIER    1 // Default value for the modifier value.
#define DEFAULT_MODIFIER_SZ    _T("1") // Default value[string] for the modifier value.


#define DATE_SEPARATOR_CHAR         _T('/')
#define DATE_SEPARATOR_STR          _T("/")
#define FIRST_DATESEPARATOR_POS     2
#define SECOND_DATESEPARATOR_POS    5
#define FOURTH_DATESEPARATOR_POS    4
#define SEVENTH_DATESEPARATOR_POS   7

#define SCHEDULER_NOT_RUNNING_ERROR_CODE    0x80041315
#define UNABLE_TO_ESTABLISH_ACCOUNT         0x80041310
#define RPC_SERVER_NOT_AVAILABLE            0x800706B5

#define DATESTR_LEN                 10
#define MAX_TOKENS_LENGTH               60

#define MIN_REPETITION_INTERVAL     1
#define MAX_REPETITION_INTERVAL     599940

#define TIME_SEPARATOR_CHAR    _T(':')
#define TIME_SEPARATOR_STR    _T(":")
#define FIRST_TIMESEPARATOR_POS     2
#define SECOND_TIMESEPARATOR_POS    5
#define TIMESTR_LEN                 5
#define HOURSPOS_IN_TIMESTR         1
#define MINSPOS_IN_TIMESTR          2
#define SECSPOS_IN_TIMESTR          3
#define EXE_LENGTH                  4
#define TIMESTR_OPT_LEN             8

#define MAX_CREATE_OPTIONS    24

#define OI_CREATE_OPTION           0 // Index of -create option in cmdOptions structure.
#define OI_CREATE_USAGE            1 // Index of -? option in cmdOptions structure.
#define OI_CREATE_SERVER           2 // Index of -s option in cmdOptions structure.
#define OI_CREATE_USERNAME         3 // Index of -u option in cmdOptions structure.
#define OI_CREATE_PASSWORD         4 // Index of -p option in cmdOptions structure.
#define OI_CREATE_RUNASUSERNAME    5 // Index of -ru option in cmdOptions structure.
#define OI_CREATE_RUNASPASSWORD    6 // Index of -rp option in cmdOptions structure.
#define OI_CREATE_SCHEDTYPE        7 // Index of -scheduletype option in cmdOptions structure.
#define OI_CREATE_MODIFIER         8 // Index of -modifier option in cmdOptions structure.
#define OI_CREATE_DAY              9 // Index of -day option in cmdOptions structure.
#define OI_CREATE_MONTHS           10// Index of -months option in cmdOptions structure.
#define OI_CREATE_IDLETIME         11 // Index of -idletime option in cmdOptions structure.
#define OI_CREATE_TASKNAME         12 // Index of -taskname option in cmdOptions structure.
#define OI_CREATE_TASKRUN          13 // Index of -taskrun option in cmdOptions structure.
#define OI_CREATE_STARTTIME        14 // Index of -starttime option in cmdOptions structure.
#define OI_CREATE_STARTDATE        15 // Index of -startdate option in cmdOptions structure.
#define OI_CREATE_ENDDATE          16 // Index of -enddate option in cmdOptions structure.
#define OI_CREATE_LOGON_ACTIVE     17 // Index of -it option in cmdOptions structure.
#define OI_CREATE_ENDTIME          18 // Index of -endtime option in cmdOptions structure.
#define OI_CREATE_DUR_END          19 // Index of -k option in cmdOptions structure.
#define OI_CREATE_DURATION         20 // Index of -du option in cmdOptions structure.
#define OI_CREATE_REPEAT_INTERVAL  21 // Index of -ri option in cmdOptions structure.
#define OI_CREATE_DELNOSCHED       22 // Index of -z option in cmdOptions structure.
#define OI_CREATE_FORCE            23 // Index of -f option in cmdOptions structure.


#define OI_RUNANDUSER       6

// Schedule Types
#define SCHED_TYPE_MINUTE   1
#define SCHED_TYPE_HOURLY   2
#define SCHED_TYPE_DAILY    3
#define SCHED_TYPE_WEEKLY   4
#define SCHED_TYPE_MONTHLY  5
#define SCHED_TYPE_ONETIME  6
#define SCHED_TYPE_ONSTART  7
#define SCHED_TYPE_ONLOGON  8
#define SCHED_TYPE_ONIDLE   9

// Months Indices.
#define IND_JAN         1  // January
#define IND_FEB         2  // February
#define IND_MAR         3  // March
#define IND_APR         4  // April
#define IND_MAY         5  // May
#define IND_JUN         6  // June
#define IND_JUL         7  // July
#define IND_AUG         8  // August
#define IND_SEP         9  // September
#define IND_OCT         10 // October
#define IND_NOV         11 // November
#define IND_DEC         12 // December


// Return Values
#define RETVAL_SUCCESS      0
#define RETVAL_FAIL         1

typedef struct __tagCreateSubOps
{
    WCHAR   *szServer ;        // Server Name
    WCHAR   *szRunAsUser ;     //Run As User Name
    WCHAR   *szRunAsPassword;  // Run As Password
    WCHAR   *szUser ;      // User Name
    WCHAR   *szPassword ;  // Password
    WCHAR   szSchedType[MAX_STRING_LENGTH];   // Schedule Type
    WCHAR   szModifier[MAX_STRING_LENGTH] ;   // Modifier Value
    WCHAR   szDays[MAX_STRING_LENGTH] ;       // Days
    WCHAR   szMonths [MAX_STRING_LENGTH];     // Months
    WCHAR   szIdleTime[MAX_STRING_LENGTH] ;   // Idle Time
    WCHAR   szTaskName [ MAX_JOB_LEN];        // Task Name
    WCHAR   szStartTime[MAX_STRING_LENGTH] ;  // Task start time
    WCHAR   szEndTime [MAX_STRING_LENGTH];    // Task end time
    WCHAR   szStartDate [MAX_STRING_LENGTH];  // Task start date
    WCHAR   szEndDate [MAX_STRING_LENGTH];    // End Date of the Task
    WCHAR   szTaskRun [MAX_TASK_LEN];         // executable name of task
    WCHAR   szDuration [MAX_STRING_LENGTH];   //duration
    WCHAR   szRepeat [MAX_STRING_LENGTH];   //duration
    DWORD   bCreate; // Create option
    DWORD   bUsage;  // Usage option.
    BOOL    bActive; // /it option
    BOOL    bIsDurEnd; // /du option
    BOOL    bIsDeleteNoSched; // /z option
    BOOL    bForce; // /f option
    BOOL    bInMinutes; // /it option
    BOOL    bInHours; // /du option

} TCREATESUBOPTS, *PTCREATESUBOPTS;


typedef struct __tagCreateOpsVals
{
    BOOL    bSetStartDateToCurDate; // Is start date to be set to current date
    BOOL    bSetStartTimeToCurTime; // Is start date to be set to current date
    BOOL    bPassword;
    BOOL    bRunAsPassword;

} TCREATEOPVALS;


DWORD DisplayCreateUsage();
HRESULT CreateTask(TCREATESUBOPTS tcresubops, TCREATEOPVALS &tcreoptvals,
                        DWORD dwScheduleType, WORD wUserStatus );
DWORD ProcessCreateOptions(DWORD argc, LPCTSTR argv[],TCREATESUBOPTS &tcresubops,
            TCREATEOPVALS &tcreoptvals, DWORD* pdwRetScheType, WORD *pwUserStatus );
DWORD ValidateSuboptVal(TCREATESUBOPTS& tcresubops, TCREATEOPVALS &tcreoptvals,
                        TCMDPARSER2 cmdOptions[], DWORD dwScheduleType);
DWORD ValidateRemoteSysInfo(
            TCMDPARSER2 cmdOptions[] , TCREATESUBOPTS& tcresubops, TCREATEOPVALS &tcreoptvals);
DWORD ValidateModifierVal(LPCTSTR szModifier, DWORD dwScheduleType,
                          DWORD dwModOptActCnt, DWORD dwDayOptCnt,
                          DWORD dwMonOptCnt, BOOL &bIsDefltValMod);
DWORD ValidateDayAndMonth(LPWSTR szDay, LPWSTR szMonths, DWORD dwSchedType,
    DWORD dwDayOptCnt, DWORD dwMonOptCnt, DWORD dwModifier,LPWSTR szModifier);
DWORD ValidateStartDate(LPWSTR szStartDate, DWORD dwSchedType, DWORD dwStDtOptCnt,
                        BOOL &bIsCurrentDate);
DWORD ValidateEndDate(LPWSTR szEndDate, DWORD dwSchedType, DWORD dwEndDtOptCnt);
DWORD ValidateStartTime(LPWSTR szStartTime, DWORD dwSchedType, DWORD dwStTimeOptCnt,
                        BOOL &bIsCurrentTime);
DWORD ValidateEndTime(LPWSTR szEndTime, DWORD dwSchedType, DWORD dwEndTimeOptCnt );
DWORD ValidateIdleTimeVal(LPWSTR szIdleTime, DWORD dwSchedType,
                          DWORD dwIdlTimeOptCnt);
DWORD ValidateDateString(LPWSTR szDate, BOOL bStartDate );
DWORD ValidateTimeString(LPWSTR szTime);
DWORD GetDateFieldEntities(LPWSTR szDate, WORD* pdwDate, WORD* pdwMon,
                           WORD* pdwYear);
DWORD ValidateDateFields( DWORD dwDate, DWORD dwMon, DWORD dwyear);
DWORD GetTimeFieldEntities(LPWSTR szTime, WORD* pdwHours, WORD* pdwMins );
DWORD ValidateTimeFields( DWORD dwHours, DWORD dwMins );
WORD GetTaskTrigwDayForDay(LPWSTR szDay);
WORD GetTaskTrigwMonthForMonth(LPWSTR szMonth);
DWORD ValidateMonth(LPWSTR szMonths);
DWORD ValidateDay(LPWSTR szDays);
WORD GetMonthId(DWORD dwMonthId);
DWORD GetNumDaysInaMonth(WCHAR* szMonths, WORD wStartYear);
BOOL VerifyJobName(WCHAR* pszJobName);
DWORD GetDateFieldFormat(WORD* pdwDate);
DWORD GetDateFormatString(LPWSTR szFormat);
DWORD ProcessFilePath(LPWSTR szInput,LPWSTR szFirstString,LPWSTR szSecondString);
BOOL  ReleaseMemory(PTCREATESUBOPTS pParams);
DWORD ConfirmInput ( BOOL *bCancel );


#endif // __CREATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\createvalidations.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        CreateValidations.cpp

    Abstract:

        This module validates the various -create sub options specified by the user

    Author:

        B.Raghu babu  20-Sept-2000 : Created

    Revision History:

        G.Surender Reddy  25-sep-2000 : Modified it
                                       [ Added error checking ]

        G.Surender Reddy  10-Oct-2000 : Modified it
                                        [ made changes in validatemodifierval(),
                                          ValidateDayAndMonth() functions ]


        G.Surender Reddy 15-oct-2000 : Modified it
                                       [ Moved the strings to Resource table ]

        Venu Gopal S     26-Feb-2001 : Modified it
                                       [ Added GetDateFormatString(),
                                         GetDateFieldFormat() functions to
                                         gets the date format according to
                                         regional options]

******************************************************************************/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

/******************************************************************************
    Routine Description:

        This routine validates the sub options specified by the user  reg.create option
        & determines the type of a scheduled task.

    Arguments:

        [ out ] tcresubops     : Structure containing the task's properties
        [ out ] tcreoptvals    : Structure containing optional values to set
        [ in ] cmdOptions[]   : Array of type TCMDPARSER
        [ in ] dwScheduleType : Type of schedule[Daily,once,weekly etc]

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
        on failure
******************************************************************************/

DWORD
ValidateSuboptVal(
                  OUT TCREATESUBOPTS& tcresubops,
                  OUT TCREATEOPVALS &tcreoptvals,
                  IN TCMDPARSER2 cmdOptions[],
                  IN DWORD dwScheduleType
                  )
{
    DWORD   dwRetval = RETVAL_SUCCESS;
    BOOL    bIsStDtCurDt = FALSE;
    BOOL    bIsStTimeCurTime = FALSE;
    BOOL    bIsDefltValMod = FALSE;

    // Validate whether -s, -u, -p options specified correctly or not.
    //Accept password if -p not specified.
    dwRetval = ValidateRemoteSysInfo( cmdOptions, tcresubops, tcreoptvals);
    if(RETVAL_FAIL == dwRetval )
    {
        return dwRetval; // Error.
    }

    // Validate Modifier value.
    dwRetval = ValidateModifierVal( tcresubops.szModifier, dwScheduleType,
                                       cmdOptions[OI_CREATE_MODIFIER].dwActuals,
                                       cmdOptions[OI_CREATE_DAY].dwActuals,
                                       cmdOptions[OI_CREATE_MONTHS].dwActuals,
                                       bIsDefltValMod);
    if(RETVAL_FAIL == dwRetval )
    {

        return dwRetval; // error in modifier value
    }
    else
    {
        if(bIsDefltValMod)
        {
            StringCopy(tcresubops.szModifier,DEFAULT_MODIFIER_SZ, SIZE_OF_ARRAY(tcresubops.szModifier));
        }
    }

    // Validate Day and Month strings
    dwRetval = ValidateDayAndMonth( tcresubops.szDays, tcresubops.szMonths,
                                        dwScheduleType,
                                        cmdOptions[OI_CREATE_DAY].dwActuals,
                                        cmdOptions[OI_CREATE_MONTHS].dwActuals,
                                        cmdOptions[OI_CREATE_MODIFIER].dwActuals,
                                        tcresubops.szModifier);
    if(RETVAL_FAIL == dwRetval )
    {
        return dwRetval; // Error found in Day/Month string.
    }

    // Validate Start Date value.
    dwRetval = ValidateStartDate( tcresubops.szStartDate, dwScheduleType,
                                      cmdOptions[OI_CREATE_STARTDATE].dwActuals,
                                      bIsStDtCurDt);
    if(RETVAL_FAIL == dwRetval )
    {
        return dwRetval; // Error in Day/Month string.
    }
    else
    {
        if(bIsStDtCurDt) // Set start date to current date.
        {
            tcreoptvals.bSetStartDateToCurDate = TRUE;
        }
    }

    // Validate End Date value.
    dwRetval = ValidateEndDate( tcresubops.szEndDate, dwScheduleType,
                                    cmdOptions[OI_CREATE_ENDDATE].dwActuals);
    if(RETVAL_FAIL == dwRetval )
    {
        return dwRetval; // Error in Day/Month string.
    }

    //Check Whether end date should be greater than startdate

    WORD wEndDay = 0;
    WORD wEndMonth = 0;
    WORD wEndYear = 0;
    WORD wStartDay = 0;
    WORD wStartMonth = 0;
    WORD wStartYear = 0;

    if( cmdOptions[OI_CREATE_ENDDATE].dwActuals != 0 )
    {
        if( RETVAL_FAIL == GetDateFieldEntities( tcresubops.szEndDate,&wEndDay,
                                                &wEndMonth,&wEndYear))
        {
            return RETVAL_FAIL;
        }
    }

    SYSTEMTIME systime = {0,0,0,0,0,0,0,0};

    if(bIsStDtCurDt)
    {
        GetLocalTime(&systime);
        wStartDay = systime.wDay;
        wStartMonth = systime.wMonth;
        wStartYear = systime.wYear;
    }
    else if( ( cmdOptions[OI_CREATE_STARTDATE].dwActuals != 0 ) &&
        (RETVAL_FAIL == GetDateFieldEntities(tcresubops.szStartDate,
                                                 &wStartDay,&wStartMonth,
                                                 &wStartYear)))
    {
        return RETVAL_FAIL;
    }

    if( (cmdOptions[OI_CREATE_ENDDATE].dwActuals != 0) )
    {
        if( ( wEndYear == wStartYear ) )
        {
            // For same years if the end month is less than start month or for same years and same months
            // if the endday is less than the startday.
            if ( ( wEndMonth < wStartMonth ) || ( ( wEndMonth == wStartMonth ) && ( wEndDay < wStartDay ) ) )
            {
                ShowMessage(stderr, GetResString(IDS_ENDATE_INVALID));
                return RETVAL_FAIL;
            }


        }
        else if ( wEndYear < wStartYear )
        {
            ShowMessage(stderr, GetResString(IDS_ENDATE_INVALID));
            return RETVAL_FAIL;

        }
    }

    // Validate Start Time value.
    dwRetval = ValidateStartTime( tcresubops.szStartTime, dwScheduleType,
                                      cmdOptions[OI_CREATE_STARTTIME].dwActuals,
                                      bIsStTimeCurTime);
    if ( RETVAL_FAIL == dwRetval )
    {
        return dwRetval; // Error found in starttime.
    }
    else
    {
        if(bIsStTimeCurTime)
        {
            tcreoptvals.bSetStartTimeToCurTime = TRUE;
        }
    }

    // Validate End Time value.
    dwRetval = ValidateEndTime( tcresubops.szEndTime, dwScheduleType,
                                      cmdOptions[OI_CREATE_ENDTIME].dwActuals);
    if ( RETVAL_FAIL == dwRetval )
    {
        return dwRetval; // Error found in endtime.
    }

    // Validate Idle Time value.
    dwRetval = ValidateIdleTimeVal( tcresubops.szIdleTime, dwScheduleType,
                                        cmdOptions[OI_CREATE_IDLETIME].dwActuals);
    if ( RETVAL_FAIL == dwRetval )
    {

        return dwRetval;
    }

    return RETVAL_SUCCESS;
}

/******************************************************************************
    Routine Description:

        Checks whether password to be prompted for remote system or not.

    Arguments:

        [ in ] szServer   : Server name
        [ in ] szUser     : User name
        [ in ] szPassword : Password
        [ in ] cmdOptions : TCMDPARSER Array containg the options given by the user
        [ in ] tcreoptvals: Structure containing optional values to set

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
        on failure
******************************************************************************/

DWORD
ValidateRemoteSysInfo(
                            IN TCMDPARSER2 cmdOptions[],
                            IN TCREATESUBOPTS& tcresubops,
                            IN TCREATEOPVALS& tcreoptvals
                            )
{

    BOOL bIsLocalSystem = FALSE;

    // "-rp" should not be specified without "-ru"
    if ( ( ( cmdOptions[ OI_CREATE_RUNASUSERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_CREATE_RUNASPASSWORD ].dwActuals == 1 ) ) ||
        ( ( cmdOptions[ OI_CREATE_USERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_CREATE_PASSWORD ].dwActuals == 1 ) ) ||
        ( ( cmdOptions[ OI_CREATE_USERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_CREATE_RUNASPASSWORD ].dwActuals == 1 ) && ( cmdOptions[ OI_CREATE_PASSWORD ].dwActuals == 1 ) ) ||
        ( ( cmdOptions[ OI_CREATE_RUNASUSERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_CREATE_RUNASPASSWORD ].dwActuals == 1 ) && ( cmdOptions[ OI_CREATE_PASSWORD ].dwActuals == 1 ) ) ||
        ( ( cmdOptions[ OI_CREATE_USERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_CREATE_RUNASUSERNAME ].dwActuals == 0 )  &&
         ( cmdOptions[ OI_CREATE_RUNASPASSWORD ].dwActuals == 1 ) && ( cmdOptions[ OI_CREATE_PASSWORD ].dwActuals == 1 ) ) )
    {
        // invalid syntax
        ShowMessage(stderr, GetResString(IDS_CPASSWORD_BUT_NOUSERNAME));
        return RETVAL_FAIL;         // indicate failure
    }

    tcreoptvals.bPassword = FALSE;

    bIsLocalSystem = IsLocalSystem( tcresubops.szServer );
    if ( TRUE == bIsLocalSystem )
    {
        tcreoptvals.bPassword = FALSE;
    }

    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( tcresubops.szServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( tcresubops.szUser == NULL )
        {
            tcresubops.szUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tcresubops.szUser == NULL )
            {
                SaveLastError();
                return RETVAL_FAIL;
            }
        }

        // password
        if ( tcresubops.szPassword == NULL )
        {
            tcreoptvals.bPassword = TRUE;
            tcresubops.szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( tcresubops.szPassword == NULL )
            {
                SaveLastError();
                return RETVAL_FAIL;
            }
        }

        // case 1
        if ( cmdOptions[ OI_CREATE_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ OI_CREATE_PASSWORD ].pValue == NULL )
        {
            StringCopy( tcresubops.szPassword, L"*", GetBufferSize(tcresubops.szPassword)/sizeof(WCHAR));
        }

        // case 3
        else if ( StringCompareEx( tcresubops.szPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&tcresubops.szPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                return RETVAL_FAIL;
            }

            // ...
            tcreoptvals.bPassword = TRUE;
        }
    }


    if( ( cmdOptions[ OI_CREATE_RUNASPASSWORD ].dwActuals == 1 ) )
    {
        tcreoptvals.bRunAsPassword = TRUE;


        if ( cmdOptions[ OI_CREATE_RUNASPASSWORD ].pValue == NULL )
        {

            tcresubops.szRunAsPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( NULL == tcresubops.szRunAsPassword)
            {
                SaveLastError();
                return RETVAL_FAIL;
            }
            StringCopy( tcresubops.szRunAsPassword, L"*", GetBufferSize(tcresubops.szRunAsPassword)/sizeof(WCHAR));
        }
    }


    return RETVAL_SUCCESS;
}

/******************************************************************************
    Routine Description:

        This routine validates & determines the modifier value .

    Arguments:

        [ in ] szModifier        : Modifer value
        [ in ] dwScheduleType  : Type of schedule[Daily,once,weekly etc]
        [ in ] dwModOptActCnt  : Modifier optional value
        [ in ] dwDayOptCnt     :   Days value
        [ in ] dwMonOptCnt     : Months value
        [ out ] bIsDefltValMod : Whether default value should be given for modifier

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
        on failure
******************************************************************************/

DWORD
ValidateModifierVal(
                    IN LPCTSTR szModifier,
                    IN DWORD dwScheduleType,
                    IN DWORD dwModOptActCnt,
                    IN DWORD dwDayOptCnt,
                    IN DWORD dwMonOptCnt,
                    OUT BOOL& bIsDefltValMod
                    )
{

    WCHAR szDayType[MAX_RES_STRING] = L"\0";
    ULONG dwModifier = 0;

    StringCopy(szDayType,GetResString(IDS_TASK_FIRSTWEEK), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,_T("|"), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,GetResString(IDS_TASK_SECONDWEEK), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,_T("|"), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,GetResString(IDS_TASK_THIRDWEEK), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,_T("|"), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,GetResString(IDS_TASK_FOURTHWEEK), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,_T("|"), SIZE_OF_ARRAY(szDayType));
    StringConcat(szDayType,GetResString(IDS_TASK_LASTWEEK), SIZE_OF_ARRAY(szDayType));


    bIsDefltValMod = FALSE; // If TRUE : Set modifier to default value, 1.
    LPWSTR pszStopString = NULL;


    switch( dwScheduleType )
    {

        case SCHED_TYPE_MINUTE:   // Schedule type is Minute

            if( (dwModOptActCnt <= 0) || (StringLength(szModifier, 0) <= 0) )
            {

                bIsDefltValMod = TRUE;
                return RETVAL_SUCCESS;
            }

            dwModifier = wcstoul(szModifier,&pszStopString,BASE_TEN);

            // check whether alpha-numneric value specified or not..
            // Also, check for underflow/overflow.
            if( (errno == ERANGE) ||
                ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
             {
                break;
             }


            if( dwModifier > 0 && dwModifier < 1440 ) // Valid Range 1 - 1439
                return RETVAL_SUCCESS;

            break;

        // Schedule type is Hourly
        case SCHED_TYPE_HOURLY:

            if( (dwModOptActCnt <= 0) || (StringLength(szModifier, 0) <= 0) )
            {

                bIsDefltValMod = TRUE;
                return RETVAL_SUCCESS;
            }


            dwModifier = wcstoul(szModifier,&pszStopString,BASE_TEN);

            // check whether alpha-numneric value specified or not..
            // Also, check for underflow/overflow.
            if( (errno == ERANGE) ||
                ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
             {
                break;
             }

            if( dwModifier > 0 && dwModifier < 24 ) // Valid Range 1 - 23
            {
                return RETVAL_SUCCESS;
            }

            break;

        // Schedule type is Daily
        case SCHED_TYPE_DAILY:
            // -days option is NOT APPLICABLE for DAILY type item.

            if( (dwDayOptCnt > 0) )
            {// Invalid sysntax. Return error
                // Modifier option and days options both should not specified same time.
                bIsDefltValMod = FALSE;
                ShowMessage(stderr, GetResString(IDS_DAYS_NA));
                return RETVAL_FAIL;
            }

            // -months option is NOT APPLICABLE for DAILY type item.
            if( dwMonOptCnt > 0 )
            {// Invalid sysntax. Return error
                // Modifier option and days options both should not specified same time.
                bIsDefltValMod = FALSE;
                ShowMessage(stderr , GetResString(IDS_MON_NA));
                return RETVAL_FAIL;
            }

            // Check whether the -modifier switch is psecified. If not, then take default value.
            if( (dwModOptActCnt <= 0) || (StringLength(szModifier, 0) <= 0) )
            {
                // Modifier options is not specified. So, set it to default value. (i.e, 1 )
                bIsDefltValMod = TRUE;
                return RETVAL_SUCCESS;
            }

            dwModifier = wcstoul(szModifier,&pszStopString,BASE_TEN);

            // check whether alpha-numneric value specified or not..
            // Also, check for underflow/overflow.
            if( (errno == ERANGE) ||
                ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
             {
                break;
             }

            // If the -modifier option is specified, then validate the value.
            if( dwModifier > 0 && dwModifier < 366 ) // Valid Range 1 - 365
            {
                return RETVAL_SUCCESS;
            }
            else
            {
                ShowMessage(stderr, GetResString(IDS_INVALID_MODIFIER));
                return RETVAL_FAIL;
            }

            break;

        // Schedule type is Weekly
        case SCHED_TYPE_WEEKLY:

            // If -modifier option is not specified, then set it to default value.
            if( (dwModOptActCnt <= 0) || (StringLength(szModifier, 0) <= 0) )
            {
                // Modifier options is not specified. So, set it to default value. (i.e, 1 )
                bIsDefltValMod = TRUE;
                return RETVAL_SUCCESS;
            }


            if( dwModOptActCnt > 0)
            {
                dwModifier = wcstoul(szModifier,&pszStopString,BASE_TEN);
                // check whether alpha-numneric value specified or not..
                // Also, check for underflow/overflow.
                if( (errno == ERANGE) ||
                    ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
                 {
                    break;
                 }

                if( dwModifier > 0 && dwModifier < 53 ) // Valid Range 1 - 52
                    return RETVAL_SUCCESS;

                break;
            }

            break;

        // Schedule type is Monthly
        case SCHED_TYPE_MONTHLY:

            // If -modifier option is not specified, then set it to default value.
            if( ( dwModOptActCnt > 0) && (StringLength(szModifier, 0) == 0) )
            {
                // Modifier option is not proper. So display error and return false.
                bIsDefltValMod = FALSE;
                ShowMessage(stderr, GetResString(IDS_INVALID_MODIFIER));
                return RETVAL_FAIL;
            }
            //check if the modifier is LASTDAY[not case sensitive]
            if( StringCompare( szModifier , GetResString( IDS_DAY_MODIFIER_LASTDAY ), TRUE, 0 ) == 0)
                return RETVAL_SUCCESS;

            //Check if -mo is in between FIRST,SECOND ,THIRD, LAST
            //then -days[ MON to SUN ] is applicable , -months is also applicable

            if( InString ( szModifier , szDayType , TRUE ) )
            {
                return RETVAL_SUCCESS;

            }
            else
            {

                dwModifier = wcstoul(szModifier,&pszStopString,BASE_TEN);
                if( (errno == ERANGE) ||
                ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
                 {
                    break;
                 }

                if( ( dwModOptActCnt == 1 ) && ( dwModifier < 1 || dwModifier > 12 ) ) //check whether -mo value is in between 1 - 12
                {
                    //invalid -mo value
                    ShowMessage(stderr, GetResString(IDS_INVALID_MODIFIER));
                    return RETVAL_FAIL;
                }

                return RETVAL_SUCCESS;
            }

            break;

        case SCHED_TYPE_ONETIME:
        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:
        case SCHED_TYPE_ONIDLE:

            if( dwModOptActCnt <= 0 )
            {
                // Modifier option is not applicable. So, return success.
                bIsDefltValMod = FALSE;
                return RETVAL_SUCCESS;
            }
            else
            {
                // Modifier option is not applicable. But specified. So, return error.
                bIsDefltValMod = FALSE;
                ShowMessage(stderr, GetResString(IDS_MODIFIER_NA));
                return RETVAL_FAIL;
            }
            break;

        default:
            return RETVAL_FAIL;

    }

    // Modifier option is not proper. So display error and return false.
    bIsDefltValMod = FALSE;
    ShowMessage(stderr, GetResString(IDS_INVALID_MODIFIER));

    return RETVAL_FAIL;
}

/******************************************************************************
    Routine Description:

        This routine validates & determines the day,month value .

    Arguments:

        [ in ] szDay         : Day value
        [ in ] szMonths      : Months[Daily,once,weekly etc]
        [ in ] dwSchedType   : Modifier optional value
        [ in ] dwDayOptCnt   : Days option  value
        [ in ] dwMonOptCnt   : Months option value
        [ in ] dwOptModifier : Modifier option value
        [ in ] szModifier    : Whether default value for modifier

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
        on failure
******************************************************************************/

DWORD
ValidateDayAndMonth(
                    IN LPWSTR szDay,
                    IN LPWSTR szMonths,
                    IN DWORD dwSchedType,
                    IN DWORD dwDayOptCnt,
                    IN DWORD dwMonOptCnt,
                    IN DWORD dwOptModifier,
                    IN LPWSTR szModifier
                    )
{

    DWORD   dwRetval = 0;
    DWORD   dwModifier = 0;
    DWORD   dwDays = 0;
    WCHAR  szDayModifier[MAX_RES_STRING]  = L"\0";

    //get the valid  week day modifiers from the rc file
    StringCopy(szDayModifier,GetResString(IDS_TASK_FIRSTWEEK), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_TASK_SECONDWEEK), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_TASK_THIRDWEEK), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_TASK_FOURTHWEEK), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_TASK_LASTWEEK), SIZE_OF_ARRAY(szDayModifier));

    switch (dwSchedType)
    {
        case SCHED_TYPE_DAILY:
            // -days and -months optons is not applicable. SO, check for it.
            if( dwDayOptCnt > 0 || dwMonOptCnt > 0)
            {
                return RETVAL_FAIL;
            }

            return RETVAL_SUCCESS;

        case SCHED_TYPE_MONTHLY:

            if( dwMonOptCnt > 0 && StringLength(szMonths, 0) == 0)
            {
                    ShowMessage(stderr, GetResString(IDS_INVALID_MONTH_MODFIER));
                    return RETVAL_FAIL;
            }

            //if the modifier is LASTDAY
            if( StringCompare( szModifier , GetResString( IDS_DAY_MODIFIER_LASTDAY ), TRUE, 0 ) == 0)
            {
                //-day is not applicable for this case only -months is applicable
                if( dwDayOptCnt > 0 )
                {
                    ShowMessage(stderr, GetResString(IDS_DAYS_NA));
                    return RETVAL_FAIL;
                }

                if(StringLength(szMonths, 0))
                {

                    if( ( ValidateMonth( szMonths ) == RETVAL_SUCCESS ) ||
                        InString( szMonths, ASTERIX, TRUE )  )
                    {
                        return RETVAL_SUCCESS;
                    }
                    else
                    {
                        ShowMessage(stderr , GetResString(IDS_INVALID_VALUE_FOR_MON));
                        return RETVAL_FAIL;
                    }
                }
                else
                {
                        ShowMessage(stderr ,GetResString(IDS_NO_MONTH_VALUE));
                        return RETVAL_FAIL;
                }

            }

            // If -day is specified then check whether the day value is valid or not.
            if( InString( szDay, ASTERIX, TRUE) )
            {
                ShowMessage(stderr ,GetResString(IDS_INVALID_VALUE_FOR_DAY));
                return RETVAL_FAIL;
            }
            if(( StringLength (szDay, 0 ) == 0 )  &&  InString(szModifier, szDayModifier, TRUE))
            {
                ShowMessage(stderr, GetResString(IDS_NO_DAY_VALUE));
                return RETVAL_FAIL;
            }

            if( dwDayOptCnt )
            {
                dwModifier = (DWORD) AsLong(szModifier, BASE_TEN);

                //check for multiples days,if then return error

                if ( wcspbrk ( szDay , COMMA_STRING ) )
                {
                    ShowMessage(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
                    return RETVAL_FAIL;
                }


                if( ValidateDay( szDay ) == RETVAL_SUCCESS )
                {
                    //Check the modifier value should be in FIRST, SECOND, THIRD, FOURTH, LAST OR LASTDAY etc..
                    if(!( InString(szModifier, szDayModifier, TRUE) ) )
                    {
                        ShowMessage(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
                        return RETVAL_FAIL;
                    }

                }
                else
                {
                    dwDays = (DWORD) AsLong(szDay, BASE_TEN);

                    if( ( dwDays < 1 ) || ( dwDays > 31 ) )
                    {
                        ShowMessage(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
                        return RETVAL_FAIL;
                    }

                    if( ( dwOptModifier == 1 ) && ( ( dwModifier < 1 ) || ( dwModifier > 12 ) ) )
                    {
                        ShowMessage(stderr, GetResString(IDS_INVALID_MODIFIER));
                        return RETVAL_FAIL;
                    }

                    if( InString(szModifier, szDayModifier, TRUE) )
                    {
                        ShowMessage(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
                        return RETVAL_FAIL;
                    }

                    if(dwMonOptCnt && StringLength(szModifier, 0))
                    {
                        ShowMessage(stderr ,GetResString(IDS_INVALID_MONTH_MODFIER));
                        return RETVAL_FAIL;
                    }
                }

            } //end of dwDayOptCnt

            if(StringLength(szMonths, 0))
            {

                if( StringLength(szModifier, 0) )
                {
                    dwModifier = (DWORD) AsLong(szModifier, BASE_TEN);

                     if(dwModifier >= 1 && dwModifier <= 12)
                     {
                        ShowMessage( stderr ,GetResString(IDS_MON_NA));
                        return RETVAL_FAIL;
                     }
                }

                if( ( ValidateMonth( szMonths ) == RETVAL_SUCCESS ) ||
                    InString( szMonths, ASTERIX, TRUE )  )
                {
                    return RETVAL_SUCCESS;
                }
                else
                {
                    ShowMessage(stderr ,GetResString(IDS_INVALID_VALUE_FOR_MON));
                    return RETVAL_FAIL;
                }
            }


            // assgin default values for month,day
            return RETVAL_SUCCESS;

        case SCHED_TYPE_HOURLY:
        case SCHED_TYPE_ONETIME:
        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:
        case SCHED_TYPE_ONIDLE:
        case SCHED_TYPE_MINUTE:

            // -months switch is NOT APPLICABLE.
            if( dwMonOptCnt > 0 )
            {
                ShowMessage(stderr ,GetResString(IDS_MON_NA));
                return RETVAL_FAIL;
            }

            // -days switch is NOT APPLICABLE.
            if( dwDayOptCnt > 0 )
            {
                ShowMessage(stderr ,GetResString(IDS_DAYS_NA));
                return RETVAL_FAIL;
            }

            break;

        case SCHED_TYPE_WEEKLY:

            // -months field is NOT APPLICABLE for WEEKLY item.
            if( dwMonOptCnt > 0 )
            {
                ShowMessage(stderr ,GetResString(IDS_MON_NA));
                return RETVAL_FAIL;
            }


            if(dwDayOptCnt > 0)
            {
                dwRetval = ValidateDay(szDay);
                if(  RETVAL_FAIL == dwRetval )
                {
                    ShowMessage(stderr ,GetResString(IDS_INVALID_VALUE_FOR_DAY));
                    return RETVAL_FAIL;
                }
            }


        return RETVAL_SUCCESS;

        default:
            break;
    }

    return RETVAL_SUCCESS;
}

/******************************************************************************
    Routine Description:

        This routine validates the months values specified by the user

    Arguments:

        [ in ] szMonths : Months options given by user

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
        on failure
******************************************************************************/

DWORD
ValidateMonth(
                IN LPWSTR szMonths
                )
{
    WCHAR* pMonthstoken = NULL; // For getting months.
    WCHAR seps[]   = _T(", \n");
    WCHAR szMonthsList[MAX_STRING_LENGTH] = L"\0";
    WCHAR szTmpMonths[MAX_STRING_LENGTH] = L"\0";
    WCHAR szPrevTokens[MAX_TOKENS_LENGTH] = L"\0";
    LPCTSTR lpsz = NULL;

    // If the szMonths string is empty or NULL return error.
    if( szMonths == NULL )
    {
        return RETVAL_FAIL;
    }
    else
    {
        lpsz = szMonths;
    }

    //check for any illegal input like only ,DEC,[comma at the end of month name or before]
    if(*lpsz == _T(','))
        return RETVAL_FAIL;

    lpsz = _wcsdec(lpsz, lpsz + StringLength(lpsz, 0) );

    if( lpsz != NULL )
    {
        if( *lpsz == _T(','))
            return RETVAL_FAIL;
    }

    //get the valid  month modifiers from the rc file
    StringCopy(szMonthsList,GetResString(IDS_MONTH_MODIFIER_JAN), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_FEB), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_MAR), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_APR), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_MAY), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_JUN), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_JUL), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_AUG), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_SEP), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_OCT), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_NOV), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,_T("|"), SIZE_OF_ARRAY(szMonthsList));
    StringConcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_DEC), SIZE_OF_ARRAY(szMonthsList));

    if( InString( szMonths , szMonthsList , TRUE )  &&
        InString( szMonths , ASTERIX , TRUE ) )
    {
        return RETVAL_FAIL;
    }

    if( InString( szMonths , ASTERIX , TRUE ) )
        return RETVAL_SUCCESS;

    //Check for multiple commas[,] after months like FEB,,,MAR errors
    lpsz = szMonths;
    while ( StringLength ( lpsz, 0 ) )
    {
        if(*lpsz == _T(','))
        {
            lpsz = _wcsinc(lpsz);
            while ( ( lpsz != NULL ) && ( _istspace(*lpsz) ) )
                lpsz = _wcsinc(lpsz);

            if( lpsz != NULL )
            {
                if(*lpsz == _T(','))
                    return RETVAL_FAIL;
            }

        }
        else
            lpsz = _wcsinc(lpsz);
    }

    StringCopy(szTmpMonths, szMonths, SIZE_OF_ARRAY(szTmpMonths));

    WCHAR* pPrevtoken = NULL;
    pMonthstoken = wcstok( szTmpMonths, seps );

    if( !(InString(pMonthstoken, szMonthsList, TRUE)) )
            return RETVAL_FAIL;

    if( pMonthstoken )
        StringCopy ( szPrevTokens, pMonthstoken, SIZE_OF_ARRAY(szPrevTokens));

    while( pMonthstoken != NULL )
    {
        //check if month names are replicated like MAR,MAR from user input
        pPrevtoken = pMonthstoken;
        pMonthstoken = wcstok( NULL, seps );

        if ( pMonthstoken == NULL)
            return RETVAL_SUCCESS;

        if( !(InString(pMonthstoken, szMonthsList, TRUE)) )
            return RETVAL_FAIL;

        if( InString(pMonthstoken,szPrevTokens, TRUE) )
            return RETVAL_FAIL;

        StringConcat( szPrevTokens, _T("|"), SIZE_OF_ARRAY(szPrevTokens));
        StringConcat( szPrevTokens, pMonthstoken, SIZE_OF_ARRAY(szPrevTokens));
    }

    return RETVAL_SUCCESS;
}


/******************************************************************************
    Routine Description:

        This routine validates the days values specified by the user

    Arguments:

        [ in ] szDays : Days options given by user

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
        on failure
******************************************************************************/

DWORD
ValidateDay(
            IN LPWSTR szDays
            )
{
    WCHAR* pDaystoken = NULL;
    WCHAR seps[]   = _T(", \n");
    WCHAR szDayModifier[MAX_STRING_LENGTH ] = L"\0";
    WCHAR szTmpDays[MAX_STRING_LENGTH] = L"\0";

    //get the valid   day modifiers from the rc file
    StringCopy(szDayModifier,GetResString(IDS_DAY_MODIFIER_SUN), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_MON), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_TUE), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_WED), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_THU), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_FRI), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,_T("|"), SIZE_OF_ARRAY(szDayModifier));
    StringConcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_SAT), SIZE_OF_ARRAY(szDayModifier));

    //check for any illegal input like MON, or ,MON [comma at the end of day name or before]
    LPCTSTR lpsz = NULL;
    if( szDays != NULL)
        lpsz = szDays;
    else
        return RETVAL_FAIL;

    if(*lpsz == _T(','))
        return RETVAL_FAIL;

    lpsz = _wcsdec(lpsz, lpsz + StringLength(lpsz, 0) );
    if( lpsz != NULL )
    {
        if( *lpsz == _T(',') )
            return RETVAL_FAIL;
    }

    if ( ( lpsz != NULL ) && ( _istspace(*lpsz) ))
    {
        return RETVAL_FAIL;
    }

    if( (InString( szDays , szDayModifier , TRUE )) || (InString( szDays , ASTERIX , TRUE )))
    {
        return RETVAL_SUCCESS;
    }

    //Check for multiple commas[,] after days like SUN,,,TUE errors
    lpsz = szDays;
    while ( StringLength ( lpsz, 0 ) )
    {
        if(*lpsz == _T(','))
        {
            lpsz = _wcsinc(lpsz);
            while ( ( lpsz != NULL ) && ( _istspace(*lpsz) ))
                lpsz = _wcsinc(lpsz);

            if( lpsz != NULL )
            {
                if(*lpsz == _T(','))
                    return RETVAL_FAIL;
            }

        }
        else
        {
            lpsz = _wcsinc(lpsz);
        }
    }

    if(szDays != NULL)
    {
        StringCopy(szTmpDays, szDays, SIZE_OF_ARRAY(szTmpDays));
    }

    // If the szDays string is empty or NULL return error.
    if( (StringLength(szTmpDays, 0) <= 0) )
    {
        return RETVAL_FAIL;
    }

    //WCHAR* pPrevtoken = NULL;
    WCHAR szPrevtokens[MAX_TOKENS_LENGTH] = L"\0";

    // Establish string and get the first token:
    pDaystoken = wcstok( szTmpDays, seps );

    if( pDaystoken )
    {
        StringCopy( szPrevtokens , pDaystoken, SIZE_OF_ARRAY(szPrevtokens) );
    }

    while( pDaystoken != NULL )
    {
        //check if day names are replicated like SUN,MON,SUN from user input

        if( !(InString(pDaystoken,szDayModifier,TRUE)) )
        {
            return RETVAL_FAIL;
        }

        pDaystoken = wcstok( NULL, seps );
        if( pDaystoken )
        {
            if( (InString(pDaystoken,szPrevtokens,TRUE)) )
            {
                return RETVAL_FAIL;
            }

            StringConcat( szPrevtokens , _T("|"), SIZE_OF_ARRAY(szPrevtokens) );
            StringConcat( szPrevtokens , pDaystoken , SIZE_OF_ARRAY(szPrevtokens));
        }
    }

    return RETVAL_SUCCESS;
}

/******************************************************************************
    Routine Description:

        This routine validates the start date specified by the user

    Arguments:

        [ in ] szStartDate     : Start date specified by user
        [ in ] dwSchedType     : Schedule type
        [ in ] dwStDtOptCnt    : whether start  date specified by the user
        [ out ] bIsCurrentDate : If start date not specified then startdate = current date

Return Value :
    A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
    on failure
******************************************************************************/

DWORD
ValidateStartDate(
                    IN LPWSTR szStartDate,
                    IN DWORD dwSchedType,
                    IN DWORD dwStDtOptCnt,
                    OUT BOOL &bIsCurrentDate
                    )
{

    DWORD dwRetval = RETVAL_SUCCESS;
    bIsCurrentDate = FALSE; // If TRUE : Startdate should be set to Current Date.

    WCHAR szFormat[MAX_DATE_STR_LEN] = L"\0";

    if ( RETVAL_FAIL == GetDateFormatString( szFormat) )
    {
        return RETVAL_FAIL;
    }

    switch (dwSchedType)
    {
        case SCHED_TYPE_MINUTE:
        case SCHED_TYPE_HOURLY:
        case SCHED_TYPE_DAILY:
        case SCHED_TYPE_WEEKLY:
        case SCHED_TYPE_MONTHLY:
        case SCHED_TYPE_ONIDLE:
        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:

            if( (dwStDtOptCnt <= 0))
            {
                bIsCurrentDate = TRUE;
                return RETVAL_SUCCESS;
            }

            // validate the date string
            dwRetval = ValidateDateString(szStartDate, TRUE );
            if(RETVAL_FAIL == dwRetval)
            {
                return dwRetval;
            }
            return RETVAL_SUCCESS;

        case SCHED_TYPE_ONETIME:

        if( (dwStDtOptCnt <= 0))
            {
                bIsCurrentDate = TRUE;
                return RETVAL_SUCCESS;

            }

            dwRetval = ValidateDateString(szStartDate, TRUE );
            if(RETVAL_FAIL == dwRetval)
            {
                 return dwRetval;
            }

            return RETVAL_SUCCESS;

        default:

            // validate the date string
            dwRetval = ValidateDateString(szStartDate, TRUE );
            if(RETVAL_FAIL == dwRetval)
            {
                return dwRetval;
            }

            return RETVAL_SUCCESS;

    }

    return RETVAL_FAIL;
}

/******************************************************************************
    Routine Description:

        This routine validates the end date specified by the user

    Arguments:

    [ in ] szEndDate       : End date specified by user
    [ in ] dwSchedType   : Schedule type
    [ in ] dwEndDtOptCnt : whether end date specified by the user

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
        on failure
******************************************************************************/

DWORD
ValidateEndDate(
                IN LPWSTR szEndDate,
                IN DWORD dwSchedType,
                IN DWORD dwEndDtOptCnt
                )
{

    DWORD dwRetval = RETVAL_SUCCESS; // return value
    WCHAR szFormat[MAX_DATE_STR_LEN] = L"\0";

    if ( RETVAL_FAIL == GetDateFormatString( szFormat) )
    {
        return RETVAL_FAIL;
    }

    switch (dwSchedType)
    {
        case SCHED_TYPE_MINUTE:
        case SCHED_TYPE_HOURLY:
        case SCHED_TYPE_DAILY:
        case SCHED_TYPE_WEEKLY:
        case SCHED_TYPE_MONTHLY:


            if( (dwEndDtOptCnt <= 0))
            {
                // No default value & Value is not mandatory.. so return success.
                szEndDate = L"\0"; // Set to empty string.
                return RETVAL_SUCCESS;
            }

            // validate end date string
            dwRetval = ValidateDateString(szEndDate, FALSE );
            if( RETVAL_FAIL == dwRetval )
            {
                  return dwRetval;
            }
            else
            {
                return RETVAL_SUCCESS;
            }
            break;

        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:
        case SCHED_TYPE_ONIDLE:
        case SCHED_TYPE_ONETIME:

            if( dwEndDtOptCnt > 0 )
            {
                // Error. End date is not applicable here, but option specified.
                ShowMessage(stderr,GetResString(IDS_ENDDATE_NA));
                return RETVAL_FAIL;
            }
            else
            {
                return RETVAL_SUCCESS;
            }
            break;

        default:

            // validate end date string
            dwRetval = ValidateDateString(szEndDate, FALSE );
            if( RETVAL_FAIL == dwRetval )
            {
                  return dwRetval;
            }
            else
            {
                return RETVAL_SUCCESS;
            }

            break;
    }

    return RETVAL_FAIL;
}


/******************************************************************************
    Routine Description:

        This routine validates the start time specified by the user

    Arguments:

        [ in ] szStartTime     : End date specified by user
        [ in ] dwSchedType     : Schedule type
        [ in ] dwStTimeOptCnt  : whether end date specified by the user
        [ out ] bIsCurrentTime : Determine if start time is present else assign
                               to current time

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure

******************************************************************************/


DWORD
ValidateStartTime(
                    IN LPWSTR szStartTime,
                    IN DWORD dwSchedType,
                    IN DWORD dwStTimeOptCnt,
                    OUT BOOL &bIsCurrentTime
                    )
{

    DWORD dwRetval = RETVAL_SUCCESS; // return value
    bIsCurrentTime = FALSE; // If TRUE : Startdate should be set to Current Date.

    switch (dwSchedType)
    {
        case SCHED_TYPE_MINUTE:
        case SCHED_TYPE_HOURLY:
        case SCHED_TYPE_DAILY:
        case SCHED_TYPE_WEEKLY:
        case SCHED_TYPE_MONTHLY:

            if( (dwStTimeOptCnt <= 0))
            {
                bIsCurrentTime = TRUE;
                return RETVAL_SUCCESS;
            }

            dwRetval = ValidateTimeString(szStartTime);

            if(RETVAL_FAIL == dwRetval)
            {
                // Error. Invalid date string.
                ShowMessage(stderr,GetResString(IDS_INVALIDFORMAT_STARTTIME));
                return dwRetval;
            }
            return RETVAL_SUCCESS;

        case SCHED_TYPE_ONETIME:

            dwRetval = ValidateTimeString(szStartTime);

            if( (dwStTimeOptCnt <= 0))
            {
                // Error. Start Time is not specified.
                ShowMessage(stderr,GetResString(IDS_NO_STARTTIME));
                return RETVAL_FAIL;
            }
            else if(RETVAL_FAIL == dwRetval)
            {
                // Error. Invalid date string.
                ShowMessage(stderr,GetResString(IDS_INVALIDFORMAT_STARTTIME));
                return dwRetval;
            }

            return RETVAL_SUCCESS;

        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:
        case SCHED_TYPE_ONIDLE:

            if( dwStTimeOptCnt > 0 )
            {
                // Start Time is not applicable in this option.
                //But the -starttime option specified. Display error.
                ShowMessage(stderr,GetResString(IDS_STARTTIME_NA));
                return RETVAL_FAIL;
            }
            else
            {
                return RETVAL_SUCCESS;
            }
            break;

        default:
            // Never comes here.
            break;
    }

    return RETVAL_FAIL;
}

/******************************************************************************
    Routine Description:

        This routine validates the start time specified by the user

    Arguments:

        [ in ] szEndTime       : End time specified by user
        [ in ] dwSchedType     : Schedule type
        [ in ] dwStTimeOptCnt  : whether end time specified by the user or not

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure

******************************************************************************/


DWORD
ValidateEndTime(
                IN LPWSTR szEndTime,
                IN DWORD dwSchedType,
                IN DWORD dwEndTimeOptCnt
                )
{

    DWORD dwRetval = RETVAL_SUCCESS; // return value

    switch (dwSchedType)
    {
        case SCHED_TYPE_MINUTE:
        case SCHED_TYPE_HOURLY:
        case SCHED_TYPE_DAILY:
        case SCHED_TYPE_WEEKLY:
        case SCHED_TYPE_MONTHLY:
        case SCHED_TYPE_ONETIME:

            dwRetval = ValidateTimeString(szEndTime);
            if( ( dwEndTimeOptCnt > 0 ) && ( RETVAL_FAIL == dwRetval) )
            {
                // Error. Invalid date string.
                ShowMessage(stderr,GetResString(IDS_INVALIDFORMAT_ENDTIME));
                return dwRetval;
            }

            return RETVAL_SUCCESS;


        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:
        case SCHED_TYPE_ONIDLE:

            if( dwEndTimeOptCnt > 0 )
            {
                // Start Time is not applicable in this option.
                //But the -endtime option specified. Display error.
                ShowMessage(stderr,GetResString(IDS_ENDTIME_NA));
                return RETVAL_FAIL;
            }
            else
            {
                return RETVAL_SUCCESS;
            }
            break;

        default:
            // Never comes here.
            break;
    }

    return RETVAL_FAIL;
}

/******************************************************************************
    Routine Description:

        This routine validates the idle time specified by the user

    Arguments:

        [ in ] szIdleTime      : Ilde time specified by user
        [ in ] dwSchedType     : Schedule type
        [ in ] dwIdlTimeOptCnt : whether Idle time specified by the user

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure

******************************************************************************/

DWORD
ValidateIdleTimeVal(
                    IN LPWSTR szIdleTime,
                    IN DWORD dwSchedType,
                    IN DWORD dwIdlTimeOptCnt
                    )
{

    long lIdleTime = 0;
    LPWSTR pszStopString = NULL;
    switch (dwSchedType)
    {
        case SCHED_TYPE_MINUTE:
        case SCHED_TYPE_HOURLY:
        case SCHED_TYPE_DAILY:
        case SCHED_TYPE_WEEKLY:
        case SCHED_TYPE_MONTHLY:
        case SCHED_TYPE_ONSTART:
        case SCHED_TYPE_ONLOGON:
        case SCHED_TYPE_ONETIME:

            if( dwIdlTimeOptCnt > 0 )
            {
                ShowMessage(stderr ,GetResString(IDS_IDLETIME_NA));
                return RETVAL_FAIL;
            }
            else
            {
                return RETVAL_SUCCESS;
            }
            break;

        case SCHED_TYPE_ONIDLE:

            if( dwIdlTimeOptCnt == 0 )
            {

                ShowMessage(stderr,GetResString(IDS_NO_IDLETIME));
                return RETVAL_FAIL;
            }

            lIdleTime = wcstoul(szIdleTime,&pszStopString,BASE_TEN);
            if( ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))) ||
                (errno == ERANGE) ||( lIdleTime <= 0 ) || ( lIdleTime > 999 ) )
            {
                ShowMessage(stderr,GetResString(IDS_INVALIDORNO_IDLETIME));
                return RETVAL_FAIL;
            }

            return RETVAL_SUCCESS;

        default:
                break;
    }

    ShowMessage(stderr,GetResString(IDS_INVALIDORNO_IDLETIME));
    return RETVAL_FAIL;
}

/******************************************************************************
    Routine Description:

        This routine validates the date string.

    Arguments:

        [ in ] szDate : Date string
        [ in ] bStartDate : flag

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure
******************************************************************************/

DWORD
ValidateDateString(
                    IN LPWSTR szDate,
                    IN BOOL bStartDate
                    )
{
    WORD  dwDate = 0;
    WORD  dwMon  = 0;
    WORD  dwYear = 0;
    WCHAR* szValues[1] = {NULL};//To pass to FormatMessage() API
    WCHAR szFormat[MAX_DATE_STR_LEN] = L"\0";
    //WCHAR szBuffer[MAX_RES_STRING] = L"\0";

    if(StringLength(szDate, 0) <= 0)
    {
        if ( TRUE == bStartDate )
        {
            ShowMessage ( stderr, GetResString (IDS_STARTDATE_EMPTY) );
        }
        else
        {
            ShowMessage ( stderr, GetResString (IDS_DURATION_EMPTY) );
        }

        return RETVAL_FAIL;
    }

    if ( RETVAL_FAIL == GetDateFormatString( szFormat) )
    {
        return RETVAL_FAIL;
    }

    if( GetDateFieldEntities(szDate, &dwDate, &dwMon, &dwYear) ) // Error
    {
        szValues[0] = (WCHAR*) (szFormat);
        if ( TRUE == bStartDate )
        {
              ShowMessageEx ( stderr, 1, FALSE, GetResString(IDS_INVALIDFORMAT_STARTDATE), _X(szFormat));
        }
        else
        {
              ShowMessageEx ( stderr, 1, FALSE, GetResString(IDS_INVALIDFORMAT_ENDDATE), _X(szFormat));
        }

        //ShowMessage(stderr, _X(szBuffer) );
        return RETVAL_FAIL;
    }

    if( ValidateDateFields(dwDate, dwMon, dwYear) )
    {
        if ( TRUE == bStartDate )
        {
            ShowMessage(stderr, GetResString(IDS_INVALID_STARTDATE) );
        }
        else
        {
            ShowMessage(stderr, GetResString(IDS_INVALID_ENDDATE) );
        }

        return RETVAL_FAIL;

    }

    return RETVAL_SUCCESS; // return success if no error.
}

/******************************************************************************
    Routine Description:

        This routine retrives the date field entities out of the date string

    Arguments:

        [ in ] szDate   : Date string
        [ out ] pdwDate : Pointer to date value[1,2,3 ...30,31 etc]
        [ out ] pdwMon  : Pointer to Month value[1,2,3 ...12 etc]
        [ out ] pdwYear : Pointer to year value[2000,3000 etc]

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure
******************************************************************************/

DWORD
GetDateFieldEntities(
                    IN LPWSTR szDate,
                    OUT WORD* pdwDate,
                    OUT WORD* pdwMon,
                    OUT WORD* pdwYear
                    )
{
    WCHAR  strDate[MAX_STRING_LENGTH] = L"\0"; // Date in WCHAR type string.
    WCHAR  tDate[MAX_DATE_STR_LEN] = L"\0"; // Date
    WCHAR  tMon[MAX_DATE_STR_LEN] = L"\0"; // Month
    WCHAR  tYear[MAX_DATE_STR_LEN] = L"\0"; // Year
    WORD    wFormatID = 0;

    if(szDate != NULL)
    {
        StringCopy(strDate, szDate, SIZE_OF_ARRAY(strDate));
    }

    if(StringLength(strDate, 0) <= 0)
        return RETVAL_FAIL; // No value specified in szDate.

    if ( RETVAL_FAIL == GetDateFieldFormat( &wFormatID ))
    {
        return RETVAL_FAIL;
    }

    if ( wFormatID == 0 || wFormatID == 1 )
    {
        if( (StringLength(strDate, 0) != DATESTR_LEN) ||
            (strDate[FIRST_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR)
            || (strDate[SECOND_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR) )
        {
            return RETVAL_FAIL;
        }
    }
    else
    {
        if( (StringLength(strDate, 0) != DATESTR_LEN) ||
            (strDate[FOURTH_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR)
            || (strDate[SEVENTH_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR) )
        {
            return RETVAL_FAIL;
        }
    }

    // Get the individual date field entities using wcstok function
    // with respect to regional options.


    if ( wFormatID == 0 )
    {
        StringCopy(tMon, wcstok(strDate,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tMon)); // Get the Month field.
        if(StringLength(tMon, 0) > 0)
        {
            StringCopy(tDate, wcstok(NULL,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tDate)); // Get the date field.
            StringCopy(tYear, wcstok(NULL,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tYear)); // Get the Year field.
        }
    }
    else if ( wFormatID == 1 )
    {
        StringCopy(tDate, wcstok(strDate,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tDate)); // Get the Month field.
        if(StringLength(tDate, 0) > 0)
        {
            StringCopy(tMon, wcstok(NULL,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tMon)); // Get the date field.
            StringCopy(tYear, wcstok(NULL,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tYear)); // Get the Year field.
        }
    }
    else
    {
        StringCopy(tYear, wcstok(strDate,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tYear)); // Get the Month field.
        if(StringLength(tYear, 0) > 0)
        {
            StringCopy(tMon, wcstok(NULL,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tMon)); // Get the date field.
            StringCopy(tDate, wcstok(NULL,DATE_SEPARATOR_STR), SIZE_OF_ARRAY(tDate)); // Get the Year field.
        }
    }

    // Now convert string values to numeric for date validations.
    LPWSTR pszStopString = NULL;

    *pdwDate = (WORD)wcstoul(tDate,&pszStopString,BASE_TEN);
     if( (errno == ERANGE) ||
        ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
         {
            return RETVAL_FAIL;
         }


    *pdwMon = (WORD)wcstoul(tMon,&pszStopString,BASE_TEN);
    if( (errno == ERANGE) ||
        ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
         {
            return RETVAL_FAIL;
         }

    *pdwYear = (WORD)wcstoul(tYear,&pszStopString,BASE_TEN);
     if( (errno == ERANGE) ||
        ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
         {
            return RETVAL_FAIL;
         }

    return RETVAL_SUCCESS;
}

/******************************************************************************
    Routine Description:

        This routine validates the date field entities

    Arguments:

        [ in ] dwDate : Date value[Day in a month]
        [ in ] dwMon    : Month constant
        [ in ] dwYear : year value

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure
******************************************************************************/

DWORD
ValidateDateFields(
                    IN DWORD dwDate,
                    IN DWORD dwMon,
                    IN DWORD dwYear
                    )
{

    if(dwYear <= MIN_YEAR  || dwYear > MAX_YEAR)
        return RETVAL_FAIL;

    switch(dwMon)
    {
        case IND_JAN:
        case IND_MAR:
        case IND_MAY:
        case IND_JUL:
        case IND_AUG:
        case IND_OCT:
        case IND_DEC:

            if(dwDate > 0 && dwDate <= 31)
            {
                return RETVAL_SUCCESS;
            }
            break;

        case IND_APR:
        case IND_JUN:
        case IND_SEP:
        case IND_NOV:

            if(dwDate > 0 && dwDate < 31)
            {
                return RETVAL_SUCCESS;
            }
            break;

        case IND_FEB:

            if( ((dwYear % 4) == 0) && (dwDate > 0 && dwDate <= 29) )
            {
                    return RETVAL_SUCCESS;
            }
            else if( ((dwYear % 4) != 0) && (dwDate > 0 && dwDate < 29) )
            {
                    return RETVAL_SUCCESS;
            }

            break;

        default:

            break;
    }

    return RETVAL_FAIL;

}

/******************************************************************************
    Routine Description:

        This routine validates the time specified by the user

    Arguments:

        [ in ] szTime : time string

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure
******************************************************************************/


DWORD
ValidateTimeString(
                    IN LPWSTR szTime
                    )
{
    WORD  dwHours = 0;
    WORD  dwMins = 0;
    //WORD  dwSecs = 0 ;

    // Check for the empty string value.
    if(StringLength(szTime, 0) <= 0)
    {
        return RETVAL_FAIL;
    }

    // Get separate entities from the given time string.
    if( GetTimeFieldEntities(szTime, &dwHours, &dwMins ) )
    {
        return RETVAL_FAIL;
    }

    // Validate the individual entities of the given time.
    if( ValidateTimeFields( dwHours, dwMins ) )
    {
        return RETVAL_FAIL;
    }

    return RETVAL_SUCCESS;
}

/******************************************************************************
    Routine Description:

        This routine retrieves the different fields of time
    Arguments:

        [ in ] szTime    : Time string
        [ out ] pdwHours : pointer to hours value
        [ out ] pdwMins  : pointer to mins value

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure
******************************************************************************/

DWORD
GetTimeFieldEntities(
                        IN LPWSTR szTime,
                        OUT WORD* pdwHours,
                        OUT WORD* pdwMins
                        )
{
    WCHAR strTime[MAX_STRING_LENGTH] = L"\0" ; // Time in WCHAR type string.
    WCHAR tHours[MAX_TIME_STR_LEN] = L"\0" ; // Date
    WCHAR tMins[MAX_TIME_STR_LEN]  = L"\0" ; // Month
    //WCHAR tSecs[MAX_TIME_STR_LEN]  = L"\0" ; // Year

    if(StringLength(szTime, 0) <= 0)
        return RETVAL_FAIL;

    StringCopy(strTime, szTime, SIZE_OF_ARRAY(strTime));

    //
	//Start Time accepts both HH:mm:ss and HH:mm formats even though seconds are of no use..
	//This feature has been supported to be in sync with XP Professional.
	//
	if( ((StringLength(strTime, 0) != TIMESTR_LEN) && (StringLength(strTime, 0) != TIMESTR_OPT_LEN)) ||
          ((strTime[FIRST_TIMESEPARATOR_POS] != TIME_SEPARATOR_CHAR) && (strTime[SECOND_TIMESEPARATOR_POS] != TIME_SEPARATOR_CHAR)) )
		  {
            return RETVAL_FAIL;
	}

    // Get the individual Time field entities using wcstok function.in the order "hh" followed by "mm" followed by "ss"
    StringCopy(tHours, wcstok(strTime,TIME_SEPARATOR_STR), SIZE_OF_ARRAY(tHours)); // Get the Hours field.
    if(StringLength(tHours, 0) > 0)
    {
        StringCopy(tMins, wcstok(NULL,TIME_SEPARATOR_STR), SIZE_OF_ARRAY(tMins)); // Get the Minutes field.
    }

    LPWSTR pszStopString = NULL;

    // Now convert string values to numeric for time validations.
    *pdwHours = (WORD)wcstoul(tHours,&pszStopString,BASE_TEN);
     if( (errno == ERANGE) ||
        ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
         {
            return RETVAL_FAIL;
         }

    *pdwMins = (WORD)wcstoul(tMins,&pszStopString,BASE_TEN);
    if( (errno == ERANGE) ||
        ((pszStopString != NULL) && (StringLength( pszStopString, 0 ))))
         {
            return RETVAL_FAIL;
         }

    return RETVAL_SUCCESS;
}

/******************************************************************************
    Routine Description:

    This routine validates the time fields of a  given time

    Arguments:

        [ in ] dwHours :Hours value
        [ in ] dwMins  :Minutes value
        [ in ] dwSecs  : seconds value

    Return Value :
        A DWORD value indicating RETVAL_SUCCESS on success else
        RETVAL_FAIL on failure
******************************************************************************/

DWORD
ValidateTimeFields(
                    IN DWORD dwHours,
                    IN DWORD dwMins
                    )
{

    if ( dwHours <= HOURS_PER_DAY_MINUS_ONE )
    {
        if ( dwMins < MINUTES_PER_HOUR )
        {
            return RETVAL_SUCCESS;
        }
        else
        {
            return RETVAL_FAIL;
        }
    }
    else
    {
            return RETVAL_FAIL;
    }

}

/******************************************************************************
    Routine Description:

        This routine validates the time fields of a  given time

    Arguments:

        [ in ] szDay : time string

    Return Value :
        A WORD value containing the day constant [TASK_SUNDAY,TASK_MONDAY etc]
******************************************************************************/

WORD
GetTaskTrigwDayForDay(
                        IN LPWSTR szDay
                        )
{
    WCHAR szDayBuff[MAX_RES_STRING] = L"\0";
    WCHAR *token = NULL;
    WCHAR seps[]   = _T(" ,\n");
    WORD dwRetval = 0;
    SYSTEMTIME systime = {0,0,0,0,0,0,0,0};

    if(StringLength(szDay, 0) != 0)
    {
        StringCopy(szDayBuff, szDay, SIZE_OF_ARRAY(szDayBuff));
    }

    // if /D is not specified.. set the default day to current day..
    if( StringLength(szDayBuff, 0) <= 0 )
    {
        GetLocalTime (&systime);
        
        switch ( systime.wDayOfWeek )
        {
            case 0: 
                return TASK_SUNDAY;
            case 1: 
                return TASK_MONDAY;
            case 2: 
                return TASK_TUESDAY;
            case 3: 
                return TASK_WEDNESDAY;
            case 4: 
                return TASK_THURSDAY;
            case 5: 
                return TASK_FRIDAY;
            case 6: 
                return TASK_SATURDAY;
            default: 
                break;
        }
    }

    token = wcstok( szDayBuff, seps );
    while( token != NULL )
    {
        if( !(StringCompare(token, GetResString( IDS_DAY_MODIFIER_SUN ), TRUE, 0)) )
            dwRetval |= (TASK_SUNDAY);
        else if( !(StringCompare(token, GetResString( IDS_DAY_MODIFIER_MON ), TRUE, 0)) )
            dwRetval |= (TASK_MONDAY);
        else if( !(StringCompare(token, GetResString( IDS_DAY_MODIFIER_TUE ), TRUE, 0)) )
            dwRetval |= (TASK_TUESDAY);
        else if( !(StringCompare(token, GetResString( IDS_DAY_MODIFIER_WED ), TRUE, 0)) )
            dwRetval |= (TASK_WEDNESDAY);
        else if( !(StringCompare(token, GetResString( IDS_DAY_MODIFIER_THU ), TRUE, 0)) )
            dwRetval |= (TASK_THURSDAY);
        else if( !(StringCompare(token,GetResString( IDS_DAY_MODIFIER_FRI ), TRUE, 0)) )
            dwRetval |= (TASK_FRIDAY);
        else if( !(StringCompare(token, GetResString( IDS_DAY_MODIFIER_SAT ), TRUE, 0)) )
            dwRetval |= (TASK_SATURDAY);
        else if( !(StringCompare(token, ASTERIX, TRUE, 0)) )
            return (TASK_SUNDAY | TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY |
                    TASK_THURSDAY | TASK_FRIDAY | TASK_SATURDAY);
        else
            return 0;

        token = wcstok( NULL, seps );
    }

    return dwRetval;
}

/******************************************************************************

    Routine Description:

        This routine validates the time fields of a  given time

    Arguments:

        [ in ] szMonth : Month string

    Return Value :
        A WORD value containing the Month constant
        [TASK_JANUARY,TASK_FEBRUARY etc]

******************************************************************************/

WORD
GetTaskTrigwMonthForMonth(
                            IN LPWSTR szMonth
                            )
{
    WCHAR *token = NULL;
    WORD dwRetval = 0;
    WCHAR strMon[MAX_TOKENS_LENGTH] = L"\0";
    WCHAR seps[]   = _T(" ,\n");

    if( StringLength(szMonth, 0) <= 0 )
    {
        return (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH | TASK_APRIL | TASK_MAY | TASK_JUNE |
                TASK_JULY | TASK_AUGUST | TASK_SEPTEMBER | TASK_OCTOBER
                | TASK_NOVEMBER | TASK_DECEMBER );
    }

    StringCopy(strMon, szMonth, SIZE_OF_ARRAY(strMon));

    token = wcstok( szMonth, seps );
    while( token != NULL )
    {
        if( !(StringCompare(token, ASTERIX, TRUE, 0)) )
            return (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH | TASK_APRIL
                | TASK_MAY | TASK_JUNE | TASK_JULY | TASK_AUGUST | TASK_SEPTEMBER | TASK_OCTOBER
                | TASK_NOVEMBER | TASK_DECEMBER );
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_JAN ), TRUE, 0)) )
            dwRetval |= (TASK_JANUARY);
        else if( !(StringCompare(token,GetResString( IDS_MONTH_MODIFIER_FEB ), TRUE, 0)) )
            dwRetval |= (TASK_FEBRUARY);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_MAR ), TRUE, 0)) )
            dwRetval |= (TASK_MARCH);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_APR ), TRUE, 0)) )
            dwRetval |= (TASK_APRIL);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_MAY ), TRUE, 0)) )
            dwRetval |= (TASK_MAY);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_JUN ), TRUE, 0)) )
            dwRetval |= (TASK_JUNE);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_JUL ), TRUE, 0)) )
            dwRetval |= (TASK_JULY);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_AUG ), TRUE, 0)) )
            dwRetval |= (TASK_AUGUST);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_SEP ), TRUE, 0)) )
            dwRetval |= (TASK_SEPTEMBER);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_OCT ), TRUE, 0)) )
            dwRetval |= (TASK_OCTOBER);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_NOV ), TRUE, 0)) )
            dwRetval |= (TASK_NOVEMBER);
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_DEC ), TRUE, 0)) )
            dwRetval |= (TASK_DECEMBER);
        else
            return 0;

        token = wcstok( NULL, seps );
    }

    return dwRetval;
 }

/******************************************************************************

    Routine Description:

        This routine returns the corresponding month flag

    Arguments:

        [ in ] dwMonthId : Month index

    Return Value :
        A WORD value containing the Month constant
        [TASK_JANUARY,TASK_FEBRUARY etc]

******************************************************************************/

WORD
GetMonthId(
            IN DWORD dwMonthId
            )
{
    DWORD dwMonthsArr[] = {TASK_JANUARY,TASK_FEBRUARY ,TASK_MARCH ,TASK_APRIL ,
                           TASK_MAY ,TASK_JUNE ,TASK_JULY ,TASK_AUGUST,
                           TASK_SEPTEMBER ,TASK_OCTOBER ,TASK_NOVEMBER ,TASK_DECEMBER } ;

    DWORD wMonthFlags = 0;
    DWORD dwMod = 0;

    dwMod = dwMonthId - 1;

    while(dwMod < 12)
    {
        wMonthFlags |= dwMonthsArr[dwMod];
        dwMod = dwMod + dwMonthId;
    }

    return (WORD)wMonthFlags;
}

/******************************************************************************

    Routine Description:

        This routine returns the maximum Last day in the  months specifed

    Arguments:

        [ in ] szMonths   : string containing months specified by user
        [ in ] wStartYear : string containing start year
     Return Value :
        A DWORD value specifying the maximum last day in the specified months

******************************************************************************/

DWORD
GetNumDaysInaMonth(
                        IN WCHAR* szMonths,
                        IN WORD wStartYear
                        )
{
    DWORD dwDays = 31;//max.no of days in a month
    BOOL bMaxDays = FALSE;//if any of the months have 31 then days of value 31 is returned

    if( ( StringLength(szMonths, 0) == 0 ) || ( StringCompare(szMonths,ASTERIX, TRUE, 0) == 0 ) )
        return dwDays; //All months[default]


    WCHAR *token = NULL;
    WCHAR strMon[MAX_MONTH_STR_LEN] = L"\0";
    WCHAR seps[]   = _T(" ,\n");

    StringCopy(strMon, szMonths, SIZE_OF_ARRAY(strMon));

    token = wcstok( strMon, seps );
    while( token != NULL )
    {
        if( !(StringCompare(token,GetResString( IDS_MONTH_MODIFIER_FEB ), TRUE, 0)) )
        {

            if( ( (wStartYear % 400) == 0) ||
                ( ( (wStartYear % 4) == 0) &&
                ( (wStartYear % 100) != 0) ) )
            {
                dwDays = 29;
            }
            else
            {
                dwDays = 28;
            }
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_JAN ), TRUE, 0)) )
        {
            bMaxDays = TRUE;
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_MAR ), TRUE, 0)) )
        {
            bMaxDays = TRUE;
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_MAY ), TRUE, 0)) )
        {
            bMaxDays = TRUE;
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_JUL ), TRUE, 0)) )
        {
            bMaxDays = TRUE;

        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_AUG ), TRUE, 0)) )
        {
            bMaxDays = TRUE;

        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_OCT ), TRUE, 0)) )
        {
            bMaxDays = TRUE;

        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_DEC ), TRUE, 0)) )
        {
            bMaxDays = TRUE;
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_APR ), TRUE, 0)) )
        {
            dwDays = 30;
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_JUN ), TRUE, 0)) )
        {
            dwDays = 30;
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_SEP ), TRUE, 0)) )
        {
            dwDays = 30;
        }
        else if( !(StringCompare(token, GetResString( IDS_MONTH_MODIFIER_NOV ), TRUE, 0)) )
        {
            dwDays =  30;
        }


        token = wcstok( NULL, seps );
    }

    if (bMaxDays == TRUE)
    {
        return 31;
    }
    else
    {
        return dwDays;
    }

}

/******************************************************************************

    Routine Description:

        This routine checks the validates the taskname of the task to be created.

    Arguments:

        [ in ] pszJobName : Pointer to the job[task] name

     Return Value :
        If valid task name then TRUE else FALSE

******************************************************************************/

BOOL
VerifyJobName(
                    IN WCHAR* pszJobName
              )
{
    WCHAR szTokens[] = {_T('<'),_T('>'),_T(':'),_T('/'),_T('\\'),_T('|')};

    if( wcspbrk(pszJobName,szTokens)  == NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/******************************************************************************

    Routine Description:

    This routine gets the date format value with respective to regional options.

    Arguments:

        [ out ] pdwFormat : Date format value.

     Return Value :
        Returns RETVAL_FAIL on failure and RETVAL_SUCCESS on success.


******************************************************************************/

DWORD
GetDateFieldFormat(
                    OUT WORD* pwFormat
                    )
{
    LCID lcid;
    WCHAR szBuffer[MAX_BUF_SIZE];

    //Get the user default locale in the users computer
    lcid = GetUserDefaultLCID();

    //Get the date format
    if (GetLocaleInfo(lcid, LOCALE_IDATE, szBuffer, MAX_BUF_SIZE))
    {
        switch (szBuffer[0])
        {
            case TEXT('0'):
                *pwFormat = 0;
                 break;
            case TEXT('1'):
                *pwFormat = 1;
                 break;
            case TEXT('2'):
                *pwFormat = 2;
                 break;
            default:
                return RETVAL_FAIL;
        }
    }
    return RETVAL_SUCCESS;
}

/******************************************************************************

    Routine Description:

        This routine gets the date format string with respective to regional options.

    Arguments:

        [ out ] szFormat : Date format string.

     Return Value :
        Returns RETVAL_FAIL on failure and RETVAL_SUCCESS on success.

******************************************************************************/

DWORD
GetDateFormatString(
                    IN LPWSTR szFormat
                    )
{
    WORD wFormatID = 0;

    if ( RETVAL_FAIL == GetDateFieldFormat( &wFormatID ))
    {
        return RETVAL_FAIL;
    }


    if ( wFormatID == 0 )
    {
        StringCopy (szFormat, GetResString(IDS_MMDDYY_FORMAT), MAX_STRING_LENGTH);
    }
    else if ( wFormatID == 1 )
    {
        StringCopy (szFormat, GetResString( IDS_DDMMYY_FORMAT), MAX_STRING_LENGTH);
    }
    else if ( wFormatID == 2 )
    {
        StringCopy (szFormat, GetResString(IDS_YYMMDD_FORMAT), MAX_STRING_LENGTH);
    }
    else
    {
        return RETVAL_FAIL;
    }

    return RETVAL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\delete.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        delete.cpp

    Abstract:

        This module deletes the task(s) present in the system

    Author:

        Hari 10-Sep-2000

    Revision History:

        Hari 10-Sep-2000 : Created it
        G.Surender Reddy  25-Sep-2000 : Modified it [added error checking]
        G.Surender Reddy  31-Oct-2000 : Modified it
                                        [Moved strings to resource file]
        G.Surender Reddy  18-Nov-2000 : Modified it
                                        [Modified usage help to be displayed]
        G.Surender Reddy  15-Dec-2000 : Modified it
                                        [Removed getch() fn.& used Console API
                                            to read characters]
        G.Surender Reddy  22-Dec-2000 : Modified it
                                        [Rewrote the DisplayDeleteUsage() fn.]
        G.Surender Reddy  08-Jan-2001 : Modified it
                                        [Deleted the unused variables.]

******************************************************************************/


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


// Function declaration for the Usage function.
VOID DisplayDeleteUsage();
DWORD ConfirmDelete( LPCTSTR szTaskName , PBOOL pbFalg );


/*****************************************************************************

    Routine Description:

    This routine  deletes a specified scheduled task(s)

    Arguments:

        [ in ] argc :  Number of command line arguments
        [ in ] argv : Array containing command line arguments

    Return Value :
        A DWORD value indicating EXIT_SUCCESS on success else
        EXIT_FAILURE on failure

*****************************************************************************/

DWORD
DeleteScheduledTask(
                    IN DWORD argc,
                    IN LPCTSTR argv[]
                    )
{
    // Variables used to find whether Delete main option, Usage option
    // or the force option is specified or not
    BOOL bDelete = FALSE;
    BOOL bUsage = FALSE;
    BOOL bForce = FALSE;

    // Set the TaskSchduler object as NULL
    ITaskScheduler *pITaskScheduler = NULL;

    // Return value
    HRESULT hr  = S_OK;

    // Initialising the variables that are passed to TCMDPARSER structure
    LPWSTR  szServer = NULL;
    WCHAR  szTaskName[ MAX_JOB_LEN ] = L"\0";
    LPWSTR  szUser   = NULL;
    LPWSTR  szPassword = NULL;

    // For each task in all the tasks.
    WCHAR szEachTaskName[ MAX_JOB_LEN ];
    BOOL bWrongValue = FALSE;

    // Task name or the job name which is to be deleted
    WCHAR wszJobName[MAX_JOB_LEN] ;

    // Dynamic Array contaning array of jobs
    TARRAY arrJobs = NULL;

    // Loop Variable.
    DWORD dwJobCount = 0;
    //buffer for displaying error message
    WCHAR   szMessage[2 * MAX_STRING_LENGTH] = L"\0";
    BOOL    bNeedPassword = FALSE;
    BOOL   bResult = FALSE;
    BOOL  bCloseConnection = TRUE;
    BOOL  bFlag = FALSE;

    TCMDPARSER2 cmdDeleteOptions[MAX_DELETE_OPTIONS];
    BOOL bReturn = FALSE;
    DWORD dwPolicy = 0;

    // /delete sub-options
    const WCHAR szDeleteOpt[]           = L"delete";
    const WCHAR szDeleteHelpOpt[]       = L"?";
    const WCHAR szDeleteServerOpt[]     = L"s";
    const WCHAR szDeleteUserOpt[]       = L"u";
    const WCHAR szDeletePwdOpt[]        = L"p";
    const WCHAR szDeleteTaskNameOpt[]   = L"tn";
    const WCHAR szDeleteForceOpt[]      = L"f";

    // set all the fields to 0
    SecureZeroMemory( cmdDeleteOptions, sizeof( TCMDPARSER2 ) * MAX_DELETE_OPTIONS );

    //
    // fill the commandline parser
    //

    //  /delete option
    StringCopyA( cmdDeleteOptions[ OI_DELETE_OPTION ].szSignature, "PARSER2\0", 8 );
    cmdDeleteOptions[ OI_DELETE_OPTION ].dwType       = CP_TYPE_BOOLEAN;
    cmdDeleteOptions[ OI_DELETE_OPTION ].pwszOptions  = szDeleteOpt;
    cmdDeleteOptions[ OI_DELETE_OPTION ].dwCount = 1;
    cmdDeleteOptions[ OI_DELETE_OPTION ].dwFlags = 0;
    cmdDeleteOptions[ OI_DELETE_OPTION ].pValue = &bDelete;

    //  /? option
    StringCopyA( cmdDeleteOptions[ OI_DELETE_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdDeleteOptions[ OI_DELETE_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdDeleteOptions[ OI_DELETE_USAGE ].pwszOptions  = szDeleteHelpOpt;
    cmdDeleteOptions[ OI_DELETE_USAGE ].dwCount = 1;
    cmdDeleteOptions[ OI_DELETE_USAGE ].dwFlags = CP2_USAGE;
    cmdDeleteOptions[ OI_DELETE_USAGE ].pValue = &bUsage;

    //  /s option
    StringCopyA( cmdDeleteOptions[ OI_DELETE_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdDeleteOptions[ OI_DELETE_SERVER ].dwType       = CP_TYPE_TEXT;
    cmdDeleteOptions[ OI_DELETE_SERVER ].pwszOptions  = szDeleteServerOpt;
    cmdDeleteOptions[ OI_DELETE_SERVER ].dwCount = 1;
    cmdDeleteOptions[ OI_DELETE_SERVER ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /u option
    StringCopyA( cmdDeleteOptions[ OI_DELETE_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdDeleteOptions[ OI_DELETE_USERNAME ].dwType       = CP_TYPE_TEXT;
    cmdDeleteOptions[ OI_DELETE_USERNAME ].pwszOptions  = szDeleteUserOpt;
    cmdDeleteOptions[ OI_DELETE_USERNAME ].dwCount = 1;
    cmdDeleteOptions[ OI_DELETE_USERNAME ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /p option
    StringCopyA( cmdDeleteOptions[ OI_DELETE_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdDeleteOptions[ OI_DELETE_PASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdDeleteOptions[ OI_DELETE_PASSWORD ].pwszOptions  = szDeletePwdOpt;
    cmdDeleteOptions[ OI_DELETE_PASSWORD ].dwCount = 1;
    cmdDeleteOptions[ OI_DELETE_PASSWORD ].dwActuals = 0;
    cmdDeleteOptions[ OI_DELETE_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;

    //  /tn option
    StringCopyA( cmdDeleteOptions[ OI_DELETE_TASKNAME ].szSignature, "PARSER2\0", 8 );
    cmdDeleteOptions[ OI_DELETE_TASKNAME ].dwType       = CP_TYPE_TEXT;
    cmdDeleteOptions[ OI_DELETE_TASKNAME ].pwszOptions  = szDeleteTaskNameOpt;
    cmdDeleteOptions[ OI_DELETE_TASKNAME ].dwCount = 1;
    cmdDeleteOptions[ OI_DELETE_TASKNAME ].dwFlags = CP2_MANDATORY;
    cmdDeleteOptions[ OI_DELETE_TASKNAME ].pValue = szTaskName;
    cmdDeleteOptions[ OI_DELETE_TASKNAME ].dwLength = MAX_JOB_LEN;


    //  /f option
    StringCopyA( cmdDeleteOptions[ OI_DELETE_FORCE ].szSignature, "PARSER2\0", 8 );
    cmdDeleteOptions[ OI_DELETE_FORCE ].dwType       = CP_TYPE_BOOLEAN;
    cmdDeleteOptions[ OI_DELETE_FORCE ].pwszOptions  = szDeleteForceOpt;
    cmdDeleteOptions[ OI_DELETE_FORCE ].dwCount = 1;
    cmdDeleteOptions[ OI_DELETE_FORCE ].pValue = &bForce;


    //parse command line arguments
    bReturn = DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdDeleteOptions), cmdDeleteOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }


    // get the buffer pointers allocated by command line parser
    szServer = (LPWSTR)cmdDeleteOptions[ OI_CREATE_SERVER ].pValue;
    szUser = (LPWSTR)cmdDeleteOptions[ OI_CREATE_USERNAME ].pValue;
    szPassword = (LPWSTR)cmdDeleteOptions[ OI_CREATE_PASSWORD ].pValue;


    if ( (argc > 3) && (bUsage  == TRUE) )
    {
        ShowMessage ( stderr, GetResString (IDS_ERROR_DELETEPARAM) );
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // Displaying delete usage if user specified -? with -delete option
    if( bUsage == TRUE )
    {
        DisplayDeleteUsage();
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    // check for invalid user name
    if( ( cmdDeleteOptions[OI_DELETE_SERVER].dwActuals == 0 ) && ( cmdDeleteOptions[OI_DELETE_USERNAME].dwActuals == 1 )  )
    {
        ShowMessage(stderr, GetResString(IDS_DELETE_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }


    // check whether username is specified or not along with the password
    if ( cmdDeleteOptions[ OI_DELETE_USERNAME ].dwActuals == 0 && cmdDeleteOptions[OI_DELETE_PASSWORD].dwActuals == 1 )
    {
        // invalid syntax
        ShowMessage(stderr, GetResString(IDS_DPASSWORD_BUT_NOUSERNAME));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }

    // check for the length of the taskname
    if( ( StringLength( szTaskName, 0 ) > MAX_JOB_LEN ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_TASKLENGTH));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }


    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( szServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( szUser == NULL )
        {
            szUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szUser == NULL )
            {
                SaveLastError();
                return RETVAL_FAIL;
            }
        }

        // password
        if ( szPassword == NULL )
        {
            bNeedPassword = TRUE;
            szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szPassword == NULL )
            {
                SaveLastError();
                return RETVAL_FAIL;
            }
        }

        // case 1
        if ( cmdDeleteOptions[ OI_DELETE_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdDeleteOptions[ OI_DELETE_PASSWORD ].pValue == NULL )
        {
            StringCopy( szPassword, L"*", GetBufferSize(szPassword)/sizeof(WCHAR));
        }

        // case 3
        else if ( StringCompareEx( szPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&szPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                return RETVAL_FAIL;
            }

            // ...
            bNeedPassword = TRUE;
        }
    }


    if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdDeleteOptions[OI_DELETE_USERNAME].dwActuals == 1 ) )
    {
        bFlag = TRUE;
        // Establish the connection on a remote machine
        bResult = EstablishConnection(szServer,szUser,GetBufferSize(szUser)/sizeof(WCHAR),szPassword,GetBufferSize(szPassword)/sizeof(WCHAR), bNeedPassword );
        if (bResult == FALSE)
        {
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            FreeMemory((LPVOID*) &szServer);
            FreeMemory((LPVOID*) &szUser);
            FreeMemory((LPVOID*) &szPassword);
            return EXIT_FAILURE ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                    bCloseConnection = FALSE;
                    break;

            // for mismatched credentials
            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
                    ShowMessage( stderr, GetReason());
                    FreeMemory((LPVOID*) &szServer);
                    FreeMemory((LPVOID*) &szUser);
                    FreeMemory((LPVOID*) &szPassword);
                    return EXIT_FAILURE;
                }
             default :
                 bCloseConnection = TRUE;
            }
        }

        //release memory for password
        FreeMemory((LPVOID*) &szPassword);
    }

    // Get the task Scheduler object for the machine.
    pITaskScheduler = GetTaskScheduler( szServer );

    // If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {
        // close the connection that was established by the utility
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    //for holding values of parameters in FormatMessage()
    WCHAR* szValues[1] = {szTaskName};

    // Validate the Given Task and get as TARRAY in case of taskname
    // as *.
    arrJobs = ValidateAndGetTasks( pITaskScheduler, szTaskName);
    if( arrJobs == NULL )
    {
        if(StringCompare(szTaskName, ASTERIX, TRUE, 0) == 0)
        {
            ShowMessage(stdout,GetResString(IDS_TASKNAME_NOTASKS));
            // close the connection that was established by the utility
            if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
            {
                CloseConnection( szServer );
            }

            Cleanup(pITaskScheduler);
            FreeMemory((LPVOID*) &szServer);
            FreeMemory((LPVOID*) &szUser);
            FreeMemory((LPVOID*) &szPassword);
            return EXIT_SUCCESS;
        }
        else
        {
            StringCchPrintf( szMessage , SIZE_OF_ARRAY(szMessage) , GetResString(IDS_TASKNAME_NOTEXIST), _X( szTaskName ));
            ShowMessage(stderr, szMessage );
        }

        // close the connection that was established by the utility
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;

    }

     // check whether the group policy prevented user from deleting tasks or not.
    if ( FALSE == GetGroupPolicy( szServer, szUser, TS_KEYPOLICY_DENY_DELETE , &dwPolicy ) )
    {
        // close the connection that was established by the utility
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }
    
    if ( dwPolicy > 0 )
    {
        ShowMessage ( stdout, GetResString (IDS_PREVENT_DELETE));
        // close the connection that was established by the utility
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    // Confirm whether delete operation is to be perfromed
    if( !bForce && ConfirmDelete( szTaskName , &bWrongValue ) )
    {
        // close the connection that was established by the utility
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        if ( bWrongValue == TRUE )
        {
            return EXIT_FAILURE;
        }
        else
        {
            return EXIT_SUCCESS;
        }
    }

    // Loop through all the Jobs.
    for( dwJobCount = 0; dwJobCount < DynArrayGetCount(arrJobs); dwJobCount++ )
    {
        // Get Each TaskName in the Array.
        StringCopy (szEachTaskName, DynArrayItemAsString( arrJobs, dwJobCount ), SIZE_OF_ARRAY(szEachTaskName) );

        StringCopy ( wszJobName, szEachTaskName , SIZE_OF_ARRAY(wszJobName));

        // Parse the Task so that .job is removed.
         if ( ParseTaskName( szEachTaskName ) )
         {
            Cleanup(pITaskScheduler);
            FreeMemory((LPVOID*) &szServer);
            FreeMemory((LPVOID*) &szUser);
            FreeMemory((LPVOID*) &szPassword);
            return EXIT_FAILURE;
         }

        // Calling the delete method of ITaskScheduler interface
        hr = pITaskScheduler->Delete(wszJobName);
        szValues[0] = (WCHAR*) szEachTaskName;
        // Based on the return value
        switch (hr)
        {
            case S_OK:

                StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_SUCCESS_DELETED), _X(szEachTaskName));
                ShowMessage ( stdout, _X(szMessage));

                break;
            case E_INVALIDARG:
                ShowMessage(stderr,GetResString(IDS_INVALID_ARG));

                // close the connection that was established by the utility
                if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
                {
                    CloseConnection( szServer );
                }

                Cleanup(pITaskScheduler);
                FreeMemory((LPVOID*) &szServer);
                FreeMemory((LPVOID*) &szUser);
                FreeMemory((LPVOID*) &szPassword);
                return EXIT_FAILURE;
            case E_OUTOFMEMORY:
                ShowMessage(stderr,GetResString(IDS_NO_MEMORY));

               // close the connection that was established by the utility
                if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
                {
                    CloseConnection( szServer );
                }

                Cleanup(pITaskScheduler);
                FreeMemory((LPVOID*) &szServer);
                FreeMemory((LPVOID*) &szUser);
                FreeMemory((LPVOID*) &szPassword);
                return EXIT_FAILURE;
            default:
                SetLastError ((DWORD) hr);
                ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

                // close the connection that was established by the utility
                if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
                {
                    CloseConnection( szServer );
                }

                Cleanup(pITaskScheduler);
                FreeMemory((LPVOID*) &szServer);
                FreeMemory((LPVOID*) &szUser);
                FreeMemory((LPVOID*) &szPassword);
                return EXIT_FAILURE;
        }

    }

   // close the connection that was established by the utility
    if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
    {
        CloseConnection( szServer );
    }

    Cleanup(pITaskScheduler);
    FreeMemory((LPVOID*) &szServer);
    FreeMemory((LPVOID*) &szUser);
    FreeMemory((LPVOID*) &szPassword);
    return EXIT_SUCCESS;
}

/*****************************************************************************

    Routine Description:

        This routine  displays the usage of -delete option

    Arguments:
        None

    Return Value :
        VOID
******************************************************************************/

VOID
DisplayDeleteUsage()
{
    // Displaying delete usage
    DisplayUsage( IDS_DEL_HLP1, IDS_DEL_HLP23);
}

/******************************************************************************
    Routine Description:

        This function validates whether the tasks to be deleted are present
        in system & are valid.

    Arguments:

        [ in ] pITaskScheduler : Pointer to the ITaskScheduler Interface

        [ in ] szTaskName      : Array containing Task name

    Return Value :
        Array of type TARRAY containing tasks
******************************************************************************/

TARRAY
ValidateAndGetTasks(
                    IN ITaskScheduler *pITaskScheduler,
                    IN LPCTSTR szTaskName
                    )
{
    // Dynamic Array of Jobs
    TARRAY arrJobs = NULL;

    // Enumerating WorkItems
    IEnumWorkItems *pIEnum = NULL;

    if( (pITaskScheduler == NULL ) || ( szTaskName == NULL ) )
    {
        return NULL;
    }

    // Create a Dynamic Array
    arrJobs = CreateDynamicArray();
    if (NULL == arrJobs)
    {
        return NULL;
    }

    // Enumerate the Work Items
    HRESULT hr = pITaskScheduler->Enum(&pIEnum);
    if( FAILED( hr) )
    {
        if( pIEnum )
            pIEnum->Release();
        DestroyDynamicArray(&arrJobs);
        return NULL;
    }

    // Names and Tasks fetches.
    LPWSTR *lpwszNames = NULL;
    DWORD dwFetchedTasks = 0;
    DWORD dwTasks = 0;
    ITask *pITask = NULL;//ITask interface

    // Task found or not
    BOOL blnFound = FALSE;
    // array containing the Actual Taskname .
    WCHAR szActualTask[MAX_STRING_LENGTH] = L"\0";
    WCHAR szTmpTaskName[MAX_STRING_LENGTH] = L"\0";

    // Enumerate all the Work Items
    while (SUCCEEDED(pIEnum->Next(TASKS_TO_RETRIEVE,
                                   &lpwszNames,
                                   &dwFetchedTasks))
                      && (dwFetchedTasks != 0))
    {
            dwTasks = dwFetchedTasks - 1;

            // returns an pITask inteface for szEachTaskName
            hr = pITaskScheduler->Activate(lpwszNames[dwTasks],IID_ITask,
                                               (IUnknown**) &pITask);

            //case 1:
            // check whether the specified scheduled task is created under
            // some other user. If so, ignore the respective task and
            // continue to retrieve other tasks in the system.
            // If the taskname created under some other user return value
            // of above API must 0x80070005.

            //case 2:
            // check whether the respective .job file in %windir%\tasks\***.job is corrupted
            //or not. if corrupted, the above function fails and return the value
            // SCHED_E_UNKNOWN_OBJECT_VERSION. Eventhough, corrupted tasks would not shown in
            // UI..tasks would still exists in database..can remove specific/all task names
            // in task sheduler database.
            if (hr == 0x80070005 || hr == 0x8007000D || hr == SCHED_E_UNKNOWN_OBJECT_VERSION || hr == E_INVALIDARG )
            {
                // continue to retrieve other tasks
                continue;
            }

            if ( FAILED(hr))
            {

                CoTaskMemFree(lpwszNames[dwFetchedTasks]);

                if( pIEnum )
                {
                    pIEnum->Release();
                }

                DestroyDynamicArray(&arrJobs);

                return NULL;

            }

            // If the Task Name is * then get parse the tokens
            // and append the jobs.
            if(StringCompare( szTaskName , ASTERIX, TRUE, 0) == 0 )
            {

                StringCopy(szActualTask, lpwszNames[--dwFetchedTasks], SIZE_OF_ARRAY(szActualTask));

                StringCopy ( szTmpTaskName, szActualTask , SIZE_OF_ARRAY(szTmpTaskName));

                // Parse the Task so that .job is removed.
                 if ( ParseTaskName( szTmpTaskName ) )
                 {
                    CoTaskMemFree(lpwszNames[dwFetchedTasks]);

                    if( pIEnum )
                    {
                        pIEnum->Release();
                    }

                    DestroyDynamicArray(&arrJobs);

                    return NULL;
                 }

                // Append the task in the job array
                DynArrayAppendString( arrJobs, szActualTask, StringLength( szActualTask, 0 ) );

                // Set the found flag as True.
                blnFound = TRUE;

                // Free the Named Task Memory.
                CoTaskMemFree(lpwszNames[dwFetchedTasks]);
            }
            else
            {

                StringCopy( szActualTask, lpwszNames[--dwFetchedTasks], SIZE_OF_ARRAY(szActualTask));

                StringCopy ( szTmpTaskName, szActualTask, SIZE_OF_ARRAY(szTmpTaskName) );

                // Parse the TaskName to remove the .job extension.
                if ( ParseTaskName( szTmpTaskName ) )
                {
                    CoTaskMemFree(lpwszNames[dwFetchedTasks]);

                    if( pIEnum )
                    {
                        pIEnum->Release();
                    }

                    DestroyDynamicArray(&arrJobs);

                    return NULL;
                }

                // If the given Task matches with the TaskName present then form
                // the TARRAY with this task and return.
                if( StringCompare( szTmpTaskName, szTaskName, TRUE, 0 )  == 0 )
                {
                    CoTaskMemFree(lpwszNames[dwFetchedTasks]);
                    DynArrayAppendString( arrJobs, szActualTask,
                                     StringLength( szActualTask, 0 ) );

                    if( pIEnum )
                        pIEnum->Release();
                    return arrJobs;
                }
            }
    }

    CoTaskMemFree(lpwszNames);

    if( pIEnum )
        pIEnum->Release();

    if( !blnFound )
    {
        DestroyDynamicArray(&arrJobs);
        return NULL;
    }

    // return the TARRAY object.
    return arrJobs;
}


DWORD
ConfirmDelete(
                IN LPCTSTR szTaskName ,
                OUT PBOOL pbFalg
                )
/*++
    Routine Description:

        This function confirms from the user really to delete the task(s).

    Arguments:

        [ in ] szTaskName  : Array containing Task name
        [ out ] pbFalg     : Boolean flag to check whether wrong information entered
                             in the console or not.
    Return Value :
        EXIT_SUCCESS on success else EXIT_FAILURE

--*/

{
    // sub-local variables
    DWORD   dwCharsRead = 0;
    DWORD   dwPrevConsoleMode = 0;
    HANDLE  hInputConsole = NULL;
    BOOL    bIndirectionInput   = FALSE;
    CHAR chAnsi = '\0';
    CHAR szAnsiBuf[ 10 ] = "\0";
    WCHAR chTmp = L'\0';
    WCHAR wch = L'\0';
    DWORD dwCharsWritten = 0;
    WCHAR szBuffer[MAX_RES_STRING];
    TCHAR szBackup[MAX_RES_STRING];
    TCHAR szTmpBuf[MAX_RES_STRING];
    WCHAR szMessage [2 * MAX_STRING_LENGTH];
    DWORD dwIndex = 0 ;
    BOOL  bNoBreak = TRUE;

    //intialize the variables
    SecureZeroMemory ( szBuffer, SIZE_OF_ARRAY(szBuffer));
    SecureZeroMemory ( szTmpBuf, SIZE_OF_ARRAY(szTmpBuf));
    SecureZeroMemory ( szBackup, SIZE_OF_ARRAY(szBackup));
    SecureZeroMemory ( szMessage, SIZE_OF_ARRAY(szMessage));

    if ( szTaskName == NULL )
    {
        return FALSE;
    }

    // Get the handle for the standard input
    hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
    if ( hInputConsole == INVALID_HANDLE_VALUE  )
    {
        SaveLastError();
        // could not get the handle so return failure
        return EXIT_FAILURE;
    }

    MessageBeep(MB_ICONEXCLAMATION);

    // Check for the input redirect
    if( ( hInputConsole != (HANDLE)0x0000000F ) &&
        ( hInputConsole != (HANDLE)0x00000003 ) &&
        ( hInputConsole != INVALID_HANDLE_VALUE ) )
    {
        bIndirectionInput   = TRUE;
    }

    // if there is no redirection
    if ( bIndirectionInput == FALSE )
    {
        // Get the current input mode of the input buffer
        if ( FALSE == GetConsoleMode( hInputConsole, &dwPrevConsoleMode ))
        {
            SaveLastError();
            // could not set the mode, return failure
            return EXIT_FAILURE;
        }

        // Set the mode such that the control keys are processed by the system
        if ( FALSE == SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) )
        {
            SaveLastError();
            // could not set the mode, return failure
            return EXIT_FAILURE;
        }
    }

    
    // Print the warning message.accoring to the taskname
    if( StringCompare( szTaskName , ASTERIX, TRUE, 0 ) == 0 )
    {
        ShowMessage(stdout, GetResString(IDS_WARN_DELETEALL));
    }
    else
    {
        StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_WARN_DELETE), _X(szTaskName));
        ShowMessage ( stdout, _X(szMessage));

    }


    // redirect the data into the console
    if ( bIndirectionInput  == TRUE )
    {
        do {
            //read the contents of file
            if ( ReadFile(hInputConsole, &chAnsi, 1, &dwCharsRead, NULL) == FALSE )
            {
                SaveLastError();
                // could not get the handle so return failure
                return EXIT_FAILURE;
            }

            // check if number of characters read were zero.. or
            // any carriage return pressed..
            if ( dwCharsRead == 0 || chTmp == CARRIAGE_RETURN || chTmp == L'\n' || chTmp == L'\t' )
            {
                bNoBreak = FALSE;
                // exit from the loop
                break;
            }
            else
            {
                // convert the ANSI character into UNICODE character
                szAnsiBuf[ 0 ] = chAnsi;
                dwCharsRead = SIZE_OF_ARRAY( szBuffer );
                GetAsUnicodeString2( szAnsiBuf, szBuffer, &dwCharsRead );
                chTmp = szBuffer[ 0 ];
            }

            // write the contents to the console
            if ( FALSE == WriteFile ( GetStdHandle( STD_OUTPUT_HANDLE ), &chTmp, 1, &dwCharsRead, NULL ) )
            {
                SaveLastError();
                // could not get the handle so return failure
                return EXIT_FAILURE;
            }

            // copy the character
            wch = chTmp;

            StringCchPrintf ( szBackup, SIZE_OF_ARRAY(szBackup), L"%c" , wch );

            // increment the index
            dwIndex++;

        } while (TRUE == bNoBreak);

    }
    else
    {
        do {
            // Get the Character and loop accordingly.
            if ( ReadConsole( hInputConsole, &chTmp, 1, &dwCharsRead, NULL ) == FALSE )
            {
                SaveLastError();

                // Set the original console settings
                if ( FALSE == SetConsoleMode( hInputConsole, dwPrevConsoleMode ) )
                {
                    SaveLastError();
                }
                // return failure
                return EXIT_FAILURE;
            }

            // check if number of chars read were zero..if so, continue...
            if ( dwCharsRead == 0 )
            {
                continue;
            }

            // check if any carriage return pressed...
            if ( chTmp == CARRIAGE_RETURN )
            {
                bNoBreak = FALSE;
                // exit from the loop
                break;
            }

            wch = chTmp;

            if ( wch != BACK_SPACE )
            {
                StringCchPrintf ( szTmpBuf, SIZE_OF_ARRAY(szTmpBuf), L"%c" , wch );
                StringConcat ( szBackup, szTmpBuf , SIZE_OF_ARRAY(szBackup));
            }

            // Check id back space is hit
            if ( wch == BACK_SPACE )
            {
                if ( dwIndex != 0 )
                {
                    //
                    // Remove a asterix from the console

                    // move the cursor one character back
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BACK_SPACE );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ) )
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }


                    // replace the existing character with space
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BLANK_CHAR );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ))
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }

                    // now set the cursor at back position
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BACK_SPACE );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ))
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }

                    szBackup [StringLength(szBackup, 0) - 1] = L'\0';
                    // decrement the index
                    dwIndex--;
                }

                // process the next character
                continue;
            }

            // write the contents onto console
            if ( FALSE == WriteFile ( GetStdHandle( STD_OUTPUT_HANDLE ), &wch, 1, &dwCharsRead, NULL ) )
            {
                SaveLastError();
                // return failure
                return EXIT_FAILURE;
            }

            // increment the index value
            dwIndex++;

        } while (TRUE == bNoBreak);

    }

    ShowMessage(stdout, _T("\n") );

    //StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , ch );

    if( (1 == dwIndex) && StringCompare ( szBackup, GetResString(IDS_UPPER_YES), TRUE, 0 ) == 0  )    {
        //Set the original console settings
        SetConsoleMode( hInputConsole, dwPrevConsoleMode );
        return EXIT_SUCCESS;
    }
    else if( (1 == dwIndex) && StringCompare ( szBackup, GetResString(IDS_UPPER_NO), TRUE, 0 ) == 0  )
    {
        // display a message as .. operation has been cancelled...
        ShowMessage ( stdout, GetResString (IDS_OPERATION_CANCELLED ) );
        SetConsoleMode( hInputConsole, dwPrevConsoleMode );
        return EXIT_FAILURE;
    }
    else
    {
        ShowMessage(stderr, GetResString( IDS_WRONG_INPUT_DELETE ));
        SetConsoleMode( hInputConsole, dwPrevConsoleMode );
        *pbFalg = TRUE;
        return EXIT_FAILURE;
    }

    //not returning anything as control never comes here...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\pch.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        pch.h

    Abstract:

        This header file is a precompiled header for this project.
        This module contains the common include files [ system,user defined ]
        which are not changed frequently.

    Author:

        B.Raghu Babu     10-oct-2000

    Revision History:

        B.Raghu Babu     10-oct-2000 : Created it

******************************************************************************/


#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000   // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#define CMDLINE_VERSION  200

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>

//
// public Windows header files
//
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <mstask.h>
#include <msterr.h>
#include <mbctype.h>
//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <wchar.h>
#include <io.h>
#include <sys/stat.h>
#include <crtdbg.h>
#include <assert.h>
#include <shlwapi.h>
#include <Wincon.h>
#include <errno.h>
#include <policy.hxx>
#include <strsafe.h>



// private Common header files

#include "cmdline.h"
#include "cmdlineres.h"



#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\end.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        run.h

    Abstract:

        This module contains the macros, user defined structures & function
        definitions needed by end.cpp

    Author:

        Venu Gopal Choudary   12-Mar-2001

    Revision History:

        Venu Gopal Choudary   12-Mar-2001  : Created it


******************************************************************************/

#ifndef __END_H
#define __END_H

#pragma once
#define MAX_END_OPTIONS         6

#define OI_END_OPTION           0 // Index of -end option in cmdOptions structure.
#define OI_END_USAGE            1 // Index of -? option in cmdOptions structure.
#define OI_END_SERVER           2 // Index of -s option in cmdOptions structure.
#define OI_END_USERNAME         3 // Index of -u option in cmdOptions structure.
#define OI_END_PASSWORD         4 // Index of -p option in cmdOptions structure.
#define OI_END_TASKNAME         5 // Index of -p option in cmdOptions structure.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\end.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        end.cpp

    Abstract:

        This module terminates the schedule task which is currently running in the system

    Author:

        Venu Gopal Choudary 12-Mar-2001

    Revision History:

        Venu Gopal Choudary  12-Mar-2001 : Created it


******************************************************************************/


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


// Function declaration for the Usage function.
VOID DisplayEndUsage();

/*****************************************************************************

    Routine Description:

    This routine terminates the scheduled task(s)

    Arguments:

        [ in ] argc :  Number of command line arguments
        [ in ] argv : Array containing command line arguments

    Return Value :
        A DWORD value indicating EXIT_SUCCESS on success else
        EXIT_FAILURE on failure

*****************************************************************************/

DWORD
TerminateScheduledTask(
                        IN DWORD argc,
                        IN LPCTSTR argv[]
                        )
{
    // Variables used to find whether End option, Usage option
    // are specified or not
    BOOL bEnd = FALSE;
    BOOL bUsage = FALSE;
    BOOL bFlag = FALSE;

    // Set the TaskSchduler object as NULL
    ITaskScheduler *pITaskScheduler = NULL;

    // Return value
    HRESULT hr  = S_OK;

    // Initialising the variables that are passed to TCMDPARSER structure
    LPWSTR  szServer = NULL;
    WCHAR  szTaskName[ MAX_JOB_LEN ] = L"\0";
    LPWSTR  szUser = NULL;
    LPWSTR  szPassword = NULL;

    // Dynamic Array contaning array of jobs
    TARRAY arrJobs = NULL;

    BOOL  bNeedPassword = FALSE;
    BOOL  bResult = FALSE;
    BOOL  bCloseConnection = TRUE;

    //buffer for displaying error message
    WCHAR   szMessage[2 * MAX_STRING_LENGTH] = L"\0";

    TCMDPARSER2 cmdEndOptions[MAX_END_OPTIONS];
    BOOL bReturn = FALSE;
    DWORD dwCheck = 0;
    DWORD dwPolicy = 0;

    // /run sub-options
    const WCHAR szEndnOpt[]           = L"end";
    const WCHAR szEndHelpOpt[]       = L"?";
    const WCHAR szEndServerOpt[]     = L"s";
    const WCHAR szEndUserOpt[]       = L"u";
    const WCHAR szEndPwdOpt[]        = L"p";
    const WCHAR szEndTaskNameOpt[]   = L"tn";


    // set all the fields to 0
    SecureZeroMemory( cmdEndOptions, sizeof( TCMDPARSER2 ) * MAX_END_OPTIONS );

    //
    // fill the commandline parser
    //

    //  /delete option
    StringCopyA( cmdEndOptions[ OI_END_OPTION ].szSignature, "PARSER2\0", 8 );
    cmdEndOptions[ OI_END_OPTION ].dwType       = CP_TYPE_BOOLEAN;
    cmdEndOptions[ OI_END_OPTION ].pwszOptions  = szEndnOpt;
    cmdEndOptions[ OI_END_OPTION ].dwCount = 1;
    cmdEndOptions[ OI_END_OPTION ].dwFlags = 0;
    cmdEndOptions[ OI_END_OPTION ].pValue = &bEnd;

    //  /? option
    StringCopyA( cmdEndOptions[ OI_END_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdEndOptions[ OI_END_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdEndOptions[ OI_END_USAGE ].pwszOptions  = szEndHelpOpt;
    cmdEndOptions[ OI_END_USAGE ].dwCount = 1;
    cmdEndOptions[ OI_END_USAGE ].dwFlags = CP2_USAGE;
    cmdEndOptions[ OI_END_USAGE ].pValue = &bUsage;

    //  /s option
    StringCopyA( cmdEndOptions[ OI_END_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdEndOptions[ OI_END_SERVER ].dwType       = CP_TYPE_TEXT;
    cmdEndOptions[ OI_END_SERVER].pwszOptions  = szEndServerOpt;
    cmdEndOptions[ OI_END_SERVER ].dwCount = 1;
    cmdEndOptions[ OI_END_SERVER ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /u option
    StringCopyA( cmdEndOptions[ OI_END_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdEndOptions[ OI_END_USERNAME ].dwType       = CP_TYPE_TEXT;
    cmdEndOptions[ OI_END_USERNAME ].pwszOptions  = szEndUserOpt;
    cmdEndOptions[ OI_END_USERNAME ].dwCount = 1;
    cmdEndOptions[ OI_END_USERNAME ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /p option
    StringCopyA( cmdEndOptions[ OI_END_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdEndOptions[ OI_END_PASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdEndOptions[ OI_END_PASSWORD ].pwszOptions  = szEndPwdOpt;
    cmdEndOptions[ OI_END_PASSWORD ].dwCount = 1;
    cmdEndOptions[ OI_END_PASSWORD ].dwActuals = 0;
    cmdEndOptions[ OI_END_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;

    //  /tn option
    StringCopyA( cmdEndOptions[ OI_END_TASKNAME ].szSignature, "PARSER2\0", 8 );
    cmdEndOptions[ OI_END_TASKNAME ].dwType       = CP_TYPE_TEXT;
    cmdEndOptions[ OI_END_TASKNAME ].pwszOptions  = szEndTaskNameOpt;
    cmdEndOptions[ OI_END_TASKNAME ].dwCount = 1;
    cmdEndOptions[ OI_END_TASKNAME ].dwFlags = CP2_MANDATORY;
    cmdEndOptions[ OI_END_TASKNAME ].pValue = szTaskName;
    cmdEndOptions[ OI_END_TASKNAME ].dwLength = MAX_JOB_LEN;

    //parse command line arguments
    bReturn = DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdEndOptions), cmdEndOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // get the buffer pointers allocated by command line parser
    szServer = (LPWSTR)cmdEndOptions[ OI_RUN_SERVER ].pValue;
    szUser = (LPWSTR)cmdEndOptions[ OI_RUN_USERNAME ].pValue;
    szPassword = (LPWSTR)cmdEndOptions[ OI_RUN_PASSWORD ].pValue;

    if ( (argc > 3) && (bUsage  == TRUE) )
    {
        ShowMessage ( stderr, GetResString (IDS_ERROR_ENDPARAM) );
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // Displaying end usage if user specified -? with -run option
    if( bUsage == TRUE )
    {
        DisplayEndUsage();
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    // check for invalid user name
    if( ( cmdEndOptions[OI_END_SERVER].dwActuals == 0 ) && ( cmdEndOptions[OI_END_USERNAME].dwActuals == 1 )  )
    {
        ShowMessage(stderr, GetResString(IDS_END_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }


    // check for invalid username
    if ( cmdEndOptions[ OI_END_USERNAME ].dwActuals == 0 && cmdEndOptions[ OI_END_PASSWORD ].dwActuals == 1 )
    {
        // invalid syntax
        ShowMessage(stderr, GetResString(IDS_EPASSWORD_BUT_NOUSERNAME));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;         // indicate failure
    }

    // check for the length of the taskname
    if( ( StringLength( szTaskName, 0 ) > MAX_JOB_LEN ) )
    {
        ShowMessage(stderr, GetResString(IDS_INVALID_TASKLENGTH));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }


    //for holding values of parameters in FormatMessage()
    WCHAR* szValues[1] = {NULL};

    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( szServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( szUser == NULL )
        {
            szUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szUser == NULL )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
				FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);
                return RETVAL_FAIL;
            }
        }

        // password
        if ( szPassword == NULL )
        {
            bNeedPassword = TRUE;
            szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szPassword == NULL )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
				FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);

                return RETVAL_FAIL;
            }
        }

        // case 1
        if ( cmdEndOptions[ OI_END_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdEndOptions[ OI_END_PASSWORD ].pValue == NULL )
        {
            StringCopy( szPassword, L"*", GetBufferSize(szPassword)/sizeof(WCHAR));
        }

        // case 3
        else if ( StringCompareEx( szPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&szPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
				FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);

                return RETVAL_FAIL;
            }

            // ...
            bNeedPassword = TRUE;
        }
    }


    if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdEndOptions[OI_END_USERNAME].dwActuals == 1 ))
    {
        bFlag = TRUE;
        // Establish the connection on a remote machine
        bResult = EstablishConnection(szServer,szUser,GetBufferSize(szUser)/sizeof(WCHAR),szPassword,GetBufferSize(szPassword)/sizeof(WCHAR), bNeedPassword);
        if (bResult == FALSE)
        {
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            //ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
            //ShowMessage( stderr, GetReason());
            FreeMemory((LPVOID*) &szServer);
            FreeMemory((LPVOID*) &szUser);
            FreeMemory((LPVOID*) &szPassword);
            return EXIT_FAILURE ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                    bCloseConnection = FALSE;
                    break;

            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                    //ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
                    //ShowMessage( stderr, GetReason());
                    FreeMemory((LPVOID*) &szServer);
                    FreeMemory((LPVOID*) &szUser);
                    FreeMemory((LPVOID*) &szPassword);
                    return EXIT_FAILURE;
                }
             default :
                 bCloseConnection = TRUE;
            }
        }

        //release memory for password
        FreeMemory((LPVOID*) &szPassword);
    }
    // Get the task Scheduler object for the machine.
    pITaskScheduler = GetTaskScheduler( szServer );

    // If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // check whether the task scheduler service is running or not.
    if ( TRUE == CheckServiceStatus(szServer, &dwCheck, FALSE) )
    {
        ShowMessage ( stderr, GetResString (IDS_SERVICE_NOT_RUNNING) );
    }

    // Validate the Given Task and get as TARRAY in case of taskname
    arrJobs = ValidateAndGetTasks( pITaskScheduler, szTaskName);
    if( arrJobs == NULL )
    {
        StringCchPrintf( szMessage , SIZE_OF_ARRAY(szMessage), GetResString(IDS_TASKNAME_NOTEXIST), _X( szTaskName ));
        ShowMessage(stderr, szMessage );

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;

    }

    // check whether the group policy prevented user from running or not.
    if ( FALSE == GetGroupPolicy( szServer, szUser, TS_KEYPOLICY_DENY_EXECUTION, &dwPolicy ) )
    {
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }
    
    if ( dwPolicy > 0 )
    {
        ShowMessage ( stdout, GetResString (IDS_PREVENT_END));
        
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;

    StringConcat ( szTaskName, JOB, SIZE_OF_ARRAY(szTaskName) );

    // return an pITask inteface for szTaskName
    hr = pITaskScheduler->Activate(szTaskName,IID_ITask,
                                       (IUnknown**) &pITask);

    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);

        return EXIT_FAILURE;
    }

    //WCHAR szBuffer[2 * MAX_STRING_LENGTH] = L"\0";

    if ( ParseTaskName( szTaskName ) )
    {
        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // terminate the scheduled task
    hr = pITask->Terminate();

    if ( FAILED(hr) )
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }
    else
    {
        szValues[0] = (WCHAR*) (szTaskName);

        StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_END_SUCCESSFUL), _X(szTaskName));
        ShowMessage(stdout, _X(szMessage));

    }

    if( pIPF )
        pIPF->Release();

    if( pITask )
        pITask->Release();

    if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

    Cleanup(pITaskScheduler);
    FreeMemory((LPVOID*) &szServer);
    FreeMemory((LPVOID*) &szUser);
    FreeMemory((LPVOID*) &szPassword);

    return EXIT_SUCCESS;
}

/*****************************************************************************

    Routine Description:

        This routine  displays the usage of -end option

    Arguments:
        None

    Return Value :
        VOID
******************************************************************************/

VOID
DisplayEndUsage()
{
    // Displaying run option usage
    DisplayUsage( IDS_END_HLP1, IDS_END_HLP17);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\query.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        query.cpp

    Abstract:

        This module queries the scheduled tasks present in the system & shows
        in the appropriate user specifed format.

    Author:

        G.Surender Reddy  10-Sep-2000

    Revision History:

        G.Surender Reddy  10-Sep-2000 : Created it
        G.Surender Reddy  25-Sep-2000 : Modified it
                                        [ Made changes to avoid memory leaks ]
        G.Surender Reddy  15-oct-2000 : Modified it
                                        [ Moved the strings to Resource table ]

******************************************************************************/


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

/******************************************************************************
    Routine Description:

        This function process the options specified in the command line ,
        Queries the tasks present in the system  and displays according
        to the user specied format

    Arguments:

        [ in ] argc :    The count of arguments specified in the command line
        [ in ] argv : Array of command line arguments

    Return Value :
        A DWORD value indicating EXIT_SUCCESS on success else
        EXIT_FAILURE on failure
******************************************************************************/

DWORD
QueryScheduledTasks(
                    IN DWORD argc,
                    IN LPCTSTR argv[]
                    )
{

    // Variables used to find whether Query main option or Usage option
    // specified or not
    BOOL    bQuery = FALSE;
    BOOL    bUsage = FALSE;
    BOOL    bHeader = FALSE;
    BOOL    bVerbose =  FALSE;

    // Initialising the variables that are passed to TCMDPARSER structure
    LPWSTR   szServer = NULL;
    LPWSTR   szUser = NULL;
    LPWSTR   szPassword = NULL;
    WCHAR   szFormat [ MAX_STRING_LENGTH ]   = L"\0";


    //Taskscheduler object to operate upon
    ITaskScheduler *pITaskScheduler = NULL;

    BOOL    bNeedPassword = FALSE;
    BOOL   bResult = FALSE;
    BOOL  bCloseConnection = TRUE;

    TCMDPARSER2 cmdQueryOptions[MAX_QUERY_OPTIONS];
    BOOL bReturn = FALSE;

    // /query sub-options
    const WCHAR szQueryOpt[]           = L"query";
    const WCHAR szQueryHelpOpt[]       = L"?";
    const WCHAR szQueryServerOpt[]     = L"s";
    const WCHAR szQueryUserOpt[]       = L"u";
    const WCHAR szQueryPwdOpt[]        = L"p";
    const WCHAR szQueryFormatOpt[]      = L"fo";
    const WCHAR szQueryNoHeaderOpt[]      = L"nh";
    const WCHAR szQueryVerboseOpt[]      = L"v";

    const WCHAR szFormatValues[]  = L"table|list|csv";


    // set all the fields to 0
    SecureZeroMemory( cmdQueryOptions, sizeof( TCMDPARSER2 ) * MAX_QUERY_OPTIONS );

    //
    // fill the commandline parser
    //

    //  /delete option
    StringCopyA( cmdQueryOptions[ OI_QUERY_OPTION ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_OPTION ].dwType       = CP_TYPE_BOOLEAN;
    cmdQueryOptions[ OI_QUERY_OPTION ].pwszOptions  = szQueryOpt;
    cmdQueryOptions[ OI_QUERY_OPTION ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_OPTION ].dwFlags = 0;
    cmdQueryOptions[ OI_QUERY_OPTION ].pValue = &bQuery;

    //  /? option
    StringCopyA( cmdQueryOptions[ OI_QUERY_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdQueryOptions[ OI_QUERY_USAGE ].pwszOptions  = szQueryHelpOpt;
    cmdQueryOptions[ OI_QUERY_USAGE ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_USAGE ].dwFlags = CP2_USAGE;
    cmdQueryOptions[ OI_QUERY_USAGE ].pValue = &bUsage;

    //  /s option
    StringCopyA( cmdQueryOptions[ OI_QUERY_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_SERVER ].dwType       = CP_TYPE_TEXT;
    cmdQueryOptions[ OI_QUERY_SERVER ].pwszOptions  = szQueryServerOpt;
    cmdQueryOptions[ OI_QUERY_SERVER ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_SERVER ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /u option
    StringCopyA( cmdQueryOptions[ OI_QUERY_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_USERNAME ].dwType       = CP_TYPE_TEXT;
    cmdQueryOptions[ OI_QUERY_USERNAME ].pwszOptions  = szQueryUserOpt;
    cmdQueryOptions[ OI_QUERY_USERNAME ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_USERNAME ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /p option
    StringCopyA( cmdQueryOptions[ OI_QUERY_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_PASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdQueryOptions[ OI_QUERY_PASSWORD ].pwszOptions  = szQueryPwdOpt;
    cmdQueryOptions[ OI_QUERY_PASSWORD ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_PASSWORD ].dwActuals = 0;
    cmdQueryOptions[ OI_QUERY_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;

    //  /fo option
    StringCopyA( cmdQueryOptions[ OI_QUERY_FORMAT ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_FORMAT ].dwType       = CP_TYPE_TEXT;
    cmdQueryOptions[ OI_QUERY_FORMAT ].pwszOptions  = szQueryFormatOpt;
    cmdQueryOptions[ OI_QUERY_FORMAT ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_FORMAT ].dwFlags = CP2_MODE_VALUES| CP2_VALUE_TRIMINPUT| CP2_VALUE_NONULL;
    cmdQueryOptions[ OI_QUERY_FORMAT ].pwszValues = szFormatValues;
    cmdQueryOptions[ OI_QUERY_FORMAT ].pValue = szFormat;
    cmdQueryOptions[ OI_QUERY_FORMAT ].dwLength = MAX_STRING_LENGTH;

    //  /nh option
    StringCopyA( cmdQueryOptions[ OI_QUERY_NOHEADER ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_NOHEADER ].dwType       = CP_TYPE_BOOLEAN;
    cmdQueryOptions[ OI_QUERY_NOHEADER ].pwszOptions  = szQueryNoHeaderOpt;
    cmdQueryOptions[ OI_QUERY_NOHEADER ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_NOHEADER ].dwFlags = 0;
    cmdQueryOptions[ OI_QUERY_NOHEADER ].pValue = &bHeader;


    //  /v option
    StringCopyA( cmdQueryOptions[ OI_QUERY_VERBOSE ].szSignature, "PARSER2\0", 8 );
    cmdQueryOptions[ OI_QUERY_VERBOSE ].dwType       = CP_TYPE_BOOLEAN;
    cmdQueryOptions[ OI_QUERY_VERBOSE ].pwszOptions  = szQueryVerboseOpt;
    cmdQueryOptions[ OI_QUERY_VERBOSE ].dwCount = 1;
    cmdQueryOptions[ OI_QUERY_VERBOSE ].dwFlags = 0;
    cmdQueryOptions[ OI_QUERY_VERBOSE ].pValue = &bVerbose;


     //parse command line arguments
    bReturn = DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdQueryOptions), cmdQueryOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // get the buffer pointers allocated by command line parser
    szServer = (LPWSTR)cmdQueryOptions[ OI_QUERY_SERVER ].pValue;
    szUser = (LPWSTR)cmdQueryOptions[ OI_QUERY_USERNAME ].pValue;
    szPassword = (LPWSTR)cmdQueryOptions[ OI_QUERY_PASSWORD ].pValue;

    if ( (argc > 3) && (bUsage  == TRUE) )
    {
        ShowMessage ( stderr, GetResString (IDS_ERROR_QUERYPARAM) );
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage == TRUE)
    {
        DisplayQueryUsage();
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    if ( cmdQueryOptions[ OI_QUERY_USERNAME ].dwActuals == 0 && cmdQueryOptions[OI_QUERY_PASSWORD].dwActuals == 1 )
    {
        // invalid syntax
        ShowMessage(stderr, GetResString(IDS_QPASSWORD_BUT_NOUSERNAME));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }

    // check for invalid user name
    if( ( cmdQueryOptions[OI_QUERY_SERVER].dwActuals == 0 ) && ( cmdQueryOptions[OI_QUERY_USERNAME].dwActuals == 1 )  )
    {
        ShowMessage(stderr, GetResString(IDS_QUERY_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }


    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( szServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( szUser == NULL )
        {
            szUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szUser == NULL )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
				FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);
                return RETVAL_FAIL;
            }
        }

        // password
        if ( szPassword == NULL )
        {
            bNeedPassword = TRUE;
            szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szPassword == NULL )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
				FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);

                return RETVAL_FAIL;
            }
        }

        // case 1
        if ( cmdQueryOptions[ OI_QUERY_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdQueryOptions[ OI_QUERY_PASSWORD ].pValue == NULL )
        {
            StringCopy( szPassword, L"*", GetBufferSize(szPassword)/sizeof(WCHAR));
        }

        // case 3
        else if ( StringCompareEx( szPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&szPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
				FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);

                return RETVAL_FAIL;
            }

            // ...
            bNeedPassword = TRUE;
        }
    }


    DWORD dwFormatType = SR_FORMAT_TABLE;//default format type(TABLE Format)
    BOOL bNoHeader = TRUE; // For  LIST  format type -nh switch is not applicable
    DWORD dwCheck = 0;

    //Determine the Format for display & check for error if any in format type

    if( StringCompare( szFormat , GetResString(IDS_QUERY_FORMAT_LIST), TRUE, 0 ) == 0 )
    {
        dwFormatType = SR_FORMAT_LIST;
        bNoHeader = FALSE;
    }
    else if( StringCompare( szFormat , GetResString(IDS_QUERY_FORMAT_CSV), TRUE, 0 ) == 0 )
    {
        dwFormatType = SR_FORMAT_CSV;
    }
    else
    {
        dwFormatType = SR_FORMAT_TABLE;
    }

    //If -n is specified for LIST or CSV then report error
    if( ( bNoHeader == FALSE ) && ( bHeader == TRUE ))
    {
        ShowMessage( stderr , GetResString(IDS_NOHEADER_NA ));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdQueryOptions[OI_QUERY_USERNAME].dwActuals == 1 ) )
    {
        // Establish the connection on a remote machine
        bResult = EstablishConnection(szServer,szUser,GetBufferSize(szUser)/sizeof(WCHAR),szPassword,GetBufferSize(szPassword)/sizeof(WCHAR), bNeedPassword );
        if (bResult == FALSE)
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            //ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
            //ShowMessage( stderr, GetReason());
            FreeMemory((LPVOID*) &szServer);
            FreeMemory((LPVOID*) &szUser);
            FreeMemory((LPVOID*) &szPassword);
            return EXIT_FAILURE ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                    bCloseConnection = FALSE;
                    break;

            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowMessage( stderr, GetResString(IDS_ERROR_STRING) );
                    ShowMessage( stderr, GetReason());
                    FreeMemory((LPVOID*) &szServer);
                    FreeMemory((LPVOID*) &szUser);
                    FreeMemory((LPVOID*) &szPassword);
                    return EXIT_FAILURE;
                }
             default :
                 bCloseConnection = TRUE;
            }
        }

        //release memory for password
        FreeMemory((LPVOID*) &szPassword);

    }

    //Fetch the TaskScheduler Interface to operate on
    pITaskScheduler = GetTaskScheduler( szServer );
    if(pITaskScheduler == NULL)
    {
        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( szServer );

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // check whether the task scheduler service is running or not.
    if ( TRUE == CheckServiceStatus(szServer, &dwCheck, FALSE) )
    {
        ShowMessage ( stderr, GetResString (IDS_SERVICE_NOT_RUNNING) );
    }

    //Display the tasks & its properties in the user specified format
    HRESULT hr = DisplayTasks(pITaskScheduler,bVerbose,dwFormatType,bHeader);

    if(FAILED(hr))
    {
        // close the connection that was established by the utility
        if ( bCloseConnection == TRUE )
            CloseConnection( szServer );

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // close the connection that was established by the utility
    if ( bCloseConnection == TRUE )
        CloseConnection( szServer );

    Cleanup(pITaskScheduler);
    FreeMemory((LPVOID*) &szServer);
    FreeMemory((LPVOID*) &szUser);
    FreeMemory((LPVOID*) &szPassword);
    return EXIT_SUCCESS;
}


/******************************************************************************
    Routine Description:

        This function displays the usage of -query option.

    Arguments:

        None

    Return Value :

        VOID
******************************************************************************/

VOID
DisplayQueryUsage()
{
    // Display the usage of -query option
    DisplayUsage( IDS_QUERY_HLP1, IDS_QUERY_HLP25);
}


/******************************************************************************
    Routine Description:

        This function retrieves the tasks present in the system & displays according to
        the user specified format.

    Arguments:

        [ in ] pITaskScheduler : Pointer to the ITaskScheduler Interface

        [ in ] bVerbose      : flag indicating whether the out is to be filtered.
        [ in ] dwFormatType  : Format type[TABLE,LIST,CSV etc]
        [ in ] bHeader       : Whether the header should be displayed in the output

    Return Value :
        A HRESULT  value indicating success code else failure code

******************************************************************************/

HRESULT
DisplayTasks(ITaskScheduler* pITaskScheduler,BOOL bVerbose,DWORD dwFormatType,
             BOOL bHeader)
{
    //declarations
    LPWSTR lpwszComputerName = NULL;
    HRESULT hr = S_OK;
    WCHAR szServerName[MAX_STRING_LENGTH] = L"\0";
    WCHAR szResolvedServerName[MAX_STRING_LENGTH] = L"\0";
    LPWSTR lpszTemp = NULL;
    DWORD dwResolvedServerLen = 0;

    StringCopy( szServerName , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szServerName));

    //Retrieve the name of the computer on which TaskScheduler is operated
    hr = pITaskScheduler->GetTargetComputer(&lpwszComputerName);
    if( SUCCEEDED( hr ) )
    {
        lpszTemp = lpwszComputerName;
        //Remove the backslash[\\] from the computer name
        lpwszComputerName = _wcsspnp( lpwszComputerName , L"\\" );
        if ( lpwszComputerName == NULL )
        {
            ShowMessage(stderr,GetResString(IDS_CREATE_READERROR));
            CoTaskMemFree(lpszTemp);
            return S_FALSE;
        }


        StringCopy (szServerName, lpwszComputerName, SIZE_OF_ARRAY(szServerName) );

        CoTaskMemFree(lpszTemp);

        dwResolvedServerLen = SIZE_OF_ARRAY(szResolvedServerName);

        if ( IsValidIPAddress( szServerName ) == TRUE  )
        {

            if( TRUE == GetHostByIPAddr( szServerName, szResolvedServerName , &dwResolvedServerLen, FALSE ) )
            {
                StringCopy( szServerName , szResolvedServerName, SIZE_OF_ARRAY(szServerName) );
            }
            else
            {
                StringCopy( szServerName , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szServerName));
            }

        }
    }


    //Initialize the TCOLUMNS structure array

    TCOLUMNS pVerboseCols[] =
    {
        {L"\0",WIDTH_HOSTNAME, SR_TYPE_STRING, COL_FORMAT_STRING, NULL, NULL},
        {L"\0",WIDTH_TASKNAME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_NEXTRUNTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_STATUS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_MODE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_LASTRUNTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_LASTRESULT,SR_TYPE_NUMERIC|SR_VALUEFORMAT,COL_FORMAT_HEX,NULL,NULL},
        {L"\0",WIDTH_CREATOR,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_SCHEDULE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_APPNAME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_WORKDIRECTORY,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_COMMENT,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKSTATE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKTYPE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKSTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKSDATE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKEDATE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKDAYS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKMONTHS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKRUNASUSER,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKDELETE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKSTOP,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASK_RPTEVERY,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASK_UNTILRPTTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASK_RPTDURATION,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASK_RPTRUNNING,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKIDLE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_TASKPOWER,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL}

    };

    TCOLUMNS pNonVerboseCols[] =
    {
        {L"\0",WIDTH_TASKNAME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_NEXTRUNTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",WIDTH_STATUS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL}
    };

    DWORD dwColCount = 0;
    int   j = 0;

    //Load the column names for non verbose mode
    if ( (dwFormatType == SR_FORMAT_TABLE) || (dwFormatType == SR_FORMAT_CSV) )
    {
        for( dwColCount = IDS_COL_TASKNAME , j = 0 ; dwColCount <= IDS_COL_STATUS;
         dwColCount++,j++)
         {
            StringCopy(pNonVerboseCols[j].szColumn ,GetResString(dwColCount), MAX_RES_STRING);
         }
    }

    //Load the column names for verbose mode
    for( dwColCount = IDS_COL_HOSTNAME , j = 0 ; dwColCount <= IDS_COL_POWER;
         dwColCount++,j++)
    {
        StringCopy(pVerboseCols[j].szColumn ,GetResString(dwColCount), MAX_RES_STRING);
    }

    TARRAY pColData = CreateDynamicArray();
    if ( NULL == pColData )
    {
        return S_FALSE;
    }

    size_t iArrSize = SIZE_OF_ARRAY( pVerboseCols );

    //latest declarations

    WCHAR  szTaskProperty[MAX_STRING_LENGTH] = L"\0";
    WCHAR  szScheduleName[MAX_STRING_LENGTH] = L"\0";
    WCHAR  szMessage[MAX_STRING_LENGTH] = L"\0";
    WCHAR  szBuffer[MAX_STRING_LENGTH] = L"\0";
    WCHAR  szTmpBuf[MAX_STRING_LENGTH] = L"\0";
    ITask *pITask = NULL;//ITask interface
    DWORD dwExitCode = 0;

    LPWSTR* lpwszNames = NULL;
    DWORD dwFetchedTasks = 0;
    int iTaskCount = 0;
    BOOL bTasksExists = FALSE;
    WCHAR szTime[MAX_DATETIME_LEN] = L"\0";
    WCHAR szDate[MAX_DATETIME_LEN] = L"\0";
    WCHAR szMode[MAX_STRING_LENGTH] = L"\0";

    //Index to the array of task names
    DWORD dwArrTaskIndex = 0;

    WORD wIdleMinutes = 0;
    WORD wDeadlineMinutes = 0 ;

    WCHAR szIdleTime[MAX_STRING_LENGTH] = L"\0";
    WCHAR szIdleRetryTime[MAX_STRING_LENGTH] = L"\0";
    WCHAR szTaskName[MAX_STRING_LENGTH] = L"\0";
    TASKPROPS tcTaskProperties;
    WCHAR* szValues[1] = {NULL};//for holding values of parameters in FormatMessage()
    BOOL    bOnBattery  = FALSE;
    BOOL    bStopTask  = FALSE;
    BOOL    bNotScheduled = FALSE;
    DWORD   dwNoTasks = 0;

    IEnumWorkItems *pIEnum = NULL;
    hr = pITaskScheduler->Enum(&pIEnum);//Get the IEnumWorkItems Interface

    if (FAILED(hr))
    {
        ShowMessage(stderr,GetResString(IDS_CREATE_READERROR));
        if( pIEnum )
            pIEnum->Release();
        return hr;
    }

    while (SUCCEEDED(pIEnum->Next(TASKS_TO_RETRIEVE,
                                    &lpwszNames,
                                    &dwFetchedTasks))
                      && (dwFetchedTasks != 0))
    {
        bTasksExists = TRUE;
        dwArrTaskIndex  = dwFetchedTasks - 1;


        StringCopy(szTaskName, lpwszNames[dwArrTaskIndex], SIZE_OF_ARRAY(szTaskName));

        if(szTaskName != NULL)
        {
            //remove the .job extension from the task name
            if (ParseTaskName(szTaskName))
            {
                CoTaskMemFree(lpwszNames[dwArrTaskIndex]);
                if(pIEnum)
                    pIEnum->Release();

                if(pITask)
                    pITask->Release();
                return S_FALSE;
            }
        }

        // return an pITask inteface for wszJobName
        hr = pITaskScheduler->Activate(lpwszNames[dwArrTaskIndex],IID_ITask,
                                       (IUnknown**) &pITask);

        //case 1:
        // check whether the specified scheduled task is created under
        // some other user. If so, ignore the respective task and
        // continue to retrieve other tasks in the system.
        // If the taskname created under some other user return value
        // of above API must 0x80070005.

        //case 2:
        // check whether the respective .job file in %windir%\tasks\***.job is corrupted
        //or not. if corrupted, the above function fails and return the value
        // SCHED_E_UNKNOWN_OBJECT_VERSION.
        if (hr == 0x80070005 || hr == 0x8007000D || hr == SCHED_E_UNKNOWN_OBJECT_VERSION || hr == E_INVALIDARG )
        {
             // check whether tasks are zero  or not
             if ( dwNoTasks == 0 )
             {
               bTasksExists = FALSE;
             }

             // continue to retrieve other tasks
             continue;
        }
        else
        {
            // count the number of tasks which are accessible under logged-on
            // user
            ++dwNoTasks;
        }


        if ( ( FAILED(hr) ) || (pITask == NULL) )
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            CoTaskMemFree(lpwszNames[dwArrTaskIndex]);
            if(pIEnum)
                pIEnum->Release();

            if(pITask)
                pITask->Release();
            return hr;
        }

        WORD wTriggerCount = 0;
        BOOL bMultiTriggers = FALSE;
        DWORD dwTaskFlags = 0;
        BOOL bInteractive = FALSE;

        hr = pITask->GetTriggerCount( &wTriggerCount );
        if ( FAILED(hr) )
        {
            SetLastError ((DWORD) hr);
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            CoTaskMemFree(lpwszNames[dwArrTaskIndex]);
            if(pIEnum)
                pIEnum->Release();

            if(pITask)
                pITask->Release();
            return hr;
        }

        // check for multiple triggers
        if( wTriggerCount > 1)
        {
            bMultiTriggers = TRUE;
        }

        // check for not scheduled tasks
        if ( wTriggerCount == 0 )
        {
            bNotScheduled = TRUE;
        }

        for( WORD wCurrentTrigger = 0; ( bNotScheduled == TRUE ) || ( wCurrentTrigger < wTriggerCount );
                                                    wCurrentTrigger++ )
        {
            //Start appending to the 2D array
            DynArrayAppendRow(pColData,(DWORD)iArrSize);

            // For LIST format
            if ( ( bVerbose == TRUE ) || (dwFormatType == SR_FORMAT_LIST ))
            {
                //Insert the server name
                DynArraySetString2(pColData,iTaskCount,HOSTNAME_COL_NUMBER,szServerName,0);
            }

            // For TABLE and CSV formats
            if ( ( bVerbose == FALSE ) && ( (dwFormatType == SR_FORMAT_TABLE) ||
                                    (dwFormatType == SR_FORMAT_CSV) ) )
            {
                DWORD dwTaskColNumber = TASKNAME_COL_NUMBER - 1;
                //Insert the task name for TABLE or CSV
                DynArraySetString2(pColData,iTaskCount,dwTaskColNumber,szTaskName,0);
            }
            else
            {
            //Insert the task name for verbose mode
            DynArraySetString2(pColData,iTaskCount,TASKNAME_COL_NUMBER,szTaskName,0);
            }

            StringCopy(szTime,L"\0", SIZE_OF_ARRAY(szTime));
            StringCopy(szDate,L"\0", SIZE_OF_ARRAY(szDate));

            // display the mode whether the system is running interactively under system
            // account or not
            hr = pITask->GetFlags(&dwTaskFlags);
            if ( FAILED(hr) )
            {
                SetLastError ((DWORD) hr);
                ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                CoTaskMemFree(lpwszNames[dwArrTaskIndex]);
                if(pIEnum)
                    pIEnum->Release();

                if(pITask)
                    pITask->Release();
                return hr;
            }

            //find the next run time of the task
            hr = GetTaskRunTime(pITask,szTime,szDate,TASK_NEXT_RUNTIME,wCurrentTrigger);
            if (FAILED(hr))
            {
                StringCopy( szTaskProperty , GetResString(IDS_TASK_NEVER), SIZE_OF_ARRAY(szTaskProperty) );
            }
            else
            {
                if(StringCompare( szDate , GetResString( IDS_TASK_IDLE ), TRUE, 0 ) == 0 ||
                   StringCompare( szDate , GetResString( IDS_TASK_SYSSTART ), TRUE, 0) == 0 ||
                   StringCompare( szDate , GetResString( IDS_TASK_LOGON ), TRUE, 0) == 0 ||
                   StringCompare( szDate , GetResString( IDS_TASK_NEVER ), TRUE, 0) == 0 )

                {
                    StringCopy( szTaskProperty , szDate, SIZE_OF_ARRAY(szTaskProperty) );
                }
                else
                {
                    StringCopy( szTaskProperty , szTime, SIZE_OF_ARRAY(szTaskProperty) );
                    StringConcat( szTaskProperty , TIME_DATE_SEPERATOR, SIZE_OF_ARRAY(szTaskProperty));
                    StringConcat( szTaskProperty , szDate, SIZE_OF_ARRAY(szTaskProperty));
                }
            }

            // check if task is already been disabled or not
            if ( (dwTaskFlags & TASK_FLAG_DISABLED) == TASK_FLAG_DISABLED )
            {
                StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_DISABLED), SIZE_OF_ARRAY(szTaskProperty) );
            }

            if ( ( bVerbose == FALSE ) && ( (dwFormatType == SR_FORMAT_TABLE) ||
                                        (dwFormatType == SR_FORMAT_CSV) ) )
            {
                DWORD dwNextRunTime = NEXTRUNTIME_COL_NUMBER - 1;
                //Insert the task name for TABLE or CSV
                DynArraySetString2(pColData,iTaskCount,dwNextRunTime,szTaskProperty,0);
            }
            else
            {
            //Insert the Next run time of the task
            DynArraySetString2(pColData,iTaskCount,NEXTRUNTIME_COL_NUMBER,szTaskProperty,0);
            }

            //retrieve the status code
            hr = GetStatusCode(pITask,szTaskProperty);
            if (FAILED(hr))
            {
                StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
            }

            if ( ( bVerbose == FALSE ) && ( (dwFormatType == SR_FORMAT_TABLE) ||
                                        (dwFormatType == SR_FORMAT_CSV) ) )
            {
                DWORD dwStatusColNum = STATUS_COL_NUMBER - 1;
                //Insert the task name for TABLE or CSV
                DynArraySetString2(pColData,iTaskCount,dwStatusColNum,szTaskProperty,0);
            }
            else
            {
            //Insert the status string
            DynArraySetString2(pColData,iTaskCount,STATUS_COL_NUMBER,szTaskProperty,0);
            }

            if ( dwTaskFlags & TASK_FLAG_RUN_ONLY_IF_LOGGED_ON )
            {
                bInteractive = TRUE;
            }

            if( bVerbose) //If V [verbose mode is present ,show all other columns]
            {
                StringCopy(szTime,L"\0", SIZE_OF_ARRAY(szTime));
                StringCopy(szDate,L"\0", SIZE_OF_ARRAY(szDate));

                //Insert the server name
                //DynArraySetString2(pColData,iTaskCount,HOSTNAME_COL_NUMBER,szServerName,0);

                //find the last run time of the task
                hr = GetTaskRunTime(pITask,szTime,szDate,TASK_LAST_RUNTIME,wCurrentTrigger);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_NEVER), SIZE_OF_ARRAY(szTaskProperty) );
                }
                else
                {
                    if(StringCompare( szDate , GetResString( IDS_TASK_IDLE ), TRUE, 0 ) == 0 ||
                       StringCompare( szDate , GetResString( IDS_TASK_SYSSTART ), TRUE, 0) == 0 ||
                       StringCompare( szDate , GetResString( IDS_TASK_LOGON ), TRUE, 0) == 0 ||
                       StringCompare( szDate , GetResString( IDS_TASK_NEVER ), TRUE, 0) == 0 )
                    {
                        StringCopy( szTaskProperty , szDate, SIZE_OF_ARRAY(szTaskProperty));
                    }
                    else
                    {
                        StringCopy( szTaskProperty , szTime, SIZE_OF_ARRAY(szTaskProperty) );
                        StringConcat( szTaskProperty , TIME_DATE_SEPERATOR, SIZE_OF_ARRAY(szTaskProperty));
                        StringConcat( szTaskProperty , szDate, SIZE_OF_ARRAY(szTaskProperty));
                    }
                }
                //Insert the task last run time
                DynArraySetString2(pColData,iTaskCount,LASTRUNTIME_COL_NUMBER,szTaskProperty,0);

                //retrieve the exit code
                 pITask->GetExitCode(&dwExitCode);

                //Insert the Exit code
                DynArraySetDWORD2(pColData,iTaskCount,LASTRESULT_COL_NUMBER,dwExitCode);

                // Get the creator name for the task
                hr = GetCreator(pITask,szTaskProperty);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                if( StringCompare( szTaskProperty , L"\0", TRUE, 0 ) == 0 )
                {
                        StringCopy( szTaskProperty , GetResString(IDS_QUERY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                //insert the creator name to 2D array
                DynArraySetString2(pColData,iTaskCount,CREATOR_COL_NUMBER,szTaskProperty,0);

                //retrieve the Trigger string
                hr = GetTriggerString(pITask,szTaskProperty,wCurrentTrigger);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_NOTSCHEDULED_TASK), SIZE_OF_ARRAY(szTaskProperty) );
                }

                // check if task is already been disabled or not
                if ( (dwTaskFlags & TASK_FLAG_DISABLED) == TASK_FLAG_DISABLED )
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_DISABLED), SIZE_OF_ARRAY(szTaskProperty) );
                }
                else
                {
                    StringCopy(szScheduleName, szTaskProperty, SIZE_OF_ARRAY(szScheduleName));
                }

                    //Insert the trigger string
                DynArraySetString2(pColData,iTaskCount,SCHEDULE_COL_NUMBER,szTaskProperty,0);


                //Get the application path associated with the task
                hr = GetApplicationToRun(pITask,szTaskProperty);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                if( StringCompare( szTaskProperty , L"\0", TRUE, 0 ) == 0 )
                {
                    StringCopy( szTaskProperty , GetResString(IDS_QUERY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                //Insert the application associated with task
                DynArraySetString2(pColData,iTaskCount,TASKTORUN_COL_NUMBER,szTaskProperty,0);

                //Get the working directory of the task's associated application
                 hr = GetWorkingDirectory(pITask,szTaskProperty);
                 if (FAILED(hr))
                 {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                 }

                 if( StringCompare( szTaskProperty , L"\0", TRUE, 0 ) == 0 )
                 {
                    StringCopy( szTaskProperty , GetResString(IDS_QUERY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                 }

                 //Insert the app.working directory
                 DynArraySetString2(pColData,iTaskCount,STARTIN_COL_NUMBER,szTaskProperty,0);


                //Get the comment name associated with the task
                hr = GetComment(pITask,szTaskProperty);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }
                //Insert the comment name

                if( StringCompare( szTaskProperty , L"\0", TRUE, 0 ) == 0 )
                {
                    StringCopy( szTaskProperty , GetResString(IDS_QUERY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                DynArraySetString2(pColData,iTaskCount,COMMENT_COL_NUMBER,szTaskProperty,0);

                //Determine the task state properties

                //Determine the TASK_FLAG_DISABLED
                hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_DISABLED);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                //Insert the TASK_FLAG_DISABLED state
                DynArraySetString2(pColData,iTaskCount,TASKSTATE_COL_NUMBER,szTaskProperty,0);

                //Determine the TASK_FLAG_DELETE_WHEN_DONE
                hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_DELETE_WHEN_DONE );
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                //Insert the TASK_FLAG_DELETE_WHEN_DONE state
                DynArraySetString2(pColData,iTaskCount,DELETE_IFNOTRESCHEDULED_COL_NUMBER,
                                szTaskProperty,0);

                //TASK_FLAG_START_ONLY_IF_IDLE
                //initialise to neutral values
                StringCopy(szIdleTime, GetResString(IDS_TASK_PROPERTY_DISABLED), SIZE_OF_ARRAY(szIdleTime));
                StringCopy(szIdleRetryTime, szIdleTime, SIZE_OF_ARRAY(szIdleRetryTime));

                hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_START_ONLY_IF_IDLE);
                if (FAILED(hr))
                {
                    StringCopy( szIdleTime , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szIdleTime) );
                    StringCopy( szIdleRetryTime , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szIdleRetryTime) );
                }

                if(StringCompare(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED), TRUE, 0) == 0 )
                {
                    //Display the rest applicable Idle fields
                    hr = pITask->GetIdleWait(&wIdleMinutes,&wDeadlineMinutes);

                    if ( SUCCEEDED(hr))
                    {
                        StringCchPrintf(szIdleTime, SIZE_OF_ARRAY(szIdleTime), _T("%d"),wIdleMinutes);
                        StringCchPrintf(szIdleRetryTime, SIZE_OF_ARRAY(szIdleRetryTime), _T("%d"),wDeadlineMinutes);
                    }

                    szValues[0] = (WCHAR*) szIdleTime;

                    StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_COL_IDLE_ONLYSTART),  szIdleTime );

                    StringCopy( szBuffer, szMessage, SIZE_OF_ARRAY(szBuffer) );
                    StringConcat( szBuffer, TIME_DATE_SEPERATOR, SIZE_OF_ARRAY(szBuffer) );

                    szValues[0] = (WCHAR*) szIdleRetryTime;

                    StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_COL_IDLE_NOTIDLE),  szIdleRetryTime );

                    StringConcat( szBuffer, szMessage, SIZE_OF_ARRAY(szBuffer) );

                    //Get the property of ( kill task if computer goes idle)
                    hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_KILL_ON_IDLE_END );
                    if (FAILED(hr))
                    {
                        StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                    }

                    if(StringCompare(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED), TRUE, 0) == 0 )
                    {
                        StringConcat( szBuffer, TIME_DATE_SEPERATOR, SIZE_OF_ARRAY(szBuffer) );
                        StringConcat( szBuffer, GetResString ( IDS_COL_IDLE_STOPTASK ), SIZE_OF_ARRAY(szBuffer) );
                    }

                    //Insert the property of ( kill task if computer goes idle)
                    DynArraySetString2(pColData,iTaskCount,IDLE_COL_NUMBER,szBuffer,0);

                }
                else
                {
                    DynArraySetString2(pColData,iTaskCount,IDLE_COL_NUMBER,szTaskProperty,0);
                }


                //Get the Power mgmt.properties
                hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_DONT_START_IF_ON_BATTERIES );
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                if(StringCompare(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED), TRUE, 0) ==0 )
                {
                    StringCopy(szBuffer, GetResString (IDS_COL_POWER_NOSTART), SIZE_OF_ARRAY(szBuffer));
                    bOnBattery = TRUE;
                }

                hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_KILL_IF_GOING_ON_BATTERIES);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                if(StringCompare(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED), TRUE, 0) ==0 )
                {
                    StringCopy( szMessage, GetResString (IDS_COL_POWER_STOP), SIZE_OF_ARRAY(szMessage));
                    bStopTask = TRUE;
                }

                if ( ( bOnBattery == TRUE ) && ( bStopTask == TRUE ) )
                {
                    StringCopy(szTmpBuf, szBuffer, SIZE_OF_ARRAY(szTmpBuf));
                    StringConcat( szTmpBuf, TIME_DATE_SEPERATOR, SIZE_OF_ARRAY(szTmpBuf) );
                    StringConcat( szTmpBuf, szMessage, SIZE_OF_ARRAY(szTmpBuf) );
                }
                else if ( ( bOnBattery == FALSE ) && ( bStopTask == TRUE ) )
                {
                    StringCopy( szTmpBuf, szMessage, SIZE_OF_ARRAY(szTmpBuf) );
                }
                else if ( ( bOnBattery == TRUE ) && ( bStopTask == FALSE ) )
                {
                    StringCopy( szTmpBuf, szBuffer, SIZE_OF_ARRAY(szTmpBuf) );
                }


                if( ( bOnBattery == FALSE )  && ( bStopTask == FALSE ) )
                {
                DynArraySetString2(pColData,iTaskCount,POWER_COL_NUMBER,szTaskProperty,0);
                }
                else
                {
                DynArraySetString2(pColData,iTaskCount,POWER_COL_NUMBER,szTmpBuf,0);
                }


                //Get RunAsUser
                hr = GetRunAsUser(pITask, szTaskProperty);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_USER_UNKNOWN), SIZE_OF_ARRAY(szTaskProperty) );
                }

                if( StringCompare( szTaskProperty , L"\0", TRUE, 0 ) == 0 )
                {
                    StringCopy( szTaskProperty ,  NTAUTHORITY_USER, SIZE_OF_ARRAY(szTaskProperty) );

                    // display the mode as background
                    StringCopy ( szMode, GetResString (IDS_COL_MODE_BACKGROUND), SIZE_OF_ARRAY(szMode) );
                }
                else
                {
                    if ( bInteractive == TRUE )
                    {
                        // display the mode as interactive
                        StringCopy ( szMode, GetResString (IDS_COL_MODE_INTERACTIVE), SIZE_OF_ARRAY(szMode) );
                    }
                    else
                    {
                        StringCopy ( szMode, GetResString (IDS_COL_MODE_INTERACT_BACK), SIZE_OF_ARRAY(szMode) );
                    }

                }

                DynArraySetString2(pColData, iTaskCount, MODE_COL_NUMBER, szMode, 0);

                DynArraySetString2(pColData,iTaskCount,RUNASUSER_COL_NUMBER,szTaskProperty,0);

                StringCopy( szTaskProperty , L"\0", SIZE_OF_ARRAY(szTaskProperty) );
                //Get the task's maximum run time & insert in the 2D array
                hr = GetMaxRunTime(pITask,szTaskProperty);
                if (FAILED(hr))
                {
                    StringCopy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szTaskProperty) );
                }

                DynArraySetString2(pColData,iTaskCount,STOPTASK_COL_NUMBER,szTaskProperty,0);

                hr = GetTaskProps(pITask,&tcTaskProperties,wCurrentTrigger, szScheduleName);
                if (FAILED(hr))
                {
                    StringCopy( tcTaskProperties.szTaskType , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szTaskType) );
                    StringCopy( tcTaskProperties.szTaskStartTime , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szTaskStartTime) );
                    StringCopy( tcTaskProperties.szTaskEndDate , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szTaskEndDate) );
                    StringCopy( tcTaskProperties.szTaskDays , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szTaskDays) );
                    StringCopy( tcTaskProperties.szTaskMonths , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szTaskMonths) );
                    StringCopy( tcTaskProperties.szRepeatEvery , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szRepeatEvery) );
                    StringCopy( tcTaskProperties.szRepeatUntilTime , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szRepeatUntilTime) );
                    StringCopy( tcTaskProperties.szRepeatDuration , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szRepeatDuration) );
                    StringCopy( tcTaskProperties.szRepeatStop , GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(tcTaskProperties.szRepeatStop) );

                }


                //Insert Task Type
                DynArraySetString2(pColData,iTaskCount,TASKTYPE_COL_NUMBER,
                                   tcTaskProperties.szTaskType, 0);
                //Insert start time
                DynArraySetString2(pColData,iTaskCount,STARTTIME_COL_NUMBER,
                                   tcTaskProperties.szTaskStartTime, 0);

                //Insert start Date
                DynArraySetString2(pColData,iTaskCount,STARTDATE_COL_NUMBER,
                                   tcTaskProperties.szTaskStartDate, 0);
                //Insert Task idle time
                if( StringCompare( tcTaskProperties.szTaskType , GetResString(IDS_TASK_IDLE), TRUE, 0 ) == 0 )
                {
                    hr = pITask->GetIdleWait(&wIdleMinutes,&wDeadlineMinutes);
                    if ( SUCCEEDED(hr))
                    {
                        StringCchPrintf(szIdleTime, SIZE_OF_ARRAY(szIdleTime), _T("%d"),wIdleMinutes);
                    }
                    else
                    {
                        StringCopy( szIdleTime,  GetResString(IDS_TASK_PROPERTY_NA), SIZE_OF_ARRAY(szIdleTime) );

                    }
                }


                //Insert Task End date
                DynArraySetString2(pColData,iTaskCount,ENDDATE_COL_NUMBER,
                                   tcTaskProperties.szTaskEndDate, 0);
                //Insert days value
                DynArraySetString2(pColData,iTaskCount,DAYS_COL_NUMBER,
                                   tcTaskProperties.szTaskDays,0);
                //Insert months value
                DynArraySetString2(pColData,iTaskCount,MONTHS_COL_NUMBER,
                                   tcTaskProperties.szTaskMonths,   0);

                //Insert repeat every time
                DynArraySetString2(pColData,iTaskCount, REPEAT_EVERY_COL_NUMBER ,
                                   tcTaskProperties.szRepeatEvery,0);

                //Insert repeat until time
                DynArraySetString2(pColData,iTaskCount,REPEAT_UNTILTIME_COL_NUMBER,
                                   tcTaskProperties.szRepeatUntilTime,0);

                //Insert repeat duration
                DynArraySetString2(pColData,iTaskCount,REPEAT_DURATION_COL_NUMBER,
                                   tcTaskProperties.szRepeatDuration,0);

                //Insert repeat stop if running
                DynArraySetString2(pColData,iTaskCount,REPEAT_STOP_COL_NUMBER,
                                   tcTaskProperties.szRepeatStop,0);


            }//end of bVerbose
            if( bMultiTriggers == TRUE)
            {
                iTaskCount++;
            }

            bNotScheduled = FALSE;
        }//end of Trigger FOR loop


        CoTaskMemFree(lpwszNames[dwArrTaskIndex]);

        if( bMultiTriggers == FALSE)
            iTaskCount++;

        CoTaskMemFree(lpwszNames);

        if( pITask )
            pITask->Release();

    }//End of the enumerating tasks

    if(pIEnum)
        pIEnum->Release();

	//if there are no tasks display msg.
    if( bTasksExists == FALSE )
    {
        DestroyDynamicArray(&pColData);
        ShowMessage(stdout,GetResString(IDS_TASKNAME_NOTASKS));
        return S_OK;
    }

    if (dwFormatType != SR_FORMAT_CSV)
    {
        ShowMessage(stdout,_T("\n"));
    }

    if( bVerbose == FALSE )
    {
        if ( dwFormatType == SR_FORMAT_LIST )
        {
            iArrSize = COL_SIZE_LIST; // for LIST non-verbose mode only 4 columns
        }
        else
        {
            iArrSize = COL_SIZE_VERBOSE; // for non-verbose mode only 3 columns
        }

    }

    if(bHeader)
    {
        if ( ( bVerbose == FALSE ) &&
            ( (dwFormatType == SR_FORMAT_TABLE) || (dwFormatType == SR_FORMAT_CSV) ) )
        {
        ShowResults((DWORD)iArrSize,pNonVerboseCols,SR_HIDECOLUMN|dwFormatType,pColData);
        }
        else
        {
        ShowResults((DWORD)iArrSize,pVerboseCols,SR_HIDECOLUMN|dwFormatType,pColData);
        }
    }
    else
    {
        if ( ( bVerbose == FALSE ) &&
                ( (dwFormatType == SR_FORMAT_TABLE) || (dwFormatType == SR_FORMAT_CSV) ) )
        {
        ShowResults((DWORD)iArrSize,pNonVerboseCols,dwFormatType,pColData);
        }
        else
        {
        ShowResults((DWORD)iArrSize,pVerboseCols,dwFormatType,pColData);
        }
    }

    DestroyDynamicArray(&pColData);

    return S_OK;
}


BOOL 
CheckServiceStatus(
                    IN LPCTSTR szServer, 
                    IN OUT DWORD *dwCheck,
                    IN BOOL bFlag
                    )
/*++
Routine Description:
   This routine return if Task Scheduler services running or not.
Arguments:

    [in]  szServer   : Server Name.
    [in]  bFlag      : falg 

Return Value:
     BOOL : TRUE- Service is STOPEED.
            FALSE- Otherwise.
--*/
{
    SERVICE_STATUS ServiceStatus;
    LPWSTR wszComputerName = NULL;
    SC_HANDLE  SCMgrHandle = NULL;
    SC_HANDLE  SCSerHandle = NULL;
    LPWSTR pwsz = NULL;
    WORD wSlashCount = 0;
    WCHAR wszActualComputerName[ 2 * MAX_STRING_LENGTH ];
    BOOL  bCancel = FALSE;
    BOOL bNobreak = TRUE;

    SecureZeroMemory ( wszActualComputerName, SIZE_OF_ARRAY(wszActualComputerName));

    wszComputerName = (LPWSTR)szServer;

    if( IsLocalSystem(szServer) == FALSE )
    {
        StringCopy ( wszActualComputerName, DOMAIN_U_STRING, SIZE_OF_ARRAY(wszActualComputerName));
        //check whether the server name prefixed with \\ or not.
        if( wszComputerName != NULL )
        {
           pwsz =  wszComputerName;
           while ( ( *pwsz != NULL_U_CHAR ) && ( *pwsz == BACK_SLASH_U )  )
           {
                // server name prefixed with '\'..
                // so..increment the pointer and count number of black slashes..
                pwsz = _wcsinc(pwsz);
                wSlashCount++;
           }

            if( (wSlashCount == 2 ) ) // two back slashes are present
            {
              StringCopy( wszActualComputerName, wszComputerName, SIZE_OF_ARRAY(wszActualComputerName) );
            }
            else if ( wSlashCount == 0 )
            {
               //Append "\\" to computer name
               StringConcat(wszActualComputerName, wszComputerName, 2 * MAX_RES_STRING);
            }
        
         }
    }

    // open service manager
    SCMgrHandle = OpenSCManager( wszActualComputerName, NULL, SC_MANAGER_CONNECT );
    if ( NULL == SCMgrHandle)
    {
        *dwCheck = 1;
        return FALSE;
    } 

    // open service
    SCSerHandle =  OpenService( SCMgrHandle, SERVICE_NAME, SERVICE_START | SERVICE_QUERY_STATUS );
    if ( NULL == SCSerHandle)
    {
        *dwCheck = 1;
        CloseServiceHandle(SCMgrHandle);
        return FALSE;
    } 
    
    // get the status of service
    if ( FALSE == QueryServiceStatus( SCSerHandle,  &ServiceStatus) )
    {
        *dwCheck = 1;
        CloseServiceHandle(SCMgrHandle);
        CloseServiceHandle(SCSerHandle);
        return FALSE;
    }

    //check whether the service status is running or not..
    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING)
    {
        if ( TRUE == bFlag )
        {
            ShowMessage ( stdout, GetResString(IDS_CONFIRM_SERVICE));
            if (EXIT_FAILURE == ConfirmInput(&bCancel))
            {
                *dwCheck = 2;
                CloseServiceHandle(SCMgrHandle);
                CloseServiceHandle(SCSerHandle);
                return FALSE;
            }

            if ( TRUE == bCancel )
            {
                *dwCheck = 3;
                CloseServiceHandle(SCMgrHandle);
                CloseServiceHandle(SCSerHandle);

                // operation cancelled.. return with success..
                return FALSE;
            }

           // start the service
           if (FALSE == StartService( SCSerHandle, 0, NULL))
            {
                *dwCheck = 1;
                 //release handles
                CloseServiceHandle(SCMgrHandle);
                CloseServiceHandle(SCSerHandle);
                return FALSE;
            }
            else
            {
                // Since task scheduler service is taking some time to start..
                // check whether the task scheduler service is started or not..
                while (1)
                {
                     // get the status of service
                    if ( FALSE == QueryServiceStatus( SCSerHandle,  &ServiceStatus) )
                    {
                        *dwCheck = 1;
                        CloseServiceHandle(SCMgrHandle);
                        CloseServiceHandle(SCSerHandle);
                        return FALSE;
                    }

                    //check whether the service is started or not..
                    if (ServiceStatus.dwCurrentState != SERVICE_RUNNING)
                    {
                        // continue till service runs
                        continue;
                    }
                    else
                    {
                        // service is started ..
                        break;
                    }
                }
                
                
                 //release handles
                CloseServiceHandle(SCMgrHandle);
                CloseServiceHandle(SCSerHandle);
                return TRUE;
            }
        }
        else
        {
            //release handles
            CloseServiceHandle(SCMgrHandle);
            CloseServiceHandle(SCSerHandle);
            return TRUE;
        }
    }
    
    //release handles
    CloseServiceHandle(SCMgrHandle);
    CloseServiceHandle(SCSerHandle);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\querytasks.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        QueryTasks.cpp

    Abstract:

        This module queries the different properties of a Scheduled Task

    Author:

        G.Surender Reddy  10-Sept-2000

    Revision History:

        G.Surender Reddy  10-Sep-2000 : Created it
        G.Surender Reddy  25-Sep-2000 : Modified it
                                        [ Made changes to avoid memory leaks,
                                          changed to suit localization ]
        G.Surender Reddy  15-oct-2000 : Modified it
                                        [ Moved the strings to Resource table ]
******************************************************************************/


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


/******************************************************************************

    Routine Description:

        This function returns the next or last  run time of the task depending on
        the type of time specified by user.

    Arguments:

        [ in ]  pITask     : Pointer to the ITask interface
        [ out ] pszRunTime : pointer to the string containing Task run time[last or next]
        [ out ] pszRunDate : pointer to the string containing Task run Date[last or next]
        [ in ]  dwTimetype : Type of run time[TASK_LAST_RUNTIME or TASK_NEXT_RUNTIME]

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
GetTaskRunTime(
                IN ITask* pITask,
                IN WCHAR* pszRunTime,
                IN WCHAR* pszRunDate,
                IN DWORD dwTimetype,
                IN WORD wTriggerNum
                )
{
    HRESULT hr = S_OK;
    SYSTEMTIME tRunTime = {0,0,0,0,0,0,0,0};
    WCHAR szTime[MAX_DATETIME_LEN] = L"\0";
    WCHAR szDate[MAX_DATETIME_LEN] = L"\0";
    int iBuffSize = 0;
    BOOL bNoStartTime  = FALSE;
    BOOL bLocaleChanged = FALSE;
    LCID lcid;

    if(pITask == NULL)
    {
        return S_FALSE;
    }


    ITaskTrigger *pITaskTrigger = NULL;

    if( ( dwTimetype == TASK_NEXT_RUNTIME ) || ( dwTimetype == TASK_START_RUNTIME ) )
    {
        //determine the task type
        hr = pITask->GetTrigger(wTriggerNum,&pITaskTrigger);
        if ( FAILED(hr) )
        {
            if(pITaskTrigger)
            {
                pITaskTrigger->Release();
            }

            return hr;
        }

        TASK_TRIGGER Trigger;
        SecureZeroMemory(&Trigger, sizeof (TASK_TRIGGER));

        hr = pITaskTrigger->GetTrigger(&Trigger);
        if ( FAILED(hr) )
        {
            if( pITaskTrigger )
            {
                pITaskTrigger->Release();
            }

            return hr;
        }

        if( dwTimetype == TASK_START_RUNTIME )
        {
            tRunTime.wDay = Trigger.wBeginDay;
            tRunTime.wMonth = Trigger.wBeginMonth;
            tRunTime.wYear = Trigger.wBeginYear;
            tRunTime.wHour = Trigger.wStartHour;
            tRunTime.wMinute = Trigger.wStartMinute;

        }

        if((Trigger.TriggerType >= TASK_EVENT_TRIGGER_ON_IDLE)  &&
           (Trigger.TriggerType <= TASK_EVENT_TRIGGER_AT_LOGON))
        {
            switch(Trigger.TriggerType )
            {
                case TASK_EVENT_TRIGGER_ON_IDLE ://On Idle time
                    LoadString(NULL, IDS_TASK_IDLE , pszRunTime ,
                                  MAX_DATETIME_LEN );
                    break;
                case TASK_EVENT_TRIGGER_AT_SYSTEMSTART://At system start
                    LoadString(NULL, IDS_TASK_SYSSTART , pszRunTime ,
                                  MAX_DATETIME_LEN );
                    break;
                case TASK_EVENT_TRIGGER_AT_LOGON ://At logon time
                    LoadString(NULL, IDS_TASK_LOGON , pszRunTime ,
                                  MAX_DATETIME_LEN );
                    break;

                default:
                    break;


            }

            if( dwTimetype == TASK_START_RUNTIME )
            {
                bNoStartTime  = TRUE;
            }

            if( dwTimetype == TASK_NEXT_RUNTIME )
            {
                StringCopy( pszRunDate, pszRunTime, MAX_RES_STRING );
                if( pITaskTrigger )
                {
                    pITaskTrigger->Release();
                }
                return S_OK;
            }
        }


        if( dwTimetype == TASK_NEXT_RUNTIME )
        {
            hr = pITask->GetNextRunTime(&tRunTime);
            if (FAILED(hr))
            {
                if( pITaskTrigger )
                {
                    pITaskTrigger->Release();
                }

                return hr;
            }

           // check whether the task has next run time to run or not..
           // If not, Next Run Time would be "Never".
           if(( tRunTime.wHour == 0 ) && (tRunTime.wMinute == 0) && (tRunTime.wDay == 0) && 
              (tRunTime.wMonth == 0) && (tRunTime.wYear == 0) )
            {
                LoadString(NULL, IDS_TASK_NEVER , pszRunTime , MAX_DATETIME_LEN );
                StringCopy( pszRunDate, pszRunTime, MAX_RES_STRING );
                if( pITaskTrigger )
                {
                    pITaskTrigger->Release();
                }
                return S_OK;
            }

        }
        if( pITaskTrigger )
        {
            pITaskTrigger->Release();
        }
    }
    //Determine Task last run time
    else if(dwTimetype == TASK_LAST_RUNTIME )
    {
        // Retrieve task's last run time
        hr = pITask->GetMostRecentRunTime(&tRunTime);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        return S_FALSE;
    }


    if((hr == SCHED_S_TASK_HAS_NOT_RUN) && (dwTimetype == TASK_LAST_RUNTIME))
    {
        LoadString(NULL, IDS_TASK_NEVER , pszRunTime , MAX_DATETIME_LEN );
        StringCopy( pszRunDate, pszRunTime, MAX_RES_STRING );
        return S_OK;
    }

    // verify whether console supports the current locale fully or not
    lcid = GetSupportedUserLocale( bLocaleChanged );

    //Retrieve  the Date
    iBuffSize = GetDateFormat( lcid, 0, &tRunTime,
        (( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL), szDate, SIZE_OF_ARRAY( szDate ) );

    if(iBuffSize == 0)
    {
        return S_FALSE;
    }

    // to give the time string format as hh:mm:ss

    if(!bNoStartTime )
    {

        iBuffSize = GetTimeFormat( lcid, 0,
            &tRunTime,  (( bLocaleChanged == TRUE ) ? L"HH:mm:ss" : NULL),szTime, SIZE_OF_ARRAY( szTime ) );

        if(iBuffSize == 0)
        {
            return S_FALSE;
        }

    }

    if( StringLength(szTime, 0) )
    {
        StringCopy(pszRunTime, szTime, MAX_RES_STRING);
    }

    if( StringLength(szDate, 0) )
    {
        StringCopy(pszRunDate, szDate, MAX_RES_STRING);
    }

    return S_OK;

}

/******************************************************************************

    Routine Description:

        This function returns the status code description of a particular task.

    Arguments:

        [ in ] pITask         : Pointer to the ITask interface
        [ out ] pszStatusCode : pointer to the Task's status string

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
GetStatusCode(
            IN ITask* pITask,
            IN WCHAR* pszStatusCode
            )
{
    HRESULT hrStatusCode = S_OK;
    HRESULT hr = S_OK;
    DWORD   dwExitCode = 0;

    hr = pITask->GetStatus(&hrStatusCode);//Got status of the task
    if (FAILED(hr))
    {
        return hr;
    }

    *pszStatusCode = L'\0';

    switch(hrStatusCode)
    {
        case SCHED_S_TASK_READY:
            hr = pITask->GetExitCode(&dwExitCode);
            if (FAILED(hr))
            {
            LoadString(NULL, IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
            }
            else
            {
            LoadString(NULL, IDS_STATUS_READY , pszStatusCode , MAX_STRING_LENGTH );
            }
            break;
        case SCHED_S_TASK_RUNNING:
            LoadString(NULL, IDS_STATUS_RUNNING , pszStatusCode , MAX_STRING_LENGTH );
            break;
        case SCHED_S_TASK_NOT_SCHEDULED:

            hr = pITask->GetExitCode(&dwExitCode);
            if (FAILED(hr))
            {
            LoadString(NULL, IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
            }
            else
            {
            LoadString(NULL, IDS_STATUS_NOTYET , pszStatusCode , MAX_STRING_LENGTH );
            }
            break;
        case SCHED_S_TASK_HAS_NOT_RUN:

            hr = pITask->GetExitCode(&dwExitCode);
            if (FAILED(hr))
            {
            LoadString(NULL, IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
            }
            else
            {
            LoadString(NULL, IDS_STATUS_NOTYET , pszStatusCode , MAX_STRING_LENGTH );
            }
            break;
        case SCHED_S_TASK_DISABLED:
            hr = pITask->GetExitCode(&dwExitCode);
            if (FAILED(hr))
            {
            LoadString(NULL, IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
            }
            else
            {
            LoadString(NULL, IDS_STATUS_NOTYET , pszStatusCode , MAX_STRING_LENGTH );
            }
            break;

       default:
            LoadString( NULL, IDS_STATUS_UNKNOWN , pszStatusCode , MAX_STRING_LENGTH );
            break;
    }

    return S_OK;
}

/******************************************************************************

    Routine Description:

        This function returns the path of the scheduled task application

    Arguments:

        [ in ] pITask               : Pointer to the ITask interface
        [ out ] pszApplicationName  : pointer to the Task's scheduled application name

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
GetApplicationToRun(
                    IN ITask* pITask,
                    IN WCHAR* pszApplicationName
                    )
{
    LPWSTR lpwszApplicationName = NULL;
    LPWSTR lpwszParameters = NULL;
    WCHAR szAppName[MAX_STRING_LENGTH] = L"\0";
    WCHAR szParams[MAX_STRING_LENGTH] = L"\0";

    // get the entire path of application name
    HRESULT hr = pITask->GetApplicationName(&lpwszApplicationName);
    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszApplicationName);
        return hr;
    }

    // get the parameters
    hr = pITask->GetParameters(&lpwszParameters);
    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszApplicationName);
        CoTaskMemFree(lpwszParameters);
        return hr;
    }

    
    StringCopy( szAppName, lpwszApplicationName, SIZE_OF_ARRAY(szAppName));

    
    StringCopy(szParams, lpwszParameters, SIZE_OF_ARRAY(szParams));

    if(StringLength(szAppName, 0) == 0)
    {
        StringCopy(pszApplicationName, L"\0", MAX_STRING_LENGTH);
    }
    else
    {
        StringConcat( szAppName, _T(" "), SIZE_OF_ARRAY(szAppName) );
        StringConcat( szAppName, szParams, SIZE_OF_ARRAY(szAppName) );
        StringCopy( pszApplicationName, szAppName, MAX_STRING_LENGTH);
    }

    CoTaskMemFree(lpwszApplicationName);
    CoTaskMemFree(lpwszParameters);
    return S_OK;
}

/******************************************************************************

    Routine Description:

        This function returns the WorkingDirectory of the scheduled task application

    Arguments:

        [ in ] pITask       : Pointer to the ITask interface
        [ out ] pszWorkDir  : pointer to the Task's scheduled application working
                              directory

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
GetWorkingDirectory(ITask* pITask,WCHAR* pszWorkDir)
{

    LPWSTR lpwszWorkDir = NULL;
    WCHAR szWorkDir[MAX_STRING_LENGTH] = L"\0";
    HRESULT hr = S_OK;

    hr = pITask->GetWorkingDirectory(&lpwszWorkDir);
    if(FAILED(hr))
    {
        CoTaskMemFree(lpwszWorkDir);
        return hr;
    }

    StringCopy(szWorkDir, lpwszWorkDir, SIZE_OF_ARRAY(szWorkDir));

    if(StringLength(szWorkDir, 0) == 0)
    {
        StringCopy(pszWorkDir, L"\0", MAX_RES_STRING);
    }
    else
    {
        StringCopy(pszWorkDir,szWorkDir, MAX_RES_STRING);
    }

    CoTaskMemFree(lpwszWorkDir);

    return S_OK;
}

/******************************************************************************

    Routine Description:

        This function returns the comment of a task

    Arguments:

        [ in ] pITask       : Pointer to the ITask interface
        [ out ] pszComment : pointer to the Task's comment name

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

********************************************************************************/

HRESULT
GetComment(
            IN ITask* pITask,
            IN WCHAR* pszComment
            )
{
    LPWSTR lpwszComment = NULL;
    WCHAR szTaskComment[MAX_STRING_LENGTH] = L"\0";
    HRESULT hr = S_OK;

    hr = pITask->GetComment(&lpwszComment);
    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszComment);
        return hr;
    }
    
    StringCopy(szTaskComment, lpwszComment, SIZE_OF_ARRAY(szTaskComment));

    if(StringLength(szTaskComment, 0) == 0)
    {
        StringCopy(pszComment,L"\0", MAX_RES_STRING);
    }
    else
    {
        StringCopy(pszComment,szTaskComment, MAX_RES_STRING);
    }

    CoTaskMemFree(lpwszComment);
    return S_OK;
}

/******************************************************************************

    Routine Description:

        This function returns the creator name of a task

    Arguments:

        [ in ] pITask       : Pointer to the ITask interface
        [ out ] pszCreator   : pointer to the Task's creator name

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

*******************************************************************************/

HRESULT
GetCreator(
            IN ITask* pITask,
            IN WCHAR* pszCreator
            )
{
    LPWSTR lpwszCreator = NULL;
    WCHAR szTaskCreator[MAX_STRING_LENGTH] = L"\0";
    HRESULT hr = S_OK;

    hr = pITask->GetCreator(&lpwszCreator);
    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszCreator);
        return hr;
    }

    
    StringCopy(szTaskCreator, lpwszCreator, SIZE_OF_ARRAY(szTaskCreator));

    if(StringLength(szTaskCreator, 0) == 0)
    {
        StringCopy(pszCreator, L"\0", MAX_RES_STRING);
    }
    else
    {
        StringCopy(pszCreator,szTaskCreator, MAX_RES_STRING);
    }

    CoTaskMemFree(lpwszCreator);
    return S_OK;
}


/******************************************************************************

    Routine Description:

        This function returns the Trigger string of a task

    Arguments:

        [ in ] pITask       : Pointer to the ITask interface
        [ out ] pszTrigger  : pointer to the Task's trigger string

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
GetTriggerString(
                IN ITask* pITask,
                IN WCHAR* pszTrigger,
                IN WORD wTriggNum)
{
    LPWSTR lpwszTrigger = NULL;
    WCHAR szTaskTrigger[MAX_STRING_LENGTH] = L"\0";
    HRESULT hr = S_OK;

    hr = pITask->GetTriggerString(wTriggNum,&lpwszTrigger);
    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszTrigger);
        return hr;
    }

    StringCopy(szTaskTrigger, lpwszTrigger, SIZE_OF_ARRAY(szTaskTrigger));

    if(StringLength(szTaskTrigger, 0) == 0)
    {
        StringCopy(pszTrigger,L"\0", MAX_RES_STRING);
    }
    else
    {
        StringCopy(pszTrigger,szTaskTrigger, MAX_RES_STRING);
    }

    CoTaskMemFree(lpwszTrigger);
    return S_OK;
}

/******************************************************************************

    Routine Description:

        This function returns the user name of task

    Arguments:

        [ in ]  pITask       : Pointer to the ITask interface
        [ out ] pszRunAsUser : pointer to the user's task name

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

*******************************************************************************/

HRESULT
GetRunAsUser(
                IN ITask* pITask,
                IN WCHAR* pszRunAsUser
                )
{
    LPWSTR lpwszUser = NULL;
    WCHAR szUserName[MAX_STRING_LENGTH] = L"\0";
    HRESULT hr = S_OK;

    hr = pITask->GetAccountInformation(&lpwszUser);

    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszUser);
        return hr;
    }

    StringCopy(szUserName, lpwszUser, SIZE_OF_ARRAY(szUserName));

    if(StringLength(szUserName, 0) == 0)
    {
        StringCopy(pszRunAsUser,L"\0", MAX_RES_STRING);
    }
    else
    {
        StringCopy(pszRunAsUser, szUserName, MAX_RES_STRING);
    }

    CoTaskMemFree(lpwszUser);
    return S_OK;

}


/******************************************************************************

    Routine Description:

        This function returns the Maximium run time of a  task.

    Arguments:

        [ in ]  pITask          : Pointer to the ITask interface
        [ out ] pszMaxRunTime   : pointer to the Task's Maximum run time

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
GetMaxRunTime(
                IN ITask* pITask,
                IN WCHAR* pszMaxRunTime
                )
{

    DWORD dwRunTime = 0;
    DWORD dwHrs = 0;
    DWORD dwMins = 0;

    //Get the task max run time in milliseconds
    HRESULT hr = pITask->GetMaxRunTime(&dwRunTime);
    if (FAILED(hr))
    {
        return hr;
    }

    dwHrs = (dwRunTime / (1000 * 60 * 60));//Convert ms to hours
    dwMins = (dwRunTime % (1000 * 60 * 60));//get the minutes portion
    dwMins /= (1000 * 60);// Now convert to Mins

    if( (( dwHrs > 999 ) && ( dwMins > 99 )) ||(( dwHrs == 0 ) && ( dwMins == 0 ) ) )
    {
        //dwHrs = 0;
        //dwMins = 0;
        StringCopy( pszMaxRunTime , GetResString(IDS_TASK_PROPERTY_DISABLED), MAX_STRING_LENGTH );

    }
    else if ( dwHrs == 0 )
    {
        if( dwMins < 99 )
        {
            StringCchPrintf(pszMaxRunTime, MAX_STRING_LENGTH, _T("%d:%d"), dwHrs, dwMins);
        }
    }
    else if ( (dwHrs < 999) && (dwMins < 99) )
    {
        StringCchPrintf(pszMaxRunTime, MAX_STRING_LENGTH, _T("%d:%d"), dwHrs, dwMins);
    }
    else
    {
        StringCopy( pszMaxRunTime , GetResString(IDS_TASK_PROPERTY_DISABLED), MAX_STRING_LENGTH );
    }


    return S_OK;
}


/******************************************************************************

    Routine Description:

        This function returns the state of the task properties

    Arguments:

        [ in ]  pITask        : Pointer to the ITask interface
        [ out ] pszTaskState  : pointer holding the task's state
        [ in ]  dwFlagType    : flag indicating the task state

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

********************************************************************************/

HRESULT
GetTaskState(
            IN ITask* pITask,
            IN WCHAR* pszTaskState,
            IN DWORD dwFlagType)
{
    DWORD dwFlags = 0;
    HRESULT hr = S_OK;

    hr = pITask->GetFlags(&dwFlags);
    if(FAILED(hr))
    {
        return hr;
    }

    if(dwFlagType == TASK_FLAG_DISABLED)
    {
        if((dwFlags & dwFlagType) ==  dwFlagType)
        {
            LoadString(NULL, IDS_TASK_PROPERTY_DISABLED , pszTaskState , MAX_STRING_LENGTH );
        }
        else
        {
            LoadString(NULL, IDS_TASK_PROPERTY_ENABLED , pszTaskState , MAX_STRING_LENGTH );
        }

        return S_OK;
    }

    if((dwFlags & dwFlagType) ==  dwFlagType)
    {
        LoadString(NULL, IDS_TASK_PROPERTY_ENABLED , pszTaskState , MAX_STRING_LENGTH );
    }
    else
    {
        LoadString(NULL, IDS_TASK_PROPERTY_DISABLED , pszTaskState , MAX_STRING_LENGTH );
    }

    return S_OK;
}

/******************************************************************************

    Routine Description:

        This function retrives the task properties [modfier,task nextrun time etc]

    Arguments:

        [ in ]  pITask     : Pointer to the ITask interface
        [ out ] pTaskProps : pointer to the array of task properties

    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
GetTaskProps(
            IN ITask* pITask,
            OUT TASKPROPS* pTaskProps,
            IN WORD wTriggNum, 
            IN WCHAR* pszScName
            )
{
    WCHAR szWeekDay[MAX_STRING_LENGTH] = L"\0";
    WCHAR szMonthDay[MAX_STRING_LENGTH] = L"\0";
    WCHAR szWeek[MAX_STRING_LENGTH]  = L"\0";
    WCHAR szTime[MAX_DATETIME_LEN] = L"\0";
    WCHAR szDate[MAX_DATETIME_LEN] = L"\0";
    WCHAR* szValues[3] = {NULL,NULL,NULL};//for holding values of parameters in FormatMessage()
    WCHAR szBuffer[MAX_RES_STRING]  = L"\0";
    WCHAR szTempBuf[MAX_RES_STRING]  = L"\0";
    WCHAR szScheduleName[MAX_RES_STRING] = L"\0";

    ITaskTrigger *pITaskTrigger = NULL;
    HRESULT hr = S_OK;
    WCHAR *szToken = NULL;
    const WCHAR seps[]   = L" ";
    BOOL bMin = FALSE;
    BOOL bHour = FALSE;
    DWORD dwMinutes = 0;
    DWORD dwHours = 0;
    DWORD dwMinInterval = 0;
    DWORD dwMinDuration = 0;

    if ( NULL == pITask )
    {
        return S_FALSE;
    }

    if ( StringLength(pszScName, 0) != 0)
    {
        StringCopy(szScheduleName, pszScName, SIZE_OF_ARRAY(szScheduleName));
    }

    hr = pITask->GetTrigger(wTriggNum,&pITaskTrigger);
    if (FAILED(hr))
    {
        if(pITaskTrigger)
        {
            pITaskTrigger->Release();
        }

        return hr;
    }

    TASK_TRIGGER Trigger;
    SecureZeroMemory(&Trigger, sizeof (TASK_TRIGGER));

    hr = pITaskTrigger->GetTrigger(&Trigger);
    if (FAILED(hr))
    {
        if(pITaskTrigger)
        {
            pITaskTrigger->Release();
        }
        return hr;
    }

    //Get the task start time & start date
    hr = GetTaskRunTime(pITask,szTime,szDate,TASK_START_RUNTIME,wTriggNum);
    if (FAILED(hr))
    {
        StringCopy( pTaskProps->szTaskStartTime , GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING );
    }
    else
    {
        StringCopy( pTaskProps->szTaskStartTime , szTime, MAX_RES_STRING );
        StringCopy(pTaskProps->szTaskStartDate, szDate, MAX_RES_STRING );
    }

    //Initialize to default values
    StringCopy(pTaskProps->szRepeatEvery, GetResString(IDS_TASK_PROPERTY_DISABLED), MAX_RES_STRING);
    StringCopy(pTaskProps->szRepeatUntilTime, GetResString(IDS_TASK_PROPERTY_DISABLED), MAX_RES_STRING);
    StringCopy(pTaskProps->szRepeatDuration, GetResString(IDS_TASK_PROPERTY_DISABLED), MAX_RES_STRING);
    StringCopy(pTaskProps->szRepeatStop, GetResString(IDS_TASK_PROPERTY_DISABLED), MAX_RES_STRING);

    if((Trigger.TriggerType >= TASK_TIME_TRIGGER_ONCE ) &&
       (Trigger.TriggerType <= TASK_TIME_TRIGGER_MONTHLYDOW ))
    {
        if(Trigger.MinutesInterval > 0)
        {
        // Getting the minute interval
        dwMinInterval =  Trigger.MinutesInterval;

        if ( dwMinInterval >= 60)
        {
            // convert minutes into hours
            dwHours = dwMinInterval / 60;

            szValues[0] = _ultot(dwHours,szBuffer,10);

            
            StringCchPrintf ( pTaskProps->szRepeatEvery, SIZE_OF_ARRAY(pTaskProps->szRepeatEvery), 
                                      GetResString(IDS_RPTTIME_PROPERTY_HOURS),  szValues[0] );          

        }
        else
        {
            szValues[0] = _ultot(dwMinInterval,szBuffer,10);

            StringCchPrintf ( pTaskProps->szRepeatEvery, SIZE_OF_ARRAY(pTaskProps->szRepeatEvery),
                                    GetResString(IDS_RPTTIME_PROPERTY_MINUTES),  szValues[0] );          
        }

        if ( dwMinInterval )
        {
            StringCopy(pTaskProps->szRepeatUntilTime, GetResString(IDS_TASK_PROPERTY_NONE), MAX_RES_STRING);
        }

        // Getting the minute duration
        dwMinDuration = Trigger.MinutesDuration;

        dwHours = dwMinDuration / 60;
        dwMinutes = dwMinDuration % 60;

        szValues[0] = _ultot(dwHours,szBuffer,10);
        szValues[1] = _ultot(dwMinutes,szTempBuf,10);

              
         StringCchPrintf ( pTaskProps->szRepeatDuration, SIZE_OF_ARRAY(pTaskProps->szRepeatDuration), 
                           GetResString(IDS_RPTDURATION_PROPERTY),  szValues[0], szValues[1] );  

        }
    }

    StringCopy(pTaskProps->szTaskMonths, GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING);

    switch(Trigger.TriggerType)
    {
        case TASK_TIME_TRIGGER_ONCE:

            StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_ONCE), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskEndDate,GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskMonths, GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskDays,GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING );
            break;

        case TASK_TIME_TRIGGER_DAILY :

            szToken = wcstok( szScheduleName, seps );
            if ( szToken != NULL )
            {
                szToken = wcstok( NULL , seps );
                if ( szToken != NULL )
                {
                    szToken = wcstok( NULL , seps );
                }

                if ( szToken != NULL )
                {
                    if (StringCompare(szToken, GetResString( IDS_TASK_HOURLY ), TRUE, 0) == 0)
                    {
                        bHour = TRUE;
                    }
                    else if (StringCompare(szToken, GetResString( IDS_TASK_MINUTE ), TRUE, 0) == 0)
                    {
                        bMin = TRUE;
                    }
                }

            }

            if ( bHour == TRUE )
            {
                StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_HOURLY), MAX_RES_STRING);
            }
            else if ( bMin == TRUE )
            {
                StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_MINUTE), MAX_RES_STRING);
            }
            else
            {
                StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_DAILY), MAX_RES_STRING);
            }

            StringCopy(pTaskProps->szTaskDays, GetResString(IDS_DAILY_TYPE), MAX_RES_STRING);

            break;

        case TASK_TIME_TRIGGER_WEEKLY :

            StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_WEEKLY), MAX_RES_STRING);
            CheckWeekDay(Trigger.Type.Weekly.rgfDaysOfTheWeek,szWeekDay);

            StringCopy(pTaskProps->szTaskDays,szWeekDay, MAX_RES_STRING);
            break;

        case TASK_TIME_TRIGGER_MONTHLYDATE :
            {

                StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_MONTHLY), MAX_RES_STRING);
                CheckMonth(Trigger.Type.MonthlyDate.rgfMonths ,szMonthDay);

                DWORD dwDays = (Trigger.Type.MonthlyDate.rgfDays);
                DWORD dwModdays = 0;
                DWORD  dw  = 0x0; //loop counter
                DWORD dwTemp = 0x1;
                DWORD dwBits = sizeof(DWORD) * 8; //total no. of bits in a DWORD.

                //find out the day no.by finding out which particular bit is set

                for(dw = 0; dw <= dwBits; dw++)
                {
                    if( (dwDays  & dwTemp) == dwDays )
                        dwModdays = dw + 1;
                    dwTemp = dwTemp << 1;

                }


                StringCchPrintf(pTaskProps->szTaskDays, SIZE_OF_ARRAY(pTaskProps->szTaskDays), _T("%d"),dwModdays);

                StringCopy(pTaskProps->szTaskMonths,szMonthDay, MAX_RES_STRING);
                }
            break;

        case TASK_TIME_TRIGGER_MONTHLYDOW:

            StringCopy(pTaskProps->szTaskType,GetResString(IDS_TASK_PROPERTY_MONTHLY), MAX_RES_STRING);
            CheckWeek(Trigger.Type.MonthlyDOW.wWhichWeek,szWeek);
            CheckWeekDay(Trigger.Type.MonthlyDOW.rgfDaysOfTheWeek,szWeekDay);

            StringCopy(pTaskProps->szTaskDays,szWeekDay, MAX_RES_STRING);
            CheckMonth(Trigger.Type.MonthlyDOW.rgfMonths,szMonthDay);
            StringCopy(pTaskProps->szTaskMonths,szMonthDay, MAX_RES_STRING);
            break;

        case TASK_EVENT_TRIGGER_ON_IDLE :

            StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_IDLE), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskDays,pTaskProps->szTaskMonths, MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskEndDate, GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING);

            if(pITaskTrigger)
                pITaskTrigger->Release();
            return S_OK;

        case TASK_EVENT_TRIGGER_AT_SYSTEMSTART :

            StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_SYSSTART), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskEndDate, GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskDays, pTaskProps->szTaskMonths, MAX_RES_STRING);

            if(pITaskTrigger)
                pITaskTrigger->Release();
            return S_OK;

        case TASK_EVENT_TRIGGER_AT_LOGON :

            StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_LOGON), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskEndDate, GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskDays, pTaskProps->szTaskMonths, MAX_RES_STRING);

            if(pITaskTrigger)
                pITaskTrigger->Release();
            return S_OK;

        default:

            StringCopy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_UNDEF), MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskEndDate, pTaskProps->szTaskType, MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskDays, pTaskProps->szTaskType, MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskStartTime, pTaskProps->szTaskType, MAX_RES_STRING);
            StringCopy(pTaskProps->szTaskStartDate, pTaskProps->szTaskType, MAX_RES_STRING);
            if(pITaskTrigger)
                pITaskTrigger->Release();
            return S_OK;

    }

    //Determine whether the end date is specified.
    int iBuffSize = 0;//buffer to know how many TCHARs for end date
    SYSTEMTIME tEndDate = {0,0,0,0,0,0,0,0 };
    LCID lcid;
    BOOL bLocaleChanged = FALSE;

    // verify whether console supports the current locale fully or not
    lcid = GetSupportedUserLocale( bLocaleChanged );

    if((Trigger.rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE ) == TASK_TRIGGER_FLAG_HAS_END_DATE)
    {

        tEndDate.wMonth = Trigger.wEndMonth;
        tEndDate.wDay = Trigger.wEndDay;
        tEndDate.wYear = Trigger.wEndYear;

        iBuffSize = GetDateFormat(LOCALE_USER_DEFAULT,0,
            &tEndDate,(( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL),pTaskProps->szTaskEndDate,0);
        if(iBuffSize)
        {
            GetDateFormat(LOCALE_USER_DEFAULT,0,
             &tEndDate,(( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL),pTaskProps->szTaskEndDate,iBuffSize);
        }
        else
        {
            StringCopy( pTaskProps->szTaskEndDate , GetResString(IDS_TASK_PROPERTY_NA), MAX_RES_STRING);
        }

    }

    else
    {
        StringCopy(pTaskProps->szTaskEndDate,GetResString(IDS_QUERY_NOENDDATE), MAX_RES_STRING);
    }

    if(pITaskTrigger)
        pITaskTrigger->Release();

    return S_OK;

}


/******************************************************************************

    Routine Description:

        This function checks the week modifier[ -monthly option] & returns the app.week
        day.

    Arguments:

        [ in ]  dwFlag      : Flag indicating the week type
        [ out ] pWhichWeek  : address of pointer containing the week string

    Return Value :
        None

******************************************************************************/

VOID
CheckWeek(
            IN DWORD dwFlag,
            IN WCHAR* pWhichWeek
            )
{
    StringCopy(pWhichWeek,L"\0", MAX_RES_STRING);


    if( dwFlag == TASK_FIRST_WEEK )
    {
        StringConcat(pWhichWeek, GetResString(IDS_TASK_FIRSTWEEK), MAX_RES_STRING);
        StringConcat(pWhichWeek,COMMA_STRING, MAX_RES_STRING);
    }

    if( dwFlag == TASK_SECOND_WEEK )
    {
        StringConcat(pWhichWeek, GetResString(IDS_TASK_SECONDWEEK), MAX_RES_STRING);
        StringConcat(pWhichWeek,COMMA_STRING, MAX_RES_STRING);
    }

    if( dwFlag == TASK_THIRD_WEEK )
    {
        StringConcat(pWhichWeek, GetResString(IDS_TASK_THIRDWEEK), MAX_RES_STRING);
        StringConcat(pWhichWeek,COMMA_STRING, MAX_RES_STRING);
    }

    if( dwFlag == TASK_FOURTH_WEEK )
    {
        StringConcat(pWhichWeek, GetResString(IDS_TASK_FOURTHWEEK), MAX_RES_STRING);
        StringConcat(pWhichWeek,COMMA_STRING, MAX_RES_STRING);
    }

    if( dwFlag == TASK_LAST_WEEK )
    {
        StringConcat(pWhichWeek, GetResString(IDS_TASK_LASTWEEK), MAX_RES_STRING);
        StringConcat(pWhichWeek,COMMA_STRING, MAX_RES_STRING);
    }

    int iLen = StringLength(pWhichWeek, 0);
    if(iLen)
        *( ( pWhichWeek ) + iLen - StringLength( COMMA_STRING, 0 ) ) = L'\0';


}

/******************************************************************************

    Routine Description:

        This function checks the days in the week  & returns the app. day.

    Arguments:

        [ in ]  dwFlag      : Flag indicating the day type
        [ out ] pWeekDay    : resulting day string

    Return Value :
        None

******************************************************************************/

VOID
CheckWeekDay(
            IN DWORD dwFlag,
            IN WCHAR* pWeekDay)
{
    StringCopy(pWeekDay, L"\0", MAX_RES_STRING);

    if((dwFlag & TASK_SUNDAY) == TASK_SUNDAY)
    {

        StringConcat(pWeekDay, GetResString(IDS_TASK_SUNDAY), MAX_RES_STRING);
        StringConcat(pWeekDay,COMMA_STRING, MAX_RES_STRING);

    }

    if((dwFlag & TASK_MONDAY) == TASK_MONDAY)
    {
        StringConcat(pWeekDay, GetResString(IDS_TASK_MONDAY), MAX_RES_STRING);
        StringConcat(pWeekDay,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_TUESDAY) == TASK_TUESDAY)
    {
        StringConcat(pWeekDay, GetResString(IDS_TASK_TUESDAY), MAX_RES_STRING);
        StringConcat(pWeekDay,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_WEDNESDAY) == TASK_WEDNESDAY)
    {
        StringConcat(pWeekDay, GetResString(IDS_TASK_WEDNESDAY), MAX_RES_STRING);
        StringConcat(pWeekDay,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_THURSDAY) == TASK_THURSDAY)
    {
        StringConcat(pWeekDay, GetResString(IDS_TASK_THURSDAY), MAX_RES_STRING);
        StringConcat(pWeekDay,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag& TASK_FRIDAY) == TASK_FRIDAY)
    {
        StringConcat(pWeekDay, GetResString(IDS_TASK_FRIDAY), MAX_RES_STRING);
        StringConcat(pWeekDay,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_SATURDAY)== TASK_SATURDAY)
    {
        StringConcat(pWeekDay, GetResString(IDS_TASK_SATURDAY), MAX_RES_STRING);
        StringConcat(pWeekDay,COMMA_STRING, MAX_RES_STRING);
    }

    //Remove the comma from the end of the string.
    int iLen = StringLength(pWeekDay, 0);
    if(iLen)
    {
        *( ( pWeekDay ) + iLen - StringLength( COMMA_STRING, 0 ) ) = L'\0';
    }

}

/******************************************************************************

    Routine Description:

        This function checks the months in a year & returns the app.Month(s)


    Arguments:

        [ in ]  dwFlag      : Flag indicating the Month type
        [ out ] pWhichMonth : resulting Month string

    Return Value :
        None

******************************************************************************/

VOID
CheckMonth(
        IN DWORD dwFlag,
        IN WCHAR* pWhichMonth)
{
    StringCopy(pWhichMonth, L"\0", MAX_RES_STRING);

    if((dwFlag & TASK_JANUARY) == TASK_JANUARY)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_JANUARY), MAX_RES_STRING);
        StringConcat(pWhichMonth,COMMA_STRING, MAX_RES_STRING);

    }

    if((dwFlag & TASK_FEBRUARY) == TASK_FEBRUARY)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_FEBRUARY), MAX_RES_STRING);
        StringConcat(pWhichMonth,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_MARCH) == TASK_MARCH)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_MARCH), MAX_RES_STRING);
        StringConcat(pWhichMonth, COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_APRIL) == TASK_APRIL)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_APRIL), MAX_RES_STRING);
        StringConcat(pWhichMonth, COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_MAY) == TASK_MAY)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_MAY), MAX_RES_STRING);
        StringConcat(pWhichMonth, COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag& TASK_JUNE) == TASK_JUNE)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_JUNE), MAX_RES_STRING);
        StringConcat(pWhichMonth, COMMA_STRING, MAX_RES_STRING);

    }

    if((dwFlag & TASK_JULY)== TASK_JULY)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_JULY), MAX_RES_STRING);
        StringConcat(pWhichMonth,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_AUGUST)== TASK_AUGUST)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_AUGUST), MAX_RES_STRING);
        StringConcat(pWhichMonth,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_SEPTEMBER)== TASK_SEPTEMBER)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_SEPTEMBER), MAX_RES_STRING);
        StringConcat(pWhichMonth, COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_OCTOBER)== TASK_OCTOBER)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_OCTOBER), MAX_RES_STRING);
        StringConcat(pWhichMonth, COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_NOVEMBER)== TASK_NOVEMBER)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_NOVEMBER), MAX_RES_STRING);
        StringConcat(pWhichMonth,COMMA_STRING, MAX_RES_STRING);
    }

    if((dwFlag & TASK_DECEMBER)== TASK_DECEMBER)
    {
        StringConcat(pWhichMonth, GetResString(IDS_TASK_DECEMBER), MAX_RES_STRING);
        StringConcat(pWhichMonth,COMMA_STRING, MAX_RES_STRING);
    }

    int iLen = StringLength(pWhichMonth, 0);

    //Remove the comma from the end of the string.
    if(iLen)
    {
        *( ( pWhichMonth ) + iLen - StringLength( COMMA_STRING, 0 ) ) = L'\0';
    }
}

/******************************************************************************

    Routine Description:

        This function checks whether the current locale supported by our tool or not.

    Arguments:

        [ out ] bLocaleChanged : Locale change flag

    Return Value :
        None

******************************************************************************/
LCID 
GetSupportedUserLocale( 
                    OUT BOOL& bLocaleChanged 
                    )
{
    // local variables
    LCID lcid;

    // get the current locale
    lcid = GetUserDefaultLCID();

    // check whether the current locale is supported by our tool or not
    // if not change the locale to the english which is our default locale
    bLocaleChanged = FALSE;
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
        bLocaleChanged = TRUE;
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

    // return the locale
    return lcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\resource.h ===
#define IDS_ERROR_PARSEPARAM                101
#define IDS_MODIFIER_NA                     102
#define IDS_INVALID_MODIFIER                103
#define IDS_INVALID_VALUE_FOR_DAY           104
#define IDS_INVALID_VALUE_FOR_MON           105
#define IDS_MON_NA                          106
#define IDS_INVALIDFORMAT_STARTDATE         107
#define IDS_NO_STARTDATE                    108
#define IDS_INVALIDFORMAT_ENDDATE           109
#define IDS_ENDDATE_NA                      110
#define IDS_INVALIDFORMAT_STARTTIME         111
#define IDS_NO_STARTTIME                    112
#define IDS_STARTTIME_NA                    113
#define IDS_INVALIDORNO_IDLETIME            114
#define IDS_NTAUTH_SYSTEM_ERROR             115
#define IDS_INVALID_NET_ADDRESS             116
#define IDS_FAILED_TOGET_USER               117
#define IDS_INVALID_ARG                     118
#define IDS_NO_MEMORY                       119
#define IDS_INVALID_TASK                    120
#define IDS_INVALID_USERNAME                121
#define IDS_TASKNAME_NOTEXIST               122
#define IDS_DELETE_SYNERROR                 123
#define IDS_CHANGE_SYNERROR                 124
#define IDS_RUN_SYNERROR                    125
#define IDS_END_SYNERROR                    126
#define IDS_CREATE_USAGE                    127
#define IDS_INVALID_SCHEDTYPE               128
#define IDS_USERNAME_BUT_NOMACHINE          129
#define IDS_PASSWORD_BUT_NOUSERNAME         130
#define IDS_NO_CHANGE_OPTIONS               131
#define IDS_NO_PASSWORD                     132
#define IDS_RUN_ERROR                       133
#define IDS_FAILED_TOSET_PARAMS             134
#define IDS_FAILED_TOGET_RUNASUSER          135
#define IDS_DAYS_NA                         136
#define IDS_CREATEFAIL_INVALIDARGS          137
#define IDS_CREATE_TASK_EXISTS              138
#define IDS_INVALIDFORMAT_DATE              139
#define IDS_NOTAPPLICABLE_SDATE             140
#define IDS_INVALIDIDLETIME_OPTION          141
#define IDS_INVALID_TASKLENGTH              142
#define IDS_INVALID_JOBNAME                 143
#define IDS_LOGGED_USER_ERR                 144
#define IDS_NOHEADER_NA                     145
#define IDS_WRONG_INPUT_DELETE              146
#define IDS_IDLETIME_NA                     147
#define IDS_NO_DAY_VALUE                    148
#define IDS_NO_MONTH_VALUE                  149
#define IDS_INVALID_TASKRUN                 150
#define IDS_NO_SERVER                       151
#define IDS_INVALID_SERVER                  152
#define IDS_DELETEOPTION_ERROR              153
#define IDS_CREATEFILE_USAGE                154
#define IDS_RES_ERROR                       155
#define IDS_QUERY_USAGE                     156
#define IDS_CREATE_READERROR                157
#define IDS_ENDATE_INVALID                  158
#define IDS_CREATE_ERR                      159
#define IDS_QUERY_READ                      160
#define IDS_LOGTYPE_ERROR                   161
#define IDS_MODIFIER_INVALID                162
#define IDS_QUERY_FORMAT_ERR                163
#define IDS_IDLETIME_INVALID                164
#define IDS_INVALID_TASKNAME1               165
#define IDS_NO_IDLETIME                     166
#define IDS_WARNING_STRING                  169
#define IDS_SERVICE_NAME                    170
#define IDS_ENDTIME_INVALID                 171
#define IDS_INVALIDFORMAT_ENDTIME           172
#define IDS_ENDTIME_NA                      173
#define IDS_IT_SWITCH_NA                    174
#define IDS_INVALID_DURATION1               175
#define IDS_NO_ENDTIME                      176
#define IDS_INVALID_STARTDATE               177
#define IDS_INVALID_ENDDATE                 178
#define IDS_STARTDATE_EMPTY                 179
#define IDS_ENDDATE_EMPTY                   180
#define IDS_DURATION_NOT_ENDTIME            181
#define IDS_DURATION_EMPTY                  182
#define IDS_INVALIDDURATION_FORMAT          183
#define IDS_DURATION_NA                     184
#define IDS_INVALID_DURATION2               185
#define IDS_IT_NO_SYSTEM                    186
#define IDS_UPPER_YES                       187
#define IDS_UPPER_NO                        188
#define IDS_SYSTEM_TASK_EXISTS              189

#define IDS_RUNNING_ALREADY                 201
#define IDS_NTAUTH_SYSTEM_INFO              202
#define IDS_NTAUTH_SYSTEM_CHANGE_INFO       203
#define IDS_TASKNAME_NOTASKS                204
#define IDS_INVALID_TASKNAME2               205
#define IDS_CONFIRM_SERVICE                 206
#define IDS_NOT_START_SERVICE               207

#define IDS_INVALID_USER                    251
#define IDS_PASSWORD_NOEFFECT               252
#define IDS_WARN_DELETEALL                  253
#define IDS_WARN_DELETE                     254
#define IDS_INVALID_DU_VALUE                255
#define IDS_ERROR_CREATEPARAM               256
#define IDS_ERROR_DELETEPARAM               257
#define IDS_ERROR_RUNPARAM                  258
#define IDS_ERROR_ENDPARAM                  259
#define IDS_ERROR_QUERYPARAM                260
#define IDS_ERROR_CHANGEPARAM               261
#define IDS_INVALID_MONTH_MODFIER           262

#define IDS_SUCCESS_DELETED                 301
#define IDS_CREATE_SUCCESSFUL               302
#define IDS_CHANGE_SUCCESSFUL               303
#define IDS_RUN_SUCCESSFUL                  304
#define IDS_END_SUCCESSFUL                  305

#define IDS_COL_HOSTNAME                    351
#define IDS_COL_TASKNAME                    352
#define IDS_COL_NEXTRUNTIME                 353
#define IDS_COL_LASTRUNTIME                 354
#define IDS_COL_MODE                        355
#define IDS_COL_STATUS                      356
#define IDS_COL_LASTRESULT                  357
#define IDS_COL_CREATOR                     358
#define IDS_COL_SCHEDULE                    359
#define IDS_COL_APPNAME                     360
#define IDS_COL_WORKDIRECTORY               361
#define IDS_COL_COMMENT                     362
#define IDS_COL_TASKSTATE                   363
#define IDS_COL_TASKTYPE                    364
#define IDS_COL_STARTTIME                   365
#define IDS_COL_STARTDATE                   366
#define IDS_COL_ENDDATE                     367
#define IDS_COL_DAYS                        368
#define IDS_COL_MONTHS                      369
#define IDS_COL_RUNASUSER                   370
#define IDS_COL_DELTASK                     371
#define IDS_COL_STOPTASK                    372
#define IDS_COL_REPEAT_EVERY                373
#define IDS_COL_REPEAT_UNTILTIME            374
#define IDS_COL_REPEAT_DURATION             375
#define IDS_COL_REPEAT_RUNNING              376
#define IDS_COL_IDLE                        377
#define IDS_COL_POWER                       378

#define IDS_COL_IDLE_START                  379
#define IDS_COL_IDLE_ONLYSTART              380
#define IDS_COL_IDLE_NOTIDLE                381
#define IDS_COL_IDLE_STOPTASK               382
#define IDS_COL_POWER_NOSTART               383
#define IDS_COL_POWER_STOP                  384
#define IDS_COL_MODE_INTERACTIVE            385
#define IDS_COL_MODE_BACKGROUND             386
#define IDS_COL_MODE_INTERACT_BACK          387

#define IDS_WIDTH_HOSTNAME                  601
#define IDS_WIDTH_TASKNAME                  602
#define IDS_WIDTH_NEXTRUNTIME               603
#define IDS_WIDTH_LASTRUNTIME               604
#define IDS_WIDTH_STATUS                    605
#define IDS_WIDTH_LASTRESULT                606
#define IDS_WIDTH_CREATOR                   607
#define IDS_WIDTH_SCHEDULE                  608
#define IDS_WIDTH_APPNAME                   609
#define IDS_WIDTH_WORKDIRECTORY             610
#define IDS_WIDTH_COMMENT                   611
#define IDS_WIDTH_TASKSTATE                 612
#define IDS_WIDTH_TASKTYPE                  613
#define IDS_WIDTH_TASKMODIFIER              614
#define IDS_WIDTH_TASKSTIME                 615
#define IDS_WIDTH_TASKSDATE                 616
#define IDS_WIDTH_TASKEDATE                 617
#define IDS_WIDTH_TASKDAYS                  618
#define IDS_WIDTH_TASKMONTHS                619
#define IDS_WIDTH_TASKRUNASUSER             620
#define IDS_WIDTH_TASKDELETE                621
#define IDS_WIDTH_TASK_RPTEVERY             622
#define IDS_WIDTH_TASK_UNTILRPTTIME         623
#define IDS_WIDTH_TASK_RPTDURATION          624
#define IDS_WIDTH_TASK_RPTRUNNING           625
#define IDS_WIDTH_TASKIDLESTART             626
#define IDS_WIDTH_TASKIDLEONLYSTART         627
#define IDS_WIDTH_TASKNOTIDLE               628
#define IDS_WIDTH_TASKIDLESTOP              629
#define IDS_WIDTH_TASKPOWERNOSTART          630
#define IDS_WIDTH_TASKPOWERSTOP             631
#define IDS_WIDTH_TASKSTOP                  632
#define IDS_WIDTH_TASKIDLE                  633
#define IDS_WIDTH_TASKPOWERMGMT             634
#define IDS_WIDTH_MODE                      635

#define IDS_HOSTNAME_COL_NUMBER                 651
#define IDS_TASKNAME_COL_NUMBER                 652
#define IDS_NEXTRUNTIME_COL_NUMBER              653
#define IDS_STATUS_COL_NUMBER                   654
#define IDS_MODE_COL_NUMBER                     655
#define IDS_LASTRUNTIME_COL_NUMBER              656
#define IDS_LASTRESULT_COL_NUMBER               657
#define IDS_CREATOR_COL_NUMBER                  658
#define IDS_SCHEDULE_COL_NUMBER                 659
#define IDS_TASKTORUN_COL_NUMBER                660
#define IDS_STARTIN_COL_NUMBER                  661
#define IDS_COMMENT_COL_NUMBER                  662
#define IDS_TASKSTATE_COL_NUMBER                663
#define IDS_TASKTYPE_COL_NUMBER                 664
#define IDS_STARTTIME_COL_NUMBER                665
#define IDS_STARTDATE_COL_NUMBER                666
#define IDS_ENDDATE_COL_NUMBER                  667
#define IDS_DAYS_COL_NUMBER                     668
#define IDS_MONTHS_COL_NUMBER                   669
#define IDS_RUNASUSER_COL_NUMBER                670
#define IDS_DELETE_IFNOTRESCHEDULED_COL_NUMBER  671
#define IDS_STOPTASK_COL_NUMBER                 672
#define IDS_REPEAT_EVERY_COL_NUMBER             673
#define IDS_REPEAT_UNTILTIME_COL_NUMBER         674
#define IDS_REPEAT_DURATION_COL_NUMBER          675
#define IDS_REPEAT_STOP_COL_NUMBER              676
#define IDS_IDLE_STARTTIME_COL_NUMBER           677
#define IDS_IDLE_ONLYSTART_IFIDLE_COL_NUMBER    678
#define IDS_IDLE_IFNOTIDLE_COL_NUMBER           679
#define IDS_IDLE_STOPTASK_COL_NUMBER            680
#define IDS_POWER_NOSTARTONBATT_COL_NUMBER      681
#define IDS_POWER_STOPONBATT_COL_NUMBER         682
#define IDS_IDLE_COL_NUMBER                     683
#define IDS_POWER_MGMT_COL_NUMBER               684


#define IDS_STATUS_UNKNOWN           401
#define IDS_STATUS_NOTSCHED          402
#define IDS_TASK_PROPERTY_UNKNOWN    403
#define IDS_TASK_PROPERTY_DISABLED   404
#define IDS_TASK_PROPERTY_NONE       405
#define IDS_TASK_PROPERTY_ENABLED    406
#define IDS_USER_UNKNOWN             407
#define IDS_ACCNAME_ERR              408
#define IDS_MINUTES                  411
#define IDS_MMDDYY_FORMAT            412
#define IDS_DDMMYY_FORMAT            413
#define IDS_YYMMDD_FORMAT            414
#define IDS_MMDDYY_VALUE             415
#define IDS_DDMMYY_VALUE             416
#define IDS_YYMMDD_VALUE             417
#define IDS_TASK_IDLE                418
#define IDS_TASK_SYSSTART            419
#define IDS_TASK_LOGON               420
#define IDS_TASK_NEVER               421
#define IDS_STATUS_RUNNING           422
#define IDS_STATUS_READY             423
#define IDS_STATUS_NOTYET            424
#define IDS_STATUS_SCHEDULED         425
#define IDS_PROMPT_USERNAME          426
#define IDS_PROMPT_PASSWD            427
#define IDS_PROMPT_CHGPASSWD         428
#define IDS_TASK_INFO                429
#define IDS_SCHEDTYPE_MINUTE         430
#define IDS_SCHEDTYPE_HOUR           431
#define IDS_SCHEDTYPE_DAILY          432
#define IDS_SCHEDTYPE_WEEK           433
#define IDS_SCHEDTYPE_MONTHLY        434
#define IDS_SCHEDTYPE_ONCE           435
#define IDS_SCHEDTYPE_STARTUP        436
#define IDS_SCHEDTYPE_LOGON          437
#define IDS_SCHEDTYPE_IDLE           438
#define IDS_QUERY_NOENDDATE          439
#define IDS_TASK_PROPERTY_NA         440
#define IDS_TASK_PROPERTY_ONCE       441
#define IDS_TASK_PROPERTY_NEVER      442
#define IDS_TASK_PROPERTY_DAILY      443
#define IDS_TASK_PROPERTY_HOURLY     444
#define IDS_TASK_PROPERTY_MINUTE     445
#define IDS_TASK_HOURLY              446
#define IDS_TASK_MINUTE              447
#define IDS_TASK_PROPERTY_WEEKLY     448
#define IDS_TASK_PROPERTY_MONTHLY    449
#define IDS_TASK_PROPERTY_SPMONTHS   450
#define IDS_TASK_PROPERTY_UNDEF      451
#define IDS_TASK_SUNDAY              452
#define IDS_TASK_MONDAY              453
#define IDS_TASK_TUESDAY             454
#define IDS_TASK_WEDNESDAY           455
#define IDS_TASK_THURSDAY            456
#define IDS_TASK_FRIDAY              457
#define IDS_TASK_SATURDAY            458
#define IDS_TASK_JANUARY             459
#define IDS_TASK_FEBRUARY            460
#define IDS_TASK_MARCH               461
#define IDS_TASK_APRIL               462
#define IDS_TASK_MAY                 463
#define IDS_TASK_JUNE                464
#define IDS_TASK_JULY                465
#define IDS_TASK_AUGUST              466
#define IDS_TASK_SEPTEMBER           467
#define IDS_TASK_OCTOBER             468
#define IDS_TASK_NOVEMBER            469
#define IDS_TASK_DECEMBER            470
#define IDS_TASK_FIRSTWEEK           471
#define IDS_TASK_SECONDWEEK          472
#define IDS_TASK_THIRDWEEK           473
#define IDS_TASK_FOURTHWEEK          474
#define IDS_TASK_LASTWEEK            475
#define IDS_QUERY_FORMAT_TABLE       476
#define IDS_QUERY_FORMAT_LIST        477
#define IDS_QUERY_FORMAT_CSV         478
#define IDS_MONTH_MODIFIER_JAN       479
#define IDS_MONTH_MODIFIER_FEB       480
#define IDS_MONTH_MODIFIER_MAR       481
#define IDS_MONTH_MODIFIER_APR       482
#define IDS_MONTH_MODIFIER_MAY       483
#define IDS_MONTH_MODIFIER_JUN       484
#define IDS_MONTH_MODIFIER_JUL       485
#define IDS_MONTH_MODIFIER_AUG       486
#define IDS_MONTH_MODIFIER_SEP       487
#define IDS_MONTH_MODIFIER_OCT       488
#define IDS_MONTH_MODIFIER_NOV       489
#define IDS_MONTH_MODIFIER_DEC       490
#define IDS_DAY_MODIFIER_SUN         491
#define IDS_DAY_MODIFIER_MON         492
#define IDS_DAY_MODIFIER_TUE         493
#define IDS_DAY_MODIFIER_WED         494
#define IDS_DAY_MODIFIER_THU         495
#define IDS_DAY_MODIFIER_FRI         496
#define IDS_DAY_MODIFIER_SAT         497
#define IDS_DAY_MODIFIER_LASTDAY     498
#define IDS_RPTTIME_PROPERTY_MINUTES 499
#define IDS_RPTTIME_PROPERTY_HOURS   500
#define IDS_RPTDURATION_PROPERTY     501
#define IDS_DAILY_TYPE               502
#define IDS_EVERYDAY                 504
#define IDS_WEEK_DISPLAY_STRING      505
#define IDS_MONTHLY_DISPLAY_STRING   506
#define IDS_QUERY_NA                 507
#define IDS_ERROR_STRING             508
#define IDS_STATUS_COULDNOTSTART     509
#define IDS_NOTSCHEDULED_TASK        510
#define IDS_INVALID_PASSWORD         511
#define IDS_INVALID_UNAME            512
#define IDS_CPASSWORD_BUT_NOUSERNAME 513
#define IDS_QPASSWORD_BUT_NOUSERNAME 514
#define IDS_DPASSWORD_BUT_NOUSERNAME 515
#define IDS_RPASSWORD_BUT_NOUSERNAME 516
#define IDS_EPASSWORD_BUT_NOUSERNAME 517
#define IDS_CHPASSWORD_BUT_NOUSERNAME 518
#define IDS_SCHEDULER_NOT_RUNNING     519
#define IDS_RPC_SERVER_NOT_AVAIL      520
#define IDS_USER_INFO                 521
#define IDS_WARN_EMPTY_PASSWORD       522
#define IDS_CREATE_USER_BUT_NOMACHINE IDS_USERNAME_BUT_NOMACHINE
#define IDS_DELETE_USER_BUT_NOMACHINE IDS_USERNAME_BUT_NOMACHINE
#define IDS_QUERY_USER_BUT_NOMACHINE  IDS_USERNAME_BUT_NOMACHINE
#define IDS_RUN_USER_BUT_NOMACHINE    IDS_USERNAME_BUT_NOMACHINE
#define IDS_END_USER_BUT_NOMACHINE    IDS_USERNAME_BUT_NOMACHINE
#define IDS_CHANGE_USER_BUT_NOMACHINE IDS_USERNAME_BUT_NOMACHINE

#define IDS_OPERATION_CANCELLED  550
#define IDS_WRONG_INPUT          551
#define IDS_WARN_ST_LESS_CT      552
#define IDS_SERVICE_NOT_RUNNING  553

#define IDS_CREATE_HLP1         2001
#define IDS_CREATE_HLP2         2002
#define IDS_CREATE_HLP3         2003
#define IDS_CREATE_HLP4         2004
#define IDS_CREATE_HLP5         2005
#define IDS_CREATE_HLP6         2006
#define IDS_CREATE_HLP7         2007
#define IDS_CREATE_HLP8         2008
#define IDS_CREATE_HLP9         2009
#define IDS_CREATE_HLP10        2010
#define IDS_CREATE_HLP11        2011
#define IDS_CREATE_HLP12        2012
#define IDS_CREATE_HLP13        2013
#define IDS_CREATE_HLP14        2014
#define IDS_CREATE_HLP15        2015
#define IDS_CREATE_HLP16        2016
#define IDS_CREATE_HLP17        2017
#define IDS_CREATE_HLP18        2018
#define IDS_CREATE_HLP19        2019
#define IDS_CREATE_HLP20        2020
#define IDS_CREATE_HLP21        2021
#define IDS_CREATE_HLP22        2022
#define IDS_CREATE_HLP23        2023
#define IDS_CREATE_HLP24        2024
#define IDS_CREATE_HLP25        2025
#define IDS_CREATE_HLP26        2026
#define IDS_CREATE_HLP27        2027
#define IDS_CREATE_HLP28        2028
#define IDS_CREATE_HLP29        2029
#define IDS_CREATE_HLP30        2030
#define IDS_CREATE_HLP31        2031
#define IDS_CREATE_HLP32        2032
#define IDS_CREATE_HLP33        2033
#define IDS_CREATE_HLP34        2034
#define IDS_CREATE_HLP35        2035
#define IDS_CREATE_HLP36        2036
#define IDS_CREATE_HLP37        2037
#define IDS_CREATE_HLP38        2038
#define IDS_CREATE_HLP39        2039
#define IDS_CREATE_HLP40        2040
#define IDS_CREATE_HLP41        2041
#define IDS_CREATE_HLP42        2042
#define IDS_CREATE_HLP43        2043
#define IDS_CREATE_HLP44        2044
#define IDS_CREATE_HLP45        2045
#define IDS_CREATE_HLP46        2046
#define IDS_CREATE_HLP47        2047
#define IDS_CREATE_HLP48        2048
#define IDS_CREATE_HLP49        2049
#define IDS_CREATE_HLP50        2050
#define IDS_CREATE_HLP51        2051
#define IDS_CREATE_HLP52        2052
#define IDS_CREATE_HLP53        2053
#define IDS_CREATE_HLP54        2054
#define IDS_CREATE_HLP55        2055
#define IDS_CREATE_HLP56        2056
#define IDS_CREATE_HLP57        2057
#define IDS_CREATE_HLP58        2058
#define IDS_CREATE_HLP59        2059
#define IDS_CREATE_HLP60        2060
#define IDS_CREATE_HLP61        2061
#define IDS_CREATE_HLP62        2062
#define IDS_CREATE_HLP63        2063
#define IDS_CREATE_HLP64        2064
#define IDS_CREATE_HLP65        2065
#define IDS_CREATE_HLP66        2066
#define IDS_CREATE_HLP67        2067
#define IDS_CREATE_HLP68        2068
#define IDS_CREATE_HLP69        2069
#define IDS_CREATE_HLP70        2070
#define IDS_CREATE_HLP71        2071
#define IDS_CREATE_HLP72        2072
#define IDS_CREATE_HLP73        2073
#define IDS_CREATE_HLP74        2074
#define IDS_CREATE_HLP75        2075
#define IDS_CREATE_HLP76        2076
#define IDS_CREATE_HLP77        2077
#define IDS_CREATE_HLP78        2078
#define IDS_CREATE_HLP79        2079
#define IDS_CREATE_HLP80        2080
#define IDS_CREATE_HLP81        2081
#define IDS_CREATE_HLP82        2082
#define IDS_CREATE_HLP83        2083
#define IDS_CREATE_HLP84        2084
#define IDS_CREATE_HLP85        2085
#define IDS_CREATE_HLP86        2086
#define IDS_CREATE_HLP87        2087
#define IDS_CREATE_HLP88        2088
#define IDS_CREATE_HLP89        2089
#define IDS_CREATE_HLP90        2090
#define IDS_CREATE_HLP91        2091
#define IDS_CREATE_HLP92        2092
#define IDS_CREATE_HLP93        2093
#define IDS_CREATE_HLP94        2094
#define IDS_CREATE_HLP95        2095
#define IDS_CREATE_HLP96        2096
#define IDS_CREATE_HLP97        2097
#define IDS_CREATE_HLP98        2098
#define IDS_CREATE_HLP99        2099
#define IDS_CREATE_HLP100       2100
#define IDS_CREATE_HLP101       2101
#define IDS_CREATE_HLP102       2102
#define IDS_CREATE_HLP103       2103
#define IDS_CREATE_HLP104       2104
#define IDS_CREATE_HLP105       2105
#define IDS_CREATE_HLP106       2106
#define IDS_CREATE_HLP107       2107
#define IDS_CREATE_HLP108       2108
#define IDS_CREATE_HLP109       2109
#define IDS_CREATE_HLP110       2110
#define IDS_CREATE_HLP111       2111
#define IDS_CREATE_HLP112       2112
#define IDS_CREATE_HLP113       2113
#define IDS_CREATE_HLP114       2114
#define IDS_CREATE_HLP115       2115
#define IDS_CREATE_HLP116       2116
#define IDS_CREATE_HLP117       2117
#define IDS_CREATE_HLP118       2118
#define IDS_CREATE_HLP119       2119
#define IDS_CREATE_HLP120       2120
#define IDS_CREATE_HLP121       2121
#define IDS_CREATE_HLP122       2122
#define IDS_CREATE_HLP123       2123
#define IDS_CREATE_HLP124       2124
#define IDS_CREATE_HLP125       2125
#define IDS_CREATE_HLP126       2126
#define IDS_CREATE_HLP127       2127
#define IDS_CREATE_HLP128       2128
#define IDS_CREATE_HLP129       2129
#define IDS_CREATE_HLP130       2130
#define IDS_CREATE_HLP131       2131
#define IDS_CREATE_HLP132       2132
#define IDS_CREATE_HLP133       2133
#define IDS_CREATE_HLP134       2134
#define IDS_CREATE_HLP135       2135
#define IDS_CREATE_HLP136       2136
#define IDS_CREATE_HLP137       2137
#define IDS_CREATE_HLP138       2138
#define IDS_CREATE_HLP139       2139
#define IDS_CREATE_HLP140       2140
#define IDS_CREATE_HLP141       2141
#define IDS_CREATE_HLP142       2142
#define IDS_CREATE_HLP143       2143
#define IDS_CREATE_HLP144       2144
#define IDS_CREATE_HLP145       2145
#define IDS_CREATE_HLP146       2146
#define IDS_CREATE_HLP147       2147
#define IDS_CREATE_HLP148       2148

#define IDS_MAINHLP1            1101
#define IDS_MAINHLP2            1102
#define IDS_MAINHLP3            1103
#define IDS_MAINHLP4            1104
#define IDS_MAINHLP5            1105
#define IDS_MAINHLP6            1106
#define IDS_MAINHLP7            1107
#define IDS_MAINHLP8            1108
#define IDS_MAINHLP9            1109
#define IDS_MAINHLP10           1110
#define IDS_MAINHLP11           1111
#define IDS_MAINHLP12           1112
#define IDS_MAINHLP13           1113
#define IDS_MAINHLP14           1114
#define IDS_MAINHLP15           1115
#define IDS_MAINHLP16           1116
#define IDS_MAINHLP17           1117
#define IDS_MAINHLP18           1118
#define IDS_MAINHLP19           1119
#define IDS_MAINHLP20           1120
#define IDS_MAINHLP21           1121

#define IDS_QUERY_HLP1          1201
#define IDS_QUERY_HLP2          1202
#define IDS_QUERY_HLP3          1203
#define IDS_QUERY_HLP4          1204
#define IDS_QUERY_HLP5          1205
#define IDS_QUERY_HLP6          1206
#define IDS_QUERY_HLP7          1207
#define IDS_QUERY_HLP8          1208
#define IDS_QUERY_HLP9          1209
#define IDS_QUERY_HLP10         1210
#define IDS_QUERY_HLP11         1211
#define IDS_QUERY_HLP12         1212
#define IDS_QUERY_HLP13         1213
#define IDS_QUERY_HLP14         1214
#define IDS_QUERY_HLP15         1215
#define IDS_QUERY_HLP16         1216
#define IDS_QUERY_HLP17         1217
#define IDS_QUERY_HLP18         1218
#define IDS_QUERY_HLP19         1219
#define IDS_QUERY_HLP20         1220
#define IDS_QUERY_HLP21         1221
#define IDS_QUERY_HLP22         1222
#define IDS_QUERY_HLP23         1223
#define IDS_QUERY_HLP24         1224
#define IDS_QUERY_HLP25         1225

#define IDS_DEL_HLP1            1301
#define IDS_DEL_HLP2            1302
#define IDS_DEL_HLP3            1303
#define IDS_DEL_HLP4            1304
#define IDS_DEL_HLP5            1305
#define IDS_DEL_HLP6            1306
#define IDS_DEL_HLP7            1307
#define IDS_DEL_HLP8            1308
#define IDS_DEL_HLP9            1309
#define IDS_DEL_HLP10           1310
#define IDS_DEL_HLP11           1311
#define IDS_DEL_HLP12           1312
#define IDS_DEL_HLP13           1313
#define IDS_DEL_HLP14           1314
#define IDS_DEL_HLP15           1315
#define IDS_DEL_HLP16           1316
#define IDS_DEL_HLP17           1317
#define IDS_DEL_HLP18           1318
#define IDS_DEL_HLP19           1319
#define IDS_DEL_HLP20           1320
#define IDS_DEL_HLP21           1321
#define IDS_DEL_HLP22           1322
#define IDS_DEL_HLP23           1323
#define IDS_DEL_HLP24           1324

#define IDS_CHANGE_HLP1         1401
#define IDS_CHANGE_HLP2         1402
#define IDS_CHANGE_HLP3         1403
#define IDS_CHANGE_HLP4         1404
#define IDS_CHANGE_HLP5         1405
#define IDS_CHANGE_HLP6         1406
#define IDS_CHANGE_HLP7         1407
#define IDS_CHANGE_HLP8         1408
#define IDS_CHANGE_HLP9         1409
#define IDS_CHANGE_HLP10        1410
#define IDS_CHANGE_HLP11        1411
#define IDS_CHANGE_HLP12        1412
#define IDS_CHANGE_HLP13        1413
#define IDS_CHANGE_HLP14        1414
#define IDS_CHANGE_HLP15        1415
#define IDS_CHANGE_HLP16        1416
#define IDS_CHANGE_HLP17        1417
#define IDS_CHANGE_HLP18        1418
#define IDS_CHANGE_HLP19        1419
#define IDS_CHANGE_HLP20        1420
#define IDS_CHANGE_HLP21        1421
#define IDS_CHANGE_HLP22        1422
#define IDS_CHANGE_HLP23        1423
#define IDS_CHANGE_HLP24        1424
#define IDS_CHANGE_HLP25        1425
#define IDS_CHANGE_HLP26        1426
#define IDS_CHANGE_HLP27        1427
#define IDS_CHANGE_HLP28        1428
#define IDS_CHANGE_HLP29        1429
#define IDS_CHANGE_HLP30        1430
#define IDS_CHANGE_HLP31        1431
#define IDS_CHANGE_HLP32        1432
#define IDS_CHANGE_HLP33        1433
#define IDS_CHANGE_HLP34        1434
#define IDS_CHANGE_HLP35        1435
#define IDS_CHANGE_HLP36        1436
#define IDS_CHANGE_HLP37        1437
#define IDS_CHANGE_HLP38        1438

#define IDS_RUN_HLP1            1501
#define IDS_RUN_HLP2            1502
#define IDS_RUN_HLP3            1503
#define IDS_RUN_HLP4            1504
#define IDS_RUN_HLP5            1505
#define IDS_RUN_HLP6            1506
#define IDS_RUN_HLP7            1507
#define IDS_RUN_HLP8            1508
#define IDS_RUN_HLP9            1509
#define IDS_RUN_HLP10           1510
#define IDS_RUN_HLP11           1511
#define IDS_RUN_HLP12           1512
#define IDS_RUN_HLP13           1513
#define IDS_RUN_HLP14           1514
#define IDS_RUN_HLP15           1515
#define IDS_RUN_HLP16           1516
#define IDS_RUN_HLP17           1517

#define IDS_END_HLP1            1601
#define IDS_END_HLP2            1602
#define IDS_END_HLP3            1603
#define IDS_END_HLP4            1604
#define IDS_END_HLP5            1605
#define IDS_END_HLP6            1606
#define IDS_END_HLP7            1607
#define IDS_END_HLP8            1608
#define IDS_END_HLP9            1609
#define IDS_END_HLP10           1610
#define IDS_END_HLP11           1611
#define IDS_END_HLP12           1612
#define IDS_END_HLP13           1613
#define IDS_END_HLP14           1614
#define IDS_END_HLP15           1615
#define IDS_END_HLP16           1616
#define IDS_END_HLP17           1617


#define IDS_ALREADY_ENABLED      2500
#define IDS_ALREADY_DISABLED     2501
#define IDS_REPEAT_NA            2502
#define IDS_OPTIONS_NA           2503
#define IDS_INVALID_RT_VALUE     2504
#define IDS_SCTYPE_NA            2505
#define IDS_EI_OR_ET_OR_DU_NOT_RI  2506
#define IDS_WARN_VALUE             2507
#define IDS_NO_CHANGE_K_OR_RT      2508
#define IDS_ENABLE_AND_DISABLE     2509
#define IDS_ONCE_NA_OPTIONS        2510
#define IDS_CHANGE_ONCE_NA         2511
#define IDS_PREVENT_CREATE         2512
#define IDS_PREVENT_DELETE         2513
#define IDS_PREVENT_RUN            2514
#define IDS_PREVENT_END            2515
#define IDS_PREVENT_CHANGE         2516
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\query.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        Query.h

    Abstract:

        This module contains the macros, user defined structures & function
        definitions needed by Query.cpp , QueryTasks.cpp files.

    Author:

        G.Surender Reddy  10-sept-2000

    Revision History:

        G.Surender Reddy 10-sept-2000 : Created it
        G.Surender Reddy 25-sep-2000 : Modified it
                                       [ Added macro constants,Function
                                        definitions ]

******************************************************************************/

#ifndef __QUERY_H
#define __QUERY_H

#pragma once        // include header file only once


//width constants for the fields
#define WIDTH_HOSTNAME          AsLong( GetResString( IDS_WIDTH_HOSTNAME ), 10 )
#define WIDTH_TASKNAME          AsLong( GetResString( IDS_WIDTH_TASKNAME ), 10 )
#define WIDTH_NEXTRUNTIME       AsLong( GetResString( IDS_WIDTH_NEXTRUNTIME ), 10 )
#define WIDTH_LASTRUNTIME       AsLong( GetResString( IDS_WIDTH_LASTRUNTIME ), 10 )
#define WIDTH_STATUS            AsLong( GetResString( IDS_WIDTH_STATUS ), 10 )
#define WIDTH_MODE              AsLong( GetResString( IDS_WIDTH_MODE ), 10 )
#define WIDTH_LASTRESULT        AsLong( GetResString( IDS_WIDTH_LASTRESULT ), 10 )
#define WIDTH_CREATOR           AsLong( GetResString( IDS_WIDTH_CREATOR ), 10 )
#define WIDTH_SCHEDULE          AsLong( GetResString( IDS_WIDTH_SCHEDULE ), 10 )
#define WIDTH_APPNAME           AsLong( GetResString( IDS_WIDTH_APPNAME ), 10 )
#define WIDTH_WORKDIRECTORY     AsLong( GetResString( IDS_WIDTH_WORKDIRECTORY ), 10 )
#define WIDTH_COMMENT           AsLong( GetResString( IDS_WIDTH_COMMENT ), 10 )
#define WIDTH_TASKSTATE         AsLong( GetResString( IDS_WIDTH_TASKSTATE ), 10 )
#define WIDTH_TASKTYPE          AsLong( GetResString( IDS_WIDTH_TASKTYPE ), 10 )
#define WIDTH_TASKSTIME         AsLong( GetResString( IDS_WIDTH_TASKSTIME ), 10 )
#define WIDTH_TASKSDATE         AsLong( GetResString( IDS_WIDTH_TASKSDATE ), 10 )
#define WIDTH_TASKEDATE         AsLong( GetResString( IDS_WIDTH_TASKEDATE ), 10 )
#define WIDTH_TASKDAYS          AsLong( GetResString( IDS_WIDTH_TASKDAYS ), 10 )
#define WIDTH_TASKMONTHS        AsLong( GetResString( IDS_WIDTH_TASKMONTHS ), 10 )

#define WIDTH_TASKRUNASUSER     AsLong( GetResString( IDS_WIDTH_TASKRUNASUSER ), 10 )
#define WIDTH_TASKDELETE        AsLong( GetResString( IDS_WIDTH_TASKDELETE ), 10 )
#define WIDTH_TASKSTOP          AsLong( GetResString( IDS_WIDTH_TASKSTOP ), 10 )
#define WIDTH_TASK_RPTEVERY     AsLong( GetResString( IDS_WIDTH_TASK_RPTEVERY ), 10 )
#define WIDTH_TASK_UNTILRPTTIME AsLong( GetResString( IDS_WIDTH_TASK_UNTILRPTTIME ), 10 )
#define WIDTH_TASK_RPTDURATION  AsLong( GetResString( IDS_WIDTH_TASK_RPTDURATION ), 10 )
#define WIDTH_TASK_RPTRUNNING   AsLong( GetResString( IDS_WIDTH_TASK_RPTRUNNING ), 10 )

#define WIDTH_TASKIDLE      AsLong( GetResString( IDS_WIDTH_TASKIDLE ), 10 )
#define WIDTH_TASKPOWER     AsLong( GetResString( IDS_WIDTH_TASKPOWERMGMT ), 10 )

//constants of Task properties column numbers

#define HOSTNAME_COL_NUMBER                     AsLong( GetResString( IDS_HOSTNAME_COL_NUMBER ), 10 )
#define TASKNAME_COL_NUMBER                     AsLong( GetResString( IDS_TASKNAME_COL_NUMBER ), 10 )
#define NEXTRUNTIME_COL_NUMBER                  AsLong( GetResString( IDS_NEXTRUNTIME_COL_NUMBER ), 10 )
#define LASTRUNTIME_COL_NUMBER                  AsLong( GetResString( IDS_LASTRUNTIME_COL_NUMBER ), 10 )
#define STATUS_COL_NUMBER                       AsLong( GetResString( IDS_STATUS_COL_NUMBER ), 10 )
#define LASTRESULT_COL_NUMBER                   AsLong( GetResString( IDS_LASTRESULT_COL_NUMBER ), 10 )
#define CREATOR_COL_NUMBER                      AsLong( GetResString( IDS_CREATOR_COL_NUMBER ), 10 )
#define SCHEDULE_COL_NUMBER                     AsLong( GetResString( IDS_SCHEDULE_COL_NUMBER ), 10 )
#define MODE_COL_NUMBER                         AsLong( GetResString( IDS_MODE_COL_NUMBER ), 10 )

#define TASKTORUN_COL_NUMBER                    AsLong( GetResString( IDS_TASKTORUN_COL_NUMBER ), 10 )
#define STARTIN_COL_NUMBER                      AsLong( GetResString( IDS_STARTIN_COL_NUMBER ), 10 )
#define COMMENT_COL_NUMBER                      AsLong( GetResString( IDS_COMMENT_COL_NUMBER ), 10 )
#define TASKSTATE_COL_NUMBER                    AsLong( GetResString( IDS_TASKSTATE_COL_NUMBER ), 10 )

#define TASKTYPE_COL_NUMBER                     AsLong( GetResString( IDS_TASKTYPE_COL_NUMBER ), 10 )
#define STARTTIME_COL_NUMBER                    AsLong( GetResString( IDS_STARTTIME_COL_NUMBER ), 10 )
#define STARTDATE_COL_NUMBER                    AsLong( GetResString( IDS_STARTDATE_COL_NUMBER ), 10 )
#define ENDDATE_COL_NUMBER                      AsLong( GetResString( IDS_ENDDATE_COL_NUMBER ), 10 )
#define DAYS_COL_NUMBER                         AsLong( GetResString( IDS_DAYS_COL_NUMBER ), 10 )
#define MONTHS_COL_NUMBER                       AsLong( GetResString( IDS_MONTHS_COL_NUMBER ), 10 )
#define RUNASUSER_COL_NUMBER                    AsLong( GetResString( IDS_RUNASUSER_COL_NUMBER ), 10 )
#define DELETE_IFNOTRESCHEDULED_COL_NUMBER      AsLong( GetResString( IDS_DELETE_IFNOTRESCHEDULED_COL_NUMBER ), 10 )
#define STOPTASK_COL_NUMBER                     AsLong( GetResString( IDS_STOPTASK_COL_NUMBER ), 10 )

#define REPEAT_EVERY_COL_NUMBER                 AsLong( GetResString( IDS_REPEAT_EVERY_COL_NUMBER ), 10 )
#define REPEAT_UNTILTIME_COL_NUMBER             AsLong( GetResString( IDS_REPEAT_UNTILTIME_COL_NUMBER ), 10 )
#define REPEAT_DURATION_COL_NUMBER              AsLong( GetResString( IDS_REPEAT_DURATION_COL_NUMBER ), 10 )
#define REPEAT_STOP_COL_NUMBER                  AsLong( GetResString( IDS_REPEAT_STOP_COL_NUMBER ), 10 )


#define IDLE_COL_NUMBER                 AsLong( GetResString( IDS_IDLE_COL_NUMBER ), 10 )
#define POWER_COL_NUMBER                AsLong( GetResString( IDS_POWER_MGMT_COL_NUMBER ), 10 )

#define COL_FORMAT_STRING               _T("%s")
#define COL_FORMAT_HEX                  _T("%d")
#define COL_SIZE_VERBOSE                3 //for Non-verbose mode only 3 columns
#define COL_SIZE_LIST                   4 //for LIST non-verbose mode only 4 columns

#define TIME_DATE_SEPERATOR     _T(", ")
#define MAX_DATETIME_LEN 64
#define MAX_TIME_FORMAT_LEN 9
#define VARIABLE_ARGS 2 //for now 2 variable  arguments used in FormatMessage() API

#define SERVICE_NAME    L"Schedule"

//Constants used in GetTaskTime to identify the type of time needed

#define TASK_NEXT_RUNTIME     0x0
#define TASK_LAST_RUNTIME     0x1
#define TASK_START_RUNTIME    0x2

#define MAX_DELETE_OPTIONS         7

// for -delete option
#define OI_DELETE_OPTION            0 // Index of -delete option in cmdOptions structure.
#define OI_DELETE_USAGE             1 // Index of -? option in cmdOptions structure.
#define OI_DELETE_SERVER            2 // Index of -s option in cmdOptions structure.
#define OI_DELETE_USERNAME          3 // Index of -u option in cmdOptions structure.
#define OI_DELETE_PASSWORD          4 // Index of -p option in cmdOptions structure.
#define OI_DELETE_TASKNAME          5 // Index of -tn option in cmdOptions structure.
#define OI_DELETE_FORCE             6 // Index of -f option in cmdOptions structure.

#define MAX_QUERY_OPTIONS          8

// for -query option
#define OI_QUERY_OPTION            0 // Index of -delete option in cmdOptions structure.
#define OI_QUERY_USAGE             1 // Index of -? option in cmdOptions structure.
#define OI_QUERY_SERVER            2 // Index of -s option in cmdOptions structure.
#define OI_QUERY_USERNAME          3 // Index of -u option in cmdOptions structure.
#define OI_QUERY_PASSWORD          4 // Index of -p option in cmdOptions structure.
#define OI_QUERY_FORMAT            5 // Index of -fo option in cmdOptions structure.
#define OI_QUERY_NOHEADER          6 // Index of -p option in cmdOptions structure.
#define OI_QUERY_VERBOSE           7 // Index of -fo option in cmdOptions structure.


//TaskProperties structure
typedef struct _tagTaskProperties
{
    WCHAR szTaskType[MAX_RES_STRING];
    WCHAR szTaskEndDate[MAX_RES_STRING];
    WCHAR szTaskDays[MAX_RES_STRING];
    WCHAR szTaskMonths[MAX_RES_STRING];
    WCHAR szTaskStartTime[MAX_DATETIME_LEN];
    WCHAR szTaskStartDate[MAX_DATETIME_LEN];
    WCHAR szRepeatEvery[MAX_DATETIME_LEN];
    WCHAR szRepeatUntilTime[MAX_RES_STRING];
    WCHAR szRepeatDuration[MAX_RES_STRING];
    WCHAR szRepeatStop[MAX_RES_STRING];

}TASKPROPS;

//Function prototype declarations

VOID DisplayQueryUsage();
HRESULT DisplayTasks(ITaskScheduler* pITS,BOOL bFilter,DWORD dwFormatType,BOOL bHeader);
HRESULT GetTaskRunTime(ITask* pITask,WCHAR* pszRunTime,WCHAR* pszRunDate,DWORD dwTimetype,
                       WORD wCurrentTrigger);
HRESULT GetApplicationToRun(ITask* pIT,WCHAR* pszApplicationName);
HRESULT GetWorkingDirectory(ITask* pIT,WCHAR* pszWorkingDirectory);
HRESULT GetComment(ITask* pIT,WCHAR*  pwszComment);
HRESULT GetCreator(ITask* pITask,WCHAR* pszCreator);
HRESULT GetTriggerString(ITask* pITask,WCHAR* pszTrigger,WORD wCurrentTrigger);
HRESULT GetTaskState(ITask* pITask,WCHAR* pszTaskState,DWORD dwFlag);
HRESULT GetRunAsUser(ITask* pIT,WCHAR* pszRunAsUser);
HRESULT GetMaxRunTime(ITask* pIT,WCHAR* pszMaxRunTime);
HRESULT GetTaskProps(ITask* pIT,TASKPROPS* pTaskProps,WORD wCurrentTrigger,WCHAR* pszScName );
HRESULT GetStatusCode(ITask* pITask,WCHAR* pszStatusCode);
VOID    CheckWeekDay(DWORD dwFlag,WCHAR* pWeekDay);
VOID    CheckMonth(DWORD dwFlag,WCHAR* pWhichMonth);
VOID    CheckWeek(DWORD dwFlag,WCHAR* pWhichWeek);
LCID    GetSupportedUserLocale( BOOL& bLocaleChanged );
BOOL    CheckServiceStatus(  IN LPCTSTR szServer, IN OUT DWORD* dwCheck, IN BOOL bFlag );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\run.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        run.h

    Abstract:

        This module contains the macros, user defined structures & function
        definitions needed by run.cpp

    Author:

        Venu Gopal Choudary   12-Mar-2001

    Revision History:

        Venu Gopal Choudary   12-Mar-2001  : Created it


******************************************************************************/

#ifndef __RUN_H
#define __RUN_H

#pragma once

#define MAX_RUN_OPTIONS         6

#define OI_RUN_OPTION            0 // Index of -run option in cmdOptions structure.
#define OI_RUN_USAGE             1 // Index of -? option in cmdOptions structure.
#define OI_RUN_SERVER            2 // Index of -s option in cmdOptions structure.
#define OI_RUN_USERNAME          3 // Index of -u option in cmdOptions structure.
#define OI_RUN_PASSWORD          4 // Index of -p option in cmdOptions structure.
#define OI_RUN_TASKNAME          5 // Index of -p option in cmdOptions structure.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\run.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        run.cpp

    Abstract:

        This module runs the schedule task present in the system

    Author:

        Venu Gopal Choudary 12-Mar-2001

    Revision History:

        Venu Gopal Choudary  12-Mar-2001 : Created it


******************************************************************************/


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


// Function declaration for the Usage function.
VOID DisplayRunUsage();

/*****************************************************************************

    Routine Description:

    This routine runs the scheduled task(s)

    Arguments:

        [ in ] argc :  Number of command line arguments
        [ in ] argv : Array containing command line arguments

    Return Value :
        A DWORD value indicating EXIT_SUCCESS on success else
        EXIT_FAILURE on failure

*****************************************************************************/

DWORD
RunScheduledTask(
                    IN DWORD argc,
                    IN LPCTSTR argv[]
                    )
{
    // Variables used to find whether Run option, Usage option
    // are specified or not
    BOOL bRun = FALSE;
    BOOL bUsage = FALSE;
    DWORD dwPolicy = 0;

    // Set the TaskSchduler object as NULL
    ITaskScheduler *pITaskScheduler = NULL;

    // Return value
    HRESULT hr  = S_OK;

    // Initialising the variables that are passed to TCMDPARSER structure
    LPWSTR  szServer = NULL;
    WCHAR  szTaskName[ MAX_JOB_LEN ] = L"\0";
    LPWSTR      szUser = NULL;
    LPWSTR      szPassword = NULL;

    // Dynamic Array contaning array of jobs
    TARRAY arrJobs = NULL;

    //buffer for displaying error message
    WCHAR   szMessage[2 * MAX_STRING_LENGTH] = L"\0";

    BOOL    bNeedPassword = FALSE;
    BOOL   bResult = FALSE;
    BOOL  bCloseConnection = TRUE;
    BOOL bFlag = FALSE;
    DWORD dwCheck = 0;

    TCMDPARSER2 cmdRunOptions[MAX_RUN_OPTIONS];
    BOOL bReturn = FALSE;

    // /run sub-options
    const WCHAR szRunOpt[]           = L"run";
    const WCHAR szRunHelpOpt[]       = L"?";
    const WCHAR szRunServerOpt[]     = L"s";
    const WCHAR szRunUserOpt[]       = L"u";
    const WCHAR szRunPwdOpt[]        = L"p";
    const WCHAR szRunTaskNameOpt[]   = L"tn";


    // set all the fields to 0
    SecureZeroMemory( cmdRunOptions, sizeof( TCMDPARSER2 ) * MAX_RUN_OPTIONS );

    //
    // fill the commandline parser
    //

    //  /delete option
    StringCopyA( cmdRunOptions[ OI_RUN_OPTION ].szSignature, "PARSER2\0", 8 );
    cmdRunOptions[ OI_RUN_OPTION ].dwType       = CP_TYPE_BOOLEAN;
    cmdRunOptions[ OI_RUN_OPTION ].pwszOptions  = szRunOpt;
    cmdRunOptions[ OI_RUN_OPTION ].dwCount = 1;
    cmdRunOptions[ OI_RUN_OPTION ].dwFlags = 0;
    cmdRunOptions[ OI_RUN_OPTION ].pValue = &bRun;

    //  /? option
    StringCopyA( cmdRunOptions[ OI_RUN_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdRunOptions[ OI_RUN_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdRunOptions[ OI_RUN_USAGE ].pwszOptions  = szRunHelpOpt;
    cmdRunOptions[ OI_RUN_USAGE ].dwCount = 1;
    cmdRunOptions[ OI_RUN_USAGE ].dwFlags = CP2_USAGE;
    cmdRunOptions[ OI_RUN_USAGE ].pValue = &bUsage;

    //  /s option
    StringCopyA( cmdRunOptions[ OI_RUN_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdRunOptions[ OI_RUN_SERVER ].dwType       = CP_TYPE_TEXT;
    cmdRunOptions[ OI_RUN_SERVER ].pwszOptions  = szRunServerOpt;
    cmdRunOptions[ OI_RUN_SERVER ].dwCount = 1;
    cmdRunOptions[ OI_RUN_SERVER ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /u option
    StringCopyA( cmdRunOptions[ OI_RUN_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdRunOptions[ OI_RUN_USERNAME ].dwType       = CP_TYPE_TEXT;
    cmdRunOptions[ OI_RUN_USERNAME ].pwszOptions  = szRunUserOpt;
    cmdRunOptions[ OI_RUN_USERNAME ].dwCount = 1;
    cmdRunOptions[ OI_RUN_USERNAME ].dwFlags = CP2_ALLOCMEMORY| CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL ;

    //  /p option
    StringCopyA( cmdRunOptions[ OI_RUN_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdRunOptions[ OI_RUN_PASSWORD ].dwType       = CP_TYPE_TEXT;
    cmdRunOptions[ OI_RUN_PASSWORD ].pwszOptions  = szRunPwdOpt;
    cmdRunOptions[ OI_RUN_PASSWORD ].dwCount = 1;
    cmdRunOptions[ OI_RUN_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;

    //  /tn option
    StringCopyA( cmdRunOptions[ OI_RUN_TASKNAME ].szSignature, "PARSER2\0", 8 );
    cmdRunOptions[ OI_RUN_TASKNAME ].dwType       = CP_TYPE_TEXT;
    cmdRunOptions[ OI_RUN_TASKNAME ].pwszOptions  = szRunTaskNameOpt;
    cmdRunOptions[ OI_RUN_TASKNAME ].dwCount = 1;
    cmdRunOptions[ OI_RUN_TASKNAME ].dwFlags = CP2_MANDATORY;
    cmdRunOptions[ OI_RUN_TASKNAME ].pValue = szTaskName;
    cmdRunOptions[ OI_RUN_TASKNAME ].dwLength = MAX_JOB_LEN;

    //parse command line arguments
    bReturn = DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdRunOptions), cmdRunOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // get the buffer pointers allocated by command line parser
    szServer = (LPWSTR)cmdRunOptions[ OI_RUN_SERVER ].pValue;
    szUser = (LPWSTR)cmdRunOptions[ OI_RUN_USERNAME ].pValue;
    szPassword = (LPWSTR)cmdRunOptions[ OI_RUN_PASSWORD ].pValue;

    if ( (argc > 3) && (bUsage  == TRUE) )
    {
        ShowMessage ( stderr, GetResString (IDS_ERROR_RUNPARAM) );
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // Displaying run usage if user specified -? with -run option
    if( bUsage == TRUE )
    {
        DisplayRunUsage();
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    // check for invalid user name
    if( ( cmdRunOptions[OI_RUN_SERVER].dwActuals == 0 ) && ( cmdRunOptions[OI_RUN_USERNAME].dwActuals == 1 )  )
    {
        ShowMessage(stderr, GetResString(IDS_RUN_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }

    // check whether -ru is specified or not
    if ( cmdRunOptions[ OI_RUN_USERNAME ].dwActuals == 0 &&
                cmdRunOptions[ OI_RUN_PASSWORD ].dwActuals == 1 )
    {
        // invalid syntax
        ShowMessage(stderr, GetResString(IDS_RPASSWORD_BUT_NOUSERNAME));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }

    // check for the length of taskname
    if( ( StringLength( szTaskName, 0 ) > MAX_JOB_LEN ) )
    {
        ShowMessage(stderr, GetResString( IDS_INVALID_TASKLENGTH ));
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return RETVAL_FAIL;
    }


    //for holding values of parameters in FormatMessage()
    WCHAR* szValues[1] = {NULL};

    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( szServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( szUser == NULL )
        {
            szUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szUser == NULL )
            {
                SaveLastError();
		        FreeMemory((LPVOID*) &szServer);
		        FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);

                return RETVAL_FAIL;
            }
        }

        // password
        if ( szPassword == NULL )
        {
            bNeedPassword = TRUE;
            szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( szPassword == NULL )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
		        FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);

                return RETVAL_FAIL;
            }
        }

        // case 1
        if ( cmdRunOptions[ OI_RUN_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdRunOptions[ OI_RUN_PASSWORD ].pValue == NULL )
        {
            StringCopy( szPassword, L"*", GetBufferSize(szPassword)/sizeof(WCHAR));
        }

        // case 3
        else if ( StringCompareEx( szPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&szPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
				FreeMemory((LPVOID*) &szServer);
		        FreeMemory((LPVOID*) &szUser);
				FreeMemory((LPVOID*) &szPassword);

                return RETVAL_FAIL;
            }

            // ...
            bNeedPassword = TRUE;
        }
    }


    if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdRunOptions[OI_RUN_USERNAME].dwActuals == 1 ) )
    {
        bFlag = TRUE;
        // Establish the connection on a remote machine
        bResult = EstablishConnection(szServer,szUser,GetBufferSize(szUser)/sizeof(WCHAR),szPassword,GetBufferSize(szPassword)/sizeof(WCHAR), bNeedPassword );
        if (bResult == FALSE)
        {
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            FreeMemory((LPVOID*) &szServer);
            FreeMemory((LPVOID*) &szUser);
            FreeMemory((LPVOID*) &szPassword);
            return EXIT_FAILURE ;
        }
        else
        {
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                    bCloseConnection = FALSE;
                    break;
            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bCloseConnection = FALSE;
                    ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                    FreeMemory((LPVOID*) &szServer);
                    FreeMemory((LPVOID*) &szUser);
                    FreeMemory((LPVOID*) &szPassword);
                    return EXIT_FAILURE;
                }
             default :
                 bCloseConnection = TRUE;
            }
        }

        //release memory for password
        FreeMemory((LPVOID*) &szPassword);
    }
    // Get the task Scheduler object for the machine.
    pITaskScheduler = GetTaskScheduler( szServer );

    // If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {
        // close the connection that was established by the utility
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    //check whether service is running or not
    if ((FALSE == CheckServiceStatus ( szServer , &dwCheck, TRUE)) && (0 != dwCheck) && ( GetLastError () != ERROR_ACCESS_DENIED)) 
    {
        // close the connection that was established by the utility
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);

        if ( 1 == dwCheck )
        {
            ShowMessage ( stderr, GetResString (IDS_NOT_START_SERVICE));
            return EXIT_FAILURE;
        }
        else if (2 == dwCheck )
        {
            return EXIT_FAILURE;
        }
        else if (3 == dwCheck )
        {
            return EXIT_SUCCESS;
        }
        
    }

    // Validate the Given Task and get as TARRAY in case of taskname
    arrJobs = ValidateAndGetTasks( pITaskScheduler, szTaskName);
    if( arrJobs == NULL )
    {
        StringCchPrintf( szMessage , SIZE_OF_ARRAY(szMessage), GetResString(IDS_TASKNAME_NOTEXIST), _X( szTaskName ));
        ShowMessage(stderr, szMessage );

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;

    }

    // check whether the group policy prevented user from running or not.
    if ( FALSE == GetGroupPolicy( szServer, szUser, TS_KEYPOLICY_DENY_EXECUTION, &dwPolicy ) )
    {
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }
    
    if ( dwPolicy > 0 )
    {
        ShowMessage ( stdout, GetResString (IDS_PREVENT_RUN));
        
        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    
    IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;

    StringConcat ( szTaskName, JOB, SIZE_OF_ARRAY(szTaskName) );

    // returns an pITask inteface for szTaskName
    hr = pITaskScheduler->Activate(szTaskName,IID_ITask,
                                       (IUnknown**) &pITask);

    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);

        return EXIT_FAILURE;
    }

    WCHAR  szTaskProperty[MAX_STRING_LENGTH] = L"\0";

    // get the status code
    hr = GetStatusCode(pITask,szTaskProperty);
    if (FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;

    }

    // remove the .job extension from the taskname
    if ( ParseTaskName( szTaskName ) )
    {
        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    // check whether the task already been running or not
    if ( (StringCompare(szTaskProperty , GetResString(IDS_STATUS_RUNNING), TRUE, 0) == 0 ))
    {
        szValues[0] = (WCHAR*) (szTaskName);

        StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_RUNNING_ALREADY), _X(szTaskName));
        ShowMessage(stdout, _X(szMessage));

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_SUCCESS;
    }

    // run the scheduled task immediately
    hr = pITask->Run();

    if ( FAILED(hr) )
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        if( pIPF )
            pIPF->Release();

        if( pITask )
            pITask->Release();

        if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

        Cleanup(pITaskScheduler);
        FreeMemory((LPVOID*) &szServer);
        FreeMemory((LPVOID*) &szUser);
        FreeMemory((LPVOID*) &szPassword);
        return EXIT_FAILURE;
    }

    szValues[0] = (WCHAR*) (szTaskName);

    StringCchPrintf ( szMessage, SIZE_OF_ARRAY(szMessage), GetResString(IDS_RUN_SUCCESSFUL), _X(szTaskName));
    ShowMessage ( stdout, _X(szMessage));


    if( pIPF )
        pIPF->Release();

    if( pITask )
        pITask->Release();

    if ( (TRUE == bFlag) && (bCloseConnection == TRUE) )
        {
            CloseConnection( szServer );
        }

    Cleanup(pITaskScheduler);
    FreeMemory((LPVOID*) &szServer);
    FreeMemory((LPVOID*) &szUser);
    FreeMemory((LPVOID*) &szPassword);

    return EXIT_SUCCESS;
}

/*****************************************************************************

    Routine Description:

        This routine  displays the usage of -run option

    Arguments:
        None

    Return Value :
        VOID
******************************************************************************/

VOID
DisplayRunUsage()
{
    // Displaying run option usage
    DisplayUsage( IDS_RUN_HLP1, IDS_RUN_HLP17 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scriptpw\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\scheduledtasks.h ===
/******************************************************************************
//
//    Copyright(c) Microsoft Corporation
//
//    Module Name:
//
//        ScheduledTasks.h
//
//    Abstract:
//
//        This module contains the macros, user defined structures & function
//        definitions needed by ScheduledTasks.cpp , create.cpp , delete.cpp ,
//        query.cpp , createvalidations.cpp , change.cpp , run.cpp and end.cpp files.
//
//    Author:
//
//        G.Surender Reddy  10-sept-2000
//
//    Revision History:
//
//        G.Surender Reddy 10-sept-2000 : Created it
//       G.Surender Reddy 25-sep-2000 : Modified it
//                                       [ Added macro constants,Function
//                                        definitions ]
//        Venu Gopal Choudary 01-Mar-2001 : Modified it
//                                        [ Added -change option]
//
//        Venu Gopal Choudary 12-Mar-2001 : Modified it
//                                        [ Added -run and -end options]
//
******************************************************************************/

#ifndef __SCHEDULEDTASKS_H
#define __SCHEDULEDTASKS_H

#pragma once        // include header file only once

// constants / defines / enumerations

#define MAX_MAIN_COMMANDLINE_OPTIONS       8

// Options
#define OI_USAGE           0
#define OI_CREATE          1 
#define OI_DELETE          2
#define OI_QUERY           3
#define OI_CHANGE          4
#define OI_RUN             5
#define OI_END             6
#define OI_OTHERS          7

// Other constants

//To retrive 1 tasks at a time ,used in TaskScheduler API fns.
#define TASKS_TO_RETRIEVE   1
//#define TRIM_SPACES TEXT(" \0")

#define NTAUTHORITY_USER _T("NT AUTHORITY\\SYSTEM")
#define SYSTEM_USER      _T("SYSTEM")

// Exit values
#define EXIT_SUCCESS        0
#define EXIT_FAILURE        1


#define DOMAIN_U_STRING     L"\\\\"
#define NULL_U_CHAR         L'\0'
#define BACK_SLASH_U        L'\\'

#define JOB             _T(".job")

#define COMMA_STRING     _T(",")

#define DASH         L"-"
#define SID_STRING   L"S-1"
#define AUTH_FORMAT_STR1         L"0x%02hx%02hx%02hx%02hx%02hx%02hx"
#define AUTH_FORMAT_STR2         L"%lu"

// Main functions
HRESULT CreateScheduledTask( DWORD argc , LPCTSTR argv[] );
DWORD DeleteScheduledTask( DWORD argc , LPCTSTR argv[] );
DWORD QueryScheduledTasks( DWORD argc , LPCTSTR argv[] );
DWORD ChangeScheduledTaskParams( DWORD argc , LPCTSTR argv[] );
DWORD RunScheduledTask( DWORD argc , LPCTSTR argv[] );
DWORD TerminateScheduledTask( DWORD argc , LPCTSTR argv[] );

HRESULT Init( ITaskScheduler **pITaskScheduler );
VOID displayMainUsage();
BOOL PreProcessOptions( DWORD argc, LPCTSTR argv[], PBOOL pbUsage, PBOOL pbCreate,
   PBOOL pbQuery, PBOOL pbDelete, PBOOL pbChange, PBOOL pbRun, PBOOL pbEnd, PBOOL pbDefVal );

VOID Cleanup( ITaskScheduler *pITaskScheduler);
ITaskScheduler* GetTaskScheduler( LPCTSTR pszServerName );
TARRAY ValidateAndGetTasks( ITaskScheduler * pITaskScheduler, LPCTSTR pszTaskName);
DWORD ParseTaskName( LPWSTR lpszTaskName );
DWORD DisplayUsage( ULONG StartingMessage, ULONG EndingMessage );
BOOL GetGroupPolicy( LPWSTR szServer, LPWSTR szUserName, LPWSTR PolicyType, LPDWORD lpdwPolicy );
BOOL GetPolicyValue( HKEY hKey, LPWSTR szPolicyType, LPDWORD lpdwPolicy );
BOOL GetSidString ( IN PSID pSid, OUT LPWSTR wszSid );

#endif // __SCHEDULEDTASKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scheduledtasks\scheduledtasks.cpp ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        ScheduledTasks.cpp

    Abstract:

        This module initialises the OLE library,Interfaces, & reads the  input data
        from the command line.This module calls the appropriate functions for acheiving
        the functionality of different options.

    Author:

        Raghu B  10-Sep-2000

    Revision History:

        Raghu B  10-Sep-2000 : Created it

        G.Surender Reddy 25-sep-2000 : Modified it
                                       [ Added error checking ]

        G.Surender Reddy 10-oct-2000 : Modified it
                                       [ Moved the strings to Resource table ]

        Venu Gopal Choudary 01-Mar-2001 : Modified it
                                        [ Added -change option]

        Venu Gopal Choudary 12-Mar-2001 : Modified it
                                        [ Added -run and -end options]

******************************************************************************/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

/******************************************************************************

    Routine Description:

        This function process the options specified in the command line & routes to
        different appropriate options [-create,-query,-delete,-change,-run,-end]
        handling functions.This is the MAIN entry point for this utility.

    Arguments:

        [ in ] argc : The count of arguments specified in the command line
        [ in ] argv : Array of command line arguments

    Return Value :
        A DWORD value indicating EXIT_SUCCESS on success else
        EXIT_FAILURE on failure

******************************************************************************/


DWORD _cdecl
wmain(
        IN DWORD argc,
        IN LPCTSTR argv[]
        )
{
    // Declaring the main option switches as boolean values
    BOOL    bUsage  = FALSE;
    BOOL    bCreate = FALSE;
    BOOL    bQuery  = FALSE;
    BOOL    bDelete = FALSE;
    BOOL    bChange = FALSE;
    BOOL    bRun    = FALSE;
    BOOL    bEnd    = FALSE;
    BOOL    bDefVal = FALSE;

    DWORD   dwRetStatus = EXIT_SUCCESS;
    HRESULT hr = S_OK;

     // Call the preProcessOptions function to find out the option selected by the user
     BOOL bValue = PreProcessOptions( argc , argv , &bUsage , &bCreate , &bQuery , &bDelete ,
                                        &bChange , &bRun , &bEnd , &bDefVal );


    if(bValue == FALSE)
    {
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // If ScheduledTasks.exe /?
    if( bUsage &&  ( bCreate + bQuery + bDelete + bChange + bRun + bEnd ) == 0 )
    {
        displayMainUsage();
        ReleaseGlobals();
        return EXIT_SUCCESS;
    }

    // If ScheduledTasks.exe -create option is selected
    if( bCreate  == TRUE)
    {
        hr = CreateScheduledTask( argc, argv );

        ReleaseGlobals();

        if ( FAILED(hr) )
        {
            return EXIT_FAILURE;
        }
        else
        {
            return EXIT_SUCCESS;
        }

    }

    // If ScheduledTasks.exe -Query option is selected
    if( bQuery == TRUE )
    {
        dwRetStatus = QueryScheduledTasks( argc, argv );
        ReleaseGlobals();
        return dwRetStatus;
    }

    // If ScheduledTasks.exe -delete option is selected
    if( bDelete  == TRUE)
    {
        dwRetStatus = DeleteScheduledTask( argc, argv );
        ReleaseGlobals();
        return dwRetStatus;
    }

    // If ScheduledTasks.exe -change option is selected
    if( bChange  == TRUE)
    {
        dwRetStatus = ChangeScheduledTaskParams( argc, argv );
        ReleaseGlobals();
        return dwRetStatus;
    }

    // If ScheduledTasks.exe -run option is selected
    if( bRun  == TRUE)
    {
        dwRetStatus = RunScheduledTask( argc, argv );
        ReleaseGlobals();
        return dwRetStatus;
    }

    // If ScheduledTasks.exe -end option is selected
    if( bEnd  == TRUE)
    {
        dwRetStatus = TerminateScheduledTask( argc, argv );
        ReleaseGlobals();
        return dwRetStatus;
    }

    // If ScheduledTasks.exe option is selected
    if( bDefVal == TRUE )
    {
        dwRetStatus = QueryScheduledTasks( argc, argv );
        ReleaseGlobals();
        return dwRetStatus;
    }

    ReleaseGlobals();
    return  dwRetStatus;

}

/******************************************************************************

    Routine Description:

        This function process the options specified in the command line & routes to
        different appropriate functions.

    Arguments:

        [ in ]  argc         : The count of arguments specified in the command line
        [ in ]  argv         : Array of command line arguments
        [ out ] pbUsage      : pointer to flag for determining [usage] -? option
        [ out ] pbCreate     : pointer to flag for determining -create option
        [ out ] pbQuery      : pointer to flag for determining -query option
        [ out ] pbDelete     : pointer to flag for determining -delete option
        [ out ] pbChange     : pointer to flag for determining -change option
        [ out ] pbRun        : pointer to flag for determining -run option
        [ out ] pbEnd        : pointer to flag for determining -end option
        [ out ] pbDefVal     : pointer to flag for determining default value

    Return Value :
        A BOOL value indicating TRUE on success else FALSE

******************************************************************************/

BOOL
PreProcessOptions(
                    IN DWORD argc,
                    IN LPCTSTR argv[] ,
                    OUT PBOOL pbUsage,
                    OUT PBOOL pbCreate,
                    OUT PBOOL pbQuery,
                    OUT PBOOL pbDelete ,
                    OUT PBOOL pbChange ,
                    OUT PBOOL pbRun ,
                    OUT PBOOL pbEnd ,
                    OUT PBOOL pbDefVal
                    )
{
     // sub-local variables
    TCMDPARSER2 cmdOptions[MAX_MAIN_COMMANDLINE_OPTIONS];
    BOOL bReturn = FALSE;
    //BOOL bOthers = FALSE;

    // command line options
    const WCHAR szCreateOpt[]    = L"create";
    const WCHAR szDeleteOpt[]    = L"delete";
    const WCHAR szQueryOpt[]     = L"query";
    const WCHAR szChangeOpt[]    = L"change";
    const WCHAR szRunOpt[]       = L"run";
    const WCHAR szEndOpt[]       = L"end";
    const WCHAR szHelpOpt[]      = L"?";

    TARRAY arrTemp         = NULL;

    arrTemp = CreateDynamicArray();
    if( NULL == arrTemp)
    {
        SetLastError((DWORD)E_OUTOFMEMORY);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_ERROR| SLE_INTERNAL);
        return FALSE;
    }


    SecureZeroMemory(cmdOptions,sizeof(TCMDPARSER2) * MAX_MAIN_COMMANDLINE_OPTIONS);


    //
    // fill the commandline parser
    //

     //  /? option
    StringCopyA( cmdOptions[ OI_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_USAGE ].pwszOptions  = szHelpOpt;
    cmdOptions[ OI_USAGE ].dwCount = 1;
    cmdOptions[ OI_USAGE ].dwFlags = CP2_USAGE ;
    cmdOptions[ OI_USAGE ].pValue = pbUsage;

     //  /create option
    StringCopyA( cmdOptions[ OI_CREATE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_CREATE ].dwType       = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_CREATE ].pwszOptions  = szCreateOpt;
    cmdOptions[ OI_CREATE ].dwCount = 1;
    cmdOptions[ OI_CREATE ].pValue = pbCreate;

     //  /delete option
    StringCopyA( cmdOptions[ OI_DELETE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_DELETE ].dwType       = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_DELETE ].pwszOptions  = szDeleteOpt;
    cmdOptions[ OI_DELETE ].dwCount = 1;
    cmdOptions[ OI_DELETE ].dwActuals = 0;
    cmdOptions[ OI_DELETE ].pValue = pbDelete;


    //  /query option
    StringCopyA( cmdOptions[ OI_QUERY ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_QUERY ].dwType       = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_QUERY ].pwszOptions  = szQueryOpt;
    cmdOptions[ OI_QUERY ].dwCount = 1;
    cmdOptions[ OI_QUERY ].pValue = pbQuery;

     //  /change option
    StringCopyA( cmdOptions[ OI_CHANGE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_CHANGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_CHANGE ].pwszOptions  = szChangeOpt;
    cmdOptions[ OI_CHANGE ].dwCount = 1;
    cmdOptions[ OI_CHANGE ].pValue = pbChange;

    //  /run option
    StringCopyA( cmdOptions[ OI_RUN ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_RUN ].dwType       = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_RUN ].pwszOptions  = szRunOpt;
    cmdOptions[ OI_RUN ].dwCount = 1;
    cmdOptions[ OI_RUN ].pValue = pbRun;

     //  /end option
    StringCopyA( cmdOptions[ OI_END ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_END ].dwType       = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_END ].pwszOptions  = szEndOpt;
    cmdOptions[ OI_END ].dwCount = 1;
    cmdOptions[ OI_END ].pValue = pbEnd;

     //  default/sub options
    StringCopyA( cmdOptions[ OI_OTHERS ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_OTHERS ].dwType       = CP_TYPE_TEXT;
    cmdOptions[ OI_OTHERS ].dwFlags = CP2_MODE_ARRAY|CP2_DEFAULT;
    cmdOptions[ OI_OTHERS ].pValue = &arrTemp;


   //parse command line arguments
    bReturn = DoParseParam2( argc, argv, -1, MAX_MAIN_COMMANDLINE_OPTIONS, cmdOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        // destroy dynamic array
        if(arrTemp != NULL)
        {
            DestroyDynamicArray(&arrTemp);
            arrTemp = NULL;
        }

        ReleaseGlobals();
        return FALSE;
    }

    // destroy dynamic array
    if(arrTemp != NULL)
    {
        DestroyDynamicArray(&arrTemp);
        arrTemp = NULL;
    }

    //
    // check for invalid syntax
    //
    if ( (( *pbCreate + *pbQuery + *pbDelete + *pbChange + *pbRun + *pbEnd ) == 0) &&
        (TRUE == *pbUsage) && (argc > 2) )
    {
        ShowMessage( stderr, GetResString(IDS_RES_ERROR ));
        return FALSE;
    }

    if(((*pbCreate + *pbQuery + *pbDelete + *pbChange + *pbRun + *pbEnd)> 1 ) ||
       (( *pbCreate + *pbQuery + *pbDelete + *pbChange + *pbRun + *pbEnd + *pbUsage ) == 0 ) )
    {
        if ( ( *pbCreate + *pbQuery + *pbDelete + *pbChange + *pbRun + *pbEnd + *pbUsage ) > 1 )
        {
            ShowMessage( stderr, GetResString(IDS_RES_ERROR ));
            return FALSE;
        }
        else if( *pbCreate == TRUE )
        {
            ShowMessage(stderr, GetResString(IDS_CREATE_USAGE));
            return FALSE;
        }
        else if( *pbQuery == TRUE )
        {
            ShowMessage(stderr, GetResString(IDS_QUERY_USAGE));
            return FALSE;
        }
        else if( *pbDelete == TRUE )
        {
            ShowMessage(stderr, GetResString(IDS_DELETE_SYNERROR));
            return FALSE;
        }
        else if( *pbChange == TRUE )
        {
            ShowMessage(stderr, GetResString(IDS_CHANGE_SYNERROR));
            return FALSE;
        }
        else if( *pbRun == TRUE )
        {
            ShowMessage(stderr, GetResString(IDS_RUN_SYNERROR));
            return FALSE;
        }
        else if( *pbEnd == TRUE )
        {
            ShowMessage(stderr, GetResString(IDS_END_SYNERROR));
            return FALSE;
        }
        else if( (!( *pbQuery )) && ( argc > 2 ) )
        {
            ShowMessage( stderr, GetResString(IDS_RES_ERROR ));
            return FALSE;
        }
        else
        {
            *pbDefVal = TRUE;
        }
    }

    return TRUE;
}

/******************************************************************************

    Routine Description:

        This function fetches the ITaskScheduler Interface.It also connects to
        the remote machine if specified &   helps  to operate
        ITaskScheduler on the specified target m/c.

    Arguments:

        [ in ] szServer   : server's name

    Return Value :
        ITaskScheduler interface pointer on success else NULL

******************************************************************************/

ITaskScheduler*
GetTaskScheduler(
                    IN LPCTSTR szServer
                    )
{
    HRESULT hr = S_OK;
    ITaskScheduler *pITaskScheduler = NULL;
    LPWSTR wszComputerName = NULL;
    WCHAR wszActualComputerName[ 2 * MAX_STRING_LENGTH ] = DOMAIN_U_STRING;
    wchar_t* pwsz = L"";
    WORD wSlashCount = 0 ;

    hr = Init( &pITaskScheduler );

    if( FAILED(hr))
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return NULL;
    }

    //If the operation is on remote machine
    if( IsLocalSystem(szServer) == FALSE )
    {

        wszComputerName = (LPWSTR)szServer;

        //check whether the server name prefixed with \\ or not.
        if( wszComputerName != NULL )
        {
            pwsz =  wszComputerName;
            while ( ( *pwsz != NULL_U_CHAR ) && ( *pwsz == BACK_SLASH_U )  )
            {
                // server name prefixed with '\'..
                // so..increment the pointer and count number of black slashes..
                pwsz = _wcsinc(pwsz);
                wSlashCount++;
            }

            if( (wSlashCount == 2 ) ) // two back slashes are present
            {
                StringCopy( wszActualComputerName, wszComputerName, SIZE_OF_ARRAY(wszActualComputerName) );
            }
            else if ( wSlashCount == 0 )
            {
                //Append "\\" to computer name
                StringConcat(wszActualComputerName, wszComputerName, 2 * MAX_RES_STRING);
            }
            else
            {
                // display an error message as invalid address specified.
                ShowMessage (stderr, GetResString ( IDS_INVALID_NET_ADDRESS ));
                return NULL;
            }

        }

        hr = pITaskScheduler->SetTargetComputer( wszActualComputerName );

    }
    else
    {
        //Local Machine
        hr = pITaskScheduler->SetTargetComputer( NULL );
    }

    if( FAILED( hr ) )
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return NULL;
    }

    return pITaskScheduler;
}

/******************************************************************************

    Routine Description:

        This function initialises the COM library & fetches the ITaskScheduler interface.

    Arguments:

        [ in ] pITaskScheduler  : double pointer to taskscheduler interface

    Return Value:

        A HRESULT  value indicating success code else failure code

******************************************************************************/

HRESULT
Init(
        IN OUT ITaskScheduler **pITaskScheduler
        )
{
    // Initalize the HRESULT value.
    HRESULT hr = S_OK;

    // Bring in the library
    hr = CoInitializeEx( NULL , COINIT_APARTMENTTHREADED );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_NONE,
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                NULL, EOAC_NONE, 0 );
    if (FAILED(hr))
    {
        CoUninitialize();
        return hr;
    }

    // Create the pointer to Task Scheduler object
    // CLSID from the header file mstask.h
    // Fill the task schdeuler object.
    hr = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_ALL,
                           IID_ITaskScheduler,(LPVOID*) pITaskScheduler );

    // Should we fail, unload the library
    if (FAILED(hr))
    {
        CoUninitialize();
    }

    return hr;
}



/******************************************************************************

    Routine Description:

        This function releases the ITaskScheduler & unloads the COM library

    Arguments:

        [ in ] pITaskScheduler : pointer to the ITaskScheduler

    Return Value :
        VOID

******************************************************************************/

VOID
Cleanup(
        IN ITaskScheduler *pITaskScheduler
        )
{
    if (pITaskScheduler)
    {
        pITaskScheduler->Release();

    }

    // Unload the library, now that our pointer is freed.
    CoUninitialize();
    return;

}


/******************************************************************************

    Routine Description:

        This function displays the main  usage help of this utility

    Arguments:

        None

    Return Value :
        VOID

******************************************************************************/

VOID
displayMainUsage()
{

    DisplayUsage( IDS_MAINHLP1, IDS_MAINHLP21);
    return;

}

/******************************************************************************

    Routine Description:

        This function deletes the .job extension from the task name

    Arguments:

        [ in ] lpszTaskName : Task name

    Return Value :
        None

******************************************************************************/

DWORD
ParseTaskName(
                IN LPWSTR lpszTaskName
                )
{

    if(lpszTaskName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Remove the .Job extension from the task name
    lpszTaskName[StringLength(lpszTaskName, 0 ) - StringLength(JOB, 0) ] = L'\0';
    return EXIT_SUCCESS;
}

/******************************************************************************

    Routine Description:

        This function displays the messages for usage of different option

    Arguments:

        [ in ] StartingMessage : First string to display
        [ in ] EndingMessage   : Last string to display

    Return Value :
        DWORD

******************************************************************************/

DWORD
DisplayUsage(
                    IN ULONG StartingMessage,
                    IN ULONG EndingMessage
                    )
{
     ULONG       ulCounter = 0;
     LPCTSTR     lpszCurrentString = NULL;

     for( ulCounter = StartingMessage; ulCounter <= EndingMessage; ulCounter++ )
     {
         lpszCurrentString = GetResString( ulCounter );

         if( lpszCurrentString != NULL )
         {
             ShowMessage( stdout, _X(lpszCurrentString) );
         }
         else
         {
             return ERROR_INVALID_PARAMETER;
         }

     }
    return ERROR_SUCCESS;

}


BOOL
GetGroupPolicy( 
                IN LPWSTR szServer, 
                IN LPWSTR szUserName,
                IN LPWSTR szPolicyType, 
                OUT LPDWORD lpdwPolicy 
                )
/*++
    Routine Description:

        This function gets the value of a group policy in the registry 
        for a specified policy type.

    Arguments:

        [ in ] szServer : Server name
        [ in ] szPolicyType   : Policy Type
        [ out ] lpdwPolicy   : Value of the policy

    Return Value :
        DWORD

--*/

{
    // sub-variables
    LONG lResult = 0;
    HKEY hKey = 0;
    HKEY hLMKey = 0;
    HKEY hUKey = 0;
    HKEY hPolicyKey = 0;
    PBYTE pByteData = NULL;
    LPWSTR wszComputerName = NULL;
    LPWSTR pwsz = NULL;
    LPWSTR pszStopStr = NULL;
    WCHAR wszActualComputerName[ 2 * MAX_STRING_LENGTH ];
    WCHAR wszBuffer[ MAX_STRING_LENGTH ];
    WCHAR wszSid[ MAX_STRING_LENGTH ];
    DWORD dwType = 0;
    WORD wSlashCount = 0;
    DWORD dwPolicy = 0;

    SecureZeroMemory ( wszActualComputerName, SIZE_OF_ARRAY(wszActualComputerName) );
    SecureZeroMemory ( wszBuffer, SIZE_OF_ARRAY(wszBuffer) );


    StringCopy ( wszActualComputerName, DOMAIN_U_STRING, SIZE_OF_ARRAY(wszActualComputerName) );
    
    // check whether server name prefixed with "\\" or not..If not, append the same
    // to the server name
    if ( (StringLength (szServer, 0 ) != 0) && (IsLocalSystem (szServer) == FALSE ))
    {
        wszComputerName = (LPWSTR)szServer;

        //check whether the server name prefixed with \\ or not.
        if( wszComputerName != NULL )
        {
            pwsz =  wszComputerName;
            while ( ( *pwsz != NULL_U_CHAR ) && ( *pwsz == BACK_SLASH_U )  )
            {
                // server name prefixed with '\'..
                // so..increment the pointer and count number of black slashes..
                pwsz = _wcsinc(pwsz);
                wSlashCount++;
            }

            if( (wSlashCount == 2 ) ) // two back slashes are present
            {
                StringCopy( wszActualComputerName, wszComputerName, SIZE_OF_ARRAY(wszActualComputerName) );
            }
            else if ( wSlashCount == 0 )
            {
                //Append "\\" to computer name
                StringConcat(wszActualComputerName, wszComputerName, 2 * MAX_RES_STRING);
            }
        }

        
        
        DWORD cbSid = 0;
        DWORD cbDomainName = 0;
        LPWSTR szDomain = NULL;
        WCHAR szUser[MAX_RES_STRING+5];
        SID_NAME_USE peUse;
        PSID pSid = NULL;
        DWORD dwUserLength = 0;
        BOOL bResult = FALSE;
        
        dwUserLength = MAX_RES_STRING + 5;

        SecureZeroMemory (szUser, SIZE_OF_ARRAY(szUser));

        if ( StringLength (szUserName, 0) == 0 )
        {
            if(FALSE == GetUserName ( szUser, &dwUserLength ))
            {
                SaveLastError();
                return FALSE;
            }
                
            szUserName = szUser;

        }



#ifdef _WIN64
    INT64 dwPos ;
#else
    DWORD dwPos ;
#endif

        pszStopStr = StrRChrI( (LPCWSTR)szUserName, NULL, L'\\' );
        
        if ( NULL != pszStopStr )
        {
            pszStopStr++;
            szUserName = pszStopStr;
        }

        //
        // Get the actual size of domain name and SID
        // 
        bResult = LookupAccountName( szServer, szUserName, pSid, &cbSid, szDomain, &cbDomainName, &peUse );

       
        // API should have failed with insufficient buffer.

        // allocate the buffer with the actual size
        pSid =  (PSID) AllocateMemory( cbSid );
        if ( pSid == NULL )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        // allocate the buffer with the actual size
        szDomain = (LPWSTR) AllocateMemory(cbDomainName*sizeof(WCHAR));

        if(NULL == szDomain)
        {
          SaveLastError();
          FreeMemory((LPVOID*) &pSid);
          return FALSE;
        }

        //Retrieve SID and Domain name for a specified computer and account names
        if ( FALSE == LookupAccountName( szServer, szUserName, pSid, &cbSid, szDomain, &cbDomainName, &peUse ) )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
			FreeMemory((LPVOID*) &pSid);
			FreeMemory((LPVOID*) &szDomain);
            return FALSE;
        }

        
        // Get SID string for a specified username
        if ( FALSE == GetSidString ( pSid, wszSid ) )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
			FreeMemory((LPVOID*) &pSid);
			FreeMemory((LPVOID*) &szDomain);
            return FALSE;
        }

		//release memory
		FreeMemory((LPVOID*) &pSid);
		FreeMemory((LPVOID*) &szDomain);

        // form the registry path to get the value for policy
        StringCopy ( wszBuffer, wszSid, SIZE_OF_ARRAY(wszBuffer));
        StringConcat ( wszBuffer, L"\\", SIZE_OF_ARRAY(wszBuffer));
        StringConcat ( wszBuffer, TS_KEYPOLICY_BASE, SIZE_OF_ARRAY(wszBuffer));


        //
        // Connect to the remote machine
        //

        // connect to HKEY_LOCAL_MACHINE on remote machine
        lResult = RegConnectRegistry( wszActualComputerName, HKEY_LOCAL_MACHINE, &hLMKey );
        if ( ERROR_SUCCESS != lResult )
        {
            SaveLastError();
            return FALSE;
        }

        
        // connect to HKEY_USERS on remote machine
        lResult = RegConnectRegistry( wszActualComputerName, HKEY_USERS, &hUKey );
        if ( ERROR_SUCCESS != lResult )
        {
            SaveLastError();
            return FALSE;
        }


        // check for NULL
        if (NULL != hLMKey )
        {
            //
            // Open the registry key
            //
            lResult = RegOpenKeyEx( hLMKey, 
                TS_KEYPOLICY_BASE, 0, KEY_READ, &hPolicyKey );
            if ( NULL == hPolicyKey && NULL != hUKey)
            {
                lResult = RegOpenKeyEx( hUKey, 
                wszBuffer, 0, KEY_READ, &hPolicyKey );
            }
        }

        // Get the value of a policy in the registry
        if ( ( NULL != hPolicyKey ) && (FALSE == GetPolicyValue (hPolicyKey, szPolicyType, &dwPolicy) ) )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            
            if ( NULL != hPolicyKey )
            {
                RegCloseKey (hPolicyKey);
                hPolicyKey = NULL;
            }

            if ( NULL != hLMKey )
            {
                RegCloseKey (hLMKey);
                hLMKey = NULL;
            }
            
            if ( NULL != hUKey )
            {
                RegCloseKey (hUKey);
                hUKey = NULL;
            }
            
            return FALSE;
        }

        // release all the keys
        if ( NULL != hPolicyKey )
        {
            RegCloseKey (hPolicyKey);
            hPolicyKey = NULL;
        }
        
        if ( NULL != hLMKey )
        {
            RegCloseKey (hLMKey);
            hLMKey = NULL;
        }
        
        if ( NULL != hUKey )
        {
            RegCloseKey (hUKey);
            hUKey = NULL;
        }       
            
      }
    else
    {
        //
        // Open the registry key for HKEY_LOCAL_MACHINE
        //
       
        lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                        TS_KEYPOLICY_BASE, 0, KEY_READ, &hKey );

        if( lResult != ERROR_SUCCESS)
        {
            // check the keyvalue
            if ( NULL == hKey )
            {
                 //
                // Open the registry key for HKEY_CURRENT_USER
                //
                lResult = RegOpenKeyEx( HKEY_CURRENT_USER, 
                        TS_KEYPOLICY_BASE, 0, KEY_READ, &hKey );
            }
        }

        // Get the value of a policy in the registry
        if ( ( NULL != hKey ) && (FALSE == GetPolicyValue (hKey, szPolicyType, &dwPolicy) ))
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            
			// release the resource 
			if ( NULL != hKey )
			{
				RegCloseKey (hKey);
			}

			return FALSE;
        }

        // check for NULL 
        if ( NULL != hKey )
        {
            RegCloseKey (hKey);
        }
    }

    // assign the value
    *lpdwPolicy = dwPolicy;

    // return success
    return TRUE;
}


BOOL
GetPolicyValue( 
                IN HKEY hKey, 
                IN LPWSTR szPolicyType, 
                OUT LPDWORD lpdwPolicy 
                )
/*++
    Routine Description:

        This function gets the value of a group policy in the registry 
        for a given Register Key

    Arguments:

        [ in ] hKey : Register Key
        [ in ] szPolicyType   : Policy Type
        [ out ] lpdwPolicy   : Value of the policy

    Return Value :
        BOOL

--*/
{

    // sub-variables
    LONG  lResult = 0;
    DWORD dwLength = 0;
    LPBYTE pByteData = NULL;
    DWORD dwType = 0;

    // get the size of the buffer to hold the value associated with the value name
    lResult = RegQueryValueEx( hKey, szPolicyType, NULL, NULL, NULL, &dwLength );
    
    // allocate the buffer
    pByteData = (LPBYTE) AllocateMemory( (dwLength + 10) * sizeof( BYTE ) );
    if ( pByteData == NULL )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    // now get the data
    lResult = RegQueryValueEx( hKey, szPolicyType, NULL, &dwType, pByteData, &dwLength );
    
    *lpdwPolicy = *((DWORD*) pByteData);

    FreeMemory( (LPVOID*) &pByteData );

    return TRUE;
}


BOOL
GetSidString (
              IN PSID pSid, 
              OUT LPWSTR wszSid
              )
/*++
   Routine Description:
    This function gets the SID string.

   Arguments:
          [IN] PSID pSid  : SID structure
          [OUT] LPWSTR wszSid  : Stores SID string

   Return Value:
         TRUE  On success
         FALSE On failure
--*/
{

    // sub-local variables
   PSID_IDENTIFIER_AUTHORITY  Auth ;
   PUCHAR                     lpNbSubAuth ;
   LPDWORD                    lpSubAuth = 0 ;
   UCHAR                      uloop ;
   WCHAR                     wszTmp[MAX_RES_STRING] ;
   WCHAR                     wszStr[ MAX_RES_STRING ] ;

   // initialize the variables
   SecureZeroMemory ( wszTmp, SIZE_OF_ARRAY(wszTmp) );
   SecureZeroMemory ( wszStr, SIZE_OF_ARRAY(wszStr) );

   //Add the revision
   StringCopy ( wszStr, SID_STRING, MAX_RES_STRING );

   //Get identifier authority
   Auth = GetSidIdentifierAuthority ( pSid ) ;

   if ( NULL == Auth )
   {
       SaveLastError();
       return FALSE ;
   }

    // format authority value
   if ( (Auth->Value[0] != 0) || (Auth->Value[1] != 0) ) {
      StringCchPrintf ( wszTmp, SIZE_OF_ARRAY(wszTmp), AUTH_FORMAT_STR1 ,
                 (ULONG)Auth->Value[0],
                 (ULONG)Auth->Value[1],
                 (ULONG)Auth->Value[2],
                 (ULONG)Auth->Value[3],
                 (ULONG)Auth->Value[4],
                 (ULONG)Auth->Value[5] );
    }
    else {
      StringCchPrintf ( wszTmp, SIZE_OF_ARRAY(wszTmp), AUTH_FORMAT_STR2 ,
                 (ULONG)(Auth->Value[5]      )   +
                 (ULONG)(Auth->Value[4] <<  8)   +
                 (ULONG)(Auth->Value[3] << 16)   +
                 (ULONG)(Auth->Value[2] << 24)   );
    }

   StringConcat (wszStr, DASH , SIZE_OF_ARRAY(wszStr));
   StringConcat (wszStr, wszTmp, SIZE_OF_ARRAY(wszStr));

   //Get sub authorities
   lpNbSubAuth = GetSidSubAuthorityCount ( pSid ) ;

   if ( NULL == lpNbSubAuth )
   {
       SaveLastError();
       return FALSE ;
   }

   // loop through and get sub authority
   for ( uloop = 0 ; uloop < *lpNbSubAuth ; uloop++ ) {
      lpSubAuth = GetSidSubAuthority ( pSid,(DWORD)uloop ) ;
       if ( NULL == lpSubAuth )
       {
         SaveLastError();
         return FALSE;
       }

      // convert long integer to a string
      _ultot (*lpSubAuth, wszTmp, BASE_TEN) ;
      StringConcat ( wszStr, DASH, SIZE_OF_ARRAY(wszStr) ) ;
      StringConcat (wszStr, wszTmp, SIZE_OF_ARRAY(wszStr) ) ;
   }

   StringCopy ( wszSid, wszStr, MAX_RES_STRING );

   // retunr success
   return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scriptpw\password.cpp ===
// Password.cpp : Implementation of CPassword
#include "stdafx.h"
#include "ScriptPW.h"
#include "Password.h"

/////////////////////////////////////////////////////////////////////////////
// CPassword

STDMETHODIMP CPassword::GetPassword( BSTR *bstrOutPassword )
{
    // local variables
    WCHAR wch;
    DWORD dwIndex = 0;
    DWORD dwCharsRead = 0;
    DWORD dwPrevConsoleMode = 0;
    HANDLE hInputConsole = NULL;
    BOOL bIndirectionInput  = FALSE;
    LPWSTR pwszPassword = NULL;
    const DWORD dwMaxPasswordSize = 256;

    // check the input
    if ( bstrOutPassword == NULL )
    {
        return E_FAIL;
    }

    // get the handle for the standard input
    hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
    if ( hInputConsole == NULL )
    {
        // could not get the handle so return failure
        return E_FAIL;
    }

    // check for the input redirection on console and telnet session
    if( ( hInputConsole != (HANDLE)0x0000000F ) &&
        ( hInputConsole != (HANDLE)0x00000003 ) &&
        ( hInputConsole != INVALID_HANDLE_VALUE ) )
    {
        bIndirectionInput   = TRUE;
    }

    // change the console mode properties if the input is not redirected
    if ( bIndirectionInput  == FALSE )
    {
        // Get the current input mode of the input buffer
        GetConsoleMode( hInputConsole, &dwPrevConsoleMode );

        // Set the mode such that the control keys are processed by the system
        if ( SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) == 0 )
        {
            // could not set the mode, return failure
            return E_FAIL;
        }
    }

    // allocate memory for the password buffer
    pwszPassword = (LPWSTR) AllocateMemory( (dwMaxPasswordSize + 1) * sizeof( WCHAR ) );
    if ( pwszPassword == NULL )
    {
        return E_FAIL;
    }


    //  Read the characters until a carriage return is hit
    for( ;; )
    {
        if ( bIndirectionInput == TRUE )
        {
            //read the contents of file
            if ( ReadFile( hInputConsole, &wch, 1, &dwCharsRead, NULL ) == FALSE )
            {
                FreeMemory( (LPVOID*) &pwszPassword );
                return E_FAIL;
            }

            // check for end of file
            if ( dwCharsRead == 0 )
            {
                break;
            }
        }
        else
        {
            if ( ReadConsole( hInputConsole, &wch, 1, &dwCharsRead, NULL ) == 0 )
            {
                // Set the original console settings
                SetConsoleMode( hInputConsole, dwPrevConsoleMode );

                // return failure
                FreeMemory( (LPVOID*) &pwszPassword );
                return E_FAIL;
            }
        }

        // Check for carraige return
        if ( wch == CARRIAGE_RETURN )
        {
            // break from the loop
            break;
        }

        // Check id back space is hit
        if ( wch == BACK_SPACE )
        {
            if ( dwIndex != 0 )
            {
                //
                // Remove a asterix from the console
                // (display of characters onto console is blocked)

                // move the cursor one character back
                // StringCchPrintfW(
                //     wszBuffer,
                //     SIZE_OF_ARRAY( wszBuffer ), L"%c", BACK_SPACE );
                // WriteConsole(
                //     GetStdHandle( STD_OUTPUT_HANDLE ),
                //     wszBuffer, 1, &dwCharsWritten, NULL );

                // replace the existing character with space
                // StringCchPrintfW(
                //     wszBuffer,
                //     SIZE_OF_ARRAY( wszBuffer ), L"%c", BLANK_CHAR );
                // WriteConsole(
                //     GetStdHandle( STD_OUTPUT_HANDLE ),
                //     wszBuffer, 1, &dwCharsWritten, NULL );

                // now set the cursor at back position
                // StringCchPrintfW(
                //     wszBuffer,
                //     SIZE_OF_ARRAY( wszBuffer ), L"%c", BACK_SPACE );
                // WriteConsole(
                //     GetStdHandle( STD_OUTPUT_HANDLE ),
                //     wszBuffer, 1, &dwCharsWritten, NULL );

                // decrement the index
                dwIndex--;
            }

            // process the next character
            continue;
        }

        // if the max password length has been reached then sound a beep
        if ( dwIndex == ( dwMaxPasswordSize - 1 ) )
        {
            // WriteConsole(
            //     GetStdHandle( STD_OUTPUT_HANDLE ),
            //     BEEP_SOUND, 1, &dwCharsWritten, NULL );
        }
        else
        {
            // check for new line character
            if ( wch != L'\n' )
            {
                // store the input character
                *( pwszPassword + dwIndex ) = wch;
                dwIndex++;

                // display asterix onto the console
                // WriteConsole(
                //     GetStdHandle( STD_OUTPUT_HANDLE ),
                //     ASTERIX, 1, &dwCharsWritten, NULL );
            }
        }
    }

    // Add the NULL terminator
    *( pwszPassword + dwIndex ) = cwchNullChar;

    // display the character ( new line character )
    // StringCopy( wszBuffer, L"\n\n", SIZE_OF_ARRAY( wszBuffer ) );
    // WriteConsole(
    //     GetStdHandle( STD_OUTPUT_HANDLE ),
    //     wszBuffer, 2, &dwCharsWritten, NULL );

	CComBSTR bstrPassword( pwszPassword );
	*bstrOutPassword = bstrPassword.Copy();

    // set the original console settings
    SetConsoleMode( hInputConsole, dwPrevConsoleMode );

	// free the memory
    FreeMemory( (LPVOID*) &pwszPassword );

    // return success
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scriptpw\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CBE0A547_8DA2_4974_82A0_E68E9186DA77__INCLUDED_)
#define AFX_STDAFX_H__CBE0A547_8DA2_4974_82A0_E68E9186DA77__INCLUDED_

#define STRICT
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <cmdline.h>
#include <strsafe.h>

#endif // !defined(AFX_STDAFX_H__CBE0A547_8DA2_4974_82A0_E68E9186DA77__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scriptpw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScriptPW.rc
//
#define IDS_PROJNAME                    100
#define IDR_PASSWORD                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scriptpw\password.h ===
// Password.h : Declaration of the CPassword

#ifndef __PASSWORD_H_
#define __PASSWORD_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPassword
class ATL_NO_VTABLE CPassword : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPassword, &CLSID_Password>,
	public IDispatchImpl<IPassword, &IID_IPassword, &LIBID_SCRIPTPWLib>
{
public:
	CPassword()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PASSWORD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPassword)
	COM_INTERFACE_ENTRY(IPassword)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IPassword
public:
	STDMETHOD(GetPassword)(/*[out, retval]*/ BSTR *bstrOutPassword);
};

#endif //__PASSWORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scriptpw\scriptpw.cpp ===
// ScriptPW.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ScriptPWps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ScriptPW.h"

#include "ScriptPW_i.c"
#include "Password.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Password, CPassword)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SCRIPTPWLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scrptutl\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( ScriptingUtils )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( ScriptingUtils ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scrptutl\datetimeobject.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  
//  Module Name:
//  
// 	  DateTimeObject.cpp
//  
//  Abstract:
//  
// 	  This component is required by VB Scripts to get date and time in various calenders.
// 	
//  Author:
//  
// 	  Bala Neerumalla (a-balnee@microsoft.com) 31-July-2001
//  
//  Revision History:
//  
// 	  Bala Neerumalla (a-balnee@microsoft.com) 31-July-2001 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "ScriptingUtils.h"
#include "DateTimeObject.h"

/////////////////////////////////////////////////////////////////////////////
// CDateTimeObject

// ***************************************************************************
// Routine Description:
//		This the entry point to this utility.
//		  
// Arguments:
//		[ in ] bstrInDateTime	: argument containing the date and time in 
//								  YYYYMMDDHHMMSS.MMMMMM format
//		[ out ] pVarDateTime	: argument returning date and time in Locale 
//								  specific format
//  
// Return Value:
//		This functin returns S_FALSE if any errors occur else returns S_OK.
// ***************************************************************************

STDMETHODIMP CDateTimeObject::GetDateAndTime(BSTR bstrInDateTime, VARIANT *pVarDateTime)
{
	DWORD dwCount = 0;
	BOOL bLocaleChanged = FALSE;
	SYSTEMTIME systime;
	CHString strDate,strTime;
	LCID lcid;

	try
	{
		lcid = GetSupportedUserLocale(bLocaleChanged);
		systime = GetDateTime(bstrInDateTime);

		dwCount = GetDateFormat( lcid, 0, &systime, 
				((bLocaleChanged == TRUE) ? _T("MM/dd/yyyy") : NULL), NULL, 0 );

		// get the required buffer
		LPWSTR pwszTemp = NULL;
		pwszTemp = strDate.GetBufferSetLength( dwCount + 1 );

		// now format the date
		GetDateFormat( lcid, 0, &systime, 
				(LPTSTR)((bLocaleChanged == TRUE) ? _T("MM/dd/yyyy") : NULL), pwszTemp, dwCount );

		// release the buffer3
		strDate.ReleaseBuffer();
		
		// get the formatted time
		// get the size of buffer that is needed
		
		dwCount = 0;
		dwCount = GetTimeFormat( lcid, 0, &systime, 
			((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), NULL, 0 );

		// get the required buffer
		pwszTemp = NULL;
		pwszTemp = strTime.GetBufferSetLength( dwCount + 1 );

		// now format the date
		GetTimeFormat( lcid, 0, &systime, 
				((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), pwszTemp, dwCount );

		// release the buffer
		strTime.ReleaseBuffer();


		// Initialize the Out Variant.
		VariantInit(pVarDateTime);
		pVarDateTime->vt = VT_BSTR;


		// Put it in the out parameter.
		pVarDateTime->bstrVal = SysAllocString((LPCWSTR)(strDate + L" " + strTime));
	}
	catch( ... )
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		This function returns LCID of the current USer Locale. If the User locale 
//		is not a supported one, it would return LCID of English language.
//		  
// Arguments:
//		[ out ] bLocaleChanged	: argument returning whether the user locale is
//								  changed or not.
//  
// Return Value:
//		This function returns LCID of the User Locale.
// ***************************************************************************

LCID CDateTimeObject::GetSupportedUserLocale( BOOL& bLocaleChanged )
{
	// local variables
    LCID lcid;

	// get the current locale
	lcid = GetUserDefaultLCID();

	// check whether the current locale is supported by our tool or not
	// if not change the locale to the english which is our default locale
	bLocaleChanged = FALSE;
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
		bLocaleChanged = TRUE;
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

	// return the locale
    return lcid;
}

// ***************************************************************************
// Routine Description:
//		This function extracts the date and time fields from a string.
//		  
// Arguments:
//		[ in ] strTime	: string containing the date and time in the format
//						  YYYYMMDDHHMMSS.MMMMMM.
//  
// Return Value:
//		returns SYSTEMTIME structure containing the date & time info present in
//		strTime.
// ***************************************************************************

SYSTEMTIME CDateTimeObject::GetDateTime(CHString strTime)
{
	SYSTEMTIME systime;

	systime.wYear = (WORD) _ttoi( strTime.Left( 4 ));
	systime.wMonth = (WORD) _ttoi( strTime.Mid( 4, 2 ));
	systime.wDayOfWeek = 0;
	systime.wDay = (WORD) _ttoi( strTime.Mid( 6, 2 ));
	systime.wHour = (WORD) _ttoi( strTime.Mid( 8, 2 ));
	systime.wMinute = (WORD) _ttoi( strTime.Mid( 10, 2 ));
	systime.wSecond = (WORD) _ttoi( strTime.Mid( 12, 2 ));
	systime.wMilliseconds = (WORD) _ttoi( strTime.Mid( 15, 6 ));
	
	return systime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scrptutl\datetimeobject.h ===
// DateTimeObject.h : Declaration of the CDateTimeObject

#ifndef __DATETIMEOBJECT_H_
#define __DATETIMEOBJECT_H_

#include "resource.h"       // main symbols
#include <windows.h>
#include <Chstring.h>

/////////////////////////////////////////////////////////////////////////////
// CDateTimeObject
class ATL_NO_VTABLE CDateTimeObject : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDateTimeObject, &CLSID_DateTimeObject>,
	public IDispatchImpl<IDateTimeObject, &IID_IDateTimeObject, &LIBID_SCRIPTINGUTILSLib>
{
public:
	CDateTimeObject()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DATETIMEOBJECT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDateTimeObject)
	COM_INTERFACE_ENTRY(IDateTimeObject)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDateTimeObject
public:
	STDMETHOD(GetDateAndTime)(BSTR bstrInDateTime, VARIANT* pVarDateTime);
private:
	LCID GetSupportedUserLocale( BOOL& bLocaleChanged ) ;
	SYSTEMTIME GetDateTime(CHString strTime) ;

};

#endif //__DATETIMEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scrptutl\pch.h ===
// PCH.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_PCH_H__8D74987A_3855_4745_A1FE_71ED45DCDEAF__INCLUDED_)
#define AFX_PCH_H__8D74987A_3855_4745_A1FE_71ED45DCDEAF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PCH_H__8D74987A_3855_4745_A1FE_71ED45DCDEAF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scrptutl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScriptingUtils.rc
//
#define IDS_PROJNAME                    100
#define IDR_DATETIMEOBJECT              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\scrptutl\scriptingutils.cpp ===
// ScriptingUtils.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ScriptingUtilsps.mk in the project directory.

#include "pch.h"
#include "resource.h"
#include <initguid.h>
#include "ScriptingUtils.h"

#include "ScriptingUtils_i.c"
#include "DateTimeObject.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DateTimeObject, CDateTimeObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SCRIPTINGUTILSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\setx\resource.h ===
#define IDS_SETX_HELP_BEGIN    2000
#define IDS_SETX_HELP_1        2001
#define IDS_SETX_HELP_2        2002
#define IDS_SETX_HELP_3        2003
#define IDS_SETX_HELP_4        2004
#define IDS_SETX_HELP_5        2005
#define IDS_SETX_HELP_6        2006
#define IDS_SETX_HELP_7        2007
#define IDS_SETX_HELP_8        2008
#define IDS_SETX_HELP_9        2009
#define IDS_SETX_HELP_10       2010
#define IDS_SETX_HELP_11       2011
#define IDS_SETX_HELP_12       2012
#define IDS_SETX_HELP_13       2013
#define IDS_SETX_HELP_14       2014
#define IDS_SETX_HELP_15       2015
#define IDS_SETX_HELP_16       2016
#define IDS_SETX_HELP_17       2017
#define IDS_SETX_HELP_18       2018
#define IDS_SETX_HELP_19       2019
#define IDS_SETX_HELP_20       2020
#define IDS_SETX_HELP_21       2021
#define IDS_SETX_HELP_22       2022
#define IDS_SETX_HELP_23       2023
#define IDS_SETX_HELP_24       2024
#define IDS_SETX_HELP_25       2025
#define IDS_SETX_HELP_26       2026
#define IDS_SETX_HELP_27       2027
#define IDS_SETX_HELP_28       2028
#define IDS_SETX_HELP_29       2029
#define IDS_SETX_HELP_30       2030
#define IDS_SETX_HELP_31       2031
#define IDS_SETX_HELP_32       2032
#define IDS_SETX_HELP_33       2033
#define IDS_SETX_HELP_34       2034
#define IDS_SETX_HELP_35       2035
#define IDS_SETX_HELP_36       2036
#define IDS_SETX_HELP_37       2037
#define IDS_SETX_HELP_38       2038
#define IDS_SETX_HELP_39       2039
#define IDS_SETX_HELP_40       2040
#define IDS_SETX_HELP_41       2041
#define IDS_SETX_HELP_42       2042
#define IDS_SETX_HELP_43       2043
#define IDS_SETX_HELP_44       2044
#define IDS_SETX_HELP_45       2045
#define IDS_SETX_HELP_46       2046
#define IDS_SETX_HELP_47       2047
#define IDS_SETX_HELP_48       2048
#define IDS_SETX_HELP_49       2049
#define IDS_SETX_HELP_50       2050
#define IDS_SETX_HELP_51       2051
#define IDS_SETX_HELP_52       2052
#define IDS_SETX_HELP_53       2053
#define IDS_SETX_HELP_54       2054
#define IDS_SETX_HELP_55       2055
#define IDS_SETX_HELP_56       2056
#define IDS_SETX_HELP_57       2057
#define IDS_SETX_HELP_58       2058
#define IDS_SETX_HELP_59       2059
#define IDS_SETX_HELP_60       2060
#define IDS_SETX_HELP_61       2061
#define IDS_SETX_HELP_62       2062
#define IDS_SETX_HELP_63       2063
#define IDS_SETX_HELP_64       2064
#define IDS_SETX_HELP_65       2065
#define IDS_SETX_HELP_66       2066
#define IDS_SETX_HELP_67       2067
#define IDS_SETX_HELP_68       2068
#define IDS_SETX_HELP_69       2069
#define IDS_SETX_HELP_70       2070
#define IDS_SETX_HELP_71       2071
#define IDS_SETX_HELP_72       2072
#define IDS_SETX_HELP_73       2073
#define IDS_SETX_HELP_74       2074
#define IDS_SETX_HELP_75       2075
#define IDS_SETX_HELP_76       2076
#define IDS_SETX_HELP_77       2077
#define IDS_SETX_HELP_78       2078
#define IDS_SETX_HELP_79       2079
#define IDS_SETX_HELP_80       2080
#define IDS_SETX_HELP_81       2081
#define IDS_SETX_HELP_82       2082
#define IDS_SETX_HELP_83       2083
#define IDS_SETX_HELP_84       2084
#define IDS_SETX_HELP_85       2085
#define IDS_SETX_HELP_86       2086
#define IDS_SETX_HELP_87       2087
#define IDS_SETX_HELP_88       2088
#define IDS_SETX_HELP_89       2089
#define IDS_SETX_HELP_90       2090
#define IDS_SETX_HELP_91       2091
#define IDS_SETX_HELP_92       2092
#define IDS_SETX_HELP_93       2093
#define IDS_SETX_HELP_94       2094
#define IDS_SETX_HELP_95       2095
#define IDS_SETX_HELP_96       2096
#define IDS_SETX_HELP_97       2097
#define IDS_SETX_HELP_98       2098
#define IDS_SETX_HELP_99       2099
#define IDS_SETX_HELP_100      2100
#define IDS_SETX_HELP_101      2101
#define IDS_SETX_HELP_102      2102
#define IDS_SETX_HELP_103      2103
#define IDS_SETX_HELP_104      2104
#define IDS_SETX_HELP_105      2105
#define IDS_SETX_HELP_106      2106
#define IDS_SETX_HELP_107      2107

#define IDS_SETX_HELP_END      2108

#define IDS_ERROR_SYNTAX                501
#define IDS_ERROR_FILE_NOT_FOUND        502
#define IDS_ERROR_PATH_NOT_FOUND        503
#define IDS_ERROR_ACCESS_DENIED         504
#define IDS_ERROR_INVALID_HANDLE        505
#define IDS_ERROR_NOT_ENOUGH_MEMORY     506
#define IDS_ERROR_BAD_ENVIRONMENT       507
#define IDS_ERROR_INVALID_ACCESS        508
#define IDS_ERROR_INVALID_DATA          509
#define IDS_ERROR_INVALID_DRIVE         510
#define IDS_REGDB_E_READREGDB           511
#define IDS_REGDB_E_WRITEREGDB          512
#define IDS_REGDB_E_KEYMISSING          513
#define IDS_ERROR_5010                  514
#define IDS_ERROR_5011                  515
#define IDS_ERROR_5012                  516
#define IDS_ERROR_5013                  517
#define IDS_ERROR_5014                  518
#define IDS_ERROR_5015                  519
#define IDS_ERROR_5016                  520
#define IDS_ERROR_5017                  521
#define IDS_ERROR_5020                  522
#define IDS_ERROR_5030                  523
#define IDS_ERROR_5031                  524
#define IDS_ERROR_5032                  525
#define IDS_ERROR_5040                  526
#define IDS_ERROR_5041                  527
#define IDS_ERROR_5042                  528
#define IDS_ERROR_DEFAULT               529
#define IDS_NULL_SERVER                 530
#define IDS_NULL_USER                   531
#define IDS_NULL_FILE                   532
#define IDS_VALUE                       533

#define IDS_USER_BUT_NOMACHINE          535
#define IDS_PASSWD_BUT_NOUSER           536
#define IDS_SETX_SYNTAX                 537
#define IDS_INVALID_ARG                 538
#define IDS_REGVALUE_ZERO               539
#define IDS_REGVALUE_SPECIFIED          540
#define IDS_ERROR_INVALIDCOORDINATES    541
#define IDS_ERROR_5018                  542

#define IDS_NULL_REGISTRY               544
#define IDS_WARNING_LENGTH_EXCEED       545
#define IDS_WARNING_LENGTH_EXCEED_EX    546
#define IDS_ERROR_CMDPARSER_LENGTH      547
#define IDS_NULL_REGISTRY_VALUE         548
#define IDS_NULL_ABSOLUTE_VALUE         549
#define IDS_NULL_RELATIVE_VALUE         550
#define IDS_INVALID_ABS_NEG             551



#define IDS_VALUE_UPDATED               601

#define IDS_VALUE2                      602
#define IDS_INVALID_LENGTH              603

#define IDS_IGNORE_LOCALCREDENTIALS     604
#define IDS_VALUE_UPDATED2              605
#define IDS_ERROR_SEARCH_STRING         606
#define IDS_MAX_COORDINATES             607
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\setx\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

//
// public Windows header files
//

#define CMDLINE_VERSION         200

#include <windows.h>
#include <shlwapi.h>
#include <wtypes.h>
#include <winuser.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <direct.h>
#include <io.h>
#include <TCHAR.H>
#include <malloc.h>
#include "resource.h"
#include <strsafe.h>

//
// public C header files
//
#include <stdio.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\setx\setx.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    SetX.h

Abstract:

    This module is the header  file used for setx.cpp

Author:
     Gary Milne

Revision History:
    Created ????. 1996  - Gary Milne
    #54581  Dec.  1996  - Joe Hughes (a-josehu)
    Modified on 10-7-2001 (Wipro Technologies) .

--*/


#ifndef __SETX_H
#define __SETX_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once
#include "pch.h"

#define FAILURE 1
#define SUCCESS 0
#define TOKEN_BACKSLASH  L"\\"
#define TOKEN_BACKSLASH2 L"\\\\"

#define  HKEYLOCALMACHINE   L"HKEY_LOCAL_MACHINE"
#define  HKLM               L"HKLM"
#define  HKEYCURRENTUSER    L"HKEY_CURRENT_USER"
#define  HKCU               L"HKCU"

#define COLON_SYMBOL L":"
//#define MAX_OPTIONS 12
#define NEWLINE  L'\n'
#define NULLCHAR  L'\0'
#define COMMA  L','
#define DOT    L"."
#define HYPHEN L'-'
#define PLUS   L'+'
#define  OPTION_USAGE    0
#define  OPTION_SERVER   1
#define  OPTION_USER     2
#define  OPTION_PASSWORD 3
#define  OPTION_MACHINE   4
#define  OPTION_REGISTRY  5
#define  OPTION_FILE      6
#define  OPTION_DEFAULT      7
//#define  OPTION_VERBOSE   8
#define  OPTION_ABS_OFFSET 8
#define  OPTION_REL_OFFSET 9
#define  OPTION_DEBUG       10
#define  OPTION_DELIMITER   11
#define  MAX_OPTIONS      12


#define ERROR_REGISTRY 99



#define BACKSLASH4      L"\\\\"
#define CHAR_TILDE      L'~'
#define CHAR_PERCENT    L'%'
#define MACHINE_KEY     L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"
#define ENVIRONMENT_KEY L"Environment"

#define NULL_U_STRING               L"\0"
#define RETVALZERO 0



#define LINE_BUFFER 5000

#define FREE_MEMORY( VARIABLE ) \
                FreeMemory(&VARIABLE); \
                1


#define ASSIGN_MEMORY( VARIABLE , TYPE , VALUE ) \
            VARIABLE = ( TYPE * ) AllocateMemory( VALUE * sizeof( TYPE ) ); \
            1

#define REALLOC_MEMORY( VARIABLE , TYPE , VALUE )  \
              ReallocateMemory( VARIABLE, VALUE * sizeof( TYPE ) ); \
              1

/* Functions definitions here */

LONG Parsekey(WCHAR * ptr,
             WCHAR * hive,
             WCHAR ** path,
             WCHAR * parameter );

LONG GetCoord(WCHAR * rcv_buffer,
              LONG * row,
              LONG * column
			  );

WCHAR * ParseLine(WCHAR *szPtr,
                  LONG* row,
                  LONG* column,
                  WCHAR szDelimiters[15],
                  WCHAR *search_string ,
                  LONG DEBUG ,
                  LONG ABS ,
                  LONG REL ,
                  LONG *record_counter ,
                  LONG *iValue ,
                  DWORD *dwFound,
                  DWORD* dwColPos,
				  BOOL bNegCoord,
				  FILE *fin) ;

VOID  DisplayHelp();

DWORD CheckKeyType( DWORD *dwType,
                    TCHAR ** buffer,
                    DWORD dwBytesRead,
                    PBOOL pbLengthExceed);

BOOL DisplayError( LONG value,
                   LPCTSTR ptr );

DWORD WriteEnv(
                LPCTSTR  szVariable,
                LPTSTR szBuffer,
                DWORD dwType ,
                LPTSTR szServer,
                DWORD MACHINE
                );

DWORD CheckPercent( TCHAR * buffer);

DWORD ReadRegValue ( PWCHAR wszHive,
                     LPCWSTR wszPath,
                     LPCWSTR wszParameter,
                     LPWSTR* wszBuffer,
                     DWORD buffsize ,
                     LPTSTR szServer,
                     PDWORD pdwBytesRead,
                     PBOOL pbLengthExceed);

DWORD ProcessOptions( IN LONG argc ,
                      IN LPCWSTR argv[] ,
                      PBOOL pbShowUsage ,
                      LPTSTR* szServer,
                      LPTSTR* szUserName,
                      LPTSTR* szPassword,
                      PBOOL pbMachine,
                      LPTSTR* szRegistry,
                    //  PBOOL pbConnFlag ,
                      LPTSTR* szDefault,
                      PBOOL pbNeedPwd,
                      LPTSTR szFile ,
                      LPTSTR szAbsolute,
                      LPTSTR szRelative,
                      PBOOL pbDebug,
                      LPTSTR* szBuffer,
                      LPTSTR szDelimiter);
                      //PDWORD pdwBufferSize);

VOID SafeCloseConnection(BOOL bConnFlag,
                         LPTSTR szServer);

BOOL ProcessUnlimitedArguments( LPCWSTR pwszOption, 
                                LPCWSTR pwszValue, 
                                LPVOID pData,
                                DWORD* pdwIncrement );

#define SIZE1 100
#define SIZE2 500
#define SIZE3 5000
#define SIZE4 15
#define SIZE5 5024
#define CHAR_BACKSLASH L'\\'

#define SPACE_CHAR L" "
#define NEW_LINE     L"\n"

#define INVALID_LENGTH 999

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\setx\setx.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    SetX.C

Abstract:

    This Utility is used to set the environment variables
    through console mode or file mode or registry mode.

Author:
     Gary Milne

Revision History:
    Created ????. 1996  - Gary Milne
    #54581  Dec.  1996  - Joe Hughes (a-josehu)
    Modified on 10-7-2001 (Wipro Technologies) .

--*/

#include "setx.h"

const WCHAR*   wszSwitchRegistry  =  L"k"  ;//SWITCH_REGISTRY

DWORD 
__cdecl _tmain(
    IN DWORD argc,
    IN WCHAR *argv[]
    )

/*++

  Routine description   : Main function which calls all the other main functions
                          depending on the option specified by the user.

  Arguments:
          [in] argc     : argument count specified at the command prompt.
          [in] argv     : arguments specified at the command prompt.

  Return Value        : DWORD
         0            : If the utility successfully performs the operation.
         1            : If the utility is unsuccessful in performing the specified
                        operation.
--*/


{

LPWSTR  buffer = NULL;
LPWSTR path = NULL;
LPWSTR szServer = NULL;
LPWSTR szUserName = NULL;
LPWSTR szPassword = NULL;
LPWSTR szRegistry = NULL;
LPWSTR szDefault = NULL;
LPWSTR RegBuffer = NULL;
LPWSTR szLine = NULL;
LPWSTR szBuffer = NULL;


WCHAR parameter[SIZE2] ;
WCHAR wszHive[SIZE2] ;
WCHAR delimiters[SIZE4 + MAX_RES_STRING] ;
WCHAR szFile[MAX_RES_STRING] ;
WCHAR szDelimiter[MAX_RES_STRING] ;
WCHAR szAbsolute[MAX_RES_STRING] ;
WCHAR szRelative[MAX_RES_STRING] ;
WCHAR szFinalPath[MAX_RES_STRING +20] ;
WCHAR szTmpServer[2*MAX_RES_STRING + 40] ;

PWCHAR pdest = NULL ;
PWCHAR pszToken = NULL;
WCHAR * wszResult = NULL ;

DWORD dwRetVal = 0 ;
DWORD dwType;
DWORD dwFound = 0 ;
DWORD dwBytesRead = 0;
DWORD dwFileSize = 0;
DWORD dwColPos = 0;

BOOL  bConnFlag = TRUE ;
BOOL bResult = FALSE ;
BOOL bNeedPwd = FALSE ;
BOOL bDebug = FALSE ;
BOOL bMachine = FALSE ;
BOOL bShowUsage = FALSE ;
BOOL bLocalFlag = FALSE ;
BOOL bLengthExceed = FALSE;
BOOL bNegCoord = FALSE;

LONG row = -1;
LONG rowtemp = -1;
LONG column = -1;
LONG columntemp = -1;
LONG DEBUG = 0;
LONG MACHINE=0;
LONG MODE = 0;
LONG ABS = -1;
LONG REL = -1;
LONG record_counter = 0;
LONG iValue = 0;

FILE *fin = NULL;       /* Pointer to FILE Information */

HANDLE    hFile;

HRESULT   hr;

    SecureZeroMemory(parameter, SIZE2 * sizeof(WCHAR));
    SecureZeroMemory(wszHive, SIZE2 * sizeof(WCHAR));
    SecureZeroMemory(delimiters, (SIZE4 + MAX_RES_STRING) * sizeof(WCHAR));
    SecureZeroMemory(szFile, MAX_RES_STRING * sizeof(WCHAR));
    SecureZeroMemory(szDelimiter, MAX_RES_STRING * sizeof(WCHAR));
    SecureZeroMemory(szAbsolute, MAX_RES_STRING * sizeof(WCHAR));
    SecureZeroMemory(szRelative, MAX_RES_STRING * sizeof(WCHAR));
    SecureZeroMemory(szFinalPath, (MAX_RES_STRING + 20) * sizeof(WCHAR));
    SecureZeroMemory(szTmpServer, (2*MAX_RES_STRING + 40) * sizeof(WCHAR));
    
    dwRetVal = ProcessOptions( argc, argv, &bShowUsage, &szServer, &szUserName, &szPassword, &bMachine, &szRegistry, 
                               &szDefault, &bNeedPwd, szFile, szAbsolute, szRelative, &bDebug, &buffer, szDelimiter); 
                               
    if(EXIT_FAILURE == dwRetVal )
    {
        
        FREE_MEMORY(szRegistry);
        FREE_MEMORY(szDefault);
        
        FREE_MEMORY(buffer);
        FREE_MEMORY(szServer);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szPassword);
        ReleaseGlobals();
        return EXIT_FAILURE ;

    }

    //Display the syntax .
    if( bShowUsage == TRUE)
    {
        DisplayHelp();
        FREE_MEMORY(szRegistry);
        FREE_MEMORY(szDefault);
        FREE_MEMORY(buffer);
        FREE_MEMORY(szServer);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szPassword);
        ReleaseGlobals();
        return (EXIT_SUCCESS);

    }


    //Set the Absolute Flag to True
    
    if(StringLengthW(szAbsolute, 0) != 0 )
    {
        ABS = 1;
    }

    //Set the Relative Flag to True
    
    if(StringLengthW(szRelative, 0) != 0 )
    {
        REL = 1;
    }

    //Set the Debug Flag to True
    if(TRUE == bDebug)
    {
        DEBUG = 1 ;
    }

    //Set the Machine Flag to True
    if(TRUE == bMachine)
    {
        MACHINE = 1 ;
    }

    //Set the Mode to Registry Mode.
    
    if( StringLengthW(szRegistry, 0) != 0 )
    {
        MODE=2;
    }
   else if(StringLengthW(szFile, 0) != 0) //Set the Mode to File Mode.
    {
        MODE=3;
    }
    else //Set the Mode to Normal Mode.
    {
        MODE = 1;
    }


    if(MODE==3)
    {
        if( (szFile[0] == CHAR_BACKSLASH )&&(szFile[1] == CHAR_BACKSLASH))
        {

            StringCopyW( szTmpServer, szFile, GetBufferSize(szTmpServer) / sizeof(WCHAR) );

        }
    }

    bLocalFlag = IsLocalSystem( IsUNCFormat(szServer)?szServer+2:szServer ) ;
    // Connect to the Remote System specified.

    if( StringLengthW(szServer, 0)!= 0 && (FALSE == bLocalFlag  ) )
    
    {
        //establish a connection to the Remote system specified by the user.
        bResult = EstablishConnection(szServer, (LPTSTR)szUserName, GetBufferSize(szUserName) / sizeof(WCHAR), (LPTSTR)szPassword, GetBufferSize(szPassword) / sizeof(WCHAR), bNeedPwd);

        if (bResult == FALSE)
        {
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            /*ShowMessage(stderr, GetResString(IDS_TAG_ERROR )); 
            ShowMessage(stderr, SPACE_CHAR); 
            ShowMessage(stderr, GetReason());*/
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szPassword);
            ReleaseGlobals();
            return EXIT_FAILURE ;
        }
        else
        {
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                bConnFlag = FALSE ;
                break;

            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    bConnFlag = FALSE ;
                    ShowLastErrorEx(stderr, SLE_TYPE_WARNING | SLE_SYSTEM);
                    break;
                }
             default:
                bConnFlag = TRUE;
            }
        }

        FREE_MEMORY(szPassword);

    }

    if( TRUE == bLocalFlag )
        {
            if( StringLengthW( szUserName, 0 ) != 0 )
             {
                ShowMessage(stderr, GetResString(IDS_IGNORE_LOCALCREDENTIALS) ); 
             }
        }

    /* End of parsing ARGC values */
    switch (MODE)
    {
    case 1:     /* Setting variable from the command line */
            dwType= CheckPercent ( buffer );
          
            szBuffer = AllocateMemory( 1030 * sizeof( WCHAR ) );

            if ( NULL ==  szBuffer)
            {
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();

                return FAILURE ;
            }

            if(StringLengthW(buffer, 0) > 1024)
            {
                
                StringCopyW( szBuffer, buffer, 1025 );
                ShowMessage(stderr, GetResString(IDS_WARNING_LENGTH_EXCEED_EX)); 
            }
            else
            {
                StringCopyW( szBuffer, buffer, 1030 );
            }

            if( WriteEnv( szDefault, szBuffer, dwType,IsUNCFormat(szServer)?szServer+2:szServer ,MACHINE ) == FAILURE)
            {
              SafeCloseConnection(bConnFlag, szServer);
               FREE_MEMORY( szBuffer );
               FREE_MEMORY( szRegistry );
               FREE_MEMORY( szDefault );
               FREE_MEMORY( buffer );
               FREE_MEMORY(szServer);
               FREE_MEMORY(szUserName);
               ReleaseGlobals();
               return FAILURE ;
            }

            FREE_MEMORY( szBuffer );
            break;

    case 2:     /* Setting the variable from a registry value */

            RegBuffer = AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );

            if(NULL == RegBuffer)
            {

                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( RegBuffer );
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }

            if( Parsekey(szRegistry, wszHive, &path, parameter ) == FAILURE)
            {
       
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( RegBuffer );
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(path);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }

            if(path == NULL)
            {
                ShowMessage(stderr, GetResString(IDS_INVALID_ARG) ); 
            }

           /* Read the value from the registry and put it in the buffer */
            dwType= ReadRegValue( wszHive, path, parameter, &RegBuffer, sizeof(RegBuffer),szServer,&dwBytesRead, &bLengthExceed);

            if(dwType == ERROR_REGISTRY)
            {
                
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( RegBuffer );
                FreeMemory(&szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(path);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }


            /* Check and see what key type is being used */
            if( CheckKeyType( &dwType, &RegBuffer, dwBytesRead, &bLengthExceed ) == FAILURE )
            {
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( RegBuffer );
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(path);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }

            /* Write the value back to the environment */
           if ( WriteEnv( szDefault, RegBuffer, dwType,IsUNCFormat(szServer)?szServer+2:szServer ,MACHINE) == FAILURE)
           {
                
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( RegBuffer );
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(path);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
           }

            break;

    case 3:     /* Setting the variable from a file  */

        /* Set the delimiters to all NULL and then copy in the built in delimiters. */

        SecureZeroMemory(delimiters, sizeof(delimiters));
        StringCopyW( delimiters, L" \n\t\r", SIZE_OF_ARRAY(delimiters) );

        if (DEBUG)
        {
            row=9999999;
            column=9999999;
        }

        /* Start testing integrity of the command line parameters for acceptable values */
        /* Make sure that we got a file name to work with */

        if(StringLengthW(szFile, 0) == 0 )
        {
            DisplayError(5031, NULL );
            
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            ReleaseGlobals();
            return FAILURE ;

        }

        /* Extract the coordinates and convert them to integers */
        if( (ABS != -1) && !DEBUG )
        {
            if ( FAILURE == GetCoord(szAbsolute, &row, &column) )
            {
                
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;

            }
        }

        if( ( REL != -1 )&& !DEBUG )
        {
            if(FAILURE ==  GetCoord(szRelative, &row, &column))
            {
                    
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }

        }

        /* Test ROWS and COLUMNS variables.  If something did not get set
        properly it will still be -1.  If so do error and exit */
        /*if ( ( row < 0  || column < 0 ) && !DEBUG )
        {
            if(ABS)
            {
                DisplayError(5010, NULL );
            }
            else if(REL)
            {
                DisplayError(5011, NULL );
            }

            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            
            ReleaseGlobals();
            return FAILURE ;
        }*/

        /* Test for additional delimiters and append if existing */
        if (StringLengthW(szDelimiter, 0) > 0 )
        {
            if ( StringLengthW(delimiters, 0) + StringLengthW(szDelimiter, 0) >= SIZE4 + 1 ) //sizeof(delimiters) )
            {
                
                DisplayError(5020, szDelimiter );
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;

            }
            else
            {
                /* If not then append them to the built in delimiters */
                StringConcat(delimiters, szDelimiter, SIZE_OF_ARRAY(delimiters));
                StringConcat(delimiters, L'\0', SIZE_OF_ARRAY(delimiters));
            }
        }

        //copy the path into a variable
        StringCopyW( szFinalPath, szFile, SIZE_OF_ARRAY(szFinalPath) );


        //get the token upto the delimiter ":"
        pszToken = wcstok(szFinalPath, COLON_SYMBOL );

        if(NULL == pszToken)
        {
            DisplayError(5030, szFile);
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            
            ReleaseGlobals();
            return FAILURE ;
        }


         //form the string for getting the absolute path in
        if((StringLengthW(szServer, 0) != 0) && bLocalFlag == FALSE)
        {                         //the required format if it is a remote system.
                                  //
            pdest = wcsstr(szFile, COLON_SYMBOL);

            if(pdest != NULL)
            {
                _wcsnset(pdest, L'$', 1);

                if(FALSE == IsUNCFormat(szFile))
                {
                    
                    StringCopyW( szTmpServer, TOKEN_BACKSLASH2, SIZE_OF_ARRAY(szTmpServer) );
                    
                    StringConcat(szTmpServer, szServer, SIZE_OF_ARRAY(szTmpServer));
                    
                    StringConcat(szTmpServer, TOKEN_BACKSLASH, SIZE_OF_ARRAY(szTmpServer));
                    
                    StringConcat(szTmpServer, pszToken, SIZE_OF_ARRAY(szTmpServer));

                }
                else
                {
                    
                    StringCopyW( szTmpServer, pszToken, SIZE_OF_ARRAY(szTmpServer) );

                }

                StringConcat(szTmpServer, pdest, SIZE_OF_ARRAY(szTmpServer));
            }
            else
            {
                if(FALSE == IsUNCFormat(szFile))
                {
                    
                    StringCopyW( szTmpServer, TOKEN_BACKSLASH2, SIZE_OF_ARRAY(szTmpServer) );
                    
                    StringConcat(szTmpServer, szServer, SIZE_OF_ARRAY(szTmpServer));
                    
                    StringConcat(szTmpServer, TOKEN_BACKSLASH, SIZE_OF_ARRAY(szTmpServer));
                    
                    StringConcat(szTmpServer, szFile, SIZE_OF_ARRAY(szTmpServer));
                }
                else
                {
                    
                    StringCopyW( szTmpServer, szFile, SIZE_OF_ARRAY(szTmpServer) );

                }

            }
        }
        else
        {
            
            StringCopyW( szTmpServer, szFile, SIZE_OF_ARRAY(szTmpServer) );
        }


        /* Open the specified file either in Local system or Remote System.
         If it fails exit with error 5030 */


        if( (fin = _wfopen( szTmpServer, L"r" )) == NULL )
        {
            DisplayError(5030, szFile);
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            
            ReleaseGlobals();
            return FAILURE ;
        }

        hFile = CreateFile( szTmpServer, READ_CONTROL | 0, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if( INVALID_HANDLE_VALUE == hFile )
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            
            ReleaseGlobals();
            return FAILURE ;
        }

        dwFileSize = GetFileSize(hFile,NULL);

        if(-1 == dwFileSize)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            
            ReleaseGlobals();
            return FAILURE ;

        }

        /* Start of main WHILE loop: Get one line at a time from
        the file and parse it out until the specified value is found */


        
        
        szLine = AllocateMemory( (dwFileSize + 10) * sizeof( WCHAR ) );
         

        if(NULL == szLine)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            ReleaseGlobals();
            return FAILURE ;
        }

		rowtemp = row;
		columntemp = column;

		if(row < 0 || column < 0)
		{
			bNegCoord = TRUE;
		}

		if(ABS == 1 && bNegCoord == TRUE)
		{
			ShowMessage(stderr, GetResString(IDS_INVALID_ABS_NEG)); 
			SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            ReleaseGlobals();
            return FAILURE ;

		}

        if(0 != dwFileSize)
        {
            while(_fgetts( szLine, dwFileSize + 1 , fin ) != NULL )
            {
                wszResult=ParseLine(szLine, &row, &column, delimiters, buffer, DEBUG, ABS, REL, &record_counter, &iValue, &dwFound, &dwColPos, bNegCoord, fin );

                if (wszResult != 0  )
                {
                    break;
                }

                record_counter++;
            }
        }
        else
        {
            while(_fgetts( szLine, 8 + 1 , fin ) != NULL )
            {
                wszResult=ParseLine(szLine, &row, &column, delimiters, buffer, DEBUG, ABS, REL, &record_counter, &iValue, &dwFound, &dwColPos, bNegCoord, fin );

                if (wszResult != 0  )
                {
                    break;
                }

                record_counter++;
            }

        }

        if((fin != NULL) )
        {
            fclose(fin);        /* Close the previously opened file */
        }

        CloseHandle( hFile );

        if (wszResult == 0 )
        {
            /* Reached the end of the file without a match */
            

            if (GetLastError() == INVALID_LENGTH)
            {
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( szLine );
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }

            if (DEBUG)
            {
                
                ShowMessage(stdout, L"\n"); 
                DisplayError(0, NULL);          /* Just exit if we are doing debug */
                
                if(NULL != szLine )
                {
                    
                    FreeMemory(&szLine);
                }
                
                if(NULL != szRegistry )
                {
                    FreeMemory(&szRegistry);
                }
                
                
                if(NULL != szDefault )
                {
                    FreeMemory(&szDefault);
                }
                
                
                if(NULL != szDefault )
                {
                    FreeMemory(&buffer);
                }
                
                SafeCloseConnection(bConnFlag, szServer );
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return SUCCESS ;
            }

            if(NULL != buffer)
            {
                
                SecureZeroMemory(buffer, GetBufferSize(buffer));
                
                hr = StringCchPrintf(buffer, (GetBufferSize(buffer) / sizeof(WCHAR)), L"(%ld,%ld)",rowtemp,columntemp);

                if(FAILED(hr))
                {
                    SetLastError(HRESULT_CODE(hr));
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    SafeCloseConnection(bConnFlag, szServer);
                    FREE_MEMORY( szLine );
                    FREE_MEMORY(szRegistry);
                    FREE_MEMORY(szDefault);
                    FREE_MEMORY(buffer);
                    FREE_MEMORY(szServer);
                    FREE_MEMORY(szUserName);
                    ReleaseGlobals();
                    return FAILURE;
                }
  
                
            }
            else
            {
                
                buffer = AllocateMemory( (2 * MAX_RES_STRING) * sizeof( WCHAR ) );

                if ( NULL ==  buffer)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    SafeCloseConnection(bConnFlag, szServer);
                    FREE_MEMORY( szLine );
                    FREE_MEMORY(szRegistry);
                    FREE_MEMORY(szDefault);
                    FREE_MEMORY(szServer);
                    FREE_MEMORY(szUserName);
                    ReleaseGlobals();
                    return FAILURE ;
                }

                hr = StringCchPrintf(buffer, (GetBufferSize(buffer) / sizeof(WCHAR)), L"(%ld,%ld)",rowtemp,columntemp);

                if(FAILED(hr))
                {
                    SetLastError(HRESULT_CODE(hr));
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    SafeCloseConnection(bConnFlag, szServer);
                    FREE_MEMORY( szLine );
                    FREE_MEMORY(szRegistry);
                    FREE_MEMORY(szDefault);
                    FREE_MEMORY(buffer);
                    FREE_MEMORY(szServer);
                    FREE_MEMORY(szUserName);
                    ReleaseGlobals();
                    return FAILURE;
                }

            }

            if(1 == REL)
            {
                DisplayError(5012,buffer);              /* Display message that coordinates of text not found and exit.*/
            }
            else if (1 == ABS)
            {
                DisplayError(5018,buffer);
            }
            
            SafeCloseConnection(bConnFlag, szServer);
            FREE_MEMORY( szLine );
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);
            ReleaseGlobals();
            return FAILURE ;
        }
        else    /* We found a match */
        {
            dwType = REG_SZ;

            szBuffer = AllocateMemory( (1030) * sizeof( WCHAR ) );
            
            if ( NULL ==  szBuffer)
            {
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( szLine );
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }

            if(StringLengthW(wszResult, 0) > 1024)
            {
                
                StringCopyW( szBuffer, wszResult, (1025) );
                bLengthExceed = TRUE;
            }
            else
            {
                StringCopyW( szBuffer, wszResult, ( GetBufferSize(szBuffer) / sizeof(WCHAR) ) );
            }

            if(bLengthExceed == TRUE)
            {
                ShowMessage(stderr, GetResString(IDS_WARNING_LENGTH_EXCEED) ); 
            }

            ShowMessage(stdout, GetResString(IDS_VALUE2)); 
            ShowMessage(stdout, _X(szBuffer) ); 
            
            ShowMessage(stdout, L".\n" );
            
            if( WriteEnv( szDefault, szBuffer, dwType, IsUNCFormat(szServer)?szServer+2:szServer, MACHINE)== FAILURE )
            {
                SafeCloseConnection(bConnFlag, szServer);
                FREE_MEMORY( szLine );
                FREE_MEMORY( szBuffer );
                FREE_MEMORY(szRegistry);
                FREE_MEMORY(szDefault);
                FREE_MEMORY(buffer);
                FREE_MEMORY(szServer);
                FREE_MEMORY(szUserName);
                ReleaseGlobals();
                return FAILURE ;
            }

            FREE_MEMORY( szBuffer );
            FREE_MEMORY(szRegistry);
            FREE_MEMORY(szDefault);
            FREE_MEMORY(buffer);
            FREE_MEMORY(szServer);
            FREE_MEMORY(szUserName);

        }

    };

    if( TRUE == bLocalFlag ||(StringLengthW(szServer, 0)==0) )
    {
        SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0L, (LPARAM) L"Environment" );
    }

    ShowMessage(stdout, GetResString(IDS_VALUE_UPDATED) ); 
    SafeCloseConnection(bConnFlag, szServer);
    FREE_MEMORY( RegBuffer );

    FREE_MEMORY( szLine );
    FREE_MEMORY(szRegistry);

    FREE_MEMORY(szDefault);
    FREE_MEMORY(buffer);
    
    FREE_MEMORY(szServer);
    FREE_MEMORY(szUserName);
    ReleaseGlobals();
    
    exit(SUCCESS);
}


DWORD WriteEnv(
                LPCTSTR  szVariable,
                LPTSTR szBuffer,
                DWORD dwType ,
                LPTSTR szServer,
                DWORD MACHINE
                
             )
/*++

  Routine description   : Write the contents of the buffer to the parameter in the specified registry key


  Arguments:
          [in] szVariable   : argument count specified at the command prompt.
          [in] szBuffer     : arguments specified at the command prompt.
          [in] dwType       : Type .
          [in] MACHINE      : Flag indicating which environment to write into.
          [in] szServer     : Server Name

  Return Value              : NONE

--*/

{
    HKEY hKeyResult = 0;
    LONG lresult = 0 ;
    HKEY hRemoteKey = 0 ;
    LPWSTR  szSystemName = NULL;

    //Form the  system name in the appropriate format.
    if(StringLengthW(szServer, 0)!= 0)
    {
        szSystemName = AllocateMemory((StringLengthW(szServer, 0) + 10) * sizeof(WCHAR));
        if(NULL == szSystemName)
        {
           ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
           return FAILURE ;
        }
        StringCopyW( szSystemName, BACKSLASH4, GetBufferSize(szSystemName) / sizeof(WCHAR) );
        StringConcat(szSystemName, szServer, GetBufferSize(szSystemName) / sizeof(WCHAR));

    }

    switch( MACHINE )   /* If machine is 0 put into User environment */
    {
    case 0:         /* User Environment */

            lresult= RegConnectRegistry(szSystemName, HKEY_CURRENT_USER,&hRemoteKey);

            if( lresult != ERROR_SUCCESS)
            {
                DisplayError(lresult, NULL);
                FREE_MEMORY(szSystemName);
                return FAILURE ;
            }

            lresult=RegOpenKeyEx(hRemoteKey, ENVIRONMENT_KEY , 0, KEY_WRITE, &hKeyResult );

            if( ERROR_SUCCESS == lresult)
            {

                lresult=RegSetValueEx (hKeyResult, szVariable, 0, dwType, (LPBYTE)szBuffer, (StringLengthW(szBuffer, 0)+1)*sizeof(WCHAR));
                
                if(ERROR_SUCCESS != lresult)
                {

                    DisplayError(lresult, NULL);

                    
                    lresult=RegCloseKey( hRemoteKey );

                    if(ERROR_SUCCESS != lresult)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    }

                    lresult=RegCloseKey( hKeyResult );

                    if(ERROR_SUCCESS != lresult)
                    {
                          ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM); 
                    }

                    FREE_MEMORY(szSystemName);
                    return FAILURE ;

                }

                lresult=RegCloseKey( hRemoteKey );

                if(ERROR_SUCCESS != lresult)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    FREE_MEMORY(szSystemName);
                    return FAILURE ;
                }

                lresult=RegCloseKey( hKeyResult );
                if(ERROR_SUCCESS != lresult)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    FREE_MEMORY(szSystemName);
                    return FAILURE ;
                }

                FREE_MEMORY(szSystemName);
                return SUCCESS ;

            }
            else
            {
                DisplayError(lresult, NULL);

                lresult=RegCloseKey( hRemoteKey );

                if(ERROR_SUCCESS != lresult)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);

                }
                FREE_MEMORY(szSystemName);
                return FAILURE ;
            }


    case 1:     /* Machine Environment */
                lresult= RegConnectRegistry(szSystemName, HKEY_LOCAL_MACHINE,&hRemoteKey);
                if( lresult != ERROR_SUCCESS)
                {
                    DisplayError(lresult, NULL);
                    FREE_MEMORY(szSystemName);
                    return FAILURE ;

                }

                

                lresult=RegOpenKeyEx(hRemoteKey, MACHINE_KEY, 0, KEY_WRITE, &hKeyResult );
                if( lresult == ERROR_SUCCESS)
                {
                    lresult=RegSetValueEx (hKeyResult, szVariable, 0, dwType, (LPBYTE)szBuffer, (StringLengthW(szBuffer, 0) + 1)*sizeof(WCHAR));

                    if(lresult != ERROR_SUCCESS)
                    {
                        DisplayError(lresult, szVariable);
                        lresult=RegCloseKey( hRemoteKey );

                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);

                        }

                        lresult=RegCloseKey( hKeyResult );
                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        }

                        FREE_MEMORY(szSystemName);
                        return FAILURE ;
                    }

                    if ( NULL != hKeyResult )
					{
                        // we ignore the return code here
						lresult = RegCloseKey( hKeyResult );
					}

					if ( NULL != hRemoteKey )
					{
                        // we ignore the return code here
						lresult=RegCloseKey( hRemoteKey );
					}

                    FREE_MEMORY(szSystemName);
                    return SUCCESS ;

                }
                else
                {
 
                    DisplayError(lresult, NULL);

                    if ( NULL != hKeyResult )
					{
                        // we ignore the return code here
						lresult=RegCloseKey( hKeyResult );
					}

					if ( NULL != hRemoteKey )
					{
                        // we ignore the return code here
						lresult=RegCloseKey( hRemoteKey );
					}

                    FREE_MEMORY(szSystemName);
                    return FAILURE ;
                }

    };

    FREE_MEMORY(szSystemName);
    return SUCCESS ;
}


DWORD ReadRegValue( PWCHAR wszHive,
                    LPCWSTR wszPath,
                    LPCWSTR wszParameter,
                    LPWSTR* wszBuffer,
                    DWORD buffsize ,
                    LPWSTR szServer,
                    PDWORD pdwBytesRead,
                    PBOOL pbLengthExceed)

/*++

  Routine description      : Read the value from the provided registry path


  Arguments:
          [in] wszHive     : Contains the Hive to be opened.
          [in] wszPath     : Contains the Path of the key
          [in] wszParameter: Contains the Parameter
          [in] wszBuffer   : Contains the Buffer to hold the result.
          [in] buffsize    : Contains the Buffer Size to hold the result.
          [in] szServer    : Remote System Name to Connect to .
  Return Value             : 0 on Success .
                             1 on Failure.

--*/
{
    LONG reg = 0 ;
    HKEY hKeyResult = 0;
    DWORD dwBytes = 0;
    DWORD dwType  = 0 ;
    LONG  lresult;
    HKEY  hRemoteKey = 0;
    DWORD dwSizeToAllocate = 0;
    LPWSTR szSystemName = NULL;
    WCHAR szTmpBuffer[4 * MAX_RES_STRING + 9] ;
    LPWSTR  pwszChangedPath = NULL;
    HRESULT hr;

    SecureZeroMemory(szTmpBuffer, ((4 * MAX_RES_STRING) + 9) * sizeof(WCHAR));

    /* Set the value of reg to identify which registry we are using */
    
    if ((0 == StringCompare( wszHive, HKEYLOCALMACHINE, TRUE, 0 ) ) || ( 0 == StringCompare( wszHive, HKLM, TRUE, 0 ) ) )
    {
        reg = 1 ;
    }

    if (( 0 == StringCompare( wszHive, HKEYCURRENTUSER, TRUE, 0 )) || ( 0 == StringCompare( wszHive, HKCU, TRUE, 0 ) ) )
    {
        reg = 2 ;
    }

    //Form the UNC path.
    if( StringLengthW(szServer, 0) != 0)
    {
        szSystemName = AllocateMemory((StringLengthW(szServer, 0) + 10) * sizeof(WCHAR));
        if(NULL == szSystemName)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return ERROR_REGISTRY;
        }

        if(!IsUNCFormat(szServer))
        {
            StringCopyW( szSystemName, BACKSLASH4, GetBufferSize(szSystemName) / sizeof(WCHAR) );
            StringConcat(szSystemName, szServer, GetBufferSize(szSystemName) / sizeof(WCHAR) );
        }
        else
        {
            StringCopyW( szSystemName, szServer, GetBufferSize(szSystemName) / sizeof(WCHAR)  );
        }
    }

    if(StringLengthW((LPWSTR)wszParameter, 0) == 0)
    {
        wszParameter = NULL;
    }


    /* Try to extract the value based upon which registry we are using */
    switch( reg )
    {
        case 0:         // No matching key found, error and exit */

            DisplayError(5040, NULL);
            return ERROR_REGISTRY;

        case 1:         // Using Machine //

                lresult= RegConnectRegistry(szSystemName, HKEY_LOCAL_MACHINE,&hRemoteKey);

                if( lresult != ERROR_SUCCESS)
                {
                    DisplayError(lresult, NULL);
                    FREE_MEMORY(szSystemName);
                    return ERROR_REGISTRY;

                }

                FREE_MEMORY(szSystemName);

                lresult=RegOpenKeyEx(hRemoteKey, wszPath, 0, KEY_QUERY_VALUE, &hKeyResult );

                if( lresult == ERROR_SUCCESS)
                {
                    dwBytes = buffsize;
                    lresult = RegQueryValueEx   (hKeyResult, wszParameter, NULL,
                                            &dwType, NULL, &dwBytes );
                    if ( lresult != ERROR_SUCCESS )
                    {
                        lresult = RegCloseKey( hKeyResult );
                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        }

                        dwSizeToAllocate = StringLengthW((LPWSTR)wszPath, 0) + StringLengthW((LPWSTR)wszParameter, 0) + SIZE1;
                        
                        pwszChangedPath = AllocateMemory( (dwSizeToAllocate) * sizeof( WCHAR ) );


                        if ( NULL ==  pwszChangedPath)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);

                            lresult=RegCloseKey( hRemoteKey );

                            if(ERROR_SUCCESS != lresult)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                            }

                            return ERROR_REGISTRY;
                        }

                        if((NULL != wszPath) && (0 != StringLengthW((LPWSTR)wszPath, 0)))
                        {
                            StringCopyW( pwszChangedPath, wszPath, dwSizeToAllocate );
                            StringConcat(pwszChangedPath, L"\\", dwSizeToAllocate);
                            StringConcat(pwszChangedPath, wszParameter, dwSizeToAllocate);

                        }
                        else
                        {
                            if( !((0 == StringCompare( HKLM, wszParameter, TRUE, 0 )) || (0 == StringCompare( HKEYLOCALMACHINE, wszParameter, TRUE, 0 ))) )
                            {

                                StringCopyW( pwszChangedPath, wszParameter, dwSizeToAllocate );

                            }

                        }
                        wszParameter = NULL_U_STRING;

                        lresult = RegOpenKeyEx(hRemoteKey, (pwszChangedPath), 0, KEY_QUERY_VALUE, &hKeyResult );

                        if( lresult == ERROR_SUCCESS)
                        {
                            lresult = RegQueryValueEx   (hKeyResult, wszParameter, NULL,
                                        &dwType, NULL, &dwBytes );

                            if ( lresult != ERROR_SUCCESS )
                            {
                                if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                                {
                                    ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND) ); 
                                }
                                else
                                {
                                    DisplayError(lresult, NULL);
                                }

                                lresult = RegCloseKey( hRemoteKey );

                                if(ERROR_SUCCESS != lresult)
                                {
                                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                                }

                                lresult = RegCloseKey( hKeyResult );

                                if(ERROR_SUCCESS != lresult)
                                {
                                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                                }

                                FREE_MEMORY( pwszChangedPath );

                                return ERROR_REGISTRY ;
                            }

                            FREE_MEMORY( pwszChangedPath );
                        }
                     else
                        {
                            if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                            {
                                ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND)); 

                            }
                            else
                            {
                                //DisplayError(lresult, NULL);   
                                ShowMessage(stderr, GetResString(IDS_ERROR_FILE_NOT_FOUND)); 
                            }

                            lresult = RegCloseKey( hRemoteKey );

                            if(ERROR_SUCCESS != lresult)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                            }

                            FREE_MEMORY( pwszChangedPath );
                            return ERROR_REGISTRY ;
                        }

                    }

                    if(dwBytes > MAX_STRING_LENGTH)
                    {

                        if(FALSE == ReallocateMemory( wszBuffer , dwBytes * sizeof(WCHAR) ))
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            lresult = RegCloseKey( hRemoteKey );
                            lresult = RegCloseKey( hKeyResult );
                            return ERROR_REGISTRY;
                        }

                    }

                    lresult = RegQueryValueEx   (hKeyResult, wszParameter, NULL,
                                            &dwType, (LPBYTE)(*wszBuffer), &dwBytes );

                    if ( lresult != ERROR_SUCCESS )
                    {
                        if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                        {
                            ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND) ); 

                        }
                        else
                        {
                            DisplayError(lresult, NULL);
                        }

                        lresult = RegCloseKey( hRemoteKey );

                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        }

                        lresult = RegCloseKey( hKeyResult );
                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        }
                        return ERROR_REGISTRY ;
                    }

                    dwSizeToAllocate = StringLengthW(*wszBuffer, 0);
                    
                    if( dwSizeToAllocate > 1024 )
                    {
                        StringCopyW( szTmpBuffer, (*wszBuffer), 4 * MAX_RES_STRING + 9  );
                        SecureZeroMemory(*wszBuffer,dwBytes);
                        StringCopyW( *wszBuffer, szTmpBuffer, dwSizeToAllocate  );
                        *pbLengthExceed = TRUE;
                    }


                    if(REG_DWORD == dwType  )
                    {
                        if(NULL != *wszBuffer)
                        {
                            hr = StringCchPrintf(*wszBuffer, (GetBufferSize(*wszBuffer) / sizeof(WCHAR)), L"%u", *((LPDWORD)(*wszBuffer)));

                            if(FAILED(hr))
                            {
                                SetLastError(HRESULT_CODE(hr));
                                SaveLastError();
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                return ERROR_REGISTRY ;
                            }
                        }

                    }

                    lresult = RegCloseKey( hRemoteKey );

                    if(ERROR_SUCCESS != lresult)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    }

                    lresult = RegCloseKey( hKeyResult );
                    if(ERROR_SUCCESS != lresult)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        return ERROR_REGISTRY ;
                    }
                    break;
                }
                else
                {
                    if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                    {
                        ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND)); 

                    }
                    else
                    {
                        DisplayError(lresult, NULL);
                    }

                    lresult = RegCloseKey( hRemoteKey );

                    if(ERROR_SUCCESS != lresult)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    }
                    return ERROR_REGISTRY ;
                }


       case 2:      // Using User Environment//

                lresult= RegConnectRegistry(szSystemName, HKEY_CURRENT_USER,&hRemoteKey);
                if( lresult != ERROR_SUCCESS)
                {
                    DisplayError(lresult, NULL);
                    FREE_MEMORY(szSystemName);
                    return ERROR_REGISTRY ;

                }

                FREE_MEMORY(szSystemName);

                lresult=RegOpenKeyEx(hRemoteKey, (wszPath), 0, KEY_QUERY_VALUE, &hKeyResult );

                if( lresult == ERROR_SUCCESS)
                {

                    lresult=RegQueryValueEx (hKeyResult, wszParameter, NULL,
                                            &dwType, NULL, &dwBytes );
                    if ( lresult != ERROR_SUCCESS )
                    {

                        lresult=RegCloseKey( hKeyResult );

                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        }

                        dwSizeToAllocate = StringLengthW((LPWSTR)wszPath, 0) + StringLengthW((LPWSTR)wszParameter, 0) + SIZE1;
                        
                        pwszChangedPath = AllocateMemory( (dwSizeToAllocate) * sizeof( WCHAR ) );

                        if ( NULL ==  pwszChangedPath)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                            lresult=RegCloseKey( hRemoteKey );

                            if(ERROR_SUCCESS != lresult)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                            }

                            return ERROR_REGISTRY;
                        }

                        if((NULL != wszPath) && (0 != StringLengthW((LPWSTR)wszPath, 0)))
                        
                        {
                            StringCopyW( pwszChangedPath, wszPath, dwSizeToAllocate );
                            StringConcat(pwszChangedPath, wszParameter, dwSizeToAllocate);
                        }
                        else
                        {
                            if( !((0 == StringCompare( HKCU, wszParameter, TRUE, 0 )) || (0 == StringCompare( HKEYCURRENTUSER, wszParameter, TRUE, 0 ))) )
                            {

                                StringCopyW( pwszChangedPath, wszParameter, dwSizeToAllocate  );

                            }
                        }

                        wszParameter = NULL_U_STRING;

                        lresult=RegOpenKeyEx(hRemoteKey, (pwszChangedPath), 0, KEY_QUERY_VALUE, &hKeyResult );

                        if( lresult == ERROR_SUCCESS)
                        {
                            lresult=RegQueryValueEx (hKeyResult, wszParameter, NULL,
                                        &dwType, NULL, &dwBytes );

                            if ( lresult != ERROR_SUCCESS )
                            {
                                if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                                {
                                    ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND)); 
                                }
                                else
                                {
                                    DisplayError(lresult, NULL);
                                }

                                lresult = RegCloseKey( hRemoteKey );
                                if(ERROR_SUCCESS != lresult)
                                {
                                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                                }

                                lresult=RegCloseKey( hKeyResult );

                                if(ERROR_SUCCESS != lresult)
                                {
                                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                                }

                                FREE_MEMORY( pwszChangedPath );

                                return ERROR_REGISTRY ;
                            }

                            FREE_MEMORY( pwszChangedPath );
                        }
                     else
                        {
                            if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                            {
                                ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND)); 

                            }
                            else
                            {
                                //DisplayError(lresult, NULL);
                                ShowMessage(stderr, GetResString(IDS_ERROR_FILE_NOT_FOUND)); 
                            }
                            lresult = RegCloseKey( hRemoteKey );

                            if(ERROR_SUCCESS != lresult)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                            }

                            FREE_MEMORY( pwszChangedPath );

                            return ERROR_REGISTRY ;
                        }

                    }

                    if(dwBytes > MAX_STRING_LENGTH )
                    {
                        if(FALSE == ReallocateMemory( wszBuffer , dwBytes * sizeof(WCHAR) ))
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            lresult = RegCloseKey( hRemoteKey );
                            lresult = RegCloseKey( hKeyResult );
                            return ERROR_REGISTRY;
                        }
                    }

                    lresult=RegQueryValueEx (hKeyResult, wszParameter, NULL,
                                            &dwType, (LPBYTE)(*wszBuffer), &dwBytes );

                    if ( lresult != ERROR_SUCCESS )
                    {

                        if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                        {
                            ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND)); 

                        }
                        else
                        {
                            DisplayError(lresult, NULL);
                        }

                        lresult = RegCloseKey( hRemoteKey );

                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        }

                        lresult = RegCloseKey( hKeyResult );

                        if(ERROR_SUCCESS != lresult)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        }
                        return ERROR_REGISTRY ;
                    }

                    dwSizeToAllocate = StringLengthW(*wszBuffer, 0);
                    

                    if( dwSizeToAllocate > 1024 )
                    {
                        StringCopyW( szTmpBuffer, (*wszBuffer), 4 * MAX_RES_STRING + 9  );
                        
                        SecureZeroMemory(*wszBuffer, dwBytes);
                        StringCopyW( *wszBuffer, szTmpBuffer, dwSizeToAllocate  );
                        *pbLengthExceed = TRUE;
                    }

                    if(REG_DWORD == dwType  )
                    {

                        hr = StringCchPrintf(*wszBuffer, (GetBufferSize(*wszBuffer) / sizeof(WCHAR)), L"%u", *((LPDWORD)(*wszBuffer)));

                        if(FAILED(hr))
                        {
                            SetLastError(HRESULT_CODE(hr));
                            SaveLastError();
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            return ERROR_REGISTRY ;
                        }

                    }

                    lresult=RegCloseKey( hRemoteKey );

                    if(ERROR_SUCCESS != lresult)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    }

                    lresult = RegCloseKey( hKeyResult );

                    if(ERROR_SUCCESS != lresult)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        return ERROR_REGISTRY ;
                    }

                    break;
                }
                else
                {
                    if(ERROR_BAD_PATHNAME == lresult || ERROR_FILE_NOT_FOUND == lresult)
                    {
                        ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND) ); 
                    }
                    else
                    {
                        DisplayError(lresult, NULL);
                    }

                    lresult = RegCloseKey( hRemoteKey );

                    if(ERROR_SUCCESS != lresult)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    }
                    return ERROR_REGISTRY ;
                }
    };
            *pdwBytesRead = dwBytes;
            return (dwType);
}


DWORD CheckKeyType( DWORD *dwType,
                    WCHAR ** buffer,
                    DWORD dwBytesRead,
                    PBOOL pbLengthExceed)
/*++

  Routine description   : Check the key type and do some massaging of the data based upon the key type


  Arguments:
          [in] dwType           : Holds the key type.
          [in] buffer           : buffer to hold the String.
          [in] dwBytesRead      : Number of bytes read
          [in] pbLengthExceed   : Whether length exceeded


  Return Value                  : NONE

--*/

{

    LPWSTR szString=NULL;
    LPWSTR szBuffer = NULL;
    LPWSTR lpszManString = NULL;
    HRESULT hr;

    szBuffer = AllocateMemory( (dwBytesRead + MAX_STRING_LENGTH) * sizeof( WCHAR ) );

    if(NULL == szBuffer)
    {
        
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        return FAILURE;
    }
    
    szString = *buffer;
    lpszManString = *buffer;

    switch(*dwType)
    {
    case REG_SZ:

        if(*pbLengthExceed == TRUE)
        {
            
            ShowMessage(stderr, GetResString(IDS_WARNING_LENGTH_EXCEED) ); 
        }

        
        ShowMessage(stdout, GetResString(IDS_VALUE2) ); 
       
        hr = StringCchPrintf(szBuffer, (dwBytesRead + MAX_STRING_LENGTH), L"\"%s\".", _X(*buffer));

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stdout, szBuffer); 
        
        break;

    case REG_MULTI_SZ:

       
        while(NULL != lpszManString && 0 != StringLengthW(lpszManString, 0))
        {
            
            if(NULL != szBuffer && 0 == StringLengthW(szBuffer, 0) )
            {
                
                StringCopyW( szBuffer, lpszManString, (dwBytesRead + MAX_STRING_LENGTH) );
            }
            else
            {
                
                StringConcat(szBuffer, L";", (dwBytesRead + MAX_STRING_LENGTH));
                
                StringConcat(szBuffer, lpszManString, (dwBytesRead + MAX_STRING_LENGTH));
            }

            
            lpszManString = lpszManString + StringLengthW(lpszManString, 0) + 1  ;
            
        }

        
        if(FALSE == ReallocateMemory( buffer , (dwBytesRead + MAX_STRING_LENGTH) * sizeof(WCHAR) ))
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            return FAILURE;
        }

       
        if(StringLengthW(szBuffer, 0) > 1024)
        {
            
            StringCopyW( *buffer, szBuffer, 1025  );
            *pbLengthExceed = TRUE;
        }
        else
        {
            
            StringCopyW( *buffer, szBuffer, dwBytesRead  );
        }
        
        if(*pbLengthExceed == TRUE)
        {
            
            ShowMessage(stderr, GetResString(IDS_WARNING_LENGTH_EXCEED) ); 
        }

        
        ShowMessage( stdout, GetResString(IDS_VALUE2) ); 
        
        hr = StringCchPrintf(szBuffer, (dwBytesRead + MAX_STRING_LENGTH), L"\"%s\".",_X(*buffer));

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stdout, (szBuffer)); 
        *dwType=1;  /* Use REG_SZ when we write it back to the environment */
        break;

    case REG_EXPAND_SZ:
        
        if(*pbLengthExceed == TRUE)
        {
            
            ShowMessage( stderr, GetResString(IDS_WARNING_LENGTH_EXCEED) ); 
        }

        
        ShowMessage( stdout, GetResString(IDS_VALUE2) ); 
       
        hr = StringCchPrintf(szBuffer, (dwBytesRead + MAX_STRING_LENGTH), L"\"%s\".",_X(*buffer));

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage( stdout, (szBuffer) ); 
        break;

    case REG_DWORD:         /* Display it as a hex number */

        
        ShowMessage( stdout, GetResString(IDS_VALUE2) ); 
        
        hr = StringCchPrintf(szBuffer, (dwBytesRead + MAX_STRING_LENGTH), L"\"%s\".",_X(*buffer));

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stdout, (szBuffer)); 

        *dwType=1;  /* Use REG_SZ when we write it back to the environment */
        break;
    default:
        DisplayError(5041, NULL);   /* Unsupported Registry Type */
        return FAILURE ;
    }

    FREE_MEMORY( szBuffer );
    return SUCCESS ;
}




DWORD CheckPercent ( WCHAR * buffer)
/*++

  Routine description   : Checking for a percent symbol
                          and setting it via the command line
                          so we did not need to open a registry key


  Arguments:
          [in] buffer   : buffer containing the string .

  Return Value        : DWORD.

--*/

{
    WCHAR * wszBeginPtr = NULL;
    DWORD dwType = 0;
    DWORD dwPercentCount = 0;

    wszBeginPtr = buffer;

    
    if(*wszBeginPtr == CHAR_TILDE  && StringLengthW(wszBeginPtr, 0) > 2)
    {


        for(wszBeginPtr;*wszBeginPtr != NULLCHAR;wszBeginPtr++);
        wszBeginPtr--;
        if(*wszBeginPtr== CHAR_TILDE)
        {
            *wszBeginPtr= CHAR_PERCENT;
            wszBeginPtr = buffer;
            *wszBeginPtr= CHAR_PERCENT;
            dwType=REG_EXPAND_SZ;
            return (dwType);

        }
        
    }

    if((NULL != wszBeginPtr) && (StringLengthW(wszBeginPtr, 0) > 2))
    {
        for(wszBeginPtr;*wszBeginPtr != NULLCHAR;wszBeginPtr++)
        {
            if(*wszBeginPtr == CHAR_PERCENT)
            {

                if(0 == dwPercentCount)
                {
                    dwPercentCount++;
                    wszBeginPtr++;
                    if(NULL != wszBeginPtr)
                    {
                        wszBeginPtr++;

                        if(NULL != wszBeginPtr)
                        {
                            if(*wszBeginPtr != CHAR_PERCENT)
                            {
                                continue;
                            }
                            else
                            {
                                dwType=REG_EXPAND_SZ;
                                return (dwType);
                            }
                        }
                        else
                        {
                            break;
                        }
                        
                    }
                    else
                    {
                        break;
                    }

                }
                else
                {
                    
                    dwType=REG_EXPAND_SZ;
                    return (dwType);
                }
            }

        }

    }

    dwType=REG_SZ;
    return (dwType);

}



WCHAR * ParseLine(WCHAR *szPtr,
                  LONG* row,
                  LONG* column,
                  WCHAR szDelimiters[15],
                  WCHAR *search_string ,
                  LONG DEBUG ,
                  LONG ABS ,
                  LONG REL ,
                  LONG *record_counter ,
                  LONG *iValue ,
                  DWORD *dwFound,
                  DWORD* dwColPos,
				  BOOL bNegCoord,
				  FILE *fin)
/*++

  Routine description   : Parse the provided value into Hive, path and parameter .
                          Parses each of the line that

  Arguments:
          [in] szPtr            : Pointer to the Buffer containing the Input string.
          [out] row           : Row of the
          [out] column        : Column
          [in] szDelimiters     : Delimiters to search for
          [in] search_string  : String to be searched relative from.
          [in] DEBUG          : Debug purpose
          [in] ABS            : Flag indicating how to search
          [in] REL            : Flag indicating how to search
          [in] record_counter
          [in] iValue         : Value set when the specified string is found in the RELATIVE switch.
          [in] dwFound        : Value indicating whether the specified string has already been found or not.
                              : This is used when the specified search string has more than
                              : one occurance in the file.
  Return Value                : WCHAR *

--*/


{
    WCHAR *cp = NULL ;
    WCHAR *bp = NULL ;
    LONG i=0;
    LPWSTR wszParameter = NULL;
    LPWSTR wszBuffer = NULL;
    HRESULT hr;
    DWORD dw = 0;
    DWORD dwColReach = 0;
	

    wszParameter = AllocateMemory(  GetBufferSize(szPtr) + 10 );

    if(NULL == wszParameter)
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return NULL ;
    }

    /* Check to see if the last character in the line is a newline.
    If it is not then this is not a text file and we should quit */

    cp = szPtr;

    while (*cp != NULLCHAR)
    {
        cp++;
    }

    if (DEBUG)
    {
        
        ShowMessage(stdout, L"\n");/* Make sure each line is printed on a new line */ 
    }


    bp=szPtr;
    cp = szPtr;
    if ( (REL == 1) && (*dwFound == 1))
    {
        while( (*cp != NULLCHAR) && (*dwColPos != dwColReach))
        {
            //while( ( (memchr(szDelimiters, *cp, lstrlen(szDelimiters)*sizeof(WCHAR)) ) != NULL )  && (*cp!=NULLCHAR) )
            while( ( (memchr(szDelimiters, *cp, StringLengthW(szDelimiters, 0) * sizeof(WCHAR)) ) != NULL )  && (*cp!=NULLCHAR) )
            {
                bp = ++cp;
            }

            //while( ( (memchr(szDelimiters, *cp, lstrlen(szDelimiters)*sizeof(WCHAR) ) ) == NULL )  && (*cp!=NULLCHAR))
            while( ( (memchr(szDelimiters, *cp, StringLengthW(szDelimiters, 0) * sizeof(WCHAR) ) ) == NULL )  && (*cp!=NULLCHAR))
            {
                cp++;
            }

            /*while( ( ( memchr(cp, *szDelimiters,lstrlen(szDelimiters)*sizeof(WCHAR) ) ) == NULL )  && (*cp!=NULLCHAR))
            {
                cp++;
            }*/

            if (*cp == *bp && *cp == NULLCHAR)
            {
                FREE_MEMORY( wszParameter );
                //FREE_MEMORY( wszBuffer );
                return NULL ;
            }

            dwColReach++;
        }
     }

    while( *cp != NULLCHAR )
    {
        //while( ( (memchr(szDelimiters, *cp, lstrlen(szDelimiters)*sizeof(WCHAR)) ) != NULL )  && (*cp!=NULLCHAR) )
        while( ( (memchr(szDelimiters, *cp, StringLengthW(szDelimiters, 0) * sizeof(WCHAR)) ) != NULL )  && (*cp!=NULLCHAR) )
        {
            bp = ++cp;
        }

        //while( ( (memchr(szDelimiters, *cp, lstrlen(szDelimiters)*sizeof(WCHAR) ) ) == NULL )  && (*cp!=NULLCHAR))
        while( ( (memchr(szDelimiters, *cp, StringLengthW(szDelimiters, 0) * sizeof(WCHAR) ) ) == NULL )  && (*cp!=NULLCHAR))
        {
            cp++;
        }

        
        if (*cp == *bp && *cp == NULLCHAR)
        {
            FREE_MEMORY( wszParameter );
            
            return NULL ;

        }
        dw = GetBufferSize(wszParameter) / sizeof(WCHAR);
        if( (GetBufferSize(wszParameter) / sizeof(WCHAR)) > (DWORD)(cp-bp) )
        {
            memmove(wszParameter, bp, (cp-bp)*sizeof(WCHAR));
            wszParameter[cp-bp] = NULLCHAR;
            //StringCopy(wszParameter, bp, (cp-bp) * sizeof(WCHAR));
        }
        



        if (DEBUG)
        {
            
            //ASSIGN_MEMORY( wszBuffer , WCHAR , (StringLengthW(wszParameter, 0) + 2 * MAX_STRING_LENGTH) );
            wszBuffer = AllocateMemory( (StringLengthW(wszParameter, 0) + 2 * MAX_STRING_LENGTH) * sizeof( WCHAR ) );
 
            if(NULL == wszBuffer)//partha
            {
                //DisplayErrorMsg(E_OUTOFMEMORY);
                
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                FREE_MEMORY(wszParameter);
                return NULL ;
            }

            
            hr = StringCchPrintf(wszBuffer, (GetBufferSize(wszBuffer) / sizeof(WCHAR)), L"(%ld,%ld %s)", *record_counter, i, _X(wszParameter));

            if(FAILED(hr))
            {
               SetLastError(HRESULT_CODE(hr));
               SaveLastError();
               ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               FREE_MEMORY(wszBuffer);
               FREE_MEMORY(wszParameter);
               return NULL;
            }

            ShowMessage(stdout, wszBuffer); 
            
            FREE_MEMORY(wszBuffer);
        }

        if ( (REL == 1) && (*dwFound == 0))
        {
            
            if ( 0 == StringCompare( wszParameter, search_string, TRUE, 0 ) )
            {
				if(FALSE == bNegCoord)
				{
					*record_counter = 0;
					*dwColPos = i;
					i = 0;
					*iValue = 1 ;
					*dwFound = 1 ;
				}
				else
				{
					//*record_counter +=  row;
                     //i += column;
					*row += *record_counter;
					*column += i;
					*record_counter = -1;
					//i = 0;
					i = 0;
					*dwColPos = *column;
					*column = 0;
					*dwFound = 1 ;
					*iValue = 1 ;

					 //if(*record_counter < 0 || i < 0)
					 if(*row < 0 || *column < 0)
					 {
						 
						 FREE_MEMORY(wszParameter);
						 return NULL;
					 }
					 else
					 {
						 if(0 != fseek(fin, 0, SEEK_SET))
						 {
							 ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
							 return NULL ;

						 }
						 
					 }

					 break;
				}

            }
        }

        if (*record_counter == *row && i == *column  && ( REL == 1) && (*iValue == 1 ) )
        {
            SecureZeroMemory(szPtr, GetBufferSize(szPtr));
            
            StringCopy(szPtr, wszParameter, GetBufferSize(szPtr) / sizeof(WCHAR));
            
            cp = szPtr;
            
            FREE_MEMORY(wszParameter);
            return (cp);
        }

        if ( *record_counter == *row && i == *column  && ( ABS == 1))
        {
            SecureZeroMemory(szPtr, GetBufferSize(szPtr));
            
            StringCopy(szPtr, wszParameter, GetBufferSize(szPtr) / sizeof(WCHAR));
            
            cp = szPtr;
            

            FREE_MEMORY(wszParameter);
            return (cp);
        }
        i++;

    } // End while loop

    
    FREE_MEMORY( wszParameter );
    return NULL ;

}



LONG GetCoord(WCHAR * rcv_buffer,
             LONG * row,
             LONG * column
             )

/*++

  Routine description       : Function to parse the coordinates out of the argument string and convert to integer
  Arguments:
          [in] rcv_buffer   : argument count specified at the command prompt.
          [in] row          : Row number.
          [in] column       : Column number.

  Return Value              : NONE

--*/

{
    WCHAR *bp = NULL ;
    WCHAR *cp = NULL ;
    WCHAR tmp_buffer[SIZE3] ;
    LPWSTR szTemp = NULL;
	BOOL bComma = FALSE;
	WCHAR* wszStopStr = NULL;

    SecureZeroMemory(tmp_buffer, SIZE3 * sizeof(WCHAR));

    /* Test the contents of the COORDINATES for numbers or commas */
        cp=rcv_buffer;

        if( *cp==NULLCHAR )   /* If coordinates are NULL error and exit */
        {
            DisplayError(5014, NULL);
            return FAILURE ;
        }

	
		while(*cp != NULLCHAR )
		{
			//if( (iswdigit(*cp)!=0)  || *cp == COMMA )
			if( *cp == COMMA )
			{
				cp++;  // We are all digits or COMMAS 
				if(FALSE == bComma)
				{
					bComma = TRUE;
				}
				else
				{
					DisplayError(5015, rcv_buffer);
					return FAILURE ;
				}
			}
			else
				if(*cp == HYPHEN || *cp == PLUS || (iswdigit(*cp)!=0))
				{
					cp++;
				}
				else
				{
					DisplayError(5015, rcv_buffer);     // If we're not error and exit 
					return FAILURE ;
				}
		}
	

        /* Everthing must be O.K. with the coordinates */
        /* Start with the ROW value */
        bp=cp=rcv_buffer;
        while( *cp != COMMA && *cp != NULLCHAR )
        {
            cp++;
        }

        memcpy(tmp_buffer,bp, (cp-bp)*sizeof(WCHAR));  /* Copy the first coordinate to the buffer */

         /* Convert the row value to integer. If it fails then error */
        if( _wtoi(tmp_buffer) == NULLCHAR && *tmp_buffer != _T('0') )
        {
            //DisplayError(5015, tmp_buffer);
			DisplayError(5015, bp);
            return FAILURE ;
        }
        else
        {
            szTemp = tmp_buffer;

            while( *szTemp == L'0' && *(szTemp+1) != L'\0')
                szTemp++;

            
            StringCopyW( tmp_buffer, szTemp, SIZE3  );

            if(StringLengthW(tmp_buffer, 0) > 1)
			{
				if(StringLengthW(tmp_buffer+1, 0) > 7)
            
				{
                
					ShowMessage( stderr, GetResString(IDS_MAX_COORDINATES) ); 
					return FAILURE ;
				}
		
            }
            //*row=_wtol(tmp_buffer);
			*row = wcstol(tmp_buffer, &wszStopStr, 10);
			if(StringLengthW(wszStopStr,0) != 0)
			{
				DisplayError(5015, bp);
                return FAILURE ;
			}
        }


        /* Now do the COLUMN value */
        //memcpy(tmp_buffer, (cp+1), lstrlen(cp)*sizeof(WCHAR));  /* Copy the second coordinate to the buffer */
        memcpy(tmp_buffer, (cp + 1), StringLengthW(cp, 0) * sizeof(WCHAR));  /* Copy the second coordinate to the buffer */
        
		wszStopStr = NULL;

        if( _wtoi(tmp_buffer) == NULLCHAR && *tmp_buffer != _T('0') )
        {
            //DisplayError(5015, tmp_buffer);
			DisplayError(5015, bp);
            return FAILURE ;
        }
        else
        {
            szTemp = tmp_buffer;

            while( *szTemp == L'0' && *(szTemp+1) != L'\0')
                szTemp++;

            
            StringCopyW( tmp_buffer, szTemp, SIZE3  );

            if(StringLengthW(tmp_buffer, 0) > 1)
			{
				if(StringLengthW(tmp_buffer+1, 0) > 7)
				{
                
					ShowMessage( stderr, GetResString(IDS_MAX_COORDINATES) ); 
					return FAILURE ;
				}
			}

            //*column=_wtoi(tmp_buffer);
			*column = wcstol(tmp_buffer, &wszStopStr, 10);
			if(StringLengthW(wszStopStr,0) != 0)
			{
				DisplayError(5015, bp);
                return FAILURE ;
			}
        }

        return(SUCCESS);
}


BOOL DisplayError( LONG value,
                   LPCTSTR ptr )
/*++

  Routine description   : Critical error handling routine


  Arguments:
          [in] value     : Error Code.
          [in] ptr       : Error description .


  Return Value        : NONE

--*/

{
    WCHAR szErrorMsg[3*MAX_RES_STRING] ;
    HRESULT hr;

    
    SecureZeroMemory(szErrorMsg, (3*MAX_RES_STRING) * sizeof(WCHAR));

    /* Process the errors and exit accordingly */
    switch( value )
    {
    case 0:         // No error - exit normally //

            break ;

    /* Common WIN32 error codes */
    case ERROR_FILE_NOT_FOUND:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_FILE_NOT_FOUND)); 
        break ;

    case ERROR_PATH_NOT_FOUND:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND)); 
        break ;

    case ERROR_ACCESS_DENIED:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_ACCESS_DENIED)); 
        break ;

    case ERROR_INVALID_HANDLE:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_INVALID_HANDLE)); 
        break ;

    case ERROR_NOT_ENOUGH_MEMORY:
        
        ShowMessage( stderr, GetResString(IDS_ERROR_NOT_ENOUGH_MEMORY) ); 
        break ;

    case ERROR_BAD_ENVIRONMENT:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_BAD_ENVIRONMENT)); 
        break ;

    case ERROR_INVALID_ACCESS:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_INVALID_ACCESS)); 
        break ;

    case ERROR_INVALID_DATA:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_INVALID_DATA)); 
        break ;

    case ERROR_INVALID_DRIVE:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_INVALID_DRIVE)); 
        break ;

    case REGDB_E_READREGDB:
        
        ShowMessage(stderr, GetResString(IDS_REGDB_E_READREGDB)); 
        break ;

    case REGDB_E_WRITEREGDB:
        
        ShowMessage(stderr, GetResString(IDS_REGDB_E_WRITEREGDB)); 
        break ;

    case REGDB_E_KEYMISSING:
        
        ShowMessage(stderr, GetResString(IDS_REGDB_E_KEYMISSING)); 
        break ;

    /* Start at 5010 for Coordinate Problems */
    case 5010:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5010)); 
        break ;

    case 5011:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5011)); 
        break ;

    case 5012:
       
        hr = StringCchPrintf(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg), GetResString(IDS_ERROR_5012),ptr);

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stderr, szErrorMsg); 
        break ;

    case 5013:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5013)); 
        break ;

    case 5014:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5014)); 
        break ;

    case 5015:
        
        hr = StringCchPrintf(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg), GetResString(IDS_ERROR_5015),ptr);

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stderr, _X(szErrorMsg)); 
        break ;

    case 5016:
        
        hr = StringCchPrintf(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg), GetResString(IDS_ERROR_5016),ptr);

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stderr, szErrorMsg); 
        break ;

    case 5017:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5017)); 
        break ;
    case 5018:
        
        hr = StringCchPrintf(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg), GetResString(IDS_ERROR_5018),ptr);

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stderr, szErrorMsg); 
        break ;


    /* Start at 5020 for Command line parameter problems */

    case 5020:
        
        hr = StringCchPrintf(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg), GetResString(IDS_ERROR_5020),ptr);

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stderr, szErrorMsg); 
        break ;

    case 5030:
        
        hr = StringCchPrintf(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg), GetResString(IDS_ERROR_5030),ptr);

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stderr, szErrorMsg); 
        break ;

    case 5031:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5031)); 
        break ;

    case 5032:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5032)); 
        break ;

    /* Start at 5040 for Registry Problems */
    case 5040:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5040)); 
        break ;

    case 5041:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_5041)); 
        break ;

    case 5042:
        
        hr = StringCchPrintf(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg), GetResString(IDS_ERROR_5042),ptr);

        if(FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return FAILURE ;
        }
        
        ShowMessage(stderr, szErrorMsg); 
        break ;

    default:
        
        ShowMessage(stderr, GetResString(IDS_ERROR_DEFAULT)); 
        break ;
    };
  return SUCCESS;
};


VOID DisplayHelp()
/*++

  Routine description   : To display the Help/Usage


  Arguments             : NONE

  Return Value          : NONE

--*/

{
    DWORD dwIndex = IDS_SETX_HELP_BEGIN ;

    for(;dwIndex <= IDS_SETX_HELP_END ; dwIndex++)
    {
        
        ShowMessage(stdout, GetResString(dwIndex)); 
    }
    return ;
}

LONG Parsekey ( WCHAR * wszPtr,
                WCHAR * wszHive,
                WCHAR ** ppwszPath,
                WCHAR * wszParameter
              )
/*++

  Routine description   : Parses the Command line input into various keys.


  Arguments:
          [in ] wszPtr       : argument specified at the command prompt.
          [out] wszHive      : Stores the Hive in the registry
          [out] ppwszPath      : Stores the Path
          [out] wszParameter : Stores the Parameter
  Return Value               : 1 if either the wszHive or wszPath or wszParameter are not found.
                               0 on successful finding

--*/

{
    
    WCHAR * wszBeginPtr = NULL;
    WCHAR * wszCurrentPtr = NULL;
    DWORD dwBegptrLen = 0;
    DWORD dwCurptrLen = 0;
    
    LONG count=0;
    WCHAR wszTempHive[MAX_STRING_LENGTH] ;
   
    wszCurrentPtr =  wszPtr ; 
    wszBeginPtr =    wszCurrentPtr;  

    SecureZeroMemory(wszTempHive, MAX_STRING_LENGTH * sizeof(WCHAR));
    
    while ( *wszCurrentPtr != NULLCHAR )
    {
        if ( *wszCurrentPtr == CHAR_BACKSLASH )
        {
            count++;  /* Ensure the regpath has at least two \\ chars */
        }
        wszCurrentPtr++;
    }
        wszCurrentPtr = NULL;
        wszCurrentPtr=wszPtr;   /* put wszCurrentPtr back to the start of the string */

    /* Move to the first / in the string */
    while ((*wszCurrentPtr != CHAR_BACKSLASH) && (*wszCurrentPtr != NULLCHAR) )
    {
        wszCurrentPtr++;
    }

    /* Extract the wszHive information */
    /* wszBeginPtr is at the start of the string and wszCurrentPtr is at the first / */
     if(SIZE2 >=(wszCurrentPtr-wszBeginPtr) )
    {
        memmove(wszHive, wszBeginPtr, (wszCurrentPtr-wszBeginPtr)*sizeof(WCHAR));
        wszHive[wszCurrentPtr-wszBeginPtr]=NULLCHAR;
    }

    
    if((NULL != wszHive) && (0 == StringLengthW(wszHive, 0)) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_PATH_NOT_FOUND)); 
        return(FAILURE);
    }
    
    StringCopy(wszTempHive, wszHive, SIZE_OF_ARRAY(wszTempHive));


    /* Extract the wszParameter information */
    while ( *wszBeginPtr != NULLCHAR )
    {
        wszBeginPtr++;  /* Go all the way to the end of the string */
    }

    while ( (*(wszBeginPtr-1) != CHAR_BACKSLASH)  && (wszBeginPtr > wszPtr) )
    {
        wszBeginPtr--;  /* Now go back to the first \ */
    }

    if((*(wszBeginPtr-1) == CHAR_BACKSLASH)  && (wszBeginPtr > wszPtr))
    {
        wszBeginPtr--;
        for(;(wszBeginPtr > wszPtr);wszBeginPtr--)
        {
            if((*(wszBeginPtr-1) != CHAR_BACKSLASH))
                break;

        }

        wszBeginPtr++;

    }

   
   if(  StringLengthW(wszBeginPtr, 0) <= SIZE2 )
    {
        //memmove(wszParameter, wszBeginPtr, lstrlen(wszBeginPtr)*sizeof(WCHAR));
        memmove(wszParameter, wszBeginPtr, StringLengthW(wszBeginPtr, 0) * sizeof(WCHAR));
        //wszParameter[lstrlen(wszBeginPtr)] = NULLCHAR;
        wszParameter[StringLengthW(wszBeginPtr, 0)] = NULLCHAR;
    }
    else
    {
        memmove(wszParameter, wszBeginPtr, SIZE2 * sizeof(WCHAR));
        //wszParameter[lstrlen(wszBeginPtr)] = NULLCHAR;
        wszParameter[SIZE2] = NULLCHAR;
    }

    
    /* wszBeginPtr is left pointing to the last \ in the string */

    /* Extract the wszPath information */
    if (count >= 2)
    {
       
        if(NULL != wszBeginPtr)
        {
            dwBegptrLen = StringLengthW(wszBeginPtr, 0);
        }
        if(NULL != wszCurrentPtr)
        {
            dwCurptrLen = StringLengthW(wszCurrentPtr, 0);
        }
        
        dwBegptrLen = (dwBegptrLen + dwCurptrLen) * sizeof(WCHAR);
        *ppwszPath = AllocateMemory((( dwBegptrLen + 10) * sizeof( WCHAR ) ));
        if(*ppwszPath == NULL)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            return( FAILURE );
        }

        

        if((GetBufferSize(*ppwszPath) / sizeof(WCHAR)) > (DWORD)(wszBeginPtr-(wszCurrentPtr+1)))
        {
            memmove(*ppwszPath, wszCurrentPtr+1, ((wszBeginPtr)-(wszCurrentPtr+1))*sizeof(WCHAR) );     /* Drop the two slashes at the start and end */
           //*ppwszPath + (wszBeginPtr-(wszCurrentPtr+1))  = NULLCHAR;
            StringCopyW( (*ppwszPath + (wszBeginPtr-(wszCurrentPtr+1))),NULLCHAR, (GetBufferSize(*ppwszPath) / sizeof(WCHAR)) );

        }

    }
    else
    {
        if(NULL != wszHive)
        {
            
            *ppwszPath = AllocateMemory( (StringLengthW( wszHive, 0 ) + 10) * sizeof( WCHAR ) );

            if(*ppwszPath == NULL)
            {
                
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                return( FAILURE );
            }

        }

    }
    StringCopy(wszHive, wszTempHive, SIZE2);

    if ( (wszHive == NULL) || (*ppwszPath == NULL) || (wszParameter == NULL) )
    {
        return(FAILURE);
    }

    return (SUCCESS);
}


DWORD ProcessOptions( IN LONG argc ,
                      IN LPCWSTR argv[] ,
                      PBOOL pbShowUsage ,
                      LPWSTR* szServer,
                      LPWSTR* szUserName,
                      LPWSTR* szPassword,
                      PBOOL pbMachine,
                      LPWSTR* ppszRegistry,
                 //     PBOOL pbConnFlag ,
                      LPWSTR* ppszDefault,
                      PBOOL pbNeedPwd,
                      LPWSTR szFile ,
                      LPWSTR szAbsolute,
                      LPWSTR szRelative,
                      PBOOL pbDebug,
                      LPWSTR* ppszBuffer,
                      LPWSTR szDelimiter)
                      //PDWORD pdwBufferSize)
/*++

  Routine description   : This function parses the options specified at the command prompt
  Arguments:
        [ in  ] argc            : count of elements in argv
        [ in  ] argv            : command-line parameter specified by the user
        [ out ] pbShowUsage     : Boolean for displaying Help.
        [ out ] szServer        : Contains the Remote System Name specified by User.
        [ out ] szUserName      : Contains the User Name specified by User.
        [ out ] szPassword      : Contains the Password specified by User.
        [ out ] pbMachine       : Boolean for Saving the properties into Registry.
        [ out ] ppszRegistry      : String Containing the Path at which to store the Value.
        [ out ] ppszDefault       : String to store the default arguments.
        [ out ] pbNeedPwd       : To check if password prompting need to be done.
        [ out ] szFile          : File name from which to take the input.
        [ out ] szAbsolute      : Absolute coordinates position for taking the input.
        [ out ] szRelative      : Relative coordinates position for taking the input.
        [ out ] pbDebug         : To check whether to display the Coordinates.
        [ out ] ppszBuffer      : To store the Value
        [ out ] szDelimiter     : To store the additional delimiter which may be specified by the User.
        


  Return Value        : DWORD
         EXIT_FAILURE : If the utility successfully performs the operation.
         EXIT_SUCCESS : If the utility is unsuccessful in performing the specified
                        operation.
--*/

{
    
    
    TCMDPARSER2 cmdOptions[MAX_OPTIONS] ;
   
    TARRAY arrValue = NULL ;
    DWORD dwCount = 0 ;
    
    LPWSTR szTempAbsolute = NULL;
    BOOL bInitialComma = TRUE;
    DWORD pdwBufferSize = 0;
    

    
    const WCHAR*   wszSwitchServer     =   L"s" ;  //SWITCH_SERVER
    const WCHAR*   wszSwitchUser       =  L"u" ;       //wszSwitchUser
    const WCHAR*   wszSwitchPassword   =  L"p" ;//SWITCH_PASSWORD
    const WCHAR*   wszSwitchMachine    = L"m" ;//SWITCH_MACHINE
    const WCHAR*   wszOptionHelp       =  L"?" ;//OPTION_HELP
    const WCHAR*   wszCmdoptionDefault = L"" ;//CMDOPTION_DEFAULT
    const WCHAR*   wszSwitchFile       =  L"f" ;//SWITCH_FILE
    const WCHAR*   wszSwitchDebug      =  L"x" ;//SWITCH_DEBUG
    const WCHAR*   wszSwitchAbs        =  L"a" ;//SWITCH_ABS
    const WCHAR*   wszSwitchRel        =  L"r" ;//SWITCH_REL
    const WCHAR*   wszSwitchDelimiter  = L"d" ;//SWITCH_DELIMITER

 
    arrValue  = CreateDynamicArray();
    if(arrValue == NULL )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return (EXIT_FAILURE);
    }

    
    //Fill each structure with the appropriate value.
    //Usage.
    StringCopyA( cmdOptions[OPTION_USAGE].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_USAGE].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[OPTION_USAGE].pwszOptions = wszOptionHelp;
    cmdOptions[OPTION_USAGE].pwszFriendlyName = NULL;
    cmdOptions[OPTION_USAGE].pwszValues = NULL;
    cmdOptions[OPTION_USAGE].dwCount = 1 ;
    cmdOptions[OPTION_USAGE].dwActuals = 0;
    cmdOptions[OPTION_USAGE].dwFlags = CP2_USAGE ;
    cmdOptions[OPTION_USAGE].pValue = pbShowUsage  ;
    cmdOptions[OPTION_USAGE].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[OPTION_USAGE].pFunction = NULL ;
    cmdOptions[OPTION_USAGE].pFunctionData = NULL ;
    cmdOptions[OPTION_USAGE].dwReserved = 0;
    cmdOptions[OPTION_USAGE].pReserved1 = NULL;
    cmdOptions[OPTION_USAGE].pReserved2 = NULL;
    cmdOptions[OPTION_USAGE].pReserved3 = NULL;
    
    //Server.
    StringCopyA( cmdOptions[OPTION_SERVER].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_SERVER].dwType = CP_TYPE_TEXT;
    cmdOptions[OPTION_SERVER].pwszOptions = wszSwitchServer;
    cmdOptions[OPTION_SERVER].pwszFriendlyName = NULL;
    cmdOptions[OPTION_SERVER].pwszValues = NULL;
    cmdOptions[OPTION_SERVER].dwCount = 1 ;
    cmdOptions[OPTION_SERVER].dwActuals = 0;
    cmdOptions[OPTION_SERVER].dwFlags =  CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdOptions[OPTION_SERVER].pValue = NULL  ;
    cmdOptions[OPTION_SERVER].dwLength    = 0;
    cmdOptions[OPTION_SERVER].pFunction = NULL ;
    cmdOptions[OPTION_SERVER].pFunctionData = NULL ;
    cmdOptions[OPTION_SERVER].dwReserved = 0;
    cmdOptions[OPTION_SERVER].pReserved1 = NULL;
    cmdOptions[OPTION_SERVER].pReserved2 = NULL;
    cmdOptions[OPTION_SERVER].pReserved3 = NULL;
   
    //User
    StringCopyA( cmdOptions[OPTION_USER].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_USER].dwType = CP_TYPE_TEXT;
    cmdOptions[OPTION_USER].pwszOptions = wszSwitchUser;
    cmdOptions[OPTION_USER].pwszFriendlyName = NULL;
    cmdOptions[OPTION_USER].pwszValues = NULL;
    cmdOptions[OPTION_USER].dwCount = 1 ;
    cmdOptions[OPTION_USER].dwActuals = 0;
    cmdOptions[OPTION_USER].dwFlags = CP2_VALUE_TRIMINPUT | CP2_ALLOCMEMORY | CP2_VALUE_NONULL;
    cmdOptions[OPTION_USER].pValue = NULL;
    cmdOptions[OPTION_USER].dwLength    = 0;
    cmdOptions[OPTION_USER].pFunction = NULL;
    cmdOptions[OPTION_USER].pFunctionData = NULL;
    cmdOptions[OPTION_USER].dwReserved = 0;
    cmdOptions[OPTION_USER].pReserved1 = NULL;
    cmdOptions[OPTION_USER].pReserved2 = NULL;
    cmdOptions[OPTION_USER].pReserved3 = NULL;
    
    //Password.
    StringCopyA( cmdOptions[OPTION_PASSWORD].szSignature, "PARSER2\0", 8 ) ;
    cmdOptions[OPTION_PASSWORD].dwType = CP_TYPE_TEXT ;
    cmdOptions[OPTION_PASSWORD].pwszOptions = wszSwitchPassword ;
    cmdOptions[OPTION_PASSWORD].pwszFriendlyName = NULL ;
    cmdOptions[OPTION_PASSWORD].pwszValues = NULL ;
    cmdOptions[OPTION_PASSWORD].dwCount = 1 ;
    cmdOptions[OPTION_PASSWORD].dwActuals = 0;
    cmdOptions[OPTION_PASSWORD].dwFlags = CP2_VALUE_OPTIONAL | CP2_ALLOCMEMORY ;
    cmdOptions[OPTION_PASSWORD].pValue = NULL;
    cmdOptions[OPTION_PASSWORD].dwLength    = 0 ;
    cmdOptions[OPTION_PASSWORD].pFunction = NULL ;
    cmdOptions[OPTION_PASSWORD].pFunctionData = NULL ;
    cmdOptions[OPTION_PASSWORD].dwReserved = 0 ;
    cmdOptions[OPTION_PASSWORD].pReserved1 = NULL ;
    cmdOptions[OPTION_PASSWORD].pReserved2 = NULL ;
    cmdOptions[OPTION_PASSWORD].pReserved3 = NULL ;
    
    //Machine.
    StringCopyA( cmdOptions[OPTION_MACHINE].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_MACHINE].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[OPTION_MACHINE].pwszOptions = wszSwitchMachine;
    cmdOptions[OPTION_MACHINE].pwszFriendlyName = NULL;
    cmdOptions[OPTION_MACHINE].pwszValues = NULL;
    cmdOptions[OPTION_MACHINE].dwCount = 1;
    cmdOptions[OPTION_MACHINE].dwActuals = 0;
    cmdOptions[OPTION_MACHINE].dwFlags = 0;
    cmdOptions[OPTION_MACHINE].pValue = pbMachine;
    cmdOptions[OPTION_MACHINE].dwLength    = MAX_RES_STRING;
    cmdOptions[OPTION_MACHINE].pFunction = NULL;
    cmdOptions[OPTION_MACHINE].pFunctionData = NULL;
    cmdOptions[OPTION_MACHINE].dwReserved = 0;
    cmdOptions[OPTION_MACHINE].pReserved1 = NULL;
    cmdOptions[OPTION_MACHINE].pReserved2 = NULL;
    cmdOptions[OPTION_MACHINE].pReserved3 = NULL;
   
    //Registry
    StringCopyA( cmdOptions[OPTION_REGISTRY].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_REGISTRY].dwType = CP_TYPE_TEXT;
    cmdOptions[OPTION_REGISTRY].pwszOptions = wszSwitchRegistry;
    cmdOptions[OPTION_REGISTRY].pwszFriendlyName = NULL;
    cmdOptions[OPTION_REGISTRY].pwszValues = NULL;
    cmdOptions[OPTION_REGISTRY].dwCount = 1 ;
    cmdOptions[OPTION_REGISTRY].dwActuals = 0;
    cmdOptions[OPTION_REGISTRY].dwFlags =  CP2_VALUE_NONULL  | CP2_ALLOCMEMORY ; //CP_VALUE_OPTIONAL ;//| CP_VALUE_MANDATORY ;
    cmdOptions[OPTION_REGISTRY].pValue = NULL;
    cmdOptions[OPTION_REGISTRY].dwLength    = 0;
    cmdOptions[OPTION_REGISTRY].pFunction = NULL;
    cmdOptions[OPTION_REGISTRY].pFunctionData = NULL;
    cmdOptions[OPTION_REGISTRY].dwReserved = 0;
    cmdOptions[OPTION_REGISTRY].pReserved1 = NULL;
    cmdOptions[OPTION_REGISTRY].pReserved2 = NULL;
    cmdOptions[OPTION_REGISTRY].pReserved3 = NULL;
    
    //Default
    StringCopyA( cmdOptions[OPTION_DEFAULT].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_DEFAULT].dwType = CP_TYPE_TEXT ;
    cmdOptions[OPTION_DEFAULT].pwszOptions = wszCmdoptionDefault;
    cmdOptions[OPTION_DEFAULT].pwszFriendlyName = NULL;
    cmdOptions[OPTION_DEFAULT].pwszValues = NULL;
    cmdOptions[OPTION_DEFAULT].dwCount = 2;
    cmdOptions[OPTION_DEFAULT].dwActuals = 0;
    cmdOptions[OPTION_DEFAULT].dwFlags =  CP2_MODE_ARRAY | CP2_DEFAULT ;
    cmdOptions[OPTION_DEFAULT].pValue = &arrValue;
    cmdOptions[OPTION_DEFAULT].dwLength    = 0;
    cmdOptions[OPTION_DEFAULT].pFunction = NULL;
    cmdOptions[OPTION_DEFAULT].pFunctionData = NULL;
    cmdOptions[OPTION_DEFAULT].dwReserved = 0;
    cmdOptions[OPTION_DEFAULT].pReserved1 = NULL;
    cmdOptions[OPTION_DEFAULT].pReserved2 = NULL;
    cmdOptions[OPTION_DEFAULT].pReserved3 = NULL;
   
    // File
    StringCopyA( cmdOptions[OPTION_FILE].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_FILE].dwType = CP_TYPE_TEXT ;
    cmdOptions[OPTION_FILE].pwszOptions = wszSwitchFile;
    cmdOptions[OPTION_FILE].pwszFriendlyName = NULL;
    cmdOptions[OPTION_FILE].pwszValues = NULL;
    cmdOptions[OPTION_FILE].dwCount = 1 ;
    cmdOptions[OPTION_FILE].dwActuals = 0;
    cmdOptions[OPTION_FILE].dwFlags =  CP2_VALUE_TRIMINPUT  ;
    cmdOptions[OPTION_FILE].pValue = szFile ;
    cmdOptions[OPTION_FILE].dwLength    = MAX_RES_STRING;
    cmdOptions[OPTION_FILE].pFunction = NULL ;
    cmdOptions[OPTION_FILE].pFunctionData = NULL ;
    cmdOptions[OPTION_FILE].dwReserved = 0;
    cmdOptions[OPTION_FILE].pReserved1 = NULL;
    cmdOptions[OPTION_FILE].pReserved2 = NULL;
    cmdOptions[OPTION_FILE].pReserved3 = NULL;
    
    //Absolute Offset
    StringCopyA( cmdOptions[OPTION_ABS_OFFSET].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_ABS_OFFSET].dwType = CP_TYPE_TEXT ;
    cmdOptions[OPTION_ABS_OFFSET].pwszOptions = wszSwitchAbs;
    cmdOptions[OPTION_ABS_OFFSET].pwszFriendlyName = NULL;
    cmdOptions[OPTION_ABS_OFFSET].pwszValues = NULL;
    cmdOptions[OPTION_ABS_OFFSET].dwCount = 1 ;
    cmdOptions[OPTION_ABS_OFFSET].dwActuals = 0;
    cmdOptions[OPTION_ABS_OFFSET].dwFlags =  CP2_VALUE_TRIMINPUT ;
    cmdOptions[OPTION_ABS_OFFSET].pValue = szAbsolute;
    cmdOptions[OPTION_ABS_OFFSET].dwLength    = MAX_RES_STRING;
    cmdOptions[OPTION_ABS_OFFSET].pFunction = NULL ;
    cmdOptions[OPTION_ABS_OFFSET].pFunctionData = NULL ;
    cmdOptions[OPTION_ABS_OFFSET].dwReserved = 0;
    cmdOptions[OPTION_ABS_OFFSET].pReserved1 = NULL;
    cmdOptions[OPTION_ABS_OFFSET].pReserved2 = NULL;
    cmdOptions[OPTION_ABS_OFFSET].pReserved3 = NULL;
    
    //Relative Offset
    StringCopyA( cmdOptions[OPTION_REL_OFFSET].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_REL_OFFSET].dwType = CP_TYPE_TEXT ;
    cmdOptions[OPTION_REL_OFFSET].pwszOptions = wszSwitchRel;
    cmdOptions[OPTION_REL_OFFSET].pwszFriendlyName = NULL;
    cmdOptions[OPTION_REL_OFFSET].pwszValues = NULL;
    cmdOptions[OPTION_REL_OFFSET].dwCount = 1 ;
    cmdOptions[OPTION_REL_OFFSET].dwActuals = 0;
    cmdOptions[OPTION_REL_OFFSET].dwFlags = CP2_VALUE_TRIMINPUT ;
    cmdOptions[OPTION_REL_OFFSET].pValue = szRelative ;
    cmdOptions[OPTION_REL_OFFSET].dwLength    = MAX_RES_STRING;
    cmdOptions[OPTION_REL_OFFSET].pFunction = NULL ;
    cmdOptions[OPTION_REL_OFFSET].pFunctionData = NULL ;
    cmdOptions[OPTION_REL_OFFSET].dwReserved = 0;
    cmdOptions[OPTION_REL_OFFSET].pReserved1 = NULL;
    cmdOptions[OPTION_REL_OFFSET].pReserved2 = NULL;
    cmdOptions[OPTION_REL_OFFSET].pReserved3 = NULL;
    
    //Debug
    StringCopyA( cmdOptions[OPTION_DEBUG].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_DEBUG].dwType = CP_TYPE_BOOLEAN ;
    cmdOptions[OPTION_DEBUG].pwszOptions = wszSwitchDebug;
    cmdOptions[OPTION_DEBUG].pwszFriendlyName = NULL;
    cmdOptions[OPTION_DEBUG].pwszValues = NULL;
    cmdOptions[OPTION_DEBUG].dwCount = 1 ;
    cmdOptions[OPTION_DEBUG].dwActuals = 0;
    cmdOptions[OPTION_DEBUG].dwFlags =  0 ;
    cmdOptions[OPTION_DEBUG].pValue = pbDebug ;
    cmdOptions[OPTION_DEBUG].dwLength    = MAX_RES_STRING;
    cmdOptions[OPTION_DEBUG].pFunction = NULL ;
    cmdOptions[OPTION_DEBUG].pFunctionData = NULL ;
    cmdOptions[OPTION_DEBUG].dwReserved = 0;
    cmdOptions[OPTION_DEBUG].pReserved1 = NULL;
    cmdOptions[OPTION_DEBUG].pReserved2 = NULL;
    cmdOptions[OPTION_DEBUG].pReserved3 = NULL;
    
    StringCopyA( cmdOptions[OPTION_DELIMITER].szSignature, "PARSER2\0", 8 );
    cmdOptions[OPTION_DELIMITER].dwType =  CP_TYPE_TEXT ;
    cmdOptions[OPTION_DELIMITER].pwszOptions = wszSwitchDelimiter;
    cmdOptions[OPTION_DELIMITER].pwszFriendlyName = NULL;
    cmdOptions[OPTION_DELIMITER].pwszValues = NULL;
    cmdOptions[OPTION_DELIMITER].dwCount = 1 ;
    cmdOptions[OPTION_DELIMITER].dwActuals = 0 ;
    cmdOptions[OPTION_DELIMITER].dwFlags =  0 ;
    cmdOptions[OPTION_DELIMITER].pValue = szDelimiter ;
    cmdOptions[OPTION_DELIMITER].dwLength    = MAX_RES_STRING;
    cmdOptions[OPTION_DELIMITER].pFunction = NULL ;
    cmdOptions[OPTION_DELIMITER].pFunctionData = NULL ;
    cmdOptions[OPTION_DELIMITER].dwReserved = 0;
    cmdOptions[OPTION_DELIMITER].pReserved1 = NULL;
    cmdOptions[OPTION_DELIMITER].pReserved2 = NULL;
    cmdOptions[OPTION_DELIMITER].pReserved3 = NULL;
    
    //display a syntax error if no arguments are given.

    if(argc == 1)
    {
        //DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_SYNTAX));
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX)); 
        DestroyDynamicArray(&arrValue);
        return (EXIT_FAILURE);
    }

    //parse the command line arguments
    if ( ! DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        DISPLAY_MESSAGE(stderr,GetResString(IDS_TAG_ERROR));
        DISPLAY_MESSAGE(stderr,SPACE_CHAR);
        DISPLAY_MESSAGE(stderr,GetReason());
        //ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        DestroyDynamicArray(&arrValue);
        return (EXIT_FAILURE);
    }

    *szServer = (LPWSTR)cmdOptions[OPTION_SERVER].pValue;
    *szUserName = (LPWSTR)cmdOptions[OPTION_USER].pValue;
    *szPassword = (LPWSTR)cmdOptions[OPTION_PASSWORD].pValue;
    *ppszRegistry = (LPWSTR)cmdOptions[OPTION_REGISTRY].pValue;

    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( *szServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name 
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails 
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password 
        // before trying to connect
        //
        // case 3: -p * is specified
        
        // user name
        if ( *szUserName == NULL )
        {
            *szUserName = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *szUserName == NULL )
            {
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                DestroyDynamicArray(&arrValue);
                return EXIT_FAILURE;
            }
        }

        // password
        if ( *szPassword == NULL )
        {
            *pbNeedPwd = TRUE;
            *szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *szPassword == NULL )
            {
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                DestroyDynamicArray(&arrValue);
                return EXIT_FAILURE;
            }
        }

        // case 1
        /*if ( cmdOptions[OPTION_PASSWORD].dwActuals == 0 )
        {
            // we need not do anything special here
        }*/
        if ( cmdOptions[OPTION_PASSWORD].pValue == NULL )
            {
                StringCopy( *szPassword, L"*", GetBufferSize((LPVOID)(*szPassword)));
            }
         else 
           if ( StringCompareEx( *szPassword, L"*", TRUE, 0 ) == 0 )
            {
                if ( ReallocateMemory( (LPVOID*)(szPassword), 
                                       MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
                {
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    DestroyDynamicArray(&arrValue);
                    
                    return EXIT_FAILURE;
                }

                // ...
                *pbNeedPwd = TRUE;
            }
        
        // case 3
       
    }

    
    if(NULL != *ppszRegistry && 0 != StringLengthW(*ppszRegistry, 0))
    {
        StrTrim(*ppszRegistry,SPACE_CHAR);
    }

    //
    //Display an error message if the User enters any junk along with the help option.
    //or verbose help option
    if( ( *pbShowUsage ==TRUE ) )
    {
        if(argc > 2 )
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX)); 
            DestroyDynamicArray(&arrValue);
            return (EXIT_FAILURE);
        }

    }
    else
    {   //Display error message if user enters any junk.
        if(argc == 2)
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX)); 
            DestroyDynamicArray(&arrValue);
            return (EXIT_FAILURE);
        }


    }

    
    if(  ( ( 0 != cmdOptions[OPTION_REGISTRY].dwActuals ) && (NULL == (*ppszRegistry) )) )
    {
        
        ShowMessage(stderr, GetResString(IDS_NULL_REGISTRY) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

     if(  ( ( 0 != cmdOptions[OPTION_REGISTRY].dwActuals ) &&  0 == StringLengthW(*ppszRegistry, 0)) )
    {
        
        DISPLAY_MESSAGE(stderr,GetResString(IDS_TAG_ERROR));
        DISPLAY_MESSAGE(stderr,SPACE_CHAR);
        ShowMessage(stderr, GetResString(IDS_NULL_REGISTRY_VALUE) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    //
    // Display an error message if the User does not enter either absolute position
    // or relative position or debug flag along with file name
    if(  ( StringLengthW(szFile, 0) != 0 ) && ( (cmdOptions[OPTION_REL_OFFSET].dwActuals == 1) &&(cmdOptions[OPTION_ABS_OFFSET].dwActuals == 1)  ))
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }
    //
    
    if(  ( StringLengthW(szFile, 0) != 0 ) && ((cmdOptions[OPTION_ABS_OFFSET].dwActuals == 1) && ( StringLengthW(szAbsolute, 0) == 0 )   ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_NULL_ABSOLUTE_VALUE ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    if(  ( StringLengthW(szFile, 0) != 0 ) && ( (cmdOptions[OPTION_REL_OFFSET].dwActuals == 1) &&( StringLengthW(szRelative, 0) == 0 )  ))
    {
        
        ShowMessage(stderr, GetResString(IDS_NULL_RELATIVE_VALUE ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }


    if(  ( StringLengthW(szFile, 0) != 0 ) && ( ( StringLengthW(szRelative, 0) == 0 ) && (StringLengthW(szAbsolute, 0) == 0) && ( *pbDebug == FALSE ) ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    if( (cmdOptions[OPTION_DELIMITER].dwActuals == 1) && ( cmdOptions[OPTION_FILE].dwActuals == 0) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }


    if ((cmdOptions[OPTION_REGISTRY].dwActuals ==1) && (cmdOptions[OPTION_FILE].dwActuals ==1))
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );
    }

    //get the count of the number of default arguments.
    dwCount = DynArrayGetCount(arrValue);


    // Display an error if  the user enters a invalid
    // syntax.
    if(dwCount == 0)
    {
        if ( (cmdOptions[OPTION_SERVER].dwActuals ==1) && (cmdOptions[OPTION_FILE].dwActuals ==0)&& ((cmdOptions[OPTION_REGISTRY].dwActuals ==0)) )
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }
        if ((cmdOptions[OPTION_REGISTRY].dwActuals ==1) || ((cmdOptions[OPTION_FILE].dwActuals ==1)&& (cmdOptions[OPTION_DEBUG].dwActuals ==0)))
        {
            
            ShowMessage(stderr, GetResString(IDS_REGVALUE_SPECIFIED ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }
    }

    if(dwCount > 0)
    {

        
        *ppszDefault = AllocateMemory( (StringLengthW((LPWSTR)DynArrayItemAsString(arrValue,0) , 0) + 10) * sizeof( WCHAR ) );
        

        if(*ppszDefault == NULL)
        {
           
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }

        
        StringCopyW( *ppszDefault, DynArrayItemAsString(arrValue,0), StringLengthW((LPWSTR)DynArrayItemAsString(arrValue, 0) , 0) + 10  );

       
        
        
        if(StringLengthW(*ppszDefault, 0) == 0)
        {
            
            ShowMessage(stderr, GetResString(IDS_REGVALUE_ZERO ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }

        
        if(StringLengthW(*ppszDefault, 0) > MAX_STRING_LENGTH)
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_CMDPARSER_LENGTH ) ); 
            
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }

    }

    //copy the second default argument into  *ppszBuffer value.
    if( (dwCount == 2  ) && ( cmdOptions[OPTION_REGISTRY].dwActuals == 0) && ( cmdOptions[OPTION_DEBUG].dwActuals == 0) &&(cmdOptions[OPTION_ABS_OFFSET].dwActuals == 0) && (cmdOptions[OPTION_FILE].dwActuals != 0) )
    {
        
        pdwBufferSize = StringLengthW((LPWSTR)DynArrayItemAsString(arrValue,1), 0) + 20;
       
        *ppszBuffer = AllocateMemory( (pdwBufferSize) * sizeof( WCHAR ) );

        if(*ppszBuffer == NULL)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }

        
        StringCopyW( *ppszBuffer, DynArrayItemAsString(arrValue,1), StringLengthW((LPWSTR)DynArrayItemAsString(arrValue,1), 0) + 20  );
        
       
        StrTrim(*ppszBuffer,SPACE_CHAR);

        
        if(0 == StringLengthW(*ppszBuffer, 0))
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_SEARCH_STRING ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );

        }
    }
    else if( (dwCount == 2  ) && ( cmdOptions[OPTION_REGISTRY].dwActuals == 0) && ( cmdOptions[OPTION_DEBUG].dwActuals == 0) &&(cmdOptions[OPTION_ABS_OFFSET].dwActuals == 0)  )
    {
                
        pdwBufferSize = StringLengthW((LPWSTR)DynArrayItemAsString(arrValue,1), 0) + 20;

        
        *ppszBuffer = AllocateMemory( (pdwBufferSize) * sizeof( WCHAR ) );

        if(*ppszBuffer == NULL)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }

        
        StringCopyW( *ppszBuffer, DynArrayItemAsString(arrValue,1), StringLengthW((LPWSTR)DynArrayItemAsString(arrValue,1), 0) + 20  );
     

    }


    if( ( cmdOptions[OPTION_FILE].dwActuals == 0 ) && ( cmdOptions[OPTION_REGISTRY].dwActuals == 0 ) && (dwCount== 1) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );
    }

    //display an error if any of the invalid options is specified along with /x after /f switch.
     if( ( cmdOptions[OPTION_FILE].dwActuals == 1 ) && ( cmdOptions[OPTION_DEBUG].dwActuals == 1)  )
     {
        if(( dwCount != 0) || (cmdOptions[OPTION_MACHINE].dwActuals != 0) || ( cmdOptions[OPTION_ABS_OFFSET].dwActuals == 1) ||( (cmdOptions[OPTION_REL_OFFSET].dwActuals == 1) ) )
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }
     }

    //
    // Set the bNeedPwd boolean to true
    // if the User has specified a password and has not specified any password.
    //

    
    if ( ( 0 != cmdOptions[ OPTION_PASSWORD ].dwActuals ) &&
                      ( 0 == StringCompare( *szPassword, L"*", TRUE, 0 ) ) )
    {
        // user wants the utility to prompt for the password before trying to connect
        *pbNeedPwd = TRUE;

    }
    else if ( 0 == cmdOptions[ OPTION_PASSWORD ].dwActuals  &&
            ( 0 != cmdOptions[OPTION_SERVER].dwActuals || 0 != cmdOptions[OPTION_USER].dwActuals) )
    {
        // -s, -u is specified without password ...
        // utility needs to try to connect first and if it fails then prompt for the password
        *pbNeedPwd = TRUE;
        
        StringCopyW( *szPassword, NULL_U_STRING, GetBufferSize(*szPassword) / sizeof(WCHAR)  );
    }

    //if -s is entered with empty string
    if( ( 0 != cmdOptions[ OPTION_SERVER ].dwActuals  ) &&
                                       ( 0 == StringLengthW( *szServer, 0 ) ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_NULL_SERVER ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );
    }

    //if -u is entered with empty string
    
    if( ( 0 != cmdOptions[ OPTION_USER ].dwActuals ) && ( 0 == StringLengthW( *szUserName, 0 ) ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_NULL_USER ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );
    }

    
    if(  ( StringLengthW(szFile, 0) == 0 ) && ( 0 != cmdOptions[OPTION_FILE].dwActuals ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_NULL_FILE ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    
    if(  ( StringLengthW(*ppszRegistry, 0) == 0 ) && ( 0 != cmdOptions[OPTION_REGISTRY].dwActuals ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_NULL_REGISTRY ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    //
    //display an error message if user tries to specify  -R ,-F ,-A ,-X option are specified
    // with out specifying -f option
    //
    
    if(  ( StringLengthW(szFile, 0) == 0 ) && ( ( StringLengthW(szRelative, 0) != 0 ) || (StringLengthW(szAbsolute, 0) != 0) || ( *pbDebug == TRUE ) ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    //added
    
    if( ( StringLengthW(szAbsolute, 0) != 0 )&&( dwCount == 2) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
                
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    //
    // Display an error message if the user enters 2 default arguments
    // along with the /k switch.

    
    if( (StringLengthW(*ppszRegistry, 0) != 0 ) && (dwCount == 2) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );
    }

    
    if(StringLengthW(szRelative, 0) != 0)
    {
        if(dwCount < 2)
        {
            ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
          
        }
        dwCount = 0;

        szTempAbsolute = szRelative;


        for(szTempAbsolute;;szTempAbsolute++)
        {
            if(*szTempAbsolute == L',' || *szTempAbsolute == L'\0' )
            {
                if(0 == dwCount)
                {
                    
                    ShowMessage(stderr, GetResString(IDS_ERROR_INVALIDCOORDINATES ) ); 
                    DestroyDynamicArray(&arrValue);
                    return( EXIT_FAILURE );

                }

                break;
            }
            dwCount++;
        }
        if(*szTempAbsolute != L'\0')
        {
            szTempAbsolute++;
        }
        if(*szTempAbsolute == L'\0')
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_INVALIDCOORDINATES ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }
        else
        {
            szTempAbsolute++;
            
            if(*szTempAbsolute == L'\0' && StringLengthW(*ppszBuffer, 0) == 0)
            {
                
                ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
                DestroyDynamicArray(&arrValue);
                return( EXIT_FAILURE );
            }


        }
    }

    
    if(StringLengthW(szAbsolute, 0) != 0)
    {
        szTempAbsolute = szAbsolute;


        for(szTempAbsolute;;szTempAbsolute++)
        {
            if(*szTempAbsolute == L',' || *szTempAbsolute == L'\0' )
            {
                break;
            }

            bInitialComma = FALSE;
        }
        if(*szTempAbsolute != L'\0')
        {
            szTempAbsolute++;
        }
        if((*szTempAbsolute == L'\0') || (TRUE == bInitialComma))
        {
            
            ShowMessage(stderr, GetResString(IDS_ERROR_INVALIDCOORDINATES ) ); 
            DestroyDynamicArray(&arrValue);
            return( EXIT_FAILURE );
        }

    }

    //
    // Display an error message if user gives -u with out -s
    //
    if( (cmdOptions[ OPTION_USER ].dwActuals != 0 ) && ( cmdOptions[ OPTION_SERVER ].dwActuals == 0 ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );
    }

    //
    // Display an error message if user gives -p with out -u
    //
    if( ( cmdOptions[ OPTION_USER ].dwActuals == 0 ) && ( 0 != cmdOptions[ OPTION_PASSWORD ].dwActuals  ) )
    {
        
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );
    }

    if( (cmdOptions[OPTION_ABS_OFFSET].dwActuals == 1) && ( cmdOptions[OPTION_FILE].dwActuals == 0) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    if( (cmdOptions[OPTION_REL_OFFSET].dwActuals == 1) && ( cmdOptions[OPTION_FILE].dwActuals == 0) )
    {
        
        ShowMessage(stderr, GetResString(IDS_ERROR_SYNTAX ) ); 
        DestroyDynamicArray(&arrValue);
        return( EXIT_FAILURE );

    }

    DestroyDynamicArray(&arrValue);
    return EXIT_SUCCESS ;
}


VOID SafeCloseConnection(
                         BOOL bConnFlag,
                         LPTSTR szServer
                         )
/*++

  Routine description   : This function closes a connection to the remote system
                          based on the Flag value.

  Arguments:
          [in ] bConnFlag    : Flag indicating whether to close the connection or not.
          [in] szServer      : System name.

  Return Value               : NONE

--*/


{
    if (bConnFlag == TRUE )
    {
        CloseConnection(szServer);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\takeown\pch.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//      PCH.H
//
//  Abstract:
//      Include file for standard system include files, or project specific
//      include files that are used frequently, but  are changed infrequently.
//
//  Author:
//      Vasundhara .G
//
//  Revision History:
//      Vasundhara .G 22-sep-2k : Created It.
//***************************************************************************

#ifndef __PCH_H
#define __PCH_H

#ifdef __cplusplus
extern "C" {
#endif

#pragma once        // include header file only once

//
// public Windows header files
//
#include <windows.h>
#include "winerror.h"

//
// public C header files
//

#define CMDLINE_VERSION         200


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <shlwapi.h>
#include <accctrl.h>
#include <aclapi.h>
#include <lm.h>
#include <security.h>
#include <strsafe.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#ifdef __cplusplus
}
#endif

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\takeown\resource.h ===
#define IDS_USAGE_BEGINING              101
#define IDS_USG_1                       102
#define IDS_USG_2                       103
#define IDS_USG_3                       104
#define IDS_USG_4                       105
#define IDS_USG_5                       106
#define IDS_USG_6                       107
#define IDS_USG_7                       108
#define IDS_USG_8                       109
#define IDS_USG_9                       110
#define IDS_USG_10                      111
#define IDS_USG_11                      112
#define IDS_USG_12                      113
#define IDS_USG_13                      114
#define IDS_USG_14                      115
#define IDS_USG_15                      116
#define IDS_USG_16                      117
#define IDS_USG_17                      118
#define IDS_USG_18                      119
#define IDS_USG_19                      120
#define IDS_USG_20                      121
#define IDS_USG_21                      122
#define IDS_USG_22                      123
#define IDS_USG_23                      124
#define IDS_USG_24                      125
#define IDS_USG_25                      126
#define IDS_USG_26                      127
#define IDS_USG_27                      128
#define IDS_USG_28                      129
#define IDS_USG_29                      130
#define IDS_USG_30                      131
#define IDS_USG_31                      132
#define IDS_USG_32                      133
#define IDS_USG_33                      134
#define IDS_USG_34                      135
#define IDS_USG_35                      136
#define IDS_USG_36                      137
#define IDS_USG_37                      138
#define IDS_USG_38                      139
#define IDS_USG_39                      140
#define IDS_USG_40                      141
#define IDS_USG_41                      142
#define IDS_USG_42                      143
#define IDS_USG_43                      144
#define IDS_USG_44                      145
#define IDS_USG_45                      146
#define IDS_USG_46                      147
#define IDS_USG_47                      148
#define IDS_USG_48                      149
#define IDS_USG_49                      150
#define IDS_USG_50                      151
#define IDS_USG_51                      152
#define IDS_USG_52                      153
#define IDS_USG_53                      154
#define IDS_USG_54                      155
#define IDS_USG_55                      156
#define IDS_USG_56                      157
#define IDS_USG_57                      158
#define IDS_USG_58                      159
#define IDS_USG_59                      160

#define IDS_USAGE_ENDING                161


#define IDS_INVALID_WILDCARD        301
#define IDS_SYNTAX_ERROR                302
#define IDS_NOT_ADMINISTRATOR           303
#define IDS_ACCESS_DENIED           304


#define IDS_SYSTEM_ERROR             305

#define IDS_ACCESS_VIOLATION                 306
#define IDS_IGNORE_LOCALCREDENTIALS          307

#define IDS_FILE_PROTECTION_SUCCESSFUL       401
#define IDS_ERROR_STARRECURSIVE              402
#define IDS_FILE_PROTECTION_SUCCESSFUL_USER  403
#define IDS_NOT_OWNERSHIP                    404
//#define IDS_ACCESS_DENIED_INFO               405
#define IDS_NOT_OWNERSHIP_INFO               406
#define IDS_INVALID_DIRECTORY                407
#define IDS_ACCESS_DENIED_ERROR              408
#define IDS_GIVE_FULL_PERMISSIONS            409
#define IDS_LOWER_YES                        410
#define IDS_LOWER_NO                         411
#define IDS_LOWER_CANCEL                     412
#define IDS_NOT_OWNERSHIP_ERROR              413
#define IDS_GIVE_FULL_PERMISSIONS2           414
//#define IDS_ON_FILE_FOLDER                   415
#define IDS_IGNORE_CREDENTIALS               416
#define IDS_SHARING_VIOLATION_ERROR          417
#define IDS_SHARING_VIOLATION_INFO           418
//#define IDS_SHARING_VIOLATION              419
#define IDS_FAT_VOLUME                       420
#define IDS_INVALID_USERNAME                 421
#define IDS_NO_OWNER_REMOVABLE_MEDIA         422
#define IDS_NO_PATTERN_FOUND                 423
#define IDS_CONFIRM_ERROR                    424
#define IDS_YESNO                            425
#define IDS_FAT_VOLUME_INFO                  426

         

#define IDS_TYPE_REQUEST                601
#define IDS_NEW_LINE                    602
#define IDS_NO_DEFAULT_ARG              603
#define IDS_NULL_FILENAME               604
#define IDS_INVALID_FILENAME            605
#define IDS_ERROR_PATH_NAME             606
#define IDS_USER_NMACHINE               607
#define IDS_PASSWORD_NUSER              608
#define IDS_NULL_SERVER                 609
#define IDS_NULL_USER                   610
#define IDS_INVALID_SID                 611
#define IDS_INVALID_DRIVE               612
#define IDS_NO_FILES_AVAILABLE          613
#define IDS_ERROR_MEMORY_ALLOC          614

#define IDS_ERROR_STRING                IDS_TAG_ERROR
#define IDS_WARNING_STRING              IDS_TAG_WARNING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\timeout\resource.h ===
// Help
#define IDS_HELP_1                                      501
#define IDS_HELP_2                                      502
#define IDS_HELP_3                                      503
#define IDS_HELP_4                                      504
#define IDS_HELP_5                                      505
#define IDS_HELP_6                                      506
#define IDS_HELP_7                                      507
#define IDS_HELP_8                                      508
#define IDS_HELP_9                                      509
#define IDS_HELP_10                                     510
#define IDS_HELP_11                                     511
#define IDS_HELP_12                                     512
#define IDS_HELP_13                                     513
#define IDS_HELP_14                                     514
#define IDS_HELP_15                                     515
#define IDS_HELP_16                                     516
#define IDS_HELP_17                                     517
#define IDS_HELP_18                                     518
#define IDS_HELP_19                                     519
#define IDS_HELP_20                                     520
#define IDS_HELP_21                                     521
#define IDS_HELP_22                                     522
#define IDS_HELP_23                                     523
#define IDS_HELP_24                                     524
#define IDS_HELP_25                                     525

// Error Strings
#define IDS_ERROR_TIME_VALUE                            600
#define IDS_INVALID_INPUT_REDIRECT                      601

// General strings
#define IDS_WAIT_MSG                                    151
#define IDS_WAIT_MSG_TIME1                              152
#define IDS_WAIT_TIME                                   153
#define IDS_INVALID_SYNTAX                              155
#define IDS_NOBREAK_MSG_TIME                            156
#define IDS_NO_BREAK_MSG                                157
#define IDS_FORMAT_STR                                  158
#define IDS_NB_MSG_TIME                                 159
#define IDS_WAIT_MSG_TIME2                              160
#define IDS_FORMAT_MSG_FAIL                             161

// redefines
#define IDS_ERROR_TAG                                   IDS_TAG_ERROR
#define IDS_HELP_START                                  IDS_HELP_1
#define IDS_HELP_END                                    IDS_HELP_24
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\takeown\takeown.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//      TAKEOWN.H
//
//  Abstract:
//      Contains function prototypes and macros.
//
//  Author:
//      Wipro Technologies
//
//  Revision History:
//      Wipro Technologies 22-jun-01 : Created It.
//***************************************************************************

#ifndef __TAKEOWN_H
#define __TAKEOWN_H


LPWSTR lpwszTempDummyPtr ;

// constants / defines / enumerations
#define MAX_OPTIONS                     8
#define FILESYSNAMEBUFSIZE              1024
//Command line parser index

#define CMD_PARSE_SERVER                0
#define CMD_PARSE_USER                  1
#define CMD_PARSE_PWD                   2
#define CMD_PARSE_USG                   3
#define CMD_PARSE_FN                    4
#define CMD_PARSE_RECURSE               5
#define CMD_PARSE_ADMIN                 6
#define CMD_PARSE_CONFIRM               7

//warning message
#define IGNORE_LOCALCREDENTIALS         GetResString( IDS_IGNORE_LOCALCREDENTIALS )

// Error constants


#define   ERROR_PATH_NAME               GetResString( IDS_ERROR_PATH_NAME )

// Error constants
#define ERROR_USER_WITH_NOSERVER        GetResString( IDS_USER_NMACHINE )
#define ERROR_PASSWORD_WITH_NUSER       GetResString( IDS_PASSWORD_NUSER )
#define ERROR_NULL_SERVER               GetResString( IDS_NULL_SERVER )
#define ERROR_NULL_USER                 GetResString( IDS_NULL_USER )
#define ERROR_INVALID_WILDCARD          GetResString( IDS_INVALID_WILDCARD )
#define ERROR_SYNTAX_ERROR              GetResString( IDS_SYNTAX_ERROR )
#define ERROR_STRING                    GetResString( IDS_ERROR_STRING )
#define GIVE_FULL_PERMISSIONS           GetResString(IDS_GIVE_FULL_PERMISSIONS)
#define GIVE_FULL_PERMISSIONS2           GetResString(IDS_GIVE_FULL_PERMISSIONS2)

//success string
#define TAKEOWN_SUCCESSFUL              GetResString( IDS_FILE_PROTECTION_SUCCESSFUL )
#define TAKEOWN_SUCCESSFUL_USER         GetResString( IDS_FILE_PROTECTION_SUCCESSFUL_USER )
#define LOWER_YES                       GetResString( IDS_LOWER_YES )

#define LOWER_NO                        GetResString( IDS_LOWER_NO )

#define LOWER_CANCEL                    GetResString( IDS_LOWER_CANCEL )



#define SPACE_CHAR      L" "

//command line options
#define CMDOPTION_USAGE                 L"?"
#define CMDOPTION_SERVER                L"S"
#define CMDOPTION_USER                  L"U"
#define CMDOPTION_PASSWORD              L"P"
#define CMDOPTION_FILENAME              L"F"
#define CMDOPTION_RECURSE               L"R"
#define CMDOPTION_ADMIN                 L"A"
         


#define TRIM_SPACES                     TEXT(" \0")
#define WILDCARD                        L"*"
#define DOUBLE_QUOTE                    L"\\\\"
#define SINGLE_QUOTE                    L'\\'
#define BACK_SLASH                      L"/"
#define TRIPLE_SLASH                    L"\\\\\\"
#define DOLLOR                          L'$'
#define COLON                           L':'
#define ALL_FILES                       L"\\*.*"
#define DOT                             L"."
#define DOTS                            L".."
#define CHAR_SET                        L"\"/?<>|"
#define CHAR_SET2                       L"\\\"/:?<>|*.+,$#@![](){}~&?^|="
#define CHAR_SET3                       L":"
#define ADMINISTRATOR                   L"Administrator"
#define ADMINISTRATORS                  L"Administrators"
#define SUCCESS 0
#define FAILURE 1
#define RETVALZERO 0
#define MAX_PATHNAME    512
#define MAX_SYSTEMNAME  64
#define C_COLON      L"C:\\"
#define D_COLON      L"D:\\"
#define E_COLON      L"E:\\"
#define F_COLON      L"F:\\"
#define G_COLON      L"G:\\"
#define H_COLON      L"H:\\"

#define     EXTRA_MEM               10
#define NULL_U_STRING               L"\0"
#define NULL_U_CHAR                 L'\0'
#define EXIT_FAIL                   255
#define EXIT_SUCC                   0
#define EXIT_CANCELED               1000
#define BOUNDARYVALUE               128
#define MAX_CONFIRM_VALUE           10


#define DASH         L"-"
#define BASE_TEN     10


#define FREE_MEMORY( VARIABLE ) \
            FreeMemory(&VARIABLE); \
            1


#define CLOSE_FILE_HANDLE( FILE_HANDLE ) \
            if( FILE_HANDLE != 0 ) \
            { \
                    FindClose( FILE_HANDLE ) ;  \
                    FILE_HANDLE = 0 ;  \
            } \
            1


// function prototypes
BOOL
ParseCmdLine(
    IN  DWORD   argc,
    IN  LPCWSTR argv[],
    OUT LPWSTR*  szMachineName,
    OUT LPWSTR*  szUserName,
    OUT LPWSTR*  szPassword,
    OUT LPWSTR*  szFileName,
    OUT BOOL    *pbUsage,
    OUT BOOL    *pbNeedPassword,
    OUT BOOL    *pbRecursive,
    OUT BOOL    *pbAdminsOwner,
    OUT LPWSTR  szConfirm
    );

VOID
DisplayUsage(
    );

BOOL
TakeOwnerShip(
    IN LPCWSTR lpszFileName
    );

BOOL
GetTokenHandle(
    OUT PHANDLE hTokenHandle
    );

BOOL
AssertTakeOwnership(
    IN HANDLE hTokenHandle
    );

BOOL
TakeOwnerShipAll(IN LPWSTR  lpszFileName,
                 IN BOOL bCurrDirTakeOwnAllFiles,
                 IN PDWORD  dwFileCount,
                 IN BOOL bDriveCurrDirTakeOwnAllFiles,
                 IN BOOL bAdminsOwner,
                 IN LPWSTR  szOwnerString,
                 BOOL bMatchPattern,
                 LPWSTR wszPatternString);


BOOL
TakeOwnerShipRecursive(IN LPWSTR  lpszFileName,
                       IN BOOL bCurrDirTakeOwnAllFiles,
                       IN BOOL bAdminsOwner,
                       IN LPWSTR  szOwnerString,
                       IN BOOL bTakeOwnAllFiles,
                       IN BOOL bDriveCurrDirTakeOwnAllFiles,
                       IN BOOL bMatchPattern,
                       IN LPWSTR wszPatternString,
                       IN LPWSTR szConfirm);



DWORD IsLogonDomainAdmin(IN LPWSTR szOwnerString, OUT PBOOL pbLogonDomainAdmin);

typedef struct __STORE_PATH_NAME
{
    LPTSTR pszDirName ;
    struct  __STORE_PATH_NAME  *NextNode ;
} Store_Path_Name , *PStore_Path_Name ;


DWORD
StoreSubDirectory(IN LPTSTR lpszPathName,
                  IN PBOOL pbACLChgPermGranted,
                  IN LPWSTR  szOwnerString,
                  IN BOOL bMatchPattern,
                  IN LPWSTR wszPatternString,
                  IN LPWSTR szConfirm,
                  IN BOOL bAdminsOwner);

BOOL GetOwnershipForFiles(IN LPWSTR lpszPathName,
                          IN BOOL bAdminsOwner,
                          IN LPWSTR  szOwnerString,
                          IN BOOL bMatchPattern,
                          IN LPWSTR wszPatternString,
                          IN OUT PBOOL pbFilesNone);

BOOL Pop( void );

BOOL Push( IN LPTSTR szPathName );

DWORD GetMatchedFiles(
                      IN BOOL bAdminsOwner,
                      IN LPWSTR  szOwnerString,
                      IN BOOL bMatchPattern,
                      IN LPWSTR wszPatternString,
                      IN OUT PBOOL pbFilesNone,
                      IN LPWSTR szConfirms);

BOOL
TakeOwnerShipIndividual( IN LPCTSTR lpszFileName );


DWORD
IsNTFSFileSystem(IN LPWSTR lpszPath,
                 BOOL bLocalSystem,
                 //BOOL bFileInUNCFormat,
                 BOOL bCurrDirTakeOwnAllFiles,
                 LPWSTR szUserName,
                 OUT PBOOL pbNTFSFileSystem);
DWORD 
IsNTFSFileSystem2(IN LPWSTR lpszTempDrive,
                  OUT PBOOL pbNTFSFileSystem);

BOOL
AddAccessRights(IN WCHAR *lpszFileName,
                IN DWORD dwAccessMask,
                IN LPWSTR dwUserName,
                IN BOOL bAdminsOwner);


DWORD RemoveStarFromPattern( IN OUT LPWSTR szPattern );

#endif // __TAKEOWN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\takeown\takeown.c ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//      TAKEOWN.C
//
//  Abstract:
//      Implements a recovery scheme to give an Administrator
//      access to a file that has been denied to all.
//
//  Author:
//      Wipro Technologies
//
//  Revision History:
//      Wipro Technologies 22-jun-01 : Created It.
//***************************************************************************

// Include files
#include "pch.h"
#include "takeown.h"
#include "resource.h"
#include "Lm.h"
//#include <malloc.h>


/*GLOBAL VARIABLES*/

 PStore_Path_Name    g_pPathName = NULL ;           // Holds path name from where started .
 PStore_Path_Name    g_pFollowPathName = NULL ;     // Holds information about a subdirectory .
 LPTSTR g_lpszFileToSearch = NULL;                  // Holds information about directories and subdirectories .


DWORD
_cdecl _tmain(
    IN DWORD argc,
    IN LPCWSTR argv[]
    )
/*++
Routine Description:
    Main function which calls all the other functions depending on the
    option specified by the user.

Arguments:
    [ IN ] argc - Number of command line arguments.
    [ IN ] argv - Array containing command line arguments.

Return Value:
    EXIT_FAILURE if takeown utility is not successful.
    EXIT_SUCCESS if takeown utility is successful.
--*/
{
    //local variables
    BOOL   bUsage = FALSE;
    BOOL   bFlag = FALSE;
    BOOL   bNeedPassword = FALSE;
    BOOL   bCloseConnection = FALSE;
    BOOL   bLocalSystem = FALSE;
    BOOL   bTakeOwnAllFiles = FALSE;
    BOOL   bCurrDirTakeOwnAllFiles = FALSE;
    BOOL   bDriveCurrDirTakeOwnAllFiles = FALSE;
    BOOL   bRecursive = FALSE;
    BOOL   bLogonDomainAdmin = FALSE;
    BOOL   bAdminsOwner = FALSE;
    BOOL   bFileInUNCFormat = FALSE;
    BOOL   bNTFSFileSystem  = FALSE;
    BOOL   bMatchPattern = FALSE;

    
    LPWSTR  szUserName = NULL;
    LPWSTR  szPassword = NULL;
    LPWSTR  szMachineName = NULL;
    LPWSTR  wszPatternString = NULL;
    LPWSTR  szTmpFileName = NULL;
    LPWSTR  szDirTok = NULL;
    LPWSTR  szFileName = NULL;
    LPWSTR  szTemporaryFileName = NULL;
    LPWSTR  szTempPath = NULL;
    LPTSTR  szFilePart       =    NULL;
    LPWSTR  szFullPath = NULL;
    LPWSTR  szDispFileName = NULL;
    
    WCHAR dwUserName[2 * MAX_STRING_LENGTH] ;
    WCHAR szOwnerString[4 * MAX_STRING_LENGTH+5] ;
    WCHAR ch = L'\\';
    WCHAR szTempChar[20] ;
    WCHAR szConfirm [MAX_CONFIRM_VALUE] ;
    
     
    
    DWORD nSize1 = 4 * MAX_STRING_LENGTH + 5;
    DWORD dwi = 0;
    DWORD dwCount = 2;
    DWORD  dwFileCount = 0;
    DWORD dwCnt = 0;
    
    HRESULT hr;

    SecureZeroMemory(dwUserName, (2 * MAX_STRING_LENGTH) * sizeof(WCHAR));
    SecureZeroMemory(szOwnerString, (4 * MAX_STRING_LENGTH+5) * sizeof(WCHAR));
    SecureZeroMemory(szTempChar, (20) * sizeof(WCHAR));
    SecureZeroMemory(szConfirm, (MAX_CONFIRM_VALUE) * sizeof(WCHAR));

    bFlag = ParseCmdLine( argc, argv, &szMachineName, &szUserName,
            &szPassword, &szFileName, &bUsage, &bNeedPassword, &bRecursive, &bAdminsOwner, szConfirm);

    //if syntax of command line arguments is false display the error
    //and exit
    if( FALSE == bFlag )
    {
        FREE_MEMORY(szMachineName);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szPassword);
        FREE_MEMORY(szFileName);
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    //if usage is specified at command line, display usage
    if( TRUE == bUsage )
    {
        DisplayUsage();
        FREE_MEMORY(szMachineName);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szPassword);
        FREE_MEMORY(szFileName);
        ReleaseGlobals();
        return( EXIT_SUCCESS );
    }


   if(0 == GetUserNameEx(NameSamCompatible, szOwnerString,&nSize1))
    {
         
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        FREE_MEMORY(szMachineName);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szPassword);
        FREE_MEMORY(szFileName);
        ReleaseGlobals();
        return EXIT_FAILURE;

    }
/*Check whether the current logged on user is domain administrator or not*/
  if( EXIT_FAIL == IsLogonDomainAdmin(szOwnerString,&bLogonDomainAdmin) )
    {
        FREE_MEMORY(szMachineName);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szPassword);
        FREE_MEMORY(szFileName);
        ReleaseGlobals();
        return EXIT_FAILURE;

    }

/*If /a option is specified, before giving ownership to the administrators group, check whether current logged on user has administrative privileges or NOT*/
  if(TRUE == bAdminsOwner)
  {

       if(FALSE == IsUserAdmin())
       {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR ));
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szPassword);
            FREE_MEMORY(szFileName);
            ReleaseGlobals();
            return( EXIT_FAILURE );
       }
      
  }

    
    if( StringLengthW( szFileName, 0 ) > 3 )
    {

       if((szFileName[1] == L':') && ( SINGLE_QUOTE == szFileName[ 2 ] ) &&
            ( SINGLE_QUOTE == szFileName[ 3 ] ))

        {
            ShowMessage( stderr , ERROR_PATH_NAME ) ;
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szPassword);
            FREE_MEMORY(szFileName);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    if(StringLengthW(szFileName, 0) != 0)
    {
        if(-1 != FindChar2((szFileName), L'?', TRUE, 0))
        {
            ShowMessage( stderr , ERROR_PATH_NAME ) ;
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szPassword);
            FREE_MEMORY(szFileName);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    bLocalSystem = IsLocalSystem(IsUNCFormat(szMachineName) ? szMachineName+2:szMachineName);

    if(TRUE == IsUNCFormat(szFileName))
    {
        bFileInUNCFormat = TRUE;
    }

    szTemporaryFileName = (LPWSTR)AllocateMemory((StringLengthW(szFileName, 0) + MAX_STRING_LENGTH) * sizeof(WCHAR));
    if(NULL == szTemporaryFileName)
    {
        FREE_MEMORY(szMachineName);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szPassword);
        FREE_MEMORY(szFileName);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    //if remote machine establish connection
    //if( FALSE == bLocalSystem && FALSE == bFileInUNCFormat)
    if( FALSE == bLocalSystem )
    {
        //if remote machine and wild card then display error and exit
        
        
        if( ( 1 == StringLengthW( szFileName, 0 ) ) && ( 0 == StringCompare( szFileName, WILDCARD, TRUE, 0 ) ) )
        
        {
            ShowMessage( stderr, ERROR_INVALID_WILDCARD );
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szPassword);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        //if remote machine establish connection
        bFlag = EstablishConnection( szMachineName, (LPTSTR)szUserName,
                    GetBufferSize( szUserName ) / sizeof(WCHAR), (LPTSTR)szPassword,
                    GetBufferSize( szPassword ) / sizeof(WCHAR), bNeedPassword );
        
        //failed to establish connection
        if ( FALSE == bFlag )
        {
            // failed in establishing n/w connection

            ShowMessage( stderr, ERROR_STRING );
            ShowMessage( stderr, SPACE_CHAR );
            ShowMessage( stderr, GetReason() );
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szPassword);
            FREE_MEMORY(szTemporaryFileName);
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        switch( GetLastError() )
        {
            case I_NO_CLOSE_CONNECTION:
                bCloseConnection = FALSE;
                break;
            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    //
                    // some error occured ... but can be ignored
                    // connection need not be disconnected
                    bCloseConnection= FALSE;
                    // show the warning message
                    ShowLastErrorEx(stderr, SLE_TYPE_WARNING | SLE_SYSTEM);
                    break;
                }
            default:
                bCloseConnection = TRUE;
        }

        FREE_MEMORY(szPassword);

        szTmpFileName = (LPWSTR)AllocateMemory((StringLengthW(szMachineName, 0) + StringLengthW(szFileName, 0) + MAX_STRING_LENGTH) * sizeof(WCHAR));
        if(NULL == szTmpFileName)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            if( TRUE == bCloseConnection )
            {
                CloseConnection( szMachineName );
            }
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

       if(FALSE == IsUNCFormat(szMachineName))
        {
            
            StringCopyW( szTmpFileName, DOUBLE_QUOTE, GetBufferSize(szTmpFileName) / sizeof(WCHAR));
            
            StringConcat(szTmpFileName, szMachineName, GetBufferSize(szTmpFileName) / sizeof(WCHAR));
        }
        else
        {
            
            StringCopyW( szTmpFileName, szMachineName, GetBufferSize(szTmpFileName) / sizeof(WCHAR) );
        }

       
         StringConcat(szTmpFileName, L"\\", GetBufferSize(szTmpFileName) / sizeof(WCHAR));
        
        if(FALSE == IsUNCFormat(szFileName))
        {

            
            StringCopyW( szTemporaryFileName, szFileName, GetBufferSize(szTemporaryFileName) / sizeof(WCHAR) );

            if( szFileName[1] == COLON )
            {
                szFileName[1] = DOLLOR;
            }

            
            StringConcat(szTmpFileName, szFileName, GetBufferSize(szTmpFileName) / sizeof(WCHAR));

            if( szFileName[1] == DOLLOR )
            {
                szFileName[1] = COLON;
            }

       }
        else
        {
            szTempPath = wcsrchr(szFileName,COLON); //go from the reverse direction to check for ":" . Let \\server\c:\temp

            if(NULL != szTempPath)
            {
                szTempPath--;  //Go back reverse by one step..If :\temp is obtained , by this step , we get c:\temp

                if(NULL != szTempPath)
                {
                    //ShowMessage( stderr, GetResString(IDS_IGNORE_CREDENTIALS) );
                    
                    StringCopyW( szTemporaryFileName, szTempPath, GetBufferSize(szTemporaryFileName) / sizeof(WCHAR) );

                    if( szTemporaryFileName[1] == COLON ) // change the " : " to " $ " , so , c$\temp
                    {
                        szTemporaryFileName[1] = DOLLOR;
                    }
                    szDirTok = wcstok(szFileName,L":");  // get the taken value , like \\server\c
                    
                    StringCopyW( szTmpFileName, szDirTok, GetBufferSize(szTmpFileName) / sizeof(WCHAR) );
                    
                    StringConcat(szTmpFileName, szTemporaryFileName+1, GetBufferSize(szTmpFileName) / sizeof(WCHAR));
                    //attach the value, say "$\temp" to \\server\c , so that the value becomes "\\server\c$\temp"
                    if( szTemporaryFileName[1] == DOLLOR )//convert back the original string from dollar to colon
                    {
                        szTemporaryFileName[1] = COLON;
                    }
                }
            }
            else
            {
                //ShowMessage( stderr, GetResString(IDS_IGNORE_CREDENTIALS) );
                
                StringCopyW( szTmpFileName, szFileName, GetBufferSize(szTmpFileName) / sizeof(WCHAR) );
            }
        }
    }
    else
    {
        FREE_MEMORY(szPassword);

        szTmpFileName = (LPWSTR)AllocateMemory((StringLengthW(szFileName, 0) + MAX_STRING_LENGTH) * sizeof(WCHAR));

        if(NULL == szTmpFileName)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        
        if( StringLengthW( szFileName, 0 ) == 2 && szFileName[0] == L'\\' && (szFileName[1] == L'\\' || szFileName[1] == L':') )
        {
            ShowMessage( stderr , ERROR_PATH_NAME ) ;
            ReleaseGlobals();
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(szTemporaryFileName);
            return EXIT_FAILURE;
        }

        
        if( (StringLengthW( szFileName, 0 )) > 2 )
        {
            if(( SINGLE_QUOTE == szFileName[ 0 ] ) &&
                ( SINGLE_QUOTE == szFileName[ 1 ] ))
            {
                szTempChar[0] = szFileName[2];
                szTempChar[1] = L'\0';
                if(wcspbrk(szTempChar, CHAR_SET2) != NULL)
                {

                    DISPLAY_MESSAGE( stderr , ERROR_PATH_NAME ) ;
                    ReleaseGlobals();
                    FREE_MEMORY(szMachineName);
                    FREE_MEMORY(szUserName);
                    FREE_MEMORY(szFileName);
                    FREE_MEMORY(szTmpFileName);
                    FREE_MEMORY(szTemporaryFileName);
                    return EXIT_FAILURE;
                }

                
                if( NULL != FindString( ( szFileName + 2 ), DOUBLE_QUOTE, 0  ) )
                {
                    DISPLAY_MESSAGE( stderr , ERROR_PATH_NAME ) ;
                    FREE_MEMORY(szMachineName);
                    FREE_MEMORY(szUserName);
                    FREE_MEMORY(szFileName);
                    FREE_MEMORY(szTmpFileName);
                    FREE_MEMORY(szTemporaryFileName);
                    ReleaseGlobals();
                    return EXIT_FAILURE;
                }
            }

        }

        
        if( (StringLengthW( szFileName, 0 ) == 1) || (StringLengthW( szFileName, 0 ) == 2))
        {
            if(szFileName[0] == L':')
            {
                DISPLAY_MESSAGE( stderr , ERROR_PATH_NAME ) ;
                FREE_MEMORY(szMachineName);
                FREE_MEMORY(szUserName);
                FREE_MEMORY(szFileName);
                FREE_MEMORY(szTmpFileName);
                FREE_MEMORY(szTemporaryFileName);
                ReleaseGlobals();
                return EXIT_FAILURE;
            }

        }

        if(TRUE == bFileInUNCFormat)
        {
            szTempPath = wcsrchr(szFileName,COLON);

            if(NULL != szTempPath)
            {
                szTempPath--;

                if(NULL != szTempPath)
                {

                    
                    StringCopyW( szTemporaryFileName, szTempPath, GetBufferSize(szTemporaryFileName) / sizeof(WCHAR) );

                    if( szTemporaryFileName[1] == COLON )
                    {
                        szTemporaryFileName[1] = DOLLOR;
                    }
                    szDirTok = wcstok(szFileName, L":");
                    
                    StringCopyW( szTmpFileName, szDirTok, GetBufferSize(szTmpFileName) / sizeof(WCHAR) );
                    
                    StringConcat(szTmpFileName, szTemporaryFileName+1, GetBufferSize(szTmpFileName) / sizeof(WCHAR));
                    if( szTemporaryFileName[1] == DOLLOR )
                    {
                        szTemporaryFileName[1] = COLON;
                    }

                }

            }
            else
            {

                
                StringCopyW( szTmpFileName, szFileName, GetBufferSize(szTmpFileName) / sizeof(WCHAR) );
            }

        }
        else
        {
            
            StringCopyW( szTmpFileName, szFileName, GetBufferSize(szTmpFileName) / sizeof(WCHAR) );
        }

        
        if((StringLengthW( szTmpFileName, 0 )) > 2)
        {
             if(wcspbrk(szTmpFileName+2,CHAR_SET3) != NULL)
            {

                DISPLAY_MESSAGE( stderr , ERROR_PATH_NAME ) ;
                FREE_MEMORY(szMachineName);
                FREE_MEMORY(szUserName);
                FREE_MEMORY(szFileName);
                FREE_MEMORY(szTmpFileName);
                FREE_MEMORY(szTemporaryFileName);
                ReleaseGlobals();
                return EXIT_FAILURE;
            }
        }
    }//end of else loop for (FALSE == BLocalSystem)

    /*Check whether * is given in order to give ownership to all the files in the directory specicied or current directory*/

    
    if((StringLengthW( szTmpFileName, 0 )) >= 2)
    {
        szTempPath = wcsrchr(szTmpFileName, ch);
        if(szTempPath != NULL && (*(szTempPath + 1) != L'\0'))
        {
            
            if(*(szTempPath+1) == L'*')
            {
               for(dwCount;;dwCount++)
                {
                    if(*(szTempPath + dwCount) != L'\0')
                    {
                        if(*(szTempPath + dwCount) != L'*')
                        {
                            bMatchPattern = TRUE;
                            wszPatternString = (LPWSTR)AllocateMemory((StringLengthW(szTempPath + 1, 0) + 10) * sizeof(WCHAR));
                            if(NULL == wszPatternString)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                if( TRUE == bCloseConnection )
                                {
                                    CloseConnection( szMachineName );
                                }
                                FREE_MEMORY(szMachineName);
                                FREE_MEMORY(szUserName);
                                FREE_MEMORY(szFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                ReleaseGlobals();
                                return EXIT_FAILURE;
                            }
                            StringCopyW(wszPatternString, szTempPath + 1, GetBufferSize(wszPatternString) / sizeof(WCHAR));

                            if(EXIT_FAILURE == RemoveStarFromPattern(wszPatternString))
                            {
                                if( TRUE == bCloseConnection )
                                {
                                    CloseConnection( szMachineName );
                                }
                                FREE_MEMORY(szMachineName);
                                FREE_MEMORY(szUserName);
                                FREE_MEMORY(szFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                FREE_MEMORY(wszPatternString);
                                ReleaseGlobals();
                                return EXIT_FAILURE;

                            }

                            break;
                            
                        }
                    }
                    else
                    {
                        break;
                    }
                }
               szTempPath++; ////
               *(szTempPath) = '\0';
               bTakeOwnAllFiles = TRUE;
            }
            else
            {
                if(-1 != FindChar2((LPCWSTR)(szTempPath + 1), L'*', TRUE, 0) &&
                    (-1 == FindChar2((szTempPath + 1), L'?', TRUE, 0)))
                {
                    bMatchPattern = TRUE;
                    wszPatternString = (LPWSTR)AllocateMemory((StringLengthW(szTempPath + 1, 0) + 10) * sizeof(WCHAR));
                    if(NULL == wszPatternString)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        if( TRUE == bCloseConnection )
                        {
                            CloseConnection( szMachineName );
                        }
                        FREE_MEMORY(szMachineName);
                        FREE_MEMORY(szUserName);
                        FREE_MEMORY(szFileName);
                        FREE_MEMORY(szTemporaryFileName);
                        ReleaseGlobals();
                        return EXIT_FAILURE;
                    }

                    StringCopyW(wszPatternString, szTempPath + 1, GetBufferSize(wszPatternString) / sizeof(WCHAR));
                    if(EXIT_FAILURE == RemoveStarFromPattern(wszPatternString))
                    {
                        if( TRUE == bCloseConnection )
                        {
                            CloseConnection( szMachineName );
                        }
                        FREE_MEMORY(szMachineName);
                        FREE_MEMORY(szUserName);
                        FREE_MEMORY(szFileName);
                        FREE_MEMORY(szTemporaryFileName);
                        FREE_MEMORY(wszPatternString);
                        ReleaseGlobals();
                        return EXIT_FAILURE;

                    }
                    szTempPath++;
                    *(szTempPath) = '\0';
                    bTakeOwnAllFiles = TRUE;
                }
            }
        }
        else
        {
            dwCount = 0;
            for(dwCount;;dwCount++)
                {
                    if(*(szTmpFileName + dwCount) != L'\0')
                    {
                        if(*(szTmpFileName + dwCount) != L'*')
                        {
                            break;

                        }
                    }
                    else
                    {
                        bCurrDirTakeOwnAllFiles = TRUE;
                        break;
                    }
                }

            if(bCurrDirTakeOwnAllFiles == FALSE)
            {
                dwCount = 2;
                szTempPath = wcsrchr(szTmpFileName, COLON);
                if(szTempPath != NULL)
                {
                    if((*(szTempPath + 1) != L'\0') && (*(szTempPath + 1) == L'*'))
                    {
                       for(dwCount;;dwCount++)
                        {
                            if(*(szTempPath + dwCount) != L'\0')
                            {
                                if(*(szTempPath + dwCount) != L'*')
                                {
                                    bMatchPattern = TRUE;
                                    wszPatternString = (LPWSTR)AllocateMemory((StringLengthW(szTempPath + 1, 0) + 10) * sizeof(WCHAR));
                                    if(NULL == wszPatternString)
                                    {
                                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                        if( TRUE == bCloseConnection )
                                        {
                                            CloseConnection( szMachineName );
                                        }
                                        FREE_MEMORY(szMachineName);
                                        FREE_MEMORY(szUserName);
                                        FREE_MEMORY(szFileName);
                                        FREE_MEMORY(szTemporaryFileName);
                                        ReleaseGlobals();
                                        return EXIT_FAILURE;
                                    }

                                    StringCopyW(wszPatternString, szTempPath + 1, GetBufferSize(wszPatternString) / sizeof(WCHAR));
                                    if(EXIT_FAILURE == RemoveStarFromPattern(wszPatternString))
                                    {
                                        if( TRUE == bCloseConnection )
                                        {
                                            CloseConnection( szMachineName );
                                        }
                                        FREE_MEMORY(szMachineName);
                                        FREE_MEMORY(szUserName);
                                        FREE_MEMORY(szFileName);
                                        FREE_MEMORY(szTemporaryFileName);
                                        FREE_MEMORY(wszPatternString);
                                        ReleaseGlobals();
                                        return EXIT_FAILURE;

                                    }
                                    bDriveCurrDirTakeOwnAllFiles = TRUE;
                                    break;
                                    
                                }
                            }
                            else
                            {
                                break;
                            }
                       }
                       szTempPath++; ////
                       *(szTempPath) = L'\0';

                       bDriveCurrDirTakeOwnAllFiles = TRUE;
                    }
                    else
                    {
                       if((-1 != FindChar2((szTempPath + 1), L'*', TRUE, 0)) && 
                           (-1 == FindChar2((szTempPath + 1), L'?', TRUE, 0)))
                        {
                            bMatchPattern = TRUE;
                            wszPatternString = (LPWSTR)AllocateMemory((StringLengthW(szTempPath + 1, 0) + 10) * sizeof(WCHAR));
                            if(NULL == wszPatternString)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                if( TRUE == bCloseConnection )
                                {
                                    CloseConnection( szMachineName );
                                }
                                FREE_MEMORY(szMachineName);
                                FREE_MEMORY(szUserName);
                                FREE_MEMORY(szFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                ReleaseGlobals();
                                return EXIT_FAILURE;
                            }

                            StringCopyW(wszPatternString, szTempPath + 1, GetBufferSize(wszPatternString) / sizeof(WCHAR));
                            if(EXIT_FAILURE == RemoveStarFromPattern(wszPatternString))
                            {
                                if( TRUE == bCloseConnection )
                                {
                                    CloseConnection( szMachineName );
                                }
                                FREE_MEMORY(szMachineName);
                                FREE_MEMORY(szUserName);
                                FREE_MEMORY(szFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                FREE_MEMORY(wszPatternString);
                                ReleaseGlobals();
                                return EXIT_FAILURE;

                            }
                            szTempPath++;
                            *(szTempPath) = L'\0';
                            bDriveCurrDirTakeOwnAllFiles = TRUE;
                        }

                    }
                }
                else
                {
                    if(-1 != FindChar2((szTmpFileName), L'*', TRUE, 0) &&
                       (-1 == FindChar2((szTmpFileName + 1), L'?', TRUE, 0)))
                        {
                            bMatchPattern = TRUE;
                            wszPatternString = (LPWSTR)AllocateMemory((StringLengthW(szTmpFileName + 1, 0) + 10) * sizeof(WCHAR));
                            if(NULL == wszPatternString)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                if( TRUE == bCloseConnection )
                                {
                                    CloseConnection( szMachineName );
                                }
                                FREE_MEMORY(szMachineName);
                                FREE_MEMORY(szUserName);
                                FREE_MEMORY(szFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                ReleaseGlobals();
                                return EXIT_FAILURE;
                            }

                            StringCopyW(wszPatternString, szTmpFileName, GetBufferSize(wszPatternString) / sizeof(WCHAR));
                            if(EXIT_FAILURE == RemoveStarFromPattern(wszPatternString))
                            {
                                if( TRUE == bCloseConnection )
                                {
                                    CloseConnection( szMachineName );
                                }
                                FREE_MEMORY(szMachineName);
                                FREE_MEMORY(szUserName);
                                FREE_MEMORY(szFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                FREE_MEMORY(wszPatternString);
                                ReleaseGlobals();
                                return EXIT_FAILURE;

                            }

                            bCurrDirTakeOwnAllFiles = TRUE;
                        }

                }

            }
        }
    }
    
    
    if (1 == StringLengthW( szTmpFileName, 0 ) && 0 == StringCompare( szTmpFileName, WILDCARD, TRUE, 0 )) 
    {
        bCurrDirTakeOwnAllFiles = TRUE;
    }

    if((TRUE == bLocalSystem) && (FALSE == bCurrDirTakeOwnAllFiles))
    {
       if(wcspbrk(szTmpFileName,CHAR_SET) != NULL)
        {

            DISPLAY_MESSAGE( stderr, ERROR_PATH_NAME ) ;
            if( TRUE == bCloseConnection )
            {
                CloseConnection( szMachineName );
            }
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(wszPatternString);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    /*Get the full path in order to get the ownership for the specified file*/

    if((FALSE == bCurrDirTakeOwnAllFiles) || (bDriveCurrDirTakeOwnAllFiles == TRUE ))
    {

        dwi = GetFullPathName( szTmpFileName, 0, szFullPath,  &szFilePart );

        if( 0 == dwi )
        {
                                
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            if( TRUE == bCloseConnection )
            {
                CloseConnection( szMachineName );
            }
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(wszPatternString);
            ReleaseGlobals();
            return EXIT_FAILURE;

        }


     
     szFullPath = (LPWSTR)AllocateMemory((dwi+10) * sizeof(WCHAR));// an additional ten bytes are added for safe side in order to avoid unexpected results

     if(NULL == szFullPath)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            if( TRUE == bCloseConnection )
            {
                CloseConnection( szMachineName );
            }
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(wszPatternString);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }


     if( 0 == GetFullPathName( szTmpFileName,dwi+10, szFullPath, &szFilePart ))
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            if( TRUE == bCloseConnection )
            {
                CloseConnection( szMachineName );
            }
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(szFullPath);
            FREE_MEMORY(wszPatternString);
            ReleaseGlobals();
            return EXIT_FAILURE;

        }

     
      szDispFileName = (LPWSTR)AllocateMemory((dwi + MAX_STRING_LENGTH) * sizeof(WCHAR));

     if(NULL == szDispFileName)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            if( TRUE == bCloseConnection )
            {
                CloseConnection( szMachineName );
            }
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(szFullPath);
            FREE_MEMORY(wszPatternString);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }

     
     StringCopyW( szDispFileName, szFullPath, (GetBufferSize(szDispFileName) / sizeof(WCHAR)) );

    }
    /*Check whether the system is NTFS or not*/
    dwCnt = 0;

    //dwCnt = IsNTFSFileSystem(szDispFileName, bLocalSystem, bFileInUNCFormat, bCurrDirTakeOwnAllFiles, szUserName, &bNTFSFileSystem);
    dwCnt = IsNTFSFileSystem(szDispFileName, bLocalSystem, bCurrDirTakeOwnAllFiles, szUserName, &bNTFSFileSystem);
    if(EXIT_FAILURE == dwCnt )
    {
       
        if( TRUE == bCloseConnection )
        {
            CloseConnection( szMachineName );
        }

        FREE_MEMORY(szMachineName);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szFileName);
        FREE_MEMORY(szTemporaryFileName);
        FREE_MEMORY(szTmpFileName);
        FREE_MEMORY(szFullPath);
        FREE_MEMORY(szDispFileName);
        FREE_MEMORY(wszPatternString);
        ReleaseGlobals();

        return EXIT_FAILURE;
    }
   
    if(FALSE == bNTFSFileSystem)
    {
        ShowMessage(stderr, GetResString(IDS_FAT_VOLUME));
        if( TRUE == bCloseConnection )
        {
            CloseConnection( szMachineName );
        }

        FREE_MEMORY(szMachineName);
        FREE_MEMORY(szUserName);
        FREE_MEMORY(szFileName);
        FREE_MEMORY(szTemporaryFileName);
        FREE_MEMORY(szTmpFileName);
        FREE_MEMORY(szFullPath);
        FREE_MEMORY(szDispFileName);
        FREE_MEMORY(wszPatternString);
         ReleaseGlobals();
        return EXIT_FAILURE;
    }
  


    if(TRUE == bRecursive)
    {
        
        if( EXIT_FAILURE == TakeOwnerShipRecursive(szDispFileName, bCurrDirTakeOwnAllFiles, bAdminsOwner, szOwnerString,
                                              bTakeOwnAllFiles, bDriveCurrDirTakeOwnAllFiles, 
                                              bMatchPattern, wszPatternString, szConfirm))
        {
              
            if( TRUE == bCloseConnection )
            {
                CloseConnection( szMachineName );
            }
            
            FREE_MEMORY(szFullPath);
            FREE_MEMORY(szDispFileName);
            FREE_MEMORY(szMachineName);
            FREE_MEMORY(szUserName);
            FREE_MEMORY(szFileName);
            FREE_MEMORY(szTemporaryFileName);
            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(wszPatternString);
            ReleaseGlobals();

            return EXIT_FAILURE;
        }
    }
    else
    {
         //if filename is wildcard then give owner ship to all the files in
        //the current directory
        if( (TRUE == bCurrDirTakeOwnAllFiles) || (TRUE == bTakeOwnAllFiles ) ||(bDriveCurrDirTakeOwnAllFiles == TRUE))
        {

            /*Get the ownership for all the files in the specified directory*/
            
            bFlag = TakeOwnerShipAll(szDispFileName,bCurrDirTakeOwnAllFiles,&dwFileCount,bDriveCurrDirTakeOwnAllFiles,bAdminsOwner, szOwnerString, bMatchPattern, wszPatternString);

            if( FALSE == bFlag )
            {
                switch ( GetLastError() )
                    {
                        case ERROR_ACCESS_DENIED :

                                ShowMessage(stderr,GetResString(IDS_ACCESS_DENIED_ERROR));
                                /*ShowMessage( stderr, L"( \"" );
                                ShowMessage( stderr, _X(szDispFileName) );
                                ShowMessage( stderr, L"\" )\n" ); */
                                break;
                        case ERROR_BAD_NET_NAME :
                        case ERROR_BAD_NETPATH  :
                        case ERROR_INVALID_NAME :
                            SetLastError( ERROR_FILE_NOT_FOUND );
                            SaveLastError();
                        default :
                            if(FALSE == bMatchPattern)
                            {
                            
                                ShowMessage( stderr, ERROR_STRING );
                                ShowMessage( stderr, SPACE_CHAR );
                                ShowMessage( stderr, GetReason() );
                            }
                            else
                            {
                                ShowMessage( stdout, GetResString(IDS_NO_PATTERN_FOUND));
                            }

                    }

                    if( TRUE == bCloseConnection )
                    {
                        CloseConnection( szMachineName );
                    }

                    FREE_MEMORY(szFullPath);
                    FREE_MEMORY(szDispFileName);
                    FREE_MEMORY(szMachineName);
                    FREE_MEMORY(szUserName);
                    FREE_MEMORY(szFileName);
                    FREE_MEMORY(szTemporaryFileName);
                    FREE_MEMORY(szTmpFileName);
                    FREE_MEMORY(wszPatternString);

                    ReleaseGlobals();

                    return( EXIT_FAILURE );
               
            }
           

        }
        else // give ownership to the specified file
        {
            
            /*take the owner ship of the file specified for the administrators group or the current logged on user*/

            if(TRUE == bAdminsOwner)
            {
                bFlag = TakeOwnerShip( szDispFileName);

            }
            else
            {

                bFlag = TakeOwnerShipIndividual(szDispFileName);

            }

            if( FALSE == bFlag )
            {

                if( ERROR_NOT_ALL_ASSIGNED == GetLastError()  )
                {
                   
                    hr = StringCchPrintf(szDispFileName, (GetBufferSize(szDispFileName) / sizeof(WCHAR)), GetResString(IDS_NOT_OWNERSHIP_ERROR) , szFullPath);
                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                       if( TRUE == bCloseConnection )
                        {
                            CloseConnection( szMachineName );
                        }
             
                       FREE_MEMORY(szMachineName);
                       FREE_MEMORY(szUserName);
                       FREE_MEMORY(szFileName);
                       FREE_MEMORY(szTemporaryFileName);
                       FREE_MEMORY(szTmpFileName);
                       FREE_MEMORY(szFullPath);
                       FREE_MEMORY(szDispFileName);
                       FREE_MEMORY(wszPatternString);
                       ReleaseGlobals();
                       return( EXIT_FAILURE );
                    }

                    ShowMessage(stderr, szDispFileName);

                }
                else if(ERROR_SHARING_VIOLATION == GetLastError())
                {
                    
                    hr = StringCchPrintf(szDispFileName, (GetBufferSize(szDispFileName) / sizeof(WCHAR)), GetResString(IDS_SHARING_VIOLATION_ERROR) , szFullPath);
                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                       if( TRUE == bCloseConnection )
                        {
                            CloseConnection( szMachineName );
                        }
                       FREE_MEMORY(szMachineName);
                       FREE_MEMORY(szUserName);
                       FREE_MEMORY(szFileName);
                       FREE_MEMORY(szTemporaryFileName);
                       FREE_MEMORY(szTmpFileName);
                       FREE_MEMORY(szFullPath);
                       FREE_MEMORY(szDispFileName);
                       FREE_MEMORY(wszPatternString);
                       ReleaseGlobals();
                       return( EXIT_FAILURE );
                    }

                    ShowMessage(stderr, szDispFileName);

                }
                else
                {
                    if( ( ERROR_BAD_NET_NAME == GetLastError() ) ||
                            ( ERROR_BAD_NETPATH == GetLastError() ) ||
                            ( ERROR_INVALID_NAME == GetLastError() ) )
                    {
                        SetLastError( ERROR_FILE_NOT_FOUND );
                        SaveLastError();
                    }

                    ShowMessage( stderr, ERROR_STRING );
                    ShowMessage( stderr, SPACE_CHAR );
                    ShowMessage( stderr, GetReason() );
                }

                if( TRUE == bCloseConnection )
                {
                    CloseConnection( szMachineName );
                }
               
                FREE_MEMORY(szMachineName);
                FREE_MEMORY(szUserName);
                FREE_MEMORY(szFileName);
                FREE_MEMORY(szTemporaryFileName);
                FREE_MEMORY(szTmpFileName);
                FREE_MEMORY(szFullPath);
                FREE_MEMORY(szDispFileName);
                FREE_MEMORY(wszPatternString);
                ReleaseGlobals();
                //if connection is established to a remote machine close it

                return( EXIT_FAILURE );

            }
            else
            {

                if(TRUE == bAdminsOwner)
                {
                    
                    hr = StringCchPrintf(szDispFileName, (GetBufferSize(szDispFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL, szFullPath);
                    if(FAILED(hr))
                    {
                        SetLastError(HRESULT_CODE(hr));
                        SaveLastError();
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        if( TRUE == bCloseConnection )
                        {
                            CloseConnection( szMachineName );
                        }
                        FREE_MEMORY(szMachineName);
                        FREE_MEMORY(szUserName);
                        FREE_MEMORY(szFileName);
                        FREE_MEMORY(szTemporaryFileName);
                        FREE_MEMORY(szTmpFileName);
                        FREE_MEMORY(szFullPath);
                        FREE_MEMORY(szDispFileName);
                        FREE_MEMORY(wszPatternString);
                        ReleaseGlobals();
                        return( EXIT_FAILURE );
                    }
                }
                else
                {
                    
                    //hr = StringCchPrintf(szDispFileName, (GetBufferSize(szDispFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szOwnerString, szFullPath);
                    hr = StringCchPrintf(szDispFileName, (GetBufferSize(szDispFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szFullPath, szOwnerString);
                    if(FAILED(hr))
                    {
                        SetLastError(HRESULT_CODE(hr));
                        SaveLastError();
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        if( TRUE == bCloseConnection )
                        {
                            CloseConnection( szMachineName );
                        }
                        FREE_MEMORY(szMachineName);
                        FREE_MEMORY(szUserName);
                        FREE_MEMORY(szFileName);
                        FREE_MEMORY(szTemporaryFileName);
                        FREE_MEMORY(szTmpFileName);
                        FREE_MEMORY(szFullPath);
                        FREE_MEMORY(szDispFileName);
                        FREE_MEMORY(wszPatternString);
                        ReleaseGlobals();
                        return( EXIT_FAILURE );
                    }
                }

                ShowMessage( stdout, _X(szDispFileName) );

                if( TRUE == bCloseConnection )
                {
                    CloseConnection( szMachineName );
                }

                FREE_MEMORY(szMachineName);
                FREE_MEMORY(szUserName);
                FREE_MEMORY(szFileName);
                FREE_MEMORY(szTemporaryFileName);
                FREE_MEMORY(szTmpFileName);
                FREE_MEMORY(szFullPath);
                FREE_MEMORY(szDispFileName);
                FREE_MEMORY(wszPatternString);
                ReleaseGlobals();
                return( EXIT_SUCCESS );
            }

        }

    }

    //if connection is established to a remote machine close it
    if( TRUE == bCloseConnection )
    {
        CloseConnection( szMachineName );
    }

    FREE_MEMORY(szMachineName);
    FREE_MEMORY(szUserName);
    FREE_MEMORY(szFileName);
    FREE_MEMORY(szTemporaryFileName);
    FREE_MEMORY(szTmpFileName);
    FREE_MEMORY(szFullPath);
    FREE_MEMORY(szDispFileName);
    FREE_MEMORY(wszPatternString);
    ReleaseGlobals();
    return( EXIT_SUCCESS );
}


BOOL
ParseCmdLine(
    IN  DWORD   argc,
    IN  LPCWSTR argv[],
    OUT LPWSTR*  szMachineName,
    OUT LPWSTR*  szUserName,
    OUT LPWSTR*  szPassword,
    OUT LPWSTR*  szFileName,
    OUT BOOL    *pbUsage,
    OUT BOOL    *pbNeedPassword,
    OUT BOOL    *pbRecursive,
    OUT BOOL    *pbAdminsOwner,
    OUT LPWSTR  szConfirm
    )
/*++
Routine Description:
    This function parses the command line arguments which are obtained as input
    parameters and gets the values into the corresponding variables which are
    pass by reference parameters to this function.

Arguments:
    [ IN ]  argc           - Number of command line arguments.
    [ IN ]  argv           - Array containing command line arguments.
    [ OUT ] szMachineName  - To hold machine name.
    [ OUT ] szUserName     - To hold the User Name.
    [ OUT ] szPassword     - To hold the Password.
    [ OUT ] szFileName     - The filename whose attributes will be set.
    [ OUT ] pbUsage        - usage is mentioned at command line.
    [ OUT ] pbNeedPassword - To know whether the password is required or not.
    [ OUT ] pbRecursive    - To know whether it is recursive or not.
    [ OUT ] pbAdminsOwner  - to know whether ownership to be given for administrators group

Return Value:
    TRUE  if command parser succeeds.
    FALSE if command parser fails .
--*/
{
    //local varibles
    BOOL        bFlag = FALSE;
    TCMDPARSER2  tcmdOptions[MAX_OPTIONS];

    //command line options
    const WCHAR*   wszCmdOptionUsage     =    L"?" ;  //CMDOPTION_USAGE
    const WCHAR*   wszCmdOptionServer    =    L"S" ; //CMDOPTION_SERVER
    const WCHAR*   wszCmdOptionUser      =    L"U" ; //CMDOPTION_USER
    const WCHAR*   wszCmdOptionPassword  =    L"P" ; //CMDOPTION_PASSWORD
    const WCHAR*   wszCmdOptionFilename  =    L"F" ;  //CMDOPTION_FILENAME
    const WCHAR*   wszCmdOptionRecurse   =    L"R" ;  //CMDOPTION_RECURSE
    const WCHAR*   wszCmdOptionAdmin     =    L"A" ;  //CMDOPTION_ADMIN
    const WCHAR*   wszCmdOptionDefault   =    L"D" ; 
    
    WCHAR wszConfirmValues[MAX_CONFIRM_VALUE] ;

    SecureZeroMemory(wszConfirmValues, MAX_CONFIRM_VALUE * sizeof(WCHAR));

    StringCopy(wszConfirmValues,GetResString(IDS_YESNO),SIZE_OF_ARRAY(wszConfirmValues));
    


    //validate input parameters
    if( ( NULL == pbUsage )  || ( NULL == pbNeedPassword ) )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, ERROR_STRING );
        ShowMessage( stderr, SPACE_CHAR );
        ShowLastError( stderr );
        return FALSE;
    }


    //Initialize the valid command line arguments

    //  /s option
    StringCopyA( tcmdOptions[CMD_PARSE_SERVER].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_SERVER ].dwType = CP_TYPE_TEXT;
    tcmdOptions[ CMD_PARSE_SERVER ].pwszOptions = wszCmdOptionServer;
    tcmdOptions[ CMD_PARSE_SERVER ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_SERVER ].pwszValues = NULL;
    tcmdOptions[ CMD_PARSE_SERVER ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_SERVER ].dwActuals  = 0;
    tcmdOptions[ CMD_PARSE_SERVER ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_ALLOCMEMORY | CP2_VALUE_NONULL;
    tcmdOptions[ CMD_PARSE_SERVER ].pValue = NULL;
    tcmdOptions[ CMD_PARSE_SERVER ].dwLength    = 0;
    tcmdOptions[ CMD_PARSE_SERVER ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_SERVER ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_SERVER ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_SERVER ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_SERVER ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_SERVER ].pReserved3 = NULL;

    // /u option
    StringCopyA( tcmdOptions[CMD_PARSE_USER].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_USER ].dwType = CP_TYPE_TEXT;
    tcmdOptions[ CMD_PARSE_USER ].pwszOptions = wszCmdOptionUser;
    tcmdOptions[ CMD_PARSE_USER ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_USER ].pwszValues = NULL;
    tcmdOptions[ CMD_PARSE_USER ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_USER ].dwActuals  = 0;
    tcmdOptions[ CMD_PARSE_USER ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_ALLOCMEMORY | CP2_VALUE_NONULL;
    tcmdOptions[ CMD_PARSE_USER ].pValue = NULL;
    tcmdOptions[ CMD_PARSE_USER ].dwLength    = 0;
    tcmdOptions[ CMD_PARSE_USER ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_USER ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_USER ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_USER ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_USER ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_USER ].pReserved3 = NULL;

    // /p option
    StringCopyA( tcmdOptions[CMD_PARSE_PWD].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_PWD ].dwType = CP_TYPE_TEXT;
    tcmdOptions[ CMD_PARSE_PWD ].pwszOptions = wszCmdOptionPassword;
    tcmdOptions[ CMD_PARSE_PWD ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_PWD ].pwszValues = NULL;
    tcmdOptions[ CMD_PARSE_PWD ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_PWD ].dwActuals  = 0;
    tcmdOptions[ CMD_PARSE_PWD ].dwFlags = CP2_VALUE_OPTIONAL | CP2_ALLOCMEMORY;
    tcmdOptions[ CMD_PARSE_PWD ].pValue = NULL;
    tcmdOptions[ CMD_PARSE_PWD ].dwLength    = 0;
    tcmdOptions[ CMD_PARSE_PWD ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_PWD ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_PWD ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_PWD ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_PWD ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_PWD ].pReserved3 = NULL;

    // /? option
    StringCopyA( tcmdOptions[CMD_PARSE_USG].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_USG ].dwType = CP_TYPE_BOOLEAN;
    tcmdOptions[ CMD_PARSE_USG ].pwszOptions = wszCmdOptionUsage;
    tcmdOptions[ CMD_PARSE_USG ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_USG ].pwszValues = NULL;
    tcmdOptions[ CMD_PARSE_USG ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_USG ].dwActuals  = 0;
    tcmdOptions[ CMD_PARSE_USG ].dwFlags = CP2_USAGE;
    tcmdOptions[ CMD_PARSE_USG ].pValue = pbUsage;
    tcmdOptions[ CMD_PARSE_USG ].dwLength    = MAX_STRING_LENGTH;
    tcmdOptions[ CMD_PARSE_USG ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_USG ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_USG ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_USG ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_USG ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_USG ].pReserved3 = NULL;

    // /f name
    StringCopyA( tcmdOptions[CMD_PARSE_FN].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_FN ].dwType = CP_TYPE_TEXT;
    tcmdOptions[ CMD_PARSE_FN ].pwszOptions = wszCmdOptionFilename;
    tcmdOptions[ CMD_PARSE_FN ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_FN ].pwszValues = NULL;
    tcmdOptions[ CMD_PARSE_FN ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_FN ].dwActuals = 0;
    tcmdOptions[ CMD_PARSE_FN ].dwFlags = CP2_VALUE_TRIMINPUT | CP2_ALLOCMEMORY | CP2_VALUE_NONULL;
    tcmdOptions[ CMD_PARSE_FN ].pValue = NULL;
    tcmdOptions[ CMD_PARSE_FN ].dwLength    = 0;
    tcmdOptions[ CMD_PARSE_FN ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_FN ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_FN ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_FN ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_FN ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_FN ].pReserved3 = NULL;

    // /r option
    StringCopyA( tcmdOptions[CMD_PARSE_RECURSE].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_RECURSE ].dwType = CP_TYPE_BOOLEAN;
    tcmdOptions[ CMD_PARSE_RECURSE ].pwszOptions = wszCmdOptionRecurse;
    tcmdOptions[ CMD_PARSE_RECURSE ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_RECURSE ].pwszValues = NULL;
    tcmdOptions[ CMD_PARSE_RECURSE ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_RECURSE ].dwActuals  = 0;
    tcmdOptions[ CMD_PARSE_RECURSE ].dwFlags = 0;
    tcmdOptions[ CMD_PARSE_RECURSE ].pValue = pbRecursive;
    tcmdOptions[ CMD_PARSE_RECURSE ].dwLength    = MAX_STRING_LENGTH;
    tcmdOptions[ CMD_PARSE_RECURSE ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_RECURSE ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_RECURSE ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_RECURSE ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_RECURSE ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_RECURSE ].pReserved3 = NULL;

        // /a option
    StringCopyA( tcmdOptions[CMD_PARSE_ADMIN].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_ADMIN ].dwType = CP_TYPE_BOOLEAN;
    tcmdOptions[ CMD_PARSE_ADMIN ].pwszOptions = wszCmdOptionAdmin;
    tcmdOptions[ CMD_PARSE_ADMIN ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_ADMIN ].pwszValues = NULL;
    tcmdOptions[ CMD_PARSE_ADMIN ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_ADMIN ].dwActuals  = 0;
    tcmdOptions[ CMD_PARSE_ADMIN ].dwFlags = 0;
    tcmdOptions[ CMD_PARSE_ADMIN ].pValue = pbAdminsOwner;
    tcmdOptions[ CMD_PARSE_ADMIN ].dwLength    = MAX_STRING_LENGTH;
    tcmdOptions[ CMD_PARSE_ADMIN ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_ADMIN ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_ADMIN ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_ADMIN ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_ADMIN ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_ADMIN ].pReserved3 = NULL;

    StringCopyA( tcmdOptions[CMD_PARSE_CONFIRM].szSignature, "PARSER2\0", 8 );
    tcmdOptions[ CMD_PARSE_CONFIRM ].dwType = CP_TYPE_TEXT;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pwszOptions = wszCmdOptionDefault;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pwszFriendlyName = NULL;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pwszValues = wszConfirmValues;
    tcmdOptions[ CMD_PARSE_CONFIRM ].dwCount = 1;
    tcmdOptions[ CMD_PARSE_CONFIRM ].dwActuals  = 0;
    tcmdOptions[ CMD_PARSE_CONFIRM ].dwFlags = CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pValue = szConfirm;
    tcmdOptions[ CMD_PARSE_CONFIRM ].dwLength    = MAX_CONFIRM_VALUE;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pFunction = NULL;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pFunctionData = NULL;
    tcmdOptions[ CMD_PARSE_CONFIRM ].dwReserved = 0;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pReserved1 = NULL;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pReserved2 = NULL;
    tcmdOptions[ CMD_PARSE_CONFIRM ].pReserved3 = NULL;

    //parse the command line arguments
    bFlag = DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY( tcmdOptions ), tcmdOptions, 0 );

    //if syntax of command line arguments is false display the error and exit
    if( FALSE == bFlag )
    {

        ShowMessage( stderr, ERROR_STRING );
        ShowMessage( stderr, SPACE_CHAR );
        ShowMessage( stderr, GetReason() );
        return( FALSE );
    }
    
    *szMachineName = (LPWSTR)tcmdOptions[CMD_PARSE_SERVER].pValue;
    *szUserName = (LPWSTR)tcmdOptions[CMD_PARSE_USER].pValue;
    *szPassword = (LPWSTR)tcmdOptions[CMD_PARSE_PWD].pValue;
    *szFileName = (LPWSTR)tcmdOptions[CMD_PARSE_FN].pValue;


    // remove trialing spaces
    
    //if usage is specified at command line, then check whether any other
    //arguments are entered at the command line and if so display syntax
    //error
    if( TRUE == *pbUsage )
    {
        if( argc > 2 )
        {
            ShowMessage( stderr, ERROR_SYNTAX_ERROR );
            return( FALSE );
        }
        else
        {
            return (TRUE);
        }
    }

    // check whether the password (-p) specified in the command line or not
    // and also check whether '*' or empty is given for -p or not
    // check the remote connectivity information
    if ( *szMachineName != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name 
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails 
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password 
        // before trying to connect
        //
        // case 3: -p * is specified
        
        // user name
        if ( *szUserName == NULL )
        {
            *szUserName = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *szUserName == NULL )
            {
                
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                return( FALSE );
            }
        }

        // password
        if ( *szPassword == NULL )
        {
            *pbNeedPassword = TRUE;
            *szPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *szPassword == NULL )
            {
                
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                return( FALSE );
            }
        }

        // case 1
        /*if ( cmdOptions[OPTION_PASSWORD].dwActuals == 0 )
        {
            // we need not do anything special here
        }*/
        if ( tcmdOptions[CMD_PARSE_PWD].pValue == NULL )
            {
                StringCopy( *szPassword, L"*", GetBufferSize((LPVOID)(*szPassword)));
            }
         else 
           if ( StringCompareEx( *szPassword, L"*", TRUE, 0 ) == 0 )
            {
                if ( ReallocateMemory( (LPVOID*)(szPassword), 
                                       MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
                {
                    
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    return( FALSE );
                }
                else
                    if(NULL == szPassword)
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        return( FALSE );
                    }

                // ...
                *pbNeedPassword = TRUE;
            }

        // case 3
       
    }


    if((0 != tcmdOptions[ CMD_PARSE_CONFIRM ].dwActuals ) && (0 == tcmdOptions[ CMD_PARSE_RECURSE ].dwActuals ) )
    {
        ShowMessage( stderr, GetResString(IDS_CONFIRM_ERROR ));
        return( FALSE );
    }

    
    if( (StringLengthW(*szFileName, 0) == 0 ) && (0 != tcmdOptions[ CMD_PARSE_FN ].dwActuals ) )
    {
        ShowMessage( stderr, GetResString(IDS_NULL_FILENAME ));
        return( FALSE );
    }

    //if default argument is not speciifed
    if( ( 0 == tcmdOptions[ CMD_PARSE_FN ].dwActuals ) &&
                            ( FALSE == *pbUsage  ) )
    {
        ShowMessage( stderr, ERROR_SYNTAX_ERROR );
        return( FALSE );
    }

    // return false if username is entered without machine name
    if ( ( 0 != tcmdOptions[ CMD_PARSE_USER ].dwActuals ) &&
                ( 0 == tcmdOptions[ CMD_PARSE_SERVER ].dwActuals ) )
    {
        ShowMessage( stderr, ERROR_USER_WITH_NOSERVER );
        return( FALSE );
    }

    //if password entered without username then return false
    if( ( 0 == tcmdOptions[ CMD_PARSE_USER ].dwActuals ) &&
                ( 0 != tcmdOptions[ CMD_PARSE_PWD ].dwActuals ) )
    {
        ShowMessage( stderr, ERROR_PASSWORD_WITH_NUSER );
        return( FALSE );
    }

    //if /s is entered with empty string
    if( ( 0 != tcmdOptions[ CMD_PARSE_SERVER ].dwActuals != 0 ) &&
                                      ( 0 == StringLengthW( *szMachineName, 0 ) ) )
                                    //( 0 == lstrlen( szMachineName ) ) )
    {
        ShowMessage( stderr, ERROR_NULL_SERVER );
        return( FALSE );
    }

    //if /u is entered with empty string
    if( ( 0 != tcmdOptions[ CMD_PARSE_USER ].dwActuals ) &&
                                      ( 0 == StringLengthW( *szUserName, 0 ) ) )
                                    
    {
        ShowMessage( stderr, ERROR_NULL_USER );
        return( FALSE );
    }

    //assign the data obtained from parsing to the call by address parameters

     
    if ( ( 0 != tcmdOptions[ CMD_PARSE_PWD ].dwActuals ) &&
                      ( 0 == StringCompare( *szPassword, L"*", TRUE, 0 ) ) )

    {
        // user wants the utility to prompt for the password before trying to connect
        *pbNeedPassword = TRUE;
    }
    else if ( 0 == tcmdOptions[ CMD_PARSE_PWD ].dwActuals &&
            ( 0 != tcmdOptions[ CMD_PARSE_SERVER ].dwActuals || 0 != tcmdOptions[ CMD_PARSE_USER ].dwActuals ) )
    {
        // /s, /u is specified without password ...
        // utility needs to try to connect first and if it fails then prompt for the password
        *pbNeedPassword = TRUE;
        
        StringCopyW( *szPassword, NULL_U_STRING, GetBufferSize(*szPassword) / sizeof(WCHAR));
    }

    return( TRUE );
}

VOID
DisplayUsage(
    )
/*++
Routine Description:
    This function displays the usage of takeown utility.

Arguments:
    None.

Return Value:
    VOID
--*/
{
    DWORD dwIndex = 0;
    //redirect the usage to the console
    for( dwIndex = IDS_USAGE_BEGINING; dwIndex <= IDS_USAGE_ENDING; dwIndex++ )
    {
        ShowMessage( stdout, GetResString( dwIndex ) );
    }
    return;
}

BOOL
TakeOwnerShip(
    IN LPCWSTR lpszFileName
    )
/*++
Routine Description:
    This routine takes the ownership of the specified file

Arguments:
    [ IN ] lpszFileName - File name for whose ownership has to be taken.

Return Value:
    TRUE if owner ship of the specified file has been taken
    else FALSE
--*/
{
    //local variables
    SECURITY_DESCRIPTOR        SecurityDescriptor;
    PSECURITY_DESCRIPTOR       pSd = NULL;
    PACL                       pDacl;
    HANDLE                     hFile;
    PSID                       pAliasAdminsSid = NULL;
    SID_IDENTIFIER_AUTHORITY   SepNtAuthority = SECURITY_NT_AUTHORITY;

    HANDLE  hTokenHandle = NULL;
    BOOL    bResult = TRUE;
    BOOL    bInvalidFileHandle = FALSE;

    //check for valid input parameters
    if( lpszFileName == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    //allocate and initialise sid
    bResult = AllocateAndInitializeSid(
                 &SepNtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &pAliasAdminsSid
                 );
    if( FALSE == bResult )
    {
        SaveLastError();
        return( FALSE );
    }

    //get the token of the current process
    bResult = GetTokenHandle( &hTokenHandle );
    if( FALSE == bResult )
    {
        SaveLastError();
        if(NULL != pAliasAdminsSid)
        {
            FreeSid( pAliasAdminsSid );
        }
        return( FALSE );
    }


    // Attempt to put a NULL Dacl on the object
    bResult = InitializeSecurityDescriptor( &SecurityDescriptor,
                                            SECURITY_DESCRIPTOR_REVISION );
    if( FALSE == bResult )
    {
        SaveLastError();
        if(NULL != pAliasAdminsSid)
        {
            FreeSid( pAliasAdminsSid );
        }
        if( 0 == CloseHandle( hTokenHandle ))
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        }
        return( FALSE );
    }
    //Get the handle of the file or directory
    hFile = CreateFile( lpszFileName, READ_CONTROL , FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );

    //try once again it may be a directory
    if( INVALID_HANDLE_VALUE != hFile )
    {
        //get the DACL for the currently existing file or directory
        if( 0 != GetSecurityInfo( hFile, SE_FILE_OBJECT,  DACL_SECURITY_INFORMATION, NULL,
                                  NULL, &pDacl, NULL, &pSd ) )
        {

            SaveLastError();

            if(NULL != pAliasAdminsSid)
            {
                FreeSid( pAliasAdminsSid );
            }

            CloseHandle( hFile );


            if(0 == CloseHandle( hTokenHandle ))
            {
                
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            }

            if(NULL != pSd)
            {
                LocalFree( pSd );
            }

            return( FALSE );
        }

        // set the security descriptor to acl
        bResult = SetSecurityDescriptorDacl ( &SecurityDescriptor,
                                                    TRUE, pDacl, FALSE );
        if( FALSE == bResult )
        {
            SaveLastError();

            if(NULL != pAliasAdminsSid)
            {
                FreeSid( pAliasAdminsSid );
            }

            CloseHandle( hFile );

            if(0 == CloseHandle( hTokenHandle ))
            {
                
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            }

            if(NULL != pSd)
            {
                LocalFree( pSd );
            }

            return( FALSE );
        }
    }
    else
    {
        bInvalidFileHandle = TRUE;
        
    }

    // Attempt to make Administrator the owner of the file.

    bResult = SetSecurityDescriptorOwner ( &SecurityDescriptor,
                                            pAliasAdminsSid, FALSE );

   

    if( FALSE == bResult )
    {
        SaveLastError();

        if(NULL != pAliasAdminsSid)
        {
            FreeSid( pAliasAdminsSid );
        }

        CloseHandle( hFile );

        if(0 == CloseHandle( hTokenHandle ))
        {
            //DisplayErrorMsg(GetLastError());
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        }

        if(NULL != pSd)
        {
            LocalFree( pSd );
        }

        return( FALSE );
    }

    //set the file security to adminsitrator owner
    bResult = SetFileSecurity( lpszFileName, OWNER_SECURITY_INFORMATION,
                                                    &SecurityDescriptor );

    if( TRUE == bResult )
    {

        if(NULL != pAliasAdminsSid)
        {
            FreeSid( pAliasAdminsSid );
        }

        CloseHandle( hFile );

        if(0 == CloseHandle( hTokenHandle ))
        {
            //DisplayErrorMsg(GetLastError());
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        }

        if(NULL != pSd)
        {
            LocalFree( pSd );
        }
        return( TRUE );
    }

     // Assert TakeOwnership privilege for current process, then try again
     bResult = AssertTakeOwnership( hTokenHandle );

     if( FALSE == bResult )
     {
        //SaveLastError();
        if(TRUE == bInvalidFileHandle)
        {
            hFile = CreateFile( lpszFileName, READ_CONTROL , FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
            if( INVALID_HANDLE_VALUE == hFile )
            {
                SaveLastError();

                if(NULL != pAliasAdminsSid)
                {
                    FreeSid( pAliasAdminsSid );
                }

                //CloseHandle( hFile );

                if(0 == CloseHandle( hTokenHandle ))
                {
                    //DisplayErrorMsg(GetLastError());
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                }
                return( FALSE );
            }
        }



        if(NULL != pAliasAdminsSid)
        {
            FreeSid( pAliasAdminsSid );
        }

        CloseHandle( hFile );

        if(0 == CloseHandle( hTokenHandle ))
        {
            //DisplayErrorMsg(GetLastError());
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        }

        if(NULL != pSd)
        {
            LocalFree( pSd );
        }
        return( FALSE );
     }

    //Now try to set ownership security privilege for the file
     bResult = SetFileSecurity( lpszFileName, OWNER_SECURITY_INFORMATION,
                                        &SecurityDescriptor );
    if( FALSE == bResult )
     {
        SaveLastError();
        if(TRUE == bInvalidFileHandle)
        {
            //Check out whether it is an invalid file or file does not exist
            hFile = CreateFile( lpszFileName, READ_CONTROL , FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
            if( INVALID_HANDLE_VALUE == hFile )
            {
                SaveLastError();

                if(NULL != pAliasAdminsSid)
                {
                    FreeSid( pAliasAdminsSid );
                }

                //CloseHandle( hFile );

                if(0 == CloseHandle( hTokenHandle ))
                {
                    //DisplayErrorMsg(GetLastError());
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                }
                return( FALSE );
            }
        }

         if(NULL != pAliasAdminsSid)
        {
            FreeSid( pAliasAdminsSid );
        }

        CloseHandle( hFile );

        if(0 == CloseHandle( hTokenHandle ))
        {
            //DisplayErrorMsg(GetLastError());
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        }

        if(NULL != pSd)
        {
            LocalFree( pSd );
        }

        return( FALSE );
     }

    if(NULL != pAliasAdminsSid)
    {
        FreeSid( pAliasAdminsSid );
    }

    
    CloseHandle( hFile );

    if(0 == CloseHandle( hTokenHandle ))
    {
        //DisplayErrorMsg(GetLastError());
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
    }

    if(NULL != pSd)
    {
        LocalFree( pSd );
    }

    return( TRUE );
}

BOOL
GetTokenHandle(
    OUT PHANDLE hTokenHandle
    )
/*++
Routine Description:
    Get the token handle of the current process.

Arguments:
    [ OUT ] hTokenHandle - handle to the current token.

Return Value:
    TRUE if successful in getting the token
    else FALSE
--*/
{
    //local variables
    BOOL   bFlag = TRUE;
    HANDLE hProcessHandle = NULL;

    //check for valid input arguments
    if( hTokenHandle == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    //open the current process
    hProcessHandle = OpenProcess( PROCESS_QUERY_INFORMATION,
                        FALSE, GetCurrentProcessId() );

    //if unable to open the current process
    if ( NULL == hProcessHandle )
    {
        SaveLastError();
        return( FALSE );
    }

    //open the token of the current process
    bFlag = OpenProcessToken ( hProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 hTokenHandle );

    if ( FALSE == bFlag )
    {
        SaveLastError();
        CloseHandle( hProcessHandle );
        return FALSE;
    }
    if( 0 == CloseHandle( hProcessHandle ))
    {
        //DisplayErrorMsg(GetLastError());
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
    }
    return( TRUE );
}

BOOL
AssertTakeOwnership(
    IN HANDLE hTokenHandle
    )
/*++
Routine Description:
    This routine asserts the takeownership privilege to the current process

Arguments:
    [ IN ] hTokenHandle - Token handle of the current process.

Return Value:
    TRUE if successful in asserting the takeownership privilege to current process
    else FALSE
--*/
{
    //local variables
    LUID TakeOwnershipValue;
    TOKEN_PRIVILEGES TokenPrivileges;
    BOOL bResult = TRUE;


    //check for valid input arguments
    if( hTokenHandle == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // First, assert TakeOwnership privilege
    bResult = LookupPrivilegeValue( NULL, SE_TAKE_OWNERSHIP_NAME,
                                    &TakeOwnershipValue );
    if ( FALSE == bResult )
    {
        SaveLastError();
        return( FALSE );
    }

    // Set up the privilege set we will need
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = TakeOwnershipValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //adjust the privlige to this new privilege
    (VOID) AdjustTokenPrivileges (
                hTokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                NULL,
                NULL
                );

    if ( NO_ERROR != GetLastError() )
    {
        SaveLastError();
        return( FALSE );
    }
    return( TRUE );
}

BOOL
TakeOwnerShipAll(IN LPWSTR  lpszFileName,
                 IN BOOL bCurrDirTakeOwnAllFiles,
                 IN PDWORD  dwFileCount,
                 IN BOOL bDriveCurrDirTakeOwnAllFiles,
                 IN BOOL bAdminsOwner,
                 IN LPWSTR  szOwnerString,
                 BOOL bMatchPattern,
                 LPWSTR wszPatternString)


/*++
Routine Description:
    This routine takes the owner ship of the all the files in the
    current directory

Arguments:
     [ IN ]  lpszFileName                    : The path name to which ownership for the files in the path to be given
     [ IN ]  bCurrDirTakeOwnAllFiles         : To determine whether ownership to be given for current directory files
     [ IN ]  dwFileCount                     : To determine whether there is not even a sigle file found in the specified path
     [ IN ]  bDriveCurrDirTakeOwnAllFiles    : To determine whether ownership to be given for files specified in the path
     [ IN ]  bAdminsOwner                    : To ddetermine whether ownership to be given for administrators group
     [ IN ]  dwUserName                      : Logged on user name
     [ IN ]  szOwnerString                   : Logged on user name in Sam Compatible format
     [ IN ]  bLogonDomainAdmin               : Indicates whether the logged on user is domain administrator or not


Return Value:
    TRUE if owner ship of the files in the current directory is successful
    else FALSE
--*/
{
    //local variables
    WIN32_FIND_DATA FindFileData;
    BOOL  bFlag = TRUE;
    DWORD dwRet = 0;
    HANDLE hHandle = NULL;
    WCHAR szFileName[MAX_RES_STRING + 3*EXTRA_MEM] ;
    WCHAR wszTempMessage[3*MAX_STRING_LENGTH] ;

    LPWSTR szDir = NULL;
    LPWSTR szTakeownFile = NULL;
    LPWSTR szTmpFileName = NULL;
    LPWSTR  wszFormedMessage = NULL;
    LPWSTR lpNextTok = NULL;
    //LPWSTR szDirStart  = NULL;
    HRESULT hr;
    

    

    SecureZeroMemory(szFileName, (MAX_RES_STRING + 3*EXTRA_MEM) * sizeof(WCHAR));
    SecureZeroMemory(wszTempMessage, (3 * MAX_STRING_LENGTH) * sizeof(WCHAR));

    if(FALSE == bCurrDirTakeOwnAllFiles)
    {
        
        //ASSIGN_MEMORY(szDir,WCHAR,(StringLengthW(lpszFileName, 0)) + 20);
        szDir = (LPWSTR)AllocateMemory((StringLengthW(lpszFileName, 0) + 20) * sizeof(WCHAR));
        if(NULL == szDir)
        {
            SaveLastError();
            return FALSE;
        }

        
        szTakeownFile = (LPWSTR)AllocateMemory((StringLengthW(lpszFileName, 0) + MAX_STRING_LENGTH + 20) * sizeof(WCHAR));
        if(NULL == szTakeownFile)
        {
            SaveLastError();
            FREE_MEMORY(szDir);
            return FALSE;
        }

        szTmpFileName = (LPWSTR)AllocateMemory((StringLengthW(lpszFileName, 0) + (2 * MAX_STRING_LENGTH) + 20) * sizeof(WCHAR));
        if(NULL == szTmpFileName)
        {
            SaveLastError();
            FREE_MEMORY(szDir);
            FREE_MEMORY(szTakeownFile);
            return FALSE;
        }
    }

    if(TRUE == bCurrDirTakeOwnAllFiles)
    {
        dwRet = GetCurrentDirectory( 0, szDir );
        if( 0 == dwRet )
        {
            SaveLastError();
            return FALSE;
        }

        
        szDir = (LPWSTR)AllocateMemory((dwRet + 20) * sizeof(WCHAR));
        if(NULL == szDir)
        {
            SaveLastError();
            return FALSE;
        }

        dwRet = GetCurrentDirectory( dwRet + 20, szDir );
        if( 0 == dwRet )
        {
            SaveLastError();
            FREE_MEMORY(szDir);
            return FALSE;
        }

        szTakeownFile = (LPWSTR)AllocateMemory((StringLengthW(szDir, 0)  + MAX_STRING_LENGTH + 20) * sizeof(WCHAR));
        
        if(NULL == szTakeownFile)
        {
            SaveLastError();
            FREE_MEMORY(szDir);
            return FALSE;
        }

        szTmpFileName = (LPWSTR)AllocateMemory((StringLengthW(szDir, 0)  + (2 * MAX_STRING_LENGTH) + 20) * sizeof(WCHAR));
        if(NULL == szTmpFileName)
        {
            SaveLastError();
            FREE_MEMORY(szDir);
            FREE_MEMORY(szTakeownFile);
            return FALSE;
        }
    }
    else
    {

        StringCopy( szDir, lpszFileName, (GetBufferSize(szDir) / sizeof(WCHAR)) );

    }
    /*Attach "*.*" at the end of the path to get all the files*/

    
    if(StringLengthW(szDir, 0) != 0 && FALSE == bMatchPattern)
    {
        if( *(szDir + StringLengthW(szDir, 0) - 1) != L'\\' )
        {
            
            StringConcat(szDir, ALL_FILES, GetBufferSize(szDir)/sizeof(TCHAR));
        }
        else
        {

            StringConcat(szDir,L"*.*" , (GetBufferSize(szDir) / sizeof(WCHAR)));
        }
    }
    else
    {
        StringConcat(szDir, L"\\", (GetBufferSize(szDir) / sizeof(WCHAR)));
        StringConcat(szDir, wszPatternString, (GetBufferSize(szDir) / sizeof(WCHAR)));
    }

    if( INVALID_HANDLE_VALUE != ( hHandle = FindFirstFile( szDir, &FindFileData ) ) )
    {
        
        StringCopy( szFileName, FindFileData.cFileName, SIZE_OF_ARRAY(szFileName) );
        

        if( ( 0 != StringCompare( szFileName, DOT, TRUE, 0 ) ) &&
                        ( 0 != StringCompare( szFileName, DOTS, TRUE, 0 ) ) )
        {
                (*dwFileCount)= (*dwFileCount) + 1;

                if(FALSE == bCurrDirTakeOwnAllFiles && FALSE == bDriveCurrDirTakeOwnAllFiles)
                {
                    
                    hr = StringCchPrintf(szTakeownFile, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)), L"%s%s", lpszFileName,szFileName);
                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                       FREE_MEMORY(szDir);
                       FREE_MEMORY(szTakeownFile);
                       FREE_MEMORY(szTmpFileName);
                       return FALSE;
                    }

                }
               else
                if(TRUE == bCurrDirTakeOwnAllFiles)
                {
                    
                    StringCopy( szTakeownFile, szFileName, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)) );
                }
                else
                {
                    if( *(lpszFileName + StringLengthW(lpszFileName, 0) - 1) != L'\\' )
                    {
                        hr = StringCchPrintf(szTakeownFile, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)), L"%s\\%s", lpszFileName,szFileName);
                    }
                    else
                    {
                        hr = StringCchPrintf(szTakeownFile, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)), L"%s%s", lpszFileName,szFileName);
                    }
                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                       FREE_MEMORY(szDir);
                       FREE_MEMORY(szTakeownFile);
                       FREE_MEMORY(szTmpFileName);
                       return FALSE;
                    }
                }
                
                if(TRUE == bAdminsOwner)
                {
                    bFlag = TakeOwnerShip( szTakeownFile);
                }
                else
                {
                    
                    bFlag = TakeOwnerShipIndividual(szTakeownFile);
                }

            if( FALSE == bFlag )
            {
                if( ERROR_NOT_ALL_ASSIGNED == GetLastError()) 
                {
                    
                    hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), GetResString(IDS_NOT_OWNERSHIP_INFO), szTakeownFile);
                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               
                       FREE_MEMORY(szDir);
                       FREE_MEMORY(szTakeownFile);
                       FREE_MEMORY(szTmpFileName);
                       return( FALSE );
                    }

                    ShowMessage(stdout, szTmpFileName);
                }
                else if(ERROR_SHARING_VIOLATION == GetLastError())
                {
                    
                    hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), GetResString(IDS_SHARING_VIOLATION_INFO) , szTakeownFile);
                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               
                       FREE_MEMORY(szDir);
                       FREE_MEMORY(szTakeownFile);
                       FREE_MEMORY(szTmpFileName);
                       return( FALSE );
                    }

                    ShowMessage(stdout, szTmpFileName);
                }
                else
                {
                    
                    wszFormedMessage = (LPWSTR)AllocateMemory((StringLengthW(szTakeownFile, 0)  + MAX_STRING_LENGTH) * sizeof(WCHAR));
                    
                    if ( wszFormedMessage == NULL )
                    {
                        SaveLastError();
                        FREE_MEMORY(szDir);
                        FREE_MEMORY(szTakeownFile);
                        FREE_MEMORY(szTmpFileName);
                        return( FALSE );
                    }

                    ShowMessage( stderr, ERROR_STRING );
                    ShowMessage( stderr, SPACE_CHAR );
                    //lstrcpy(wszTempMessage, GetReason());
                    StringCopy( wszTempMessage, GetReason(), SIZE_OF_ARRAY(wszTempMessage) );
                    lpNextTok = _tcstok(wszTempMessage, L".");
                    ShowMessage(stdout,wszTempMessage);
                    
                    //hr = StringCchPrintf(wszFormedMessage, (GetBufferSize(wszFormedMessage) / sizeof(WCHAR)), GetResString(IDS_ON_FILE_FOLDER), szTakeownFile);
                    hr = StringCchPrintf(wszFormedMessage, (GetBufferSize(wszFormedMessage) / sizeof(WCHAR)), L". ( \"%s\" )\n", szTakeownFile);
                    if(FAILED(hr))
                    {
                        SetLastError(HRESULT_CODE(hr));
                        SaveLastError();
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        FREE_MEMORY(szDir);
                        FREE_MEMORY(szTakeownFile);
                        FREE_MEMORY(szTmpFileName);
                        return( FALSE );
                    }
                    ShowMessage(stderr, wszFormedMessage);
                    FREE_MEMORY(wszFormedMessage);
                }
            }
            else
            {
                if(TRUE == bAdminsOwner)
                {
                    hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL, szTakeownFile);
                    if(FAILED(hr))
                    {
                        SetLastError(HRESULT_CODE(hr));
                        SaveLastError();
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        FREE_MEMORY(szDir);
                        FREE_MEMORY(szTakeownFile);
                        FREE_MEMORY(szTmpFileName);
                        return( FALSE );
                    }
                }
                else
                {
                    
                    //hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szOwnerString, szTakeownFile);
                    hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szTakeownFile, szOwnerString);
                    if(FAILED(hr))
                    {
                        SetLastError(HRESULT_CODE(hr));
                        SaveLastError();
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        FREE_MEMORY(szDir);
                        FREE_MEMORY(szTakeownFile);
                        FREE_MEMORY(szTmpFileName);
                        return( FALSE );
                    }
                }

                ShowMessage( stdout, _X(szTmpFileName) );
            }
        }

        bFlag = FindNextFile( hHandle, &FindFileData );
        while( TRUE == bFlag )
        {
            //lstrcpy( szFileName, FindFileData.cFileName );
            StringCopy( szFileName, FindFileData.cFileName, SIZE_OF_ARRAY(szFileName) );
            //if ( ( 0 != lstrcmp( szFileName, DOT ) ) &&
              //          ( 0 != lstrcmp( szFileName, DOTS ) ) )
              if ( ( 0 != StringCompare( szFileName, DOT, TRUE, 0 ) ) &&
                          ( 0 != StringCompare( szFileName, DOTS, TRUE, 0 ) ) )
            {
                (*dwFileCount)= (*dwFileCount) +1;
                if(FALSE == bCurrDirTakeOwnAllFiles && FALSE == bDriveCurrDirTakeOwnAllFiles)
                {
                    
                    hr = StringCchPrintf(szTakeownFile, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)), L"%s%s", lpszFileName,szFileName);
                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                       FREE_MEMORY(szDir);
                       FREE_MEMORY(szTakeownFile);
                       FREE_MEMORY(szTmpFileName);
                       return FALSE;
                    }

                }
                else
                if(TRUE == bCurrDirTakeOwnAllFiles)
                {
                    
                    StringCopy( szTakeownFile, szFileName, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)) );
                }
                else
                {
                    
                    if( *(lpszFileName + StringLengthW(lpszFileName, 0) - 1) != L'\\' )
                    {
                        hr = StringCchPrintf(szTakeownFile, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)), L"%s\\%s", lpszFileName,szFileName);
                    }
                    else
                    {
                        hr = StringCchPrintf(szTakeownFile, (GetBufferSize(szTakeownFile) / sizeof(WCHAR)), L"%s%s", lpszFileName,szFileName);
                    }

                    if(FAILED(hr))
                    {
                       SetLastError(HRESULT_CODE(hr));
                       SaveLastError();
                       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                       FREE_MEMORY(szDir);
                       FREE_MEMORY(szTakeownFile);
                       FREE_MEMORY(szTmpFileName);
                       return FALSE;
                    }
                }

                if(TRUE == bAdminsOwner)
                {
                    bFlag = TakeOwnerShip( szTakeownFile);
                }
                else
                {
                    
                    bFlag = TakeOwnerShipIndividual(szTakeownFile);
                }

                if( FALSE == bFlag )
                {

                    if( ( GetLastError() == ERROR_NOT_ALL_ASSIGNED  ))
                    {
                        
                        hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), GetResString(IDS_NOT_OWNERSHIP_INFO), szTakeownFile);
                        if(FAILED(hr))
                        {
                           SetLastError(HRESULT_CODE(hr));
                           SaveLastError();
                           ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               
                           FREE_MEMORY(szDir);
                           FREE_MEMORY(szTakeownFile);
                           FREE_MEMORY(szTmpFileName);
                           return( FALSE );
                        }

                        ShowMessage(stdout, szTmpFileName);

                    }
                    else if(ERROR_SHARING_VIOLATION == GetLastError())
                    {
                        
                        hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), GetResString(IDS_SHARING_VIOLATION_INFO), szTakeownFile);
                        if(FAILED(hr))
                        {
                           SetLastError(HRESULT_CODE(hr));
                           SaveLastError();
                           ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               
                           FREE_MEMORY(szDir);
                           FREE_MEMORY(szTakeownFile);
                           FREE_MEMORY(szTmpFileName);
                           return( FALSE );
                        }

                        ShowMessage(stdout, szTmpFileName);
                    }
                    else
                    {
                        if( ( ERROR_BAD_NET_NAME == GetLastError() ) ||
                                ( ERROR_BAD_NETPATH == GetLastError() ) ||
                                ( ERROR_INVALID_NAME == GetLastError() ) )
                        {
                            SetLastError( ERROR_FILE_NOT_FOUND );
                            SaveLastError();
                        }

                        
                        wszFormedMessage = (LPWSTR)AllocateMemory((StringLengthW(szTakeownFile, 0)  + MAX_STRING_LENGTH) * sizeof(WCHAR));
                        if ( wszFormedMessage == NULL )
                        {
                            SaveLastError();
                            FREE_MEMORY(szDir);
                            FREE_MEMORY(szTakeownFile);
                            FREE_MEMORY(szTmpFileName);
                            return( FALSE );
                        }

                        ShowMessage( stdout, L"\n" );
                        ShowMessage( stdout, TAG_INFORMATION );
                        ShowMessage( stdout, SPACE_CHAR );
                        
                        StringCopy( wszTempMessage, GetReason(), SIZE_OF_ARRAY(wszTempMessage) );
                        lpNextTok = _tcstok(wszTempMessage, L".");
                        ShowMessage(stdout,wszTempMessage);
                        
                        //hr = StringCchPrintf(wszFormedMessage, (GetBufferSize(wszFormedMessage) / sizeof(WCHAR)), GetResString(IDS_ON_FILE_FOLDER), szTakeownFile);
                        
                        hr = StringCchPrintf(wszFormedMessage, (GetBufferSize(wszFormedMessage) / sizeof(WCHAR)), L". ( \"%s\" )\n", szTakeownFile);
                        if(FAILED(hr))
                        {
                            SetLastError(HRESULT_CODE(hr));
                            SaveLastError();
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            FREE_MEMORY(szDir);
                            FREE_MEMORY(szTakeownFile);
                            FREE_MEMORY(szTmpFileName);
                            return( FALSE );
                        }
                        ShowMessage(stdout, wszFormedMessage);
                        FREE_MEMORY(wszFormedMessage);
                    }
                }
                else
                {
                    if(TRUE == bAdminsOwner)
                    {
                        
                        hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL, szTakeownFile);
                        if(FAILED(hr))
                        {
                            SetLastError(HRESULT_CODE(hr));
                            SaveLastError();
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            FREE_MEMORY(szDir);
                            FREE_MEMORY(szTakeownFile);
                            FREE_MEMORY(szTmpFileName);
                            return( FALSE );
                        }
                    }
                    else
                    {
                        
                        //hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szOwnerString, szTakeownFile);
                        hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szTakeownFile, szOwnerString);
                        if(FAILED(hr))
                        {
                            SetLastError(HRESULT_CODE(hr));
                            SaveLastError();
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            FREE_MEMORY(szDir);
                            FREE_MEMORY(szTakeownFile);
                            FREE_MEMORY(szTmpFileName);
                            return( FALSE );
                        }
                    }

                    ShowMessage( stdout, _X(szTmpFileName) );
                }
            }

            bFlag = FindNextFile( hHandle, &FindFileData );
        }
    }
    else
    {
        SaveLastError();
        FREE_MEMORY(szDir);
        FREE_MEMORY(szTakeownFile);
        FREE_MEMORY(szTmpFileName);
        return( FALSE );
    }

    if(0 == *dwFileCount)
    {
        if(FALSE == bMatchPattern)
        {
            ShowMessage( stdout, GetResString(IDS_NO_FILES_AVAILABLE));
        }
        else
        {
            ShowMessage( stdout, GetResString(IDS_NO_PATTERN_FOUND));
        }
    }

    CLOSE_FILE_HANDLE( hHandle ) ;
    FREE_MEMORY(szDir);
    FREE_MEMORY(szTakeownFile);
    FREE_MEMORY(szTmpFileName);
    return( TRUE );
}


DWORD
IsLogonDomainAdmin(IN LPWSTR szOwnerString,
                   OUT PBOOL pbLogonDomainAdmin)
/*++
   Routine Description:
    This function Checks whether the logged on user is domain administrator or not

   Arguments:
        [ IN ]   szOwnerString     : The logged on user
        [ OUT ]  pbLogonDomainAdmin: Indicates whether Domain admin or not

   Return Value:
        EXIT_FAIL :   On failure
        EXIT_SUCC :   On success
--*/

{
    WCHAR szSystemName[MAX_SYSTEMNAME] = NULL_U_STRING;
    WCHAR szOwnerStringTemp[(2 * MAX_STRING_LENGTH) + 5] = NULL_U_STRING;
    DWORD dwMemory = MAX_SYSTEMNAME;
    LPWSTR szToken = NULL;
    

    SecureZeroMemory(szSystemName, MAX_SYSTEMNAME * sizeof(WCHAR));
    SecureZeroMemory(szOwnerStringTemp, ((2 * MAX_STRING_LENGTH) + 5) * sizeof(WCHAR));

    StringCopy( szOwnerStringTemp, szOwnerString, SIZE_OF_ARRAY(szOwnerStringTemp) );

    if( 0 == GetComputerName(szSystemName,&dwMemory))
    {
        //DisplayErrorMsg(GetLastError());
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        return EXIT_FAIL;
    }

    szToken  = wcstok(szOwnerStringTemp,L"\\");

    if(NULL == szToken )
    {
        //DisplayErrorMsg(GetLastError());
        SetLastError(IDS_INVALID_USERNAME);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FAIL;
    }

    //if(lstrcmpi(szSystemName,szToken) == 0 )
    if(StringCompare( szSystemName, szToken, TRUE, 0 ) == 0 )
    {

        *pbLogonDomainAdmin = FALSE;
    }
    else
    {
        *pbLogonDomainAdmin = TRUE;
    }

   return EXIT_SUCC;
}


BOOL
TakeOwnerShipRecursive(IN LPWSTR  lpszFileName,
                       IN  BOOL bCurrDirTakeOwnAllFiles,
                       IN BOOL bAdminsOwner,
                       IN LPWSTR  szOwnerString,
                       IN BOOL bTakeOwnAllFiles,
                       IN BOOL bDriveCurrDirTakeOwnAllFiles,
                       IN BOOL bMatchPattern,
                       IN LPWSTR wszPatternString,
                       IN LPWSTR szConfirm)
/*++
   Routine Description:
    This function gives ownership recursively to all the files in the path specified

   Arguments:
        [ IN ]  lpszFileName           : The path to search the files recursively
        [ IN ]  bCurrDirTakeOwnAllFiles: Indicates current directory files or not
        [ IN ]  bAdminsOwner           : Indicates whether to give ownership to the administrators group
        [ IN ]  dwUserName             : Logged on user name
        [ IN ]  szOwnerString          : Logged on user name in Sam Compatible format
        [ IN ]  bLogonDomainAdmin      : Indicates whether the logged on user is domain administrator or not

   Return Value:
        EXIT_FAILURE :   On failure
        EXIT_SUCCESS :   On success
--*/

{
    DWORD dwRet = 0;
    DWORD dwSize = MAX_RES_STRING;
    BOOL bFlag = FALSE;

    
    //WCHAR szDir[2*MAX_STRING_LENGTH] = NULL_U_STRING;
    LPWSTR  szDir = NULL;
    LPWSTR szTempDirectory = NULL;
    DWORD dwRetval = 1;
    DWORD dwAttr = 1;
    HRESULT hr;
    BOOL bFilesNone = TRUE;
    
    if(FALSE == bCurrDirTakeOwnAllFiles )
    {
        dwAttr = GetFileAttributes(lpszFileName);
        if(0xffffffff == dwAttr)
        {
            if(ERROR_SHARING_VIOLATION == GetLastError())
            {
                ShowMessage(stderr,GetResString(IDS_INVALID_DIRECTORY));

            }
            else
            {
                //DisplayErrorMsg(GetLastError());
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            }
            return EXIT_FAILURE;
        }
        if( !(dwAttr&FILE_ATTRIBUTE_DIRECTORY) )
        {
            ShowMessage(stderr,GetResString(IDS_INVALID_DIRECTORY));

            return EXIT_FAILURE;

        }

        szDir = (LPWSTR)AllocateMemory((StringLengthW(lpszFileName, 0) + BOUNDARYVALUE) * sizeof(WCHAR));
        if(NULL == szDir)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return EXIT_FAILURE;
        }

        StringCopy( szDir, lpszFileName, GetBufferSize(szDir) / sizeof(WCHAR) );

        
    }
    else      //else if(TRUE == bCurrDirTakeOwnAllFiles)
    {
        szDir = (LPWSTR)AllocateMemory((MAX_PATH + BOUNDARYVALUE) * sizeof(WCHAR));
        if(NULL == szDir)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return EXIT_FAILURE;
        }
        dwRet = GetCurrentDirectory( dwSize, szDir );
        if( 0 == dwRet )
        {
            //DisplayErrorMsg(GetLastError());
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            
            FREE_MEMORY(szDir);
            return EXIT_FAILURE;
        }

    }

    if(FALSE == bCurrDirTakeOwnAllFiles && FALSE == bTakeOwnAllFiles && 
        FALSE == bDriveCurrDirTakeOwnAllFiles && FALSE == bMatchPattern)
    {

        szTempDirectory = (LPWSTR)AllocateMemory((StringLengthW(szDir, 0)  + (2 * MAX_STRING_LENGTH)) * sizeof(WCHAR));

        if(NULL == szTempDirectory)
        {
           //DisplayErrorMsg(GetLastError());
            FREE_MEMORY(szDir);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return EXIT_FAILURE;
        }


        if(TRUE == bAdminsOwner)
        {
            //bFlag = TakeOwnerShip( lpszFileName);
            bFlag = TakeOwnerShip( szDir);
        }
        else
        {
            
            bFlag = TakeOwnerShipIndividual(szDir);

        }

        if( FALSE == bFlag )
        {

            if( ERROR_NOT_ALL_ASSIGNED == GetLastError()) // || (ERROR_INVALID_HANDLE  == GetLastError()))
            {
                
                hr = StringCchPrintf(szTempDirectory, (GetBufferSize(szTempDirectory) / sizeof(WCHAR)), GetResString(IDS_NOT_OWNERSHIP_ERROR) , szDir);
                if(FAILED(hr))
                {
                   SetLastError(HRESULT_CODE(hr));
                   SaveLastError();
                   ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               
                   FREE_MEMORY(szTempDirectory);
                   FREE_MEMORY(szDir);
               
                   return( EXIT_FAILURE );
                }

                ShowMessage(stderr, szTempDirectory);

                FREE_MEMORY( szTempDirectory ) ;
                return EXIT_FAILURE;


            }
            else if(ERROR_SHARING_VIOLATION == GetLastError())
            {
                
                hr = StringCchPrintf(szTempDirectory, (GetBufferSize(szTempDirectory) / sizeof(WCHAR)), GetResString(IDS_SHARING_VIOLATION_ERROR) , szDir);
                if(FAILED(hr))
                {
                   SetLastError(HRESULT_CODE(hr));
                   SaveLastError();
                   ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               
                   FREE_MEMORY(szTempDirectory);
                   FREE_MEMORY(szDir);
               
                   return( EXIT_FAILURE );
                }

                ShowMessage(stderr, szTempDirectory);

                FREE_MEMORY( szTempDirectory ) ;
                FREE_MEMORY(szDir);
                return EXIT_FAILURE;

            }
            else
            {
                ShowMessage( stderr, ERROR_STRING );
                ShowMessage( stderr, SPACE_CHAR );
                ShowMessage( stderr, GetReason() );
                FREE_MEMORY( szTempDirectory ) ;
                FREE_MEMORY(szDir);
                return EXIT_FAILURE;

            }

        }
        else
        {

            if(TRUE == bAdminsOwner)
            {
                
                hr = StringCchPrintf(szTempDirectory, (GetBufferSize(szTempDirectory) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL, szDir);
                if(FAILED(hr))
                {
                    SetLastError(HRESULT_CODE(hr));
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    FREE_MEMORY( szTempDirectory ) ;
                    FREE_MEMORY(szDir);
                    return EXIT_FAILURE;
                }
            }
            else
            {
                //hr = StringCchPrintf(szTempDirectory, (GetBufferSize(szTempDirectory) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szOwnerString, szDir );
                hr = StringCchPrintf(szTempDirectory, (GetBufferSize(szTempDirectory) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szDir, szOwnerString);
                if(FAILED(hr))
                {
                    SetLastError(HRESULT_CODE(hr));
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    FREE_MEMORY( szTempDirectory ) ;
                    FREE_MEMORY(szDir);
                    return EXIT_FAILURE;
                }
            }

            ShowMessage( stdout, _X(szTempDirectory) );
            FREE_MEMORY( szTempDirectory ) ;

        }
    }

    if( TRUE == Push( szDir ) )
        { // Push the current directory .
           
           dwRetval = GetMatchedFiles( bAdminsOwner,szOwnerString, bMatchPattern, wszPatternString, &bFilesNone, szConfirm );

           if((TRUE == dwRetval) || (EXIT_CANCELED == dwRetval) )
            {
               if(TRUE == bFilesNone)
               {
                    if((TRUE == bCurrDirTakeOwnAllFiles || TRUE == bTakeOwnAllFiles || 
                        TRUE == bDriveCurrDirTakeOwnAllFiles) && FALSE == bMatchPattern)
                    {
                        ShowMessage(stdout, GetResString(IDS_NO_FILES_AVAILABLE));
                    }
                    else 
                        if((TRUE == bCurrDirTakeOwnAllFiles || TRUE == bTakeOwnAllFiles || 
                            TRUE == bDriveCurrDirTakeOwnAllFiles) && TRUE == bMatchPattern)
                        {
                            ShowMessage(stdout, GetResString(IDS_NO_PATTERN_FOUND));
                            
                        }

                    FREE_MEMORY(szDir);
                    return EXIT_SUCCESS ;
               }
               else
               {
                    //FREE_MEMORY( szTempDirectory ) ;
                    FREE_MEMORY(szDir);
                    return EXIT_SUCCESS ;
               }
            }
            else
            {
                //FREE_MEMORY( szTempDirectory ) ;
                FREE_MEMORY(szDir);
                return EXIT_FAILURE;
            }
        }
        else
        {
            //FREE_MEMORY( szTempDirectory ) ;
            FREE_MEMORY(szDir);
            return EXIT_FAILURE;
        }

    
}

DWORD GetMatchedFiles(IN BOOL bAdminsOwner,
                     IN LPWSTR  szOwnerString,
                     IN BOOL bMatchPattern,
                     IN LPWSTR wszPatternString,
                     IN OUT PBOOL pbFilesNone,
                     IN LPWSTR szConfirm)
                     
                     
/*++
   Routine Description:
    This function takes care of getting the files and giving the ownership

   Arguments:
        
        [ IN ]   bAdminsOwner           : Indicates whether to give ownership to the administrators group
        [ IN ]   szOwnerString          : Logged on user name in Sam Compatible format
        [ IN ]   bLogonDomainAdmin      : Indicates whether the logged on user is domain administrator or not
        [ IN ]   bMatchPattern          : Whether pattern matching exists
        [ IN ]   wszPatternString       : The pattern string used for pattern match
        [ IN ]   pbFilesNone            : Whether there are any files existing or not

   Return Value:
        EXIT_FAILURE :   On failure
        EXIT_SUCCESS :   On success
--*/

{
    //LPWSTR lpszSlashAvailLast = NULL;
    BOOL bACLChgPermGranted = FALSE;
    DWORD dwRetval = 1;
    LPWSTR lpszTempPathName = NULL;
    DWORD dwMem = 0;

    //ASSIGN_MEMORY( g_lpszFileToSearch , TCHAR , MAX_STRING_LENGTH ) ;
    g_lpszFileToSearch = (LPTSTR)AllocateMemory((MAX_STRING_LENGTH) * sizeof(WCHAR));
    if( NULL == g_lpszFileToSearch )
    {   // Memory allocation failed .

        ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
        return FALSE ;
    }

    lpszTempPathName = (LPWSTR)AllocateMemory((MAX_STRING_LENGTH) * sizeof(WCHAR));
    if( NULL == lpszTempPathName )
    {   // Memory allocation failed .

        ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
        FREE_MEMORY( g_lpszFileToSearch ) ;
        return FALSE ;
    }

        // Loop until data strycture( stack) has no item left in it .
    while( NULL != g_pPathName )
    {

        if( FALSE == Pop( ) )
        { // Control should come here only when linkedlist have no node to POP .
            FREE_MEMORY( g_lpszFileToSearch ) ; // Error message is already displayed .
            FREE_MEMORY( g_lpszFileToSearch ) ;
            return FALSE ;
        }

        
        dwMem = (StringLength(g_lpszFileToSearch, 0) + EXTRA_MEM ) * sizeof(WCHAR);
        if((DWORD)GetBufferSize(lpszTempPathName) < (dwMem))
        {
            if(FALSE == ReallocateMemory((LPVOID*)&lpszTempPathName,( dwMem) ))
            {
                               
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                FREE_MEMORY(lpszTempPathName);
                FREE_MEMORY( g_lpszFileToSearch ) ;
                return FALSE ;
            }
            else
                if(NULL == lpszTempPathName)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    FREE_MEMORY(lpszTempPathName);
                    FREE_MEMORY( g_lpszFileToSearch ) ;
                    return FALSE ;
                }
        }

        StringCopy( lpszTempPathName, g_lpszFileToSearch, GetBufferSize(lpszTempPathName) / sizeof(WCHAR) );

        
        if( *(g_lpszFileToSearch+StringLengthW(g_lpszFileToSearch, 0) - 1) != L'\\' )
        
        {
            
            StringConcat(g_lpszFileToSearch, _T( "\\" ), GetBufferSize(g_lpszFileToSearch)/sizeof(TCHAR));
        }

        
        StringConcat(g_lpszFileToSearch, _T( "*.*" ), GetBufferSize(g_lpszFileToSearch)/sizeof(TCHAR));

        /*Store all the subdirectories in the stack*/

        
        dwRetval = StoreSubDirectory( lpszTempPathName, &bACLChgPermGranted, szOwnerString, bMatchPattern, 
                                      wszPatternString, szConfirm, bAdminsOwner ) ;

        if(FAILURE == dwRetval )
        {
            FREE_MEMORY( g_lpszFileToSearch ) ;
            FREE_MEMORY(lpszTempPathName);
            return FALSE ;
        }
        else if( EXIT_CANCELED == dwRetval )
        {
            FREE_MEMORY( g_lpszFileToSearch ) ;
            FREE_MEMORY(lpszTempPathName);
            return EXIT_CANCELED ;
        }

        /*Get the ownership for the files or directories in the current folder only*/

        
        if( FALSE == GetOwnershipForFiles(lpszTempPathName,  bAdminsOwner, szOwnerString, 
                                          bMatchPattern, wszPatternString, pbFilesNone))
        {
            FREE_MEMORY( g_lpszFileToSearch ) ;
            FREE_MEMORY(lpszTempPathName);
            return FALSE ;
        }
    }

     FREE_MEMORY( g_lpszFileToSearch ) ;
     FREE_MEMORY(lpszTempPathName);
     return TRUE;
}


DWORD
StoreSubDirectory(IN LPTSTR lpszPathName,
                  IN PBOOL pbACLChgPermGranted, 
                  IN LPWSTR  szOwnerString,
                  IN BOOL bMatchPattern,
                  IN LPWSTR wszPatternString,
                  IN LPWSTR szConfirm,
                  IN BOOL bAdminsOwner)
                  
                  
/*++

Routine Description:

    Find and store subdirectories present in a directory matching criteria
    file was created between specified date or not .

Arguments:

    [ IN ] lpszPathName           : Contains path of a directory from where files matching
                                 a criteria are to be displayed .
    [ IN ] pbACLChgPermGranted    : To check whether ACLs has to be changed to give full permission.
    [ IN ] szOwnerString          : Logged on user name in Sam Compatible format.
    [ IN ] bLogonDomainAdmin      : Indicates whether the logged on user is domain administrator or not.
    [ IN ] bMatchPattern          : Whether pattern matching is supported or not
    [ IN ] wszPatternString       : The pattern string used for pattern matching 
    

Return value:

    SUCCESS       : On Success
    FAILURE       : On Failure
    EXIT_CANCELED : On Exiting Immediately

--*/

{
    HANDLE hFindFile ;
    WIN32_FIND_DATA  wfdFindFile ;
    HANDLE  hInput          = 0;// Stores the input handle device
    DWORD   dwBytesRead     = 0;// Stores number of byes read from console
    DWORD   dwMode          = 0;// Stores mode for input device
    BOOL    bSuccess        = FALSE; // Stores return value
    WCHAR chTmp[MAX_RES_STRING] ;
    WCHAR ch = NULL_U_CHAR;
    LPWSTR lpszDispMsg = NULL;
    LPWSTR lpszDispMsg2 = NULL;
    DWORD dwCount = 0;
    DWORD dwMem = 0;
    HRESULT hr;
    BOOL bNTFSFileSystem = FALSE;
    BOOL bIndirectionInputWithZeroLength = FALSE;
    BOOL bIndirectionInput = FALSE;
    //WCHAR szTemp[MAX_STRING_LENGTH] = NULL_U_STRING;
    LPWSTR lpszTempStr = NULL;

    
    SecureZeroMemory(chTmp, MAX_RES_STRING * sizeof( WCHAR ));
    
    SecureZeroMemory(&wfdFindFile, sizeof( WIN32_FIND_DATA ));

    if( INVALID_HANDLE_VALUE != ( hFindFile = FindFirstFile( g_lpszFileToSearch , &wfdFindFile ) ) )
    {
        do  // Loop until files are present in the directory to display .
        {
            // Check again whether obtained handle points to a directory or file .
            // If directory then check whether files in subdir are to be displayed .
            if( 0 != ( wfdFindFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                // Is single dot "." present or Is double dot ".." present .
                if( ( 0 != _tcsicmp( wfdFindFile.cFileName , DOT ) ) &&
                    ( 0 != _tcsicmp( wfdFindFile.cFileName , DOTS ) ) )
                {
                        
                        dwMem = ( StringLengthW( lpszPathName, 0 ) + StringLengthW( wfdFindFile.cFileName, 0 ) + EXTRA_MEM );
                        // Reallocate memory .
                        
                        if(((DWORD)GetBufferSize(g_lpszFileToSearch)) < (dwMem * sizeof(WCHAR)))
                        {
                            
                            if(FALSE == ReallocateMemory((LPVOID*)&g_lpszFileToSearch,( dwMem) * sizeof(WCHAR) ))
                            {
                                //ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC));
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FAILURE ;
                            }
                            else
                                if(NULL == g_lpszFileToSearch)
                                {
                                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                    CLOSE_FILE_HANDLE( hFindFile ) ;
                                    return FAILURE ;

                                }

                            
                        }

                        
                        StringCopy( g_lpszFileToSearch, lpszPathName, (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)) );


                        //if((NULL != g_lpszFileToSearch) &&(*(g_lpszFileToSearch+lstrlen(g_lpszFileToSearch)-1)) != L'\\' )
                        if((NULL != g_lpszFileToSearch) &&(*(g_lpszFileToSearch + StringLengthW(g_lpszFileToSearch, 0) - 1)) != L'\\' )
                        
                        {
                            
                            StringConcat(g_lpszFileToSearch, L"\\", (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)));
                        }

                        
                        StringConcat(g_lpszFileToSearch, wfdFindFile.cFileName, (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)));
                        
                        if(EXIT_SUCCESS == IsNTFSFileSystem2(g_lpszFileToSearch, &bNTFSFileSystem))
                        {
                            if(FALSE == bNTFSFileSystem)
                            {
                                continue;
                            }
                        }

                        lpszTempStr = (LPWSTR)AllocateMemory((StringLengthW(wfdFindFile.cFileName, 0) + 10) * sizeof(WCHAR));
                        if(NULL == lpszTempStr)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            CLOSE_FILE_HANDLE( hFindFile ) ;
                            return FAILURE ;
                        }

                        if( FindString( wszPatternString, L".",0) != NULL && (FindString(wfdFindFile.cFileName, L".",0)== NULL) )
                        {
                            
                            StringCopy( lpszTempStr, wfdFindFile.cFileName, GetBufferSize(lpszTempStr) / sizeof(WCHAR) );
                            StringConcat( lpszTempStr, L".", GetBufferSize(lpszTempStr) / sizeof(WCHAR) );
                        }
                        else
                        {
                            StringCopy( lpszTempStr, wfdFindFile.cFileName, GetBufferSize(lpszTempStr) / sizeof(WCHAR)  );
                        }
                        
                        if((FALSE == bMatchPattern) || ((TRUE == bMatchPattern) && (TRUE == MatchPattern(wszPatternString, lpszTempStr))))
                        {

                            
                            if( (FALSE == TakeOwnerShipIndividual(g_lpszFileToSearch)))
                            {
                                FREE_MEMORY(lpszTempStr);
                                continue;
                            }
                            else
                            {
                                // Copy current path name and store it .
                                if( FALSE == Push( g_lpszFileToSearch ) )
                                {   // Control comes here when memory allocation fails .
                                    CLOSE_FILE_HANDLE( hFindFile ) ;
                                    FREE_MEMORY(lpszTempStr);
                                    return FAILURE ;
                                } // Push Is Over .

                                FREE_MEMORY(lpszTempStr);
                            }
                        }
                        else
                        {
                             if( FALSE == Push( g_lpszFileToSearch ) )
                                {   // Control comes here when memory allocation fails .
                                    CLOSE_FILE_HANDLE( hFindFile ) ;
                                    FREE_MEMORY(lpszTempStr);
                                    return FAILURE ;
                                } // Push I

                             FREE_MEMORY(lpszTempStr);

                        }

                } // If
                else
                { // If obtained directory is A "." or ".." ,
                    continue ;
                }
             
            }
        }while( 0 != FindNextFile( hFindFile , &wfdFindFile ) ) ;  // Continue till no files are present to display.
    }
    else
    {
        if(0 == StringLengthW(szConfirm, 0))
        {
            if(FALSE == *pbACLChgPermGranted) // Check whether permission for change of ACL is already granted
            {
            
                lpszDispMsg = (LPWSTR)AllocateMemory((StringLengthW( lpszPathName, 0 ) + MAX_STRING_LENGTH) * sizeof(WCHAR));

                if( NULL == lpszDispMsg ) // Check is memory allocation is successful or not .
                { // Memory allocation is not successful .
                    ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                    return FAILURE ;
                }

            
                lpszDispMsg2 = (LPWSTR)AllocateMemory((StringLengthW( lpszPathName, 0 ) + MAX_STRING_LENGTH) * sizeof(WCHAR));

                if( NULL == lpszDispMsg2 ) // Check is memory allocation is successful or not .
                { // Memory allocation is not successful .
                    FREE_MEMORY(lpszDispMsg);
                    ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                    return FAILURE ;
                }

            
                hr = StringCchPrintf(lpszDispMsg, (GetBufferSize(lpszDispMsg) / sizeof(WCHAR)), GIVE_FULL_PERMISSIONS, lpszPathName );
                if(FAILED(hr))
                {
                    SetLastError(HRESULT_CODE(hr));
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    FREE_MEMORY(lpszDispMsg);
                    return FAILURE;
                }

            
                hr = StringCchPrintf(lpszDispMsg2, (GetBufferSize(lpszDispMsg2) / sizeof(WCHAR)), GIVE_FULL_PERMISSIONS2, lpszPathName );
                if(FAILED(hr))
                {
                    SetLastError(HRESULT_CODE(hr));
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    FREE_MEMORY(lpszDispMsg);
                    return FAILURE;
                }

             do
              {
                if(FALSE == bIndirectionInputWithZeroLength)
                {
                    if(0 == dwCount)//Give a  message asking the user for change of ACLs
                    {
                        ShowMessage(stdout,_X(lpszDispMsg));
                        ShowMessage(stdout,_X(lpszDispMsg2));
                    }
                    else
                    {
                        ShowMessage(stdout,L"\n\n");
                        ShowMessage(stdout,_X(lpszDispMsg2));
                    }
                }

                dwCount+= 1;

                hInput =  GetStdHandle( STD_INPUT_HANDLE );

                if( INVALID_HANDLE_VALUE == hInput)
                {

                
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    // Set Reason for error in memory
                
                    return FAILURE;
                }

                 // Get console mode, so we can change the input mode
                    bSuccess = GetConsoleMode( hInput, &dwMode );
                    if ( TRUE == bSuccess)
                    {
                        // turn off line input and echo
                        dwMode &= ~( ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT );
                        bSuccess = SetConsoleMode( hInput, dwMode );
                        if (FALSE == bSuccess)
                        {

                    
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                            // Set Reason for error in memory
                    
                            return FAILURE;

                        }
                        // Flush the buffer initially
                        if ( FlushConsoleInputBuffer( hInput ) == FALSE )
                        {
                    
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                            // Set Reason for error in memory
                    
                            return FAILURE;
                        }
                    }


                    if ( ReadFile(hInput, &ch, 1, &dwBytesRead, NULL) == FALSE )
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                        return FAILURE;
                    }

                    
                   
                    if( ( hInput != (HANDLE)0x0000000F )&&( hInput != (HANDLE)0x00000003 ) && ( hInput != INVALID_HANDLE_VALUE ) )
                    {

                        bIndirectionInput = TRUE;
                        
                    }
                    
                
                    hr = StringCchPrintf(chTmp, (SIZE_OF_ARRAY(chTmp)), L"%c" , ch  );
                    if(FAILED(hr))
                    {
                    
                        return FAILURE;
                    }


                    if( TRUE == bIndirectionInput)
                    {
                        if(  chTmp[0] ==  L'\n' ||  chTmp[0] ==  L'\r'|| chTmp[0] ==  L'\t')
                        {
                            bIndirectionInputWithZeroLength = TRUE;
                            continue;
                        }
                        else
                        {
                           bIndirectionInputWithZeroLength = FALSE;

                        }
                    }

                    

                    ShowMessage(stdout,_X(chTmp));
               }while(0 != dwBytesRead && !(((StringCompare( chTmp, LOWER_YES, TRUE, 0 ) == 0) || (StringCompare( chTmp, LOWER_NO, TRUE, 0 ) == 0) || (StringCompare( chTmp, LOWER_CANCEL, TRUE, 0 ) == 0))));
            

                FREE_MEMORY(lpszDispMsg);
          
            }
            else
            {
            
                StringCopy( chTmp, LOWER_YES, SIZE_OF_ARRAY(chTmp) );
                dwBytesRead =2;

            }
        }
        else
        {
            StringCopy( chTmp, szConfirm, SIZE_OF_ARRAY(chTmp) );
            dwBytesRead =2;

        }

        
        if(0 != dwBytesRead && (StringCompare( chTmp, LOWER_YES, TRUE, 0 ) == 0) )
         {
            *pbACLChgPermGranted = TRUE;
            /*if Permission for granting ACLS are obtained , then give the full permission*/

            if(TRUE == AddAccessRights(lpszPathName, 0xF0FFFFFF, szOwnerString, bAdminsOwner))
            {
                if( INVALID_HANDLE_VALUE != ( hFindFile = FindFirstFile( g_lpszFileToSearch , &wfdFindFile ) ) )
                {

                    do  // Loop until files are present in the directory to display .
                    {
                        // Check again whether obtained handle points to a directory or file .
                        // If directory then check whether files in subdir are to be displayed .
                        if( 0 != ( wfdFindFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
                        {
                            // Is single dot "." present or Is double dot ".." present .
                            if( ( 0 != _tcsicmp( wfdFindFile.cFileName , DOT ) ) &&
                                ( 0 != _tcsicmp( wfdFindFile.cFileName , DOTS ) ) )
                            {
                                    
                                    dwMem = ( StringLengthW( lpszPathName, 0 ) + StringLengthW( wfdFindFile.cFileName, 0 ) + EXTRA_MEM );
                                    // Reallocate memory .
                                    
                                    if( (DWORD)GetBufferSize(g_lpszFileToSearch) < (dwMem * sizeof(WCHAR)))
                                    {
                                        
                                        if( FALSE == ReallocateMemory((LPVOID*)&g_lpszFileToSearch,
                                            ( StringLengthW( lpszPathName, 0 ) + StringLengthW( wfdFindFile.cFileName, 0 ) + EXTRA_MEM ) * sizeof(WCHAR) ))
                                        {
                                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                            CLOSE_FILE_HANDLE( hFindFile ) ;
                                            return FAILURE ;

                                        }
                                        else
                                            if(NULL == g_lpszFileToSearch)
                                            {
                                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                                return FAILURE ;
                                            }
                                        
                                               
                                    }

                                    
                                    StringCopy( g_lpszFileToSearch, lpszPathName, (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)) );

                                    
                                    if((NULL != g_lpszFileToSearch) && (*(g_lpszFileToSearch + StringLengthW(g_lpszFileToSearch, 0) - 1)) != L'\\' )
                                    {
                                        
                                        StringConcat(g_lpszFileToSearch, L"\\", (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)));
                                    }
                                    
                                    StringConcat(g_lpszFileToSearch, wfdFindFile.cFileName, GetBufferSize(g_lpszFileToSearch)/sizeof(TCHAR));
                                    
                                    // Copy current path name and store it .
                                    if( FALSE == Push( g_lpszFileToSearch ) )
                                    {   // Control comes here when memory allocation fails .
                                        CLOSE_FILE_HANDLE( hFindFile ) ;
                                        return FAILURE ;
                                    } // Push Is Over .

                            } // If
                            else
                            { // If obtained directory is A "." or ".." ,
                                continue ;
                            }
                        }
                    }while( 0 != FindNextFile( hFindFile , &wfdFindFile ) ) ;  // Continue till no files are present to display.
                }

            }
            else
            {
                
                ShowMessage(stderr, L"\n");
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                return FAILURE;
            }

        }
        else
           if(0 == StringLengthW(szConfirm, 0))
           {
                if(0 != dwBytesRead && (StringCompare( chTmp, LOWER_CANCEL, TRUE, 0 ) == 0) )
                {
                    ShowMessage(stdout,L"\n");
                    CLOSE_FILE_HANDLE( hFindFile ) ;
                    return EXIT_CANCELED;
                }
                else
                {
                    ShowMessage(stdout,L"\n");
                }
           }
           
      
    }
    CLOSE_FILE_HANDLE( hFindFile ) ;
    return SUCCESS ;
}

BOOL GetOwnershipForFiles( IN LPWSTR lpszPathName,
                           IN BOOL bAdminsOwner,
                           IN LPWSTR  szOwnerString,
                           IN BOOL bMatchPattern,
                           IN LPWSTR wszPatternString,
                           IN OUT PBOOL pbFilesNone)
                           
                           
/*++
   Routine Description:
    This function gives the ownership for the files specified in the path

   Arguments:
        [ IN ]  lpszPathName           : The path to search the files for giving ownership
        
        [ IN ]  bAdminsOwner           : Indicates whether to give ownership to the administrators group
        [ IN ]  dwUserName             : Logged on user name
        [ IN ]  szOwnerString          : Logged on user name in Sam Compatible format
        [ IN ]  bLogonDomainAdmin      : Indicates whether the logged on user is domain administrator or not

   Return Value:
        FALSE :   On failure
        TRUE  :   On success
--*/

{

    HANDLE hFindFile = NULL ;               // Handle to a file .
    WIN32_FIND_DATA  wfdFindFile ;          // Structure keeping information about the found file .
    BOOL bTakeOwnerShipError = FALSE;
    BOOL  bFlag = TRUE;
    BOOL bNTFSFileSystem = FALSE;

    LPWSTR szTmpFileName = NULL;


    WCHAR wszTempMessage[3*MAX_STRING_LENGTH] ;
    
    LPWSTR  szTemporaryFileName = NULL;

    LPWSTR lpNextTok = NULL;
    LPWSTR wszFormedMessage = NULL;
    
    long dwMem = 0;
    HRESULT hr;
    LPWSTR lpszTempStr = NULL;

    SecureZeroMemory(wszTempMessage, (3*MAX_STRING_LENGTH) * sizeof(WCHAR));
    
    szTemporaryFileName = (LPWSTR)AllocateMemory((StringLengthW(lpszPathName, 0) + EXTRA_MEM)* sizeof(WCHAR));
    if(NULL == szTemporaryFileName)
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return FALSE ;
    }
    
    StringCopy( szTemporaryFileName, lpszPathName, GetBufferSize(szTemporaryFileName) / sizeof(WCHAR));
    
    StringConcat(lpszPathName, L"\\", GetBufferSize(lpszPathName) / sizeof(WCHAR));
    
    StringConcat(lpszPathName, L"*.*", GetBufferSize(lpszPathName) / sizeof(WCHAR));
    
    SecureZeroMemory(&wfdFindFile, sizeof( WIN32_FIND_DATA ));
    // From here onwards directory and file information should be displayed .

    if( INVALID_HANDLE_VALUE != ( hFindFile = FindFirstFile( lpszPathName , &wfdFindFile ) ) )
    {
        do  // Loop until files are present in the directory to display .
        {
                // Check again whether obtained handle points to a directory or file .
                // If directory then check whether files in subdir are to be displayed .
                if( 0 != ( wfdFindFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
                {
                    // Is single dot "." present or Is double dot ".." present .
                    if( ( 0 == _tcsicmp( wfdFindFile.cFileName , DOT ) ) ||
                        ( 0 == _tcsicmp( wfdFindFile.cFileName , DOTS ) ) )
                    {
                        continue ;
                    }
                }

                // Execute a command specified at command prompt .
                    // Reallocate memory .
                
                dwMem = ( StringLengthW( g_lpszFileToSearch, 0) + StringLengthW( wfdFindFile.cFileName, 0 ) + EXTRA_MEM );
                
                
                if(((DWORD)GetBufferSize(g_lpszFileToSearch)) < (dwMem * sizeof(WCHAR)))
                {

                    if(FALSE == ReallocateMemory((LPVOID*)&g_lpszFileToSearch,
                                ( StringLengthW( g_lpszFileToSearch, 0 ) + StringLengthW( wfdFindFile.cFileName, 0 ) + EXTRA_MEM ) * sizeof(WCHAR) ))
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        CLOSE_FILE_HANDLE( hFindFile ) ;
                        FREE_MEMORY(szTemporaryFileName);
                        return FALSE ;
                    }
                    else
                        if(NULL == g_lpszFileToSearch)
                        {
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            CLOSE_FILE_HANDLE( hFindFile ) ;
                            FREE_MEMORY(szTemporaryFileName);
                            return FALSE ;

                        }
                                        
                }

                
                StringCopy( g_lpszFileToSearch, szTemporaryFileName, (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)) );

                
                if((NULL != g_lpszFileToSearch) && (*(g_lpszFileToSearch + StringLengthW(g_lpszFileToSearch, 0) - 1)) != L'\\' )
                {
                    
                    StringConcat(g_lpszFileToSearch, L"\\", (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)) );
                }
                
                StringConcat(g_lpszFileToSearch, wfdFindFile.cFileName, (GetBufferSize(g_lpszFileToSearch) / sizeof(TCHAR)) );

                lpszTempStr = (LPWSTR)AllocateMemory((StringLengthW(wfdFindFile.cFileName, 0) + 10) * sizeof(WCHAR));
                if(NULL == lpszTempStr)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    CLOSE_FILE_HANDLE( hFindFile ) ;
                    FREE_MEMORY(szTemporaryFileName);
                    return FAILURE ;
                }

                if( FindString( wszPatternString, L".",0) != NULL && (FindString(wfdFindFile.cFileName, L".",0)== NULL) )
                {
                    
                    StringCopy( lpszTempStr, wfdFindFile.cFileName, GetBufferSize(lpszTempStr) / sizeof(WCHAR) );
                    StringConcat( lpszTempStr, L".", GetBufferSize(lpszTempStr) / sizeof(WCHAR) );
                }
                else
                {
                    StringCopy( lpszTempStr, wfdFindFile.cFileName, GetBufferSize(lpszTempStr) / sizeof(WCHAR)  );
                }

                if((FALSE == bMatchPattern) || ((TRUE == bMatchPattern) && (TRUE == MatchPattern(wszPatternString, lpszTempStr))))
                {

                    FREE_MEMORY(lpszTempStr);

                    *pbFilesNone = FALSE;
                    if(EXIT_SUCCESS == IsNTFSFileSystem2(g_lpszFileToSearch, &bNTFSFileSystem))
                    {
                        if(FALSE == bNTFSFileSystem)
                        {
                            wszFormedMessage = (LPWSTR)AllocateMemory((StringLengthW( g_lpszFileToSearch, 0 ) + MAX_RES_STRING + EXTRA_MEM ) * sizeof(WCHAR));
                            if( NULL == wszFormedMessage )
                            { // Reallocation failed .
                                ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                FREE_MEMORY(szTemporaryFileName);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FALSE ;
                            }

                            hr = StringCchPrintf(wszFormedMessage, (GetBufferSize(wszFormedMessage) / sizeof(WCHAR)), GetResString(IDS_FAT_VOLUME_INFO), _X(g_lpszFileToSearch));
                            if(FAILED(hr))
                            {
                                SetLastError(HRESULT_CODE(hr));
                                SaveLastError();
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                FREE_MEMORY( wszFormedMessage ) ;
                                FREE_MEMORY(szTemporaryFileName);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FALSE;
                            }

                            ShowMessage(stdout, wszFormedMessage);

                            FREE_MEMORY(wszFormedMessage);
                            
                            continue;
                        }
                    }
                    if(TRUE == bAdminsOwner)
                    {
                        bFlag = TakeOwnerShip( g_lpszFileToSearch);
                    }
                    else
                    {
                        
                        bFlag = TakeOwnerShipIndividual(g_lpszFileToSearch);

                    }

                
                    if( FALSE == bFlag && bTakeOwnerShipError == FALSE )
                    {

                        if( ERROR_NOT_ALL_ASSIGNED == GetLastError()) // || (ERROR_INVALID_HANDLE  == GetLastError()))
                        {
                            
                            if(NULL == szTmpFileName)
                            {
                                szTmpFileName = (LPWSTR)AllocateMemory((StringLengthW( g_lpszFileToSearch, 0 ) + MAX_RES_STRING + EXTRA_MEM ) * sizeof(WCHAR));
                                if( NULL == szTmpFileName )
                                { // Reallocation failed .
                                    ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                    FREE_MEMORY(szTemporaryFileName);
                                    CLOSE_FILE_HANDLE( hFindFile ) ;
                                    return FALSE ;
                                }
                            }
                            else
                            {
                                
                                dwMem = ( StringLengthW( g_lpszFileToSearch, 0) + MAX_RES_STRING + EXTRA_MEM );
                                
                                if((DWORD)GetBufferSize(szTmpFileName) < dwMem * sizeof(WCHAR))
                                {
                                    
                                    if(FALSE == ReallocateMemory((LPVOID*)&szTmpFileName,( StringLengthW( g_lpszFileToSearch, 0 ) + MAX_RES_STRING + EXTRA_MEM ) * sizeof(WCHAR) ))
                                    {
                                        ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                        FREE_MEMORY(szTmpFileName);
                                        FREE_MEMORY(szTemporaryFileName);
                                        CLOSE_FILE_HANDLE( hFindFile ) ;
                                        return FALSE ;
                                    }
                                    else
                                        if(NULL == szTmpFileName)
                                        {
                                            ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                            FREE_MEMORY(szTmpFileName);
                                            FREE_MEMORY(szTemporaryFileName);
                                            CLOSE_FILE_HANDLE( hFindFile ) ;
                                            return FALSE ;

                                        }
                                    
                                }
                            }

                            hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), GetResString(IDS_NOT_OWNERSHIP_INFO), g_lpszFileToSearch);
                            if(FAILED(hr))
                            {
                               SetLastError(HRESULT_CODE(hr));
                               SaveLastError();
                               ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                              
                               FREE_MEMORY(szTmpFileName);
                               FREE_MEMORY(szTemporaryFileName);
                               CLOSE_FILE_HANDLE( hFindFile ) ;
                               return( FALSE );
                            }

                            ShowMessage(stdout, szTmpFileName);

                        }
                        else if(ERROR_SHARING_VIOLATION == GetLastError())
                        {
                    
                            if(NULL == szTmpFileName)
                            {
                                
                                szTmpFileName = (LPWSTR)AllocateMemory((StringLengthW( g_lpszFileToSearch, 0 ) + MAX_RES_STRING + EXTRA_MEM ) * sizeof(WCHAR));
                                if( NULL == szTmpFileName )
                                { // Reallocation failed .
                                    ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                    FREE_MEMORY(szTemporaryFileName);
                                    CLOSE_FILE_HANDLE( hFindFile ) ;
                                    return FALSE ;
                                }
                            }
                            else
                            {
                                
                                dwMem = ( StringLengthW( g_lpszFileToSearch, 0) + MAX_RES_STRING + EXTRA_MEM );
                                
                                if((DWORD)GetBufferSize(szTmpFileName) < dwMem * sizeof(WCHAR))
                                {
                                    
                                    if( FALSE == ReallocateMemory((LPVOID*)&szTmpFileName,
                                                ( StringLengthW( g_lpszFileToSearch, 0 ) + MAX_RES_STRING + EXTRA_MEM ) * sizeof(WCHAR) ))
                                    {
                                        ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                        FREE_MEMORY(szTmpFileName);
                                        FREE_MEMORY(szTemporaryFileName);
                                        CLOSE_FILE_HANDLE( hFindFile ) ;
                                        return FALSE ;

                                    }
                                    else
                                        if(NULL == szTmpFileName)
                                        {
                                            ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                            FREE_MEMORY(szTmpFileName);
                                            FREE_MEMORY(szTemporaryFileName);
                                            CLOSE_FILE_HANDLE( hFindFile ) ;
                                            return FALSE ;

                                        }
                                    
                                }
                            }

                            hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), GetResString(IDS_SHARING_VIOLATION_INFO), g_lpszFileToSearch);
                            if(FAILED(hr))
                            {
                               SetLastError(HRESULT_CODE(hr));
                               SaveLastError();
                               ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                              
                               FREE_MEMORY(szTmpFileName);
                               FREE_MEMORY(szTemporaryFileName);
                               CLOSE_FILE_HANDLE( hFindFile ) ;
                               return( FALSE );
                            }

                            ShowMessage(stdout, szTmpFileName);

                        }
                        else
                        {
                            
                            wszFormedMessage = (LPWSTR)AllocateMemory((StringLengthW( g_lpszFileToSearch, 0 ) + MAX_STRING_LENGTH) * sizeof(WCHAR));
                            if(NULL == wszFormedMessage)
                            {
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                FREE_MEMORY(szTmpFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FALSE;
                            }
                            ShowMessage( stdout, L"\n" );
                            ShowMessage( stdout, TAG_INFORMATION );
                            ShowMessage( stdout, SPACE_CHAR );
                            
                            StringCopy( wszTempMessage, GetReason(), SIZE_OF_ARRAY(wszTempMessage) );
                            lpNextTok = _tcstok(wszTempMessage, L".");
                            ShowMessage(stdout,wszTempMessage);
                            
                            //hr = StringCchPrintf(wszFormedMessage, (GetBufferSize(wszFormedMessage) / sizeof(WCHAR)), GetResString(IDS_ON_FILE_FOLDER), _X(g_lpszFileToSearch) );
                            
                            hr = StringCchPrintf(wszFormedMessage, (GetBufferSize(wszFormedMessage) / sizeof(WCHAR)), L". ( \"%s\" )\n", _X(g_lpszFileToSearch));
                            if(FAILED(hr))
                            {
                                SetLastError(HRESULT_CODE(hr));
                                SaveLastError();
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                FREE_MEMORY( wszFormedMessage ) ;
                                FREE_MEMORY(szTemporaryFileName);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FALSE;
                            }
                            ShowMessage(stdout, wszFormedMessage);
                            FREE_MEMORY(wszFormedMessage);

                        }

                    }
                    else
                    {
                        if(NULL == szTmpFileName)
                        {
                            
                            szTmpFileName = (LPWSTR)AllocateMemory((StringLengthW( g_lpszFileToSearch, 0 ) + MAX_RES_STRING + EXTRA_MEM ) * sizeof(WCHAR));
                            if( NULL == szTmpFileName )
                            { // Reallocation failed .
                                ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                FREE_MEMORY(szTemporaryFileName);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FALSE ;
                            }
                        }
                        else
                        {
                            
                            dwMem = ( StringLengthW( g_lpszFileToSearch, 0) + MAX_RES_STRING + EXTRA_MEM );
                            
                            if((DWORD)GetBufferSize(szTmpFileName) < dwMem * sizeof(WCHAR))
                            {
                                if(FALSE == ReallocateMemory((LPVOID*)&szTmpFileName,( StringLengthW( g_lpszFileToSearch, 0 ) + MAX_RES_STRING + EXTRA_MEM ) * sizeof(WCHAR) ))
                                {
                                    ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                    FREE_MEMORY(szTemporaryFileName);
                                    FREE_MEMORY(szTmpFileName);
                                    CLOSE_FILE_HANDLE( hFindFile ) ;
                                    return FALSE ;
                                }
                                else
                                    if(NULL == szTmpFileName)
                                    {
                                        ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                                        FREE_MEMORY(szTemporaryFileName);
                                        FREE_MEMORY(szTmpFileName);
                                        CLOSE_FILE_HANDLE( hFindFile ) ;
                                        return FALSE ;

                                    }

                            }
                        }
                    
                        if(TRUE == bAdminsOwner)
                        {
                            
                            hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL,g_lpszFileToSearch );
                            if(FAILED(hr))
                            {
                                SetLastError(HRESULT_CODE(hr));
                                SaveLastError();
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                FREE_MEMORY(szTmpFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FALSE;
                            }
                        }
                        else
                        {
                            //hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, szOwnerString, g_lpszFileToSearch );
                            hr = StringCchPrintf(szTmpFileName, (GetBufferSize(szTmpFileName) / sizeof(WCHAR)), TAKEOWN_SUCCESSFUL_USER, g_lpszFileToSearch, szOwnerString);
                            if(FAILED(hr))
                            {
                                SetLastError(HRESULT_CODE(hr));
                                SaveLastError();
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                FREE_MEMORY(szTmpFileName);
                                FREE_MEMORY(szTemporaryFileName);
                                CLOSE_FILE_HANDLE( hFindFile ) ;
                                return FALSE;
                            }
                        }

                        ShowMessage( stdout, _X(szTmpFileName) );

                    }
             }

             FREE_MEMORY(lpszTempStr);
             
        } while( 0 != FindNextFile( hFindFile , &wfdFindFile ) ) ;  // Continue till no files are present to display.

        if( GetLastError() != ERROR_NO_MORE_FILES ) // If error occurs , check is error other than NOMOREFILES .
        { // If error is other than NOMOREFILES then display ERROR .
            SaveLastError();
            ShowMessage( stderr , GetReason() ) ;
            CLOSE_FILE_HANDLE( hFindFile ) ;

            FREE_MEMORY(szTmpFileName);
            FREE_MEMORY(szTemporaryFileName);
            return FALSE ;
        }
    }

    CLOSE_FILE_HANDLE( hFindFile ) ;    // Close open find file handle .
    g_pFollowPathName = NULL ;

    FREE_MEMORY(szTmpFileName);
    FREE_MEMORY(szTemporaryFileName);
    return TRUE ;
}

BOOL
Push(
    IN LPTSTR szPathName )
/*++

Routine Description:

    Store the path of obtained subdirectory .

Arguments:

      [ IN ] szPathName    : Contains path of a subdirectory .

Return value:

    TRUE if succedded in storing  a path else FALSE if failed to get memory.

--*/
{
        // Get a temporary variable .
        PStore_Path_Name    pAddPathName ;
        // Assign memory To Temporary Variable .
       
       pAddPathName = (PStore_Path_Name)AllocateMemory((1) * sizeof(struct __STORE_PATH_NAME ));   

        if( NULL == pAddPathName ) // Check is memory allocation is successful or not .
        { // Memory allocation is successful .
            ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
            return FALSE ;
        }
        // Assign memory to string variable which is going to store full path name of a valid directory .
        
        pAddPathName->pszDirName = (LPTSTR)AllocateMemory((StringLengthW( szPathName, 0 ) + EXTRA_MEM) * sizeof( WCHAR ));

        if( NULL == pAddPathName->pszDirName )// Check is memory allocation was successful or not .
        { // Memory allocation was unsuccessful .
            ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
            FREE_MEMORY( pAddPathName ) ;
            return FALSE ;
        }
        // Copy path name to memory allocated string variable .
         
         StringCopy(( LPTSTR ) pAddPathName->pszDirName, szPathName, (GetBufferSize(pAddPathName->pszDirName) / sizeof(WCHAR)) );
         
         pAddPathName->NextNode = NULL ;  // Assign null , had only one subdirectory stored  .


        // Check global variable is NULL or not .
        if( NULL == g_pPathName )
        {   // Add memory to store path of subdirectory .
            g_pPathName = pAddPathName ;
            g_pFollowPathName = g_pPathName ;
        }
        else
        {
            if( NULL == g_pFollowPathName )
            {   // Store first obtained subdirectory .
                pAddPathName->NextNode = g_pPathName ;
                g_pPathName = pAddPathName ;
                g_pFollowPathName = g_pPathName ;
            }
            else
            {
                // Stroe subdirectory in the middle
                pAddPathName->NextNode = g_pFollowPathName->NextNode ;
                g_pFollowPathName->NextNode =  pAddPathName ;
                g_pFollowPathName = pAddPathName ;
            }
        }

        return TRUE ;
}

BOOL
Pop(
    void )
/*++

Routine Description:

    Get a subdirectory which has to be searched for a file matching a user
    specified criteria .

Arguments:

Return value:

    TRUE if successful in getting a path else FALSE if failed to get memory or
    if no path is stored .

--*/
{
    // Linked list has more than 1 node .
    PStore_Path_Name    pDelPathName = g_pPathName ;

        // Check whether linked list is having any nodes .
        if( NULL == g_pPathName )
        { // No nodes present , return False ,
          // Should not happen ever . Control should not come here .
            ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
            return FALSE ;
        }

        // Realloc memory and give buffer space in which path name can fix .
            
        if((DWORD)GetBufferSize( g_lpszFileToSearch) < ((StringLengthW( g_pPathName->pszDirName, 0 ) + EXTRA_MEM) * sizeof(WCHAR)))
        {
            if(FALSE == ReallocateMemory((LPVOID*)g_lpszFileToSearch, ( StringLengthW( g_pPathName->pszDirName, 0 ) + EXTRA_MEM ) * sizeof(WCHAR) ))
            {
                ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                return FALSE ;
            }
            else
                if( NULL == g_lpszFileToSearch )
                { // Memory reallocation failed .
                    ShowMessage( stderr , GetResString(IDS_ERROR_MEMORY_ALLOC)) ;
                    return FALSE ;
                }
        }

        // Check linked list has only one node .
        if( NULL == g_pPathName->NextNode )
        { // List has only one node .
            // Memory allocation successful . Copy pathname to the buffer .
            
            StringCopy(g_lpszFileToSearch, g_pPathName->pszDirName, (GetBufferSize(g_lpszFileToSearch) / sizeof(WCHAR)) );
            g_pFollowPathName = NULL ;  // Formality , better practice to assign NULL .
            // Free node . Linked list is now empty .
            FREE_MEMORY( g_pPathName->pszDirName ) ;
            FREE_MEMORY( g_pPathName ) ;
            return TRUE;
        }

        g_pPathName = pDelPathName->NextNode ;
        // Memory allocation successful . Copy pathname to the buffer .
        
        StringCopy(g_lpszFileToSearch, pDelPathName->pszDirName, (GetBufferSize(g_lpszFileToSearch) / sizeof(WCHAR)) );
        // Free node .
        FREE_MEMORY( pDelPathName->pszDirName ) ;
        FREE_MEMORY( pDelPathName ) ;
        return TRUE ;
}

BOOL
TakeOwnerShipIndividual(
    IN LPCTSTR lpszFileName
    )
/*++
Routine Description:
    This routine takes the ownership of the specified file

Arguments:
    [ IN ] lpszFileName - File name for whose ownership has to be taken.
    [ IN ] lpszUserName - User Name in the Sam compatible format.
    [ IN ] dwUserName   - Logged on user name.
    [ IN ] bLogonDomainAdmin - To know whether the logged on user is Domain admin or not.

Return Value:
    TRUE if owner ship of the specified file has been taken
    else FALSE
--*/
{
//local variables
    SECURITY_DESCRIPTOR        SecurityDescriptor;
    PSECURITY_DESCRIPTOR        pSd = NULL;
    //PSID                       pAliasAdminsSid = NULL;
    //SID_IDENTIFIER_AUTHORITY   SepNtAuthority = SECURITY_NT_AUTHORITY;
    PACL                       pDacl;
    HANDLE                      hFile;
    HANDLE  hTokenHandle = NULL;
    BOOL    bResult = TRUE;
    BOOL    bInvalidFileHandle = FALSE;
    
    PSID pSid = NULL;

    PTOKEN_USER pTokUser = NULL;
    DWORD   dwTokLen = 0;

    


    //check for valid input parameters
    if( lpszFileName == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        SaveLastError();
        FREE_MEMORY(pTokUser);
        CloseHandle( hTokenHandle );
        return FALSE;
    }

  //get the token of the current process
    bResult = GetTokenHandle( &hTokenHandle );
    if( FALSE == bResult )
    {
        SaveLastError();
        return( FALSE );
    }

 
    GetTokenInformation(hTokenHandle,TokenUser,NULL,0,&dwTokLen);

    if(0 == dwTokLen)
    {
        
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        CloseHandle( hTokenHandle );
        return( FALSE );
    }

    pTokUser = (TOKEN_USER*)AllocateMemory(dwTokLen );

    if( pTokUser == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        SaveLastError();
        CloseHandle( hTokenHandle );
        return FALSE;
    }

    if(!GetTokenInformation(hTokenHandle,TokenUser,pTokUser,dwTokLen,&dwTokLen))
    {

        SaveLastError();

        FREE_MEMORY(pTokUser);
        CloseHandle( hTokenHandle );
        return( FALSE );
    }

    // Attempt to put a NULL Dacl on the object
    bResult = InitializeSecurityDescriptor( &SecurityDescriptor,
                                            SECURITY_DESCRIPTOR_REVISION );
    if( FALSE == bResult )
    {
        SaveLastError();

        FREE_MEMORY(pTokUser);
        CloseHandle( hTokenHandle );
        FREE_MEMORY(pSid);
        return( FALSE );
    }
    //Get the handle of the file or directory
    hFile = CreateFile( lpszFileName, READ_CONTROL , FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );

    //try once again it may be a directory
    if( INVALID_HANDLE_VALUE != hFile )
    {

        //get the DACL for the currently existing file or directory
        if( 0 != GetSecurityInfo( hFile, SE_FILE_OBJECT,  DACL_SECURITY_INFORMATION, NULL,
                                  NULL, &pDacl, NULL, &pSd ) )
        {

            SaveLastError();

            FREE_MEMORY(pTokUser);
            FREE_MEMORY(pSid);

            CloseHandle( hFile );
            CloseHandle( hTokenHandle );
            if(NULL != pSd)
            {
                LocalFree( pSd );
            }
            return( FALSE );
        }


        // set the security descriptor to acl
        bResult = SetSecurityDescriptorDacl ( &SecurityDescriptor,
                                                    TRUE, pDacl, FALSE );
        if( FALSE == bResult )
        {
            SaveLastError();

            FREE_MEMORY(pTokUser);
            FREE_MEMORY(pSid);
            CloseHandle( hFile );
            CloseHandle( hTokenHandle );
            if(NULL != pSd)
            {
                LocalFree( pSd );
            }
            return( FALSE );
        }
    }
    else
    {
        bInvalidFileHandle = TRUE;
    }


    bResult = SetSecurityDescriptorOwner ( &SecurityDescriptor,
                                            pTokUser->User.Sid, FALSE );
   

    if( FALSE == bResult )
    {
        SaveLastError();

        FREE_MEMORY(pTokUser);
        FREE_MEMORY(pSid);
        CloseHandle( hTokenHandle );
        CloseHandle( hFile );
        if(NULL != pSd)
        {
            LocalFree( pSd );
        }
        return( FALSE );
    }

    //set the file security to adminsitrator owner
    bResult = SetFileSecurity( lpszFileName, OWNER_SECURITY_INFORMATION,
                                                    &SecurityDescriptor );

    if( TRUE == bResult )
    {
        if(NULL != pSd)
        {
            LocalFree( pSd );
        }
       FREE_MEMORY(pTokUser);
       FREE_MEMORY(pSid);
       CloseHandle( hTokenHandle );
       CloseHandle( hFile );
       return( TRUE );
    }

     // Assert TakeOwnership privilege for current process, then try again
     bResult = AssertTakeOwnership( hTokenHandle );

     if( FALSE == bResult )
     {
   
        if(TRUE == bInvalidFileHandle)
        {
            hFile = CreateFile( lpszFileName, READ_CONTROL , FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
            if( INVALID_HANDLE_VALUE == hFile )
            {
                if( ( ERROR_BAD_NET_NAME == GetLastError() ) ||
                            ( ERROR_BAD_NETPATH == GetLastError() ) ||
                            ( ERROR_INVALID_NAME == GetLastError() ) )
                {
                    FREE_MEMORY(pTokUser);
                    SetLastError(ERROR_INVALID_NAME);
                    
                    
                }
                else if( ERROR_SHARING_VIOLATION == GetLastError() )
                {
                
                    FREE_MEMORY(pTokUser);
                    SetLastError(ERROR_SHARING_VIOLATION);
                    
                    
                }
                else
                {
                    SaveLastError();
                    FREE_MEMORY(pTokUser);
                }
           
                CloseHandle( hTokenHandle );
                
                return( FALSE );
            }
        }

         switch (GetLastError())
         {
            case ERROR_NOT_ALL_ASSIGNED: 
                                     FREE_MEMORY(pTokUser);
                                     FREE_MEMORY(pSid);
                                     SetLastError(ERROR_NOT_ALL_ASSIGNED);
                                     break;
            case ERROR_SHARING_VIOLATION:
                                     FREE_MEMORY(pTokUser);
                                     FREE_MEMORY(pSid);
                                     SetLastError(ERROR_SHARING_VIOLATION);
                                     break;
            case ERROR_BAD_NET_NAME :
            case ERROR_BAD_NETPATH  :
            case ERROR_INVALID_NAME : FREE_MEMORY(pTokUser);
                                      FREE_MEMORY(pSid);
                                      SetLastError(ERROR_BAD_NET_NAME);
                                      break;

                default            : FREE_MEMORY(pTokUser);
                                     FREE_MEMORY(pSid);
                                          break;
         }
        
        CloseHandle( hTokenHandle );
        CloseHandle( hFile );
        if(NULL != pSd)
        {
            LocalFree( pSd );
        }
        return( FALSE );
     }

    //Now try to set ownership security privilege for the file
     bResult = SetFileSecurity( lpszFileName, OWNER_SECURITY_INFORMATION,
                                        &SecurityDescriptor );
    if( FALSE == bResult )
     {
        SaveLastError();
         
        if(TRUE == bInvalidFileHandle)
        {
        //Check out whether it is an invalid file or file does not exist
            hFile = CreateFile( lpszFileName, READ_CONTROL , FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
            if( INVALID_HANDLE_VALUE == hFile )
            {
                if( ( ERROR_BAD_NET_NAME == GetLastError() ) ||
                            ( ERROR_BAD_NETPATH == GetLastError() ) ||
                            ( ERROR_INVALID_NAME == GetLastError() ) )
                {
                    FREE_MEMORY(pTokUser);
                    SetLastError(ERROR_INVALID_NAME);
                }
                else if( ERROR_SHARING_VIOLATION == GetLastError() )
                {
                
                    FREE_MEMORY(pTokUser);
                    SetLastError(ERROR_SHARING_VIOLATION);
                    
                }
                else
                {
                    SaveLastError();
                    FREE_MEMORY(pTokUser);
                    
                }
                
                CloseHandle( hTokenHandle );
                
                return( FALSE );
            }
        }

         switch (GetLastError())
         {
            case ERROR_NOT_ALL_ASSIGNED: 
                                     FREE_MEMORY(pTokUser);
                                     FREE_MEMORY(pSid);
                                     SetLastError(ERROR_NOT_ALL_ASSIGNED);
                                     break;
            case ERROR_SHARING_VIOLATION:
                                     FREE_MEMORY(pTokUser);
                                     FREE_MEMORY(pSid);
                                     SetLastError(ERROR_SHARING_VIOLATION);
                                     break;
            case ERROR_BAD_NET_NAME :
            case ERROR_BAD_NETPATH  :
            case ERROR_INVALID_NAME : FREE_MEMORY(pTokUser);
                                      FREE_MEMORY(pSid);
                                      SetLastError(ERROR_BAD_NET_NAME);
                                      break;

            default            : FREE_MEMORY(pTokUser);
                                 FREE_MEMORY(pSid);
                                      break;
         }

        
        CloseHandle( hTokenHandle );
        CloseHandle( hFile );
        if(NULL != pSd)
        {
            LocalFree( pSd );
        }
        return( FALSE );
     }

    if(NULL != pSd)
    {
        LocalFree( pSd );
    }

    FREE_MEMORY(pTokUser);
    FREE_MEMORY(pSid);

    CloseHandle( hTokenHandle );
    CloseHandle( hFile );
    return( TRUE );
}

BOOL
AddAccessRights(IN WCHAR *lpszFileName,
                IN DWORD dwAccessMask,
                IN LPWSTR dwUserName,
                IN BOOL bAdminsOwner)
/*++
Routine Description:
    This routine takes the ownership of the specified file

Arguments:
    [ IN ] lpszFileName - Directory name for whom access permissions has to be granted.
    [ IN ] dwAccessMask - Access Mask for giving the permissions.
    [ IN ] dwUserName   - User Name in the Sam compatible format.


Return Value:
    TRUE if owner ship of the specified file has been taken
    else FALSE
--*/

{

   // SID variables.
   SID_NAME_USE   snuType;
   WCHAR *        szDomain       = NULL;
   DWORD          cbDomain       = 0;
   PSID           pUserSID       = NULL;
   DWORD          cbUserSID      = 0;

   // File SD variables.
   PSECURITY_DESCRIPTOR pFileSD  = NULL;
   DWORD          cbFileSD       = 0;

   // New SD variables.
   PSECURITY_DESCRIPTOR pNewSD   = NULL;

   // ACL variables.
   PACL           pACL           = NULL;
   BOOL           fDaclPresent;
   BOOL           fDaclDefaulted;
   ACL_SIZE_INFORMATION AclInfo;

   // New ACL variables.
   PACL           pNewACL        = NULL;
   DWORD          cbNewACL       = 0;

   // Assume function will fail.
   BOOL           fResult        = FALSE;
   BOOL           fAPISuccess ;
   BOOL bResult = FALSE;
   ACCESS_ALLOWED_ACE *pace = NULL;
   WORD acesize = 0;

   PSID                       pAliasAdminsSid = NULL;
    SID_IDENTIFIER_AUTHORITY   SepNtAuthority = SECURITY_NT_AUTHORITY;

   dwAccessMask = 0;
   
   if(TRUE == bAdminsOwner)
   {

        //allocate and initialise sid
        bResult = AllocateAndInitializeSid(
                     &SepNtAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &pAliasAdminsSid
                     );
   }
   
      //
      //  Get the actual size of SID for current user.
      //
	  pUserSID       = NULL;
      cbUserSID      = 0;

     fAPISuccess = LookupAccountName( NULL, dwUserName,
            pUserSID, &cbUserSID, szDomain, &cbDomain, &snuType);


     // Since the buffer size is too small..API fails with insufficient buffer.
	 // If the error code is other than ERROR_INSUFFICIENT_BUFFER, then return failure.

	 if ( (FALSE == fAPISuccess) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER) )
	 {
		 SaveLastError();
		 return FALSE;
	 }


      // allocate pUserSID with the actual size i.e.,cbUserSID
      pUserSID = (PSID)AllocateMemory(cbUserSID);

      if(NULL == pUserSID)
      {

        SaveLastError();

        if(NULL != pAliasAdminsSid)
        {
            FreeSid( pAliasAdminsSid );
        }

         return FALSE;
      }


      
      szDomain =  (WCHAR*)AllocateMemory(cbDomain*sizeof(WCHAR));

      if(NULL == szDomain)
      {
          SaveLastError();
          
          FreeMemory(&pUserSID);

          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 

          return FALSE;
      }

     fAPISuccess = LookupAccountName( NULL, dwUserName,
            pUserSID, &cbUserSID, szDomain, &cbDomain, &snuType);

     if(0 == fAPISuccess)
     {
         SaveLastError();

         FreeMemory(&pUserSID);
              
         FreeMemory(&szDomain);

         if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 
         return FALSE;
     }
   

      //
      //  Get security descriptor (SD) for file. 
      //
      fAPISuccess = GetFileSecurity(lpszFileName,
            DACL_SECURITY_INFORMATION, pFileSD, 0, &cbFileSD);
      
      // API should have failed with insufficient buffer.

     
      if(0 != cbFileSD)
      {
          pFileSD = (PSECURITY_DESCRIPTOR)AllocateMemory(cbFileSD);

          if(NULL == pFileSD)
          {
              SaveLastError();
              
              FreeMemory(&pUserSID);
              
              FreeMemory(&szDomain);
              if(NULL != pAliasAdminsSid)
              { 
                FreeSid( pAliasAdminsSid );
              } 
              return FALSE;
          }
      }


      fAPISuccess = GetFileSecurity(lpszFileName,
            DACL_SECURITY_INFORMATION, pFileSD, cbFileSD, &cbFileSD);
      if (!fAPISuccess)
      {
          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 
          return FALSE;
      }

      //
      //  Initialize new SD.
      //
      
      pNewSD = (PSECURITY_DESCRIPTOR)AllocateMemory(cbFileSD); // Should be same size as FileSD.

      if (!pNewSD)
      {
          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 
          return FALSE;

      }

      if (!InitializeSecurityDescriptor(pNewSD,
            SECURITY_DESCRIPTOR_REVISION))
      {
          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          
          FreeMemory(pNewSD);
          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 
          return FALSE;

      }

      //
      // Get DACL from SD.
      //
      if (!GetSecurityDescriptorDacl(pFileSD, &fDaclPresent, &pACL,
            &fDaclDefaulted))
      {

          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          
          FreeMemory(pNewSD);
          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 
          return FALSE;

      }

      //
      //  Get size information for DACL.
      //
      AclInfo.AceCount = 0; // Assume NULL DACL.
      AclInfo.AclBytesFree = 0;
      AclInfo.AclBytesInUse = sizeof(ACL);

      // If not NULL DACL, gather size information from DACL.
      if (fDaclPresent && pACL)
      {

         if(!GetAclInformation(pACL, &AclInfo,
               sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
         {

              SaveLastError();
              
              FreeMemory(&pUserSID);
              
              FreeMemory(&szDomain);
              
              FreeMemory(pFileSD);
              
              FreeMemory(pNewSD);
              if(NULL != pAliasAdminsSid)
              { 
                FreeSid( pAliasAdminsSid );
              } 
              return FALSE;

         }
      }
      
      if(TRUE == bAdminsOwner)
      {

        pace = (ACCESS_ALLOWED_ACE*)AllocateMemory(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAliasAdminsSid) - sizeof(DWORD));
        if(NULL == pace)
        {
              SaveLastError();
              
              FreeMemory(&pUserSID);
              
              FreeMemory(&szDomain);
              
              FreeMemory(pFileSD);
              
              FreeMemory(pNewSD);
              if(NULL != pAliasAdminsSid)
              { 
                FreeSid( pAliasAdminsSid );
              } 
              return FALSE;
        }
        memcpy(&pace->SidStart, pAliasAdminsSid, GetLengthSid(pAliasAdminsSid));

      }
      else
      {

        pace = (ACCESS_ALLOWED_ACE*)AllocateMemory(sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pUserSID) - sizeof(DWORD));

        if(NULL == pace)
        {
              SaveLastError();
              
              FreeMemory(&pUserSID);
              
              FreeMemory(&szDomain);
              
              FreeMemory(pFileSD);
              
              FreeMemory(pNewSD);
              
              return FALSE;
        }

        memcpy(&pace->SidStart,pUserSID,GetLengthSid(pUserSID));
        
      }

      
      pace->Mask = 2032127;

      pace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;

      if(TRUE == bAdminsOwner)
      {
          acesize = (WORD) (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAliasAdminsSid) - sizeof(DWORD));
      }
      else
      {
        acesize = (WORD) (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pUserSID) - sizeof(DWORD) );
      }
      pace->Header.AceSize = acesize;
      pace->Header.AceFlags = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
      //pace->Header.AceFlags = OBJECT_INHERIT_ACE ;
      
     

      //
      //  Compute size needed for the new ACL.
      //
     if(TRUE == bAdminsOwner)
     {
         cbNewACL = AclInfo.AclBytesInUse + sizeof(ACCESS_ALLOWED_ACE)
            + GetLengthSid(pAliasAdminsSid) - sizeof(DWORD) + 100;
     }
     else
     {
         cbNewACL = AclInfo.AclBytesInUse + sizeof(ACCESS_ALLOWED_ACE)
            + GetLengthSid(pUserSID) - sizeof(DWORD) + 100;
     }

      

      //
      //  Allocate memory for new ACL.
      //
      
      pNewACL = (PACL) AllocateMemory(cbNewACL);
      
      if (!pNewACL)
      {
          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          
          FreeMemory(pNewSD);

          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 

          return FALSE;

      }

      
      //
      //  Initialize the new ACL.
      //
      if(!InitializeAcl(pNewACL, cbNewACL, ACL_REVISION))
      {

          SaveLastError();
          //heapfree(pUserSID);
          FreeMemory(&pUserSID);
          //heapfree(szDomain);
          FreeMemory(&szDomain);
          //heapfree(pFileSD);
          FreeMemory(pFileSD);
          //heapfree(pNewSD);
          FreeMemory(pNewSD);
          //heapfree(pNewACL);
          FreeMemory((LPVOID*)pNewACL);

          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 

          return FALSE;

      }

      if(!AddAce(pNewACL,
             ACL_REVISION,
             0xffffffff,
             pace,
             pace->Header.AceSize))
      {
          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          
          FreeMemory(pNewSD);
          
          FreeMemory((LPVOID*)pNewACL);

          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 

          return FALSE;
      }

      pace->Header.AceFlags = CONTAINER_INHERIT_ACE ;

        if(!AddAce(pNewACL,
                    pNewACL->AclRevision,
                    //ACL_REVISION,
                    0xffffffff,
                    pace,
                    pace->Header.AceSize))
        {
          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          
          FreeMemory(pNewSD);
          
          FreeMemory((LPVOID*)pNewACL);

          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 

          return FALSE; 
          
        }

    
      //
      //  Set the new DACL to the file SD.
      //
      if (!SetSecurityDescriptorDacl(pNewSD, TRUE, pNewACL,
            FALSE))
      {

          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          
          FreeMemory(pNewSD);
          
          FreeMemory((LPVOID*)pNewACL);

          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 

          return FALSE;


      }

      //
      //  Set the SD to the File.
      //
      if (!SetFileSecurity(lpszFileName, DACL_SECURITY_INFORMATION,
            pNewSD))
      {

          SaveLastError();
          
          FreeMemory(&pUserSID);
          
          FreeMemory(&szDomain);
          
          FreeMemory(pFileSD);
          
          FreeMemory(pNewSD);
          
          FreeMemory((LPVOID*)pNewACL);

          if(NULL != pAliasAdminsSid)
          { 
            FreeSid( pAliasAdminsSid );
          } 

          return FALSE;


      }

      fResult = TRUE;

      //
      //  Free allocated memory
      //

      if (pUserSID)
      {
         
         FreeMemory(&pUserSID);
      }

      if (szDomain)
      {
         
         FreeMemory(&szDomain);
      }

      if (pFileSD)
      {
       
         FreeMemory(pFileSD);
      }

      if (pNewSD)
      {
       
         FreeMemory(pNewSD);
      }

      if (pNewACL)
      {
        
        FreeMemory((LPVOID*)pNewACL);
      }

      if(NULL != pAliasAdminsSid)
      { 
        FreeSid( pAliasAdminsSid );
      } 

   return fResult;
}


DWORD
IsNTFSFileSystem(IN LPWSTR lpszPath,
                 BOOL bLocalSystem,
                 //BOOL bFileInUNCFormat,
                 BOOL bCurrDirTakeOwnAllFiles,
                 LPWSTR szUserName,
                 OUT PBOOL pbNTFSFileSystem)
/*++
Routine Description:
    This routine finds whether Persistant ACLs are available are not
Arguments:
    [ IN ] lpszPath                 - Path for which to find for Persistant ACLs.
    [ IN ] bLocalSystem             - Information whether local system or not
    [ IN ] bFileInUNCFormat         - whether file in UNC format or not
    [ IN ] bCurrDirTakeOwnAllFiles  - Whether takeown applied for curr directory
    [ IN ] szUserName               - user name
    [ IN ] pbNTFSFileSystem         - To know whether Persistant ACLs are available


Return Value:
    EXIT_SUCCESS if the Function is passed
    EXIT_FAILURE if the function fails
--*/
{
   
   
   DWORD dwi = 0;
   LPWSTR lpszTempDrive = NULL;
   
    if(TRUE == bCurrDirTakeOwnAllFiles)
    {
        dwi = GetCurrentDirectory( 0, lpszTempDrive );
        if( 0 == dwi )
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            return EXIT_FAILURE;
        }

        
        lpszTempDrive = (LPWSTR)AllocateMemory((dwi + 20) * sizeof(WCHAR));
        if(NULL == lpszTempDrive)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return EXIT_FAILURE;
        }

        dwi = GetCurrentDirectory( dwi + 10, lpszTempDrive );
        if( 0 == dwi )
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            FREE_MEMORY(lpszTempDrive);
            return EXIT_FAILURE;
        }

    }
    else
    {
         
         dwi = StringLengthW(lpszPath, 0);
         
         
         lpszTempDrive = (LPWSTR)AllocateMemory((dwi + 20) * sizeof(WCHAR));
         if(NULL == lpszTempDrive)
            {
                
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                return EXIT_FAILURE;
            }

         
         StringCopy( lpszTempDrive, lpszPath, (GetBufferSize(lpszTempDrive) / sizeof(WCHAR)) );

    }

  
    if((TRUE == bLocalSystem) && (StringLengthW( szUserName, 0 ) != 0))
    {
        ShowMessage( stderr, IGNORE_LOCALCREDENTIALS );

        /*if(FALSE == bFileInUNCFormat)
        {
            ShowMessage( stderr, IGNORE_LOCALCREDENTIALS );
        }
        else
        {
            ShowMessage( stderr, GetResString(IDS_IGNORE_CREDENTIALS) );
        }*/
    }

    /*if((FALSE == bLocalSystem) &&  TRUE == bFileInUNCFormat)
    {
        ShowMessage( stderr, GetResString(IDS_IGNORE_CREDENTIALS) );
    }*/

    if(EXIT_FAILURE == IsNTFSFileSystem2(lpszTempDrive, pbNTFSFileSystem))
    {
        FREE_MEMORY(lpszTempDrive);
        return EXIT_FAILURE;
    }
   
   FREE_MEMORY(lpszTempDrive);
   
   return EXIT_SUCCESS;

}


DWORD 
IsNTFSFileSystem2(IN LPWSTR lpszTempDrive,
                  OUT PBOOL pbNTFSFileSystem)
/*++
Routine Description:
    This routine finds whether Persistant ACLs are available are not
Arguments:
    [ IN ] lpszPath                 - Path for which to find for Persistant ACLs.
    [ IN ] bLocalSystem             - Information whether local system or not
    [ IN ] bFileInUNCFormat         - whether file in UNC format or not
    [ IN ] bCurrDirTakeOwnAllFiles  - Whether takeown applied for curr directory
    [ IN ] szUserName               - user name
    [ IN ] pbNTFSFileSystem         - To know whether Persistant ACLs are available


Return Value:
    EXIT_SUCCESS if the function is passed
    EXIT_FAILURE if the function fails
--*/
{
    DWORD dwSysFlags = 0;
    LPWSTR lpszMountPath = NULL;
    WCHAR wszFileSysNameBuf[FILESYSNAMEBUFSIZE] ;
    DWORD dwi = 0;
    LPWSTR lpszTempPath = NULL;

    SecureZeroMemory(wszFileSysNameBuf, FILESYSNAMEBUFSIZE * sizeof(WCHAR));

    lpszTempPath = (LPWSTR)AllocateMemory((StringLengthW(lpszTempDrive, 0) + 10) * sizeof(WCHAR));

    if(NULL == lpszTempPath)
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FAILURE;
    }

    StringCopy(lpszTempPath, lpszTempDrive, (GetBufferSize(lpszTempPath) / sizeof(WCHAR)));

    StringConcat(lpszTempPath, L"\\\\", (GetBufferSize(lpszTempPath) / sizeof(WCHAR)) );

       
     lpszMountPath = (LPWSTR)AllocateMemory((StringLengthW(lpszTempPath, 0) + 10) * sizeof(WCHAR));

     if(NULL == lpszMountPath)
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            FREE_MEMORY(lpszTempPath);
            return EXIT_FAILURE;
        }

    
    if(0 == GetVolumePathName( lpszTempPath, lpszMountPath, StringLengthW(lpszTempPath, 0)))
    {
            
            if( ( ERROR_BAD_NET_NAME == GetLastError() ) ||
                                ( ERROR_BAD_NETPATH == GetLastError() ) ||
                                ( ERROR_INVALID_NAME == GetLastError() ) )
            {
                SetLastError( ERROR_FILE_NOT_FOUND );
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            }
            else
            {
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            }

            
            
            FREE_MEMORY(lpszMountPath);
            FREE_MEMORY(lpszTempPath);
            return EXIT_FAILURE;

    }; 


   dwi = GetVolumeInformation(lpszMountPath,NULL,0,NULL,NULL,&dwSysFlags,wszFileSysNameBuf,FILESYSNAMEBUFSIZE);

   if(dwi == 0)
   {

        if( GetLastError() == ERROR_DIR_NOT_ROOT )
        {
            
            FREE_MEMORY(lpszMountPath);
            FREE_MEMORY(lpszTempPath);
            return EXIT_SUCCESS;
        }
        else
        {
            
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            
            FREE_MEMORY(lpszMountPath);
            FREE_MEMORY(lpszTempPath);
            return EXIT_FAILURE;
        }
   }
   else
   {
       if((dwSysFlags & FS_PERSISTENT_ACLS) == FS_PERSISTENT_ACLS)
       {
            *pbNTFSFileSystem = TRUE;
       }
              
       FREE_MEMORY(lpszMountPath);
       FREE_MEMORY(lpszTempPath);
       return EXIT_SUCCESS;
   }

}

DWORD RemoveStarFromPattern( IN OUT LPWSTR szPattern )
/*++
Routine Description:
    This routine helps to remove the stars if there are more than one star available in pattern
Arguments:
    [ IN OUT ] szPattern   - Pattern to remove stars


Return Value:
    EXIT_SUCCESS if the stars are removed
    EXIT_FAILURE if the function fails
    
--*/
{
    LPWSTR szTempPattern   = NULL;
    DWORD i = 0;
    DWORD j = 0;

    szTempPattern = (LPWSTR) AllocateMemory((StringLengthW(szPattern,0)+1)*sizeof(WCHAR) );
    if( NULL == szTempPattern )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
    
    while( szPattern[i] )
    {
        if( szPattern[i] == L'*' )
        {
            for(;szPattern[i]==L'*' && szPattern[i];i++);
            szTempPattern[j] = L'*';

        }
        else
        {
           szTempPattern[j] = szPattern[i++];
        }
        j++;
    }
    szTempPattern[j]=0;
    
    StringCopy( szPattern, szTempPattern, StringLengthW(szPattern,0)+1 );
    FreeMemory(&szTempPattern);
    return (EXIT_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\timeout\timeout.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    Timeout.h

Abstract:

    This file contains all the definitions for this utility.

Author:

    Wipro Technologies

Revision History:

    14-Jun-2001 Created it.

--*/

//
// macro definitions

// constants

#define MAX_NUM_RECS                2
#define LOW_DATE_TIME_ROLL_OVER     10000000
#define MIN_TIME_VAL                -1
#define MAX_TIME_VAL                100000

#define    MAX_COMMANDLINE_OPTIONS     3

// Option indices
#define OI_USAGE                0
#define OI_TIME_OUT             1
#define OI_NB_OUT               2

// string constants
#define ERROR_TAG               GetResString( IDS_ERROR_TAG )
//#define WAIT_TIME               L"%*lu"
#define NULL_U_STRING           L"\0"
#define SLEEP_FACTOR           1000
#define ONE_BACK_SPACE         L"\b"
#define STRING_FORMAT2         L"%s%*lu"
#define BASE_TEN               10


// Exit values
#define CLEAN_EXIT              0
#define ERROR_EXIT              1

// Function definitions
VOID DisplayUsage( VOID );

BOOL GetTimeInSecs( OUT time_t *ptTime );

BOOL ProcessOptions( IN DWORD argc,
                     IN LPCWSTR argv[],
                     OUT BOOL *pbUsage,
                     OUT DWORD *plTimeActuals,
                     OUT LPWSTR wszTimeout,
                     OUT BOOL *pbNBActuals );

BOOL WINAPI HandlerRoutine( IN DWORD dwCtrlType );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\timeout\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      pch.h
//
//  Abstract:
//
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//
//  Author:
//
//    Wipro Technologies
//
//  Revision History:
//
//    14-Jun-2000 : Created It.
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#if !defined( UNICODE ) && !defined( _UNICODE )
#define _UNICODE
#define UNICODE
#endif

// ignore version 1.0 macros
#define CMDLINE_VERSION 200

//
// public Windows header files
//
#ifdef WIN32
#include <windows.h>
#else
#include <conio.h>
#endif

#include <tchar.h>
#include <winerror.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>

#include <time.h>
#include <stdlib.h>
#include <ctype.h>
#include <Wincon.h>
#include <shlwapi.h>
#include <errno.h>
#include <strsafe.h>



//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\timeout\timeout.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    Timeout.c

Abstract:

    This file implements the parsing of the command line for the arguments and also the
    wait functionality.

Author:

    EricB

Revision History:

    26-Aug-1991 Created by EricB.
    10-Mar-1992 Added the _getch() call to flush the hit key.
    17-Apr-1992 Added countdown display.
    03-Oct-1992 Ported to NT/Win32
    23-May-1995 Added Sleep call
    14-Jun-2001 localization added by Wipro Technologies
    01-Aug-2001 Added /nobreak option by Wipro Technologies
--*/

#include "pch.h"
#include "Timeout.h"
#include "Resource.h"

DWORD _cdecl
wmain(
    IN DWORD argc,
    IN  LPCWSTR argv[]
    )
/*++
Routine Description:
  This is main entry point to this utility. Different function calls are made
  from here to achieve the required functionality.

Arguments:
    [in] argc  : Number of Command line arguments.
    [in] argv  : Pointer to Command line arguments.

Return Value:
    0 on success
    1 on failure.
--*/
{
    //local variables
    CONSOLE_SCREEN_BUFFER_INFO          csbi;

    time_t                              tWait = 0L;
    time_t                              tLast = 0L;
    time_t                              tNow = 0L;
    time_t                              tEnd = 0L;

    DWORD                               dwTimeActuals = 0;
    BOOL                                bNBActuals = 0;
    BOOL                                bUsage = FALSE;
    BOOL                                bResult = FALSE;
    BOOL                                bStatus = FALSE;

    WCHAR                               wszProgressMsg[ MAX_STRING_LENGTH ] = NULL_U_STRING ;
    DWORD                               dwWidth = 0;
    WCHAR                               wszBackup[12] = NULL_U_STRING;
    WCHAR                               wszTimeout[ MAX_RES_STRING] = NULL_U_STRING;
    LPWSTR                              pszStopString =  NULL;
    COORD                               coord = {0};
    HANDLE                              hOutput = NULL;
    HANDLE                              hStdIn = NULL;

    DWORD                               dwMode = 0L;
    DWORD                               dwRead = 0L;

    INPUT_RECORD                        InputBuffer[ MAX_NUM_RECS ] = {0};
    HRESULT                             hr = S_OK;

    if ( NULL == argv )
    {
        SetLastError (ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }

    // Parse the command line and get the actual values
    bResult = ProcessOptions( argc, argv, &bUsage, &dwTimeActuals, wszTimeout , &bNBActuals );
    if( FALSE == bResult )
    {
        // display an error message with respect to the GetReason()
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    // check for invalid syntax
    // 1. check for the case c:\>timeout.exe
    // 2. check for the case c:\>timeout.exe /nobreak
    // 3. check for the case c:\>timeout.exe /? /?
    if ( ( ( 0 == dwTimeActuals ) && ( FALSE == bNBActuals ) && ( FALSE == bUsage ) ) ||
        ( ( 0 == dwTimeActuals ) && ( TRUE == bNBActuals ) ) || ( ( TRUE  == bUsage ) && (argc > 2 )) )
    {
        // display an error message as specified syntax is invalid
        ShowMessage ( stderr, GetResString (IDS_INVALID_SYNTAX) );
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    // Check whether the usage(/?) is specified
    if( TRUE == bUsage )
    {
        // Display the help/usage for the tool
        DisplayUsage();
        ReleaseGlobals();
        return( EXIT_SUCCESS );
    }

    // get the value for timeout (/T)
    tWait = ( time_t ) wcstol(wszTimeout,&pszStopString,BASE_TEN);

    //check whether any non-numeric value specified for timeout value
    // if so, display appropriate error message as invalid timeout value specified.
    // Also, check for overflow and underflow conds
    if( ((NULL != pszStopString) && ( StringLength( pszStopString, 0 ) != 0 )) ||
        (errno == ERANGE) ||
        ( tWait < MIN_TIME_VAL ) || ( tWait >= MAX_TIME_VAL ) )
    {
        ShowMessage ( stderr, GetResString (IDS_ERROR_TIME_VALUE) );
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    // Get the time elapsed in secs since midnight (00:00:00), January 1, 1970
    bResult = GetTimeInSecs( &tNow );
    if( FALSE == bResult )
    {
        ReleaseGlobals();
        // could not get the time so exit...
        return( EXIT_FAILURE );
    }

    // check for /nobreak option is specified
    if ( TRUE == bNBActuals )
    {
        // set console handler to capture the keys like CTRL+BREAK or CRTL+C
        bStatus = SetConsoleCtrlHandler( &HandlerRoutine, TRUE );
        if ( FALSE == bStatus )
        {
            // Format an error message accroding to GetLastError() return by API.
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
            ReleaseGlobals();
            // to remove the handle
            SetConsoleCtrlHandler( NULL, FALSE );
            return( EXIT_FAILURE );
        }
    }

    hStdIn = GetStdHandle( STD_INPUT_HANDLE );
    // check for the input redirection on console and telnet session
    if( ( hStdIn != (HANDLE)0x0000000F ) &&
        ( hStdIn != (HANDLE)0x00000003 ) &&
        ( hStdIn != INVALID_HANDLE_VALUE ) )
    {
       ShowMessage( stderr, GetResString (IDS_INVALID_INPUT_REDIRECT) );
       ReleaseGlobals();
       // to remove the handle
       SetConsoleCtrlHandler( NULL, FALSE );
       return EXIT_FAILURE;
    }

#ifdef WIN32

    // Set input mode so that a single key hit can be detected.
    if ( GetConsoleMode( hStdIn, &dwMode ) == FALSE )
    {
        // Format an error message accroding to GetLastError() return by API.
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
        ReleaseGlobals();
        // to remove the handle
        SetConsoleCtrlHandler( NULL, FALSE );
        return( EXIT_FAILURE );
    }

    // Turn off the following modes:
    dwMode &= ~( ENABLE_LINE_INPUT   |   // Don't wait for CR.
                 ENABLE_ECHO_INPUT   |   // Don't echo input.
                 ENABLE_WINDOW_INPUT |   // Don't record window events.
                 ENABLE_MOUSE_INPUT      // Don't record mouse events.
               );

    // set the input mode of a console's input buffer
    if ( SetConsoleMode( hStdIn, dwMode ) == FALSE )
    {
        // Format an error message accroding to GetLastError() return by API.
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
        ReleaseGlobals();
        // to remove the handle
        SetConsoleCtrlHandler( NULL, FALSE );
        return( EXIT_FAILURE );
    }

    // retrieve number of unread input records in the console's input buffer.
    if( GetNumberOfConsoleInputEvents( hStdIn, &dwRead ) == FALSE )
    {
        // Format an error message accroding to GetLastError() return by API.
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
        ReleaseGlobals();
        // to remove the handle
        SetConsoleCtrlHandler( NULL, FALSE );
        return( EXIT_FAILURE );
    }


    // clear the console input buffer
    if ( FALSE == FlushConsoleInputBuffer (hStdIn))
    {
        // Format an error message accroding to GetLastError() return by API.
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
        ReleaseGlobals();
        // to remove the handle
        SetConsoleCtrlHandler( NULL, FALSE );
        return( EXIT_FAILURE );
    }

#endif

    // check whether /T value is -1. If so, need to wait indefinitely for a key press..
    if( -1 == tWait )
    {
        // check whether /nobreak is specified
        if ( FALSE == bNBActuals )
        {
            // Wait until a key hit.
            ShowMessage( stdout, GetResString( IDS_WAIT_MSG ) );
        }
        else // /nobreak option is not specified
        {
            // Wait until a CTRL+C key hit.
            ShowMessage( stdout, GetResString( IDS_NO_BREAK_MSG ) );
        }

        // Ensure infinite do loop.
        tEnd = tNow + 1;
    }
    else
    {
        // Wait with a timeout period.
        // Compute end time.
        tEnd = tNow + tWait;

         // Figure the time display dwWidth.
         // Need to decrement the time factor (/T) specified at a specified
         // location. To get the position where it needs to be decremented,
         // get the width of the /T value

        if (tWait < 10)
        {
            // if the /T value is less than 10 then set the width as 1
            dwWidth = 1;
        }
        else
        {
            if (tWait < 100)
            {
                // if the /T value is less than 100 then set width as 2
                dwWidth = 2;
            }
            else
            {
                if (tWait < 1000)
                {
                    // if the /T value is less than 1000 then set width as 3
                    dwWidth = 3;
                }
                else
                {
                    if (tWait < 10000)
                    {
                        // if the /T value is less than 10000 then set width as 4
                        dwWidth = 4;
                    }
                    else
                    {
                        // if the /T value is less than 100000 then set width as 5
                        dwWidth = 5;
                    }
                }
            }
        }

        if ( FALSE == Replicate ( wszBackup, ONE_BACK_SPACE, dwWidth, SIZE_OF_ARRAY(wszBackup)))
        {
            // Format an error message accroding to GetLastError() return by API.
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_INTERNAL );
            ReleaseGlobals();
            // to remove the handle
            SetConsoleCtrlHandler( NULL, FALSE );
            return( EXIT_FAILURE );
        }

        //
        // Initialize the console screen buffer structure to zero's
        // and then get the console handle and screen buffer information
        //
        SecureZeroMemory( wszProgressMsg, sizeof( WCHAR ) * MAX_STRING_LENGTH );

        // display the message as ..Waiting for...
        //ShowMessage ( stdout, GetResString (IDS_WAIT_MSG_TIME1 ) );

        //format the message as .. n seconds...for wait time
        //_snwprintf( wszProgressMsg, SIZE_OF_ARRAY(wszProgressMsg), WAIT_TIME , dwWidth, tWait );
        hr = StringCchPrintf( wszProgressMsg, SIZE_OF_ARRAY(wszProgressMsg), GetResString(IDS_WAIT_MSG_TIME1) , dwWidth, tWait );
        if ( FAILED (hr))
        {
            SetLastError (HRESULT_CODE (hr));
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
            ReleaseGlobals();
            // to remove the handle
            SetConsoleCtrlHandler( NULL, FALSE );
            return( EXIT_FAILURE );
        }

        // print the message.
        ShowMessage ( stdout, wszProgressMsg );

        //
        // Initialize the console screen buffer structure to zero's
        // and then get the console handle and screen buffer information
        //
        SecureZeroMemory( &csbi, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
        hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
        if ( NULL != hOutput )
        {
            // Get the info of screen buffer.
            GetConsoleScreenBufferInfo( hOutput, &csbi );
        }

         // set the cursor position
        coord.X = csbi.dwCursorPosition.X;
        coord.Y = csbi.dwCursorPosition.Y;

        // check whether /nobreak is specified or not
        if ( FALSE == bNBActuals )
        {
            // display the message as ...press a key to continue ...
            ShowMessage ( stdout, GetResString (IDS_WAIT_MSG_TIME2) );
        }
        else
        {
            // display the message as ...press CTRL+C to quit...
            ShowMessage ( stdout, GetResString (IDS_NB_MSG_TIME) );
        }

    }

    do
    {
        // Break out if a key is pressed.
#ifdef WIN32
        //reads data from the specified console input buffer without removing it from the buffer.
        if( PeekConsoleInput( hStdIn, InputBuffer, MAX_NUM_RECS, &dwRead ) == FALSE )
        {
            // Format an error message accroding to GetLastError() return by API.
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
            ReleaseGlobals();
            // to remove the handle
            SetConsoleCtrlHandler( NULL, FALSE );
            return( EXIT_FAILURE );
        }

        if (dwRead > 0)
        {
            //reads data from a console input buffer and removes it from the buffer
            if( ReadConsoleInput(hStdIn, InputBuffer, MAX_NUM_RECS, &dwRead ) == FALSE )
            {
                // Format an error message accroding to GetLastError() return by API.
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
                ReleaseGlobals();
                // to remove the handle
                SetConsoleCtrlHandler( NULL, FALSE );
                return( EXIT_FAILURE );
            }

            // Filter the input so that ctrl-c can be generated and passed on.
            // Also, ignore alt key presses and window focus events.
            if( (FOCUS_EVENT != InputBuffer[0].EventType)
                && (VK_CONTROL != InputBuffer[0].Event.KeyEvent.wVirtualKeyCode)
                && (VK_CONTROL != InputBuffer[0].Event.KeyEvent.wVirtualScanCode)
                && (MOUSE_MOVED != InputBuffer[0].Event.MouseEvent.dwEventFlags)
                && (MOUSE_WHEELED != InputBuffer[0].Event.MouseEvent.dwEventFlags)
                && (FALSE != InputBuffer[0].Event.KeyEvent.bKeyDown)
                && (VK_MENU != InputBuffer[0].Event.KeyEvent.wVirtualKeyCode)
                && ( FALSE == bNBActuals ) )
            {
                // exit from the loop
                break;
            }

        }
#else
        //Checks the console for keyboard input.
        if( ( _kbhit() ) && ( FALSE == bNBActuals ) )
        {
            // get characters from the console without echo
            _getch();

            // exit from the loop
            break;
        }
#endif

        // check if /T value is other than -1
        if( -1 != tWait )
        {
            // Update the time and time value display.
            tLast = tNow;

            // call the function GetTimeInSecs to get the current time in seconds
            bResult = GetTimeInSecs( &tNow );
            if( FALSE == bResult )
            {
                // Format an error message accroding to GetLastError() return by API.
                ReleaseGlobals();
                // to remove the handle
                SetConsoleCtrlHandler( NULL, FALSE );
                // could not get the time so exit...
                return( EXIT_FAILURE );
            }

            // check if tLast value is same as tNow.. if not, display the
            // message with tEnd-tNow as a wait value
            if (tLast != tNow)
            {

                // Print the message.
                SecureZeroMemory( wszProgressMsg, sizeof( WCHAR ) * MAX_STRING_LENGTH );

                // fromat the message
                //_snwprintf( wszProgressMsg, SIZE_OF_ARRAY(wszProgressMsg), STRING_FORMAT2 , wszBackup, dwWidth, tEnd - tNow );
                hr = StringCchPrintf( wszProgressMsg, SIZE_OF_ARRAY(wszProgressMsg), STRING_FORMAT2 , wszBackup, dwWidth, tEnd - tNow );
                if ( FAILED (hr))
                {
                    SetLastError (HRESULT_CODE (hr));
                    SaveLastError();
                    ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
                    ReleaseGlobals();
                    // to remove the handle
                    SetConsoleCtrlHandler( NULL, FALSE );
                    return( EXIT_FAILURE );

                }

                // set the cursor position
                SetConsoleCursorPosition( hOutput, coord );

                // display the message as ..tEnd - tNow seconds.. at the current cursor location
                ShowMessage ( stdout, wszProgressMsg );
            }
        }

#ifdef WIN32
        // Sleep for sometime...
        Sleep( 100 );
#endif

    }while( tNow < tEnd ); //check till tNow is less than tEnd value

    ShowMessage ( stdout, L"\n" );
    // release global variables
    ReleaseGlobals();

    // to remove the handle
    SetConsoleCtrlHandler( NULL, FALSE );

    // return 0
    return( EXIT_SUCCESS );
}

BOOL
GetTimeInSecs(
    OUT time_t *ptTime
    )
/*++
Routine Description
    This function calculates the time elapsed in secs since
    midnight (00:00:00), January 1, 1970

Arguments:
    [out] time_t ptTime  :  variable to hold the time in secs

Return Value
    TRUE on success
    FALSE on failure
--*/
{
#ifdef YANK
    //local variables
    SYSTEMTIME  st = {0};
    FILETIME    ft = {0};

    // check for NULL
    if ( NULL == ptTime )
    {
        SetLastError (ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return FALSE;
    }

    // get the system time
    GetSystemTime( &st );

    // convert system time to file time
    if( SystemTimeToFileTime( &st, &ft ) == FALSE )
    {
        // Format an error message accroding to GetLastError() return by API.
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR| SLE_SYSTEM );
        return( FALSE );
    }

    // need to check for LowDateTime rollover...
    *ptTime = ft.dwLowDateTime / LOW_DATE_TIME_ROLL_OVER;
#else
    // This function returns the time elapsed in secs since midnight (00:00:00), January 1, 1970
    time( ptTime );
#endif

    // return 0
    return( TRUE );
}

VOID
DisplayUsage(
    VOID
    )
/*++
Routine Description
    This function displays the usage of this utility

Arguments:
    NONE

Return Value
    NONE
--*/
{
    // local variable
    DWORD dwIndex = 0;

    // Displaying main usage
    for( dwIndex = IDS_HELP_START; dwIndex <= IDS_HELP_END; dwIndex++ )
    {
        ShowMessage( stdout, GetResString( dwIndex ) );
    }

    return;
}

BOOL ProcessOptions(
    IN DWORD argc,
    IN LPCWSTR argv[],
    OUT BOOL *pbUsage,
    OUT DWORD *pwTimeActuals,
    OUT LPWSTR wszTimeout,
    OUT BOOL *pbNBActuals
    )
/*++
Routine Description
    This function processes the command line for the main options

Arguments:
    [in]  argc      : Number of Command line arguments.
    [in]  argv      : Pointer to Command line arguments.
    [out] pbUsage   : Flag that indicates whether the usage is to be displayed or not.
    [out] plTimeoutVal : contains the timeout value specified on the command line

Return Value
    TRUE on success
    FALSE on failure
--*/
{

    // sub-local variables
    TCMDPARSER2*  pcmdParser = NULL;
    TCMDPARSER2 cmdParserOptions[MAX_COMMANDLINE_OPTIONS];
    BOOL bReturn = FALSE;

    // command line options
    const WCHAR szTimeoutOpt[] = L"t";
    const WCHAR szNoBreakOpt[] = L"nobreak";
    const WCHAR szHelpOpt[] = L"?";

    // -? help/usage
    pcmdParser = cmdParserOptions + OI_USAGE;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szHelpOpt;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = CP2_USAGE;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbUsage;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -T <timeout>
    pcmdParser = cmdParserOptions + OI_TIME_OUT;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_TEXT;
    pcmdParser->pwszOptions = szTimeoutOpt;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = CP2_DEFAULT|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = wszTimeout;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -NOBREAK
    pcmdParser = cmdParserOptions + OI_NB_OUT;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szNoBreakOpt;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbNBActuals;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;


    //
    // do the command line parsing and get the appropriate values
    //

    bReturn = DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdParserOptions), cmdParserOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        // Reason is already set by DoParseParam2
        return FALSE;
    }

    pcmdParser = cmdParserOptions + OI_TIME_OUT;
    // get the value for /T value
    *pwTimeActuals = pcmdParser->dwActuals;

    //return 0
    return TRUE;
}



BOOL WINAPI
HandlerRoutine(
  IN DWORD dwCtrlType   //  control signal type
)
/*++
   Routine Description:
    This function handles the control key CTRL+C.

   Arguments:
        IN dwCtrlType : Error code value

   Return Value:
       TRUE on success and FALSE on failure
--*/
{
    // check for CTRL+C key
    if ( dwCtrlType == CTRL_C_EVENT )
    {
        ShowMessage ( stdout, L"\n" );
        // release globals
        ReleaseGlobals ();

        // to remove the handle
        SetConsoleCtrlHandler( NULL, FALSE );

        // exit 0
        ExitProcess ( TRUE );
    }

    // for remaining keys return false
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\waitfor\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

//
// public Windows header files
//
#include <windows.h>
#include <shlwapi.h>

//
// public C header files
//
#include <stdio.h>
#include <tchar.h>
#include <winsock2.h>
//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\waitfor\resource.h ===
#define     IDS_WAITFOR_HELP_BEGIN              2001
#define     IDS_WAITFOR_HELP_1                  2002
#define     IDS_WAITFOR_HELP_2                  2003
#define     IDS_WAITFOR_HELP_3                  2004
#define     IDS_WAITFOR_HELP_4                  2005
#define     IDS_WAITFOR_HELP_5                  2006
#define     IDS_WAITFOR_HELP_6                  2007
#define     IDS_WAITFOR_HELP_7                  2008
#define     IDS_WAITFOR_HELP_8                  2009
#define     IDS_WAITFOR_HELP_9                  2010
#define     IDS_WAITFOR_HELP_10                 2011
#define     IDS_WAITFOR_HELP_11                 2012
#define     IDS_WAITFOR_HELP_12                 2013
#define     IDS_WAITFOR_HELP_13                 2014
#define     IDS_WAITFOR_HELP_14                 2015
#define     IDS_WAITFOR_HELP_15                 2016
#define     IDS_WAITFOR_HELP_16                 2017
#define     IDS_WAITFOR_HELP_17                 2018
#define     IDS_WAITFOR_HELP_18                 2019
#define     IDS_WAITFOR_HELP_19                 2020
#define     IDS_WAITFOR_HELP_20                 2021
#define     IDS_WAITFOR_HELP_21                 2022
#define     IDS_WAITFOR_HELP_22                 2023
#define     IDS_WAITFOR_HELP_23                 2024
#define     IDS_WAITFOR_HELP_24                 2025
#define     IDS_WAITFOR_HELP_25                 2026
#define     IDS_WAITFOR_HELP_26                 2027
#define     IDS_WAITFOR_HELP_27                 2028
#define     IDS_WAITFOR_HELP_28                 2029
#define     IDS_WAITFOR_HELP_29                 2030
#define     IDS_WAITFOR_HELP_30                 2031
#define     IDS_WAITFOR_HELP_31                 2032
#define     IDS_WAITFOR_HELP_32                 2033
#define     IDS_WAITFOR_HELP_33                 2034
#define     IDS_WAITFOR_HELP_34                 2035
#define     IDS_WAITFOR_HELP_35                 2036
#define     IDS_WAITFOR_HELP_36                 2037
#define     IDS_WAITFOR_HELP_37                 2038
#define     IDS_WAITFOR_HELP_38                 2039
#define     IDS_WAITFOR_HELP_39                 2040
#define     IDS_WAITFOR_HELP_40                 2041
#define     IDS_WAITFOR_HELP_41                 2042
#define     IDS_WAITFOR_HELP_42                 2043
#define     IDS_WAITFOR_HELP_43                 2044
#define     IDS_WAITFOR_HELP_44                 2045
#define     IDS_WAITFOR_HELP_45                 2046
#define     IDS_WAITFOR_HELP_46                 2047
#define     IDS_WAITFOR_HELP_END                2048


#define     IDS_ERROR_SEND_SIGNAL               251
#define     IDS_ERROR_CREATE_MAILSLOT           252
#define     IDS_ERROR_TIMEOUT                   253
#define     IDS_UNEXPECTED_ERROR                254
#define     IDS_ERROR_ZERO_TIMEOUT              255
#define     IDS_ERROR_MUTUAL_EX                 256
#define     IDS_NULL_SERVER                     257
#define     IDS_NULL_USER                       258
#define     IDS_NULL_SIGNAL                     259
#define     IDS_ERROR_SIGNAL                    260
#define     IDS_ERROR_SYNTAX                    261
#define     IDS_ERROR_HOSTNAME                  262
#define     IDS_INVALID_TIMEOUT_VAL             263
#define     IDS_ERROR_SIG_LENGTH                264
#define     IDS_ERROR_SIG_CHAR                  265
#define     IDS_IGNORE_LOCALCREDENTIALS         266
#define     IDS_USER_BUT_NOMACHINE              267
#define     IDS_PASSWD_BUT_NOUSER               268
#define     IDS_SIGNAL_RECD                     501
#define     IDS_SIGNAL_SENT                     502
#define     IDS_ERROR_SYSTEM_NAME               503
#define     IDS_ERROR_HANDLE                    504
#define     IDS_ERROR_SEND_MESSAGE              505
#define     IDS_ERROR_SEND_MESSAGE2             506
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\waitfor\waitfor.cpp ===
/*++


  Copyright (C) Microsoft Corporation
  All rights reserved.

  Module Name: waitfor.cpp

  Abstract
      This module is used to send and receive signals.


  Author:

      Microsoft

  Revision History:

      Created  by Microsoft
      Modified on 29-6-2000 by Wipro Technologies

--*/


#include "pch.h"
#include "resource.h"
#include "waitfor.h"
#include <strsafe.h>

struct Params
{
    const WCHAR *szSignalName; // To hold the name of the signal
    BOOL fSignal;              // To hold the Boolean
    UINT uiTimeOut;            // To hold the Time to wait for.
};

class CWaitFor
{
private:
WCHAR  m_szSignal[MAX_STRING_LENGTH] ;
WCHAR  m_szServer[MAX_STRING_LENGTH];
LPWSTR m_szUserName;
WCHAR m_szPassword[MAX_STRING_LENGTH] ;
WCHAR m_szDefault[MAX_STRING_LENGTH]  ;
BOOL m_bNeedPwd  ;
BOOL m_bConnFlag ;
LONG m_dwTimeOut ;
BOOL m_bLocalSystem;
TCMDPARSER2 cmdOptions[MAX_OPTIONS] ;
Params m_Parameters ;

public:
    VOID ShowUsage();
    DWORD ProcessCmdLine();
    CWaitFor();
    ~CWaitFor();
    DWORD ProcessOptions( DWORD argc ,LPCWSTR argv[] ) ;
    DWORD PerformOperations();
    DWORD CheckForValidCharacters();
    DWORD ConnectRemoteServer();

public:
    BOOL bShowUsage ;
};

CWaitFor ::CWaitFor()
/*++
  Routine description   : Constructor

  Arguments             : none

  Return Value          : None

--*/
{
        //Initialise the variables.
        StringCopy(m_szSignal,NULL_U_STRING, SIZE_OF_ARRAY(m_szSignal));
        StringCopy(m_szServer,NULL_U_STRING, SIZE_OF_ARRAY(m_szPassword));
        StringCopy(m_szPassword,NULL_U_STRING, SIZE_OF_ARRAY(m_szPassword));
        StringCopy(m_szDefault,NULL_U_STRING, SIZE_OF_ARRAY(m_szDefault));
        m_szUserName = NULL;
        m_bNeedPwd = FALSE;
        m_bLocalSystem = FALSE;
        m_dwTimeOut = 0 ;
        m_bConnFlag = TRUE ;
        bShowUsage = FALSE;
}

CWaitFor :: ~CWaitFor()
/*++

  Routine description   : Destructor. All the memory frreing is being done here
                          The connection established to the remote  system is also
                          being closed here if required.

  Arguments             : None.

  Return Value          : None

--*/

{
 //
    // Closing the connection to the remote system
    // if there is no previous connection established
    //
    if(m_bConnFlag == TRUE && !m_bLocalSystem)
    {
        CloseConnection(m_szServer);
    }
    //release all the Global memory allocations.
    FreeMemory( (LPVOID *) &m_szUserName );
    ReleaseGlobals();

}



DWORD CWaitFor::ProcessCmdLine()
/*++

  Routine description   : Function used to process the command line arguments
                          specified by the user.

  Arguments:
             none


  Return Value        : DWORD
         EXIT_SUCCESS : If the utility successfully performs the specified operation.
         EXIT_FAILURE : If the utility is unsuccessful in performing the specified operation.
--*/
{

    m_Parameters.uiTimeOut = MAILSLOT_WAIT_FOREVER;
    m_Parameters.szSignalName = NULL;
    m_Parameters.fSignal = FALSE;


    if( (cmdOptions[OI_TIMEOUT].dwActuals != 0 ) && (cmdOptions[OI_SIGNAL].dwActuals != 0 ) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_MUTUAL_EX));
        return EXIT_FAILURE ;
    }


    //
    // Display an error message if the user enters Timeout option
    // and does not enter any signal name.
    if( ( StringLengthW(m_szDefault, 0) == 0 ) && (m_dwTimeOut != 0) )
    {
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_SYNTAX));

        return EXIT_FAILURE ;
    }


    if(m_dwTimeOut != 0)
    {
        m_Parameters.uiTimeOut = m_dwTimeOut*TIMEOUT_CONST ;
    }


    //set the Signal parameter to true
    // if the User enters a signal name to send.

     if(StringLengthW(m_szSignal, 0) )
     {
        m_Parameters.fSignal = TRUE;
        m_Parameters.szSignalName = m_szSignal ;
     }

    //
    //set the Signal parameter to true
    //if the User enters a signal name to wait for.
    if(StringLengthW(m_szDefault, 0) != 0 )
    {
        m_Parameters.fSignal = TRUE;
        m_Parameters.szSignalName = m_szDefault ;
    }

   return EXIT_SUCCESS ;
}



VOID
CWaitFor :: ShowUsage()

/*++

  Routine description   : member function to show help.
  Arguments             : none.
  Return Value          : none

--*/
{


    DWORD dwIndex = IDS_WAITFOR_HELP_BEGIN ;

    for( ;  dwIndex <= IDS_WAITFOR_HELP_END ; dwIndex++ )
    {
        ShowMessage( stdout,GetResString( dwIndex ) );
    }

    return ;
}



DWORD CWaitFor::PerformOperations()
/*++

  Routine description   : This routine is used to either send a signal or wait for
                          a particular signal for a specified time interval.

  Arguments:
               none .

  Return Value        : DWORD
         EXIT_FAILURE : If the utility successfully performs the operation.
         EXIT_SUCCESS : If the utility is unsuccessful in performing the specified
                        operation.
--*/

{
    HANDLE hMailslot ;

    WCHAR szComputerName[MAX_STRING_LENGTH]   =  NULL_U_STRING ;
    DWORD dwNumWritten                                =  0 ;
    WCHAR szSignalName[MAX_RES_STRING]                =  NULL_U_STRING ;
    WCHAR szMailSlot[MAX_RES_STRING]                  =  MAILSLOT ;
    WCHAR szHostName[MAX_STRING_LENGTH]       =  NULL_U_STRING;
    WCHAR szMailSlot2[MAX_RES_STRING]                 =  MAILSLOT2 ;
    DWORD dwBytesRead = 0;
    BOOL fRead = FALSE ;
    BOOL fWrite = FALSE ;
    BOOL bRetVal = FALSE ;
    DWORD dwError = 0 ;
    DWORD dwComputerNameLen =  SIZE_OF_ARRAY(szComputerName);

    bRetVal = GetComputerName(szComputerName, &dwComputerNameLen);
    if ( bRetVal == 0)
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYSTEM_NAME));
        return EXIT_FAILURE ;
    }

    //display an error message if the signal length exceeds 225 characters
    if( StringLengthW(m_Parameters.szSignalName, 0) > 225 )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SIG_LENGTH));
        return EXIT_FAILURE ;

    }

    if ( EXIT_FAILURE == CheckForValidCharacters() )
    {
        ShowLastErrorEx(stderr,SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE ;
    }

    if( (StringLengthW(m_szServer, 0) > 0 ) )
    {
        //remove of //s infront of server name
        if( IsUNCFormat(m_szServer) )
        {
            StringCopy( szHostName, m_szServer+2, SIZE_OF_ARRAY(szHostName) );
            StringCopy( m_szServer, szHostName, SIZE_OF_ARRAY(m_szServer) );
        }

        //check if it is ip address or not
        if( IsValidIPAddress(m_szServer) )
        {
            //if it is Ip address but local system like 127.0.0.1 or local ip address
            if( IsLocalSystem( m_szServer ) )
            {
                 StringCopy( szHostName, szComputerName, SIZE_OF_ARRAY(szHostName));
            }
            else
            {
                dwComputerNameLen = MAX_STRING_LENGTH+1;
              //not local, get the remote system name
              if (FALSE == GetHostByIPAddr( m_szServer, szHostName, &dwComputerNameLen, FALSE))
              {
                    ShowMessage(stderr,GetResString(IDS_ERROR_HOSTNAME));
                    return EXIT_FAILURE;
              }
            }
        }
        else
         {
            //this is not a ip address, so copy server name as host name
                StringCopy(szHostName,m_szServer, SIZE_OF_ARRAY(szHostName) );
         }
    }
    else
    {
        //this not a remote system, so copy local host name as host name
         StringCopy(szHostName,szComputerName, SIZE_OF_ARRAY(szHostName));
    }

     if ( ( m_Parameters.fSignal && ( (m_dwTimeOut ==0) && ( cmdOptions[OI_TIMEOUT].dwActuals != 0 ) ) ) || StringLengthW(m_szSignal, 0) != 0)
     {
        //if the target system is a local system.
          if(StringLengthW(m_szServer, 0)==0)
          {
             StringCchPrintf(szSignalName, SIZE_OF_ARRAY(szSignalName), szMailSlot2,m_Parameters.szSignalName);
          }
          else
          {
            //If the target system is a remote system.
            //form the appropriate path
            //
             StringCopy(szSignalName,BACKSLASH4, SIZE_OF_ARRAY(szSignalName));
             if( IsUNCFormat( szHostName ) )
                  StringConcat(szSignalName,szHostName+2, SIZE_OF_ARRAY(szSignalName));
             else
                 StringConcat(szSignalName,szHostName, SIZE_OF_ARRAY(szSignalName));

             StringConcat(szSignalName,BACKSLASH2, SIZE_OF_ARRAY(szSignalName));
             StringConcat(szSignalName,MAILSLOT1, SIZE_OF_ARRAY(szSignalName));
             StringConcat(szSignalName,BACKSLASH2, SIZE_OF_ARRAY(szSignalName));
             StringConcat(szSignalName,m_Parameters.szSignalName, SIZE_OF_ARRAY(szSignalName));
          }

    
        hMailslot = CreateFile(
                                szSignalName,
                                GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

        //display a error message and exit if unable to create a mailslot.
        if ( INVALID_HANDLE_VALUE == hMailslot )
        {
            ShowMessage(stderr,GetResString(IDS_ERROR_SEND_MESSAGE));
            return EXIT_FAILURE;
        }

        if(StringLengthW(m_szServer, 0) > 0)
        {
            fWrite = WriteFile(hMailslot, szHostName,
                StringLengthW(szHostName, 0)+1, &dwNumWritten, NULL);

        }
        else
        {
            fWrite = WriteFile(hMailslot, szComputerName,
                StringLengthW(szComputerName, 0)+1, &dwNumWritten, NULL);
        }
        if( !fWrite )   
        {

            switch( GetLastError() )
            {
                case ERROR_NETWORK_UNREACHABLE :
                    ShowMessage( stderr, GetResString(IDS_ERROR_SEND_MESSAGE2) );
                    CloseHandle(hMailslot);
                    return EXIT_FAILURE;
                default :
                    ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_SEND_SIGNAL),m_Parameters.szSignalName);
                    return EXIT_FAILURE;
            }
        }


        //close the mail slot handle.
        CloseHandle(hMailslot);
        if (bRetVal == 0)
        {
            ShowMessage(stderr,GetResString(IDS_ERROR_HANDLE));
            return EXIT_FAILURE ;
        }

        if (fWrite)
        {
            ShowMessage( stdout, NEWLINE );
            ShowMessage(stdout,GetResString(IDS_SIGNAL_SENT));
            return EXIT_SUCCESS;
        }
    }
    else
    {
        
         if(StringLengthW(m_szServer, 0)==0)
         {
            StringCchPrintf(szSignalName, MAX_RES_STRING, szMailSlot,m_Parameters.szSignalName);
         }
         else
         {
            StringCchPrintf( szSignalName, MAX_RES_STRING, L"%s%s%s%s%s%s", BACKSLASH4, szHostName, BACKSLASH2,MAILSLOT1,BACKSLASH2,m_Parameters.szSignalName );
         }

        //swprintf(szSignalName, szMailSlot, m_Parameters.szSignalName);
        // Create a mail slot
        hMailslot = CreateMailslot(szSignalName,256,m_Parameters.uiTimeOut, NULL);

        //Display a error message and exit if unable to create a mail slot.
        if (hMailslot == INVALID_HANDLE_VALUE)
        {
            ShowMessage(stderr,GetResString(IDS_ERROR_CREATE_MAILSLOT));
            return EXIT_FAILURE;
        }

        //Read the data from the mail slot.
        fRead = ReadFile(hMailslot, szComputerName,MAX_STRING_LENGTH, &dwBytesRead, NULL);

        //Close the Handle to the mail slot.
        CloseHandle(hMailslot);

        if (!fRead)
        {
            dwError = GetLastError();

            if (GetLastError() == ERROR_SEM_TIMEOUT)
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_TIMEOUT),m_Parameters.szSignalName);
            }
            else
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_UNEXPECTED_ERROR),dwError);
            }
            return EXIT_FAILURE;
        }
        else
        {
            ShowMessage( stdout, NEWLINE );
            ShowMessage(stdout,GetResString(IDS_SIGNAL_RECD));
        }
    }
    return EXIT_SUCCESS;
}

DWORD CWaitFor:: ProcessOptions(
     IN DWORD argc ,
     IN LPCWSTR argv[]
    )
/*++

  Routine description   : This function parses the options specified at the command prompt
  Arguments:
        [ in  ] argc            : count of elements in argv
        [ in  ] argv            : command-line parameterd specified by the user


  Return Value        : DWORD
         EXIT_FAILURE : If the utility successfully performs the operation.
         EXIT_SUCCESS : If the utility is unsuccessful in performing the specified
                        operation.
--*/

{
    PTCMDPARSER2 pcmdOption;

    StringCopy(m_szPassword, L"*", MAX_STRING_LENGTH);

    //Fill each structure with the appropriate value.
    // help option
    pcmdOption  = &cmdOptions[OI_USAGE] ;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP_USAGE ;
    pcmdOption->pValue = &bShowUsage;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_HELP;
    StringCopyA(cmdOptions[OI_USAGE].szSignature, "PARSER2", 8 );
    
    //server
    pcmdOption  = &cmdOptions[OI_SERVER] ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->pValue = m_szServer ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = MAX_STRING_LENGTH;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_SERVER;
    StringCopyA(cmdOptions[OI_SERVER].szSignature, "PARSER2", 8 );
   
    //User
    pcmdOption  = &cmdOptions[OI_USER] ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL ;
    pcmdOption->pValue = NULL ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_USER;
    StringCopyA(cmdOptions[OI_USER].szSignature, "PARSER2", 8 );
    
    //password
    pcmdOption  = &cmdOptions[OI_PASSWORD] ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL ;
    pcmdOption->pValue = m_szPassword ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = MAX_STRING_LENGTH;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_PASSWORD;
    StringCopyA(cmdOptions[OI_PASSWORD].szSignature, "PARSER2", 8 );
    
     pcmdOption  = &cmdOptions[OI_SIGNAL] ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY; //CP2_VALUE_OPTIONAL ;
    pcmdOption->pValue = m_szSignal ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = MAX_STRING_LENGTH;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_SIGNAL;
    StringCopyA(cmdOptions[OI_SIGNAL].szSignature, "PARSER2", 8 );
    
    pcmdOption  = &cmdOptions[OI_TIMEOUT] ;
    pcmdOption->dwType = CP_TYPE_NUMERIC;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY ;
    pcmdOption->pValue = &m_dwTimeOut ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = MAX_STRING_LENGTH;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_TIMEOUT;
    StringCopyA(cmdOptions[OI_TIMEOUT].szSignature, "PARSER2", 8 );

    //default
    pcmdOption  = &cmdOptions[OI_DEFAULT] ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_DEFAULT ;
    pcmdOption->pValue = m_szDefault ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = MAX_STRING_LENGTH;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=OPTION_DEFAULT;
    StringCopyA(cmdOptions[OI_DEFAULT].szSignature, "PARSER2", 8 );

    //parse the command line arguments
    if ( ! DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        DISPLAY_MESSAGE(stderr,GetResString(IDS_TAG_ERROR));
        DISPLAY_MESSAGE(stderr,SPACE_CHAR);
        DISPLAY_MESSAGE(stderr,GetReason());
        return (EXIT_FAILURE);
    }

    m_szUserName = (LPWSTR)cmdOptions[OI_USER].pValue;

    TrimString(m_szSignal, TRIM_ALL);
    TrimString(m_szDefault, TRIM_ALL);
    TrimString(m_szServer, TRIM_ALL);
    TrimString(m_szUserName, TRIM_ALL);

    //this is to check if both signal to wait and /si are mentioned
    if( StringLengthW( m_szDefault, 0) != 0 && cmdOptions[OI_SIGNAL].dwActuals != 0 )
    {
        ShowMessage( stderr, GetResString(IDS_ERROR_SYNTAX) );
        return( EXIT_FAILURE );
    }

    //
    // Display an error message if user gives -u with out -s
    //
    if( (cmdOptions[ OI_USER ].dwActuals != 0 ) && ( cmdOptions[ OI_SERVER ].dwActuals == 0 ) )
    {
        ShowMessage( stderr, GetResString(IDS_USER_BUT_NOMACHINE) );
        return( EXIT_FAILURE );
    }

    //
    // Display an error message if user gives -p with out -u
    //
    if( ( cmdOptions[ OI_USER ].dwActuals == 0 ) && ( 0 != cmdOptions[ OI_PASSWORD ].dwActuals  ) )
    {
        ShowMessage( stderr, GetResString(IDS_PASSWD_BUT_NOUSER) );
        return( EXIT_FAILURE );
    }


    //check for remote system without specifying  /si option and
    if((StringLengthW(m_szServer,0) !=0) &&  cmdOptions[OI_SIGNAL].dwActuals == 0)
    {
        ShowMessage( stderr, GetResString(IDS_ERROR_SYNTAX) );
        return( EXIT_FAILURE );
    }

    //check for remote system can't wait for a signal
    if((StringLengthW(m_szServer, 0) !=0) && (cmdOptions[OI_DEFAULT].dwActuals != 0  ) )
    {
        ShowMessage( stderr, GetResString(IDS_ERROR_SYNTAX) );
        return( EXIT_FAILURE );
    }

    //check for null default value
    if( ( 0 != cmdOptions[OI_DEFAULT].dwActuals ) && ( 0 == StringLengthW(m_szDefault, 0) ) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYNTAX));
        return( EXIT_FAILURE );
    }

    //check for null /si value
    if( ( 0 != cmdOptions[OI_SIGNAL].dwActuals ) && ( 0 == StringLengthW(m_szSignal, 0) ) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYNTAX));
        return( EXIT_FAILURE );
    }

    if ( ( (m_dwTimeOut <= 0 ) || (m_dwTimeOut >99999 ) )&&( 0 != cmdOptions[OI_TIMEOUT].dwActuals )  )
    {
        DISPLAY_MESSAGE ( stderr, GetResString ( IDS_INVALID_TIMEOUT_VAL) );
        return EXIT_FAILURE;
    }

    if( IsUNCFormat(m_szServer) )
    {
        StringCopy(m_szServer, m_szServer+2, SIZE_OF_ARRAY(m_szServer) );
    }
    
    //check if password is needed or not
    if(IsLocalSystem( m_szServer ) == FALSE )
    {
        // set the bNeedPassword to True or False .
        if ( cmdOptions[ OI_PASSWORD ].dwActuals != 0 &&
             m_szPassword != NULL && StringCompare( m_szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            m_bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ OI_PASSWORD ].dwActuals == 0 &&
                ( cmdOptions[ OI_SERVER ].dwActuals != 0 || cmdOptions[ OI_USER ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            m_bNeedPwd = TRUE;
            if ( m_szPassword != NULL )
            {
                StringCopy( m_szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }

        //allocate memory if /u is not specified 
        if( NULL == m_szUserName )
        {
            m_szUserName = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        }
    }

     return EXIT_SUCCESS ;
}

DWORD
 CWaitFor::ConnectRemoteServer()
/*++

  Routine description   : This function connects to the Remote server.

  Arguments: None


  Return Value        : DWORD
         EXIT_FAILURE : If the utility successfully performs the operation.
         EXIT_SUCCESS : If the utility is unsuccessful in performing the specified
                        operation.
--*/
{
    BOOL bResult = FALSE ;

    //
    //checking for the local system
    //

    m_bLocalSystem = IsLocalSystem(m_szServer);
   
    if( m_bLocalSystem  && StringLengthW(m_szUserName, 0) != 0)
    {
        ShowMessage( stderr, NEWLINE );
        ShowMessage( stderr, GetResString( IDS_IGNORE_LOCALCREDENTIALS ) );
        return (EXIT_SUCCESS);
    }

    if ( ( StringLengthW(m_szServer, 0) != 0 ) && !m_bLocalSystem )
    {

         //establish a connection to the Remote system specified by the user.
        bResult = EstablishConnection(m_szServer,
                                      m_szUserName,
                                     (StringLengthW(m_szUserName,0)!=0?SIZE_OF_ARRAY_IN_CHARS(m_szUserName):MAX_STRING_LENGTH),
                                      m_szPassword,
                                      SIZE_OF_ARRAY(m_szPassword),
                                      m_bNeedPwd);

        if (bResult == FALSE)
        {
            ShowMessage( stderr,GetResString(IDS_TAG_ERROR ));
            ShowMessage( stderr,SPACE_CHAR );
            ShowMessage( stderr, GetReason());
            SecureZeroMemory( m_szPassword, SIZE_OF_ARRAY(m_szPassword) );
            return EXIT_FAILURE ;
        }
        else
        {
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                m_bConnFlag = FALSE ;
                break;

            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    m_bConnFlag = FALSE ;
                    ShowMessage( stderr, GetResString(IDS_TAG_WARNING) );
                    ShowMessage( stderr, EMPTY_SPACE );
                    ShowMessage( stderr, GetReason() );
                    break;
                }
            }
        }
       SecureZeroMemory( m_szPassword, SIZE_OF_ARRAY(m_szPassword) );
    }


    if( StringLength(m_szServer, 0) != 0 && TRUE == IsLocalSystem(IsUNCFormat(m_szServer)?m_szServer+2:m_szServer) )
        {
            if( StringLength( m_szUserName, 0 ) > 0 )
            {
                ShowMessage( stdout, NEWLINE );
                ShowMessage( stdout, GetResString(IDS_IGNORE_LOCALCREDENTIALS) );
            }
        }

    return EXIT_SUCCESS;
}



DWORD CWaitFor::CheckForValidCharacters()
{
    // local variables
    char ch;
    unsigned char uch;
    LPSTR pszSignal = NULL;
    DWORD dw = 0, dwLength = 0;

    // validate the input parameters
    if ( NULL == m_Parameters.szSignalName )
    {
        SetLastError( ERROR_INVALID_NAME );
        SaveLastError();
        return EXIT_FAILURE;
    }

    //
    // find the required no. of byte to translate the UNICODE name into ANSI
    //
    dwLength = WideCharToMultiByte( GetConsoleOutputCP(), 0, m_Parameters.szSignalName, -1, NULL, 0, NULL, NULL );
    if ( 0 == dwLength )
    {
        SetLastError( ERROR_INVALID_NAME );
        SaveLastError();
        return EXIT_FAILURE;
    }

    //
    // check the signal name for validity
    // here to optimize the checking, we will get the normal length of the string in UNCIDE format and
    // will compare to the length we got for translating it into Multi-byte
    // if we find that the two lengths are different, then, the signal name might have contained the double-byte
    // characters -- which is invalid and not allowed
    // so ...
    //
    if ( StringLength( m_Parameters.szSignalName, 0 ) != dwLength - 1 )
    {
        // yes -- the signal name has double-byte characters
        SetLastError( ERROR_INVALID_NAME );
        SaveLastError();
        return EXIT_FAILURE;
    }

    //
    // now, we are sure the signal name doesn't contain double-byte characters
    // the second step to validate the signal is -- making sure that signal name contains
    // only characters a-z, A-Z, 0-9 and upper ASCII characters i.e; ASCII characters in the range of 128-255
    // so, convert the UNICODE string into ANSI format ( multi-byte (or) single-byte )
    // for that
    //      #1. Allocate the needed memory
    //      #2. Do the conversion
    //      #3. do the validation
    //

    // #1
    pszSignal = (LPSTR) AllocateMemory( dwLength*sizeof( CHAR ) );
    if ( NULL == pszSignal )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return EXIT_FAILURE;
    }

    // #2 -- assuming no need to for error checking
    WideCharToMultiByte( GetConsoleOutputCP(), 0, m_Parameters.szSignalName, -1, pszSignal, dwLength, NULL, NULL );

    // #3
    // in this step, traverse thru all the characters in the string one-by-one and validate it
    for( dw = 0; dw < dwLength - 1; dw++ )
    {
        // get the current character in the string into local buffer
        ch = pszSignal[ dw ];           // signed version
        uch = static_cast< unsigned char >( pszSignal[ dw ] );

        // signed comparision --> a-z, A-Z and 0-9
        if ( ( ch >= 48 && ch <= 57 ) || ( ch >= 65 && ch <= 90 ) || ( ch >= 97 && ch <= 122 ) )
        {
            // this particular character is acceptable in the signal name
            continue;
        }

        
        // unsigned comparision --> ASCII 128 - 255
        if ( uch < 128 || uch > 255 )
        {
            // this character is not acceptable for the signal name
            FreeMemory((LPVOID*) &pszSignal );
            pszSignal = NULL;
            SetReason( GetResString(IDS_ERROR_SIG_CHAR) );
            return EXIT_FAILURE;
        }

    }
    
    if( pszSignal != NULL )
    {
        FreeMemory((LPVOID*) &pszSignal );
    }

    return EXIT_SUCCESS;
}

DWORD __cdecl wmain(
    IN DWORD argc,
    IN LPCWSTR argv[]
    )
/*++

  Routine description   : Main function which calls all the other main functions
                          depending on the option specified by the user.

  Arguments:
          [in] argc     : argument count specified at the command prompt.
          [in] argv     : arguments specified at the command prompt.

  Return Value        : DWORD
         0            : If the utility successfully performs the operation.
         1            : If the utility is unsuccessful in performing the specified
                        operation.
--*/

{
    
    CWaitFor WaitFor ;

     //display a syntax error if no arguments are given.
    if(argc==1)
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYNTAX));
        return (EXIT_FAILURE);
    }

    //
    //Process the command line arguments.
    //
    if(WaitFor.ProcessOptions( argc,argv) == EXIT_FAILURE)
    {
        return EXIT_FAILURE ;
    }

    if((WaitFor.bShowUsage ==TRUE) && ( argc > 2 ) )
    {

        ShowMessage(stderr,GetResString(IDS_ERROR_SYNTAX));
        return EXIT_FAILURE ;
    }

    //
    //display the help if the user selects help.
    //
    if (WaitFor.bShowUsage == TRUE )
    {
        WaitFor.ShowUsage();
        return EXIT_SUCCESS ;
    }

    //
    // Perform the validations and
    // display error messages if required.
    //
    if(WaitFor.ProcessCmdLine() == EXIT_FAILURE )
    {
        return EXIT_FAILURE ;
    }

    if( WaitFor.ConnectRemoteServer() == EXIT_FAILURE )
    {
        return EXIT_FAILURE;
    }
    //
    //Sends the signal or waits for the signal depending upon the
    // user specification
    if(WaitFor.PerformOperations() == EXIT_FAILURE)
    {
           return EXIT_FAILURE ;
    }

    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\where\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

//
// public Windows header files
//
#include <windows.h>
#include <shlwapi.h>

//
// public C header files
//
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <malloc.h>


//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\waitfor\waitfor.h ===
// *********************************************************************************
//
//
//  File: waitfor.h
//  Copyright (C) Microsoft Corporation
//  All rights reserved.
//
//  Abstract
//      This module is the header file used for WaitFor.cpp
//
//  Syntax
//
//    WaitFor [-s server ] [-u [domain\]username [-p password]]
//                { [-si ] | [-t time interval] } signal
//
//  Author:
//
//    29-6-2000 by J.S.Vasu .
//
//  Revision History:
//
//
//    Modified on 1-7-2000 by J.S.Vasu .
//
// *********************************************************************************


#ifndef __WAITFOR_H
#define __WAITFOR_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

#define MAX_OPTIONS  7


#define OPTION_SERVER   L"s"
#define OPTION_USER     L"u"
#define OPTION_PASSWORD L"p"
#define OPTION_SIGNAL   L"si"
#define OPTION_HELP     L"?"
#define OPTION_TIMEOUT L"t"
#define OPTION_DEFAULT L""

#define EXIT_FAILURE    1
#define EXIT_SUCCESS    0

#define NULL_U_STRING   L"\0"

#define MAILSLOT        L"\\\\.\\mailslot\\WAITFOR.EXE\\%s"
#define MAILSLOT2        L"\\\\*\\mailslot\\WAITFOR.EXE\\%s"

#define MAILSLOT1       L"mailslot\\WAITFOR.EXE"

#define BACKSLASH4 L"\\\\"
#define BACKSLASH2 L"\\"

#define EMPTY_SPACE _T(" ")

#define SIZE_OF_ARRAY_IN_CHARS(x) \
           GetBufferSize(x)/sizeof(WCHAR)

#define TIMEOUT_CONST 1000

#define OI_USAGE    0
#define OI_SERVER   1
#define OI_USER     2
#define OI_PASSWORD 3
#define OI_SIGNAL   4
#define OI_TIMEOUT  5
#define OI_DEFAULT  6

#define SPACE_CHAR L" "
#define NEWLINE     L"\n"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\where\resource.h ===
#define IDS_MAIN_HELP_BEGIN             501
#define IDS_STRING1                     502
#define IDS_STRING2                     503
#define IDS_STRING3                     504
#define IDS_STRING4                     505
#define IDS_STRING5                     506
#define IDS_STRING6                     507
#define IDS_STRING7                     508
#define IDS_STRING8                     509
#define IDS_STRING9                     510
#define IDS_STRING10                    511
#define IDS_STRING11                    512
#define IDS_STRING12                    513
#define IDS_STRING13                    514
#define IDS_STRING14                    515
#define IDS_STRING15                    516
#define IDS_STRING16                    517
#define IDS_STRING17                    518
#define IDS_STRING18                    519
#define IDS_STRING19                    520
#define IDS_STRING20                    521
#define IDS_STRING21                    522
#define IDS_STRING22                    523
#define IDS_STRING23                    524
#define IDS_STRING24                    525
#define IDS_STRING25                    526
#define IDS_STRING26                    527
#define IDS_STRING27                    528
#define IDS_STRING28                    529
#define IDS_STRING29                    530
#define IDS_STRING30                    531
#define IDS_STRING31                    532
#define IDS_STRING32                    533
#define IDS_STRING33                    534
#define IDS_STRING34                    535
#define IDS_STRING35                    536
#define IDS_STRING36                    537
#define IDS_STRING37                    538
#define IDS_STRING38                    539
#define IDS_STRING39                    540
#define IDS_MAIN_HELP_END               541

#define IDS_HELP_MESSAGE                    52
#define IDS_INVALID_DIRECTORY_SPECIFIED     58
#define IDS_RECURSIVE_WITH_DOLLAR           60
#define IDS_NO_PATTERN                      63
#define IDS_NO_DATA                         64
#define IDS_NO_RECURSIVE                    65
#define IDS_ERROR_ENV_VRARIABLE             66
#define IDS_ERROR_PARSING                   67
#define IDS_INVALID_ARUGUMENTS              68
#define IDS_INVALID_DIRECTORY               69
#define IDS_NO_DATA1                        70
#define IDS_NO_PATTERN_2                    71
#define IDS_RECURSIVE_WITH_COLON            72
#define IDS_INVALID_PATTERN                 73
#define IDS_INVALID_PATTERN1                 74
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\commonheaderfiles.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        CommonHeaderFiles.h

    Abstract:

        This module includes the common files needed for all the source files
        in this project.

    Author:

        Venu Gopal S  25-Jun-2001

    Revision History:


******************************************************************************/

#ifndef __COMHEADERFILES_H
#define __COMHEADERFILES_H

//common include files needed for all other cpp files in this project

#include "who.h"
#include "wsuser.h"
#include "wspriv.h"
#include "wssid.h"
#include "wstoken.h"
#include "resource.h"

#endif //__COMHEADERFILES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\where\where.c ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

      Where.c

  Abstract:

      Lists the files that matches

      Syntax:
      ------
      WHERE [/R dir] [/Q] [/F] [/T] pattern...

  Author:



  Revision History:

      25-Jan-2000   a-anurag in the 'found' function changed the printf format of the year in the date from
                %d to %02d and did ptm->tm_year%100 to display the right year in 2 digits.
   06-Aug-1990    davegi  Added check for no arguments
   03-Mar-1987    danl    Update usage
   17-Feb-1987 BW  Move strExeType to TOOLS.LIB
   18-Jul-1986 DL  Add /t
   18-Jun-1986 DL  handle *. properly
                   Search current directory if no env specified
   17-Jun-1986 DL  Do look4match on Recurse and wildcards
   16-Jun-1986 DL  Add wild cards to $FOO:BAR, added /q
   1-Jun-1986 DL  Add /r, fix Match to handle pat ending with '*'
   27-May-1986 MZ  Add *NIX searching.
   30-Jan-1998 ravisp Add /Q

   02-Jul-2001 Wipro Technologies, has modified the tool for localization.
                                   /Q switch is changed to /f

--*/

#include "pch.h"
#include "where.h"
#include <strsafe.h>


DWORD
_cdecl wmain( IN DWORD argc,
              IN LPCWSTR argv[] )
/*++
        Routine Description     :   This is the main routine which calls other routines
                                    for processing the options and finding the files.

        [ IN ]  argc            :   A DWORD variable having the argument count.

        [ IN ]  argv            :   An array of constant strings of command line options.


        Return Value        :   DWORD
            Returns successfully if function is success otherwise return failure.

--*/
{
    DWORD i                             =   0;
    DWORD dwStatus                      =   0;
    DWORD dwCount                       =   0;
    BOOL bQuiet                         =   FALSE;
    BOOL bQuote                         =   FALSE;
    BOOL bTime                          =   FALSE;
    BOOL bUsage                         =   FALSE;
    LPWSTR wszRecursive                 =   NULL;
    LPWSTR wszPattern                   =   NULL;
    TARRAY  szPatternInArr              =   NULL;
    TARRAY  szPatternArr                =   NULL;
    DWORD dw                            =   0;
    BOOL bFound                         =   FALSE;
    LPWSTR szTemp                       =   NULL;
    WCHAR  *szTempPattern               =  NULL;
    BOOL *bMatched                      = NULL;

    if( argc<=1 )
    {
        SetLastError( (DWORD)MK_E_SYNTAX );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ShowMessage( stderr, GetResString( IDS_HELP_MESSAGE ) );
        ReleaseGlobals();
        return( EXIT_FAILURE_2 );

    }

    //this error mode is set for not to display messagebox when device is not ready
     SetErrorMode( SEM_FAILCRITICALERRORS);
    
     dwStatus = ProcessOptions( argc, argv,
                                &wszRecursive,
                                &bQuiet,
                                &bQuote,
                                &bTime,
                                &szPatternInArr,
                                &bUsage);
     
     if( EXIT_FAILURE == dwStatus )
    {
        DestroyDynamicArray(&szPatternInArr );
        FreeMemory((LPVOID *) &wszRecursive );
        ReleaseGlobals();
        return( EXIT_FAILURE_2 );
    }

    if( TRUE == bUsage )
    {
        DisplayHelpUsage();
        DestroyDynamicArray(&szPatternInArr );
        FreeMemory((LPVOID *) &wszRecursive );
        ReleaseGlobals();
        return(EXIT_SUCCESS);
    }


    szPatternArr = CreateDynamicArray();
    if( NULL == szPatternArr )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        DestroyDynamicArray(&szPatternInArr);
        FreeMemory((LPVOID *) &wszRecursive );
        ReleaseGlobals();
        return( EXIT_FAILURE_2 );

    }

    //check for invalid slashes
    dwCount = DynArrayGetCount( szPatternInArr );

    //fill bMatched array
    bMatched = (BOOL *) AllocateMemory( (dwCount+1)*sizeof(BOOL) );
    if( NULL == bMatched )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        DestroyDynamicArray(&szPatternInArr);
        DestroyDynamicArray(&szPatternArr );
        FreeMemory((LPVOID *) &wszRecursive );
        ReleaseGlobals();
        return( EXIT_FAILURE_2 );
    }
    for(dw=0;dw<dwCount;dw++)
    {
        bMatched[dw]=FALSE;

        wszPattern =(LPWSTR)DynArrayItemAsString(szPatternInArr,dw);

        //check if / is specified in the pattern
        if( wszPattern[0] == '/'  )
        {
            ShowMessageEx( stderr, 1, TRUE, GetResString(IDS_INVALID_ARUGUMENTS), wszPattern );
            ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
            DestroyDynamicArray(&szPatternInArr );
            DestroyDynamicArray(&szPatternArr );
            FreeMemory((LPVOID *) &wszRecursive );
            FreeMemory( (LPVOID *) &bMatched );
            ReleaseGlobals();
            return( EXIT_FAILURE_2 );
        }

        //and also check if recursive option is used with $env:path pattern
        if( StringLengthW(wszRecursive, 0)!=0 && wszPattern[0]==_T('$') && (szTemp = (LPWSTR)FindString( wszPattern, _T(":"),0)) != NULL )
        {
            ShowMessage( stderr, GetResString(IDS_RECURSIVE_WITH_DOLLAR) ) ;
            DestroyDynamicArray(&szPatternInArr );
            DestroyDynamicArray(&szPatternArr );
            FreeMemory((LPVOID *) &wszRecursive );
            FreeMemory( (LPVOID *) &bMatched );
            ReleaseGlobals();
            return( EXIT_FAILURE_2 );
        }
        
        //check if path:pattern is specified along with recursive option
        if( StringLengthW(wszRecursive, 0)!=0  && (szTemp = (LPWSTR)FindString( wszPattern, _T(":"),0)) != NULL )
        {
            ShowMessage( stderr, GetResString(IDS_RECURSIVE_WITH_COLON) ) ;
            DestroyDynamicArray(&szPatternInArr );
            DestroyDynamicArray(&szPatternArr );
            FreeMemory((LPVOID *) &wszRecursive );
            FreeMemory( (LPVOID *) &bMatched );
            ReleaseGlobals();
            return( EXIT_FAILURE_2 );
        }
        
        //check if null patterns specified in $env:pattern
        if( (wszPattern[0] == _T('$')  && (szTemp = wcsrchr( wszPattern, L':' )) != NULL) )
        {
            //divide $env:pattern
            szTemp = wcsrchr( wszPattern, L':' );
            szTemp++;
            if (szTemp == NULL || StringLength( szTemp, 0) == 0)
            {
                ShowMessage(stderr, GetResString(IDS_NO_PATTERN) );
                DestroyDynamicArray(&szPatternInArr );
                DestroyDynamicArray(&szPatternArr );
                FreeMemory((LPVOID *) &wszRecursive );
                FreeMemory( (LPVOID *) &bMatched );
                ReleaseGlobals();
                return( EXIT_FAILURE_2 );
            }

            //now check whether the pattern consists of / or \s
            //this check was done for patterns, but not done for $env:pattern
            if( szTemp[0] == L'\\' || szTemp[0] == L'/' )
            {
              ShowMessage(stderr, GetResString(IDS_INVALID_PATTERN) );
              DestroyDynamicArray(&szPatternInArr );
              DestroyDynamicArray(&szPatternArr );
              FreeMemory((LPVOID *) &wszRecursive );
              FreeMemory( (LPVOID *) &bMatched );
              ReleaseGlobals();
              return EXIT_FAILURE_2;
            }
        }

        //check if null patterns specified in path:pattern 
        if( (szTemp = wcsrchr( wszPattern, L':' )) != NULL )
        {
            //divide $env:pattern
            szTemp = wcsrchr( wszPattern, L':' );
            szTemp++;
            if ( NULL == szTemp  || StringLength( szTemp, 0) == 0)
            {
                ShowMessage(stderr, GetResString(IDS_NO_PATTERN_2) );
                DestroyDynamicArray(&szPatternInArr );
                DestroyDynamicArray(&szPatternArr );
                FreeMemory((LPVOID *) &wszRecursive );
                FreeMemory( (LPVOID *) &bMatched );
                ReleaseGlobals();
                return( EXIT_FAILURE_2 );
            }

            //now check whether the pattern consists of / or \s
            //this check was done for patterns, but not done for $env:pattern
            if( szTemp[0] == L'\\' || szTemp[0] == L'/' )
            {
              ShowMessage(stderr, GetResString(IDS_INVALID_PATTERN1) );
              DestroyDynamicArray(&szPatternInArr );
              DestroyDynamicArray(&szPatternArr );
              FreeMemory((LPVOID *) &wszRecursive );
              FreeMemory( (LPVOID *) &bMatched );
              ReleaseGlobals();
              return EXIT_FAILURE_2;
            }
        }
        
        //remove off the consequtive *s in the pattern, this is because the patten matching logic
        //will match for the patten recursivly, so limit the unnecessary no. of recursions
        szTempPattern = (LPWSTR) AllocateMemory((StringLengthW(wszPattern,0)+10)*sizeof(WCHAR) );
        if( NULL == szTempPattern )
        {
             ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );   
             DestroyDynamicArray(&szPatternInArr );
             DestroyDynamicArray(&szPatternArr );
             FreeMemory((LPVOID *) &wszRecursive );
             FreeMemory( (LPVOID *) &bMatched );
             ReleaseGlobals();
             return( EXIT_FAILURE_2 );
        }
        SecureZeroMemory(szTempPattern, SIZE_OF_ARRAY_IN_BYTES(szTempPattern) );
        szTemp = wszPattern;
        i=0;
        while( *szTemp )
        {
            szTempPattern[i++] = *szTemp;
            if( L'*' ==  *szTemp )
            {
                while( L'*' ==  *szTemp )
                     szTemp++;
            }
            else
                szTemp++;
        }
        szTempPattern[i]=0;
        DynArrayAppendString( szPatternArr, (LPCWSTR) szTempPattern, StringLengthW(szTempPattern, 0) );
        FreeMemory((LPVOID *) &szTempPattern);

    }

    //no need, destroy the dynamic array
    DestroyDynamicArray( &szPatternInArr );

    if( (NULL != wszRecursive) && StringLengthW(wszRecursive, 0) != 0 )
    {
        dwStatus = FindforFileRecursive( wszRecursive, szPatternArr, bQuiet, bQuote, bTime );
        if( EXIT_FAILURE == dwStatus )
        {
            //check if it fails due to memory allocation
            if( ERROR_NOT_ENOUGH_MEMORY  == GetLastError() )
            {
               ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
               ReleaseGlobals();
               DestroyDynamicArray( &szPatternArr );
               FreeMemory((LPVOID *) &wszRecursive );
               FreeMemory( (LPVOID *) &bMatched );
               ReleaseGlobals();
               return EXIT_FAILURE_2;
            }
            bFound = FALSE;
        }
        else
            bFound = TRUE;
    }
    else
    {

        //get the patterns one by one and process them
        for(dw=0;dw<dwCount;dw++)
        {
            SetReason(L"");
            wszPattern = (LPWSTR)DynArrayItemAsString(szPatternArr,dw);
            szTempPattern = (LPWSTR) AllocateMemory((StringLengthW(wszPattern, 0)+10)*sizeof(WCHAR) );
            if( NULL == szTempPattern )
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                FreeMemory((LPVOID *) &wszRecursive );
                DestroyDynamicArray( &szPatternArr );
                FreeMemory( (LPVOID *) &bMatched );
                ReleaseGlobals();
                return( EXIT_FAILURE_2 );
            }
            StringCopy(szTempPattern, wszPattern, SIZE_OF_ARRAY_IN_CHARS(szTempPattern));
            dwStatus = Where( szTempPattern, bQuiet, bQuote, bTime );
                if( EXIT_SUCCESS == dwStatus )
                {
                    bFound = TRUE;
                    bMatched[dw]=TRUE;
                }
                else
                {
                    //check out if it fails due to outof memory
                    if( ERROR_NOT_ENOUGH_MEMORY  == GetLastError() )
                    {
                       ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                       ReleaseGlobals();
                       DestroyDynamicArray( &szPatternArr );
                       FreeMemory((LPVOID *) &wszRecursive );
                       FreeMemory((LPVOID *) &szTempPattern);
                       FreeMemory( (LPVOID *) &bMatched );
                       ReleaseGlobals();
                       return EXIT_FAILURE_2;
                    }
                    else        //might be matching not found for this pattern
                    {
                        //display it only if it is not displayed earlier
                        if( StringLengthW(GetReason(), 0) != 0 ) 
                        {
                            bMatched[dw] = TRUE;
//                            ShowMessageEx( stderr, 2,TRUE, GetResString( IDS_NO_DATA), _X( wszPattern ) );
                        }
                    }
                }
       }
        //display non matched patterns
        if( bFound )
        {
            for(dw=0;dw<dwCount;dw++)
            {
                if( !bMatched[dw] && !bQuiet)
                {
                    wszPattern = (LPWSTR)DynArrayItemAsString(szPatternArr,dw);
                    ShowMessageEx( stderr, 2,TRUE, GetResString( IDS_NO_DATA), _X( wszPattern ) );
                }
            }
        }

    }

    if( !bFound )
    {
        if(!bQuiet)
        {
                ShowMessage( stderr, GetResString(IDS_NO_DATA1) );
        }
        DestroyDynamicArray(&szPatternArr );
        FreeMemory((LPVOID *) &wszRecursive );
        FreeMemory( (LPVOID *) &bMatched );
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    DestroyDynamicArray(&szPatternArr );
    FreeMemory( (LPVOID *) &bMatched );
    
    //again set back to normal mode
    SetErrorMode(0);

    FreeMemory((LPVOID *) &wszRecursive );

    ReleaseGlobals();

    return( EXIT_SUCCESS );

}

DWORD
Where( IN LPWSTR lpszPattern,
       IN BOOL bQuiet,
       IN BOOL bQuote,
        IN BOOL bTime)
/*++
        Routine Description     :   This routine is to build the path in which the files that matches
                                    the given pattern are to be found.

        [ IN ]  lpszPattern     :   A pattern string for which the matching files are to be found.

        [ IN ]  lpszrecursive   :   A string variable having directory path along with the files
                                    mathces the pattern to be found.

        [ IN ]  bQuiet          :   A boolean variable which specifies output in quiet mode or not.

        [ IN ]  bQuote          :   A boolean variable which specifies to add quotes to the output or not.

        [ IN ]  bTime           :   A boolean variable which specifies to display time and sizes of files or not.

        Return Value            :   DWORD
            Returns successfully if function is success other wise return failure.

--*/
{
    WCHAR   *szTemp                     =   NULL;
    LPWSTR  szEnvPath                   =   NULL;
    WCHAR   *szTraversedPath            =   NULL;
    WCHAR   *szDirectory                =   NULL;
    WCHAR   *szTemp1                    =   NULL;
    DWORD   dwStatus                    =   EXIT_FAILURE;
    WCHAR   *szEnvVar                   =   NULL;
    BOOL    bFound                      =   FALSE;
    LPWSTR  szFilePart                  =   NULL;
    DWORD   dwAttr                      =   0;
    DWORD   dwSize                      =   0;
    LPWSTR  szFullPath                  =   NULL;
    LPWSTR  szLongPath                  =   NULL;
    LPWSTR  szTempPath                  =   NULL;
    BOOL    bDuplicate                  =   FALSE;
    BOOL    bAllInvalid         =   TRUE;
    DWORD   cb                          =   0;

    //return back if reverse slashes are there, because the API will consider them as part of the path
    if( lpszPattern[0] == L'\\' )
    {
        return EXIT_FAILURE;
    }


    //if environment variable is specified at default argument
    //through $ symbol find the files matches the pattern along that path
    if( lpszPattern[0] == _T('$')  && (szTemp = wcsrchr( lpszPattern, L':' )) != NULL )
    {
    //divide $env:pattern
        szTemp = wcsrchr( lpszPattern, L':' );
        szTemp++;
        lpszPattern[(szTemp-1)-lpszPattern] = 0;

        //swap these, because lpszPattern holds environment varibale and szTemp holds pattern
        szTemp1 = lpszPattern;
        lpszPattern = szTemp;
        szTemp = szTemp1;

        StrTrim( lpszPattern, L" " );

        //remove off $ from environment variable
        szTemp++;

        szTemp1 = _wgetenv( szTemp );

        if( NULL == szTemp1 )
        {
            if( !bQuiet )
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_ENV_VRARIABLE), _X(szTemp) );
            }
            SetReason(GetResString(IDS_ERROR_ENV_VRARIABLE));
            return(EXIT_FAILURE );
        }
        
        szEnvVar = (LPWSTR) AllocateMemory( StringLengthW(szTemp, 0)+10);
        if( NULL == szEnvVar )
        {
            FreeMemory( (LPVOID *) &szEnvVar );
            return( EXIT_FAILURE );
        }
        StringCopy( szEnvVar, szTemp, SIZE_OF_ARRAY_IN_CHARS(szEnvVar) );  //this is for display purpose

      
        szEnvPath = (WCHAR *) AllocateMemory( (StringLengthW(szTemp1, 0)+10)*sizeof(WCHAR) );
        if( NULL == szEnvPath )
        {
            return( EXIT_FAILURE );
        }
        
        StringCopy( szEnvPath, szTemp1, SIZE_OF_ARRAY_IN_CHARS(szEnvPath) );

        if( NULL == szEnvPath )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            SaveLastError();
            FreeMemory( (LPVOID *) &szEnvVar );
            return( EXIT_FAILURE );
        }


    }
    else
    {

        if( (szTemp = wcsrchr( lpszPattern, L':' )) != NULL )
        {
            //consider it as a path

            //divide path:pattern structure
            szTemp++;
            lpszPattern[(szTemp-1)-lpszPattern] = 0;

            //swap these, because lpszPattern holds environment varibale and szTemp holds pattern
            szTemp1 = lpszPattern;
            lpszPattern = szTemp;
            szTemp = szTemp1;

            StrTrim( lpszPattern, L" " );

            szEnvPath = (WCHAR *) AllocateMemory( (StringLengthW(szTemp, 0)+10)*sizeof(WCHAR) );
            if( NULL == szEnvPath )
            {
                return( EXIT_FAILURE );
            }
            szEnvVar = (WCHAR *) AllocateMemory( (StringLengthW(szTemp, 0)+10)*sizeof(WCHAR) );
            if( NULL == szEnvVar )
            {
                return( EXIT_FAILURE );
            }
            StringCopy( szEnvPath, szTemp, SIZE_OF_ARRAY_IN_CHARS(szEnvPath) );
            StringCopy( szEnvVar, szTemp, SIZE_OF_ARRAY_IN_CHARS(szEnvPath) );     //this is for display purpose
        }
        else
        {
            //get the PATH value
            dwSize = GetEnvironmentVariable( L"PATH", szEnvPath, 0 );
            if( 0==dwSize )
            {
                if( !bQuiet )
                {
                    ShowMessageEx( stderr, 1, TRUE, GetResString(IDS_ERROR_ENV_VRARIABLE), L"PATH" );
                }
                SetReason( GetResString(IDS_ERROR_ENV_VRARIABLE) );
                return(EXIT_FAILURE );
            }

            //this variable for display purpose
            szEnvVar = (WCHAR *) AllocateMemory( (StringLengthW(L"PATH",0)+1)*sizeof(WCHAR) );
            if( NULL == szEnvVar )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                SaveLastError();
                return( EXIT_FAILURE );
            }
            StringCopy(szEnvVar, L"PATH", SIZE_OF_ARRAY_IN_CHARS(szEnvVar) );           
            
            //now get the "PATH" value from environment
            szEnvPath = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
            if( NULL == szEnvPath )
            {
                FreeMemory( (LPVOID *) &szEnvPath );
                return( EXIT_FAILURE );
            }

            //add the current directory to the path
            StringCopy( szEnvPath, L".;", SIZE_OF_ARRAY_IN_CHARS(szEnvPath));

            if( 0==GetEnvironmentVariable( L"PATH", szEnvPath+(StringLengthW(L".",0)*sizeof(WCHAR)), dwSize ) )
            {
                if( !bQuiet )
                {
                    ShowMessageEx( stderr, 1, TRUE, GetResString(IDS_ERROR_ENV_VRARIABLE), L"PATH" );
                }
                SetReason( GetResString(IDS_ERROR_ENV_VRARIABLE) );
                FreeMemory((LPVOID *) &szEnvPath);
                FreeMemory((LPVOID *) &szEnvVar);
                return EXIT_FAILURE;
            }
        }

    }

    //take each directory path from the variable
    szDirectory = _tcstok(szEnvPath, L";");
    while(szDirectory != NULL)
    {

        //now check the given directory is true directory or not
        dwAttr = GetFileAttributes( szDirectory);
        if( -1 == dwAttr || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
        {
                szDirectory = _tcstok(NULL, L";");
                continue;
        }
        else
        {
            bAllInvalid = FALSE;  //this tells all directories in the path are not invalid
        }

        //ensure there are no duplicate directories, so far, in the path
        bDuplicate = FALSE;

        dwSize=GetFullPathName(szDirectory,
                        0,
                      szFullPath,
                     &szFilePart );

        if(  dwSize != 0  )
        {

            szFullPath = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
            if( NULL == szFullPath )
            {
                FreeMemory((LPVOID *) &szEnvPath);
                FreeMemory((LPVOID *) &szEnvVar);
                return( EXIT_FAILURE );
            }

            dwSize=GetFullPathName(szDirectory,
                    (DWORD) dwSize+5,
                      szFullPath,
                     &szFilePart );

            
            //get the long path name
            dwSize = GetLongPathName( szFullPath, szLongPath, 0 );
            szLongPath = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
            if( NULL == szLongPath )
            {
                FreeMemory((LPVOID *) &szFullPath );
                FreeMemory((LPVOID *) &szEnvPath);
                FreeMemory((LPVOID *) &szEnvVar);
                return( EXIT_FAILURE );
            }
            dwSize = GetLongPathName( szFullPath, szLongPath, dwSize+5 );

                     
            //check if a trailing \ is there, if so suppress it because it no way affect the directory name
            //but could obscure another same path not having traling \ which results in duplication of paths
            if( (*(szLongPath+StringLengthW(szLongPath,0)-1) == _T('\\')) && (*(szLongPath+StringLengthW(szLongPath,0)-2) != _T(':')) )
                *(szLongPath+StringLengthW(szLongPath,0)-1) = 0;

            FreeMemory((LPVOID *) &szFullPath );

        }


        //check for duplicates
        if( szTraversedPath != NULL)
        {
            //copy already traversedpath into temporary variable and
            //divide it into tokens, so that by comparing eache token with
            //the current path will set eliminates the duplicates
            szTempPath = (LPWSTR) AllocateMemory( (StringLengthW(szTraversedPath,0)+10)*sizeof(WCHAR) );
            if( NULL == szTempPath )
            {
                FreeMemory((LPVOID*) &szEnvPath);
                FreeMemory((LPVOID*) &szEnvVar);
                FreeMemory((LPVOID*) &szTraversedPath);
                FreeMemory( (LPVOID*) &szLongPath );
                return( EXIT_FAILURE );
            }
            SecureZeroMemory( szTempPath, SIZE_OF_ARRAY_IN_BYTES(szTempPath));
            StringCopy(szTempPath, szTraversedPath, SIZE_OF_ARRAY_IN_CHARS(szTempPath));

            szTemp=DivideToken(szTempPath);

            while( szTemp!= NULL )
            {
                if ( StringCompare( szTemp, szLongPath, TRUE, 0 ) == 0 )
                {
                    bDuplicate = TRUE;
                    break;
                }
                szTemp=DivideToken(NULL);
            }

            FreeMemory((LPVOID *) &szTempPath);
        }


        // find for file only if directory is not in already traversed path
        if( !bDuplicate )
        {
                dwStatus = FindforFile( szLongPath, lpszPattern, bQuiet, bQuote, bTime );
                cb += StringLengthW(szLongPath,0)+10;
                if( NULL != szTraversedPath )
                {
                    if( FALSE == ReallocateMemory( (LPVOID *)&szTraversedPath, cb*sizeof(WCHAR) ) )
                    {
                        FreeMemory((LPVOID*) &szTraversedPath);
                        szTraversedPath = NULL;
                    }
                }
                else
                {
                    szTraversedPath = (LPWSTR) AllocateMemory( cb*sizeof(WCHAR) );
                    SecureZeroMemory( szTraversedPath, SIZE_OF_ARRAY_IN_BYTES(szTraversedPath) );
                }

                if( szTraversedPath == NULL )
                {
                    SaveLastError();
                    FreeMemory((LPVOID*) &szEnvPath);
                    FreeMemory((LPVOID*) &szEnvVar);
                    FreeMemory((LPVOID*) &szLongPath );
                    return( EXIT_FAILURE );
                }
                            
                if( StringLengthW(szTraversedPath,0) == 0 )
                {
                    StringCopy( szTraversedPath, szLongPath, SIZE_OF_ARRAY_IN_CHARS(szTraversedPath) );
                }
                else
                {
                    StringConcat( szTraversedPath, szLongPath, SIZE_OF_ARRAY_IN_CHARS(szTraversedPath) );
                }
                StringConcat( szTraversedPath, L"*", SIZE_OF_ARRAY_IN_CHARS(szTraversedPath));
        }

        szDirectory = _tcstok(NULL, L";");
        if( EXIT_SUCCESS == dwStatus )
        {
              bFound = TRUE;
        }

        FreeMemory((LPVOID *) &szLongPath );
    }

    FreeMemory( (LPVOID *) &szEnvPath );
    FreeMemory( (LPVOID *) &szTraversedPath );
    FreeMemory( (LPVOID *) &szEnvVar );
    
    if( FALSE == bFound )
        return(EXIT_FAILURE);

    return( EXIT_SUCCESS );
}


DWORD
FindforFile(IN LPWSTR lpszDirectory,
            IN LPWSTR lpszPattern,
            IN BOOL bQuiet,
            IN BOOL bQuote,
            IN BOOL bTime
           )
/*++
        Routine Description     :   This routine is to find the files that match for the given pattern.

        [ IN ]  lpszDirectory   :   A string variable having directory path along with the files
                                    mathces the pattern to be found.

        [ IN ]  lpszPattern     :   A pattern string for which the matching files are to be found.

        [ IN ]  bQuiet          :   A boolean variable which specifies the search is recursive or not.

        [ IN ]  bQuiet          :   A boolean variable which specifies the output can be in quiet mode or not.

        [ IN ]  bQuote          :   A boolean variable which specifies to add quotes to th output or not.

        [ IN ]  bTime           :   A boolean variable which specifies to display time and sizes of file or not.

        Return Value        :   DWORD
            Returns successfully if function is success other wise return failure.

--*/
{
        HANDLE              hFData;
    WIN32_FIND_DATA     fData;
    LPWSTR              szFilenamePattern           =   NULL;
    LPWSTR              szTempPath                  =   NULL;
    LPWSTR              szBuffer                    =   NULL;
    BOOL                bFound                      =   FALSE;
    LPWSTR              szTemp                      =   NULL;
    DWORD               cb                          =   0;
    DWORD               dwSize                      =   0;
    LPWSTR              szPathExt                   =   NULL;
    LPWSTR              szTempPathExt               =   NULL;
    LPWSTR              lpszTempPattern             =   NULL;
    LPWSTR              szToken                     =   NULL;


    //get the file extension path PATHEXT
    dwSize = GetEnvironmentVariable( L"PATHEXT", szPathExt, 0 );
    if( dwSize!=0 )
    {
        szPathExt = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
        if( NULL == szPathExt )
        {
            return( EXIT_FAILURE );
        }
        GetEnvironmentVariable( L"PATHEXT", szPathExt, dwSize );

        szTempPathExt = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
        if( NULL == szPathExt )
        {
            FreeMemory((LPVOID *) &szPathExt );
            return( EXIT_FAILURE );
        }
    }

        //allocate memory for file name pattern
        cb = StringLengthW(lpszDirectory,0)+15;
        szFilenamePattern = (LPWSTR)AllocateMemory( cb*sizeof(WCHAR) );
        if( NULL == szFilenamePattern )
        {
            FreeMemory((LPVOID *) &lpszTempPattern );
            FreeMemory((LPVOID *) &szTempPathExt );
            FreeMemory((LPVOID *) &szPathExt );
            return( EXIT_FAILURE );
        }
        SecureZeroMemory( szFilenamePattern, SIZE_OF_ARRAY_IN_BYTES(szFilenamePattern) );

        //check for trailing slash is there in the path of directory
        //if it is there remove it other wise add it along with the *.* pattern
        if( *(lpszDirectory+StringLengthW(lpszDirectory,0)-1) != _T('\\'))
        {
            StringCchPrintf( szFilenamePattern, cb-1, L"%s\\*.*", _X( lpszDirectory ) );
        }
        else
        {
            StringCchPrintf( szFilenamePattern, cb-1, L"%s*.*", _X( lpszDirectory ) );
        }

        //find first file in the directory
        hFData = FindFirstFileEx( szFilenamePattern,
                                  FindExInfoStandard,
                                  &fData,
                                  FindExSearchNameMatch,
                                  NULL,
                                  0);
        if( INVALID_HANDLE_VALUE != hFData )
        {

            do
            {

              //allocate memory for full path of file name
              cb = StringLengthW(lpszDirectory,0)+StringLengthW(fData.cFileName,0)+10;
              szTempPath = (LPWSTR) AllocateMemory( cb*sizeof(WCHAR) );
              if( NULL == szTempPath )
              {
                   FreeMemory((LPVOID *) &szFilenamePattern );
                   FreeMemory((LPVOID *) &lpszTempPattern );
                   FreeMemory((LPVOID *) &szTempPathExt );
                   FreeMemory((LPVOID *) &szPathExt );
                   return( EXIT_FAILURE );
              }
              SecureZeroMemory( szTempPath, cb*sizeof(WCHAR) );

              //get full path of file name
              if( *(lpszDirectory+StringLengthW(lpszDirectory,0)-1) != _T('\\'))
              {
                StringCchPrintf( szTempPath, cb, L"%s\\%s", _X( lpszDirectory ), _X2( fData.cFileName ) );
              }
              else
              {
                StringCchPrintf( szTempPath, cb, L"%s%s", _X( lpszDirectory ), _X2( fData.cFileName ) );
              }


               //check for patten matching
               //if file name is a directory then dont match for the pattern
                if( (FILE_ATTRIBUTE_DIRECTORY & fData.dwFileAttributes))
                {
                    FreeMemory((LPVOID *) &szTempPath );
                    continue;
                }
                
                szBuffer = (LPWSTR) AllocateMemory( (StringLengthW(fData.cFileName,0)+10)*sizeof(WCHAR) );
                if( NULL == szBuffer )
                {
                   FreeMemory((LPVOID *) &szFilenamePattern );
                   FreeMemory((LPVOID *) &lpszTempPattern );
                   FreeMemory((LPVOID *) &szTempPathExt );
                   FreeMemory((LPVOID *) &szPathExt );
                   return( EXIT_FAILURE );
                }
                StringCopy( szBuffer, fData.cFileName, SIZE_OF_ARRAY_IN_CHARS(szBuffer) );
               //if pattern has dot and file doesn't have dot means search for *. type
               //so append . for the file
               if( ((szTemp=(LPWSTR)FindString((LPCWSTR)lpszPattern, _T("."),0)) != NULL) &&
                   ((szTemp=(LPWSTR)FindString(szBuffer, _T("."),0)) == NULL) )
               {

                    StringConcat(szBuffer, _T("."), SIZE_OF_ARRAY_IN_CHARS(szBuffer) );
               }

               if(Match( lpszPattern, szBuffer ))
               {
                       found( szTempPath, bQuiet, bQuote, bTime );
                       bFound = TRUE ;
               }
               else
               {
                   //checkout for if extension in the EXTPATH matches
                       StringCopy(szTempPathExt, szPathExt, SIZE_OF_ARRAY_IN_CHARS(szTempPathExt));
                       szTemp = szTempPathExt;

                      szToken=(LPWSTR)FindString(szTemp, L";",0);
                      if( szToken != NULL )
                       {
                           szToken[0]=0;
                           szToken = szTemp;
                           szTemp+=StringLengthW(szTemp,0)+1;
                       }
                       else
                       {
                           szToken = szTempPathExt;
                           szTemp = NULL;
                       }

                       while(szToken!=NULL  )
                       {
                            //allocate memory for temporary pattern which can be used to check for file extensions
                            cb = StringLengthW(lpszPattern,0)+StringLengthW(szToken,0)+25;
                            lpszTempPattern = (LPWSTR)AllocateMemory( cb*sizeof(WCHAR) );
                            if( NULL == lpszTempPattern )
                            {
                                FreeMemory((LPVOID *) &szTempPathExt );
                                FreeMemory((LPVOID *) &szPathExt );
                                FreeMemory((LPVOID *) &szBuffer );
                                return( EXIT_FAILURE );
                            }
                            SecureZeroMemory( lpszTempPattern, SIZE_OF_ARRAY_IN_BYTES(lpszTempPattern) );

                            if( szToken[0] == L'.' )
                            {
                               StringCchPrintf(lpszTempPattern, cb-1, L"%s%s",lpszPattern, szToken);
                               if(Match( lpszTempPattern, szBuffer ))
                               {
                                       found( szTempPath, bQuiet, bQuote, bTime );
                                       bFound = TRUE ;
                               }
                            }

                           if( NULL == szTemp )
                           {
                               szToken = NULL;
                           }
                           else
                           {
                               szToken=(LPWSTR)FindString(szTemp, L";",0);
                               if( szToken != NULL )
                               {
                                   szToken[0]=0;
                                   szToken = szTemp;
                                   szTemp+=StringLengthW(szTemp,0)+1;
                               }
                               else
                               {
                                    szToken = szTemp;
                                    szTemp=NULL;
                               }
                           }
                           FreeMemory((LPVOID*) &lpszTempPattern );

                       }
                       FreeMemory( (LPVOID *) &szBuffer );

               }



               FreeMemory((LPVOID *) &szTempPath );
               FreeMemory( (LPVOID *) &szBuffer );


            }while(FindNextFile(hFData, &fData));

            FindClose(hFData);
        }

        FreeMemory((LPVOID *) &szFilenamePattern );
        FreeMemory((LPVOID *) &szTempPathExt );
        FreeMemory((LPVOID *) &szPathExt );




    if( !bFound )
    {
        return( EXIT_FAILURE );
    }

    return( EXIT_SUCCESS );

}

DWORD
FindforFileRecursive(
            IN LPWSTR lpszDirectory,
            IN PTARRAY PatternArr,
            IN BOOL bQuiet,
            IN BOOL bQuote,
            IN BOOL bTime
           )
/*++
        Routine Description     :   This routine is to find the files that match for the given pattern.

        [ IN ]  lpszDirectory   :   A string variable having directory path along with the files
                                    mathces the pattern to be found.

        [ IN ]  lpszPattern     :   A pattern string for which the matching files are to be found.

        [ IN ]  bQuiet          :   A boolean variable which specifies the directory is to recursive or not.

        [ IN ]  bQuiet          :   A boolean variable which specifies the output is in quiet mode or not.

        [ IN ]  bQuote          :   A boolean variable which specifies to add quotes to the output or not.

        [ IN ]  bTime           :   A boolean variable which specifies to display time and size of file or not.

        Return Value        :   DWORD
            Returns successfully if function is success other wise return failure.

--*/
{
    HANDLE              hFData;
    WIN32_FIND_DATA     fData;
    BOOL                bStatus                     =   FALSE;
    LPWSTR              szFilenamePattern           =   NULL;
    LPWSTR              szTempPath                  =   NULL;
    LPWSTR              szDirectoryName             =   NULL;
    LPWSTR              lpszPattern                 =   NULL;
    WCHAR               *szBuffer                   =   NULL;
    BOOL                bFound                      =   FALSE;
    LPWSTR              szTemp                      =   NULL;
    DIRECTORY           dir                         =   NULL;
    DIRECTORY           dirNextLevel                =   NULL;
    DIRECTORY           dirTemp                     =   NULL;
    DWORD               cb                          =   0;
    DWORD               dwCount                     =   0;
    DWORD               dw                          =   0;
    DWORD               dwSize                      =   0;
    LPWSTR              szPathExt                   =   NULL;
    LPWSTR              szTempPathExt               =   NULL;
    LPWSTR              lpszTempPattern             =   NULL;
    LPWSTR              szToken                     =   NULL;
    BOOL                *bMatched                   =   NULL;


    //get the file extension path PATHEXT
    dwSize = GetEnvironmentVariable( L"PATHEXT", szPathExt, 0 );
    if( dwSize!=0 )
    {
        szPathExt = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
        if( NULL == szPathExt )
        {
            return( EXIT_FAILURE );
        }
        GetEnvironmentVariable( L"PATHEXT", szPathExt, dwSize );

        szTempPathExt = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
        if( NULL == szPathExt )
        {
            FreeMemory((LPVOID *) &szPathExt );
            return( EXIT_FAILURE );
        }
    }



    //this array of bools corresponding to each given patterns
    //which tells whether any file found corresponding to that pattern
    dwCount = DynArrayGetCount( PatternArr );
    bMatched = (BOOL *)AllocateMemory((dwCount+1)*sizeof(BOOL) );
    if(NULL == bMatched )
    {
        FreeMemory((LPVOID *) &szTempPathExt );
        FreeMemory((LPVOID *) &szPathExt );
        return (EXIT_FAILURE ); 
    }
    
    //allocate memory for directory name
    cb = (StringLengthW(lpszDirectory,0)+5)*sizeof(WCHAR);
    szDirectoryName = (LPWSTR) AllocateMemory(cb);
    if( NULL == szDirectoryName )
    {
        FreeMemory((LPVOID *) &szTempPathExt );
        FreeMemory((LPVOID *) &szPathExt );
        return( EXIT_FAILURE );
    }
    SecureZeroMemory( szDirectoryName, SIZE_OF_ARRAY_IN_BYTES(szDirectoryName) );

    StringCopy( szDirectoryName, lpszDirectory, SIZE_OF_ARRAY_IN_CHARS(szDirectoryName) );


    do
    {
        //allocate memory for file name pattern
        cb = StringLengthW(szDirectoryName,0)+15;
        szFilenamePattern = AllocateMemory( cb*sizeof(WCHAR) );
        if( NULL == szFilenamePattern )
        {
            FreeMemory((LPVOID *) &szDirectoryName );
            FreeMemory((LPVOID *) &szTempPathExt );
            FreeMemory((LPVOID *) &szPathExt );
            return( EXIT_FAILURE );
        }
        ZeroMemory( szFilenamePattern, cb*sizeof(WCHAR) );

        //check for trailing slash is there in the path of directory
        //if it is there remove it other wise add it along with the *.* pattern
        if( *(szDirectoryName+StringLengthW(szDirectoryName,0)-1) != _T('\\'))
        {
            StringCchPrintf( szFilenamePattern, cb, L"%s\\*.*", _X( szDirectoryName ) );
        }
        else
        {
            StringCchPrintf( szFilenamePattern, cb, L"%s*.*", _X( szDirectoryName ) );
        }

        //find first file in the directory
        hFData = FindFirstFileEx( szFilenamePattern,
                                  FindExInfoStandard,
                                  &fData,
                                  FindExSearchNameMatch,
                                  NULL,
                                  0);
        if( INVALID_HANDLE_VALUE != hFData )
        {

            do
            {

              //allocate memory for full path of file name
              cb = StringLengthW(szDirectoryName,0)+StringLengthW(fData.cFileName,0)+10;
              szTempPath = (LPWSTR) AllocateMemory( cb*sizeof(WCHAR) );
              if( NULL == szTempPath )
              {
                   FreeMemory((LPVOID *) &szDirectoryName );
                   FreeMemory((LPVOID *) &szFilenamePattern );
                   FreeMemory((LPVOID *) &szTempPathExt );
                   FreeMemory((LPVOID *) &szPathExt );
                   return( EXIT_FAILURE );
              }
              SecureZeroMemory( szTempPath, SIZE_OF_ARRAY_IN_CHARS(szTempPath) );

              //get full path of file name
              if( *(szDirectoryName+StringLengthW(szDirectoryName,0)-1) != _T('\\'))
              {
                    StringCchPrintf( szTempPath, cb, L"%s\\%s", _X( szDirectoryName ), _X2( fData.cFileName ) );
              }
              else
              {
                    StringCchPrintf( szTempPath, cb, L"%s%s", _X( szDirectoryName ), _X2( fData.cFileName ) );
              }


              //check if recursive is specified and file name is directory then push that into stack
               if( StringCompare(fData.cFileName, L".", TRUE, 0)!=0 && StringCompare(fData.cFileName, L"..", TRUE, 0)!=0 &&
                   (FILE_ATTRIBUTE_DIRECTORY & fData.dwFileAttributes) )
               {
                   //place the directory in the list which is to be recursed later
                   if( EXIT_FAILURE == Push(&dirNextLevel, szTempPath ) )
                    {
                        FreeMemory((LPVOID *) &szDirectoryName );
                        FreeMemory((LPVOID *) &szFilenamePattern );
                        FreeMemory((LPVOID *) &szTempPath );
                        FreeMemory((LPVOID *) &szTempPathExt );
                        FreeMemory((LPVOID *) &szPathExt );
                        FreeList( dir );
                        return(EXIT_FAILURE );
                    }

                   //the file name is a directory so continue
                   FreeMemory((LPVOID *) &szTempPath );
                   continue;

               }
               else                         //check for patten matching
               {
                   //check for patten matching
                   //if file name is a directory then dont match for the pattern
                    if( (FILE_ATTRIBUTE_DIRECTORY & fData.dwFileAttributes))
                    {
                        FreeMemory((LPVOID*) &szTempPath );
                        continue;
                    }

                    //check if this file is mathched with any of the patterns given
                    dwCount = DynArrayGetCount( PatternArr );
                    for(dw=0;dw<dwCount;dw++)
                    {
                        szBuffer = (LPWSTR) AllocateMemory( (StringLengthW(fData.cFileName,0)+10)*sizeof(WCHAR) );
                        if( NULL == szBuffer )
                        {
                             FreeMemory((LPVOID *) &szDirectoryName );
                             FreeMemory((LPVOID *) &szFilenamePattern );
                             FreeMemory((LPVOID *) &szTempPathExt );
                             FreeMemory((LPVOID *) &szPathExt );
                             FreeList(dir);
                             return( EXIT_FAILURE );
                        }
                        lpszPattern = (LPWSTR)DynArrayItemAsString( PatternArr, dw );
                        StringCopy( szBuffer, fData.cFileName, SIZE_OF_ARRAY_IN_CHARS(szBuffer) );
                        
                       //if pattern has dot and file doesn't have dot means search for *. type
                       //so append . for the file
                       if( ((szTemp=(LPWSTR)FindString((LPCWSTR)lpszPattern, _T("."),0)) != NULL) &&
                           ((szTemp=(LPWSTR)FindString(szBuffer, _T("."),0)) == NULL) )
                       {

                            StringConcat(szBuffer, _T("."), SIZE_OF_ARRAY_IN_CHARS(szBuffer) );
                       }

                       if(Match( lpszPattern, szBuffer ))
                       {
                               found( szTempPath, bQuiet, bQuote, bTime );
                               bFound = TRUE ;
                               bMatched[dw]=TRUE;
                       }
                       else
                       {
                       //checkout for if extension in the EXTPATH matches
                           StringCopy(szTempPathExt, szPathExt, SIZE_OF_ARRAY_IN_CHARS(szTempPathExt));
                           szTemp = szTempPathExt;

                           szToken=(LPWSTR)FindString(szTemp, L";",0);
                           if( szToken != NULL )
                           {
                               szToken[0]=0;
                               szToken = szTemp;
                               szTemp+=StringLengthW(szTemp,0)+1;
                           }
                           else
                           {
                               szToken = szTempPathExt;
                               szTemp = NULL;
                           }

                           while(szToken!=NULL )
                           {
                                //allocate memory for temporary pattern which can be used to check for file extensions
                                cb = StringLengthW(lpszPattern,0)+StringLengthW(szToken,0)+25;
                                lpszTempPattern = AllocateMemory( cb*sizeof(WCHAR) );
                                if( NULL == lpszTempPattern )
                                {
                                    FreeMemory((LPVOID *) &szDirectoryName );
                                    FreeMemory((LPVOID *) &szFilenamePattern );
                                    FreeMemory((LPVOID *) &bMatched);
                                    FreeMemory((LPVOID *) &szTempPathExt );
                                    FreeMemory((LPVOID *) &szPathExt );
                                    FreeMemory((LPVOID *) &szTempPathExt );
                                    FreeMemory((LPVOID *) &szPathExt );
                                    FreeMemory((LPVOID *) &szBuffer );
                                    FreeList(dir);
                                    return( EXIT_FAILURE );
                                }
                                SecureZeroMemory( lpszTempPattern, SIZE_OF_ARRAY_IN_BYTES(lpszTempPattern) );

                               if( szToken[0] == L'.' )         //if the extension in PATHEXT doesn't have dot
                               {
                                   StringCchPrintf(lpszTempPattern, cb, L"%s%s",lpszPattern, szToken);
                                   if(Match( lpszTempPattern, szBuffer ))
                                   {
                                          found( szTempPath, bQuiet, bQuote, bTime );
                                           bFound = TRUE ;
                                           bMatched[dw]=TRUE;
                                   }
                               }

                               if( NULL == szTemp )
                               {
                                   szToken = NULL;
                               }
                               else
                               {
                                   szToken=(LPWSTR)FindString(szTemp, L";",0);
                                   if( szToken != NULL )
                                   {
                                       szToken[0]=0;
                                       szToken = szTemp;
                                       szTemp+=StringLengthW(szTemp,0)+1;
                                   }
                                   else
                                   {
                                        szToken = szTemp;
                                        szTemp=NULL;
                                   }
                                }
                               FreeMemory((LPVOID *) &lpszTempPattern );

                           }

                      }
                      
                       FreeMemory((LPVOID *) &szBuffer );
                    }

               }

               FreeMemory((LPVOID *) &szTempPath );


            }while(FindNextFile(hFData, &fData));

            FindClose(hFData);
        }

        FreeMemory((LPVOID *) &szDirectoryName );
        FreeMemory((LPVOID *) &szFilenamePattern );

        //pop directory and do the search in that directory
        //now insert Nextlevel directories in the begining of the list,
        //because it is to be processed first
        if( NULL == dir && dirNextLevel )
        {
            dir = dirNextLevel;
            dirNextLevel = NULL;
        }
        else if( dirNextLevel )
        {
            dirTemp = dirNextLevel;
            while( dirTemp->next && dirTemp)
                    dirTemp = dirTemp->next;
            dirTemp->next = dir;
            dir = dirNextLevel;
            dirNextLevel = NULL;
            dirTemp=NULL;
        }
        bStatus = Pop( &dir, &szDirectoryName );



    }while(  bStatus );

    FreeMemory((LPVOID *) &lpszTempPattern );
    FreeMemory((LPVOID *) &szTempPathExt );
    FreeMemory((LPVOID *) &szPathExt );
    FreeList(dir);

    if( !bFound )
    {
        FreeMemory((LPVOID *) &bMatched );
        return( EXIT_FAILURE );
    }

    //display error messages for all patterns which dont have any matched files
    dwCount = DynArrayGetCount( PatternArr );
    for( dw=0;dw<dwCount;dw++ )
    {
        if( FALSE == bMatched[dw] )
        {
            lpszPattern = (LPWSTR) DynArrayItemAsString( PatternArr, dw );
            if( !bQuiet )
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString( IDS_NO_DATA), _X( lpszPattern ) );
            }
        }
    }

    FreeMemory((LPVOID *) &bMatched );

    return( EXIT_SUCCESS );

}
BOOL
Match(
      IN LPWSTR szPat,
      IN LPWSTR szFile
      )
/*++
        Routine Description     :   This routine is used to check whether file is mathced against
                                    pattern or not.

        [ IN ]  szPat           :   A string variable pattern against which the file name to be matched.

        [ IN ]  szFile          :   A pattern string which specifies the file name to be matched.


        Return Value        :   BOOL
            Returns successfully if function is success other wise return failure.
--*/

{
    switch (*szPat) {
        case '\0':
            return *szFile == L'\0';
        case '?':
            return *szFile != L'\0' && Match (szPat + 1, szFile + 1);
        case '*':
            do {
                if (Match (szPat + 1, szFile))
                    return TRUE;
            } while (*szFile++);
            return FALSE;
        default:
            return towupper (*szFile) == towupper (*szPat) && Match (szPat + 1, szFile + 1);
    }
}

DWORD
found(
       IN LPWSTR p,
       IN BOOL bQuiet,
       IN BOOL bQuote,
       IN BOOL bTimes
      )
/*++
        Routine Description     :   This routine is to display the file name as per the attributes specified.

        [ IN ]  p               :   A string variable having full path of file that is to be displayed.

        [ IN ]  bQuiet          :   A boolean variable which specifies the directory is to recursive or not.

        [ IN ]  bQuiet          :   A boolean variable which specifies quiet or not.

        [ IN ]  bQuote          :   A boolean variable which specifies to add quotes or not.

        [ IN ]  bTime           :   A boolean variable which specifies to times and sizes or not.

        Return Value        :   DWORD
            Returns successfully if function is success otherwise return failure.

--*/
{

    WCHAR           szDateBuffer[MAX_RES_STRING]    =   NULL_U_STRING;
    WCHAR           szTimeBuffer[MAX_RES_STRING]    =   NULL_U_STRING;
    DWORD           dwSize                          =   0;

    if (!bQuiet)
    {
        if (bTimes)
        {

            if( EXIT_SUCCESS == GetFileDateTimeandSize( p, &dwSize, szDateBuffer, szTimeBuffer ) )
            {
                ShowMessageEx( stdout, 3, TRUE, L"% 10ld   %9s  %12s  ", dwSize, szDateBuffer, szTimeBuffer );
            }
            else
            {
                ShowMessage( stdout, _T("        ?         ?       ?          ") );
            }

        }
        if (bQuote)
        {
            ShowMessageEx( stdout, 1, TRUE,  _T("\"%s\"\n"),  _X( p ) );
        }
        else
        {
            ShowMessage( stdout, _X(p) );
            ShowMessage( stdout, NEW_LINE );
        }
    }
    return( 0 );
}

DWORD
   Push( OUT DIRECTORY *dir,
         IN LPWSTR szPath
         )
/*
    Routine Description : will place the  directory name in the list
        [ IN ]  dir             :   Pointer to a list of files

        [ IN ]  szPath          :   A string variable having the path to be inserted into list

        Return Value        :   DWORD

            Returns successfully if function is success otherwise return failure.
*/
{
    DIRECTORY tmp                   =   NULL;
    DIRECTORY tempnode              =   NULL;
    
    tmp = NULL;

    //create a node
    tmp = (DIRECTORY) AllocateMemory( sizeof(struct dirtag) );
    if( NULL == tmp )
    {
        return( EXIT_FAILURE );
    }

   tmp->szDirectoryName = (LPWSTR) AllocateMemory( (StringLengthW(szPath, 0)+10)*sizeof(WCHAR) );
   if( NULL == tmp->szDirectoryName )
   {
        return( EXIT_FAILURE );
   }


   StringCopy(tmp->szDirectoryName, szPath, SIZE_OF_ARRAY_IN_CHARS(tmp->szDirectoryName) );
   tmp->next = NULL;

   if( NULL == *dir )                   //if stack is empty
   {
       *dir = tmp;
       return EXIT_SUCCESS;
   }

   for( tempnode=*dir;tempnode->next!=NULL;tempnode=tempnode->next);

   tempnode->next = tmp;

    return EXIT_SUCCESS;

}

BOOL Pop( IN DIRECTORY *dir,
           OUT LPWSTR *lpszDirectory)
/*
        Routine Description : It will pop the directory name from the stack

        [ IN ]  dir             :   Pointer to a list of files

        [ IN ]  lpszDirectory   :   A pointer to a string will have the next directory in the list

        Return Value        :   DWORD

            Returns TRUE if list is not NULL, returns FALSE otherwise

*/
{
    DIRECTORY   tmp                     =   *dir;
    
    if( NULL == tmp )                   //if there are no elements in stack
        return FALSE;

    *lpszDirectory = (LPWSTR )AllocateMemory( (StringLengthW( tmp->szDirectoryName, 0 )+10)*sizeof(WCHAR) );
    if( NULL == *lpszDirectory )
   {
        return( EXIT_FAILURE );
   }


    StringCopy( *lpszDirectory, tmp->szDirectoryName, SIZE_OF_ARRAY_IN_CHARS(*lpszDirectory) );

    *dir = tmp->next;                   //move to the next element

    FreeMemory((LPVOID *) &tmp->szDirectoryName);
    FreeMemory((LPVOID *) &tmp);

    return( TRUE );

}



DWORD
   GetFileDateTimeandSize( LPWSTR wszFileName, DWORD *dwSize, LPWSTR wszDate, LPWSTR wszTime )
 /*++
    Routine Description :    This function gets the date and time according to system locale.

 --*/
{
    HANDLE      hFile;
    FILETIME    fileLocalTime= {0,0};
    SYSTEMTIME  sysTime = {0,0,0,0,0,0,0,0};
    LCID        lcid;
    BOOL        bLocaleChanged      =   FALSE;
    DWORD       wBuffSize           =   0;
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    struct _stat sbuf;
    struct tm *ptm;

    hFile = CreateFile( wszFileName, 0 ,FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS , NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        if (  _wstat(wszFileName, &sbuf) != 0 )
            return EXIT_FAILURE;

        ptm = localtime (&sbuf.st_mtime);
        if( NULL == ptm )
            return EXIT_FAILURE;

        *dwSize = sbuf.st_size;
        sysTime.wYear = (WORD) ptm->tm_year+1900;
        sysTime.wMonth = (WORD)ptm->tm_mon+1;
        sysTime.wDayOfWeek = (WORD)ptm->tm_wday;
        sysTime.wDay = (WORD)ptm->tm_mday;
        sysTime.wHour = (WORD)ptm->tm_hour;
        sysTime.wMinute = (WORD)ptm->tm_min;
        sysTime.wSecond = (WORD)ptm->tm_sec;
        sysTime.wMilliseconds = (WORD)0;
    }
    else
    {

        *dwSize = GetFileSize( hFile, NULL );

        if (FALSE == GetFileInformationByHandle( hFile, &FileInfo ) )
        {
            CloseHandle (hFile);
            return EXIT_FAILURE;
        }

        if (FALSE == CloseHandle (hFile))
            return EXIT_FAILURE;


        // get the creation time
        if ( FALSE == FileTimeToLocalFileTime ( &FileInfo.ftLastWriteTime, &fileLocalTime ) )
                return EXIT_FAILURE;

        // get the creation time
        if ( FALSE == FileTimeToSystemTime ( &fileLocalTime, &sysTime ) )
                return EXIT_FAILURE;
    }

    // verify whether console supports the current locale fully or not
    lcid = GetSupportedUserLocale( &bLocaleChanged );

    //Retrieve  the Date
    wBuffSize = GetDateFormat( lcid, 0, &sysTime,
        (( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL), wszDate, MAX_RES_STRING );

    if( 0 == wBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    wBuffSize = GetTimeFormat( lcid, 0, &sysTime,
        (( bLocaleChanged == TRUE ) ? L"HH:mm:ss" : NULL), wszTime, MAX_RES_STRING );

    if( 0 == wBuffSize )
        return EXIT_FAILURE;

    return EXIT_SUCCESS;

}
DWORD DisplayHelpUsage()
/*++
        Routine Description     :   This routine is to display the help usage.

        Return Value        :   DWORD
            Returns success.

--*/
{
    DWORD dw = 0;

    for(dw=IDS_MAIN_HELP_BEGIN;dw<=IDS_MAIN_HELP_END;dw++)
        ShowMessage(stdout, GetResString(dw) );
    return( EXIT_SUCCESS);
}

DWORD ProcessOptions( IN DWORD argc,
                      IN LPCWSTR argv[],
                      OUT LPWSTR *lpszRecursive,
                      OUT PBOOL pbQuiet,
                      OUT PBOOL pbQuote,
                      OUT PBOOL pbTime,
                      OUT PTARRAY pArrVal,
                      OUT PBOOL pbUsage
                    )
/*++

    Routine Description : Function used to process the main options

    Arguments:
         [ in  ]  argc           : Number of command line arguments
         [ in  ]  argv           : Array containing command line arguments
         [ out ]  lpszRecursive  : A string varibles returns recursive directory if specified.
         [ out ]  pbQuiet        : A pointer to boolean variable returns TRUE if Quiet option is specified.
         [ out ]  pbQuote        : A pointer to boolean variable returns TRUE if Quote option is specified.
         [ out ]  pbTime         : A pointer to boolean variable returns TRUE if Times option is specified.
         [ out ]  pArrVal        : A pointer to dynamic array returns patterns specified as default options.
         [ out ]  pbUsage        : A pointer to boolean variable returns TRUE if Usage option is specified.

      Return Type      : DWORD
        A Integer value indicating EXIT_SUCCESS on successful parsing of
                command line else EXIT_FAILURE

--*/
{
    DWORD dwAttr                =   0;
    LPWSTR szFilePart           =   NULL;
    WCHAR szBuffer[MAX_MAX_PATH]    =   NULL_STRING;
    WCHAR *szBuffer1                =   NULL;
    LPWSTR szLongPath               =   NULL;
    LPWSTR szFullPath               =   NULL;
    DWORD dwSize                    =   0;
    TCMDPARSER2 cmdOptions[6];

        //Fill the structure for recursive option
    StringCopyA(cmdOptions[OI_RECURSIVE].szSignature, "PARSER2", 8 );
    cmdOptions[OI_RECURSIVE].dwType    = CP_TYPE_TEXT;
    cmdOptions[OI_RECURSIVE].dwFlags   =  CP2_ALLOCMEMORY | CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL; // | CP_VALUE_MANDATORY;
    cmdOptions[OI_RECURSIVE].dwCount = 1;
    cmdOptions[OI_RECURSIVE].dwActuals = 0;
    cmdOptions[OI_RECURSIVE].pwszOptions = CMDOPTION_RECURSIVE;
    cmdOptions[OI_RECURSIVE].pwszFriendlyName = NULL;
    cmdOptions[OI_RECURSIVE].pwszValues = NULL;
    cmdOptions[OI_RECURSIVE].pValue = NULL;
    cmdOptions[OI_RECURSIVE].dwLength  = 0;
    cmdOptions[OI_RECURSIVE].pFunction = NULL;
    cmdOptions[OI_RECURSIVE].pFunctionData = NULL;
    cmdOptions[OI_RECURSIVE].dwReserved = 0;
    cmdOptions[OI_RECURSIVE].pReserved1 = NULL;
    cmdOptions[OI_RECURSIVE].pReserved2 = NULL;
    cmdOptions[OI_RECURSIVE].pReserved3 = NULL;

    //Fill the structure for Quite option
    StringCopyA(cmdOptions[OI_QUITE].szSignature, "PARSER2", 8 );
    cmdOptions[OI_QUITE].dwType    = CP_TYPE_BOOLEAN;
    cmdOptions[OI_QUITE].dwFlags   = 0;
    cmdOptions[OI_QUITE].dwCount = 1;
    cmdOptions[OI_QUITE].dwActuals = 0;
    cmdOptions[OI_QUITE].pwszOptions = CMDOPTION_QUITE;
    cmdOptions[OI_QUITE].pwszFriendlyName = NULL;
    cmdOptions[OI_QUITE].pwszValues = NULL;
    cmdOptions[OI_QUITE].pValue = pbQuiet;
    cmdOptions[OI_QUITE].dwLength  = 0;
    cmdOptions[OI_QUITE].pFunction = NULL;
    cmdOptions[OI_QUITE].pFunctionData = NULL;
    cmdOptions[OI_QUITE].dwReserved = 0;
    cmdOptions[OI_QUITE].pReserved1 = NULL;
    cmdOptions[OI_QUITE].pReserved2 = NULL;
    cmdOptions[OI_QUITE].pReserved3 = NULL;
    
   //Fill the structure for Quote option
    StringCopyA(cmdOptions[OI_QUOTE].szSignature, "PARSER2", 8 );
    cmdOptions[OI_QUOTE].dwType    = CP_TYPE_BOOLEAN;
    cmdOptions[OI_QUOTE].dwFlags   = 0;
    cmdOptions[OI_QUOTE].dwCount = 1;
    cmdOptions[OI_QUOTE].dwActuals = 0;
    cmdOptions[OI_QUOTE].pwszOptions = CMDOPTION_QUOTE;
    cmdOptions[OI_QUOTE].pwszFriendlyName = NULL;
    cmdOptions[OI_QUOTE].pwszValues = NULL;
    cmdOptions[OI_QUOTE].pValue = pbQuote;
    cmdOptions[OI_QUOTE].dwLength  = 0;
    cmdOptions[OI_QUOTE].pFunction = NULL;
    cmdOptions[OI_QUOTE].pFunctionData = NULL;
    cmdOptions[OI_QUOTE].dwReserved = 0;
    cmdOptions[OI_QUOTE].pReserved1 = NULL;
    cmdOptions[OI_QUOTE].pReserved2 = NULL;
    cmdOptions[OI_QUOTE].pReserved3 = NULL;
    
   //Fill the structure for Quite option
    StringCopyA(cmdOptions[OI_TIME].szSignature, "PARSER2", 8 );
    cmdOptions[OI_TIME].dwType    = CP_TYPE_BOOLEAN;
    cmdOptions[OI_TIME].dwFlags   = 0;
    cmdOptions[OI_TIME].dwCount = 1;
    cmdOptions[OI_TIME].dwActuals = 0;
    cmdOptions[OI_TIME].pwszOptions = CMDOPTION_TIME;
    cmdOptions[OI_TIME].pwszFriendlyName = NULL;
    cmdOptions[OI_TIME].pwszValues = NULL;
    cmdOptions[OI_TIME].pValue = pbTime;
    cmdOptions[OI_TIME].dwLength  = 0;
    cmdOptions[OI_TIME].pFunction = NULL;
    cmdOptions[OI_TIME].pFunctionData = NULL;
    cmdOptions[OI_TIME].dwReserved = 0;
    cmdOptions[OI_TIME].pReserved1 = NULL;
    cmdOptions[OI_TIME].pReserved2 = NULL;
    cmdOptions[OI_TIME].pReserved3 = NULL;
    
   //Fill the structure for Quite option
    StringCopyA(cmdOptions[OI_USAGE].szSignature, "PARSER2", 8 );
    cmdOptions[OI_USAGE].dwType    = CP_TYPE_BOOLEAN;
    cmdOptions[OI_USAGE].dwFlags   = CP2_USAGE;
    cmdOptions[OI_USAGE].dwCount = 1;
    cmdOptions[OI_USAGE].dwActuals = 0;
    cmdOptions[OI_USAGE].pwszOptions = CMDOPTION_USAGE;
    cmdOptions[OI_USAGE].pwszFriendlyName = NULL;
    cmdOptions[OI_USAGE].pwszValues = NULL;
    cmdOptions[OI_USAGE].pValue = pbUsage;
    cmdOptions[OI_USAGE].dwLength  = 0;
    cmdOptions[OI_USAGE].pFunction = NULL;
    cmdOptions[OI_USAGE].pFunctionData = NULL;
    cmdOptions[OI_USAGE].dwReserved = 0;
    cmdOptions[OI_USAGE].pReserved1 = NULL;
    cmdOptions[OI_USAGE].pReserved2 = NULL;
    cmdOptions[OI_USAGE].pReserved3 = NULL;
    
    StringCopyA(cmdOptions[OI_DEFAULT].szSignature, "PARSER2", 8 );
    cmdOptions[OI_DEFAULT].dwType    = CP_TYPE_TEXT;
    cmdOptions[OI_DEFAULT].dwFlags   =CP2_DEFAULT | CP2_MANDATORY | CP2_VALUE_MASK | CP2_MODE_ARRAY;
    cmdOptions[OI_DEFAULT].dwCount = 0;
    cmdOptions[OI_DEFAULT].dwActuals = 0;
    cmdOptions[OI_DEFAULT].pwszOptions = CMDOPTION_DEFAULT;
    cmdOptions[OI_DEFAULT].pwszFriendlyName = NULL;
    cmdOptions[OI_DEFAULT].pwszValues = NULL;
    cmdOptions[OI_DEFAULT].pValue = pArrVal;
    cmdOptions[OI_DEFAULT].dwLength  = 0;
    cmdOptions[OI_DEFAULT].pFunction = NULL;
    cmdOptions[OI_DEFAULT].pFunctionData = NULL;
    cmdOptions[OI_DEFAULT].dwReserved = 0;
    cmdOptions[OI_DEFAULT].pReserved1 = NULL;
    cmdOptions[OI_DEFAULT].pReserved2 = NULL;
    cmdOptions[OI_DEFAULT].pReserved3 = NULL;


    *pArrVal=CreateDynamicArray();
    if( NULL == *pArrVal  )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        SaveLastError();
        ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
        return( EXIT_FAILURE );
    }

    //process the command line options and display error if it fails
    cmdOptions[OI_DEFAULT].pValue = pArrVal;
    
    if( DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) == FALSE )
    {
        ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
        return( EXIT_FAILURE );
    }
    
    *lpszRecursive = cmdOptions[OI_RECURSIVE].pValue;

    //if usage specified with any other value display error and return with failure
    if( ( TRUE == *pbUsage ) && ( argc > 2 ) )
    {
        SetLastError( (DWORD)MK_E_SYNTAX );
        SaveLastError();
        ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
        ShowMessage( stderr, GetResString( IDS_HELP_MESSAGE ) );
        return( EXIT_FAILURE );
    }

    if( TRUE == *pbUsage )
        return( EXIT_SUCCESS);

    StrTrim( *lpszRecursive, L" " );

    if( 0 == StringLengthW(*lpszRecursive, 0)  && cmdOptions[OI_RECURSIVE].dwActuals !=0 )
    {
        ShowMessage( stderr, GetResString(IDS_NO_RECURSIVE) );
        return( EXIT_FAILURE );
    }

    //check for invalid characters in the directory name
    if ( (*lpszRecursive != NULL) &&  (szFilePart = wcspbrk(*lpszRecursive, INVALID_DIRECTORY_CHARACTERS ))!=NULL )
    {
        ShowMessage( stderr, GetResString(IDS_INVALID_DIRECTORY_SPECIFIED) );
        return( EXIT_FAILURE );

    }

    //if recursive is specified check whether the given path is
    //a true directory or not.
    if( StringLengthW(*lpszRecursive, 0) != 0)
    {
        szBuffer1 = (LPWSTR) AllocateMemory( (StringLengthW(*lpszRecursive, 0)+10)*sizeof(WCHAR) );
        if( NULL == szBuffer1 )
        {
            ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
            return EXIT_FAILURE;
        }
        //place a copy of recursive directory name into a temporary variable to check later for consequtive dots
        StringCopy( szBuffer1, *lpszRecursive, SIZE_OF_ARRAY_IN_CHARS(szBuffer1) );
        
        //get the full path name of directory
        dwSize=GetFullPathName(*lpszRecursive,
                        0,
                      szFullPath,
                     &szFilePart );

        if(  dwSize != 0  )
        {

            szFullPath = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
            if( NULL == szFullPath )
            {
                ShowMessageEx( stderr, 2, TRUE,  L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
                FreeMemory((LPVOID *) &szBuffer1);
                return( EXIT_FAILURE );
            }

            
            if( FALSE == GetFullPathName(*lpszRecursive,
                              dwSize,
                              szFullPath,
                             &szFilePart ) )
            {
                SaveLastError();
                ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
                FreeMemory((LPVOID *) &szBuffer1);
                return EXIT_FAILURE;
            }
            
        }
        else
        {
            SaveLastError();
            ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
            return EXIT_FAILURE;
        }
        
        //get the long path name
        dwSize = GetLongPathName( szFullPath, szLongPath, 0 );
        if( dwSize == 0 )
        {
            SaveLastError();
            ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
            FreeMemory((LPVOID *) &szBuffer1 );
            FreeMemory((LPVOID *) &szFullPath);
            return( EXIT_FAILURE );
        }

        szLongPath = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
        if( NULL == szLongPath )
        {
            ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
            FreeMemory((LPVOID *) &szBuffer1 );
            FreeMemory((LPVOID *) &szFullPath);
            return( EXIT_FAILURE );
        }

        if( FALSE == GetLongPathName( szFullPath, szLongPath, dwSize+5 ) )
        {
            ShowMessage(stderr,GetResString(IDS_INVALID_DIRECTORY_SPECIFIED));
            FreeMemory((LPVOID *) &szBuffer1 );
            FreeMemory((LPVOID *) &szFullPath);
            FreeMemory((LPVOID *) &szLongPath);
            return EXIT_FAILURE;
        }
        else
        {
            FreeMemory((LPVOID *) &(*lpszRecursive) );
            *lpszRecursive = (LPWSTR ) AllocateMemory( (StringLengthW(szLongPath, 0)+10)*sizeof(WCHAR) );
             if( NULL == *lpszRecursive )
            {
                ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
                FreeMemory((LPVOID *) &szBuffer1 );
                FreeMemory((LPVOID *) &szFullPath);
                FreeMemory((LPVOID *) &szLongPath);
                return( EXIT_FAILURE );
            }

            StringCopy( *lpszRecursive, szLongPath, SIZE_OF_ARRAY_IN_CHARS(*lpszRecursive) );
        }
          
        dwAttr = GetFileAttributes( *lpszRecursive);
        if( -1 == dwAttr )
        {
            SaveLastError();
            ShowMessageEx( stderr, 2, TRUE, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
            FreeMemory((LPVOID *) &szBuffer1 );
            FreeMemory((LPVOID *) &szFullPath);
            FreeMemory((LPVOID *) &szLongPath);
            return EXIT_FAILURE;
        }
        if( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
        {
            ShowMessage(stderr,GetResString(IDS_INVALID_DIRECTORY_SPECIFIED));
            FreeMemory((LPVOID *) &szBuffer1 );
            FreeMemory((LPVOID *) &szFullPath);
            FreeMemory((LPVOID *) &szLongPath);
            return EXIT_FAILURE;
        }

        //check if current directory is specified by more than two dots
        GetCurrentDirectory(MAX_MAX_PATH, szBuffer );
        StringConcat( szBuffer, L"\\", MAX_MAX_PATH );
        if( StringCompare(szBuffer, *lpszRecursive, TRUE, 0) == 0 && (szFilePart=(LPWSTR)FindString( szBuffer1, L"...", 0) )!= NULL )
        {
            ShowMessage(stderr,GetResString(IDS_INVALID_DIRECTORY_SPECIFIED));
            FreeMemory((LPVOID *) &szBuffer1 );
            FreeMemory((LPVOID *) &szFullPath);
            FreeMemory((LPVOID *) &szLongPath);
            return EXIT_FAILURE;
        }

    }
    return( EXIT_SUCCESS );
}

LPWSTR DivideToken( LPTSTR szString )
/*++


  Routine Description : Function used to divide the string into tokens delimited by quotes or space

  Arguments:
       [ in  ]  szString   : An LPTSTR string which is to parsed for quotes and spaces.


  Return Type      : LPWSTR
        Returns the token upon successful, NULL otherwise


--*/

{
    static WCHAR* str=NULL;
    WCHAR* szTemp=NULL;

    if( szString )
        str = szString;

    szTemp = str;

    while( *str!=_T('*')  && *str )
        str++;
    if( *str )
    {
        *str=_T('\0');
        str++;
    }

    while( *str==_T('*') && *str )
        str++;

    if( szTemp[0] )
        return (szTemp );
    else return( NULL );

}

DWORD FreeList( DIRECTORY dir )
/*++
  Routine Description : Function is used to free the linked list

  Arguments:
       [ in  ]  *dir   : pointer to DIRECTORY list

  Return Type      : LPWSTR
        Returns the EXIT_SUCCESS successful, EXIT_FAILURE otherwise
--*/
{
    DIRECTORY temp;
    for( temp=dir; dir; temp=dir->next )
    {
        FreeMemory( (LPVOID *)&temp->szDirectoryName );
        FreeMemory((LPVOID*) &temp );
    }
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\where\where.h ===
#include "resource.h"
#include <sys\types.h>
#include <sys\stat.h>
#include <time.h>


#define SRCHATTR    (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_NORMAL)

#define     MAX_OPTIONS         8
#define     MAX_MAX_PATH        1024

#define     CMDOPTION_RECURSIVE L"R"
#define     CMDOPTION_QUITE     L"Q"
#define     CMDOPTION_QUOTE     L"F"
#define     CMDOPTION_TIME      L"T"
#define     CMDOPTION_USAGE     L"?"
#define     CMDOPTION_DEFAULT   L""

#define     EXIT_FAILURE_2      2   

#define OI_RECURSIVE    0
#define OI_QUITE        1
#define OI_QUOTE        2
#define OI_TIME         3
#define OI_USAGE        4
#define OI_DEFAULT      5

#define SAFE_FREE( p )      if( (p) != NULL ) \
                            { \
                                free(p); \
                                p=NULL; \
                            }

#define UNC_FORMAT      L"\\\\?\\"
#define NEW_LINE        L"\n"
#define EMPTY_SPACE     L" "
#define INVALID_DIRECTORY_CHARACTERS     L"*/?<>|"
#define NULL_U_STRING   L"\0"

#define SIZE_OF_ARRAY_IN_CHARS(x) \
        GetBufferSize(x)/sizeof(WCHAR)

#define SIZE_OF_ARRAY_IN_BYTES(x) \
        GetBufferSize(x)

struct dirtag
{
   WCHAR *szDirectoryName;
    struct dirtag *next;
};

typedef struct dirtag* DIRECTORY;


extern enum exeKind exeType( LPWSTR f);
extern WCHAR *strExeType(enum exeKind exenum);


DWORD FindforFile(IN LPWSTR lpszDirectory,
            IN LPWSTR lpszPattern,
            IN BOOL bQuite,
            IN BOOL bQuote,
            IN BOOL bTime
           );

DWORD FindforFileRecursive(IN LPWSTR lpszDirectory,
            IN PTARRAY Pattern,
            IN BOOL bQuiet,
            IN BOOL bQuote,
            IN BOOL bTime
           );

DWORD Where( LPWSTR lpszPattern,
             IN BOOL bQuite,
             IN BOOL bQuote,
             IN BOOL bTime);

BOOL Match ( LPWSTR pat,
              LPWSTR text
            );
DWORD
found (
      LPWSTR p,
      BOOL bQuite,
      BOOL bQuote,
      BOOL bTime
      );

DWORD DisplayHelpUsage();
DWORD GetFileDateTimeandSize( LPWSTR wszFileName, DWORD *dwSize, LPWSTR wszDate, LPWSTR wszTime );

DWORD ProcessOptions( IN DWORD argc,
                      IN LPCWSTR argv[],
                      OUT LPWSTR *lpszRecursive,
                      OUT PBOOL pbQuite,
                      OUT PBOOL pbQuote,
                      OUT PBOOL pbTime,
                      OUT PTARRAY pArrVal,
                      OUT PBOOL pbUsage);

DWORD Push( OUT DIRECTORY *dir, IN LPWSTR szPath );
BOOL Pop( IN DIRECTORY *dir, OUT LPWSTR *lpszDirectory);
LPWSTR DivideToken( LPTSTR szString );
BOOL GetRecursiveDirectory( IN LPCWSTR pwszOption, IN LPCWSTR pwszValue, OUT LPVOID pData, IN DWORD* pdwIncrement );
DWORD FreeList( DIRECTORY dir );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\pch.h ===
// *********************************************************************************
//
//    Copyright(c) Microsoft Corporation
//
//    Module Name:
//
//        pch.h
//
//    Abstract:
//
//        This header file is a precompiled header for this project.
//        This module contains the common include files [ system,user defined ]
//        which are not changed frequently.
//
//    Author:
//
//        Venu Gopal Choudary  10-July-2001 : Created it
//
//    Revision History:
//        Wipro Technologies 10-July-10: Modified
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000   // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#define CMDLINE_VERSION     200
//
// public Windows header files
//
#include <windows.h>
#include <security.h>

// public C header files
//
#include <stdio.h>
#include <tchar.h>
#include <shlwapi.h>
#include <strsafe.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\who.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    who.h

Abstract:

    This module contains the macros, user defined structures & function
    definitions needed by whoami.cpp, wsuser.cpp, wssid.cpp and
    wspriv.cppfiles.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

//maximum number of options
#define MAX_COMMANDLINE_OPTIONS    10

#define EXIT_SUCCESS        0
#define EXIT_FAILURE        1

#define OI_USAGE            0
#define OI_USER             1
#define OI_GROUPS           2
#define OI_LOGONID          3
#define OI_PRIV             4
#define OI_ALL              5
#define OI_UPN              6
#define OI_FQDN             7
#define OI_FORMAT           8
#define OI_NOHEADER         9

#define UPN_FORMAT          1
#define FQDN_FORMAT         2
#define USER_ONLY           3

#define RETVALZERO          0
#define COL_FORMAT_STRING   L"%s"
#define COL_FORMAT_HEX      L"%d"

#define  FORMAT_TABLE       L"TABLE"
#define  FORMAT_LIST        L"LIST"
#define  FORMAT_CSV         L"CSV"


// function declarations
VOID DisplayHelp ( VOID );
BOOL ProcessOptions(
    IN DWORD argc,
    IN LPCWSTR argv[],
    OUT BOOL *pbUser,
    OUT BOOL *pbGroups,
    OUT BOOL *pbPriv,
    OUT BOOL *pbLogonId,
    OUT BOOL *pbAll,
    OUT BOOL *pbUpn,
    OUT BOOL *pbFqdn,
    OUT LPWSTR wszFormat,
    OUT DWORD *dwFormatActuals,
    OUT BOOL *pbUsage,
    OUT BOOL *pbNoHeader
    )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\resource.h ===
#define IDS_WHOAMI_HLP1             101
#define IDS_WHOAMI_HLP2             102
#define IDS_WHOAMI_HLP3             103
#define IDS_WHOAMI_HLP4             104
#define IDS_WHOAMI_HLP5             105
#define IDS_WHOAMI_HLP6             106
#define IDS_WHOAMI_HLP7             107
#define IDS_WHOAMI_HLP8             108
#define IDS_WHOAMI_HLP9             109
#define IDS_WHOAMI_HLP10            110
#define IDS_WHOAMI_HLP11            111
#define IDS_WHOAMI_HLP12            112
#define IDS_WHOAMI_HLP13            113
#define IDS_WHOAMI_HLP14            114
#define IDS_WHOAMI_HLP15            115
#define IDS_WHOAMI_HLP16            116
#define IDS_WHOAMI_HLP17            117
#define IDS_WHOAMI_HLP18            118
#define IDS_WHOAMI_HLP19            119
#define IDS_WHOAMI_HLP20            120
#define IDS_WHOAMI_HLP21            121
#define IDS_WHOAMI_HLP22            122
#define IDS_WHOAMI_HLP23            123
#define IDS_WHOAMI_HLP24            124
#define IDS_WHOAMI_HLP25            125
#define IDS_WHOAMI_HLP26            126
#define IDS_WHOAMI_HLP27            127
#define IDS_WHOAMI_HLP28            128
#define IDS_WHOAMI_HLP29            129
#define IDS_WHOAMI_HLP30            130
#define IDS_WHOAMI_HLP31            131
#define IDS_WHOAMI_HLP32            132
#define IDS_WHOAMI_HLP33            133
#define IDS_WHOAMI_HLP34            134
#define IDS_WHOAMI_HLP35            135
#define IDS_WHOAMI_HLP36            136
#define IDS_WHOAMI_HLP37            137
#define IDS_WHOAMI_HLP38            138
#define IDS_WHOAMI_HLP39            139
#define IDS_WHOAMI_HLP40            140
#define IDS_WHOAMI_HLP41            141
#define IDS_WHOAMI_HLP42            142
#define IDS_WHOAMI_HLP43            143
#define IDS_WHOAMI_HLP44            144
#define IDS_WHOAMI_HLP45            145
#define IDS_WHOAMI_HLP46            146
#define IDS_WHOAMI_HLP47            147
#define IDS_WHOAMI_HLP48            148
#define IDS_WHOAMI_HLP49            149
#define IDS_WHOAMI_HLP50            150
#define IDS_WHOAMI_HLP51            151
#define IDS_WHOAMI_HLP52            152
#define IDS_WHOAMI_HLP53            153
#define IDS_WHOAMI_HLP54            154
#define IDS_WHOAMI_HLP55            155
#define IDS_WHOAMI_HLP56            156
#define IDS_WHOAMI_HLP57            157
#define IDS_WHOAMI_HLP58            158
#define IDS_WHOAMI_HLP59            159
#define IDS_WHOAMI_HLP60            160
#define IDS_WHOAMI_HLP61            161
#define IDS_WHOAMI_HLP62            162
#define IDS_WHOAMI_HLP63            163
#define IDS_WHOAMI_HLP64            164
#define IDS_WHOAMI_HLP65            165


#define IDS_INVALID_SYNERROR        302
#define IDS_QUERY_FORMAT_TABLE      303
#define IDS_QUERY_FORMAT_LIST       304
#define IDS_QUERY_FORMAT_CSV        305
#define IDS_INVALID_SID             306
#define IDS_INVALID_FORMAT          307

#define IDS_STATE_ENABLED           322
#define IDS_STATE_DISABLED          323
#define IDS_LIST_USER_NAMES         324
#define IDS_LIST_GROUP_NAMES        325
#define IDS_LIST_LOGON_ID           326
#define IDS_LIST_PRIV_NAMES         327
#define IDS_DISPLAY_DASH            328
#define IDS_ERROR_FQDN              329
#define IDS_ERROR_UPN               330
#define IDS_NOT_NH_LIST             331

#define IDS_COL_USERNAME            400
#define IDS_COL_SID                 401
#define IDS_COL_USERNAME_FQDN       402

#define IDS_COL_GROUP_NAME          420
#define IDS_COL_TYPE_GROUP          421
#define IDS_COL_GROUP_SID           422
#define IDS_COL_ATTRIBUTE           423

#define IDS_COL_PRIV_NAME           453
#define IDS_COL_PRIV_DESC           454
#define IDS_COL_PRIV_STATE          455

#define IDS_PRIVNAME_COL_NUMBER     456
#define IDS_PRIVDESC_COL_NUMBER     457
#define IDS_PRIVSTATE_COL_NUMBER    458

#define IDS_WIDTH_PRIVNAME          459
#define IDS_WIDTH_PRIVDESC          460
#define IDS_WIDTH_PRIVSTATE         461

#define IDS_WIDTH_GROUP_NAME        462
#define IDS_WIDTH_GROUP_SID         463

#define IDS_WIDTH_LOGONID           466
#define IDS_NO_SERVER               467
#define IDS_USER_BUT_NOMACHINE      468
#define IDS_INVALID_USERNAME        469
#define IDS_IGNORE_LOCALCREDENTIALS 470
#define IDS_PASSWORD_BUT_NOUSER     471

#define IDS_WIDTH_GROUP_FQDN         472
#define IDS_GROUP_FQDN_COL_NUMBER    473
#define IDS_WIDTH_USERNAME_FQDN      474
#define IDS_USERNAME_FQDN_COL_NUMBER 475

#define IDS_LIST_FQDN                476
#define IDS_LIST_UPN                 477
#define IDS_SLASH                    478

#define IDS_COL_USERNAME_UPN        479
#define IDS_UPN_ONLY_COL_NUMBER     480
#define IDS_FQDN_ONLY_COL_NUMBER    481
#define IDS_WIDTH_USERNAME_UPN      482

#define IDS_DISPLAY_USER_DASH       483
#define IDS_DISPLAY_GROUP_DASH      484
#define IDS_DISPLAY_LOGON_DASH      485
#define IDS_DISPLAY_PRIV_DASH       486

#define IDS_FORMAT_MSG_FAIL         487
#define IDS_NO_GROUPS               488

#define IDS_OVALUES_FORMAT          489

//Types and Attributes
#define IDS_TYPE_USER                500
#define IDS_TYPE_GROUP               501
#define IDS_TYPE_DOMAIN              502
#define IDS_TYPE_ALIAS               503
#define IDS_TYPE_WELLKNOWN           504
#define IDS_TYPE_DELETACCOUNT        505
#define IDS_TYPE_INVALIDSID          506
#define IDS_TYPE_UNKNOWN             507

#define IDS_ATTRIB_MANDATORY         510
#define IDS_ATTRIB_BYDEFAULT         511
#define IDS_ATTRIB_ENABLED           512
#define IDS_ATTRIB_OWNER             513
#define IDS_ATTRIB_USEFORDENY        514
#define IDS_ATTRIB_LOGONID           515
#define IDS_ATTRIB_LOCAL             516


//redefines
#define IDS_WHOAMI_HELP_START       IDS_WHOAMI_HLP1
#define IDS_WHOAMI_HELP_END         IDS_WHOAMI_HLP65
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wspriv.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wspriv.h

Abstract:

    This module contains the macros, user defined structures & function
    definitions needed by whoami.cpp, wsuser.cpp, wssid.cpp and
    wspriv.cppfiles.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/
#ifndef WSPRIV_H
#define WSPRIV_H
;
class WsPrivilege {
   protected:
      LUID        Luid ;
      DWORD       Attributes ;

   public:
      WsPrivilege                ( IN LUID Luid,
                                   IN DWORD Attributes ) ;
      WsPrivilege                ( IN LUID_AND_ATTRIBUTES *lpLuaa ) ;

      DWORD    GetDisplayName    ( OUT LPWSTR wszPrivName,
                                   OUT LPWSTR wszPrivDisplayName) ;

      DWORD    GetName           ( OUT LPWSTR wszPrivName ) ;

      BOOL     IsEnabled         ( VOID ) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wspriv.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wspriv.cpp

Abstract:

     This file can be used to get the privileges with the respective display
     names in the current access token on a local system.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

WsPrivilege::WsPrivilege ( IN LUID Luid,
                           IN DWORD Attributes )
/*++
   Routine Description:
    This function intializes the members of WsPrivilege.

   Arguments:
        [IN] LUID Luid     : LUID
        [OUT] DWORD Attributes      : Attributes

   Return Value:
        None
--*/
{
    // initialize the member variables
   memcpy ( (LPSTR) &this->Luid, (LPSTR) &Luid, sizeof(LUID) ) ;
   this->Attributes = Attributes ;
}

WsPrivilege::WsPrivilege (
                            IN LUID_AND_ATTRIBUTES *lpLuaa
                         )
/*++
   Routine Description:
    This function intializes the members of WsPrivilege.

   Arguments:
        [IN] LUID_AND_ATTRIBUTES *lpLuaa ; LUID attributes

   Return Value:
        None
--*/
{
    // set the attributes
   memcpy ( (LPSTR) &Luid, (LPSTR) &lpLuaa->Luid, sizeof(LUID) ) ;
   Attributes = lpLuaa->Attributes ;
}


DWORD
WsPrivilege::GetName (
                        OUT LPWSTR wszPrivName
                     )
/*++
   Routine Description:
    This function gets the privilege name.

   Arguments:
          [OUT] LPWSTR wszPrivName      : Stores privilege name

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

    // sub-local variables
   DWORD    dwSize = 0 ;
   WCHAR   wszTempPrivName [ MAX_RES_STRING ];

   SecureZeroMemory ( wszTempPrivName, SIZE_OF_ARRAY(wszTempPrivName) );

   //Get the name
   dwSize = SIZE_OF_ARRAY ( wszTempPrivName ) ;
   if ( FALSE == LookupPrivilegeName ( NULL,
                                &Luid,
                                wszTempPrivName,
                                &dwSize ) ){
       // return WIN32 error code
       return GetLastError() ;
   }

   StringCopy ( wszPrivName, wszTempPrivName, MAX_RES_STRING );
   return EXIT_SUCCESS ;
}


DWORD
WsPrivilege::GetDisplayName ( IN LPWSTR  wszName,
                              OUT LPWSTR wszDispName )
/*++
   Routine Description:
    This function gets the privilege description.

   Arguments:
        [OUT] LPWSTR  szName      : Stores privilege name
        [OUT] LPWSTR szDispName   : Stores privilege description

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{
   // sub-local variables
   DWORD    dwSize = 0 ;
   DWORD    dwLang = 0 ;
   WCHAR   wszTempDispName [ MAX_RES_STRING ];

   SecureZeroMemory ( wszTempDispName, SIZE_OF_ARRAY(wszTempDispName) );


   //Get the display name
   dwSize = SIZE_OF_ARRAY ( wszTempDispName ) ;
   // get the description for the privilege name
   if ( FALSE == LookupPrivilegeDisplayName ( NULL,
                                       (LPWSTR) wszName,
                                       wszTempDispName,
                                       &dwSize,
                                       &dwLang ) ){
       return GetLastError () ;
   }

   StringCopy ( wszDispName, wszTempDispName, MAX_RES_STRING );

   // return success
   return EXIT_SUCCESS ;
}


BOOL
WsPrivilege::IsEnabled ( VOID )
/*++
   Routine Description:
    This function checks whether the privilege is enabled or not.

   Arguments:
     None
   Return Value:
         TRUE  :   On success
         FALSE :   On failure
--*/
{

    // check if prvilege is enabled
   if ( Attributes & SE_PRIVILEGE_ENABLED ){
       return TRUE ;
   }
   else{
       return FALSE ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\whoami.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    Whoami.cpp

Abstract:

     This file can be used to get the information of user name, groups
     with the respective security identifiers (SID), privileges, logon
     identifier (logon ID) in the current access token on a local system
     or a remote system.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


 DWORD __cdecl
 wmain(
     IN DWORD argc,
     IN LPCWSTR argv[]
     )
/*++
   Routine Description:
    This is the main entry for this utility. This function reads the input from
    console and calls the appropriate functions to achieve the functionality.

   Arguments:
        [IN] argc              : Command line argument count
        [IN] argv              : Command line argument

   Return Value:
         EXIT_FAILURE :   On failure
         EXIT_SUCCESS :   On success
--*/
     {

    // class instance
    WsUser      User ;

    // Local variables
    BOOL bUser       = FALSE;
    BOOL bGroups     = FALSE;
    BOOL bPriv       = FALSE;
    BOOL bLogonId    = FALSE;
    BOOL bSid        = FALSE;
    BOOL bAll        = FALSE;
    BOOL bUsage      = FALSE;
    BOOL bUpn        = FALSE;
    BOOL bFqdn       = FALSE;
    BOOL bFlag      = FALSE;

    DWORD dwCount    = 0 ;
    DWORD  dwRetVal = 0 ;
    DWORD  dwFormatType = 0 ;
    DWORD  dwNameFormat = 0 ;
    BOOL   bResult = 0;
    DWORD  dwFormatActuals = 0;
    BOOL   bNoHeader = FALSE;

    WCHAR   wszFormat[ MAX_STRING_LENGTH ];

    SecureZeroMemory ( wszFormat, SIZE_OF_ARRAY(wszFormat) );

    //check for empty arguments
    if ( NULL == argv )
    {
        SetLastError ((DWORD)ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }

    //parse command line options
    bResult = ProcessOptions(argc, argv, &bUser, &bGroups, &bPriv, &bLogonId, &bAll,
                             &bUpn, &bFqdn, wszFormat, &dwFormatActuals, &bUsage, &bNoHeader );
     if( FALSE == bResult )
    {
        // display an error message with respect to the GetReason()
        //ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    // Check for invalid syntax
    if ( //( ( TRUE == bOthers ) && ( argc > 1 ) ) ||
         ( ( TRUE == bUsage ) && ( argc > 2 ) ) ||
         ( ( ( (bUser && dwCount++) || (bGroups && dwCount++) || (bLogonId && dwCount++) || (bPriv && dwCount++) ||
             (bAll && dwCount++) || (bUsage && dwCount++) || ( bUpn && dwCount++ ) || ( bFqdn && dwCount++ ) || ( bNoHeader && dwCount++ ) ||
                  (dwFormatActuals && dwCount++)) && (dwCount == 0) ) &&
                  ( argc > 1 ) ) ||
         ( ( (bUser && dwCount++) || (bGroups && dwCount++) || (bLogonId && dwCount++) || (bPriv && dwCount++)|| ( bUpn && dwCount++ ) || ( bFqdn && dwCount++ ) ) && (dwCount > 0 ) && ( TRUE == bAll ) )  ||
         ( bUpn && bFqdn) || ( bUpn && ( argc > 2 ) ) || ( bFqdn && ( argc > 2 )) || ( bLogonId && ( argc > 2 )) ||
         ( ( 1 == dwFormatActuals ) && ( 3 == argc )) || ( ( TRUE == bNoHeader ) && ( 1 == dwFormatActuals ) && ( 4 == argc )) )
    {
        // display an error message as .. invalid syntax specified..
        ShowMessage( stderr, GetResString(IDS_INVALID_SYNERROR ));
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

      // if /FO option is specified
    if ( 1 == dwFormatActuals )
     {
        // if /FO LIST specified
        if( StringCompare( wszFormat , FORMAT_LIST, TRUE, 0 ) == 0 )
        {
            dwFormatType = SR_FORMAT_LIST;
        }
        // if /FO TABLE is specified
        else if( StringCompare ( wszFormat , FORMAT_TABLE, TRUE, 0 ) == 0 )
        {
            dwFormatType = SR_FORMAT_TABLE;
        }
        // if /FO CSV is specified
        else if( StringCompare ( wszFormat , FORMAT_CSV, TRUE, 0 ) == 0 )
        {
            dwFormatType = SR_FORMAT_CSV;
        }
        else // check for invalid format .. other than /LIST, /TABLE or /CSV
        {
            // display an error message as ..invalid format specified..
            ShowMessage ( stderr, GetResString ( IDS_INVALID_FORMAT ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
     }
     else
     {
            // If /FO is not specified. Default format is TABLE
            dwFormatType = SR_FORMAT_TABLE;
     }

    if ((SR_FORMAT_LIST == dwFormatType) && ( TRUE == bNoHeader ) )
    {
        ShowMessage ( stderr, GetResString (IDS_NOT_NH_LIST) );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

     if ( TRUE == bNoHeader )
     {
        dwFormatType |= SR_HIDECOLUMN;
     }

    // Initialize access token , user, groups and privileges
    if( EXIT_SUCCESS != User.Init () ){
        //display an error message
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        // release memory
        ReleaseGlobals();
        return EXIT_FAILURE ;
    }

    // if /UPN (User Pricipal Name)is specified
    if ( ( TRUE == bUpn ) && ( 2 == argc ) )
    {
        dwNameFormat = UPN_FORMAT;
    }
    // if /FQDN (Fully Qualified Distinguished Name) is specified
    else if ( ( TRUE == bFqdn ) && ( 2 == argc ))
    {
        dwNameFormat = FQDN_FORMAT;
    }

    //reset to 0
    dwCount = 0;

    // if /USER /GROUPS /PRIV or /ALL specified, set the flag to TRUE
    if ( ( (bUser && dwCount++) || (bGroups && dwCount++) || (bPriv && dwCount++) && ( dwCount > 1 )) || ( TRUE == bAll ) )
    {
        bFlag = TRUE;
    }

    // Display information

    // if /all option is specified, then set all the flags to TRUE.
    if( TRUE == bAll ) {
     // set all the flags i.e./USER, /GROUPS, /PRIV to TRUE
     bUser       = TRUE;
     bGroups     = TRUE ;
     bPriv       = TRUE ;
     bSid        = TRUE ;
    }

    // if /user option is specified
    if ( ( TRUE == bUser )  || (FQDN_FORMAT == dwNameFormat) || (UPN_FORMAT == dwNameFormat) )
    {
        // display the current logged-on user name
        dwRetVal = User.DisplayUser ( dwFormatType , dwNameFormat ) ;
        if ( EXIT_SUCCESS != dwRetVal )
        {
            //release memory
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    // if /groups option is specified
    if( TRUE == bGroups ) {
        if ( TRUE == bFlag )
        {
            // display a new line
            ShowMessage ( stdout, L"\n");
        }
        // display the group names
        dwRetVal = User.DisplayGroups ( dwFormatType ) ;
        if ( EXIT_SUCCESS != dwRetVal )
        {
            if ( GetLastError() != E_OUTOFMEMORY )
            {
                // display an error message as .. there are no groups available..
                ShowMessage ( stderr, GetResString (IDS_NO_GROUPS) );
            }
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    // if /logonid option is specified
    if( TRUE == bLogonId ) {
        // display LOGON ID
        dwRetVal = User.DisplayLogonId () ;
        if ( EXIT_SUCCESS != dwRetVal )
        {
            // display an error messagw with respect to GetLastError() error code
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            // release memory
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    // if /priv option is specified
    if( TRUE == bPriv ) {
        if ( TRUE == bFlag )
        {
            ShowMessage ( stdout, L"\n");
        }
        // display all privilege names
        dwRetVal = User.DisplayPrivileges ( dwFormatType ) ;
        if ( EXIT_SUCCESS != dwRetVal  )
        {
            // display an error message with respect to GetLastError() error code
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            //release memory
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    // if /? option is specified
    if ( bUsage == TRUE )
    {
        // display the help/usage for this tool
        DisplayHelp() ;
        // release memory
        ReleaseGlobals();
        return EXIT_SUCCESS;
    }

    // if the command is "whoami.exe" .. then display the username by default
    // in other words.. if argument count is 1.. then display current logged-on user name
    if ( ( !( (bUser && dwCount++) || (bGroups && dwCount++) || (bLogonId && dwCount++) ||
           (bPriv && dwCount++) || (bAll && dwCount++) || (bUsage && dwCount++) ||
           ( bUpn && dwCount++ ) || ( bFqdn && dwCount++ ) ) && ( dwCount == 0 ) && (1 == argc)) )
    {
        dwNameFormat = USER_ONLY;

        // display current logged-on user name
        dwRetVal = User.DisplayUser ( dwFormatType, dwNameFormat ) ;
        if ( EXIT_SUCCESS != dwRetVal )
        {
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            // release memory
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

      // release memory
      ReleaseGlobals();

      //retrun success
      return EXIT_SUCCESS;
}


VOID
DisplayHelp (
        VOID
)
/*++
   Routine Description:
    This function displays the help/usage for this utility.

   Arguments:
     None
   Return Value:
     None
--*/
{
    // sub-local variable
    WORD wCount = 0;

    // display the help/usage
    for ( wCount = IDS_WHOAMI_HELP_START; wCount <= IDS_WHOAMI_HELP_END ; wCount++ )
    {
        //display the help/usage
        ShowMessage ( stdout, GetResString ( wCount ) );
    }
    // return success
    return;
}


BOOL
ProcessOptions(
    IN DWORD argc,
    IN LPCWSTR argv[],
    OUT BOOL *pbUser,
    OUT BOOL *pbGroups,
    OUT BOOL *pbPriv,
    OUT BOOL *pbLogonId,
    OUT BOOL *pbAll,
    OUT BOOL *pbUpn,
    OUT BOOL *pbFqdn,
    OUT LPWSTR wszFormat,
    OUT DWORD *dwFormatActuals,
    OUT BOOL *pbUsage,
    OUT BOOL *pbNoHeader
    )
/*++
Routine Description
    This function processes the command line for the main options

Arguments:
    [in]  argc      : Number of Command line arguments.
    [in]  argv      : Pointer to Command line arguments.
    [out] pbUser    : Flag that indicates whether /USER option is specified or not
    [out] pbGroups  : Flag that indicates whether /GROUPS option is specified or not
    [out] pbPriv    : Flag that indicates whether /PRIV option is specified or not
    [out] pbLogonId : Flag that indicates whether /LOGONID option is specified or not
    [out] pbAll     : Flag that indicates whether /ALL option is specified or not
    [out] pbUpn     : Flag that indicates whether /UPN option is specified or not
    [out] pbFqdn    : Flag that indicates whether /FQDN option is specified or not
    [out] wszFormat : Value for /FO option
    [out] dwFormatActuals : Flag that indicates whether /FO option is specified or not
    [out] pbUsage : Flag that indicates whether /? option is specified or not

Return Value
    TRUE on success
    FALSE on failure
--*/
{

    // sub-local variables
    TCMDPARSER2*  pcmdParser = NULL;
    TCMDPARSER2 cmdParserOptions[MAX_COMMANDLINE_OPTIONS];
    BOOL bReturn = FALSE;

    // command line options
    const WCHAR szUserOption[]    = L"user";
    const WCHAR szGroupOption[]   = L"groups";
    const WCHAR szLogonOpt[]      = L"logonid";
    const WCHAR szPrivOption[]    = L"priv";
    const WCHAR szAllOption[]     = L"all";
    const WCHAR szUpnOption[]     = L"upn";
    const WCHAR szFqdnOption[]    = L"fqdn";
    const WCHAR szFormatOption[]  = L"fo";
    const WCHAR szHelpOpt[]       = L"?";
    const WCHAR szNoHeaderOption[]   = L"nh";

    const WCHAR szFormatValues[]  = L"table|list|csv";

    //
    // fill the commandline parser
    //

    // -? help/usage
    pcmdParser = cmdParserOptions + OI_USAGE;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szHelpOpt;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = CP2_USAGE;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbUsage;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -user option
    pcmdParser = cmdParserOptions + OI_USER;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szUserOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbUser;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

   // -groups option
    pcmdParser = cmdParserOptions + OI_GROUPS;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szGroupOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbGroups;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -logonid option
    pcmdParser = cmdParserOptions + OI_LOGONID;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szLogonOpt;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbLogonId;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -priv option
    pcmdParser = cmdParserOptions + OI_PRIV;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szPrivOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbPriv;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -all option
    pcmdParser = cmdParserOptions + OI_ALL;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szAllOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbAll;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -upn option
    pcmdParser = cmdParserOptions + OI_UPN;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szUpnOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbUpn;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -fqdn option
    pcmdParser = cmdParserOptions + OI_FQDN;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szFqdnOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbFqdn;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -fo <format>
    pcmdParser = cmdParserOptions + OI_FORMAT;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_TEXT;
    pcmdParser->pwszOptions = szFormatOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = szFormatValues;
    pcmdParser->dwFlags    = CP2_MODE_VALUES|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = wszFormat;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // -nh 
    pcmdParser = cmdParserOptions + OI_NOHEADER;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = szNoHeaderOption;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbNoHeader;
    pcmdParser->dwLength    = 0;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;


    //parse command line arguments
    bReturn = DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdParserOptions), cmdParserOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return FALSE;
    }

    // check whether /FO is specified in the command line or not.
    pcmdParser = cmdParserOptions + OI_FORMAT;
    *dwFormatActuals = pcmdParser->dwActuals;

    //return 0
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wssid.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wssid.h

Abstract:

    This module contains the macros, user defined structures & function
    definitions needed by whoami.cpp, wsuser.cpp, wssid.cpp and
    wspriv.cppfiles.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

#ifndef  WSSID_H
#define  WSSID_H


//width constants for the fields

#define USERNAME_COL_NUMBER         0
#define SID_COL_NUMBER              1

#define GROUP_NAME_COL_NUMBER       0
#define GROUP_TYPE_COL_NUMBER       1
#define GROUP_SID_COL_NUMBER        2
#define GROUP_ATT_COL_NUMBER        3


#define SLASH        L"\\"
#define DASH         L"-"
#define BASE_TEN     10
#define SID_STRING   L"S-1"

#define AUTH_FORMAT_STR1         L"0x%02hx%02hx%02hx%02hx%02hx%02hx"
#define AUTH_FORMAT_STR2         L"%lu"
#define STRING_SID               L"-513"


// ----- Class WsSid -----
class WsSid {
   protected:
      PSID     pSid ;            // The SID
      BOOL     bToBeFreed ;      // TRUE if SID must be freed when object destroyed

   public:
      WsSid                        ( VOID ) ;
      ~WsSid                       ( VOID ) ;

      DWORD    DisplayAccountName       ( IN DWORD dwFormat,
                                          IN DWORD dwNameFormat) ;

      DWORD    DisplayGroupName       ( OUT LPWSTR wszGroupName,
                                        OUT LPWSTR wszGroupSid,
                                        IN DWORD *dwSidUseName) ;

      DWORD    DisplaySid        ( OUT LPWSTR wszSid ) ;

      DWORD    GetAccountName    ( OUT LPWSTR wszUserName, OUT DWORD *dwSidType ) ;

      DWORD    GetSidString      ( OUT LPWSTR wszSid ) ;

      DWORD    Init              ( OUT PSID pOtherSid ) ;

      BOOL     EnableDebugPriv(VOID) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wstoken.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wstoken.h

Abstract:

    This module contains the macros, user defined structures & function
    definitions needed by whoami.cpp, wsuser.cpp, wssid.cpp and
    wspriv.cppfiles.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

#ifndef  WSTOKEN_H
#define  WSTOKEN_H

#include "wssid.h"

class WsUser;
class WsPrivilege ;

// ----- Class WsAccessToken -----
class WsAccessToken {
protected:
    HANDLE      hToken ;

    BOOL     IsLogonId      ( OUT TOKEN_GROUPS *lpTokenGroups ) ;

public:
    WsAccessToken           ( VOID ) ;
    ~WsAccessToken          ( VOID ) ;
    DWORD    *dwDomainAttributes;


    DWORD    InitUserSid    ( OUT WsSid *lpSid ) ;

    DWORD    InitGroups     ( OUT WsSid ***lppGroupsSid,
                              OUT WsSid **lppLogonId,
                              OUT DWORD *lpnbGroups ) ;

    DWORD    InitPrivs      ( OUT WsPrivilege ***lppPriv,
                              OUT DWORD *lpnbPriv ) ;

    DWORD    Open           ( VOID ) ;

    VOID     GetDomainAttributes( DWORD dwAttributes, 
                                  LPWSTR szDmAttrib, 
                                  DWORD dwSize );
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wssid.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wssid.cpp

Abstract:

     This file gets the security identifier (SID) for respective user name and
     groups in the current access token on a local system or a remote system.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


WsSid::WsSid  ( VOID )
/*++
   Routine Description:
    This function intializes the members of WsSid class.

   Arguments:
    None
   Return Value:
    None
--*/
{
    // initializing member variables
   pSid        = NULL ;
   bToBeFreed  = FALSE ;
}



WsSid::~WsSid ( VOID )
/*++
   Routine Description:
    This function deallocates the members of WsSid class.

   Arguments:
     None
  Return Value:
     None
--*/
{

    // release memory
   if ( bToBeFreed && pSid ){
       FreeMemory ( (LPVOID *) &pSid ) ;
     }
}


DWORD
WsSid::DisplayAccountName (
                            IN DWORD dwFormatType ,
                            IN DWORD dwNameFormat
                            )
/*++
   Routine Description:
    This function displays the user name and SID.

   Arguments:
        [IN] DWORD dwFormatType  : Format type i.,e LIST, CSV or TABLE
        [IN] DWORD dwNameFormat  : Name Format either UPN or FQDN

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

    // sub-local variables
   WCHAR      wszUserName[ MAX_STRING_LENGTH ];
   WCHAR      wszSid [ MAX_STRING_LENGTH ];
   WCHAR      wszGroup[MAX_STRING_LENGTH];
   DWORD      dwErr = 0 ;
   DWORD      dwColCount = 0 ;
   DWORD      dw = 0 ;
   DWORD      dwCount = 0 ;
   DWORD      dwArrSize = 0 ;
   DWORD      dwSize = 0;
   DWORD      dwUserLen = 0;
   DWORD      dwSidLen = 0;
   DWORD      dwUserColLen = 0;
   DWORD      dwSidColLen = 0;
   DWORD      dwSidUse = 0;
   LPWSTR     wszBuffer = NULL;

   //initialize memory
   SecureZeroMemory ( wszUserName, SIZE_OF_ARRAY(wszUserName) );
   SecureZeroMemory ( wszSid, SIZE_OF_ARRAY(wszSid) );
   SecureZeroMemory ( wszGroup, SIZE_OF_ARRAY(wszGroup) );

   // create a dynamic array
    TARRAY pColData = CreateDynamicArray();
    if ( NULL == pColData)
    {
        // set last error and display an error message with respect
        //to ERROR_NOT_ENOUGH_MEMORY
        SetLastError((DWORD)E_OUTOFMEMORY);
        SaveLastError();
        ShowLastErrorEx (stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        return EXIT_FAILURE;
    }

    dwSize = SIZE_OF_ARRAY(wszGroup);

    //if /FQDN is specified
    if ( (FQDN_FORMAT == dwNameFormat) )
    {
        //Get the username in FQDN format
        if (GetUserNameEx ( NameFullyQualifiedDN, wszGroup, &dwSize) == FALSE )
        {
            // GetUserNameEx() got failed due to small size specified for username.
            // allocate the actual size (dwSize) of username and call the same
            // function again...
            wszBuffer = (LPWSTR) AllocateMemory(dwSize * sizeof(WCHAR));
            if ( NULL == wszBuffer )
            {
                // display system error message with respect to GetLastError()
                ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                return EXIT_FAILURE;
            }

            if (GetUserNameEx ( NameFullyQualifiedDN, wszBuffer, &dwSize) == FALSE )
            {
                // display an error messaga as.. unable to get FQDN name
                // as logged-on user is not a domain user
                ShowMessage ( stderr, GetResString (IDS_ERROR_FQDN) );
                DestroyDynamicArray(&pColData);
                FreeMemory ((LPVOID*) &wszBuffer);
                return  EXIT_FAILURE ;
            }

            ShowMessage ( stdout, _X(wszBuffer));
            ShowMessage ( stdout, L"\n");
            FreeMemory ((LPVOID*) &wszBuffer);
            DestroyDynamicArray(&pColData);
            // return success
            return EXIT_SUCCESS;
        }

            ShowMessage ( stdout, _X(wszGroup));
            ShowMessage ( stdout, L"\n");
            DestroyDynamicArray(&pColData);
            // return success
            return EXIT_SUCCESS;

    }
    else if ( (UPN_FORMAT == dwNameFormat ) )
    {
        // get the user name in UPN format
        if ( GetUserNameEx ( NameUserPrincipal, wszGroup, &dwSize) == FALSE )
        {
            // GetUserNameEx() got failed due to small size specified for username
            // allocate the actual size(dwSize) of username and call the same
            // function again...
            wszBuffer = (LPWSTR) AllocateMemory(dwSize * sizeof(WCHAR));
            if ( NULL == wszBuffer )
            {
                // display system error message with respect to GetLastError()
                ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                return EXIT_FAILURE;
            }

            // get the user name in UPN format
            if ( GetUserNameEx ( NameUserPrincipal, wszBuffer, &dwSize) == FALSE )
            {
                // display an error messaga as.. unable to get UPN name
                // as logged-on user is not a domain user
                ShowMessage ( stderr, GetResString (IDS_ERROR_UPN) );
                // release memory
                DestroyDynamicArray(&pColData);
                FreeMemory ((LPVOID*) &wszBuffer);
                return  EXIT_FAILURE ;
            }

             // convert UPN name in lower case letters
            CharLower ( wszBuffer );

            // display UPN name
            ShowMessage ( stdout, _X(wszBuffer) );
            ShowMessage ( stdout, L"\n");
            // release memory
            DestroyDynamicArray(&pColData);
            FreeMemory ((LPVOID*) &wszBuffer);
            //return success
            return EXIT_SUCCESS;
        }

        // convert UPN name in lower case letters
        CharLower ( wszGroup );

        // display UPN name
        ShowMessage ( stdout, _X(wszGroup) );
        ShowMessage ( stdout, L"\n");

        DestroyDynamicArray(&pColData);
        //return success
        return EXIT_SUCCESS;
    }


   // get user name
   if ( (dwErr = GetAccountName ( wszUserName, &dwSidUse)) != EXIT_SUCCESS ){
       // display an error message with respect to Win32 error code
       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
       DestroyDynamicArray(&pColData);
       return dwErr ;
    }

    // convery user name in lower case letters
    CharLower ( wszUserName );

    // if /USER specified
    if ( USER_ONLY != dwNameFormat)
    {
        // display SID with respect to username
        if ( (dwErr = DisplaySid ( wszSid ) ) != EXIT_SUCCESS ){
            DestroyDynamicArray(&pColData);
            return dwErr ;
        }
    }

    // get the length of user name
    dwUserLen = StringLengthInBytes (wszUserName);
    // get the length of SID
    dwSidLen = StringLengthInBytes (wszSid);

    //
    //To avoid localization problems, get the maximum length of column name and
    // values of respective columns 
    //

    // Get the maximum length of a column name "UserName"  
    dwUserColLen = StringLengthInBytes( GetResString(IDS_COL_USERNAME) );
    if ( dwUserColLen > dwUserLen )
    {
      dwUserLen = dwUserColLen;
    }

    // Get the maximum length of a column name "SID"  
    dwSidColLen = StringLengthInBytes( GetResString(IDS_COL_SID) );
    if ( dwSidColLen > dwSidLen )
    {
      dwSidLen = dwSidColLen;
    }

    // defining verbose columns with the actual size
    TCOLUMNS pVerboseCols[] =
    {
        {L"\0",dwUserLen, SR_TYPE_STRING, COL_FORMAT_STRING, NULL, NULL},
        {L"\0",dwSidLen,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL}
    };

    // if /USER is specified
    if ( USER_ONLY == dwNameFormat )
    {
        // display the user name
        StringCopy (pVerboseCols[dw].szColumn , GetResString(IDS_COL_USERNAME), MAX_RES_STRING);
        ShowMessage ( stdout, _X(wszUserName) );
        ShowMessage ( stdout, L"\n");

        // release memory
        DestroyDynamicArray(&pColData);

        return EXIT_SUCCESS;
    }
    else
    {
        //Load the column names for verbose mode
     for( dwColCount = IDS_COL_USERNAME , dw = 0 ; dwColCount <= IDS_COL_SID;
         dwColCount++, dw++)
         {
            StringCopy(pVerboseCols[dw].szColumn , GetResString(dwColCount), MAX_RES_STRING );
         }

         // get the number of columns
         dwArrSize = SIZE_OF_ARRAY( pVerboseCols );
    }

    //Start appending to the 2D array
    DynArrayAppendRow(pColData, dwArrSize);

    //Insert the user name
    DynArraySetString2(pColData, dwCount, USERNAME_COL_NUMBER, _X(wszUserName), 0);

    //Insert the SID string
    DynArraySetString2(pColData, dwCount, SID_COL_NUMBER, _X(wszSid), 0);

    // 1) If the display format is CSV.. then we should not display column headings..
    // 2) If /NH is specified ...then we should not display column headings..
    if ( !(( SR_FORMAT_CSV == dwFormatType ) || ((dwFormatType & SR_HIDECOLUMN) == SR_HIDECOLUMN))) 
    {
        // display the headings before displaying the username and SID
        ShowMessage ( stdout, L"\n" );
        ShowMessage ( stdout, GetResString ( IDS_LIST_USER_NAMES ) );
        ShowMessage ( stdout, GetResString ( IDS_DISPLAY_USER_DASH ) );
    }

     // display the actual values for user name and SID
     ShowResults(dwArrSize, pVerboseCols, dwFormatType, pColData);

    // release memory
    DestroyDynamicArray(&pColData);
    // return success
    return EXIT_SUCCESS;
}



DWORD
WsSid::DisplayGroupName ( OUT LPWSTR wszGroupName,
                          OUT LPWSTR wszGroupSid,
                          IN DWORD *dwSidUseName)
/*++
   Routine Description:
    This function gets the group name and SID to display.

   Arguments:
        [OUT] LPWSTR wszGroupName  : Stores group name
        [OUT] LPWSTR wszGroupSid   : Stores group SID
        [IN] DWORD dwSidUseName   : stores Sid use name

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{
    // sub-local variables
   DWORD       dwErr = 0 ;
   DWORD       dwSidUse = 0;

    // display the user name
   if ( (dwErr = GetAccountName ( wszGroupName, &dwSidUse) ) != EXIT_SUCCESS ){
       // display an error message with respect to Win32 error code
       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
       return dwErr ;
   }

    // display SID
    if ( (dwErr = DisplaySid ( wszGroupSid ) ) != EXIT_SUCCESS ){
           return dwErr ;
    }

    *dwSidUseName = dwSidUse;

    // return success
    return EXIT_SUCCESS;
}


DWORD
WsSid::DisplaySid (
                    OUT LPWSTR wszSid
                   )
/*++
   Routine Description:
    This function gets the SID .

   Arguments:
        [OUT] LPWSTR wszSid  : Stores SID string

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

    // sub-local variable
   DWORD       dwErr = 0 ;

    // Get SID string
   if ( (dwErr = GetSidString (wszSid)) != EXIT_SUCCESS )
    {
      return dwErr ;
    }

   // return success
   return EXIT_SUCCESS;

}



DWORD
WsSid::GetAccountName (
                        OUT LPWSTR wszAccountName,
                        OUT DWORD *dwSidType
                        )
/*++
   Routine Description:
    This function gets the account name and SID

   Arguments:
        [OUT] szAccountName  : Stores user name
        [OUT] dwSidType  : Stores Sid use name

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

   // sub-local variables
   SID_NAME_USE   SidUse ;

   WCHAR      wszUserName[ MAX_RES_STRING ];
   WCHAR      wszDomainName [ MAX_RES_STRING ];
   DWORD          dwUserLen = 0;
   DWORD          dwDomainLen = 0;
   BOOL      bNotResolved = FALSE;

   // initialize the variables
   SecureZeroMemory ( wszUserName, SIZE_OF_ARRAY(wszUserName) );
   SecureZeroMemory ( wszDomainName, SIZE_OF_ARRAY(wszDomainName) );

   // get the length of user name and group name
   dwUserLen = SIZE_OF_ARRAY ( wszUserName );
   dwDomainLen = SIZE_OF_ARRAY ( wszDomainName );

   // enable debug privileges
   if ( FALSE == EnableDebugPriv() )
   {
       // return WIN32 error code
       return GetLastError () ;
   }

    // get user name and domain name with respective to SID
   if ( FALSE == LookupAccountSid (  NULL,    // Local System
                              pSid,
                              wszUserName,
                              &dwUserLen,
                              wszDomainName,
                              &dwDomainLen,
                              &SidUse ) ){
      if ( 0 == StringLength (wszUserName, 0))
      {
         bNotResolved = TRUE;
		 StringCopy ( wszAccountName, L"   ", MAX_RES_STRING );
      }
	  else if ( ( 0 != StringLength (wszDomainName, 0) ) && ( 0 != StringLength (wszUserName, 0) ) ) {
            // return WIN32 error code
            return GetLastError () ;
      }

   }

 if ( FALSE == bNotResolved)
 {
    // check for empty domain name
   if ( 0 != StringLength ( wszDomainName, 0 ) ) {
      StringCopy ( wszAccountName, wszDomainName, MAX_RES_STRING );
      StringConcat ( wszAccountName, SLASH , MAX_RES_STRING);
      StringConcat ( wszAccountName, wszUserName, MAX_RES_STRING );
    }
   else {
        StringCopy ( wszAccountName, wszUserName, MAX_RES_STRING );
   }
 }

   *dwSidType = (DWORD)SidUse;

   // return success
   return EXIT_SUCCESS ;
}


DWORD
WsSid::GetSidString (
                        OUT LPWSTR wszSid
                     )
/*++
   Routine Description:
    This function gets the SID string.

   Arguments:
        [OUT] LPWSTR wszSid  : Stores SID string

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

    // sub-local variables
   PSID_IDENTIFIER_AUTHORITY  Auth ;
   PUCHAR                     lpNbSubAuth ;
   LPDWORD                    lpSubAuth = 0 ;
   UCHAR                      uloop ;
   WCHAR                     wszTmp[MAX_RES_STRING] ;
   WCHAR                     wszStr[ MAX_RES_STRING ] ;

   // initialize the variables
   SecureZeroMemory ( wszTmp, SIZE_OF_ARRAY(wszTmp) );
   SecureZeroMemory ( wszStr, SIZE_OF_ARRAY(wszStr) );

   //check for empty
   if ( NULL == pSid )
    {
        return EXIT_FAILURE ;
    }

   //Is it a valid SID
   if ( FALSE ==  IsValidSid ( pSid ) ) {
      ShowMessage ( stderr, GetResString ( IDS_INVALID_SID ) );
      return EXIT_FAILURE ;
   }

   //Add the revision
   StringCopy ( wszStr, SID_STRING, MAX_RES_STRING );

   //Get identifier authority
   Auth = GetSidIdentifierAuthority ( pSid ) ;

   if ( NULL == Auth )
   {
       // return WIN32 error code
       return GetLastError () ;
   }

    // format authority value
   if ( (Auth->Value[0] != 0) || (Auth->Value[1] != 0) ) {
      StringCchPrintf ( wszTmp, SIZE_OF_ARRAY(wszTmp), AUTH_FORMAT_STR1 ,
                 (ULONG)Auth->Value[0],
                 (ULONG)Auth->Value[1],
                 (ULONG)Auth->Value[2],
                 (ULONG)Auth->Value[3],
                 (ULONG)Auth->Value[4],
                 (ULONG)Auth->Value[5] );
    }
    else {
      StringCchPrintf ( wszTmp, SIZE_OF_ARRAY(wszTmp), AUTH_FORMAT_STR2 ,
                 (ULONG)(Auth->Value[5]      )   +
                 (ULONG)(Auth->Value[4] <<  8)   +
                 (ULONG)(Auth->Value[3] << 16)   +
                 (ULONG)(Auth->Value[2] << 24)   );
    }

   StringConcat (wszStr, DASH , SIZE_OF_ARRAY(wszStr));
   StringConcat (wszStr, wszTmp, SIZE_OF_ARRAY(wszStr));

   //Get sub authorities
   lpNbSubAuth = GetSidSubAuthorityCount ( pSid ) ;

   if ( NULL == lpNbSubAuth )
   {
       return GetLastError () ;
   }

   // loop through and get sub authority
   for ( uloop = 0 ; uloop < *lpNbSubAuth ; uloop++ ) {
      lpSubAuth = GetSidSubAuthority ( pSid,(DWORD)uloop ) ;
       if ( NULL == lpSubAuth )
       {
         return GetLastError () ;
       }

      // convert long integer to a string
      _ultot (*lpSubAuth, wszTmp, BASE_TEN) ;
      StringConcat ( wszStr, DASH, SIZE_OF_ARRAY(wszStr) ) ;
      StringConcat (wszStr, wszTmp, SIZE_OF_ARRAY(wszStr) ) ;
   }

   StringCopy ( wszSid, wszStr, MAX_RES_STRING );

   // retunr success
   return EXIT_SUCCESS ;
}


DWORD
WsSid::Init (
                OUT PSID pOtherSid
            )
/*++
   Routine Description:
    This function Initializes the SID

   Arguments:
        [OUT] PSID pOtherSid  : Stores SID string

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

   // sub-local variable
   DWORD    dwSize ;

   // get the length of SID
   dwSize      = GetLengthSid ( pOtherSid ) ;

   // allocate the memory with the actual size
   pSid        = (PSID) AllocateMemory ( dwSize ) ;
   if ( NULL == pSid )
   {
        // return WIN32 error code
        return GetLastError () ;
   }

   bToBeFreed  = TRUE ;

   // copy SID
   if ( FALSE == CopySid ( dwSize, pSid, pOtherSid ) ){
       return GetLastError () ;
   }

   // return success
   return EXIT_SUCCESS ;
}

BOOL
WsSid::EnableDebugPriv()
/*++
   Routine Description:
        Enables the debug privliges for the current process so that
        this utility can terminate the processes on local system without any problem

   Arguments:
        NONE

   Return Value:
         TRUE upon successfull and FALSE if failed
--*/
{
    // local variables
    LUID luidValue;
    BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;

    // Retrieve a handle of the access token
    bResult = OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_QUERY, &hToken );
    if ( bResult == FALSE )
    {
        // save the error messaage and return
        SaveLastError();
        return FALSE;
    }

    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depends on this flag.
    bResult = LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &luidValue );
    if ( bResult == FALSE )
    {
        // save the error messaage and return
        SaveLastError();
        CloseHandle( hToken );
        return FALSE;
    }

    // prepare the token privileges structure
    tkp.PrivilegeCount = 1;
    tkp.Privileges[ 0 ].Luid = luidValue;
    tkp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;

    // now enable the debug privileges in the token
    bResult = AdjustTokenPrivileges( hToken, FALSE, &tkp, sizeof( TOKEN_PRIVILEGES ),
        ( PTOKEN_PRIVILEGES ) NULL, ( PDWORD ) NULL );
    if ( bResult == FALSE )
    {
        // The return value of AdjustTokenPrivileges be texted
        SaveLastError();
        CloseHandle( hToken );
        return FALSE;
    }

    // close the opened handle object
    CloseHandle( hToken );

    // enabled ... inform success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wstoken.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wstoken.cpp

Abstract:

     This file intializes the members and methods of WsAccessToken class.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by  Wipro Technologies.

--*/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


WsAccessToken::WsAccessToken()
/*++
   Routine Description:
    This function intializes the members of WsAccessToken class.

   Arguments:
        None
   Return Value:
        None
--*/
{
    // intialize the variables
    hToken = NULL ;

    dwDomainAttributes = NULL;

}



WsAccessToken::~WsAccessToken()
/*++
   Routine Description:
    This function deallocates the members of WsAccessToken class.

   Arguments:
     None
  Return Value:
     None
--*/
{
    // release handle
    if(hToken){
        CloseHandle ( hToken ) ;
    }

    if (dwDomainAttributes)
    {
       FreeMemory ((LPVOID *) &dwDomainAttributes) ;
    }
}


DWORD
WsAccessToken::InitGroups(
                           OUT WsSid ***lppGroupsSid,
                           OUT WsSid **lppLogonId,
                           OUT DWORD *lpnbGroups
                          )
/*++
   Routine Description:
    This function retrieves and build groups SIDs array.

   Arguments:

        [OUT] lppGroupsSid     : Stores group SID
        [OUT] lppLogonId       : Stores logon ID
        [OUT] lpnbGroups       : Stores the number of groups

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{
    // sub-local variables
    TOKEN_GROUPS      *lpTokenGroups ;
    DWORD             dwTokenGroups = 0;
    DWORD             dwGroup = 0 ;
    WORD              wloop = 0 ;
    BOOL              bTokenInfo = FALSE;

    // Get groups size
    bTokenInfo = GetTokenInformation(hToken, TokenGroups, NULL, 0, &dwTokenGroups);
    // if required buffer size is zero...
    // So we assume that there are no groups present in the system
    if ( 0 == dwTokenGroups )
    {
         // return WIN32 error code
         return GetLastError () ;
    }

    // Allocate memory for the groups
    lpTokenGroups = ( TOKEN_GROUPS * ) AllocateMemory( dwTokenGroups );
    if ( NULL == lpTokenGroups )
    {
         // release memory
         FreeMemory ((LPVOID *) &lpTokenGroups) ;
         // return WIN32 error code
         return ERROR_NOT_ENOUGH_MEMORY ;
    }

    // Get the group names
    bTokenInfo = GetTokenInformation ( hToken, TokenGroups, lpTokenGroups, dwTokenGroups, &dwTokenGroups );
    if ( FALSE == bTokenInfo )
    {
        FreeMemory ((LPVOID *) &lpTokenGroups) ;
        return GetLastError () ;
    }

    //Build objects
    *lpnbGroups  = (WORD) lpTokenGroups->GroupCount  ;

    // check for logonid
    if(IsLogonId ( lpTokenGroups )){
        (*lpnbGroups)-- ;
    }
    else{
        *lppLogonId = NULL ;
    }

    // Allocate memory with the actual size
    *lppGroupsSid  = (WsSid **) AllocateMemory ( *lpnbGroups * sizeof(WsSid**) ) ;
    if ( NULL == *lppGroupsSid )
    {
         FreeMemory ((LPVOID *) &lpTokenGroups) ;
         return ERROR_NOT_ENOUGH_MEMORY ;
    }

    // Get SID with respect to the group names
    for( wloop = 0 ; wloop < *lpnbGroups ; wloop++ ){
        (*lppGroupsSid)[wloop] = new WsSid () ;
        if ( NULL == (*lppGroupsSid)[wloop] )
        {
             // release memory
             FreeMemory ((LPVOID *) &lpTokenGroups) ;
             // return WIN32 error code
             return GetLastError () ;
        }
    }


    //Allocate memory for attributes
    dwDomainAttributes = (DWORD*) AllocateMemory ( (lpTokenGroups->GroupCount * sizeof(DWORD)) + 10) ;    
    if ( 0 == dwDomainAttributes )
    {
         FreeMemory ((LPVOID *) &lpTokenGroups) ;
         return ERROR_NOT_ENOUGH_MEMORY ;
    }


    //Loop within groups
    for(wloop = 0 , dwGroup = 0;
        dwGroup < lpTokenGroups->GroupCount ;
        dwGroup++) {
        // store the domain attributes
        dwDomainAttributes[dwGroup] = lpTokenGroups->Groups[dwGroup].Attributes;

        //check whether SID is a logon SID
        if(lpTokenGroups->Groups[dwGroup].Attributes & SE_GROUP_LOGON_ID) {
            *lppLogonId = new WsSid () ;
            if ( NULL == *lppLogonId )
            {
                // release memory
                FreeMemory ((LPVOID *) &lpTokenGroups) ;
                // return WIN32 error code
                return GetLastError () ;
            }

            (*lppLogonId)->Init ( lpTokenGroups->Groups[dwGroup].Sid ) ;
        }
        else {
            (*lppGroupsSid)[wloop++]->Init(lpTokenGroups->Groups[dwGroup].Sid);
        }
    }

    dwDomainAttributes[dwGroup] = 0;

    //release memory
    FreeMemory ((LPVOID *) &lpTokenGroups) ;

    // return success
    return EXIT_SUCCESS ;
}


DWORD
WsAccessToken::InitPrivs (
                           OUT WsPrivilege ***lppPriv,
                           OUT DWORD *lpnbPriv
                           )
/*++
   Routine Description:
    This function retrieves and build privileges array.

   Arguments:
        [OUT] lppPriv     : Stores the privileges array
        [OUT] lpnbPriv    : Stores the number of privileges

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

    //sub-local variables
    DWORD                dwTokenPriv = 0;
    TOKEN_PRIVILEGES     *lpTokenPriv ;
    WORD                 wloop = 0 ;
    BOOL                 bTokenInfo = FALSE;

    // Get the privileges size
    bTokenInfo = GetTokenInformation(hToken,TokenPrivileges, NULL, 0, &dwTokenPriv);
    // if required buffer size is zero...
    // So we assume that there are no privileges present in the system
    if( 0 == dwTokenPriv )
    {
        // return WIN32 error code
        return GetLastError () ;
    }

    // allocate memory with actual size
    lpTokenPriv = (TOKEN_PRIVILEGES *) AllocateMemory ( dwTokenPriv ) ;
    if ( NULL == lpTokenPriv)
    {
        // return WIN32 error code
        return ERROR_NOT_ENOUGH_MEMORY ;
    }

    //Allocate memory for the privileges
    bTokenInfo = GetTokenInformation ( hToken, TokenPrivileges, lpTokenPriv, dwTokenPriv, &dwTokenPriv);
    if( FALSE == bTokenInfo )
    {
        // release memory
        FreeMemory ((LPVOID *) &lpTokenPriv) ;
        // return WIN32 error code
        return GetLastError () ;
    }

    //Get privilege count
    *lpnbPriv   = (DWORD) lpTokenPriv->PrivilegeCount  ;

    // allocate memory with the privilege count
    *lppPriv    = (WsPrivilege **) AllocateMemory( *lpnbPriv * sizeof(WsPrivilege**) );

    if ( NULL == *lppPriv )
    {
        // release memory
        FreeMemory ((LPVOID *) &lpTokenPriv) ;
        // retrun WIN 32 error code
        return ERROR_NOT_ENOUGH_MEMORY ;
    }

    //Loop through the privileges to display their name
    for( wloop = 0 ; wloop < (WORD) lpTokenPriv->PrivilegeCount ; wloop++) {
        (*lppPriv)[wloop] = new WsPrivilege ( &lpTokenPriv->Privileges[wloop] ) ;

        if ( NULL == (*lppPriv)[wloop] )
        {
            // release memory
            FreeMemory ((LPVOID *) &lpTokenPriv) ;
            // retrun WIN 32 error code
            return GetLastError () ;
        }
    }

    // release memory
    FreeMemory ((LPVOID *) &lpTokenPriv) ;

    // return success
    return EXIT_SUCCESS ;
}


DWORD
WsAccessToken::InitUserSid (
                            OUT WsSid *lpSid
                            )
/*++
   Routine Description:
    This function initializes the user name and SID.

   Arguments:
        [OUT] lpSid     : Stores the SID

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

    // sub-local varibles
    DWORD          dwUser = 0 ;
    TOKEN_USER     *lpUser ;
    BOOL           bTokenInfo = FALSE;
    DWORD          dwRetVal = 0;

    // Get User name size
    bTokenInfo = GetTokenInformation ( hToken, TokenUser, NULL, 0, &dwUser);
    // if required buffer size is zero...
    if( 0 == dwUser )
    {
        // return WIN32 error code
        return GetLastError () ;
    }

    // allocate memory with the actual size
    lpUser = (TOKEN_USER *) AllocateMemory ( dwUser ) ;
    if ( NULL == lpUser )
    {
         // return WIN32 error code
         return ERROR_NOT_ENOUGH_MEMORY ;
    }

    // Get the information of Logged-on user and SID
    bTokenInfo = GetTokenInformation ( hToken, TokenUser, lpUser, dwUser, &dwUser );
    if( FALSE == bTokenInfo )
    {
        FreeMemory ((LPVOID *) &lpUser) ;
        // return WIN32 error code
        return GetLastError () ;
    }

    dwRetVal = lpSid->Init ( lpUser->User.Sid );

    // release memory
    FreeMemory ((LPVOID *) &lpUser) ;

    // return SID
    return dwRetVal ;
}



BOOL
WsAccessToken::IsLogonId (
                            OUT TOKEN_GROUPS *lpTokenGroups
                        )
/*++
   Routine Description:
    This function checks whether logon id is present or not.

   Arguments:
        [OUT] lpTokenGroups     : Stores the token groups

   Return Value:
         TRUE :   On success
         FALSE :   On failure
--*/
{

    //sub-local variables
    DWORD    dwGroup = 0;

    // Loop through and check whether the SID is a logon SID
    for(dwGroup = 0; dwGroup < lpTokenGroups->GroupCount ; dwGroup++) {
        if(lpTokenGroups->Groups[dwGroup].Attributes & SE_GROUP_LOGON_ID){
            // return 0
            return TRUE ;
        }
    }

    // return 1
    return FALSE ;
}



DWORD
WsAccessToken::Open ( VOID )
/*++
   Routine Description:
    This function opens the current access token.

   Arguments:
        None

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

    // Open current process token
    if( FALSE == OpenProcessToken ( GetCurrentProcess(),
                            TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                            &hToken )){
        //return WIN32 error code
        return GetLastError () ;
    }

    // return success
    return EXIT_SUCCESS ;
}

VOID
WsAccessToken::GetDomainAttributes(
                                    IN DWORD dwAttributes,
                                    OUT LPWSTR szDmAttrib,
                                    IN DWORD dwSize
                                )
/*++
   Routine Description:
    Gets the domain attribute names

   Arguments:
        [IN] dwAttributes     : attibute value
        [OUT] szDomainAttrib     : attibute value

   Return Value:
         TRUE :   On success
         FALSE :   On failure
--*/
{
    WCHAR szDomainAttrib [2 * MAX_STRING_LENGTH] ;
    BOOL  bFlag = FALSE;
    
   // initialize the variables
   SecureZeroMemory ( szDomainAttrib, SIZE_OF_ARRAY(szDomainAttrib) );

    //Mandatory group
    if( SE_GROUP_MANDATORY & dwAttributes )
    {
        StringConcat (szDomainAttrib, GetResString(IDS_ATTRIB_MANDATORY), SIZE_OF_ARRAY(szDomainAttrib));
        bFlag = TRUE;
    }

    // Enabled by default
    if( SE_GROUP_ENABLED_BY_DEFAULT & dwAttributes )
    {
        if ( TRUE == bFlag )
        {
            StringConcat (szDomainAttrib, L", ", SIZE_OF_ARRAY(szDomainAttrib));
        }
        StringConcat (szDomainAttrib, GetResString(IDS_ATTRIB_BYDEFAULT), SIZE_OF_ARRAY(szDomainAttrib));
        bFlag = TRUE;
    }

    //Enabled group
    if( SE_GROUP_ENABLED & dwAttributes )
    {
        if ( TRUE == bFlag )
        {
            StringConcat (szDomainAttrib, L", ", SIZE_OF_ARRAY(szDomainAttrib));
        }
        StringConcat (szDomainAttrib, GetResString(IDS_ATTRIB_ENABLED), SIZE_OF_ARRAY(szDomainAttrib));
        bFlag = TRUE;
    }

    //Group owner
    if( SE_GROUP_OWNER & dwAttributes )
    {
        if ( TRUE == bFlag )
        {
            StringConcat (szDomainAttrib, L", ", SIZE_OF_ARRAY(szDomainAttrib));
        }
        StringConcat (szDomainAttrib, GetResString(IDS_ATTRIB_OWNER), SIZE_OF_ARRAY(szDomainAttrib));
        bFlag = TRUE;
    }

    //Group use for deny only
    if( SE_GROUP_USE_FOR_DENY_ONLY & dwAttributes )
    {
        if ( TRUE == bFlag )
        {
            StringConcat (szDomainAttrib, L", ", SIZE_OF_ARRAY(szDomainAttrib));
        }
        StringConcat (szDomainAttrib, GetResString(IDS_ATTRIB_USEFORDENY), SIZE_OF_ARRAY(szDomainAttrib));
        bFlag = TRUE;
    }

    //local group
    if( SE_GROUP_RESOURCE & dwAttributes )
    {
        if ( TRUE == bFlag )
        {
            StringConcat (szDomainAttrib, L", ", SIZE_OF_ARRAY(szDomainAttrib));
        }

        StringConcat (szDomainAttrib, GetResString(IDS_ATTRIB_LOCAL), SIZE_OF_ARRAY(szDomainAttrib));
        bFlag = TRUE;
    }

    // Copy domain attrinutes
    StringCopy ( szDmAttrib, szDomainAttrib, dwSize );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wsuser.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wsuser.h

Abstract:

    This module contains the macros, user defined structures & function
    definitions needed by whoami.cpp, wsuser.cpp, wssid.cpp and
    wspriv.cppfiles.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by  Wipro Technologies.

--*/

#ifndef WSUSER_H
#define WSUSER_H

#include "wspriv.h"
#include "wssid.h"
#include "wstoken.h"


class WsUser {
protected:
    WsAccessToken        wToken ;       // The token
    WsPrivilege          **lpPriv ;     // Privileges
    WsSid                wUserSid ;     // User SID
    WsSid                *lpLogonId ;   // Logon ID
    WsSid                **lpwGroups ;  // The groups
    DWORD                dwnbGroups ;     // nb of groups
    DWORD                dwnbPriv ;       // nb of privileges

 public:
    WsUser                              ( VOID ) ;
    ~WsUser                             ( VOID ) ;
    DWORD             Init              ( VOID ) ;

    DWORD             DisplayLogonId    () ;

    DWORD             DisplayUser       ( IN DWORD dwFormat,
                                          IN DWORD dwNameFormat) ;

    DWORD             DisplayGroups     ( IN DWORD dwFormat ) ;

    DWORD             DisplayPrivileges ( IN DWORD dwFormat ) ;
    VOID              GetDomainType ( IN  DWORD NameUse, 
                                      OUT LPWSTR szSidNameUse,
                                      IN DWORD dwSize ) ;

} ;

//width constants for the fields

#define PRIVNAME_COL_NUMBER         0
#define PRIVDESC_COL_NUMBER         1
#define PRIVSTATE_COL_NUMBER        2

#define WIDTH_LOGONID               77

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\account.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        account.cxx
//
// Contents:    Class wrapping account sid and name
//
// Classes:     CAccount
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include "pch.h"
#include "account.hxx"
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::CAccount, public
//
//  Synopsis:   initializes data members
//
//  Arguments:  IN [Name]   - principal
//              IN [System] - server/domain
//
//----------------------------------------------------------------------------
CAccount::CAccount(WCHAR *Name, WCHAR *System)
    : _name(Name),
      _system(System),
      _domain(NULL),
      _psid(NULL),
      _fsid(TRUE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::CAccount, public
//
//  Synopsis:   Initializes data members
//
//  Arguments:  IN [pSid]   - SID of principal
//              IN [System] - server/domain
//
//----------------------------------------------------------------------------
CAccount::CAccount(SID *pSid, WCHAR *System)
    : _name(NULL),
      _system(System),
      _domain(NULL),
      _psid(pSid),
      _fsid(FALSE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees sid or name and domain
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAccount::~CAccount()
{
    if (_fsid)
    {
        if (_psid)
        {
            LocalFree(_psid);
        }
    } 
	
/*	if (_name)
    {
        LocalFree(_name);
    }
 */   
	if (_domain)
	{
        LocalFree(_domain);
	}
	
	if (_system)
    {
        LocalFree(_system);
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountName, public
//
//  Synopsis:   returns the Name associated with the instance of the class
//
//  Arguments:  OUT [name] address of the principal name
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountName(WCHAR **name)
{

    ULONG ret = ERROR_SUCCESS;

    if (_name == NULL)
    {
        DWORD can = 0, crd = 0;
        SID_NAME_USE esnu;

        if (!LookupAccountSid( NULL,
                               _psid,
                               NULL,
                               &can,
                               NULL,
                               &crd,
                               &esnu))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
            {
                ret = ERROR_SUCCESS;
                if (NULL == (_name = (LPWSTR)LocalAlloc(LMEM_FIXED, can * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                if (NULL == (_domain = (LPWSTR)LocalAlloc(LMEM_FIXED, crd * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if ( !LookupAccountSid( NULL,
                                       _psid,
                                       (LPTSTR)_name,
                                       &can,
                                       (LPTSTR)_domain,
                                       &crd,
                                       &esnu) )
                {
                   ret = GetLastError();
                }
            }
        }
     }
     *name = _name;
     return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountSid, public
//
//  Synopsis:   returns the Sid
//
//  Arguments:  OUT [psid] - sid associated with instance of the class
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountSid(SID **psid)
{

    ULONG ret = ERROR_SUCCESS;

    if (_psid == NULL && _name != NULL)
    {
        DWORD cusid = 0, crd = 0;
        SID_NAME_USE esnu;

	    if (!LookupAccountName( (LPCTSTR)_system,
                                (LPCTSTR)_name,
                               NULL,
                               &cusid,
                               NULL,
                               &crd,
                               &esnu))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
            {

                ret = ERROR_SUCCESS;
                if (NULL == (_psid = (SID *)LocalAlloc(LMEM_FIXED, cusid)))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                if (NULL == (_domain = (LPWSTR)LocalAlloc(LMEM_FIXED, crd * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if ( !LookupAccountName( (LPCTSTR)_system,
                                         (LPCTSTR)_name,
                                         _psid,
                                         &cusid,
                                         (LPTSTR)_domain,
                                         &crd,
                                         &esnu) )

                {
                   ret = GetLastError();
                }
            }
        }
     }
     *psid = _psid;
     return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountDomain, public
//
//  Synopsis:   returns the domain for the class
//
//  Arguments:  [domain] - returns the domain associated with the instance of
//                         the class
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountDomain(LPWSTR *domain)
{
    ULONG ret = ERROR_SUCCESS;

    if (_domain == NULL)
    {
        if (_fsid)
        {
            SID *psid;
            ret = GetAccountSid(&psid);
        } else
        {
            LPWSTR name = NULL;
            ret = GetAccountName(&name);
        }
    }
    *domain = _domain;
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\accacc.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        accacc.cxx
//
// Classes:     CAccountAccess
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include "pch.h"
#include "accacc.hxx"
#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::CAccountAccess, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  IN - [Name]   - principal
//              IN - [System] - server/domain
//
//----------------------------------------------------------------------------
CAccountAccess::CAccountAccess(LPWSTR Name, LPWSTR System)
    : _mask(0),
      _savemask(0),
      _foundinheritance(0),
      _acetype(0xff),
      CAccount(Name, System)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Init, public
//
//  Synopsis:   initializes access mask
//
//  Arguments:  IN [access]  - access mask
//              IN [dirmask] - access mask for directories
//              IN [filespecified] - TRUE if no ACE for files should be written
//
//----------------------------------------------------------------------------
ULONG CAccountAccess::Init(ULONG access, ULONG dirmask, BOOL filespecified)
{
    if (access == 0)
    {
        _savemask = GENERIC_ALL;
        _mask = GENERIC_ALL;
		_dirmask = GENERIC_ALL;
        _acetype = ACCESS_DENIED_ACE_TYPE;
		_filespecified = FALSE;
    } else
    {
        _acetype = ACCESS_ALLOWED_ACE_TYPE;
        _savemask = access;
        _mask = access;
		_dirmask = dirmask;
		_filespecified = filespecified;
    }
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::AddInheritance, public
//
//  Synopsis:   accumulates inheritance of ACEs with matching SIDS
//
//  Arguments:  inheritance flags
//
//--------------------------------------------------------------------
void CAccountAccess::AddInheritance(BYTE Flags)
{
    if (!(Flags & NO_PROPAGATE_INHERIT_ACE))
    {
        if (Flags & INHERIT_ONLY_ACE)
        {
            if (Flags & CONTAINER_INHERIT_ACE)
                _foundinheritance |= CONTAINER_INHERIT_ACE;
            if (Flags & OBJECT_INHERIT_ACE)
                _foundinheritance |= OBJECT_INHERIT_ACE;
        } else
        {
           _foundinheritance |= APPLIES_TO_CONTAINER;
           if (Flags & CONTAINER_INHERIT_ACE)
              _foundinheritance |= CONTAINER_INHERIT_ACE;
           if (Flags & OBJECT_INHERIT_ACE)
              _foundinheritance |= OBJECT_INHERIT_ACE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\daclwrap.cxx ===
//+-------------------------------------------------------------------
//
//  File:        daclwrap.cxx
//
//  Contents:    class encapsulating file security.
//
//  Classes:     CDaclWrap
//
//  History:     Nov-93        Created         DaveMont
//               Oct-96        Modified        BrunoSc
//
//--------------------------------------------------------------------
#include "pch.h"
#include "t2.hxx"
#include "daclwrap.hxx"
#include "caclsmsg.h"
ULONG  printmessage (FILE* fp, DWORD messageID, ...);


#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap::CDaclWrap, public
//
//  Synopsis:   initialize data members, constructor will not throw
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDaclWrap::CDaclWrap()
      : _ccaa(0)
{
	_powner = NULL;
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   cleanup allocated data
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDaclWrap::~CDaclWrap()
{
    for (ULONG j = 0; j < _ccaa; j++)
        delete _aaa[j].pcaa;

	if (_powner) FreeSid( _powner );
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap::SetAccess, public
//
//  Synopsis:   caches data for a new ACE
//
//  Arguments:  IN [option]   - rePlace, Revoke, Grant, Deny
//              IN [Name]     - principal (username)
//              IN [System]   - server/machine where Name is defined
//              IN [access]   - access mode (Read Change None All)
//              IN [dirmask]  - access mode for directory (same as access)
//              IN [filespec] - if TRUE, no ACE for files will be written
//                              (for directories only)
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::SetAccess(ULONG option, LPWSTR Name, LPWSTR System, ULONG access, ULONG dirmask, BOOL filespec)
{
    ULONG ret;

    // static number of ACCESSes can be set at one time

    if (_ccaa >= CMAXACES)
        return(ERROR_BUFFER_OVERFLOW);

    // allocate a new account access class

    if (NULL == (_aaa[_ccaa].pcaa = new CAccountAccess(Name, System)))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    _aaa[_ccaa].option = option;

    SID *psid;

    if (ERROR_SUCCESS == ( ret = _aaa[_ccaa].pcaa->Init(access, dirmask, filespec))) // reads file security
    {
        // get the sid to make sure the username is valid

        if (ERROR_SUCCESS == ( ret =_aaa[_ccaa].pcaa->Sid(&psid)))
        {
            // loop thru the existing sids, making sure the new one is not a duplicate

            SID *poldsid;
            for (ULONG check = 0;check < _ccaa ; check++)
            {
                if (ERROR_SUCCESS == ( ret =_aaa[check].pcaa->Sid(&poldsid)))
                {
                    if (EqualSid(psid,poldsid))
                    {
                        VERBOSE((stderr, L"SetAccess found matching new sids\n"))
                        //NTRAID#NTBUG9-552419-2002/03/20-hiteshr
                        delete _aaa[_ccaa].pcaa;
                        return(ERROR_BAD_ARGUMENTS);
                    }
                }
            }
            _ccaa++;
        }
        else
        {
            //NTRAID#NTBUG9-552419-2002/03/20-hiteshr
            delete _aaa[_ccaa].pcaa;
        }
    }
    else
    {
        //NTRAID#NTBUG9-552419-2002/03/20-hiteshr
        delete _aaa[_ccaa].pcaa;
    }
    return(ret);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:BuildAcl, public
//
//  Synopsis:   merges cached new aces with the input ACL
//
//  Arguments:  OUT [pnewdacl] - Address of new ACL to build
//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN  [revision] - ACL revision
//              IN  [fdir]     - True = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::BuildAcl(ACL **pnewdacl, ACL *poldacl, WCHAR revision, BOOL fdir)
{
    ULONG ret, caclsize;

    // get the size of the new ACL we are going to create

    if (ERROR_SUCCESS == (ret =  _GetNewAclSize(&caclsize, poldacl, fdir)))
    {
        // allocate the new ACL

        if (ERROR_SUCCESS == (ret =  _AllocateNewAcl(pnewdacl, caclsize, revision)))
        {
            // and fill it up

            if (ERROR_SUCCESS != (ret =  _FillNewAcl(*pnewdacl, poldacl, fdir)))
            {
                // free the buffer if we failed

                LocalFree(*pnewdacl);
            }

        }
    }
    return(ret);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_GetNewAclSize, private
//
//  Synopsis:   returns the size need to merge the new ACEs with the old ACL,
//              this is an ugly algorithm:
//              (with integration of different rights for directory and files
//               much more uglier!!    BSC )
//
//	legend:     a combined ACE is an ACE where the CONTAINER_INHERIT_ACE and the
//              OBJECT_INHERIT_ACE Flag in the ACE header is set.
//
//if (old aces exist)
//   for (new aces)
//      if (new ace option == GRANT)
//         for (old aces)
//            if (new ace SID == old ace SID)
//               do inheritance check
//               found = true
//               if (fdir) && (combined ACE)
//                 fDirEntryFound = TRUE
//                 if (old ace type == ALLOWED)
//                    new ace mask |= old ace mask
//                    old ace mask = 0
//                 else
//                    new ace mask &= ~old ace mask
//                    old ace mask = 0
//               else
//                 if (old ace type == ALLOWED)
//                    old ace mask |= new ace mask
//                 else
//                    old ace mask &= ~new ace mask
//         if (!found)
//            if (fdir)
//               add 2 times size of new ace
//            else
//               add size of new ace
//         else
//            if (fDirEntryFound)
//               add size of new ace
//            else
//               new ace mask = 0
//      else
//         if (fdir)
//            add 2 times the size of new ace
//         else
//            add size of new ace
//
//   for (old aces)
//      for (new aces)
//         if (new ace option == DENY, REPLACE, REVOKE)
//            if (new ace SID == old ace SID)
//               found = true
//               if (fdir) && (combined ACE)
//                  bDirEntryFound = TRUE
//               break
//      if (!found)
//         if (fdir)
//            add 2 times the size of old ace
//         else
//            add size of old ace
//      else
//         old ace mask = 0
//         if (bDirEntryFound)
//            add size of old ace
//else
//   for (new aces)
//      if (fdir)
//          add 2 times the size of new ace
//      else
//          add size of new ace
//
//
//  Arguments:  OUT [caclsize] - returns size
//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN  [fdir]     - True = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_GetNewAclSize(ULONG *caclsize, ACL *poldacl, BOOL fdir)
{
    ULONG	ret;
	BOOL	bDirEntryFound = FALSE;

    // the size for the ACL header

    *caclsize = sizeof(ACL);

    // initialize the access requests
    for (ULONG j = 0; j < _ccaa; j++)
       _aaa[j].pcaa->ReInit();

    // if we are merging, calculate the merge size

    if (poldacl)
    {
        // first the grant options

        for (j = 0; j < _ccaa; j++)
        {
            SID *psid;
            if (OPTION_GRANT == _aaa[j].option)
            {
                BOOL ffound = FALSE;
                ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

                for (ULONG cace = 0; cace < poldacl->AceCount;
                     cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
                {
                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                    {
                        if (EqualSid(psid,
                                     (SID *)&((ACCESS_ALLOWED_ACE *)pah)->SidStart) )
                        {
                            // if old and new types are the same, just and with the old

                            if (fdir && (pah->AceType == _aaa[j].pcaa->AceType()))
                            {
                                // make sure that we can handle the inheritance
                                _aaa[j].pcaa->AddInheritance(pah->AceFlags);

                                ffound = TRUE;
                            } else if (pah->AceType == _aaa[j].pcaa->AceType())
                            {
                                ffound = TRUE;
                            }
                            
							// if the ACE is a 'combined' entry, it has to be 
							// broken into two entries: one for the directory itself,
							// one for the file inheritance. But merge the old settings 
							// with the new ones!
							if ((fdir) && (pah->AceFlags & CONTAINER_INHERIT_ACE) && (pah->AceFlags & OBJECT_INHERIT_ACE))
							{	bDirEntryFound = TRUE;
								// die alte ACE wird gelscht. -> vorher mit neuen mischen
								if (ACCESS_ALLOWED_ACE_TYPE == pah->AceType)
								{	_aaa[j].pcaa->Init( _aaa[j].pcaa->AccessMask() | (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask,
														_aaa[j].pcaa->DirAccessMask() | (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask,
														_aaa[j].pcaa->FileSpecified()
													  );
									// and do not copy the old entry
									(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask = 0;
								}
								else if (ACCESS_DENIED_ACE_TYPE == pah->AceType)
								{	_aaa[j].pcaa->Init( _aaa[j].pcaa->AccessMask() & ~(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask,
														_aaa[j].pcaa->DirAccessMask() & ~(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask,
														_aaa[j].pcaa->FileSpecified()
													  );
									//_aaa[j].pcaa->AccessMask() &= ~(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask;
									// and do not copy the old entry
									(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask = 0;
								} else
								{
									VERBOSE((stderr, L"_GetNewAclSize found an ace that was not allowed or denied\n"))
									return(ERROR_INVALID_DATA);
								}
							}
							else	
							{	if (ACCESS_ALLOWED_ACE_TYPE == pah->AceType)
								{	if ((fdir) && (pah->AceFlags & CONTAINER_INHERIT_ACE))
										(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask |= _aaa[j].pcaa->DirAccessMask();
									else
										(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask |= _aaa[j].pcaa->AccessMask();
								} else if (ACCESS_DENIED_ACE_TYPE == pah->AceType)
								{	if ((fdir) && (pah->AceFlags & CONTAINER_INHERIT_ACE))
										(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask &= ~_aaa[j].pcaa->DirAccessMask();
									else
										(ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask &= ~_aaa[j].pcaa->AccessMask();
								} else
								{
									VERBOSE((stderr, L"_GetNewAclSize found an ace that was not allowed or denied\n"))
									return(ERROR_INVALID_DATA);
								}
							}
                        }
                    } else
                    {
                        return(ret);
                    }
                }
                if (!ffound)
                {
                    // bugbug allowed/denied sizes currently the same
                    
                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                                 sizeof(DWORD) +
                                 GetLengthSid(psid);
					// no old entry could be found. Therefore add two entries
					// as described above.
					if (fdir) 
					{	*caclsize += sizeof(ACCESS_ALLOWED_ACE) -
									 sizeof(DWORD) +
									 GetLengthSid(psid);
					}
                    SIZE((stderr, L"adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
                } else
                {
                    if (fdir && (ERROR_SUCCESS != (ret = _aaa[j].pcaa->TestInheritance())))
					{	// if a 'combined' entry was found, a new one has to be added.
						// So adjust the size of the ACL for one entry.
						if (bDirEntryFound)
						{	*caclsize += sizeof(ACCESS_ALLOWED_ACE) -
										 sizeof(DWORD) +
										 GetLengthSid(psid);
						}
                        return(ret);
					}
                    
					// if not needed, beceause of former 'combined' ACE,
					// the new ACE(s) had been modified and therefore is not being
					// copied.
					if (!bDirEntryFound) _aaa[j].pcaa->ClearAccessMask();
                }
            } else if ( (OPTION_REPLACE == _aaa[j].option) ||
                        (OPTION_DENY == _aaa[j].option) )
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    // bugbug allowed/denied sizes currently the same
                
                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                                 sizeof(DWORD) +
                                 GetLengthSid(psid);
                
					if (fdir)
					{	*caclsize += sizeof(ACCESS_ALLOWED_ACE) -
									 sizeof(DWORD) +
									 GetLengthSid(psid);
					}
                    SIZE((stderr, L"adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
                } else
                    return(ret);
            }
        }



        // now for the deny, replace & revoke options
        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));
        SID *psid;

        // loop thru the old ACL
        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
            BOOL ffound		= FALSE;
			bDirEntryFound	= FALSE;
			ULONG	pos;

            // and thru the new ACEs looking for matching SIDs

            for (ULONG j = 0; j < _ccaa; j++)
            {
                if ( (_aaa[j].option & OPTION_DENY ) ||
                     (_aaa[j].option & OPTION_REPLACE ) ||
                     (_aaa[j].option & OPTION_REVOKE ) )
                {
                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                    {
                        if (EqualSid(psid,
                                     (SID *)&((ACCESS_ALLOWED_ACE *)
                                     pah)->SidStart) )
                        {
                            ffound = TRUE;
							pos = j;
							if ((fdir) && (pah->AceFlags & CONTAINER_INHERIT_ACE) && (pah->AceFlags & OBJECT_INHERIT_ACE))
							{	// a 'combined' entry found. Take care that the old entry
								// don't get copied.
								bDirEntryFound = TRUE;
							}
                        }
                    } else
                        return(ret);
                }
            }
            if (!ffound)
            {
                // if we did not find a match, add the size of the old ACE
				*caclsize += ((ACE_HEADER *)pah)->AceSize;
				if (fdir) 
				{	
					*caclsize += ((ACE_HEADER *)pah)->AceSize;
				}
			    SIZE((stderr, L"adding on size of an old ACE (to the new ACL) = %d\n",*caclsize))
			}
			else
            {
                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask = 0;
				// if 'combined' entry found
				if (bDirEntryFound) 
				{	*caclsize += ((ACE_HEADER *)pah)->AceSize;
				}
            }
        }
        SIZE((stderr, L"final size for new ACL = %d\n",*caclsize))
    }
	else
    {
        // no old ACL, just add up the sizes of the new aces

        for (j = 0; j < _ccaa; j++)
        {
            // need to know the size of the sid
    
            SID *psid;
            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
            {
                // bugbug allowed/denied sizes currently the same
    
                *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                             sizeof(DWORD) +
                             GetLengthSid(psid);
				// if directory, one entry for the directory itself, one for 
				// file inheritence
				if (fdir)
				{	*caclsize += sizeof(ACCESS_ALLOWED_ACE) -
								 sizeof(DWORD) +
								 GetLengthSid(psid);
				}
    
                SIZE((stderr, L"adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
            } else
            {
                return(ret);
            }
        }
        SIZE((stderr, L"final size for new ACL = %d\n",*caclsize))
    }


	// handle mode_exclusive  a-henryw
	if (_EditMode == MODE_MODIFY_EXCLUSIVE)
	{
		if (poldacl == NULL)
		{
			return ERROR_NO_MORE_ITEMS;


		}
		else
		{
			ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));
			SID *psid = NULL;
			 for (ULONG j = 0; j < _ccaa; j++)
            {
				BOOL ffound		= FALSE;
				bDirEntryFound	= FALSE;
				for (ULONG cace = 0; cace < poldacl->AceCount;
					   cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
				{
					if ( (_aaa[j].option & OPTION_DENY ) ||
						 (_aaa[j].option & OPTION_REPLACE ) ||
						(_aaa[j].option & OPTION_REVOKE ) ||
						(_aaa[j].option & OPTION_GRANT))
					{
                    
						if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
						{
							if (EqualSid(psid,
										(SID *)&((ACCESS_ALLOWED_ACE *)
								         pah)->SidStart) )
						    {
								ffound = TRUE;
							}
						}
					}
				}
				if (!ffound && psid)
				{
					*caclsize -= sizeof(ACCESS_ALLOWED_ACE) -
								 sizeof(DWORD) +
								 GetLengthSid(psid);
					_aaa[j].pcaa->ClearAccessMask();
				}

			 }
		}

	}
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_AllocateNewAcl, private
//
//  Synopsis:   allocates and initializes the new ACL
//
//  Arguments:  OUT [pnewdacl] - address of new ACL to allocate
//              IN  [caclsize] - size to allocate for the new ACL
//              IN  [revision] - revision of the new ACL
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_AllocateNewAcl(ACL **pnewdacl, ULONG caclsize, ULONG revision)
{
    if (NULL == (*pnewdacl = (ACL *) LocalAlloc(LMEM_FIXED, caclsize)))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!InitializeAcl(*pnewdacl,caclsize, revision))
    {
        ULONG ret = GetLastError();
        LocalFree(*pnewdacl);
        return(ret);

    }

    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_SetAllowedAce, private
//
//  Synopsis:   appends an allowed ACE to the input ACL
//
//  Arguments:  IN [dacl]     - ACL to add the ACE to
//              IN [mask]     - access mask to add
//              IN [psid]     - SID to add
//              IN [fdir]     - if a Dir add inherit ACE as well
//				IN [filespec] - if TRUE, no ACE for file will be written
//                              (directories only)
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_SetAllowedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir, ACCESS_MASK dirmask, BOOL filespec)
{
    ULONG ret = ERROR_SUCCESS;

    // compute the size of the ACE we are making

    USHORT acesize = (USHORT)(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psid));

    SIZE((stderr, L"adding allowed ace, size = %d\n",fdir ? acesize*2 : acesize))

    // static buffer in the hopes we won't have to allocate memory

    BYTE buf[1024];

    // allocator either uses buf or allocates a new buffer if size is not enough

    FastAllocator fa(buf, 1024);

    // get the buffer for the ACE

    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)fa.GetBuf(acesize);

    // fill in the ACE

    memcpy(&paaa->SidStart,psid,GetLengthSid(psid));
    paaa->Mask = mask;

    paaa->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
	paaa->Header.AceSize = acesize;

    // put the ACE into the ACL

    if (!fdir)
	{	paaa->Header.AceFlags = 0;
		if (!AddAce(dacl,
					dacl->AclRevision,
					0xffffffff,
					paaa,
					paaa->Header.AceSize))
		{	ret = GetLastError();
			return (ret);
		}
	}
	else
	{	if (!filespec)
		{	// if filespec is TRUE, the file inheritence is not specified
			paaa->Header.AceFlags = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
			if (!AddAce(dacl,
						dacl->AclRevision,
						0xffffffff,
						paaa,
						paaa->Header.AceSize))
			{	ret = GetLastError();
				return (ret);
			}
		}

		paaa->Mask = dirmask; 
		paaa->Header.AceFlags = CONTAINER_INHERIT_ACE;
		if (!AddAce(dacl,
					dacl->AclRevision,
					0xffffffff,
					paaa,
					paaa->Header.AceSize))
			ret = GetLastError();
	}
    return(ret);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_SetDeniedAce, private
//
//  Synopsis:   appends a denied ACE to the input ACL
//
//  Arguments:  IN [dacl] - ACL to add the ACE to
//              IN [mask] - access mask to add
//              IN [psid] - SID to add
//              IN [fdir] - if a Dir add inherit ACE as well
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_SetDeniedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir)
{
    ULONG ret = ERROR_SUCCESS;

    // compute the size of the ACE we are making

    USHORT acesize = (USHORT)( sizeof(ACCESS_DENIED_ACE) -
                   sizeof(DWORD) +
                   GetLengthSid(psid));

    SIZE((stderr, L"adding denied ace, size = %d\n",acesize))

    // static buffer in the hopes we won't have to allocate memory

    BYTE buf[1024];

    // allocator either uses buf or allocates a new buffer if size is not enough

    FastAllocator fa(buf, 1024);

    // get the buffer for the ACE

    ACCESS_DENIED_ACE *paaa = (ACCESS_DENIED_ACE *)fa.GetBuf(acesize);

    // fill in the ACE

    memcpy(&paaa->SidStart,psid,GetLengthSid(psid));
    paaa->Mask = mask;

    paaa->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    paaa->Header.AceFlags = fdir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE : 0;
    paaa->Header.AceSize = acesize;

    // put the ACE into the ACL

    if (!AddAce(dacl,
                dacl->AclRevision,
                0xffffffff,
                paaa,
                paaa->Header.AceSize))
        ret = GetLastError();
    return(ret);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_FillNewAcl, private
//
//  Synopsis:   The worker routine that actually fills the ACL, it adds the
//              new denied ACEs, then if the new ACEs are being merged with
//              an existing ACL, the existing ACL's ACE's (that don't
//              conflict) are added, finally the new allowed ACEs are added.
//              another ugly algorithm:
//
//for (new aces)
//   if (new ace option == DENY)
//      add new ace
//
//if (old aces)
//   for (old aces)
//      if (old ace mask != 0)
//         add old ace
//
//   for (new aces)
//      if (new ace option != DENY)
//         if ( new ace option != REVOKE)
//            if (new ace mask != 0
//                add new ace
//
//else
//   for (new aces)
//      if (new ace option != DENY)
//         add new ace
//
//  Arguments:  IN [pnewdacl] - the new ACL to be filled
//              IN [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN [fdir]     - TRUE = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_FillNewAcl(ACL *pnewdacl, ACL *poldacl, BOOL fdir)
{
    SID *psid;
    ULONG ret;

    // set new denied aces

    for (ULONG j = 0; j < _ccaa; j++)
    {
        if (_aaa[j].option & OPTION_DENY)
        {
            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
            {
                if (ERROR_SUCCESS != (ret = _SetDeniedAce(pnewdacl,
                                                           _aaa[j].pcaa->AccessMask(),
                                                           psid,
                                                           fdir )))
                    return(ret);
            } else
                return(ret);
        }

		// should it be the new owner ? 
		if (_aaa[j].option & OPTION_SET_OWNER)
		{	// remember the SID. If it's not empty, more than one has been specified to be the owner!
			if (_powner)
			{	// error, there can just be one...
				printmessage( stdout, MSG_TWO_OWNER, 0 );
				exit( -1 );
			}
			else
			{	// get the descriptor and allocate the SID
				SID_IDENTIFIER_AUTHORITY	*pSIDAuth;

				pSIDAuth = GetSidIdentifierAuthority( psid );
				if (!AllocateAndInitializeSid( pSIDAuth, 0, 0, 0, 0, 0, 0, 0, 0, 0, &_powner ))
				{	ret = GetLastError();
					printmessage( stdout, ret, 0 );
					exit( -1 );
				}
			}
		}
    }

    // check and see if the ACL from from the file is in correct format

    if (poldacl)
    {
        SIZE((stderr, L"old ACL size = %d, acecount = %d\n",poldacl->AclSize,
              poldacl->AceCount))

        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

        // loop thru the old ACL, looking for matches with the new ACEs

        BOOL fallowedacefound = FALSE;
        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
            // error exit if the old ACL is incorrectly formated

            if (pah->AceType == ACCESS_DENIED_ACE_TYPE && fallowedacefound)
            {
                VERBOSE((stderr, L"_FillNewAcl found an denied ACE after an allowed ACE\n"))
                return(ERROR_INVALID_DATA);
            }
            else if (pah->AceType == ACCESS_ALLOWED_ACE_TYPE)
                fallowedacefound = TRUE;

            // add the old ace to the new ACL if the old ace's mask is not zero

            if ( 0 != (ACCESS_MASK)((ACCESS_ALLOWED_ACE *)pah)->Mask)
            {
                // add the old ace
                if (!AddAce(pnewdacl,
                            pnewdacl->AclRevision,
                            0xffffffff,
                            pah,
                            pah->AceSize))
                    return(GetLastError());
            }
        }
        // now for the new aces

        for (ULONG j = 0; j < _ccaa; j++)
        {
            if ( (_aaa[j].option != OPTION_DENY) && 
                 (_aaa[j].option != OPTION_REVOKE) &&
                 (_aaa[j].pcaa->AccessMask() != 0) )
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl,
                                                               _aaa[j].pcaa->AccessMask(),
                                                               psid,
                                                               fdir,
															   _aaa[j].pcaa->DirAccessMask(),
															   _aaa[j].pcaa->FileSpecified())))
                        return(ret);
                } else
                    return(ret);
            }
            
        }
    } else
    {
        // no old acl, just add the (rest) of the new aces
        for (ULONG j = 0; j < _ccaa; j++)
        {
            if (_aaa[j].option != OPTION_DENY)
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl,
                                                               _aaa[j].pcaa->AccessMask(),
                                                               psid,
                                                               fdir,
															   _aaa[j].pcaa->DirAccessMask(),
															   _aaa[j].pcaa->FileSpecified())))
                        return(ret);
                } else
                    return(ret);
            }
        }
    }

    return(ERROR_SUCCESS);
}

//----------------------------------------------------------------------------
//
//  Function:     printmessage
//
//  Synopsis:     prints a message, either from the local message file, or from the system
//
//  Arguments:    IN [fp]    - stderr, stdio, etc.
//                IN [messageID] - variable argument list
//
//  Returns:      length of the output buffer
//
//----------------------------------------------------------------------------
ULONG  printmessage (FILE* fp, DWORD messageID, ...)
{
    WCHAR  messagebuffer[4096] = L"";
	va_list ap;

	va_start(ap, messageID);

    if (!FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE, 
                        NULL, 
                        messageID, 
                        0,
                        messagebuffer, 
                        sizeof(messagebuffer)/sizeof(messagebuffer[0]), 
                        &ap))
    {
       if(!FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, 
                          NULL, 
                          messageID, 
                          0,
                          messagebuffer, 
                          sizeof(messagebuffer)/sizeof(messagebuffer[0]), 
                          &ap))
	   {
			va_end(ap);
			return GetLastError();
	   }
    }
	
	fputws(messagebuffer,fp);
				

    va_end(ap);
    
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\wsuser.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wsuser.cpp

Abstract:

     This file can be used to initializes all the objects for access token ,
     user, groups , privileges and displays the user name with respective
     security identifiers (SID), privileges, logon identifier (logon ID)
     in the current access token on a local system or a remote system.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

WsUser::WsUser ( VOID )
/*++
   Routine Description:
    This function intializes the members of WsUser class.

   Arguments:
    None
   Return Value:
    None
--*/

{
    // intialize member variables
    lpLogonId   = NULL ;
    lpPriv      = NULL ;
    lpwGroups   = NULL ;
    dwnbGroups    = 0 ;
}

WsUser::~WsUser ( VOID )
/*++
   Routine Description:
    This function deallocates the members of WsUser class.

   Arguments:
     None
  Return Value:
     None
--*/
    {

    /// sub-local varible
    WORD   wloop = 0 ;

    //release memory
    if(NULL != lpLogonId){
        delete lpLogonId ;
    }

     //release memory
    if(NULL != lpPriv) {
        for(wloop = 0 ; wloop < dwnbPriv ; wloop++){
            delete lpPriv[wloop] ;
        }

        FreeMemory ((LPVOID *) &lpPriv) ;

    }

     //release memory
    if(NULL != lpwGroups) {
        for(wloop = 0 ; wloop < dwnbGroups ; wloop++){
            delete lpwGroups[wloop] ;
        }
        FreeMemory ((LPVOID *) &lpwGroups ) ;
    }
}


DWORD
WsUser::Init ( VOID )
/*++
   Routine Description:
    This function initializes all objects for access token , user, groups and privileges.

   Arguments:
    None

   Return Value:
         EXIT_FAILURE :   On failure
         EXIT_SUCCESS :   On success
--*/
{

    //sub-local variable
    DWORD    dwErr = 0 ;

    // Open current token
    if((dwErr = wToken.Open()) != EXIT_SUCCESS){
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

        // return 1 for failure
        return EXIT_FAILURE ;
      }

    // Get SIDs
    if((dwErr = wToken.InitUserSid (&wUserSid)) != EXIT_SUCCESS){
        // display an error message with respect to the GetLastError()
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        //return 1 for failure
        return EXIT_FAILURE ;
    }

    // Get Groups
    if((dwErr = wToken.InitGroups (&lpwGroups, &lpLogonId, &dwnbGroups))
       != EXIT_SUCCESS){
       // display an error message with respect to the GetLastError()
       ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );

       //return 1 for failure
       return EXIT_FAILURE ;
    }

    // Get Privileges
    if((dwErr = wToken.InitPrivs (&lpPriv, &dwnbPriv)) != EXIT_SUCCESS){
       // display an error message with respect to GetLastError()
       ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
       //return 1 for failure
       return EXIT_FAILURE ;
    }

    //return 0 for success
    return EXIT_SUCCESS ;
}


DWORD
WsUser::DisplayGroups (
                        IN DWORD dwFormatType
                      )
/*++
   Routine Description:
    This function displays the group names.

   Arguments:

         [IN] DWORD dwFormatType  : Format type i.,e LIST, CSV or TABLE

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{
    //sub-local variables
    DWORD  dwArrSize = 0 ;
    DWORD   dwColCount = 0 ;
    DWORD   dw = 0 ;
    DWORD   dwCount = 0 ;
    WORD    wloop = 0 ;
    DWORD      dwGroupNameColLen  = 0;
    DWORD      dwGroupNameLen  = 0;
    DWORD      dwGroupTmpNameLen  = 0;
    DWORD      dwGroupSidColLen  = 0;
    DWORD      dwGroupSidLen  = 0;
    DWORD      dwGroupTmpSidLen = 0;
    DWORD      dwGroupAttribColLen  = 0;
    DWORD      dwGroupAttribLen  = 0;
    DWORD      dwGroupTmpAttribLen = 0;
    DWORD      dwGroupTypeCol = 0;
    DWORD      dwGroupType = 0;
    DWORD      dwGroupTmpType = 0;
    DWORD      SidNameUse = 0;
    DWORD      dwSize = 0;

    WCHAR      wszGroupName[ 2 * MAX_RES_STRING ];
    WCHAR      wszGroupSid [ MAX_RES_STRING ];
    LPCWSTR     wszPartialName = NULL;
    WCHAR      wszDomainAttr[MAX_STRING_LENGTH] ;
    WCHAR      wszSidType[MAX_STRING_LENGTH] ;
    WCHAR      wszDomainAttrib[ 2 * MAX_RES_STRING ];
    WCHAR      wszSidName[ 2 * MAX_RES_STRING ];

     // initialize the variables
   SecureZeroMemory ( wszGroupName, SIZE_OF_ARRAY(wszGroupName) );
   SecureZeroMemory ( wszGroupSid, SIZE_OF_ARRAY(wszGroupSid) );
   SecureZeroMemory ( wszDomainAttr, SIZE_OF_ARRAY(wszDomainAttr) );
   SecureZeroMemory ( wszSidType, SIZE_OF_ARRAY(wszSidType) );
   SecureZeroMemory ( wszDomainAttrib, SIZE_OF_ARRAY(wszDomainAttrib) );
   SecureZeroMemory ( wszSidName, SIZE_OF_ARRAY(wszSidName) );

     // get the maximum length of group name and sid
     for( wloop = 0 , dwCount = 0 ; wloop < dwnbGroups ; wloop++ , dwCount++ ) {

       // display group names along with the SID for a specified format.
       if ( EXIT_SUCCESS != ( lpwGroups[wloop]->DisplayGroupName ( wszGroupName, wszGroupSid, &SidNameUse ) ) )
        {
            return EXIT_FAILURE;
        }

        dwSize = SIZE_OF_ARRAY(wszDomainAttrib);

        wToken.GetDomainAttributes(wToken.dwDomainAttributes[wloop], wszDomainAttrib, dwSize);

        //get attributes
        StringCopy(wszDomainAttr, wszDomainAttrib, SIZE_OF_ARRAY(wszSidType));

        dwSize = SIZE_OF_ARRAY(wszSidName);
        GetDomainType ( SidNameUse , wszSidName, dwSize );

        //get type
        StringCopy(wszSidType, wszSidName, SIZE_OF_ARRAY(wszSidType));;

        // block the domain\None name
        wszPartialName = FindString ( wszGroupSid, STRING_SID, 0 );
        if ( ( NULL != wszPartialName ) || ( 0 == StringLength (wszGroupName, 0) ) )
        {
            wszPartialName = NULL;
            dwCount--;
            continue;
        }

        // get the max length of group name
        dwGroupTmpNameLen = StringLengthInBytes(wszGroupName);
        if ( dwGroupNameLen < dwGroupTmpNameLen )
        {
            dwGroupNameLen = dwGroupTmpNameLen;
        }

        // get the max length of type
        dwGroupTmpType = StringLengthInBytes (wszSidType);
        if ( dwGroupType < dwGroupTmpType )
        {
            dwGroupType = dwGroupTmpType;
        }

        // get the max length of SID
        dwGroupTmpSidLen = StringLengthInBytes (wszGroupSid);
        if ( dwGroupSidLen < dwGroupTmpSidLen )
        {
            dwGroupSidLen = dwGroupTmpSidLen;
        }

        // get the max length of Attributes
        dwGroupTmpAttribLen = StringLengthInBytes (wszDomainAttr);
        if ( dwGroupAttribLen < dwGroupTmpAttribLen )
        {
            dwGroupAttribLen = dwGroupTmpAttribLen;
        }

    }

    //
    //To avoid localization problems, get the maximum length of column name and
    // values of respective columns 
    //

    // Get the maximum length of a column name "Group Name"  
    dwGroupNameColLen = StringLengthInBytes( GetResString(IDS_COL_GROUP_NAME) );
    if ( dwGroupNameColLen > dwGroupNameLen )
    {
      dwGroupNameLen = dwGroupNameColLen;
    }

    // Get the maximum length of a column name "Type"  
    dwGroupTypeCol = StringLengthInBytes( GetResString(IDS_COL_TYPE_GROUP) );
    if ( dwGroupTypeCol > dwGroupType )
    {
      dwGroupType = dwGroupTypeCol;
    }

    // Get the maximum length of a column name "SID"  
    dwGroupSidColLen = StringLengthInBytes( GetResString(IDS_COL_GROUP_SID) );
    if ( dwGroupSidColLen > dwGroupSidLen )
    {
      dwGroupSidLen = dwGroupSidColLen;
    }
    
    // Get the maximum length of a column name "Attributes"  
    dwGroupAttribColLen = StringLengthInBytes( GetResString(IDS_COL_ATTRIBUTE) );
    if ( dwGroupAttribColLen > dwGroupAttribLen )
    {
      dwGroupAttribLen = dwGroupAttribColLen;
    }

   // defining the verbose columns with actual length of values
   TCOLUMNS pVerboseCols[] =
    {
        {L"\0",dwGroupNameLen, SR_TYPE_STRING, COL_FORMAT_STRING, NULL, NULL},
        {L"\0",dwGroupType,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",dwGroupSidLen,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",dwGroupAttribLen,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
    };

    // get the size of pVerboseCols
    dwArrSize = SIZE_OF_ARRAY( pVerboseCols );

   //Load the column names for  verbose mode
    for( dwColCount = IDS_COL_GROUP_NAME , dw = 0 ; dwColCount <= IDS_COL_ATTRIBUTE;
         dwColCount++, dw++)
     {
        StringCopy (pVerboseCols[dw].szColumn , GetResString(dwColCount), MAX_RES_STRING);
     }

    // create a dynamic array
    TARRAY pColData = CreateDynamicArray();
    if ( NULL == pColData )
    {
        SetLastError ((DWORD)E_OUTOFMEMORY);
        SaveLastError();
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }

    //loop through and display the group names
    for( wloop = 0 , dwCount = 0 ; wloop < dwnbGroups ; wloop++ , dwCount++ ) {

       // display the group name and SID
       if ( EXIT_SUCCESS != ( lpwGroups[wloop]->DisplayGroupName ( wszGroupName, wszGroupSid, &SidNameUse ) ) )
        {
            DestroyDynamicArray(&pColData);
            return EXIT_FAILURE;
        }

        dwSize = SIZE_OF_ARRAY(wszDomainAttrib);

        wToken.GetDomainAttributes(wToken.dwDomainAttributes[wloop], wszDomainAttrib, dwSize );

        //get attributes
        StringCopy(wszDomainAttr, wszDomainAttrib, SIZE_OF_ARRAY(wszSidType));

        dwSize = SIZE_OF_ARRAY(wszSidName);

        GetDomainType ( SidNameUse , wszSidName, dwSize);
         //get type
        StringCopy(wszSidType, wszSidName, SIZE_OF_ARRAY(wszSidType));

        // block the domain\None name
        wszPartialName = FindString ( wszGroupSid, STRING_SID, 0 );
        if ( ( NULL != wszPartialName ) || ( 0 == StringLength (wszGroupName, 0) ) )
        {
            wszPartialName = NULL;
            dwCount--;
            continue;
        }

        //Start appending to the 2D array
        DynArrayAppendRow(pColData,dwArrSize);

        //Insert the user name
        DynArraySetString2(pColData, dwCount, GROUP_NAME_COL_NUMBER, _X(wszGroupName), 0);

        //Insert the domain type
        DynArraySetString2(pColData, dwCount, GROUP_TYPE_COL_NUMBER, wszSidType, 0);

        //Insert the SID string
        DynArraySetString2(pColData, dwCount, GROUP_SID_COL_NUMBER, _X(wszGroupSid), 0);

        //Insert Attributes
        DynArraySetString2(pColData, dwCount, GROUP_ATT_COL_NUMBER, wszDomainAttr, 0);

     }

    // 1) If the display format is CSV.. then we should not display column headings..
    // 2) If /NH is specified ...then we should not display column headings..
    if ( !(( SR_FORMAT_CSV == dwFormatType ) || ((dwFormatType & SR_HIDECOLUMN) == SR_HIDECOLUMN))) 
    {
        // display heading before displaying group name information
        ShowMessage ( stdout, L"\n" );
        ShowMessage ( stdout, GetResString ( IDS_LIST_GROUP_NAMES ) );
        ShowMessage ( stdout, GetResString ( IDS_DISPLAY_GROUP_DASH ) );
    }
    
    // display atual group names along with SIDs
    ShowResults(dwArrSize, pVerboseCols, dwFormatType, pColData);

    // release memory
    DestroyDynamicArray(&pColData);

    // return success
    return EXIT_SUCCESS ;
}



DWORD
WsUser::DisplayLogonId ()
/*++
   Routine Description:
    This function displays the logon ID.

   Arguments:
       [IN] DWORD dwFormatType  : Format type i.,e LIST, CSV or TABLE

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

   // sub-local variables
   WCHAR wszSid [ MAX_RES_STRING ] ;

   // initialize the variables
   SecureZeroMemory ( wszSid, SIZE_OF_ARRAY(wszSid) );

   DWORD  dwRet = 0 ;

    // get logon id
    if ( EXIT_SUCCESS != ( dwRet = lpLogonId->DisplaySid ( wszSid ) ) )
    {
        return dwRet;
    }

    // display logon id
    ShowMessage ( stdout, _X(wszSid) );
    ShowMessage ( stdout, L"\n" );
    return EXIT_SUCCESS ;

}


DWORD
WsUser::DisplayPrivileges (
                            IN DWORD dwFormatType
                        )
/*++
   Routine Description:
    This function displays the privileges

   Arguments:
       [IN] DWORD dwFormatType  : Format type i.,e LIST, CSV or TABLE

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

   //sub-local variables
   WCHAR      wszPrivName [ MAX_RES_STRING ];
   WCHAR      wszPrivDisplayName [ MAX_RES_STRING ];
   WCHAR      wszState [ MAX_RES_STRING ];
   DWORD      dwErr = 0 ;
   WORD       wloop = 0 ;

   DWORD  dwColCount = 0 ;
   DWORD  dwCount = 0 ;
   DWORD  dw = 0 ;
   DWORD  dwArrSize = 0 ;
   DWORD      dwStateColLen  = 0;
   DWORD      dwPrivNameColLen  = 0;
   DWORD      dwPrivDescColLen  = 0;
   DWORD      dwStateLen  = 0;
   DWORD      dwTmpStateLen  = 0;
   DWORD      dwPrivNameLen  = 0;
   DWORD      dwTmpPrivNameLen = 0;
   DWORD      dwPrivDispNameLen  = 0;
   DWORD      dwTmpPrivDispNameLen = 0;

   // initialize the variables
   SecureZeroMemory ( wszPrivName, SIZE_OF_ARRAY(wszPrivName) );
   SecureZeroMemory ( wszPrivDisplayName, SIZE_OF_ARRAY(wszPrivDisplayName) );
   SecureZeroMemory ( wszState, SIZE_OF_ARRAY(wszState) );

    // get the length of state, pivilege name, and display name
    for( wloop = 0 , dwCount = 0 ; wloop < dwnbPriv ; wloop++, dwCount++) {

        // check whether the privilege is enabled or not
        if(lpPriv[wloop]->IsEnabled() == TRUE )
        {
              // copy the status as .. enabled..
              StringCopy ( wszState, GetResString ( IDS_STATE_ENABLED ), SIZE_OF_ARRAY(wszState) );
        }
        else
        {
               // copy the status as .. disabled..
               StringCopy ( wszState, GetResString ( IDS_STATE_DISABLED ), SIZE_OF_ARRAY(wszState) );
        }

        // get the privilege name and description
        if((dwErr = lpPriv[wloop]->GetName ( wszPrivName)) != EXIT_SUCCESS ||
           (dwErr = lpPriv[wloop]->GetDisplayName ( wszPrivName, wszPrivDisplayName ))
           != EXIT_SUCCESS){
            // return GetLastError()
            return dwErr ;
        }

        // get the length of state
        dwTmpStateLen = StringLengthInBytes (wszState);
        if ( dwStateLen < dwTmpStateLen )
        {
            dwStateLen = dwTmpStateLen;
        }

        // get the length privilege name
        dwTmpPrivNameLen = StringLengthInBytes (wszPrivName);
        if ( dwPrivNameLen < dwTmpPrivNameLen )
        {
            dwPrivNameLen = dwTmpPrivNameLen;
        }

        // get the length of privilege display name
        dwTmpPrivDispNameLen = StringLengthInBytes (wszPrivDisplayName);
        if ( dwPrivDispNameLen < dwTmpPrivDispNameLen )
        {
            dwPrivDispNameLen = dwTmpPrivDispNameLen;
        }

    }

    //
    //To avoid localization problems, get the maximum length of column name and
    // values of respective columns 
    //

    // Get the maximum length of a column name "Privilege Name"  
    dwPrivNameColLen = StringLengthInBytes( GetResString(IDS_COL_PRIV_NAME) );
    if ( dwPrivNameColLen > dwPrivNameLen )
    {
      dwPrivNameLen = dwPrivNameColLen;
    }

    // Get the maximum length of a column name "Privilege Description"  
    dwPrivDescColLen = StringLengthInBytes( GetResString(IDS_COL_PRIV_DESC) );
    if ( dwPrivDescColLen > dwPrivDispNameLen )
    {
      dwPrivDispNameLen = dwPrivDescColLen;
    }

    // Get the maximum length of a column name "State"  
    dwStateColLen = StringLengthInBytes ( GetResString(IDS_COL_PRIV_STATE));
    if ( dwStateColLen > dwStateLen )
    {
      dwStateLen = dwStateColLen;
    }

    // create a dynamic array
    TARRAY pColData = CreateDynamicArray();

    // defining verbose columns
    TCOLUMNS pVerboseCols[] =
    {
        {L"\0",dwPrivNameLen, SR_TYPE_STRING, COL_FORMAT_STRING, NULL, NULL},
        {L"\0",dwPrivDispNameLen,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
        {L"\0",dwStateLen,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL}
    };

    // get number of columns
    dwArrSize = SIZE_OF_ARRAY( pVerboseCols );

    //Load the column names for  verbose mode
    for( dwColCount = IDS_COL_PRIV_NAME , dw = 0 ; dwColCount <= IDS_COL_PRIV_STATE;
     dwColCount++, dw++)
     {
        StringCopy (pVerboseCols[dw].szColumn , GetResString(dwColCount), MAX_RES_STRING);
     }

    // get the pivilege name, display name and state
    for( wloop = 0 , dwCount = 0 ; wloop < dwnbPriv ; wloop++, dwCount++) {

         if(lpPriv[wloop]->IsEnabled() == TRUE )
        {
              // copy the status as ... enabled..
              StringCopy ( wszState, GetResString ( IDS_STATE_ENABLED ), SIZE_OF_ARRAY(wszState) );
        }
        else
        {
               // copy the status as .. disabled..
               StringCopy ( wszState, GetResString ( IDS_STATE_DISABLED ), SIZE_OF_ARRAY(wszState) );
        }

        if((dwErr = lpPriv[wloop]->GetName ( wszPrivName)) != EXIT_SUCCESS ||
           (dwErr = lpPriv[wloop]->GetDisplayName ( wszPrivName, wszPrivDisplayName ))
           != EXIT_SUCCESS){
            // release memory
            DestroyDynamicArray(&pColData);
            // return GetLastError()
            return dwErr ;
        }

        //Start appending to the 2D array
        DynArrayAppendRow( pColData, dwArrSize );

        //Insert the privilege name
        DynArraySetString2(pColData, dwCount, PRIVNAME_COL_NUMBER, _X(wszPrivName), 0);

        //Insert the privilege display name
        DynArraySetString2(pColData, dwCount, PRIVDESC_COL_NUMBER, _X(wszPrivDisplayName), 0);

        //Insert the state
        DynArraySetString2(pColData, dwCount, PRIVSTATE_COL_NUMBER, _X(wszState), 0);

    }

    // 1) If the display format is CSV.. then we should not display column headings..
    // 2) If /NH is specified ...then we should not display column headings..
    if ( !(( SR_FORMAT_CSV == dwFormatType ) || ((dwFormatType & SR_HIDECOLUMN) == SR_HIDECOLUMN))) 
    {
        // display the the headings before displaying the actual values
        ShowMessage ( stdout, L"\n" );
        ShowMessage ( stdout, GetResString ( IDS_LIST_PRIV_NAMES ) );
        ShowMessage ( stdout, GetResString ( IDS_DISPLAY_PRIV_DASH ) );
    }

     // display privilege name, description and status values
     ShowResults(dwArrSize, pVerboseCols, dwFormatType, pColData);

    // release memory
    DestroyDynamicArray(&pColData);

    // return success
    return EXIT_SUCCESS ;

}


DWORD
WsUser::DisplayUser (
                      IN DWORD dwFormatType,
                      IN DWORD dwNameFormat
                      )
/*++
   Routine Description:
    This function calls the methods to display the user name and SID.

   Arguments:
        [IN] DWORD dwFormatType  : Format type i.,e LIST, CSV or TABLE
        [IN] DWORD dwNameFormat  : Name format either UPN or FQDN

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{

   // sub-local variables
    DWORD dwRetVal = 0;

    // get logged-on user name
    dwRetVal = wUserSid.DisplayAccountName ( dwFormatType, dwNameFormat  );
    if( 0 != dwRetVal )
    {
        // return GetLastError()
        return dwRetVal;
    }

    // return success
    return EXIT_SUCCESS ;
}

VOID
WsUser::GetDomainType (
                        IN DWORD NameUse,
                        OUT LPWSTR szSidNameUse,
                        IN DWORD dwSize 
                      )
/*++
   Routine Description:
    Gets the domain type

   Arguments:
        [IN] NameUse   : Specifies SDI use name value
        [OUT] szSidNameUse   : Buffer for SID Name
        [IN] dwSize   : size of Sid name 

   Return Value:
         EXIT_SUCCESS :   On success
         EXIT_FAILURE :   On failure
--*/
{
    //local variables
    WCHAR szSidType[2 * MAX_STRING_LENGTH];
    // initialize the variables
    SecureZeroMemory ( szSidType, SIZE_OF_ARRAY(szSidType) );
   
    //store appropriate type name with respect to NameUse value.
    switch( NameUse )
    {
    case SidTypeUser:
        StringCopy ( szSidType, GetResString(IDS_TYPE_USER), SIZE_OF_ARRAY(szSidType) );
        break;
    case SidTypeGroup:
        StringCopy ( szSidType, GetResString(IDS_TYPE_GROUP), SIZE_OF_ARRAY(szSidType) );
        break;
    case SidTypeDomain:
        StringCopy ( szSidType, GetResString(IDS_TYPE_DOMAIN), SIZE_OF_ARRAY(szSidType) );
        break;
    case SidTypeAlias:
        StringCopy ( szSidType, GetResString(IDS_TYPE_ALIAS), SIZE_OF_ARRAY(szSidType) );
        break;
    case SidTypeWellKnownGroup:
        StringCopy ( szSidType, GetResString(IDS_TYPE_WELLKNOWN), SIZE_OF_ARRAY(szSidType) );
        break;
    case SidTypeDeletedAccount:
        StringCopy ( szSidType, GetResString(IDS_TYPE_DELETACCOUNT), SIZE_OF_ARRAY(szSidType) );
        break;
    case SidTypeInvalid:
        StringCopy ( szSidType, GetResString(IDS_TYPE_INVALIDSID), SIZE_OF_ARRAY(szSidType) );
        break;
    case SidTypeUnknown:
    default:
        StringCopy ( szSidType, GetResString(IDS_TYPE_UNKNOWN), SIZE_OF_ARRAY(szSidType) );
        break;
    }

    // Copy SID Name 
    StringCopy (szSidNameUse, szSidType, dwSize);
    
    //return success
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\dumpsec.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        DumpSec.cxx
//
// Contents:    class to dump file security ACL
//
// Classes:     CDumpSecurity
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include "pch.h"
#include "DumpSec.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::CDumpSecurity, public
//
//  Synopsis:   initialized data members, constructor will not throw
//
//  Arguments:  IN [pfilename] - name of file to dump security for
//
//----------------------------------------------------------------------------
CDumpSecurity::CDumpSecurity(LPWSTR pfilename)
    : _psd(NULL),
      _pwfilename(pfilename),
      _pdacl(NULL),
      _pah(NULL),
      _psid(NULL),
      _cacethissid(0),
      _bNullDacl(FALSE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced.  Init gets the security descriptor and
//              ACL for the file
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::Init()
{
    ULONG ret;
    ULONG cpsd;

    // get the size of the security buffer

    if (!GetFileSecurity((LPCTSTR)_pwfilename,
                         DACL_SECURITY_INFORMATION |
                         GROUP_SECURITY_INFORMATION |
                         OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &cpsd) )
    {
        if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
        {
            if ( NULL == ( _psd = (BYTE *)LocalAlloc(LMEM_FIXED, cpsd)))
            {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            }

            // actually get the buffer this time

            if ( GetFileSecurity((LPCTSTR)_pwfilename,
                                 DACL_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 OWNER_SECURITY_INFORMATION,
                                 _psd,
                                 cpsd,
                                 &cpsd) )
            {
                BOOL fdaclpresent;
                BOOL cod;

                // get the ACL

                if ( GetSecurityDescriptorDacl(_psd,
                                           &fdaclpresent,
                                           &_pdacl,
                                           &cod) )

                {
                    if (!fdaclpresent)
                    {
                        _pdacl = NULL;
                        return(ERROR_NO_SECURITY_ON_OBJECT);
                    }
                    // save the ACL location
                    if(_pdacl)
                    {
                        _pah = (ACE_HEADER *)Add2Ptr(_pdacl, sizeof(ACL));
                    }
                    else
                    {
                        _bNullDacl = TRUE;
                    }
                    return(ERROR_SUCCESS);

                } else
                   return(GetLastError());
            } else
               return(GetLastError());
        }
    } else
        return(ERROR_NO_SECURITY_ON_OBJECT);

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees the security descriptor
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDumpSecurity::~CDumpSecurity()
{
    if (_psd)
    {
        LocalFree(_psd);
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetSDOwner, public
//
//  Synopsis:   returns the owner of the file
//
//  Arguments:  OUT [psid] - address of the returned sid
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::GetSDOwner(SID **psid)
{
    BOOL cod;
    if ( GetSecurityDescriptorOwner(_psd, (void **)psid, &cod) )
        return(0);
    else
        return(GetLastError());
}

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetSDGroup, public
//
//  Synopsis:   returns the group from the file
//
//  Arguments:  OUT [pgsid] - address of the returned group sid
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::GetSDGroup(SID **pgsid)
{
    BOOL cod;
    if ( GetSecurityDescriptorGroup(_psd, (void **)pgsid, &cod) )
        return(0);
    else
        return(GetLastError());
}

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::ResetAce, public
//
//  Synopsis:   sets the 'ace' index to the start of the DACL
//
//  Arguments:  IN - [psid] - the SID to find aces for
//
//----------------------------------------------------------------------------
VOID CDumpSecurity::ResetAce(SID *psid)
{

    _psid = psid;
    _cacethissid = 0;
    if (_pdacl)
        _pah = (ACE_HEADER *)Add2Ptr(_pdacl, sizeof(ACL));
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetNextAce, public
//
//  Synopsis:   gets the next ACE from the DACL for the specified SID
//
//  Arguments:  OUT  [pace] - pointer to the next ace for the SID passed
//                            in at the last reset.
//
//  Returns:    the number of the ACE
//
//----------------------------------------------------------------------------
LONG CDumpSecurity::GetNextAce(ACE_HEADER **paceh)
{
    LONG ret = -1;

    if (_pdacl)
    {
        for (;_cacethissid < _pdacl->AceCount;
            _cacethissid++, _pah = (ACE_HEADER *)Add2Ptr(_pah, _pah->AceSize))
        {
            if (!_psid || EqualSid(_psid,(SID *)&((ACCESS_ALLOWED_ACE *)_pah)->SidStart) )
            {
               *paceh = _pah;
                ret = _cacethissid++;
                _pah = (ACE_HEADER *)Add2Ptr(_pah, _pah->AceSize);
                break;
            }
        }
    }
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\fileenum.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        FileEnum.cxx
//
// Contents:    class encapsulating file enumeration, including a deep option
//
// Classes:     CFileEnumeration
//
// History:     Nov-93      DaveMont         Created.
//				Feb-98		BrunoSc			 CFileEnumerate::Init changed to avoid problems with
//											 files with german Umlaute.
//
//-------------------------------------------------------------------
#include "pch.h"
#include "t2.hxx"
#include "FileEnum.hxx"
#include <locale.h>
#include <wchar.h>
#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::CFileEnumerate, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  IN [fdeep] - TRUE = go into sub-directories
//
//----------------------------------------------------------------------------
CFileEnumerate::CFileEnumerate(BOOL fdeep)
    : _fdeep(fdeep),
      _findeep(FALSE),
      _froot(FALSE),
      _fcannotaccess(FALSE),
      _pcfe(NULL),
      _pwfileposition(NULL),
      _handle(INVALID_HANDLE_VALUE)
{
    ENUMERATE_RETURNS((stderr, L"CFileEnumerate ctor\n"))
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   closes handles
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CFileEnumerate::~CFileEnumerate()
{
    if (_handle != INVALID_HANDLE_VALUE)
        FindClose(_handle);
    ENUMERATE_RETURNS((stderr, L"CFileEnumerate dtor (%ws)\n", _wpath))
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced. converts a ASCII file/path to a UNICODE
//              file/path, and gets the first file in the enumeration
//
//  Arguments:  IN  [filename]  - the path/file to enumerate
//              OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
/*
ULONG CFileEnumerate::Init(LPCWSTR filename, LPWSTR *wfilename, BOOL *fdir)
{
    // Initialize the file name
	int		iError = 0;

    if (filename && (wcslen(filename) < MAX_PATH))
    {
        // make it wchar
        WCHAR winfilename[MAX_PATH];

		iError = MultiByteToWideChar(	CP_ACP,
										MB_PRECOMPOSED,
										(LPTSTR) filename,
										-1,
										winfilename,
										wcslen( filename ) * 2
									);
		if (!iError)
		{	// error has occured during translation
			return( iError = GetLastError());
		}

		_pwfileposition = NULL;


        // finish initialization

        return(_ialize(winfilename, wfilename, fdir));
    }
    ENUMERATE_FAIL((stderr, "Init bad file name: %ld\n",ERROR_INVALID_NAME))
    return(ERROR_INVALID_NAME);
}
*/
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Init, public
//
//  Synopsis:   Same as previous, except takes UNICODE file/path as input
//
//  Arguments:  IN  [filename]  - the path/file to enumerate
//              OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Init(LPCWSTR filename, LPWSTR *wfilename, BOOL *fdir)
{
    // Initialize the file name

    if (filename && (wcslen(filename) < MAX_PATH))
    {
        return(_ialize(filename, wfilename, fdir));
    }
    ENUMERATE_FAIL((stderr, L"Init bad file name: %ld\n",ERROR_INVALID_NAME))
    return(ERROR_INVALID_NAME);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_ialize, private
//
//  Synopsis:   finishes initialization and starts search for first file in
//              the enumeration
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_ialize(LPCWSTR winfilename, LPWSTR *wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, L"Init start, path =  %ws\n", winfilename))
    ULONG ret = ERROR_SUCCESS;

    ENUMERATE_STAT((stderr, L"start path = %ws\n",winfilename))

    // save the location of the filename or wildcards

    ULONG cwcharcount;

    if (!(cwcharcount = GetFullPathName((LPCTSTR)winfilename,
                                       MAX_PATH,
                                       (LPTSTR)_wpath,
                                       (LPTSTR*)&_pwfileposition)))
    {
        return(ERROR_INVALID_NAME);
    }

    ENUMERATE_STAT((stderr, L"got full path name = %ws, filename = (%ws), total chars = %d\n",_wpath, _pwfileposition, cwcharcount))

    // if the filepart (_pwfileposition) is NULL, then the name must end in a slash.
    // add a *

    if (NULL == _pwfileposition)
    {
       _pwfileposition = (LPWSTR) Add2Ptr(_wpath,wcslen(_wpath)*sizeof(WCHAR));
    }

    // save the filename/wildcards

    wcscpy(_wwildcards, _pwfileposition);

    ENUMERATE_EXTRA((stderr, L"wild cards = %ws\n",_wwildcards))

    // if we are at a root (path ends in :\)
    if ( (_wpath[wcslen(_wpath) - 1] == L'\\') &&
         (wcslen(_wpath) > 1) &&
         (_wpath[wcslen(_wpath) - 2] == L':') )
    {
        _wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        _wfd.cFileName[0] = L'\0';
        *wfilename = _wpath;
        *fdir = TRUE;
        _froot = TRUE;
    } else
    {
    // check to see if we can iterate through files
		if ( (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile((LPCTSTR)_wpath, &_wfd ) ) ) ) 
        {
            ret = GetLastError();
            _fcannotaccess = (ERROR_ACCESS_DENIED == ret);
            
            ENUMERATE_FAIL((stderr, L"find first returned: %ld\n",ret))
        }
        if (ERROR_SUCCESS == ret)
        {	// reject . & .. filenames (go on to next file )
        
            if ( (0 == _wcsicmp(_wfd.cFileName, L".")) ||
                 (0 == _wcsicmp(_wfd.cFileName, L"..")) )
            {
                ret = _NextLocal(wfilename,fdir);
            } else
            {
                // return the current directory
        
                if (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    *fdir = TRUE;
                else
                    *fdir = FALSE;
        
                // add the filename to the path so the whole thing is returned
				//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
				//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
				//buffer _pwfileposition
				//
                HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,MAX_PATH - (_pwfileposition- _wpath), (LPCWSTR )_wfd.cFileName);
				if(FAILED(hr))
				{
					return HRESULT_CODE(hr);
				}
        
                *wfilename = _wpath;
            }
        }

        ENUMERATE_STAT((stderr, L"next filename = %ws\n", *wfilename))
    }

    // if we are going deep and we did not find a file yet:

    if ( _fdeep && ( ( ERROR_NO_MORE_FILES == ret ) ||
                     ( ERROR_FILE_NOT_FOUND == ret ) ) )
    {
        if (_handle != INVALID_HANDLE_VALUE)
        {
            FindClose(_handle);
            _handle = INVALID_HANDLE_VALUE;
        }
        ret = _InitDir(wfilename, fdir);
    }

    ENUMERATE_RETURNS((stderr, L"Init returning  =  %ws(%ld)\n\n", *wfilename, ret))
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Next, public
//
//  Synopsis:   finds the next file in the enumeration
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Next(LPWSTR *wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, L"Next start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_NO_MORE_FILES;

    // if we failed to initialize with an ERROR_ACCESS_DENIED, then exit
    if (_fcannotaccess)
        return(ERROR_NO_MORE_FILES);

    // if we are not in deep

    if (!_findeep)
    {
        if (!_froot)
           ret = _NextLocal(wfilename, fdir);

        // if we ran out of files and we are going deep:

        if ( _fdeep &&
             ( ( ERROR_NO_MORE_FILES == ret ) ||
               ( ERROR_FILE_NOT_FOUND == ret ) || _froot ) )
        {
            if (_handle != INVALID_HANDLE_VALUE)
            {
                FindClose(_handle);
                _handle = INVALID_HANDLE_VALUE;
            }
            ret = _InitDir(wfilename, fdir);
            _froot = FALSE; // (we are past the root now)
        }

    } else
    {
        // if we are already down a directory (and in deep)

        if (_pcfe)
        {
            if (ERROR_SUCCESS != (ret = _pcfe->Next(wfilename, fdir)))
            {
                if (ERROR_ACCESS_DENIED != ret)
                {
                    delete _pcfe;
                    _pcfe = NULL;
                }
            }
        }

        // we need to go to the next directory in the current dir

        if (ERROR_NO_MORE_FILES == ret)
        {
            ret = _NextDir(wfilename, fdir);
        }
    }
    ENUMERATE_RETURNS((stderr, L"Next returning  =  %ws(%ld)\n\n", *wfilename, ret))
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_NextLocal, private
//
//  Synopsis:   searchs for the next file in the current directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_NextLocal(LPWSTR *wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, L"_NextLocal start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // ensure that we have a valid handle for a findnextfile

    if (INVALID_HANDLE_VALUE == _handle)
    {
        ret = ERROR_INVALID_HANDLE;
    } else
    {
        do
        {
            if (!FindNextFile(_handle, &_wfd))
            {
                ret = GetLastError();
                ENUMERATE_FAIL((stderr, L"find next returned: %ld\n",ret))
            } else
                ret = ERROR_SUCCESS;
        }
        while ( (ERROR_SUCCESS == ret) &&
                ( (0 == _wcsicmp(_wfd.cFileName, L".")) ||
                  (0 == _wcsicmp(_wfd.cFileName, L"..")) ) );


        // if we found a file

        if (ERROR_SUCCESS == ret)
        {
            // return the directory attrib.

            if (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                *fdir = TRUE;
            else
                *fdir = FALSE;

			//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
			//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
			//buffer _pwfileposition
			//
			HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
									   MAX_PATH - (_pwfileposition- _wpath), 
									   (const wchar_t*)_wfd.cFileName);
			if(FAILED(hr))
			{
				return HRESULT_CODE(hr);
			}


            *wfilename = _wpath;

            ENUMERATE_STAT((stderr, L"next filename = %ws\n", *wfilename))
        }
    }
    ENUMERATE_RETURNS((stderr, L"_NextLocal returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_InitDir, private
//
//  Synopsis:   (only called if going deep)
//              goes down a directory (and thus causing a new CFileEnumerator
//              to be created, or re-initializies
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_InitDir(LPWSTR *wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, L"_InitDir start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // check and see if a directory was entered as the filename

    if ( (0 == _wcsicmp( _wwildcards, _wfd.cFileName)) &&
         (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
    {
        ENUMERATE_EXTRA((stderr, L"first file matched directory = %ws\n", _wpath))
        _pwfileposition += wcslen((LPWSTR)_wfd.cFileName);

		//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
		//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
		//buffer _pwfileposition
		//
		HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
									   MAX_PATH - (_pwfileposition- _wpath), 
									   L"\\*.*");
		if(FAILED(hr))
		{
			return HRESULT_CODE(hr);
		}

        _pwfileposition++;
        wcscpy(_wwildcards, L"*.*");
        ENUMERATE_EXTRA((stderr, L"      path = %ws\n",_wpath))
        ENUMERATE_EXTRA((stderr, L"wild cards = %ws\n",_wwildcards))

        WCHAR winfilename[MAX_PATH] = L"";
		hr = StringCchCopy((LPWSTR)winfilename,
								   MAX_PATH, 
								   _wpath);
		if(FAILED(hr))
		{
			return HRESULT_CODE(hr);
		}


        ret = _ialize(winfilename, wfilename, fdir);
    } else
    {

        // we are in deep

        _findeep = TRUE;

        // search thru all directories
		//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
		//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
		//buffer _pwfileposition
		//
		HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
								   MAX_PATH - (_pwfileposition- _wpath), 
								   L"*.*");
		if(FAILED(hr))
		{
			return HRESULT_CODE(hr);
		}

        if (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile((LPCTSTR)_wpath, &_wfd) ))
        {
            ret = GetLastError();
            ENUMERATE_FAIL((stderr, L"find first (dir) returned: %ld\n",ret))
        } else
        {
            if ( !(_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                 (0 == wcscmp(( LPCWSTR)_wfd.cFileName, L".")) ||
                 (0 == wcscmp(( LPCWSTR)_wfd.cFileName, L"..")) )
            {
                ret = _NextDir(wfilename, fdir);
            } else
            {
                // if we have a sub directory, go down it

                ret = _DownDir(wfilename, fdir);

                // if we found nothing in that first sub directory, go the the next one

                if ( (ERROR_NO_MORE_FILES == ret ) ||
                     (ERROR_FILE_NOT_FOUND == ret ) )
                {
                    ret = _NextDir(wfilename, fdir);
                }
            }
        }
    }
    ENUMERATE_RETURNS((stderr, L"_InitDir returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_NextDir, private
//
//  Synopsis:   (only called if going deep)
//              finds the next sub-directory from the current directory,
//              and then goes down into that directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_NextDir(LPWSTR *wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, L"_NextDir start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // skip the . & .. & files we cannot access

    if (INVALID_HANDLE_VALUE == _handle)
    {
        ret = ERROR_INVALID_HANDLE;
    } else
    {
        do
        {
            do
            {
                if (!FindNextFile(_handle, &_wfd))
                {
                    ret = GetLastError();
                    ENUMERATE_FAIL((stderr, L"find next returned: %ld\n",ret))
                } else
                    ret = ERROR_SUCCESS;
            }
            while ( (ERROR_SUCCESS == ret) &&
                    ( !(_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                      (0 == wcscmp(( LPCWSTR )_wfd.cFileName, L".")) ||
                      (0 == wcscmp(( LPCWSTR )_wfd.cFileName, L"..")) ) );

            // if we found a directory

            if (ERROR_SUCCESS == ret)
            {
                ret = _DownDir(wfilename, fdir);
            } else
            {
                // out of subdirectories to search, break out of the loop
                break;
            }
        }
        while (( ERROR_NO_MORE_FILES == ret) || (ERROR_FILE_NOT_FOUND == ret));
    }
    ENUMERATE_RETURNS((stderr, L"_NextDir returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_DownDir, private
//
//  Synopsis:   (only called if going deep)
//              creates a new CFileEnumerator for a sub-directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_DownDir(LPWSTR *wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, L"_DownDir start, path =  %ws\n", _wpath))
    ULONG ret;

    // make a new file enumerator class (this one) We should only go down
    // 8 directories at most.

    _pcfe = new CFileEnumerate(_fdeep);
	if ( NULL == _pcfe )
	{
		ret =  GetLastError () ;
		ENUMERATE_RETURNS((stderr, L"_DownDir returning  =  %ws(%ld)\n", *wfilename, ret ))
		return(ret);
	}

    // add the wildcards to the end of the directory we are going down

	//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
	//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
	//buffer _pwfileposition
	//
	HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
								MAX_PATH - (_pwfileposition- _wpath), 
								( const wchar_t *)_wfd.cFileName);
	if(FAILED(hr))
	{
		return HRESULT_CODE(hr);
	}

	hr = StringCchCat(_wpath,MAX_PATH,L"\\");
	if(FAILED(hr))
	{
		return HRESULT_CODE(hr);
	}

    hr = StringCchCat(_wpath,MAX_PATH, _wwildcards);
	if(FAILED(hr))
	{
		return HRESULT_CODE(hr);
	}

    // start it up and see if we find a match

    if (ERROR_SUCCESS != (ret = _pcfe->Init(_wpath, wfilename, fdir)))
    {
        if (ERROR_ACCESS_DENIED != ret)
        {
            delete _pcfe;
            _pcfe = NULL;
        }
    }
    ENUMERATE_RETURNS((stderr, L"_DownDir returning  =  %ws(%ld)\n", *wfilename, ret))
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\filesec.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        filesec.cxx
//
// Classes:     CFileSecurity class encapsulating SECURITY_DESCRIPTOR
//
// History:     Nov-93      DaveMont         Created.
//              Oct-96      BrunoSc          Modified
//
//-------------------------------------------------------------------
#include "pch.h"
#include "filesec.hxx"
#include "caclsmsg.h"
//+---------------------------------------------------------------------------
// Function:    Add2Ptr
//
// Synopsis:    Add an unscaled increment to a ptr regardless of type.
//
// Arguments:   [pv]	-- Initial ptr.
//              [cb]	-- Increment
//
// Returns:     Incremented ptr.
//
//----------------------------------------------------------------------------
VOID * Add2Ptr(VOID *pv, ULONG cb)
{
    return((BYTE *) pv + cb);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::CFileSecurity, public
//
//  Synopsis:   initializes data members
//              constructor will not throw
//
//  Arguments:  [filename] - name of file to apply security descriptor to
//
//----------------------------------------------------------------------------
CFileSecurity::CFileSecurity(LPWSTR filename)
    : _psd(NULL),
      _pwfilename(filename)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced.  gets security descriptor from file
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
ULONG CFileSecurity::Init()
{
    ULONG ret;
    ULONG cpsd;

    // get the size of the security buffer
    if (!GetFileSecurity((LPCTSTR)_pwfilename,
                         DACL_SECURITY_INFORMATION |
                         GROUP_SECURITY_INFORMATION |
                         OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &cpsd) )
    {
        if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
        {
            if (NULL == (_psd = (BYTE *)LocalAlloc(LMEM_FIXED, cpsd)))
            {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            }

            // actually get the buffer this time

            if ( GetFileSecurity((LPCTSTR)_pwfilename,
                                 DACL_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 OWNER_SECURITY_INFORMATION,
                                 _psd,
                                 cpsd,
                                 &cpsd) )
                ret = ERROR_SUCCESS;
            else
                ret = GetLastError();

        }
// the following section was inserted to test an error when access to a file
// has been denied
		else
		{	if (ret == ERROR_ACCESS_DENIED)
			{	return(ret);
			}
		}

    } else
		return(ERROR_NO_SECURITY_ON_OBJECT);

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees security descriptor if allocated
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CFileSecurity::~CFileSecurity()
{
    if (_psd)
    {
        LocalFree(_psd);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::SetFS, public
//
//  Synopsis:   sets or modifies the security descriptor DACL on the specified file
//
//  Arguments:  IN - [fmodify] - TRUE = modify ACL, FALSE = replace ACL
//              IN - [pcdw]    - wrapper around new ACEs
//              IN - [fdir]    - TRUE = directory
//
//  Returns:    status
//
//----------------------------------------------------------------------------
ULONG CFileSecurity::SetFS(BOOL fmodify, CDaclWrap *pcdw, BOOL fdir)
{
   BOOL fdaclpresent;
   BOOL cod;
   ACL *pdacl;
   ULONG ret;

   // get the ACL from the security descriptor

   if ( GetSecurityDescriptorDacl(_psd,
                                  &fdaclpresent,
                                  &pdacl,
                                  &cod) )

   {
       if (fdaclpresent)
       {
           // build the new ACL (from the new ACEs and the old ACL)

           PACL pnewdacl = NULL;

           if (ERROR_SUCCESS == (ret = pcdw->BuildAcl(&pnewdacl,
                                                      fmodify ? pdacl : NULL,
                                                      pdacl ? pdacl->AclRevision : ACL_REVISION,
                                                      fdir)
                                                      ))
           {
               // make a new security descriptor

               SECURITY_DESCRIPTOR newsd;
					//NTRAID#NTBUG9-547532-2002/03/28-hiteshr
               if(!InitializeSecurityDescriptor( &newsd, SECURITY_DESCRIPTOR_REVISION ))
					{
						LocalFree(pnewdacl);
						return GetLastError();
					}

               if(!SetSecurityDescriptorDacl( &newsd, TRUE, pnewdacl, FALSE ))
					{
						LocalFree(pnewdacl);
						return GetLastError();
					}

               //
               // apply it to the file
               //

               if (!SetFileSecurity(_pwfilename,
                                    DACL_SECURITY_INFORMATION,
                                    &newsd))
               {
                   ret = GetLastError();
               }
               LocalFree(pnewdacl);
           }
       }
       else
           return(ERROR_NO_SECURITY_ON_OBJECT);
    } else
    {
        ret = GetLastError();
    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\pch.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		pch.h

	Abstract:

		This header file is a precompiled header for this project.
		This module contains the common include files [ system,user defined ]
		which are not changed frequently.

	Author:

		Venu Gopal Choudary	 10-July-2001 : Created it

	Revision History:

			
******************************************************************************/ 


#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000	// include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// public Windows header files
//
#include <windows.h>
#include <security.h>

// public C header files
//
#include <stdio.h>
#include <tchar.h>
#include <shlwapi.h>

//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\xcacls.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation.
//
// File:        t2.cxx
//
// Contents:
//
// Classes:
//
// History:     Nov-93      DaveMont         Created.
//              Oct-96      Modified         BrunoSc
//				Aug-01      Modified         Wipro Technologies
//
//-------------------------------------------------------------------
#include "pch.h"
#include "t2.hxx"
#include "filesec.hxx"
#include "fileenum.hxx"
#include "dumpsec.hxx"
#include "caclsmsg.h"
#include "locale.h"
#include "winnlsp.h"

#if DBG
ULONG Debug = 1;
#endif
//+----------------------------------------------------------------------------
//
// local prototypes
//
//+----------------------------------------------------------------------------
BOOL OpenToken(PHANDLE ph);
void printfsid(SID *psid, ULONG *outputoffset);
void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset);
void printfmask(ULONG mask, WCHAR acetype, BOOL fdir, ULONG outputoffset);
LPWSTR mbstowcs(LPCWSTR aname );
BOOL GetUserAndAccess(LPCWSTR arg, LPWSTR *user, ULONG *access, ULONG *dirmask, BOOL *filespec);
#if DBG
ULONG DebugEnumerate(LPCWSTR filename, ULONG option);
#endif
ULONG DisplayAces(LPCWSTR filename, ULONG option);
ULONG ModifyAces(LPCWSTR filename,
                 MODE emode,
                 ULONG option,
                 LPCWSTR argv[],
                 LONG astart[], LONG aend[] );
ULONG GetCmdLineArgs(DWORD argc, LPCWSTR argv[],
                     ULONG *option,
                     LONG astart[], LONG aend[],
                     MODE *emode
#if DBG
                     ,ULONG *debug
#endif
                     );
ULONG  printmessage (FILE* fp, DWORD messageID, ...);
//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints usage functionality
//
//  Arguments: none
//
//----------------------------------------------------------------------------
VOID usage()
{
    printmessage(stdout, MSG_CACLS_USAGE, NULL);

#if DBG
    if (Debug)
    {
        printf("\n   /B            deBug <[#]>\n");
        printf("                 default is display error returned\n");
        printf("                 in /B '#' is a mask: 1  display SIDS values\n");
        printf("                                      2  display access masks\n");
        printf("                                      4  display error returned\n");
        printf("                                      8  display error location\n");
        printf("                                   0x10  verbose\n");
        printf("                                   0x20  verboser\n");
        printf("                                   0x40  enumerate names\n");
        printf("                                   0x80  enumerate failures\n");
        printf("                                  0x100  enumerate starts and returns\n");
        printf("                                  0x200  enumerate extra data\n");
        printf("                                  0x400  size allocation data\n");
        printf("                                  0x800  display enumeration of files\n");
    }
#endif
}
//+----------------------------------------------------------------------------
//
//  Function:     Main, Public
//
//  Synopsis:     main!!
//
//  Arguments:    IN [argc] - cmdline arguement count
//                IN [argv] - input cmdline arguements
//
//----------------------------------------------------------------------------
VOID __cdecl wmain(DWORD argc, LPCWSTR argv[])
{
    //
    // Set the local to system OEM code page.
    //
    setlocale(LC_ALL, ".OCP" );
	SetThreadUILanguage(0);

    LONG astart[MAX_OPTIONS], aend[MAX_OPTIONS];
    MODE emode;

    ULONG ret;
    ULONG option;

    if (ERROR_SUCCESS != (ret = GetCmdLineArgs(argc, argv,
                                               &option,
                                               astart, aend,
                                               &emode
#if DBG
                                               ,&Debug
#endif
                                               )))
    {
        usage();
        exit(ret);
    }

    switch (emode)
    {
        case MODE_DISPLAY:
            ret = DisplayAces(argv[1], option);
            break;
        case MODE_REPLACE:
        case MODE_MODIFY:
		case MODE_MODIFY_EXCLUSIVE:
            ret = ModifyAces(argv[1], emode, option, argv, astart, aend );
            break;
#if DBG
        case MODE_DEBUG_ENUMERATE:
            ret = DebugEnumerate(argv[1], option);
            break;
#endif
        default:
        {
            usage();
            exit(1);
        }
    }
    if (ERROR_SUCCESS != ret)
    {
        LAST_ERROR((stderr, L"Cacls failed, %ld\n",ret))
        fwprintf ( stderr, L"ERROR: ");
		printmessage(stderr, ret, NULL);
	}

    exit(ret);
}
//---------------------------------------------------------------------------
//
//  Function:     GetCmdLineArgs
//
//  Synopsis:     gets and parses command line arguments into commands
//                recognized by this program
//
//  Arguments:    IN  [argc]   - cmdline arguement count
//                IN  [argv]   - input cmdline arguements
//                OUT [option] - requested option
//                OUT [astart] - start of arguments for each option
//                OUT [aend]   - end of arguments for each option
//                OUT [emode]  - mode of operation
//                OUT [debug]  - debug mask
//
//
//----------------------------------------------------------------------------
ULONG GetCmdLineArgs(DWORD argc, LPCWSTR argv[],
                     ULONG *option,
                     LONG astart[], LONG aend[],
                     MODE *emode
#if DBG
                     ,ULONG *debug
#endif
                     )
{
    ARG_MODE_INDEX am = ARG_MODE_INDEX_NEED_OPTION;

#if DBG
    *debug = 0;
#endif
    *emode = MODE_DISPLAY;
    *option = 0;
	LPWSTR pszBuffer = NULL;

    for (DWORD j=0; j < MAX_OPTIONS ;j++ )
    {
        astart[j] = 0;
        aend[j] = 0;
    }

    if ( (argc < 2) || (argv[1][0] == L'/') )
    {
#if DBG
        // do this so debug args are printed out

        if (argc >= 2)
        {
            if ( (0 == _wcsicmp(&argv[1][1], L"deBug")) ||
                 (0 == _wcsicmp(&argv[1][1], L"b"))  )
            {
                *debug = DEBUG_LAST_ERROR;
            }
        }
#endif
        return(ERROR_BAD_ARGUMENTS);
    }

    for (DWORD k = 2; k < argc ; k++ )
    {
        //wprintf (L"%s", &argv[k][0] );
		if (argv[k][0] == L'/')
        {
            switch (am)
            {
                case ARG_MODE_INDEX_NEED_OPTION:
#if DBG
                case ARG_MODE_INDEX_DEBUG:
#endif
                    break;

                case ARG_MODE_INDEX_DENY:
                case ARG_MODE_INDEX_REVOKE:
                case ARG_MODE_INDEX_GRANT:
                case ARG_MODE_INDEX_REPLACE:
                    if (astart[am] == k)
                        return(ERROR_BAD_ARGUMENTS);
                    break;

                default:
                    return(ERROR_BAD_ARGUMENTS);
            }

            if ( (0 == _wcsicmp(&argv[k][1], L"Tree")) ||
                 (0 == _wcsicmp(&argv[k][1], L"t")) )
            {
                if (*option & OPTION_TREE)
                    return(ERROR_BAD_ARGUMENTS);
                *option |= OPTION_TREE;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

            if ( (0 == _wcsicmp(&argv[k][1], L"Continue")) ||
                 (0 == _wcsicmp(&argv[k][1], L"c")) )
            {
                if (*option & OPTION_CONTINUE_ON_ERROR)
                    return(ERROR_BAD_ARGUMENTS);
                *option |= OPTION_CONTINUE_ON_ERROR;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

            if ( (0 == _wcsicmp(&argv[k][1], L"Edit")) ||
                 (0 == _wcsicmp(&argv[k][1], L"E")) )
            {
                if (*emode != MODE_DISPLAY)
                    return(ERROR_BAD_ARGUMENTS);
                *emode = MODE_MODIFY;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }
			//a-henry
			
			if ( (0 == _wcsicmp(&argv[k][1], L"EditX")) ||
                 (0 == _wcsicmp(&argv[k][1], L"X")) )
            {
                if (*emode != MODE_DISPLAY)
                    return(ERROR_BAD_ARGUMENTS);
                *emode = MODE_MODIFY_EXCLUSIVE;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }
			//a-henry
            if ( (0 == _wcsicmp(&argv[k][1], L"Yes")) ||
                 (0 == _wcsicmp(&argv[k][1], L"Y")) )
            {
                if (*emode & OPTION_CONTINUE_ON_REPLACE)
                    return(ERROR_BAD_ARGUMENTS);
                *option |= OPTION_CONTINUE_ON_REPLACE;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

#if DBG
            if ( (0 == _wcsicmp(&argv[k][1], L"deBug")) ||
                 (0 == _wcsicmp(&argv[k][1], L"b"))  )
            {
                if (*debug)
                    return(ERROR_BAD_ARGUMENTS);
                am = ARG_MODE_INDEX_DEBUG;
                *debug = DEBUG_LAST_ERROR;
                continue;
            }
#endif
            if ( (0 == _wcsicmp(&argv[k][1], L"Deny")) ||
                 (0 == _wcsicmp(&argv[k][1], L"D")) )
            {
                am = ARG_MODE_INDEX_DENY;
                *option |= OPTION_DENY;
            } else if ( (0 == _wcsicmp(&argv[k][1], L"Revoke")) ||
                        (0 == _wcsicmp(&argv[k][1], L"R")) )
            {
                am = ARG_MODE_INDEX_REVOKE;
                *option |= OPTION_REVOKE;
            } else if ( (0 == _wcsicmp(&argv[k][1], L"Grant")) ||
                        (0 == _wcsicmp(&argv[k][1], L"G")) )
            {
                am = ARG_MODE_INDEX_GRANT;
                *option |= OPTION_GRANT;
            } else if ( (0 == _wcsicmp(&argv[k][1], L"rePlace")) ||
                        (0 == _wcsicmp(&argv[k][1], L"P")) )
            {
                *option |= OPTION_REPLACE;
                am = ARG_MODE_INDEX_REPLACE;
            } else
                return(ERROR_BAD_ARGUMENTS);

            if (astart[am] != 0)
                return(ERROR_BAD_ARGUMENTS);
            astart[am] = k+1;
        } else
        {
            switch (am)
            {
                case ARG_MODE_INDEX_NEED_OPTION:
                    return(ERROR_BAD_ARGUMENTS);

#if DBG
                case ARG_MODE_INDEX_DEBUG:
                    *debug = wcstol(argv[k], &pszBuffer, 10 );
					if ( wcslen (pszBuffer) )
					{
						 return(ERROR_BAD_ARGUMENTS);
					}
                    if (*debug & DEBUG_ENUMERATE)
                        if (*emode == MODE_DISPLAY)
                            *emode = MODE_DEBUG_ENUMERATE;
                        else
                            return(ERROR_BAD_ARGUMENTS);

                    am = ARG_MODE_INDEX_NEED_OPTION;
                    break;
#endif
                case ARG_MODE_INDEX_DENY:
                case ARG_MODE_INDEX_REVOKE:
                case ARG_MODE_INDEX_GRANT:
                case ARG_MODE_INDEX_REPLACE:
                    aend[am] = k+1;
                    break;

                default:
                    return(ERROR_BAD_ARGUMENTS);
            }
        }
    }

    if ( ( (*option & OPTION_DENY) && (aend[ARG_MODE_INDEX_DENY] == 0) ) ||
         ( (*option & OPTION_REVOKE) && (aend[ARG_MODE_INDEX_REVOKE] == 0) ) ||
         ( (*option & OPTION_GRANT) && (aend[ARG_MODE_INDEX_GRANT] == 0) ) ||
         ( (*option & OPTION_REPLACE) && (aend[ARG_MODE_INDEX_REPLACE] == 0) ) )
    {
        return(ERROR_BAD_ARGUMENTS);
    } else if ( (*option & OPTION_DENY) ||
                (*option & OPTION_REVOKE) ||
                (*option & OPTION_GRANT) ||
                (*option & OPTION_REPLACE) )
    {
        if (*emode == MODE_DISPLAY)
            *emode = MODE_REPLACE;
    }
    return(ERROR_SUCCESS);
}

//---------------------------------------------------------------------------
//
//  Function:     DisplayAces
//
//  Synopsis:     displays ACL from specified file
//
//  Arguments:    IN [filename] - file name
//                IN [option]   - display option
//
//----------------------------------------------------------------------------
ULONG DisplayAces(LPCWSTR filename, ULONG option)
{
    CFileEnumerate cfe(option & OPTION_TREE);
    LPWSTR pwfilename = NULL;
    BOOL fdir;
    ULONG ret;

    if (NO_ERROR == (ret = cfe.Init(filename, &pwfilename, &fdir)))
    {
        while ( (NO_ERROR == ret) ||
                ( (ERROR_ACCESS_DENIED == ret ) &&
                  (option & OPTION_CONTINUE_ON_ERROR) ) )
        {
#if DBG
            if (fdir)
                DISPLAY((stderr, L"processing file: "))
            else
                DISPLAY((stderr, L"processing dir: "))
#endif
            fwprintf(stdout, L"%ws",pwfilename);
            if (ERROR_ACCESS_DENIED == ret)
            {
                printmessage(stdout,MSG_CACLS_ACCESS_DENIED, NULL);
            } else
            {
                DISPLAY((stderr, L"\n"))
                VERBOSE((stderr, L"\n"))
                CDumpSecurity cds(pwfilename);

                if (NO_ERROR == (ret = cds.Init()))
                {
#if DBG
                    if (Debug & DEBUG_VERBOSE)
                    {
                        SID *psid;
                        ULONG oo;

                        if (NO_ERROR == (ret = cds.GetSDOwner(&psid)))
                        {
                            wprintf(L"  Owner = ");
                            printfsid(psid, &oo);
                            if (NO_ERROR == (ret = cds.GetSDGroup(&psid)))
                            {
                                wprintf(L"  Group = ");
                                printfsid(psid, &oo);
                            }
                            else
                                ERRORS((stderr, L"GetSDGroup failed, %d\n",ret))
                        }
                        else
                            ERRORS((stderr, L"GetSDOwner failed, %d\n",ret))
                    }
#endif

                    if(cds.IsDaclNull())
                    {
                        printmessage(stdout,MSG_NULL_DACL, NULL);
                    }
                    else
                    {
                        ACE_HEADER *paceh;

                        LONG retace;
                        if (NO_ERROR == ret)
                            for (retace = cds.GetNextAce(&paceh); retace >= 0; )
                            {
                                printface(paceh, fdir, wcslen(pwfilename));
                                retace = cds.GetNextAce(&paceh);
                                if (retace >= 0)
                                    wprintf(L"%*s",wcslen(pwfilename),L" ");
                            }
                        }
                }
#if DBG
                   else
                    ERRORS((stderr, L"cds.init failed, %d\n",ret))
#endif
            }
            fwprintf(stdout, L"\n");

            if ( (NO_ERROR == ret) ||
                 ( (ERROR_ACCESS_DENIED == ret ) &&
                   (option & OPTION_CONTINUE_ON_ERROR) ) )
                ret = cfe.Next(&pwfilename, &fdir);
        }

        switch (ret)
        {
            case ERROR_NO_MORE_FILES:
                ret = ERROR_SUCCESS;
                break;
           case ERROR_ACCESS_DENIED:
                break;
            case ERROR_SUCCESS:
                break;
            default:
                break;
        }

    } else
    {
        ERRORS((stderr, L"cfe.init failed, %d\n",ret))
    }
    return(ret);
}
/*
BOOL FindExistingUser(ACL* poldacl, CDaclWrop* cdw)
{
	for (ULONG cace = 0; cace < poldacl->AceCount;
                     cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
	{
		if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
		{
			if (EqualSid(psid,
		                (SID *)&((ACCESS_ALLOWED_ACE *)pah)->SidStart) )
					return TRUE;
		}				
	
	}
                       
	return FALSE;
}
*/
//---------------------------------------------------------------------------
//
//  Function:     ModifyAces
//
//  Synopsis:     modifies the aces for the specified file(s)
//
//  Arguments:    IN [filename] - name of file(s) to modify the aces on
//                IN [emode]  - mode of operation
//                IN [option] - requested option
//                IN [astart] - start of arguments for each option
//                IN [aend]   - end of arguments for each option
//
//----------------------------------------------------------------------------
ULONG ModifyAces(LPCWSTR filename,
                 MODE emode,
                 ULONG option,
                 LPCWSTR argv[],
                 LONG astart[], LONG aend[])
{
    CDaclWrap cdw;
    CFileEnumerate cfe(option & OPTION_TREE);
    LPWSTR user = NULL;
    ULONG access;
	ULONG dirmask;
	BOOL  filespec;
    ULONG ret = ERROR_SUCCESS;
    LPWSTR pwfilename;
    ULONG curoption;

    VERBOSER((stderr, L"user:permission pairs\n"))

    // first proces the command line args to build up the new ace
	cdw._EditMode = emode;
    for (ULONG j = 0, k = 1;j < MAX_OPTIONS ; k <<= 1, j++ )
    {
        curoption = k;
        if (option & k)
        {
            for (LONG q = astart[j];
                      q < aend[j] ; q++ )
            {
                VERBOSER((stderr, L"      %s\n",argv[q]))

                if ((k & OPTION_GRANT) || (k & OPTION_REPLACE))
                {
                    filespec = FALSE;
					if (!GetUserAndAccess(argv[q], &user, &access, &dirmask, &filespec))
                    {
                        //if (user)
                        //    LocalFree(user);
                        return(ERROR_BAD_ARGUMENTS);
                    }
                    if (GENERIC_NONE == access)
                    {
                        if (k & OPTION_REPLACE)
                        {
                            curoption = OPTION_DENY;
                        } else
                        {
                                //if (user)
                                //LocalFree(user);
                            return(ERROR_BAD_ARGUMENTS);
                        }
                    }
                } else
                {
                    user = (LPWSTR ) (argv[q]);
                    access = GENERIC_NONE;
                }

                VERBOSER((stderr, L"OPTION = %d, USER = %ws, ACCESS = %lx, DIR = %lx\n",
                       option,
                       user,
                       access,
					   dirmask ))


                if (ERROR_SUCCESS != (ret = cdw.SetAccess(curoption,
                                                     user,
                                                     NULL,
                                                     access,
													 dirmask,
													 filespec )))
                {
                    ERRORS((stderr, L"SetAccess for %ws:%lx;%lx failed, %d\n",
                           user,
                           access,
						   dirmask,
                           ret))

                    //LocalFree(user);
                    return(ret);
                }
                //LocalFree(user);
                user = NULL;
            }
        }
    }

    BOOL fdir;

    if (emode == MODE_REPLACE)
    {	if (!(option & OPTION_CONTINUE_ON_REPLACE))
		{	
		    WCHAR well[MAX_PATH] = L"";
			WCHAR msgbuf[MAX_PATH] = L"";
			WCHAR tmpmsgbuf[MAX_PATH] = L"";
			printmessage(stdout,MSG_CACLS_ARE_YOU_SURE, NULL);
			FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_Y, NULL,
						  msgbuf, MAX_PATH, NULL);
			
			ZeroMemory ( well, MAX_PATH );
			
			if(!fgetws(well,MAX_PATH,stdin))
			{
				int err = 0;
				if((err  = ferror(stdin)))
					return err;
				return ERROR_INVALID_PARAMETER;
			}

			
			if ( L'\n' == well[ wcslen (well) - 1] )
			well[ wcslen (well) - 1] = L'\0';
			
			if (0 != _wcsicmp(well, msgbuf))
			{
				FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_YES, 0,
							  msgbuf, MAX_PATH, NULL); 

				FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_NO, 0,
							  tmpmsgbuf, MAX_PATH, NULL); 

				if (0 == _wcsicmp(well, tmpmsgbuf))
				{
					printmessage(stdout, MSG_OPERATION_CANCEL, NULL);
					return(ERROR_SUCCESS);
				}
				else if (0 != _wcsicmp(well, msgbuf))
				{
					return(MSG_WRONG_INPUT);
				}
			}
		}
    }

    if (NO_ERROR == (ret = cfe.Init(filename, &pwfilename, &fdir)))
    {
        while ( (NO_ERROR == ret) ||
                ( (ERROR_ACCESS_DENIED == ret ) &&
                  (option & OPTION_CONTINUE_ON_ERROR) ) )
        {
            CFileSecurity cfs(pwfilename);

            if (NO_ERROR == (ret = cfs.Init()))
            {
				if (NO_ERROR != (ret = cfs.SetFS(emode == MODE_REPLACE ? FALSE : TRUE, &cdw, fdir)))
                {
                    ERRORS((stderr, L"SetFS on %ws failed %ld\n",pwfilename, ret))
                 //   return(ret);
                }
            } else
            {	// continue modifying ACLs only if we receive an access denied error
				if ((ret != ERROR_SHARING_VIOLATION) && (ret != ERROR_ACCESS_DENIED) && (option & OPTION_CONTINUE_ON_ERROR))
				{	ERRORS((stderr, L"init failed, %d\n",ret))
				//	return(ret);
				}
            }

            if (fdir)
            {
				LPTSTR	sFilename = NULL;

				/*WideCharToMultiByte(	CP_UTF8,
										0,
										pwfilename,
										-1,
										(LPTSTR) sFilename,
										MAX_PATH,
										NULL,
										NULL	); */

				printmessage(stdout, MSG_CACLS_PROCESSED_DIR, NULL);
                fwprintf(stdout, L"%s\n", pwfilename);
            }
            else
            {
                switch (ret)
				{	case ERROR_SHARING_VIOLATION:
						printmessage(stdout, MSG_SHARING_VIOLATION, NULL);
						ret = ERROR_ACCESS_DENIED;
						break;
					case ERROR_ACCESS_DENIED:
						printmessage(stdout, MSG_ACCESS_DENIED, pwfilename);
						ret = ERROR_ACCESS_DENIED;
						break;
					default:
						printmessage(stdout, MSG_CACLS_PROCESSED_FILE, NULL);
						break;
				}

				// now convert the string two times again to ensure proper display of 
				// german umlaute. (probably another more elegant way??)
				LPTSTR	sFilename = NULL;
				LPCTSTR	szFile = NULL;

				/*WideCharToMultiByte(	CP_UTF8,
										0,
										pwfilename,
										-1,
										(LPSTR) sFilename,
										MAX_PATH,
										szFile,
										TRUE	); */

                fwprintf(stdout, L" %s\n", pwfilename);
            }

            if ( (NO_ERROR == ret) ||
                 ( (ERROR_ACCESS_DENIED == ret ) &&
                   (option & OPTION_CONTINUE_ON_ERROR) ) )
                ret = cfe.Next(&pwfilename, &fdir);
        }

        switch (ret)
        {
            case ERROR_NO_MORE_FILES:
                ret = ERROR_SUCCESS;
                break;
            case ERROR_ACCESS_DENIED:
                break;
            case ERROR_SUCCESS:
                break;
            default:
                DISPLAY((stderr, L"%ws failed: %d\n", pwfilename, ret))
                break;
        }
    } else
        ERRORS((stderr, L"file enumeration failed to initialize %ws, %ld\n",pwfilename, ret))

    if (ret == ERROR_NO_MORE_FILES)
    {
        ret = ERROR_SUCCESS;
    }

    if (ret != ERROR_SUCCESS)
    {
        ERRORS((stderr, L"Enumeration failed, %d\n",ret))
    }

    return(ret);
}
#if DBG
//---------------------------------------------------------------------------
//
//  Function:     DebugEnumerate
//
//  Synopsis:     debug function
//
//  Arguments:    IN [filename] - file name
//                IN [option]   - option
//
//----------------------------------------------------------------------------
ULONG DebugEnumerate(LPCWSTR filename, ULONG option)
{
    CFileEnumerate cfe(option & OPTION_TREE);
    LPWSTR pwfilename = NULL;
    BOOL fdir;
    ULONG ret;

    ret = cfe.Init(filename, &pwfilename, &fdir);
    while ( (ERROR_SUCCESS == ret) ||
            ( (ERROR_ACCESS_DENIED == ret ) &&
              (option & OPTION_CONTINUE_ON_ERROR) ) )
    {
        if (fdir)
            wprintf(L"dir  name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        else
            wprintf(L"file name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        ret = cfe.Next(&pwfilename, &fdir);
    }
    if (ret == ERROR_ACCESS_DENIED)
    {
        if (fdir)
            wprintf(L"dir  name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        else
            wprintf(L"file name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
    }
    if (ret != ERROR_NO_MORE_FILES)
        wprintf(L"Enumeration failed, %d\n",ret);

    return(ret);
}
#endif
//---------------------------------------------------------------------------
//
//  Function:     GetUserAccess
//
//  Synopsis:     parses an input string for user:access
//
//  Arguments:    IN  [arg]     - input string to parse
//                OUT [user]    - user if found
//                OUT [access]  - access if found
//                OUT [dirmask] - access for directory if found
//                                else set to [access]
//                OUT [filespec]- if TRUE, only dir ACE will be written, no
//                                file inheritence ACE (necessary for LIST etc.)
//
//----------------------------------------------------------------------------
BOOL GetUserAndAccess(LPCWSTR arg, LPWSTR *user, ULONG *access, ULONG *dirmask, BOOL *filespec)

{	ULONG	*mask;
	BOOL	bChanged;
    
	LPWSTR saccess = wcschr(arg, L':');

    if (saccess)
    {
        *saccess = NULL;
		bChanged = FALSE;
		mask	 = access;
		*mask	 = 0;
		saccess++;

        if (wcschr(saccess, L':'))
            return(FALSE);
        
		*user = (LPWSTR) arg;

		// Enter the loop for access rights
		while (	(*saccess == L'N') ||
				(*saccess == L'n') ||
				(*saccess == L'R') ||
				(*saccess == L'r') ||
				(*saccess == L'C') ||
				(*saccess == L'c') ||
				(*saccess == L'F') ||
				(*saccess == L'f') ||
				(*saccess == L'P') ||
				(*saccess == L'p') ||
				(*saccess == L'O') ||
				(*saccess == L'o') ||
				(*saccess == L'X') ||
				(*saccess == L'x') ||
				(*saccess == L'E') ||
				(*saccess == L'e') ||
				(*saccess == L'W') ||
				(*saccess == L'w') ||
				(*saccess == L'D') ||
				(*saccess == L'd') ||
				(*saccess == L'T') ||
				(*saccess == L't') ||
				(*saccess == L';'))
		{	if ((*saccess == L'F') || (*saccess == L'f'))
			{
				*mask |= ( STANDARD_RIGHTS_ALL |
							FILE_READ_DATA |
							FILE_WRITE_DATA |
							FILE_APPEND_DATA |
							FILE_READ_EA |
							FILE_WRITE_EA |
							FILE_EXECUTE |
							FILE_DELETE_CHILD |
							FILE_READ_ATTRIBUTES |
							FILE_WRITE_ATTRIBUTES );
			}
			else if ((*saccess == L'R') || (*saccess == L'r'))
			{
				if (bChanged)
					*mask |= READ_CONTROL | SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_EXECUTE | FILE_READ_DATA | FILE_EXECUTE | FILE_READ_EA | FILE_READ_ATTRIBUTES;
				else
					*mask |= FILE_GENERIC_READ | FILE_EXECUTE;
			}
			else if ((*saccess == L'C') || (*saccess == L'c'))
			{
				*mask |= FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE;
			}
			else if ((*saccess == L'N') || (*saccess == L'n'))
			{
				*mask |= GENERIC_NONE;
			}
			else if ((*saccess == L'P') || (*saccess == L'p'))
			{
				*mask |= WRITE_DAC;
			}
			else if ((*saccess == L'O') || (*saccess == L'o'))
			{
				*mask |= WRITE_OWNER;
			}
			else if ((*saccess == L'X') || (*saccess == L'x'))
			{
				if (bChanged)
					*mask |= READ_CONTROL | SYNCHRONIZE | FILE_GENERIC_EXECUTE | FILE_EXECUTE | FILE_READ_ATTRIBUTES;
				else
					*mask |= GENERIC_EXECUTE;
			} 
			else if ((*saccess == L'E') || (*saccess == L'e'))
			{	if (bChanged)
					*mask |= READ_CONTROL | SYNCHRONIZE | FILE_GENERIC_READ | FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES;
				else
					*mask |= FILE_GENERIC_READ;
			}
			else if ((*saccess == L'W') || (*saccess == L'w'))
			{
				if (bChanged)   
					*mask |= READ_CONTROL | SYNCHRONIZE | FILE_GENERIC_WRITE | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES;
				else
					*mask |= FILE_GENERIC_WRITE;
			}
			else if ((*saccess == L'D') || (*saccess == L'd'))
			{
				*mask |= DELETE;
			}
			else if ((*saccess == L'T') || (*saccess == L't'))
			{
				if (!bChanged) 
					return (FALSE);
				else
				{	*filespec = TRUE;
				    *mask     = 0;
					
					// at least one option has to follow
				    if ((*(saccess+1) == ' ') || (*(saccess+1) == 0) || (*(saccess+1) == '/'))
						return (FALSE);
				}
			}
			else if (*saccess == ';')
			{
				mask = dirmask;
				bChanged = TRUE;
				*mask = 0;
			} else
				return(FALSE);

			saccess++;
		}

		if (!bChanged) 
			*dirmask = *access;

		if ((*saccess == L' ') || (*saccess == 0) || (*saccess == L'/'))
			return(TRUE);
    }
    return(FALSE);
}
//---------------------------------------------------------------------------
//
//  Function:     mbstowcs
//
//  Synopsis:     converts char to wchar, allocates space for wchar
//
//  Arguments:    IN [aname] - char string
//
//----------------------------------------------------------------------------
LPWSTR mbstowcs(LPCWSTR aname )
{
    if (aname)
    {
        LPCWSTR pwname = NULL;
        pwname = (LPCWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * (wcslen(aname)+1));
        if (NULL == pwname)
            return(NULL);
        
		LPWSTR prwname = (LPWSTR) pwname;
        for (; prwname = (LPWSTR) aname; prwname++,aname++  );
        return((LPWSTR)pwname);
    } else
        return(NULL);
}
//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//----------------------------------------------------------------------------
BOOL OpenToken(PHANDLE ph)
{
    HANDLE hprocess;

    hprocess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    if (hprocess == NULL)
        return(FALSE);

    if (OpenProcessToken(hprocess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ph))
    {
        CloseHandle(hprocess);
        return(TRUE);
    }

    CloseHandle(hprocess);
    return(FALSE);
}
//----------------------------------------------------------------------------
//
//  Function:     printfsid
//
//  Synopsis:     prints a NT SID
//
//  Arguments:    IN [psid] - pointer to the sid to print
//
//----------------------------------------------------------------------------
void printfsid(SID *psid, ULONG *outputoffset)
{
#if DBG
    if ((Debug & DEBUG_VERBOSE) || (Debug & DEBUG_DISPLAY_SIDS))
    {
        wprintf(L"S-%lx",psid->Revision);

        if ( (psid->IdentifierAuthority.Value[0] != 0) ||
             (psid->IdentifierAuthority.Value[1] != 0) )
        {
            wprintf(L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                        (USHORT)psid->IdentifierAuthority.Value[0],
                        (USHORT)psid->IdentifierAuthority.Value[1],
                        (USHORT)psid->IdentifierAuthority.Value[2],
                        (USHORT)psid->IdentifierAuthority.Value[3],
                        (USHORT)psid->IdentifierAuthority.Value[4],
                        (USHORT)psid->IdentifierAuthority.Value[5] );
        } else
        {
            wprintf(L"-%lu",
                   (ULONG)psid->IdentifierAuthority.Value[5]          +
                   (ULONG)(psid->IdentifierAuthority.Value[4] <<  8)  +
                   (ULONG)(psid->IdentifierAuthority.Value[3] << 16)  +
                   (ULONG)(psid->IdentifierAuthority.Value[2] << 24) );
        }

        if ( 0 < psid->SubAuthorityCount )
        {
            for (int k = 0; k < psid->SubAuthorityCount; k++ )
            {
                wprintf(L"-%d",psid->SubAuthority[k]);
            }
        }
    }
#endif
    ULONG ret;

    CAccount ca(psid, NULL);

    LPWSTR domain = NULL;
    LPWSTR user = NULL;

    if (NO_ERROR == ( ret = ca.GetAccountDomain(&domain) ) )
    {
        if ( (NULL == domain) || (0 == wcslen(domain)) )
        {
            fwprintf(stdout, L" ");
            *outputoffset +=1;
        }
        else
        {
            fwprintf(stdout, L" %ws\\",domain);
            *outputoffset +=2 + wcslen(domain);
        }
        if (NO_ERROR == ( ret = ca.GetAccountName(&user) ) )
        {
            fwprintf(stdout, L"%ws:",user);
            *outputoffset += 1 + wcslen(user);
        } else
        {
            *outputoffset += printmessage(stdout, MSG_CACLS_NAME_NOT_FOUND, NULL);

            ERRORS((stderr, L"(%lx)",ret))
        }
    } else
    {
        *outputoffset+= printmessage(stdout, MSG_CACLS_DOMAIN_NOT_FOUND, NULL);
        ERRORS((stderr, L"(%lx)",ret))
    }
    VERBOSE((stderr, L"\n"))
}
//----------------------------------------------------------------------------
//
//  Function:     printface
//
//  Synopsis:     prints the specifed ace
//
//  Arguments:    IN [paceh] - input ace (header)
//                IN [fdir]  - TRUE = directory (different display options)
//
//----------------------------------------------------------------------------
void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset)
{
    VERBOSE((stderr, L"  "))
    VERBOSER((stderr, L"\npaceh->AceType  = %x\n",paceh->AceType  ))
    VERBOSER((stderr, L"paceh->AceFlags = %x\n",paceh->AceFlags ))
    VERBOSER((stderr, L"paceh->AceSize  = %x\n",paceh->AceSize  ))
    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)paceh;
    printfsid((SID *)&(paaa->SidStart),&outputoffset);
    if (paceh->AceFlags & OBJECT_INHERIT_ACE      )
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_OBJECT_INHERIT, NULL);
    }
    if (paceh->AceFlags & CONTAINER_INHERIT_ACE   ) 
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_CONTAINER_INHERIT, NULL);
    }
    if (paceh->AceFlags & NO_PROPAGATE_INHERIT_ACE)
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_NO_PROPAGATE_INHERIT, NULL);
    }
    if (paceh->AceFlags & INHERIT_ONLY_ACE        ) 
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_INHERIT_ONLY, NULL);
    }

    if (paceh->AceType == ACCESS_DENIED_ACE_TYPE)
    {
            DISPLAY_MASK((stderr, L"(DENIED)"))
            VERBOSE((stderr, L"(DENIED)"))
    }

    printfmask(paaa->Mask, paceh->AceType, fdir, outputoffset);
    fwprintf(stdout, L"\n");
}
//----------------------------------------------------------------------------
//
//  Function:     printfmask
//
//  Synopsis:     prints the access mask
//
//  Arguments:    IN [mask]    - the access mask
//                IN [acetype] -  allowed/denied
//                IN [fdir]    - TRUE = directory
//
//----------------------------------------------------------------------------
LPWSTR aRightsStr[] = { L"STANDARD_RIGHTS_ALL",
                        L"DELETE",
                        L"READ_CONTROL",
                        L"WRITE_DAC",
                        L"WRITE_OWNER",
                        L"SYNCHRONIZE",
                        L"STANDARD_RIGHTS_REQUIRED",
                        L"SPECIFIC_RIGHTS_ALL",
                        L"ACCESS_SYSTEM_SECURITY",
                        L"MAXIMUM_ALLOWED",
                        L"GENERIC_READ",
                        L"GENERIC_WRITE",
                        L"GENERIC_EXECUTE",
                        L"GENERIC_ALL",
                        L"FILE_GENERIC_READ",
                        L"FILE_GENERIC_WRITE",
                        L"FILE_GENERIC_EXECUTE",
                        L"FILE_READ_DATA",
                        //FILE_LIST_DIRECTORY
                        L"FILE_WRITE_DATA",
                        //FILE_ADD_FILE
                        L"FILE_APPEND_DATA",
                        //FILE_ADD_SUBDIRECTORY
                        L"FILE_READ_EA",
                        L"FILE_WRITE_EA",
                        L"FILE_EXECUTE",
                        //FILE_TRAVERSE
                        L"FILE_DELETE_CHILD",
                        L"FILE_READ_ATTRIBUTES",
                        L"FILE_WRITE_ATTRIBUTES" };

#define NUMRIGHTS 26
ULONG aRights[NUMRIGHTS] = { STANDARD_RIGHTS_ALL  ,
                         DELETE                   ,
                         READ_CONTROL             ,
                         WRITE_DAC                ,
                         WRITE_OWNER              ,
                         SYNCHRONIZE              ,
                         STANDARD_RIGHTS_REQUIRED ,
                         SPECIFIC_RIGHTS_ALL      ,
                         ACCESS_SYSTEM_SECURITY   ,
                         MAXIMUM_ALLOWED          ,
                         GENERIC_READ             ,
                         GENERIC_WRITE            ,
                         GENERIC_EXECUTE          ,
                         GENERIC_ALL              ,
                         FILE_GENERIC_READ        ,
                         FILE_GENERIC_WRITE       ,
                         FILE_GENERIC_EXECUTE     ,
                         FILE_READ_DATA           ,
                         //FILE_LIST_DIRECTORY    ,
                         FILE_WRITE_DATA          ,
                         //FILE_ADD_FILE          ,
                         FILE_APPEND_DATA         ,
                         //FILE_ADD_SUBDIRECTORY  ,
                         FILE_READ_EA             ,
                         FILE_WRITE_EA            ,
                         FILE_EXECUTE             ,
                         //FILE_TRAVERSE          ,
                         FILE_DELETE_CHILD        ,
                         FILE_READ_ATTRIBUTES     ,
                         FILE_WRITE_ATTRIBUTES  };

void printfmask(ULONG mask, WCHAR acetype, BOOL fdir, ULONG outputoffset)
{
    ULONG savmask = mask;
    VERBOSER((stderr, L"mask = %08lx ", mask))
    DISPLAY_MASK((stderr, L"mask = %08lx\n", mask))

    VERBOSE((stderr, L"    "))

#if DBG
    if (!(Debug & (DEBUG_VERBOSE | DEBUG_DISPLAY_MASK)))
    {
#endif
        if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (FILE_GENERIC_READ | FILE_EXECUTE)))
        {
            printmessage(stdout, MSG_CACLS_READ, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE)))
        {
            printmessage(stdout, MSG_CACLS_CHANGE, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE | DELETE)))
        {
            printmessage(stdout, MSG_CACLS_CHANGE, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask ==  ( STANDARD_RIGHTS_ALL |
                             FILE_READ_DATA |
                             FILE_WRITE_DATA |
                             FILE_APPEND_DATA |
                             FILE_READ_EA |
                             FILE_WRITE_EA |
                             FILE_EXECUTE |
                             FILE_DELETE_CHILD |
                             FILE_READ_ATTRIBUTES |
                             FILE_WRITE_ATTRIBUTES )) )
        {
            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask ==  GENERIC_ALL))
        {
            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL);
        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &&
                   (mask == GENERIC_ALL))
        {
            printmessage(stdout, MSG_CACLS_NONE, NULL);
        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &&
                   (mask ==  ( STANDARD_RIGHTS_ALL |
                             FILE_READ_DATA |
                             FILE_WRITE_DATA |
                             FILE_APPEND_DATA |
                             FILE_READ_EA |
                             FILE_WRITE_EA |
                             FILE_EXECUTE |
                             FILE_DELETE_CHILD |
                             FILE_READ_ATTRIBUTES |
                             FILE_WRITE_ATTRIBUTES )) )
        {
            printmessage(stdout, MSG_CACLS_NONE, NULL);
        } else
        {
            if (acetype == ACCESS_DENIED_ACE_TYPE)
                printmessage(stdout, MSG_CACLS_DENY, NULL);

            printmessage(stdout, MSG_CACLS_SPECIAL_ACCESS, NULL);

            for (int k = 0; k<NUMRIGHTS ; k++ )
            {
                if ((mask & aRights[k]) == aRights[k])
                {
                    fwprintf(stdout, L"%*s%s\n",outputoffset, L" ", aRightsStr[k]);
                }
                if (mask == 0)
                    break;
            }
        }
#if DBG
    } else
    {
        if (Debug & (DEBUG_DISPLAY_MASK | DEBUG_VERBOSE))
        {
            for (int k = 0; k<NUMRIGHTS ; k++ )
            {
                if ((mask & aRights[k]) == aRights[k])
                {
                    if (mask != savmask) wprintf(L" |\n");
                    wprintf(L"    %s",aRightsStr[k]);
                    mask &= ~aRights[k];
                }
                if (mask == 0)
                break;
            }
        }
        VERBOSE((stderr, L"=%x",mask))
        if (mask != 0)
            DISPLAY((stderr, L"=%x/%x",mask,savmask))
    }
#endif
    fwprintf(stdout, L" ");
}
//----------------------------------------------------------------------------
//
//  Function:     printmessage
//
//  Synopsis:     prints a message, either from the local message file, or from the system
//
//  Arguments:    IN [fp]    - stderr, stdio, etc.
//                IN [messageID] - variable argument list
//
//  Returns:      length of the output buffer
//
//----------------------------------------------------------------------------
/*ULONG  printmessage (FILE* fp, DWORD messageID, ...)
{
    WCHAR  messagebuffer[4096];
	va_list ap;

    va_start(ap, messageID);

    if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                      (LPTSTR)messagebuffer, 4095, &ap))
       FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageID, 0,
                        (LPTSTR)messagebuffer, 4095, &ap);

    fwprintf(fp,  messagebuffer);

    va_end(ap);
    return(wcslen(messagebuffer));
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\appearprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.cpp

Abstract:

    Implementation of the Appearance property page.

--*/

#include "polyline.h"
#include <Commdlg.h>
#include "appearprop.h"
#include <pdhmsg.h>
#include "smonmsg.h"
#include "unihelpr.h"
#include "winhelpr.h"

COLORREF   CustomColors[16];

CAppearPropPage::CAppearPropPage()
{
    m_uIDDialog = IDD_APPEAR_PROPP_DLG;
    m_uIDTitle = IDS_APPEAR_PROPP_TITLE;
}

CAppearPropPage::~CAppearPropPage(
    void
    )
{
    return;
}

BOOL
CAppearPropPage::InitControls ( void )
{
    BOOL  bResult = TRUE;
    HWND  hWnd;

    //
    // TODO: This piece of code should not be here to initialize 
    //       global variables
    //
    for (int i = 0; i < 16; i++) {
        CustomColors[i] = RGB(255, 255, 255);
    }

    hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
    if( NULL != hWnd ){
        CBInsert( hWnd, GraphColor, ResourceString(IDS_COLORCHOICE_GRAPH) );
        CBInsert( hWnd, ControlColor, ResourceString(IDS_COLORCHOICE_CONTROL) );
        CBInsert( hWnd, TextColor, ResourceString(IDS_COLORCHOICE_TEXT) );
        CBInsert( hWnd, GridColor, ResourceString(IDS_COLORCHOICE_GRID) );
        CBInsert( hWnd, TimebarColor, ResourceString(IDS_COLORCHOICE_TIMEBAR) );
        CBSetSelection( hWnd, 0 );
    }
    else {
        bResult = FALSE;
    }

    return bResult;
}

void 
CAppearPropPage::ColorizeButton()
{
    HBRUSH hBrush;
    RECT rect;
    HWND hWndColorObject = NULL;
    HWND hWndColorSample = NULL;
    ColorChoices sel;
    COLORREF rgbColor;
    HDC hDC;

    hWndColorObject = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
    hWndColorSample = GetDlgItem( m_hDlg, IDC_COLORSAMPLE );

    if (hWndColorObject && hWndColorSample) {

        sel = (ColorChoices)CBSelection( hWndColorObject );
        rgbColor = (COLORREF)CBData( hWndColorObject, sel );

        hDC = GetWindowDC( hWndColorSample );
        if( hDC != NULL ) {

            hBrush = CreateSolidBrush( rgbColor );

            if ( NULL != hBrush ) {
                GetClientRect( hWndColorSample, &rect );
                OffsetRect(&rect, 3, 3);
                FillRect(hDC, &rect, hBrush);
            }

            ReleaseDC( hWndColorSample, hDC );
        }
    }

}

void CAppearPropPage::SampleFont()
{
    HFONT hFont;
    HWND  hwndSample;

    hwndSample = GetDlgItem( m_hDlg, IDC_FONTSAMPLE );
    if ( hwndSample != NULL ){
        hFont = CreateFontIndirect( &m_Font );
        if( hFont != NULL ){
            SendMessage( hwndSample, WM_SETFONT, (WPARAM)hFont, (LPARAM)TRUE );
        }
    }
}

BOOL 
CAppearPropPage::WndProc(
    UINT uMsg, 
    WPARAM /* wParam */, 
    LPARAM /* lParam */)
{
    if( uMsg == WM_CTLCOLORBTN ){
        ColorizeButton();
        return TRUE;
    }
    return FALSE;   
}

/*
 * CAppearPropPage::GetProperties
 * 
 */

BOOL CAppearPropPage::GetProperties(void)
{
    BOOL    bReturn = TRUE;
    ISystemMonitor  *pObj;
    CImpISystemMonitor *pPrivObj;
    IFontDisp* pFontDisp;
    LPFONT  pIFont;
    HFONT hFont;
    HRESULT hr;
    HWND hWnd;

    if (m_cObjects == 0) {
        bReturn = FALSE;
    } else {
        pObj = m_ppISysmon[0];

        // Get pointer to actual object for internal methods
        pPrivObj = (CImpISystemMonitor*)pObj;
        pPrivObj->get_Font( &pFontDisp );

        if ( NULL == pFontDisp ) {
            bReturn = FALSE;
        } else {
            hr = pFontDisp->QueryInterface(IID_IFont, (PPVOID)&pIFont);
            if (SUCCEEDED(hr)) {
                pIFont->get_hFont( &hFont );
                GetObject( hFont, sizeof(LOGFONT), &m_Font );
                pIFont->Release();
            }

            SampleFont();
        }

        hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
        if( hWnd != NULL ){
            OLE_COLOR OleColor;
            COLORREF  rgbColor;

            pPrivObj->get_BackColor( &OleColor );
            OleTranslateColor(OleColor, NULL, &rgbColor);
            CBSetData( hWnd, GraphColor, rgbColor );

            pPrivObj->get_BackColorCtl( &OleColor );
            OleTranslateColor(OleColor, NULL, &rgbColor);
            CBSetData( hWnd, ControlColor, rgbColor );

            pPrivObj->get_ForeColor( &OleColor );
            OleTranslateColor(OleColor, NULL, &rgbColor);
            CBSetData( hWnd, TextColor, rgbColor );

            pPrivObj->get_GridColor( &OleColor );
            OleTranslateColor(OleColor, NULL, &rgbColor);
            CBSetData( hWnd, GridColor, rgbColor );

            pPrivObj->get_TimeBarColor( &OleColor );
            OleTranslateColor(OleColor, NULL, &rgbColor);
            CBSetData( hWnd, TimebarColor, rgbColor );
            
            ColorizeButton();
        }
    }

    return bReturn;
}


/*
 * CAppearPropPage::SetProperties
 * 
 */

BOOL CAppearPropPage::SetProperties(void)
{
    BOOL bReturn = TRUE;
    IFontDisp* pFontDisp;
    ISystemMonitor  *pObj;
    CImpISystemMonitor *pPrivObj;

    if (m_cObjects == 0) {
        bReturn = FALSE;
    } else {
        
        FONTDESC fd;

        pObj = m_ppISysmon[0];
        pPrivObj = (CImpISystemMonitor*)pObj;

        fd.cbSizeofstruct = sizeof(FONTDESC);
        fd.lpstrName = m_Font.lfFaceName;
        fd.sWeight = (short)m_Font.lfWeight;
        fd.sCharset = m_Font.lfCharSet;
        fd.fItalic = m_Font.lfItalic;
        fd.fUnderline = m_Font.lfUnderline;
        fd.fStrikethrough = m_Font.lfStrikeOut;

        long lfHeight = m_Font.lfHeight;
        int ppi;
		HDC hdc;

        if (lfHeight < 0){
	        lfHeight = -lfHeight;
        }

		hdc = ::GetDC(GetDesktopWindow());
		ppi = GetDeviceCaps(hdc, LOGPIXELSY);
		::ReleaseDC(GetDesktopWindow(), hdc);

        fd.cySize.Lo = lfHeight * 720000 / ppi;
        fd.cySize.Hi = 0;
        
        OleCreateFontIndirect(&fd, IID_IFontDisp, (void**) &pFontDisp);
        
        pPrivObj->putref_Font( pFontDisp );   
        pFontDisp->Release();

        HWND hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
        if( hWnd != NULL ){
            COLORREF  OleColor;

            OleColor = (OLE_COLOR)CBData( hWnd, GraphColor );
            pPrivObj->put_BackColor( OleColor );

            OleColor = (OLE_COLOR)CBData( hWnd, ControlColor );
            pPrivObj->put_BackColorCtl( OleColor );

            OleColor = (OLE_COLOR)CBData( hWnd, TextColor );
            pPrivObj->put_ForeColor( OleColor );

            OleColor = (OLE_COLOR)CBData( hWnd, GridColor );
            pPrivObj->put_GridColor( OleColor );

            OleColor = (OLE_COLOR)CBData( hWnd, TimebarColor );
            pPrivObj->put_TimeBarColor( OleColor );
        }
    }

    return bReturn;
}


void 
CAppearPropPage::DialogItemChange(
    WORD wID, 
    WORD /* wMsg */)
{
    BOOL bChanged = FALSE;

    switch (wID) {

        case IDC_COLOROBJECTS:
            ColorizeButton();
            break;

        case IDC_COLORSAMPLE:
        case IDC_COLORBUTTON:
        {
            CHOOSECOLOR  cc;
            COLORREF     rgbColor;
            HWND         hWnd;

            hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
            
            if ( NULL != hWnd ) {
                
                ColorChoices sel = (ColorChoices)CBSelection( hWnd );
                rgbColor = (COLORREF)CBData( hWnd, sel );

                ZeroMemory(&cc, sizeof(CHOOSECOLOR));

                cc.lStructSize = sizeof(CHOOSECOLOR);
                cc.lpCustColors = CustomColors;
                cc.hwndOwner = m_hDlg;
                cc.Flags = CC_RGBINIT;
                cc.rgbResult = rgbColor;

                if ( ChooseColor(&cc) ) {
                    CBSetData( hWnd, sel, cc.rgbResult );
                    ColorizeButton();
                    bChanged = TRUE;
                }
            }
            
            break;
        }

        case IDC_FONTBUTTON:
        case IDC_FONTSAMPLE:
        {
            CHOOSEFONT  cf;
            LOGFONT lf;
            
            memset(&cf, 0, sizeof(CHOOSEFONT));
            memcpy( &lf, &m_Font, sizeof(LOGFONT) );

            cf.lStructSize = sizeof(CHOOSEFONT);
            cf.hwndOwner = m_hDlg;
            cf.lpLogFont = &lf;    // give initial font
            cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_FORCEFONTEXIST | CF_SCREENFONTS;
            cf.nSizeMin = 5; 
            cf.nSizeMax = 50;

            if( ChooseFont(&cf) ){
                memcpy( &m_Font, &lf, sizeof(LOGFONT) );
                SampleFont();
                bChanged = TRUE;
            }
            break;
        }
    }

    if ( bChanged == TRUE ) {
        SetChange();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\appearprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.h

Abstract:

    Data Appear Property Page

--*/

#ifndef _APPEARPROP_H_07242000_
#define _APPEARPROP_H_07242000_

#include "smonprop.h"

// Dialog Controls
#define IDD_APPEAR_PROPP_DLG        600
#define IDC_COLOROBJECTS            601
#define IDC_COLORBUTTON             602
#define IDC_FONTBUTTON              604
#define IDC_FONTSAMPLE              605
#define IDC_STATIC_COLOR            606
#define IDC_STATIC_FONT             607
#define IDC_COLORSAMPLE             608

typedef enum ColorChoices {
    GraphColor,
    ControlColor,
    TextColor,
    GridColor,
    TimebarColor
};

// Data Appear property page class
class CAppearPropPage : public CSysmonPropPage
{
public:
   
    CAppearPropPage(void);
    virtual ~CAppearPropPage(void);

    enum eAppearConstants {
        eColorCount = 16,
    };

protected:

    virtual BOOL GetProperties(void);   //Read current properties
    virtual BOOL SetProperties(void);   //Set new properties
    virtual BOOL InitControls(void);
    virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
    virtual BOOL WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam); // Special msg processing 


private: 
    

    COLORREF m_Color;
    LOGFONT  m_Font;
    void ColorizeButton();
    void SampleFont();
};
typedef CAppearPropPage *PCAppearPropPage;

// {e49741e9-93a8-4ab1-8e96-bf4482282e9c}
DEFINE_GUID(CLSID_AppearPropPage,
    0xe49741e9, 0x93a8, 0x4ab1, 0x8e, 0x96, 0xbf, 0x44, 0x82, 0x28, 0x2e, 0x9c);

#endif //_APPEARPROP_H_07242000_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\appmema.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    appmema.h

Abstract:

    application memory performance counter definitions

--*/

#ifndef _APPMEMA_H_
#define _APPMEMA_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DO_TIMING_BUILD

#include ".\perfdll\perfdll\appmemi.h"

extern struct  _APPMEM_DATA_HEADER *pDataHeader;
extern struct  _APPMEM_INSTANCE    *pAppData;

#define IncrementAppPerfDwordData(dwItemId) pAppData->DwordData[dwItemId]++;

BOOL
__stdcall
AppPerfOpen(HINSTANCE   hInstance);

BOOL
__stdcall
AppPerfClose(HINSTANCE  hInstance);

void
UpdateAppPerfTimeData (
    DWORD   dwItemId,
    DWORD   dwStage
);

void
UpdateAppPerfDwordData (
    DWORD   dwItemId,
    DWORD   dwValue
);

#else
// a regular build
#define AppPerfOpen(x)
#define AppPerfClose(x)
#define UpdateAppPerfTimeData(x,y)
#define UpdateAppPerfDwordData(x,y)
#define IncrementAppPerfDwordData(x)
#endif

#ifdef __cplusplus
}
#endif
#endif // _APPMEMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\appmema.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    appmema.cpp

Abstract:

    This file contains the memory allocation function "wrappers"
    to allow monitoring of the memory usage by a performance monitoring
    application (e.g. PERFMON).

--*/

#ifdef DO_TIMING_BUILD

#include <windows.h>
#include <assert.h>
#include "appmema.h"

HANDLE ThisDLLHandle = NULL;

HANDLE  hAppMemSharedMemory = NULL;     // Handle of counter Shared Memory

PAPPMEM_DATA_HEADER pDataHeader = NULL; // pointer to header of shared mem
PAPPMEM_INSTANCE    pAppData = NULL;    // pointer to the app data for this app

static
BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    Initializes the interface to the performance counters DLL by
    opening the Shared Memory file used to communicate statistics
    from the application to the counter DLL. If the Shared memory
    file does not exist, it is created, formatted and initialized.
    If the file has already been created and formatted, then the
    next available APPMEM_INSTANCE entry is moved from the free list
    to the InUse list and the corresponding pointer is saved for
    subsequent use by this application
   
--*/
{
    LONG    status;
    WCHAR   szMappedObject[] = SHARED_MEMORY_OBJECT_NAME;
    DWORD   dwBytes;

    // save this DLL handle
    ThisDLLHandle = DllHandle;

    // disable thread attach & detach calls to save the overhead
    // since we don't care about them.
    DisableThreadLibraryCalls (DllHandle);

    // open & initialize shared memory file
    SetLastError (ERROR_SUCCESS);   // just to clear it out

    // open/create shared memory used by the application to pass performance values
    status = GetSharedMemoryDataHeader (
        &hAppMemSharedMemory, NULL, &pDataHeader,
        FALSE); // read/write access is required
    // here the memory block should be initialized and ready for use
    if (status == ERROR_SUCCESS) {
        if (pDataHeader->dwFirstFreeOffset != 0) {
            // then there are blocks left so get the next free
            pAppData = FIRST_FREE(pDataHeader);
            // update free list to make next item the first in list
            pDataHeader->dwFirstFreeOffset = pAppData->dwOffsetOfNext;

            // insert the new item into the head of the in use list
            pAppData->dwOffsetOfNext = pDataHeader->dwFirstInUseOffset;
            pDataHeader->dwFirstInUseOffset = (DWORD)((LPBYTE)pAppData -
                                                      (LPBYTE)pDataHeader);

            // now initialize this instance's data
            pAppData->dwProcessId = GetCurrentProcessId(); // id of process using this instance

            dwBytes = sizeof (APP_DATA_SAMPLE) * TD_TOTAL;
            dwBytes += sizeof (DWORD) * DD_TOTAL;
            memset (&pAppData->TimeData[0], 0, dwBytes);

            pDataHeader->dwInstanceCount++;    // increment count
        } else {
            // no more free slots left
            assert (pDataHeader->dwFirstFreeOffset != 0);
        }
    } else {
        // unable to open shared memory file
        // even though this is an error we should return true so as to 
        // not abort the application. No performance data will be 
        // collected though.
    }
    return TRUE;
}

static
BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    PAPPMEM_INSTANCE    pPrevItem;

    // remove instance for this app
    if ((pAppData != NULL) && (pDataHeader != NULL)) {
        // zero the fields out first
        memset (pAppData, 0, sizeof (APPMEM_INSTANCE));
        // move from in use (busy) list back to the free list
        if ((pDataHeader->dwFirstFreeOffset != 0) && (pDataHeader->dwFirstInUseOffset != 0)) {
            // find previous item in busy list
            if (FIRST_INUSE(pDataHeader) != pAppData) {
                // not the first so walk down the list
                pPrevItem = FIRST_INUSE(pDataHeader);
                while (APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext) != pAppData) {
                    pPrevItem = APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext);
                    if (pPrevItem->dwOffsetOfNext == 0) break; // end of list
                }
                if (APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext) == pAppData) {
                    APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext)->dwOffsetOfNext =
                        pAppData->dwOffsetOfNext;
                } else {
                    // it was never in the busy list (?!?)
                }
            } else {
                // this is the first in the list so update it
                pDataHeader->dwFirstInUseOffset = pAppData->dwOffsetOfNext;
            }
            // here, pAppData has been removed from the InUse list and now
            // it must be inserted back at the beginning of the free list
            pAppData->dwOffsetOfNext = pDataHeader->dwFirstFreeOffset;
            pDataHeader->dwFirstFreeOffset = (DWORD)((LPBYTE)pAppData - (LPBYTE)pDataHeader);
        }
    }

    // decrement instance counter
    pDataHeader->dwInstanceCount--;    // decrement count

    // close shared memory file handle

    if (hAppMemSharedMemory != NULL) CloseHandle (hAppMemSharedMemory);

    // clear pointers
    hAppMemSharedMemory = NULL;
    pDataHeader = NULL;
    pAppData = NULL;

    return TRUE;
}

BOOL
__stdcall
AppPerfOpen(HINSTANCE   hInstance)
{
    return DllProcessAttach (hInstance);
}
BOOL
__stdcall
AppPerfClose(HINSTANCE  hInstance)
{
    return DllProcessDetach (hInstance);
}

void
UpdateAppPerfTimeData (
    DWORD   dwItemId,
    DWORD   dwStage
)
{
    LONGLONG    llTime;
    assert (dwItemId < TD_TOTAL);
    QueryPerformanceCounter ((LARGE_INTEGER *)&llTime);
//  GetSystemTimeAsFileTime ((LPFILETIME)&llTime);
    if (dwStage == TD_BEGIN) {
        assert (pAppData->TimeData[dwItemId].dw1 == 0); // this shouldn't be called while timing
        pAppData->TimeData[dwItemId].ll1 = llTime;  // save start time
        pAppData->TimeData[dwItemId].dw1++;     // indicate were counting
    } else {
        assert (pAppData->TimeData[dwItemId].dw1 == 1); // this should only be called while timing
        pAppData->TimeData[dwItemId].ll0 += llTime; // add in current time
        // then remove the start time
        pAppData->TimeData[dwItemId].ll0 -= pAppData->TimeData[dwItemId].ll1;
        // increment completed operation count
        pAppData->TimeData[dwItemId].dw0++;
        // decrement busy count
        pAppData->TimeData[dwItemId].dw1--;
    }
    return;
}

void
UpdateAppPerfDwordData (
    DWORD   dwItemId,
    DWORD   dwValue
)
{
    assert (dwItemId < DD_TOTAL);
    pAppData->DwordData[dwItemId] = dwValue;
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\browser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browser.h

Abstract:

    Header file for the sysmon.ocx interaction with Pdh browse
	counters dialog.

--*/

#ifndef _BROWSER_H_
#define _BROWSER_H_

#define BROWSE_WILDCARD		1

typedef HRESULT (*ENUMPATH_CALLBACK)(LPWSTR pszPath, DWORD_PTR lpUserData, DWORD dwFlags);

extern HRESULT
BrowseCounters (	
    IN HLOG     hDataSource,
	IN DWORD	dwDetailLevel,
	IN HWND	    hwndOwner,
	IN ENUMPATH_CALLBACK pCallback,
	IN LPVOID	lpUserData,
    IN BOOL     bUseInstanceIndex
	);


extern HRESULT
EnumExpandedPath (
    HLOG    hDataSource,
	LPWSTR	pszCtrPath,
	ENUMPATH_CALLBACK pCallback,
	LPVOID	lpUserData
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\browse.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browse.cpp

Abstract:

    Implements the interaction with the PDH browser dialog.

--*/

#include <assert.h>
#include "polyline.h"
#include "pdhmsg.h"
#include "browser.h"
#include "smonmsg.h"
#include "utils.h"

typedef struct {
    PDH_BROWSE_DLG_CONFIG_H  *pBrowseInfo;
    ENUMPATH_CALLBACK   pCallback;
    LPVOID  lpUserData;
} ENUMCALLBACK_INFO;


static PDH_FUNCTION
BrowseCallback (
    DWORD_PTR lpParam
);


HRESULT
BrowseCounters (
    HLOG    hDataSource,
    DWORD   dwDetailLevel,
    HWND    hwndOwner,
    ENUMPATH_CALLBACK pCallback,
    LPVOID  lpUserData,
    BOOL    bUseInstanceIndex
)
{
#define CTRBUFLEN 8192

    PDH_BROWSE_DLG_CONFIG_H BrowseInfo;
    ENUMCALLBACK_INFO       CallbackInfo;

    // clear the structure before assigning values 
    memset (&BrowseInfo, 0, sizeof (BrowseInfo));

    BrowseInfo.bIncludeInstanceIndex = (bUseInstanceIndex ? 1 : 0);
    BrowseInfo.bSingleCounterPerAdd = 0;
    BrowseInfo.bSingleCounterPerDialog = 0;
    BrowseInfo.bLocalCountersOnly = 0;
    BrowseInfo.bWildCardInstances = 1;
    BrowseInfo.bHideDetailBox = 1;
    BrowseInfo.bInitializePath = 0;
    BrowseInfo.bDisableMachineSelection = 0;
    BrowseInfo.bReserved = 0;
    BrowseInfo.bIncludeCostlyObjects = 0;
    BrowseInfo.szDialogBoxCaption = ResourceString(IDS_ADDCOUNTERS);

    BrowseInfo.hWndOwner = hwndOwner;
    BrowseInfo.hDataSource = hDataSource;
    BrowseInfo.dwDefaultDetailLevel = dwDetailLevel;

    BrowseInfo.szReturnPathBuffer = (LPWSTR)malloc(CTRBUFLEN * sizeof(WCHAR));
    if (BrowseInfo.szReturnPathBuffer == NULL) {
        return E_OUTOFMEMORY;
    }
    BrowseInfo.cchReturnPathLength = CTRBUFLEN;

    CallbackInfo.pBrowseInfo = &BrowseInfo;
    CallbackInfo.pCallback = pCallback;
    CallbackInfo.lpUserData = lpUserData;
    BrowseInfo.dwCallBackArg = (DWORD_PTR)&CallbackInfo;
    BrowseInfo.pCallBack = BrowseCallback;


    //
    // Call PDH function to browse the counters
    //
    PdhBrowseCountersH (&BrowseInfo);

    if (BrowseInfo.szReturnPathBuffer) {
        free(BrowseInfo.szReturnPathBuffer);
    }

    return NO_ERROR;
}



static PDH_FUNCTION
BrowseCallback (
    DWORD_PTR dwParam
    )
{
#define CTRBUFLIMIT (0x10000000)

    HRESULT hr = S_OK;
    BOOLEAN fDuplicate = FALSE;

    ENUMCALLBACK_INFO *pCallbackInfo = (ENUMCALLBACK_INFO*)dwParam;
    PDH_BROWSE_DLG_CONFIG_H *pBrowseInfo = pCallbackInfo->pBrowseInfo;
    LPWSTR  pszCtrPath;

    if (pBrowseInfo->CallBackStatus == ERROR_SUCCESS) {

        //
        // Call callback for each path
        // If wildcard path, EnumExpandedPath will call once for each generated path
        //
        for (pszCtrPath = pBrowseInfo->szReturnPathBuffer;
            *pszCtrPath != L'\0';
            pszCtrPath += (lstrlen(pszCtrPath) + 1)) {

            hr = EnumExpandedPath(pBrowseInfo->hDataSource, 
                                  pszCtrPath,
                                  pCallbackInfo->pCallback, 
                                  pCallbackInfo->lpUserData);
            if ((DWORD)hr == SMON_STATUS_DUPL_COUNTER_PATH)
                fDuplicate = TRUE;
        }

        // Notify user if duplicates encountered
        if (fDuplicate) {
            MessageBox(pBrowseInfo->hWndOwner, 
                       ResourceString(IDS_DUPL_PATH_ERR), 
                       ResourceString(IDS_APP_NAME),
                       MB_OK | MB_ICONWARNING);
        }
    } 
    else if (pBrowseInfo->CallBackStatus == PDH_MORE_DATA) {
        
        if (pBrowseInfo->szReturnPathBuffer) {
            free(pBrowseInfo->szReturnPathBuffer);
            pBrowseInfo->szReturnPathBuffer  = NULL;
        }

        if (pBrowseInfo->cchReturnPathLength == CTRBUFLIMIT) {
            return PDH_MEMORY_ALLOCATION_FAILURE;
        }

        pBrowseInfo->cchReturnPathLength *= 2;
        
        if (pBrowseInfo->cchReturnPathLength > CTRBUFLIMIT) {
            pBrowseInfo->cchReturnPathLength = CTRBUFLIMIT;
        }
 
        pBrowseInfo->szReturnPathBuffer = (WCHAR*)malloc(pBrowseInfo->cchReturnPathLength * sizeof(WCHAR));
        if (pBrowseInfo->szReturnPathBuffer) {
            return PDH_RETRY;
        }
        else {
            pBrowseInfo->cchReturnPathLength = 0;
            return PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    return ERROR_SUCCESS;
}



HRESULT
EnumExpandedPath (
    HLOG    hDataSource,
    LPWSTR  pszCtrPath,
    ENUMPATH_CALLBACK pCallback,
    LPVOID  lpUserData
    )
{
#define INSTBUFLEN  4096

    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    ULONG      ulBufLen;
    INT        nInstBufRetry;
    LPWSTR     pszInstBuf = NULL;
    LPWSTR     pszInstance;

    //
    // If no wild card, invoke callback once on path
    //
    if (wcschr(pszCtrPath, L'*') == NULL) {
        return pCallback(pszCtrPath, (DWORD_PTR)lpUserData, 0);
    }

    //
    // Try 10 times before we fail out
    //
    nInstBufRetry = 10;
    ulBufLen = INSTBUFLEN;

    do {
        if ( NULL != pszInstBuf ) {
            free(pszInstBuf);
            pszInstBuf = NULL;
            ulBufLen *= 2;
        }
        
        pszInstBuf = (WCHAR*) malloc(ulBufLen * sizeof(WCHAR));
        if (pszInstBuf == NULL) {
            pdhStatus = E_OUTOFMEMORY;
            break;
        }
            
        pdhStatus = PdhExpandWildCardPathH (
            hDataSource,
            pszCtrPath,
            pszInstBuf,
            &ulBufLen,
            PDH_REFRESHCOUNTERS);

        nInstBufRetry--;
    } while ((pdhStatus == PDH_MORE_DATA) && (nInstBufRetry));

    if (pdhStatus == ERROR_SUCCESS) {
        // For each instance name, generate a path and invoke the callback
        for (pszInstance = pszInstBuf;
            *pszInstance != L'\0';
            pszInstance += lstrlen(pszInstance) + 1) {

            // Invoke callback
            HRESULT hr = pCallback(pszInstance, (DWORD_PTR)lpUserData, BROWSE_WILDCARD);

            // When expanding a wildcard, don't notify user about duplicate path errors
            if (hr != S_OK && (DWORD)hr != SMON_STATUS_DUPL_COUNTER_PATH) {
                pdhStatus = hr;
            }
        }
    }

    if (pszInstBuf) {
        free(pszInstBuf);
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\bstrutil.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    bstrutil.cpp

Abstract:

    B string utility functions.

--*/

#include "ole2.h"

#include "bstrutil.h"

INT SysStringAnsiLen (
    IN  BSTR bstr
    )
{
    if (bstr == NULL)
        return 0;

#ifndef OLE2ANSI
    return WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                 NULL, 0, NULL, NULL);
#else
    return SysStringLen(bstr);
#endif
}


HRESULT BStrToStream (
    IN  LPSTREAM pIStream, 
    IN  INT  nMbChar,
    IN  BSTR bstr
    )
{
    LPSTR   pchBuf;
    HRESULT hr;

    // If empty string just return
    if (SysStringLen(bstr) == 0)
        return NO_ERROR;

#ifndef OLE2ANSI
    // Convert to multibyte string
    pchBuf = new char[nMbChar + 1];
    if (pchBuf == NULL)
        return E_OUTOFMEMORY;

    WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                 pchBuf, nMbChar+1, NULL, NULL);
    // Write string to stream
    hr = pIStream->Write(pchBuf, nMbChar, NULL);

    delete [] pchBuf;
#else
    hr = pIStream->Write(bstr, nMbChar, NULL);
#endif

    return hr;
}


HRESULT BStrFromStream (
    IN  LPSTREAM pIStream,
    IN  INT nChar,
    OUT BSTR *pbstrRet
    )
{
    HRESULT hr;
    BSTR    bstr;   
    ULONG   nRead;
    LPSTR   pchBuf;
    INT     nWChar;

    *pbstrRet = NULL;    

    // if zero-length string just return
    if (nChar == 0)
        return NO_ERROR;

#ifndef OLE2ANSI

    // Allocate char array and read in string
    pchBuf = new char[nChar];
    if (pchBuf == NULL)
        return E_OUTOFMEMORY;
        
    hr = pIStream->Read(pchBuf, nChar, &nRead);
    
    // Verify read count
    if (!FAILED(hr)) {
        if (nRead != (ULONG)nChar)
            hr = E_FAIL;
    }
    
    if (!FAILED(hr)) {
        // Allocate BString for UNICODE translation
        nWChar = MultiByteToWideChar(CP_ACP, 0, pchBuf, nChar, NULL, 0);
        bstr = SysAllocStringLen(NULL, nWChar);

        if (bstr != NULL)   {
            MultiByteToWideChar(CP_ACP, 0, pchBuf, nChar, bstr, nWChar);
            bstr[nWChar] = 0;
            *pbstrRet = bstr;
        }
        else
            hr = E_OUTOFMEMORY;
     }

    delete [] pchBuf;
    
#else
    // Allocate BString
    bstr = SysAllocStringLen(NULL, nChar);
    if (bstr == NULL)
        return E_OUTOFMEMORY;

    // Read in string
    hr = pIStream->Read(bstr, nChar, &nRead);

    // Verify read count
    if (!FAILED(hr)) {
        if (nRead != (ULONG)nChar)
            hr = E_FAIL;
    }

    // Return or free string
    if (!FAILED(hr))
        *pbstrRet = bstr;
    else
        SysFreeString(bstr);
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\bstrutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    bstrutil.h

Abstract:

    Declares B string utility methods.

--*/


INT SysStringAnsiLen (
	IN BSTR bstr
	);

HRESULT BStrToStream (
	IN	LPSTREAM pIStream, 
	IN	INT	 nChar,
	IN	BSTR bstr
	);

HRESULT BStrFromStream (
	IN	LPSTREAM pIStream,
	IN	INT nChar,
	OUT	BSTR *pbstr
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\cathelp.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    cathelp.cpp

Abstract:

    Component category implementation.

--*/

#include "comcat.h"
#include <strsafe.h>

#define CATEGORY_DESCRIPTION_LEN   128

// Helper function to create a component category and associated description
HRESULT 
CreateComponentCategory (
    IN CATID catid, 
    IN WCHAR* catDescription )
{
    HRESULT hr = S_OK ;
    CATEGORYINFO catinfo;
    ICatRegister* pCatRegister = NULL ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_ICatRegister, 
                          (void**)&pCatRegister);
    if (SUCCEEDED(hr)) {
        //
        // Make sure the HKCR\Component Categories\{..catid...}
        // key is registered
        //
        catinfo.catid = catid;
        catinfo.lcid = 0x0409 ; // english

        //
        // Make sure the provided description is not too long.
        // Only copy the first 127 characters if it is
        //
        StringCchCopy(catinfo.szDescription, CATEGORY_DESCRIPTION_LEN, catDescription);

        hr = pCatRegister->RegisterCategories(1, &catinfo);
    }

    if (pCatRegister != NULL) {
        pCatRegister->Release();
    }

    return hr;
}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(
    IN REFCLSID clsid, 
    IN CATID catid
    )
{
    ICatRegister* pCatRegister = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_ICatRegister, 
                          (void**)&pCatRegister);
    if (SUCCEEDED(hr))
    {
       //
       // Register this category as being "implemented" by
       // the class.
       //
       CATID rgcatid[1] ;

       rgcatid[0] = catid;
       hr = pCatRegister->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pCatRegister != NULL) {
        pCatRegister->Release();
    }
  
    return hr;
}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(
    REFCLSID clsid, 
    CATID catid
    )
{
    ICatRegister* pCatRegister = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_ICatRegister, 
                          (void**)&pCatRegister);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.

       CATID rgcatid[1] ;

       rgcatid[0] = catid;
       hr = pCatRegister->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pCatRegister != NULL) {
        pCatRegister->Release();
    }
  
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\cntrtree.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    cntrtree.h

Abstract:

    Header for the counter hierarchy.

--*/

#ifndef _CNTRTREE_H_
#define _CNTRTREE_H_

#include "namenode.h"

enum {
    MACHINE_NODE,
    OBJECT_NODE,
    INSTANCE_NODE,
    COUNTER_NODE,
    ITEM_NODE
};


//
class CMachineNode;
class CObjectNode;
class CCounterNode;
class CInstanceNode;
class CReport;
class CGraphItem;

//
// Class CCounterTree
//
class CCounterTree
{
    friend CMachineNode;
    friend CInstanceNode;

public:
    CCounterTree( void );
    HRESULT AddCounterItem( LPWSTR pszPath, CGraphItem* pItem, BOOL bMonitorDuplicateInstances );
    void RemoveCounterItem( CGraphItem* pItem );
    void RemoveMachine( CMachineNode *pMachine);

    HRESULT GetMachine( LPWSTR pszName, CMachineNode **pMachineRet );
    CMachineNode *FirstMachine( void ) { return (CMachineNode*)m_listMachines.First(); }
    CGraphItem* FirstCounter( void );
    INT NumCounters( void )  { return m_nItems; }
    HRESULT IndexFromCounter( const CGraphItem* pItem, INT* pIndex );

private:
    CNamedNodeList m_listMachines;
    INT m_nItems;

};

typedef CCounterTree *PCCounterTree;

//
// Class CMachineNode
//
class CMachineNode : public CNamedNode
{
    friend CCounterTree;
    friend CGraphItem;
    friend CReport;

public:

//        void *operator new( size_t stBlock, LPWSTR pszName );
#if _MSC_VER >= 1300
    void operator delete ( void *pObject );
#endif
    void *operator new( size_t stBlock, UINT iLength);
    void operator delete ( void *pObject, UINT );

    CMachineNode( void ) { m_xWidth = -1; }

    HRESULT GetCounterObject(LPWSTR pszName, CObjectNode **ppObject);
    HRESULT AddObject(CObjectNode *pObject);
    void RemoveObject(CObjectNode *pObject);
    void DeleteNode (BOOL bPropagateUp);

    LPCWSTR Name( void ) {return m_szName;}
    CMachineNode *Next( void ) { return (CMachineNode*)m_pnodeNext; }
    CObjectNode *FirstObject( void ) { return (CObjectNode*)m_listObjects.First(); }

private:
    PCCounterTree m_pCounterTree;
    CNamedNodeList m_listObjects;
    INT   m_xWidth;
    INT   m_yPos;
    WCHAR m_szName[1];
};

typedef CMachineNode *PCMachineNode;

//
// Class CObjectNode
//
class CObjectNode : public CNamedNode
{
    friend CMachineNode;
    friend CGraphItem;
    friend CReport;

public:
//        void *operator new( size_t stBlock, LPWSTR pszName );
#if _MSC_VER >= 1300
    void operator delete ( void *pObject );
#endif
    void *operator new( size_t stBlock, UINT iLength);
    void operator delete ( void *pObject, UINT );
    CObjectNode( void ) { m_xWidth = -1; }

    LPCWSTR Name() {return m_szName;}

    HRESULT GetCounter(LPWSTR pszName, CCounterNode **ppObject);
    HRESULT AddCounter(CCounterNode *pCounter);
    void RemoveCounter(CCounterNode *pCounter);
    void DeleteNode (BOOL bPropagateUp);

    HRESULT GetInstance(
                LPWSTR pszParent,
                LPWSTR pszName,
                DWORD dwIndex,
                BOOL bMonitorDuplicateInstances,
                CInstanceNode **ppObject );
    HRESULT AddInstance(CInstanceNode *pInstance);
    void RemoveInstance(CInstanceNode *pInstance);

    CObjectNode *Next( void ) { return (CObjectNode*)m_pnodeNext; }
    CInstanceNode *FirstInstance( void ) { return (CInstanceNode*)m_listInstances.First(); }
    CCounterNode *FirstCounter( void ) { return (CCounterNode*)m_listCounters.First(); }

private:
    PCMachineNode   m_pMachine;
    CNamedNodeList  m_listCounters;
    CNamedNodeList  m_listInstances;
    INT   m_yPos;
    INT   m_xWidth;
    WCHAR m_szName[1];
};

typedef CObjectNode *PCObjectNode;

//
// Class CInstanceNode
//
class CInstanceNode : public CNamedNode
{
    friend CObjectNode;
    friend CGraphItem;
    friend CReport;

private:
    PCObjectNode    m_pObject;
    CGraphItem   *m_pItems;
    INT    m_xPos;
    INT    m_xWidth;
    INT    m_nParentLen;
    LPWSTR m_pCachedParentName;
    LPWSTR m_pCachedInstName;
    WCHAR  m_szName[1];

public:
//        void *operator new( size_t stBlock, LPWSTR pszName );
#if _MSC_VER >= 1300
    void operator delete ( void *pObject );
#endif
    void *operator new( size_t stBlock, UINT iLength);
    void operator delete ( void *pObject, UINT );
    CInstanceNode() 
    { 
        m_pItems = NULL; 
        m_xWidth = -1; 
        m_pCachedParentName = NULL;
        m_pCachedInstName = NULL;
    }


    LPCWSTR Name( void ) {return m_szName;}
    BOOL HasParent( void ) {return m_nParentLen; }
    LPWSTR GetParentName ();
    LPWSTR GetInstanceName();

    HRESULT AddItem( CCounterNode *pCounter, CGraphItem* pItemNew );
    void RemoveItem( CGraphItem* pItem );
    void DeleteNode (BOOL bPropagateUp);

    CInstanceNode *Next( void ) { return (CInstanceNode*)m_pnodeNext; }
    CGraphItem *FirstItem( void ) { return m_pItems; }

};

typedef CInstanceNode *PCInstanceNode;

//
// Class CCounterNode
//
class CCounterNode : public CNamedNode
{
    friend CObjectNode;
    friend CGraphItem;
    friend CReport;

public:
    CGraphItem *m_pFirstGenerated;

//        void *operator new( size_t stBlock, LPWSTR pszName );
#if _MSC_VER >= 1300
    void operator delete ( void *pObject );
#endif
    void *operator new( size_t stBlock, UINT iLength);
    void operator delete ( void *pObject, UINT );

    CCounterNode( void ) { m_nCounterRef = 0;m_xWidth = -1;}
    void AddItem ( CGraphItem* ) { m_nCounterRef++; }
    void RemoveItem ( CGraphItem* ) { if (--m_nCounterRef == 0) m_pObject->RemoveCounter(this); }

    LPCWSTR Name( void ) {return m_szName;}
    CCounterNode *Next( void ) { return (CCounterNode*)m_pnodeNext; }
    void DeleteNode (BOOL bPropagateUp);

private:
    PCObjectNode    m_pObject;
    INT    m_nCounterRef;
    INT    m_yPos;
    INT    m_xWidth;

    WCHAR m_szName[1];

};

typedef CCounterNode *PCCounterNode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\cntrtree.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    cntrtree.cpp

Abstract:

    Implements internal counter management.

--*/

#include "polyline.h"
#include <strsafe.h>
#include <assert.h>
#include <pdhmsg.h>
#include "smonmsg.h"
#include "appmema.h"
#include "grphitem.h"
#include "cntrtree.h"

CCounterTree::CCounterTree()
:   m_nItems (0)
{
}

HRESULT
CCounterTree::AddCounterItem(
    LPWSTR pszPath, 
    PCGraphItem pItem, 
    BOOL bMonitorDuplicateInstances
    )
{
    HRESULT hr;
    PPDH_COUNTER_PATH_ELEMENTS pPathInfo = NULL;
    ULONG ulBufSize;
    PDH_STATUS stat;
    CMachineNode *pMachine;
    CObjectNode  *pObject;
    CCounterNode *pCounter;
    CInstanceNode *pInstance;

    if ( NULL != pszPath && NULL != pItem ) { 

        // Record whether machine is explicit or defaults to local
        pItem->m_fLocalMachine = !(pszPath[0] == L'\\' && pszPath[1] == L'\\');

        pPathInfo = NULL;
        do {
            if (pPathInfo) {
                delete [] ((char*)pPathInfo);
                pPathInfo = NULL;
            }
            else {
                ulBufSize = sizeof(PDH_COUNTER_PATH_ELEMENTS) + sizeof(WCHAR) * PDH_MAX_COUNTER_PATH;
            }

            pPathInfo = (PPDH_COUNTER_PATH_ELEMENTS) new char [ ulBufSize ];

            if (pPathInfo == NULL) {
                return E_OUTOFMEMORY;
            }

            stat = PdhParseCounterPath( pszPath, pPathInfo, & ulBufSize, 0);

        } while (stat == PDH_INSUFFICIENT_BUFFER || stat == PDH_MORE_DATA);


        //
        // We use do {} while (0) here to act like a switch statement
        //
        do {
            if (stat != ERROR_SUCCESS) {
                hr = E_FAIL;
                break;
            }

            // Find or create each level of hierarchy
            hr = GetMachine( pPathInfo->szMachineName, &pMachine);
            if (FAILED(hr) || NULL == pMachine ) {
                break;
            }

            hr = pMachine->GetCounterObject(pPathInfo->szObjectName, &pObject);
            if (FAILED(hr) || NULL == pObject ) {
                break;
            }

            hr = pObject->GetCounter(pPathInfo->szCounterName, &pCounter);
            if (FAILED(hr) || NULL == pCounter ) {
                break;
            }

            hr = pObject->GetInstance(
                    pPathInfo->szParentInstance,
                    pPathInfo->szInstanceName,
                    pPathInfo->dwInstanceIndex,
                    bMonitorDuplicateInstances,
                    &pInstance);

            if (FAILED(hr) || NULL == pInstance ) {
                break;
            }

            hr = pInstance->AddItem(pCounter, pItem);
    
            if (SUCCEEDED(hr)) {
                m_nItems++;
                UpdateAppPerfDwordData (DD_ITEM_COUNT, m_nItems);
            }
        } while (0);
    } else {
        hr = E_INVALIDARG;
    }

    if (pPathInfo) {
        delete [] ((char*)pPathInfo);
    }

    return hr;
}


HRESULT
CCounterTree::GetMachine (
    IN  LPWSTR pszName,
    OUT PCMachineNode *ppMachineRet
    )
{
    PCMachineNode pMachine = NULL;
    PCMachineNode pMachineNew = NULL;
    HRESULT hr = NOERROR;

    if ( NULL == ppMachineRet || NULL == pszName ) {
        hr = E_POINTER;
    } else {

        *ppMachineRet = NULL;

        if (m_listMachines.FindByName(pszName, FIELD_OFFSET(CMachineNode, m_szName), (PCNamedNode*)&pMachine)) {
            *ppMachineRet = pMachine;
            hr = NOERROR;
        } else {

            pMachineNew = new(lstrlen(pszName) * sizeof(WCHAR)) CMachineNode;
            if (!pMachineNew) {
                hr = E_OUTOFMEMORY;
            } else {
                pMachineNew->m_pCounterTree = this;
                StringCchCopy(pMachineNew->m_szName, lstrlen(pszName) + 1, pszName);

                m_listMachines.Add(pMachineNew, pMachine);

                *ppMachineRet = pMachineNew;

                hr = NOERROR;
            }
        }
    }
    return hr;
}


void
CCounterTree::RemoveMachine (
    IN PCMachineNode pMachine
    )
{
    // Remove machine from list and delete it
    m_listMachines.Remove(pMachine);
    delete pMachine ;
}

PCGraphItem
CCounterTree::FirstCounter (
    void
    )
{
    if (!FirstMachine())
        return NULL;
    else
        return FirstMachine()->FirstObject()->FirstInstance()->FirstItem();
}

HRESULT
CCounterTree::IndexFromCounter (
    IN  const   CGraphItem* pItem, 
    OUT         INT* pIndex )    
{  
    HRESULT     hr = E_POINTER;
    CGraphItem* pLocalItem;
    INT         iLocalIndex = 0;

    if ( NULL != pItem && NULL != pIndex ) {
        *pIndex = 0;
        hr = E_INVALIDARG;
        pLocalItem = FirstCounter();
        while ( NULL != pLocalItem ) {
            iLocalIndex++;
            if ( pLocalItem != pItem ) {
                pLocalItem = pLocalItem->Next();
            } else {
                *pIndex = iLocalIndex;
                hr = S_OK;
                break;
            } 
        }
    }

    return hr;
}

HRESULT
CMachineNode::GetCounterObject (
    IN  LPWSTR pszName,
    OUT PCObjectNode *ppObjectRet
    )
{
    PCObjectNode pObject;
    PCObjectNode pObjectNew;

    if (m_listObjects.FindByName(pszName, FIELD_OFFSET(CObjectNode, m_szName), (PCNamedNode*)&pObject)) {
        *ppObjectRet = pObject;
        return NOERROR;
    }

    pObjectNew = new(lstrlen(pszName) * sizeof(WCHAR)) CObjectNode;
    if (!pObjectNew)
        return E_OUTOFMEMORY;

    pObjectNew->m_pMachine = this;
    StringCchCopy(pObjectNew->m_szName, lstrlen(pszName) + 1, pszName);

    m_listObjects.Add(pObjectNew, pObject);

    *ppObjectRet = pObjectNew;

    return NOERROR;
}


void
CMachineNode::RemoveObject (
    IN PCObjectNode pObject
    )
{
    // Remove object from list and delete it
    m_listObjects.Remove(pObject);
    delete pObject;

    // If this was the last one, remove ourself
    if (m_listObjects.IsEmpty())
        m_pCounterTree->RemoveMachine(this);

}

void
CMachineNode::DeleteNode (
    BOOL    bPropagateUp
    )
{
    PCObjectNode pObject;
    PCObjectNode pNextObject;

    // Delete all object nodes
    pObject = FirstObject();
    while ( NULL != pObject ) {
        pNextObject = pObject->Next();
        pObject->DeleteNode(FALSE);
        m_listObjects.Remove(pObject);
        delete pObject;
        pObject = pNextObject;
    }

    assert(m_listObjects.IsEmpty());

    // Notify parent if requested
    if (bPropagateUp) {
        m_pCounterTree->RemoveMachine(this);
    }
}

HRESULT
CObjectNode::GetCounter (
    IN  LPWSTR pszName,
    OUT PCCounterNode *ppCounterRet
    )
{
    PCCounterNode pCounter;
    PCCounterNode pCounterNew;

    if (m_listCounters.FindByName(pszName, FIELD_OFFSET(CCounterNode, m_szName), (PCNamedNode*)&pCounter)) {
        *ppCounterRet = pCounter;
        return NOERROR;
    }

    pCounterNew = new(lstrlen(pszName) * sizeof(WCHAR)) CCounterNode;
    if (!pCounterNew)
        return E_OUTOFMEMORY;

    pCounterNew->m_pObject = this;
    StringCchCopy(pCounterNew->m_szName, lstrlen(pszName) + 1, pszName);

    m_listCounters.Add(pCounterNew, pCounter);

    *ppCounterRet = pCounterNew;

    return NOERROR;
}

//
// The minimum of length of instance name is
// 12. 10 characters for index number(4G)
// 1 for '#' and 1 for terminating 0.
//
#define  MIN_INSTANCE_NAME_LEN  12

HRESULT
CObjectNode::GetInstance (
    IN  LPWSTR pszParent,
    IN  LPWSTR pszInstance,
    IN  DWORD  dwIndex,
    IN  BOOL bMonitorDuplicateInstances,
    OUT PCInstanceNode *ppInstanceRet
    )
{
    HRESULT hr = NOERROR;
    PCInstanceNode pInstance;
    PCInstanceNode pInstanceNew;
    LPWSTR szInstName = NULL;
    LONG lSize = MIN_INSTANCE_NAME_LEN;
    LONG lInstanceLen = 0;
    LONG lParentLen = 0;

    //
    // Calculate the length of the buffer to
    // hold the instance and parent names.
    //
    if (pszInstance) {
        lSize += lstrlen(pszInstance);
    }

    if (pszParent) {
        lParentLen = lstrlen(pszParent);
    }

    lSize += lParentLen + 1;

    szInstName = new WCHAR [lSize];
    if (szInstName == NULL) {
        return E_OUTOFMEMORY;
    }

    //
    // Initialize the string
    //
    szInstName[0] = L'\0';

    if (pszInstance) {
        //
        // If the parent name exists, copy it 
        //
        if (pszParent) {
            StringCchCopy(szInstName, lSize, pszParent);
            
            szInstName[lParentLen]   = L'/';
            szInstName[lParentLen+1] = L'\0';
        }

        //
        // Copy the instance name.
        //
        StringCchCat(szInstName, lSize, pszInstance);
        
        //
        // Append instance index
        //
        // "#n" is only appended to the stored name if the index is > 0.
        //
        if ( dwIndex > 0 && bMonitorDuplicateInstances ) {
            StringCchPrintf(&szInstName[lstrlen(szInstName)], 
                           lSize - lstrlen(szInstName),
                           L"#%d", 
                           dwIndex);
        }
    }

    //
    // We use do {} while (0) to act like a switch statement
    //
    do {
        if (m_listInstances.FindByName(szInstName, 
                                       FIELD_OFFSET(CInstanceNode, m_szName), 
                                       (PCNamedNode*)&pInstance)) {
            *ppInstanceRet = pInstance;
            break;
        }

        //
        // Create a new one if can not find it
        //
        lInstanceLen = lstrlen(szInstName);
        pInstanceNew = new(lInstanceLen * sizeof(WCHAR)) CInstanceNode;
        if (!pInstanceNew) {
            hr = E_OUTOFMEMORY;
            break;
        }

        pInstanceNew->m_pObject = this;
        pInstanceNew->m_nParentLen = lParentLen;
        StringCchCopy(pInstanceNew->m_szName, lInstanceLen + 1, szInstName);

        m_listInstances.Add(pInstanceNew, pInstance);

        *ppInstanceRet = pInstanceNew;
    } while (0);

    if (szInstName) {
        delete [] szInstName;
    }

    return hr;
}

void
CObjectNode::RemoveInstance (
    IN PCInstanceNode pInstance
    )
{
    // Remove instance from list and delete it
    m_listInstances.Remove(pInstance);
    if (pInstance->m_pCachedParentName) {
        delete [] pInstance->m_pCachedParentName;
    }
    if (pInstance->m_pCachedInstName) {
        delete [] pInstance->m_pCachedInstName;
    }

    delete pInstance ;

    // if that was the last instance, remove ourself
    if (m_listInstances.IsEmpty())
        m_pMachine->RemoveObject(this);
}

void
CObjectNode::RemoveCounter (
    IN PCCounterNode pCounter
    )
{
    // Remove counter from list and delete it
    m_listCounters.Remove(pCounter);
    delete pCounter;

    // Don't propagate removal up to object.
    // It will go away when the last instance is removed.
}

void
CObjectNode::DeleteNode (
    BOOL bPropagateUp
    )
{
    PCInstanceNode pInstance;
    PCInstanceNode pNextInstance;

    // Delete all instance nodes
    pInstance = FirstInstance();
    while ( NULL != pInstance ) {
        pNextInstance = pInstance->Next();
        pInstance->DeleteNode(FALSE);
        m_listInstances.Remove(pInstance);
        delete pInstance;
        pInstance = pNextInstance;
    }

    // No need to delete counters nodes as they get
    // deleted as their last paired instance does

    // Notify parent if requested
    if (bPropagateUp)
        m_pMachine->RemoveObject(this);
}

HRESULT
CInstanceNode::AddItem (
    IN  PCCounterNode pCounter,
    IN  PCGraphItem   pItemNew
    )
{
    PCGraphItem pItemPrev = NULL;
    PCGraphItem pItem = m_pItems;
    INT iStat = 1;

    // Check for existing item for specified counter, stopping at insertion point
    while ( pItem != NULL && (iStat = lstrcmp(pCounter->Name(), pItem->m_pCounter->Name())) > 0) {
        pItemPrev = pItem;
        pItem = pItem->m_pNextItem;
    }

    // if item exists, return duplicate error status
    if (iStat == 0) {
        return SMON_STATUS_DUPL_COUNTER_PATH;
    }
    // else insert the new item
    else {
        if (pItemPrev != NULL) {
            pItemNew->m_pNextItem = pItemPrev->m_pNextItem;
            pItemPrev->m_pNextItem = pItemNew;
        }
        else if (m_pItems != NULL) {
            pItemNew->m_pNextItem = m_pItems;
            m_pItems = pItemNew;
        }
        else {
            m_pItems = pItemNew;
        }
    }

    // Set back links
    pItemNew->m_pInstance = this;
    pItemNew->m_pCounter = pCounter;

    pCounter->AddItem(pItem);

    return NOERROR;

}

void
CInstanceNode::RemoveItem (
    IN PCGraphItem pitem
    )
{
    PCGraphItem pitemPrev = NULL;
    PCGraphItem pitemTemp = m_pItems;

    // Locate item in list
    while (pitemTemp != NULL && pitemTemp != pitem) {
        pitemPrev = pitemTemp;
        pitemTemp = pitemTemp->m_pNextItem;
    }

    if (pitemTemp == NULL)
        return;

    // Remove from list
    if (pitemPrev)
        pitemPrev->m_pNextItem = pitem->m_pNextItem;
    else
        m_pItems = pitem->m_pNextItem;

    // Remove item from Counter set
    pitem->Counter()->RemoveItem(pitem);

    // Decrement the total item count
    pitem->Tree()->m_nItems--;
    UpdateAppPerfDwordData (DD_ITEM_COUNT, pitem->Tree()->m_nItems);

  // Release the item
    pitem->Release();

    // if last item under this instance, remove the instance
    if (m_pItems == NULL)
        m_pObject->RemoveInstance(this);
}


void
CInstanceNode::DeleteNode (
    BOOL bPropagateUp
    )
{
    PCGraphItem pItem;

    pItem = m_pItems;

    while ( NULL != pItem ) {
        m_pItems = pItem->m_pNextItem;
        pItem->Delete(FALSE);
        pItem->Counter()->RemoveItem(pItem);
        pItem->Release();
        pItem = m_pItems;
    }

    if (bPropagateUp)
        m_pObject->RemoveInstance(this);
}


LPWSTR
CInstanceNode::GetParentName()
{
    if (m_pCachedParentName == NULL) {
        m_pCachedParentName = new WCHAR [m_nParentLen + 1];
        if (m_pCachedParentName == NULL) {
            return L"";
        }
        if (m_nParentLen) {
            StringCchCopy(m_pCachedParentName, m_nParentLen + 1, m_szName);
        }
        else {
            m_pCachedParentName[0] = 0;
        }
    }
    return m_pCachedParentName;
}


LPWSTR
CInstanceNode::GetInstanceName()
{
    LPWSTR pszInst = m_nParentLen ? (m_szName + m_nParentLen + 1) : m_szName;

    if (m_pCachedInstName == NULL) {
        m_pCachedInstName = new WCHAR [lstrlen(pszInst) + 1];
        if (m_pCachedInstName == NULL) {
            return L"";
        }
        StringCchCopy(m_pCachedInstName, lstrlen(pszInst) + 1, pszInst);
    }
    return m_pCachedInstName;
}

void
CCounterNode::DeleteNode (
    BOOL bPropagateUp
    )
{
    PCInstanceNode pInstance, pInstNext;
    PCGraphItem pItem, pItemNext;

    if (!bPropagateUp)
        return;

    // We have to delete the counters item via the instances
    // because they maintain the linked list of items
    pInstance = m_pObject->FirstInstance();
    while (pInstance) {

        pInstNext = pInstance->Next();

        pItem = pInstance->FirstItem();
        while (pItem) {

            if (pItem->Counter() == this) {

                // Delete all UI associated with the item
                pItem->Delete(FALSE);

                pItemNext = pItem->m_pNextItem;

                // Note that Instance->RemoveItem() will
                // also remove counters that have no more items
                pItem->Instance()->RemoveItem(pItem);

                pItem = pItemNext;
            }
            else {
                pItem = pItem->m_pNextItem;
            }
        }

        pInstance = pInstNext;
    }
}


/*******************************

CCounterNode::~CCounterNode (
    IN  PCGraphItem pItem
    )
{

    PCGraphItem pItemPrev = NULL;
    PCGraphItem pItemFind = m_pItems;

    // Find item in list
    while (pItemFind != NULL && pItemFind != pItem) {
        pItemPrev = pItem;
        pItem = pItem->m_pNextItem;
    }

    if (pItemFind != pItem)
        return E_FAIL;

    // Unlink from counter item list
    if (pItemPrev)
        pItemPrev->m_pNextItem = pItem->m_pNextItem;
    else
        m_pItems = pItem->m_pNextItem;

    // Unlink from instance
    pItem->m_pInstance->RemoveCounter(pItem);

    // if no more items, remove self from parnet object
    if (m_pItems == NULL) {
        m_pObject->RemoveCounter(this);

    return NOERROR;
}
*******************************/
/*
void*
CMachineNode::operator new( size_t stBlock, LPWSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(WCHAR)); }


void
CMachineNode::operator delete ( void * pObject, LPWSTR )
{ free(pObject); }

void*
CObjectNode::operator new( size_t stBlock, LPWSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(WCHAR)); }

void
CObjectNode::operator delete ( void * pObject, LPWSTR )
{ free(pObject); }

void*
CInstanceNode::operator new( size_t stBlock, LPWSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(WCHAR)); }

void
CInstanceNode::operator delete ( void * pObject, LPWSTR )
{ free(pObject); }

void*
CCounterNode::operator new( size_t stBlock, LPWSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(WCHAR)); }

void
CCounterNode::operator delete ( void * pObject, LPWSTR )
{ free(pObject); }CMachineNode::operator new( size_t stBlock, INT iLength )
*/

void *
CMachineNode::operator new( size_t stBlock, UINT iLength )
{ 
    return malloc(stBlock + iLength); 
}


void
CMachineNode::operator delete ( void * pObject, UINT )
{ 
    free(pObject); 
}

void*
CObjectNode::operator new( size_t stBlock, UINT iLength  )
{ 
    return malloc(stBlock + iLength); 
}

void
CObjectNode::operator delete ( void * pObject, UINT )
{ 
    free(pObject); 
}

void*
CInstanceNode::operator new( size_t stBlock, UINT iLength  )
{ 
    return malloc(stBlock + iLength); 
}

void
CInstanceNode::operator delete ( void * pObject, UINT )
{
    free(pObject); 
}

void*
CCounterNode::operator new( size_t stBlock, UINT iLength  )
{ 
    return malloc(stBlock + iLength); 
}

void
CCounterNode::operator delete ( void * pObject, UINT )
{ 
    free(pObject); 
}

#if _MSC_VER >= 1300
void
CMachineNode::operator delete ( void * pObject )
{ free(pObject); }

void
CObjectNode::operator delete ( void * pObject )
{ free(pObject); }

void
CInstanceNode::operator delete ( void * pObject )
{ 
    free(pObject); 
}

void
CCounterNode::operator delete ( void * pObject )
{ free(pObject); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\colefont.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    colefont.cpp

Abstract:

    Font class.

--*/

#include "polyline.h"
#include <strsafe.h>
#include "unihelpr.h"
#include "winhelpr.h"
#include "COleFont.h"

#pragma warning ( disable : 4355 ) // "this" used in initializer list

const   LPWSTR  COleFont::m_cwszDefaultFaceName = L"MS Shell Dlg";
const   INT     COleFont::m_iDefaultTmHeight = 13;
const   SHORT   COleFont::m_iDefaultTmWeight = 400;
const   INT     COleFont::m_iDefaultRiPxlsPerInch = 96;

COleFont::COleFont (
    CSysmonControl  *pCtrl
    ) 
    : m_NotifySink( this )
{
    m_pIFont = NULL;
    m_pIFontBold = NULL;
    m_pCtrl = pCtrl;
    m_pIConnPt = NULL;
}

COleFont::~COleFont (
    void 
    )
{
    // Release current connection point
    if (m_pIConnPt) {
        m_pIConnPt->Unadvise(m_dwCookie);
        ReleaseInterface(m_pIConnPt);
    }

    // Release fonts
    ReleaseInterface(m_pIFont);
    ReleaseInterface(m_pIFontBold);
}

void 
COleFont::InitDefaultFontDesc (
    FONTDESC&   rFontDesc,
    INT&        riPxlsPerInch,
    WCHAR       achFaceName[LF_FACESIZE+1]
    )
{
    TEXTMETRIC  TextMetrics;
    HFONT       hFontOld;
    HDC         hDC;

// Todo:  Must define proper default values, move them to resources
// for localization.

    ZeroMemory ( &rFontDesc, sizeof ( FONTDESC ) );

    // Select default font
    hDC = GetDC(NULL);
    
    if ( NULL != hDC ) {

        hFontOld = SelectFont(hDC, (HFONT)GetStockObject(DEFAULT_GUI_FONT));

        // Get face name and size
        //
        // TODO: Should we check the return error code here?
        //
        GetTextMetrics(hDC, &TextMetrics);
        GetTextFaceW(hDC, LF_FACESIZE, achFaceName);

        // Get pixels per inch
        riPxlsPerInch = GetDeviceCaps(hDC, LOGPIXELSY);

        // Create a default font
        rFontDesc.lpstrName = achFaceName;
        rFontDesc.cySize.int64 = ((TextMetrics.tmHeight * 72) / riPxlsPerInch) * 10000;
        rFontDesc.sWeight = (short)TextMetrics.tmWeight; 

        SelectFont(hDC, hFontOld);

        ReleaseDC(NULL, hDC);

    } 
    else {
        riPxlsPerInch = m_iDefaultRiPxlsPerInch;
        StringCchCopy(achFaceName, LF_FACESIZE+1, m_cwszDefaultFaceName);

        // Create a default font
        rFontDesc.lpstrName = achFaceName;
        rFontDesc.cySize.int64 = ((m_iDefaultTmHeight * 72) / m_iDefaultRiPxlsPerInch) * 10000;
        rFontDesc.sWeight = m_iDefaultTmWeight; 
    }

    rFontDesc.cbSizeofstruct = sizeof(rFontDesc);
    rFontDesc.sCharset = DEFAULT_CHARSET; 
    rFontDesc.fItalic = 0; 
    rFontDesc.fUnderline = 0; 
    rFontDesc.fStrikethrough = 0;
}

HRESULT COleFont::Init (
    VOID
    )
{
    HRESULT     hr;
    FONTDESC    fontDesc;
    WCHAR       achFontFaceName[LF_FACESIZE+1];
    LPFONT      pIFont;
    INT         iPxlsPerInch;

    InitDefaultFontDesc ( fontDesc, iPxlsPerInch, achFontFaceName );

    hr = OleCreateFontIndirect(&fontDesc, IID_IFont, (void**)&pIFont);
    if (FAILED(hr)) {
        return hr;
    }

    pIFont->SetRatio(iPxlsPerInch, HIMETRIC_PER_INCH);

    hr = SetIFont(pIFont);

    pIFont->Release();

    return hr;

}


STDMETHODIMP COleFont::SetIFont(
    LPFONT  pIFont
    )
{
    HRESULT hr;
    IConnectionPointContainer *pIConnPtCont;
    IPropertyNotifySink *pISink;

    // Release current connection point
    if (m_pIConnPt) {
        m_pIConnPt->Unadvise(m_dwCookie);
        ReleaseInterface(m_pIConnPt);
    }

    // Release current fonts
    ClearInterface(m_pIFont);
    ClearInterface(m_pIFontBold);

    // Addref and hold new IFont
    m_pIFont = pIFont;
    m_pIFont->AddRef();

    // Get it's property notify connection point
    hr = pIFont->QueryInterface(IID_IConnectionPointContainer, (void **)&pIConnPtCont);
    if (SUCCEEDED(hr)) {

        hr = pIConnPtCont->FindConnectionPoint(IID_IPropertyNotifySink, &m_pIConnPt);
        pIConnPtCont->Release();

        // Connect our sink to it
        if (SUCCEEDED(hr)) {
            m_NotifySink.QueryInterface(IID_IPropertyNotifySink, (void **)&pISink);
            hr = m_pIConnPt->Advise(pISink, &m_dwCookie);
        }
    }

    // Force a change notification 
    FontChange(DISPID_UNKNOWN);

    return hr;
}

void
COleFont::FontChange (
    DISPID DispId
    )
{
    CY  size;
    BOOL boolVal;
    short weight;
    BSTR  bstrName;

    // if not bold font, force clone of normal font
    if (m_pIFontBold == NULL) {
        DispId = DISPID_UNKNOWN;
    }

    // Copy changed parameter to bold font
    switch (DispId) {

    case DISPID_FONT_NAME:
        if (SUCCEEDED(m_pIFont->get_Name(&bstrName))) {
            m_pIFontBold->put_Name(bstrName);
            SysFreeString(bstrName);
        }
        break;

    case DISPID_FONT_SIZE:
        m_pIFont->get_Size(&size);
        m_pIFontBold->put_Size(size);
        break;

    case DISPID_FONT_ITALIC:
        m_pIFont->get_Italic(&boolVal);
        m_pIFontBold->put_Italic(boolVal);
        break;

    case DISPID_FONT_UNDER:
        m_pIFont->get_Underline(&boolVal);
        m_pIFontBold->put_Underline(boolVal);
        break;

    case DISPID_FONT_STRIKE:
        m_pIFont->get_Strikethrough(&boolVal);
        m_pIFontBold->put_Strikethrough(boolVal);
        break;

    case DISPID_FONT_WEIGHT:
        m_pIFont->get_Weight(&weight);
        m_pIFontBold->put_Weight(weight);
        m_pIFontBold->put_Bold(TRUE);
        break;

    case DISPID_UNKNOWN:
        ClearInterface(m_pIFontBold);
        if (SUCCEEDED(m_pIFont->Clone(&m_pIFontBold))) {
            m_pIFontBold->put_Bold(TRUE);
        }
    }

    // Notify owner of font change
    m_pCtrl->FontChanged();
}


STDMETHODIMP COleFont::GetFontDisp (
    OUT IFontDisp **ppFont
    )
{
    HRESULT hr = S_OK;

    if (ppFont == NULL) {
        return E_POINTER;
    }

    try {
        *ppFont = NULL;

        if (m_pIFont == NULL) {
            hr = E_UNEXPECTED;
        }
        else {
            hr = m_pIFont->QueryInterface(IID_IFontDisp, (void **)ppFont);
        }
    } catch (...) {
         hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP COleFont::GetHFont (
    OUT HFONT *phFont
    )
{
    HRESULT hr = E_FAIL;

    if (phFont == NULL) {
        return E_POINTER;
    }

    try {
        *phFont = NULL;

        if (m_pIFont != NULL ) {
            hr = m_pIFont->get_hFont(phFont);
        }

        if (FAILED(hr)) {
            *phFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
        }
    } catch (...) {
        hr =  E_POINTER;
    }

    return hr;
}


STDMETHODIMP COleFont::GetHFontBold (
    OUT HFONT *phFont
    )
{
    HRESULT hr = E_FAIL;

    if (phFont == NULL) {
        return E_POINTER;
    }

    try {
        *phFont = NULL;

        if (m_pIFontBold != NULL ) {
            hr = m_pIFontBold->get_hFont(phFont);
        }

        if ( FAILED(hr)) {
            *phFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP COleFont::LoadFromStream (
    IN LPSTREAM  pIStream
    )
{
    HRESULT hr;
    IPersistStream *pIPersist = NULL;
    FONTDESC    fontDesc;
    WCHAR       achFontFaceName[LF_FACESIZE+1];
    LPFONT      pIFont = NULL;
    INT         iPxlsPerInch;

    if (m_pIFont == NULL) {
        return E_UNEXPECTED;
    }

    // Calling pIPersist for the existing font seems to miss some
    // important notification, so create a new font, load properties 
    // from the stream, and replace the current font.

    InitDefaultFontDesc ( fontDesc, iPxlsPerInch, achFontFaceName );

    hr = OleCreateFontIndirect(&fontDesc, IID_IFont, (void**)&pIFont);
    if (FAILED(hr)) {
        return hr;
    }

    pIFont->SetRatio(iPxlsPerInch, HIMETRIC_PER_INCH);    
    
    hr = pIFont->QueryInterface(IID_IPersistStream, (void **)&pIPersist);
    
    if (SUCCEEDED(hr)) {
        hr = pIPersist->Load(pIStream);
        pIPersist->Release();
        hr = SetIFont(pIFont);
    }

    pIFont->Release();
    return hr;
}

STDMETHODIMP COleFont::SaveToStream (
    IN LPSTREAM  pIStream,
    IN BOOL fClearDirty
)
{
    IPersistStream *pIPersist = NULL;
    HRESULT hr;

    if (m_pIFont == NULL) {
        return E_UNEXPECTED;
    }

    hr = m_pIFont->QueryInterface(IID_IPersistStream, (void **)&pIPersist);
    if (SUCCEEDED(hr)) {
        hr = pIPersist->Save(pIStream, fClearDirty);
        pIPersist->Release();
    }

    return hr;
}

HRESULT 
COleFont::LoadFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog* pIErrorLog 
    )
{
    HRESULT     hr = S_OK;
    WCHAR       achFontFaceName[LF_FACESIZE+1];
    WCHAR       achPropBagFaceName[LF_FACESIZE+1];
    INT         iBufSize = LF_FACESIZE+1;
    FONTDESC    fontDesc;
    LPFONT      pIFont;

    VARIANT     vValue;
    BOOL        bValue;
    SHORT       iValue;
    CY          cySize;
    INT         iPxlsPerInch;

    if (m_pIFont == NULL) {
        return E_UNEXPECTED;
    }
    
    InitDefaultFontDesc ( fontDesc, iPxlsPerInch, achFontFaceName );

    hr = StringFromPropertyBag (
            pIPropBag,
            pIErrorLog,
            L"FontName",
            achPropBagFaceName,
            iBufSize );

    if ( SUCCEEDED( hr ) ) {
        fontDesc.lpstrName = achPropBagFaceName;
    }

    hr = CyFromPropertyBag ( pIPropBag, pIErrorLog, L"FontSize", cySize );
    if ( SUCCEEDED( hr ) ){
        fontDesc.cySize.int64 = cySize.int64;
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, L"FontItalic", bValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.fItalic = ( 0 == bValue ? 0 : 1 );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, L"FontUnderline", bValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.fUnderline = ( 0 == bValue ? 0 : 1 );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, L"FontStrikethrough", bValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.fStrikethrough = ( 0 == bValue ? 0 : 1 );
    }

    hr = ShortFromPropertyBag ( pIPropBag, pIErrorLog, L"FontWeight", iValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.sWeight = iValue;
    }

    hr = OleCreateFontIndirect(&fontDesc, IID_IFont, (void**)&pIFont);
    if (FAILED(hr)) {
        return hr;
    }

//    pIFont->SetRatio(iPxlsPerInch, HIMETRIC_PER_INCH);

    hr = SetIFont(pIFont);

    pIFont->Release();

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
COleFont::SaveToPropertyBag (
    IPropertyBag* pIPropBag,
    BOOL /* fClearDirty */,
    BOOL /* fSaveAllProps */ )
{
    HRESULT hr = NOERROR;
    VARIANT vValue;
    BOOL    bValue;
    CY      cySize;
    SHORT   iValue;

    if (m_pIFont == NULL) {
        return E_UNEXPECTED;
    }

    do {
        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        hr = m_pIFont->get_Name( &vValue.bstrVal);

        if (!SUCCEEDED(hr)) {
            break;
        }
        hr = pIPropBag->Write(L"FontName", &vValue );    
        VariantClear ( &vValue );
        if (!SUCCEEDED(hr)) {
            break;
        }

        hr = m_pIFont->get_Size ( &cySize );
        if (!SUCCEEDED(hr)) {
            break;
        }
        hr = CyToPropertyBag ( pIPropBag, L"FontSize", cySize );
        if (!SUCCEEDED(hr)) {
            break;
        }

        hr = m_pIFont->get_Italic ( &bValue );
        if (!SUCCEEDED(hr)) {
            break;
        }
        hr = BOOLToPropertyBag ( pIPropBag, L"FontItalic", bValue );
        if (!SUCCEEDED(hr)) {
            break;
        }

        hr = m_pIFont->get_Underline ( &bValue );
        if (!SUCCEEDED(hr)) {
            break;
        }
        hr = BOOLToPropertyBag ( pIPropBag, L"FontUnderline", bValue );
        if (!SUCCEEDED(hr)) {
            break;
        }

        hr = m_pIFont->get_Strikethrough ( &bValue );
        if (!SUCCEEDED(hr)) {
            break;
        }
        hr = BOOLToPropertyBag ( pIPropBag, L"FontStrikethrough", bValue );
        if (!SUCCEEDED(hr)) {
            break;
        }

        hr = m_pIFont->get_Weight ( &iValue );
        if (!SUCCEEDED(hr)) {
            break;
        }
        hr = ShortToPropertyBag ( pIPropBag, L"FontWeight", iValue );
    } while (0);

    return hr;
}


//----------------------------------------------------------------------------
// CImpIPropertyNotifySink Interface Implementation
//----------------------------------------------------------------------------

/*
 * CImpIPropertyNotifySink::CImpIPropertyNotifySink
 * CImpIPropertyNotifySink::~CImpIPropertyNotifySink
 *
 */

CImpIPropertyNotifySink::CImpIPropertyNotifySink (
    IN COleFont *pOleFont
    )
{
    m_cRef=0;
    m_pOleFont = pOleFont;
}


CImpIPropertyNotifySink::~CImpIPropertyNotifySink (
    void
    )
{
}


/*
 * CImpIPropertyNotifySink::QueryInterface
 * CImpIPropertyNotifySink::AddRef
 * CImpIPropertyNotifySink::Release
 *
 * Purpose:
 *  Non-delegating IUnknown members for CImpIPropertyNotifySink.
 */

STDMETHODIMP 
CImpIPropertyNotifySink::QueryInterface ( 
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv=NULL;

        if (IID_IUnknown==riid || IID_IPropertyNotifySink==riid) {
            *ppv = (LPVOID)this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG) 
CImpIPropertyNotifySink::AddRef(
    void
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) 
CImpIPropertyNotifySink::Release (
    void
    )
{
    if (0 != --m_cRef)
        return m_cRef;

    // delete this;
    return 0;
}


STDMETHODIMP 
CImpIPropertyNotifySink::OnChanged (
    IN DISPID   DispId
    )
{
    // Notify font object of change
    m_pOleFont->FontChange(DispId);

    return S_OK;
}

STDMETHODIMP 
CImpIPropertyNotifySink::OnRequestEdit (
    IN DISPID   // DispId
    )
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\colefont.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    colefont.h

Abstract:

    <abstract>

--*/

#ifndef _COLEFONT_H_
#define _COLEFONT_H_

class COleFont;

class CImpIPropertyNotifySink : public IPropertyNotifySink
{
public:
    CImpIPropertyNotifySink(COleFont* pOleFont);
    ~CImpIPropertyNotifySink(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //Property sink methods
    STDMETHODIMP    OnChanged( DISPID DispId );
    STDMETHODIMP    OnRequestEdit( DISPID );

private:
    COleFont*  m_pOleFont;
    ULONG      m_cRef;

};

class CSysmonControl;

class COleFont 
{
public:
	COleFont ( CSysmonControl *pCtrl );
	~COleFont( void );

    //
    // The following functions are not method of a interface
    // It is better to change the STDMETHODIMP into HRESULT
    //
	STDMETHODIMP	Init( void );
	STDMETHODIMP	SetIFont ( LPFONT pIFont );
	STDMETHODIMP	GetFontDisp ( IFontDisp **ppFont );
	STDMETHODIMP	GetHFont ( HFONT *phFont );
	STDMETHODIMP    GetHFontBold ( HFONT *phFont );
	STDMETHODIMP	SaveToStream ( LPSTREAM pIStream, BOOL fClearDirty );
	STDMETHODIMP	LoadFromStream ( LPSTREAM pIStream );
	STDMETHODIMP	SaveToPropertyBag ( IPropertyBag*, BOOL fClearDirty, BOOL fSaveAllProps );
	STDMETHODIMP	LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
	STDMETHODIMP_(VOID) FontChange ( DISPID DispId );

private:

    void InitDefaultFontDesc ( FONTDESC&, INT&, WCHAR[LF_FACESIZE+1] );

    static const    LPWSTR  m_cwszDefaultFaceName;
    static const    INT     m_iDefaultTmHeight;
    static const    INT     m_iDefaultRiPxlsPerInch;
    static const    SHORT   m_iDefaultTmWeight;

    CSysmonControl	*m_pCtrl;
	IFont			*m_pIFont;
	IFont			*m_pIFontBold;
 	IConnectionPoint *m_pIConnPt;
	CImpIPropertyNotifySink m_NotifySink;
	DWORD	        m_dwCookie;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\comcat.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    comcat.h

--*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Jun 26 18:29:20 1996
 */
/* Compiler settings for comcat.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ComCat.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//=--------------------------------------------------------------------------=
// OLE Componet Categories Interfaces.
//=--------------------------------------------------------------------------=
//




EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
typedef GUID CATID;

typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCATEGORYINFO
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUNCATEGORYINFO;

typedef struct  tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0007
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatRegister
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        END_INTERFACE
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0008
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatInformation
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        END_INTERFACE
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_EnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_IsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0009
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\counters.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    counters.cpp

Abstract:

    Implementation of the ICounters interface

--*/

#include "polyline.h"
#include "counters.h"
#include "grphitem.h"
#include "unkhlpr.h"
#include "unihelpr.h"

//Standard IUnknown implementation for contained interface
IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpICounters)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpICounters)
IMPLEMENT_CONTAINED_ADDREF(CImpICounters)
IMPLEMENT_CONTAINED_RELEASE(CImpICounters)


STDMETHODIMP 
CImpICounters::QueryInterface (
    IN  REFIID riid, 
    OUT PPVOID ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;

        if (IID_IUnknown == riid || IID_ICounters == riid) {
            *ppv = (LPVOID)this;
            AddRef();
        } else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP 
CImpICounters::GetTypeInfoCount (
    OUT UINT *pctInfo
    )
{
    HRESULT hr = S_OK;

    if (pctInfo == NULL) {
        return E_POINTER;
    }

    try {
        *pctInfo = 1;
    } catch (...) {
        hr = E_POINTER;
    } 

    return hr;
}


STDMETHODIMP 
CImpICounters::GetTypeInfo (
    IN  UINT itInfo, 
    IN  LCID /* lcid */, 
    OUT ITypeInfo **ppITypeInfo )
{
    HRESULT hr = S_OK;

    if (ppITypeInfo == NULL) {
        return E_POINTER;
    }

    try {
        *ppITypeInfo = NULL;

        if (0 == itInfo) {
            //
            // We ignore the LCID
            //
            hr = m_pObj->m_pITypeLib->GetTypeInfoOfGuid(IID_ICounters, ppITypeInfo);
        } else {
            hr = TYPE_E_ELEMENTNOTFOUND;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP 
CImpICounters::GetIDsOfNames (
    IN  REFIID riid,
    IN  OLECHAR **rgszNames, 
    IN  UINT cNames,
    IN  LCID /* lcid */,
    OUT DISPID *rgDispID
    )
{
    HRESULT     hr = DISP_E_UNKNOWNINTERFACE;
    ITypeInfo  *pTI = NULL;

    if (rgDispID == NULL || rgszNames == NULL) {
        return E_POINTER;
    }

    if (IID_NULL == riid) {
        try {
            *rgDispID = NULL;

            hr = m_pObj->m_pITypeLib->GetTypeInfoOfGuid(IID_ICounters, &pTI);

            if (SUCCEEDED(hr)) {
                hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
            }
        } catch (...) {
            hr = E_POINTER;
        }
    }

    if (pTI) {
        pTI->Release();
    }

    return hr;
}



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP 
CImpICounters::Invoke ( 
    IN  DISPID dispID, 
    IN  REFIID riid,
    IN  LCID /* lcid */, 
    IN  USHORT wFlags, 
    IN  DISPPARAMS *pDispParams,
    OUT VARIANT *pVarResult, 
    OUT EXCEPINFO *pExcepInfo, 
    OUT UINT *puArgErr
    )
{
    HRESULT     hr = DISP_E_UNKNOWNINTERFACE;
    ITypeInfo  *pTI = NULL;

    if ( IID_NULL == riid ) {
        try {
            hr = m_pObj->m_pITypeLib->GetTypeInfoOfGuid(IID_ICounters, &pTI);

            if (SUCCEEDED(hr)) {

                hr = pTI->Invoke(this, 
                                 dispID, 
                                 wFlags,
                                 pDispParams, 
                                 pVarResult, 
                                 pExcepInfo, 
                                 puArgErr);
            }
        } catch (...) {
            hr = E_POINTER;
        }
    } 

    if (pTI) {
        pTI->Release();
    }

    return hr;
}


STDMETHODIMP
CImpICounters::get_Count (
    OUT LONG *pLong
    )
{
    HRESULT hr = S_OK;

    if (pLong == NULL) {
        return E_POINTER;
    }

    try {
        *pLong = m_pObj->m_Graph.CounterTree.NumCounters();
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpICounters::get__NewEnum (
    IUnknown **ppIunk
    )
{
    HRESULT hr = S_OK;
    CImpIEnumCounter *pEnum = NULL;

    if (ppIunk == NULL) {
        return E_POINTER;
    }

    try {
        *ppIunk = NULL;

        pEnum = new CImpIEnumCounter;

        if ( NULL != pEnum ) {
            hr = pEnum->Init(
                    m_pObj->m_Graph.CounterTree.FirstCounter(), 
                    m_pObj->m_Graph.CounterTree.NumCounters() );

            if ( SUCCEEDED ( hr ) ) {
                *ppIunk = pEnum;
                pEnum->AddRef();    
            } 
        } 
        else {
            hr = E_OUTOFMEMORY;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pEnum != NULL) {
        delete pEnum;
    }

    return hr;
}


STDMETHODIMP
CImpICounters::get_Item (
    IN  VARIANT varIndex, 
    OUT DICounterItem **ppI
    )
{
    HRESULT hr = S_OK;
    VARIANT varLoc;
    INT iIndex = 0;
    INT i;
    CGraphItem *pGItem = NULL;

    if (ppI == NULL) {
        return E_POINTER;
    }

    //
    // Try coercing index to I4
    //
    VariantInit(&varLoc);

    try {
        *ppI = NULL;

        //
        // We use do{}while(0) here to act like a switch statement
        //
        do {
            hr = VariantChangeType(&varLoc, &varIndex, 0, VT_I4);
            if ( !SUCCEEDED (hr) ) {
                break;
            }

            //
            // Verify index is in range
            //
            iIndex = V_I4(&varLoc);
            if (iIndex < 1 || iIndex > m_pObj->m_Graph.CounterTree.NumCounters()) {
                hr = DISP_E_BADINDEX;
                break;
            }

            //
            // Traverse counter linked list to indexed item
            //
            pGItem = m_pObj->m_Graph.CounterTree.FirstCounter();
            i = 1;
            while (i++ < iIndex && pGItem != NULL) {
                pGItem = pGItem->Next();
            }

            //
            // Something wrong with linked list!!
            //
            if ( NULL == pGItem ) {
                hr = E_FAIL;
                break;
            }

            //
            // Return counter's dispatch interface
            //
            hr = pGItem->QueryInterface(DIID_DICounterItem, (PVOID*)ppI);

        } while (0);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpICounters::Add (
    IN  BSTR bstrPath,
    OUT DICounterItem **ppI
    )
{
    HRESULT hr = S_OK;
    PCGraphItem pGItem = NULL;

    if (ppI == NULL) {
        return E_POINTER;
    }

    try {
        *ppI = NULL;

        //
        // If non-null counter
        //
        if (bstrPath != NULL && bstrPath[0] != 0) {
            hr = m_pObj->m_pCtrl->AddCounter(bstrPath, &pGItem);
            if ( SUCCEEDED (hr)  && NULL != pGItem) {
                hr = pGItem->QueryInterface(DIID_DICounterItem, (PVOID*)ppI);
            }
        } 
        else {
            hr = E_INVALIDARG;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (pGItem) {
        pGItem->Release();
    }
    return hr;
}


STDMETHODIMP
CImpICounters::Remove (
    IN  VARIANT varIndex
    )
{
    DICounterItem *pDI = NULL;
    PCGraphItem pGItem;
    HRESULT hr;

    // Get interface to indexed item
    hr = get_Item(varIndex, &pDI);

    if ( SUCCEEDED ( hr ) ) {
        // Exchange Dispatch interface for direct one
        hr = pDI->QueryInterface(IID_ICounterItem, (PVOID*)&pGItem);
        pDI->Release();
        if ( SUCCEEDED ( hr ) ) {
            assert ( NULL != pGItem );

            // Delete the item from the control
            pGItem->Delete(TRUE);

            // Release the temp interface
            pGItem->Release();
        }
    }
    return hr;
}


CImpIEnumCounter::CImpIEnumCounter (
    VOID
    )
{
    m_cItems = 0;
    m_uCurrent = 0;
    m_cRef = 0;
    m_paGraphItem = NULL;
}


HRESULT
CImpIEnumCounter::Init (    
    PCGraphItem pGraphItem,
    INT         cItems
    )
{
    HRESULT hr = S_OK;
    INT i;

    if ( cItems > 0 ) {
        m_cItems = cItems;
        m_paGraphItem = (PCGraphItem*)malloc(sizeof(PCGraphItem) * cItems);

        if ( NULL != m_paGraphItem ) {
            ZeroMemory(m_paGraphItem, sizeof(PCGraphItem) * cItems);

            for (i = 0; i < cItems; i++) {
                m_paGraphItem[i] = pGraphItem;
                pGraphItem = pGraphItem->Next();
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } // No error if cItems <= 0

    return hr;
}

    

STDMETHODIMP
CImpIEnumCounter::QueryInterface (
    IN  REFIID riid, 
    OUT PVOID *ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;

        if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT)) {
            *ppv = this;
            AddRef();
        } else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG)
CImpIEnumCounter::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CImpIEnumCounter::Release(
    VOID
    )
{
    if (--m_cRef == 0) {

        if (m_paGraphItem != NULL)
            free(m_paGraphItem);

        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CImpIEnumCounter::Next(
    IN  ULONG cItems,
    OUT VARIANT *varItem,
    OUT ULONG *pcReturned
    )
{
    HRESULT hr = S_OK;
    ULONG i;
    ULONG cRet;

    if (varItem == NULL) {
        return E_POINTER;
    }

    try {
        //
        // Clear the return variants
        //
        for (i = 0; i < cItems; i++) {
            VariantInit(&varItem[i]);
        }
    
        //
        // Try to fill the caller's array
        //
        for (cRet = 0; cRet < cItems; cRet++) {

            //
            // No more, return success with false
            //
            if (m_uCurrent == m_cItems) {
                hr = S_FALSE;
                break;
            }

            //
            // Get a dispatch interface for the item
            //
            hr = m_paGraphItem[m_uCurrent]->QueryInterface(DIID_DICounterItem,
                                             (PVOID*)&V_DISPATCH(&varItem[cRet]));
            if (FAILED(hr)) {
                break;
            }

            V_VT(&varItem[cRet]) = VT_DISPATCH;

            m_uCurrent++;
        }

        //
        // If failed, clear out the variants
        //
        if (FAILED(hr)) {
            for (i = 0; i < cItems; i++) {
                if (V_VT(&varItem[i]) == VT_DISPATCH) {
                    V_DISPATCH(&varItem[i])->Release();
                }
                VariantClear(&varItem[i]);
            }
            cRet = 0;
        }

        // If desired, return number of items fetched
        if (pcReturned) {
            *pcReturned = cRet;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/***
*HRESULT CEnumPoint::Skip(unsigned long)
*Purpose:
*  Attempt to skip over the next 'celt' elements in the enumeration
*  sequence.
*
*Entry:
*  celt = the count of elements to skip
*
*Exit:
*  return value = HRESULT
*    S_OK
*    S_FALSE -  the end of the sequence was reached
*
***********************************************************************/
STDMETHODIMP
CImpIEnumCounter::Skip(
    IN  ULONG   cItems
    )
{
    m_uCurrent += cItems;

    if (m_uCurrent > m_cItems) {
        m_uCurrent = m_cItems;
        return S_FALSE;
    }

    return S_OK;
}


/***
*HRESULT CEnumPoint::Reset(void)
*Purpose:
*  Reset the enumeration sequence back to the beginning.
*
*Entry:
*  None
*
*Exit:
*  return value = SHRESULT CODE
*    S_OK
*
***********************************************************************/
STDMETHODIMP
CImpIEnumCounter::Reset(
    VOID
    )
{
    m_uCurrent = 0;

    return S_OK; 
}


/***
*HRESULT CEnumPoint::Clone(IEnumVARIANT**)
*Purpose:
*  Retrun a CPoint enumerator with exactly the same state as the
*  current one.
*
*Entry:
*  None
*
*Exit:
*  return value = HRESULT
*    S_OK
*    E_OUTOFMEMORY
*
***********************************************************************/
STDMETHODIMP
CImpIEnumCounter::Clone (
    OUT IEnumVARIANT **ppEnum
    )
{
    HRESULT hr = S_OK;
    ULONG   i;
    CImpIEnumCounter *pNewEnum = NULL;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        *ppEnum = NULL;

        //
        // Create new enumerator
        //
        pNewEnum = new CImpIEnumCounter;

        if ( NULL != pNewEnum ) {
            // Init, copy item list and current position
            pNewEnum->m_cItems = m_cItems;
            pNewEnum->m_uCurrent = m_uCurrent;
            pNewEnum->m_paGraphItem = (PCGraphItem*)malloc(sizeof(PCGraphItem) * m_cItems);

            if ( NULL != pNewEnum->m_paGraphItem ) {
                for (i = 0; i < m_cItems; i++) {
                    pNewEnum->m_paGraphItem[i] = m_paGraphItem[i];
                }

                *ppEnum = pNewEnum;
            }
            else {
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } catch (...) {
        hr = E_POINTER;
    }
    
    if (FAILED(hr) && pNewEnum != NULL) {
        if (pNewEnum->m_paGraphItem != NULL) {
            free(pNewEnum->m_paGraphItem);
        }

        delete pNewEnum;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\control.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    control.cpp

Abstract:

    Implementation of ISystemMonitor, IOleControl, ISpecifyPP, 
    IProvideClassInfo interfaces.

--*/
#include "polyline.h"
#include <strsafe.h>
#include <sqlext.h>
#include "unkhlpr.h"
#include "unihelpr.h"

#include "grphitem.h"
#include "ctrprop.h"
#include "grphprop.h"
#include "genprop.h"
#include "appearprop.h"
#include "logsrc.h"
#include "srcprop.h"



//----------------------------------------------------------------------------
// CImpISpecifyPP Interface Implementation
//----------------------------------------------------------------------------

// Standard IUnknown for contained interface
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpISpecifyPP)


STDMETHODIMP
CImpISpecifyPP::GetPages (
    OUT CAUUID *pPages
    )

/*++

Routine Description:

    GetPages returns an allocated array of property page GUIDs for Sysmon graph.
    There are three pages: general, graph, and counter.

Arguments:

    pPages - Pointer to GUID array header filled in by this routine

Return Value:

    HRESULT - NOERROR or OUT_OF_MEMORY

--*/

{
    HRESULT hr = S_OK;
    IMalloc *pIMalloc = NULL;
    GUID    *pGUID = NULL;

    if (pPages == NULL) {
        return E_POINTER;
    }

    try {
        pPages->cElems = 0;
        pPages->pElems = NULL;
    }  catch (...) {
        return E_POINTER;
    }

    //
    // Get Ole Malloc and allocate array
    //
    if ( FAILED(CoGetMalloc(MEMCTX_TASK, &pIMalloc)) ) {
        return E_OUTOFMEMORY;
    }

    pGUID = (GUID*)pIMalloc->Alloc((CPROPPAGES) * sizeof(GUID));

    if (NULL != pGUID) {

        // Fill the structure
        pGUID[GENERAL_PROPPAGE] = CLSID_GeneralPropPage;
        pGUID[SOURCE_PROPPAGE] = CLSID_SourcePropPage;
        pGUID[COUNTER_PROPPAGE] = CLSID_CounterPropPage;
        pGUID[GRAPH_PROPPAGE] = CLSID_GraphPropPage;
        pGUID[APPEAR_PROPPAGE] = CLSID_AppearPropPage;

        try {
            pPages->cElems = CPROPPAGES;
            pPages->pElems = pGUID;
        } catch (...) {
            hr = E_POINTER;
        }
    }
    else {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr) && pGUID) {
       pIMalloc->Free(pGUID);
    }

    pIMalloc->Release();

    return hr;
}


//----------------------------------------------------------------------------
// CImpIProvideClassInfo Interface Implementation
//----------------------------------------------------------------------------

// Standard IUnknown for contained interface
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIProvideClassInfo)


STDMETHODIMP
CImpIProvideClassInfo::GetClassInfo (
    OUT LPTYPEINFO *ppTI
    )

/*++

Routine Description:

    GetClassInfo returns an ITypeInfo interface to its type lib information.
    The interface is obtained by querying the contained ITypeLib interface.

Arguments:

    ppTI - Pointer to returned ITypeInfo interface

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (ppTI == NULL) {
        return E_POINTER;
    }

    try {
       *ppTI = NULL;
        hr = m_pObj->m_pITypeLib->GetTypeInfoOfGuid(CLSID_SystemMonitor, ppTI);
    }  catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


//----------------------------------------------------------------------------
//  CImpISystemMonitor Interface Implementation
//----------------------------------------------------------------------------

// Standard IUnknown for contained interface
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpISystemMonitor)

STDMETHODIMP
CImpISystemMonitor::put_Appearance (
    IN INT iAppearance
    )
{
    HRESULT hr = E_INVALIDARG;

    //
    // 0 = Flat, 1 = 3D
    //
    if ( ( 0 == iAppearance ) || ( 1 == iAppearance ) ) {
        m_pObj->m_pCtrl->put_Appearance( iAppearance, FALSE );
        hr =  NOERROR;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_Appearance (
    OUT INT *piAppearance
    )
{
    HRESULT hr = S_OK;

    if (piAppearance == NULL) {
        return E_POINTER;
    }

    try {
        *piAppearance = m_pObj->m_Graph.Options.iAppearance;
        if (*piAppearance == NULL_APPEARANCE) {
            *piAppearance = m_pObj->m_pCtrl->Appearance();
        }
    } catch (...) {
        hr = E_POINTER;
    }


    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_BackColor (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_BackPlotColor(Color, FALSE);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_BackColor (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = S_OK;

    if (pColor == NULL) {
        return E_POINTER;
    }

    try {
        *pColor = m_pObj->m_Graph.Options.clrBackPlot;
        if (*pColor == NULL_COLOR) {
            *pColor = m_pObj->m_pCtrl->clrBackPlot();
        }
    }  catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_BackColorCtl (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_BackCtlColor(Color);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_BackColorCtl (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = S_OK;

    if (pColor == NULL) {
        return E_POINTER;
    }

    try {
        // NT 5.0 Beta 1 files can be saved with NULL BackColorCtl.
        *pColor = m_pObj->m_Graph.Options.clrBackCtl;

        if (*pColor == NULL_COLOR) {
            *pColor = m_pObj->m_pCtrl->clrBackCtl();
        }
    } catch (...) {
        hr = E_POINTER;
    }
    

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_GridColor (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_GridColor(Color);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_GridColor (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = S_OK;

    if (pColor == NULL) {
        return E_POINTER;
    }

    try {
        *pColor = m_pObj->m_Graph.Options.clrGrid;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_TimeBarColor (
    IN OLE_COLOR Color )
{
    m_pObj->m_pCtrl->put_TimeBarColor(Color);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_TimeBarColor (
    OUT OLE_COLOR *pColor )
{
    HRESULT hr = S_OK;

    if (pColor == NULL) {
        return E_POINTER;
    }

    try {
        *pColor = m_pObj->m_Graph.Options.clrTimeBar;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_BorderStyle (
    IN INT iBorderStyle
    )
{    
    HRESULT hr;

    // 0 = none, 1 = single.
    if ( ( 0 == iBorderStyle ) || ( 1 == iBorderStyle ) ) {
        m_pObj->m_pCtrl->put_BorderStyle( iBorderStyle, FALSE );
        hr =  NOERROR;
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_BorderStyle (
    OUT INT *piBorderStyle
    )
{
    HRESULT hr = S_OK;

    if (piBorderStyle == NULL) {
        return E_POINTER;
    }

    try {
        *piBorderStyle = m_pObj->m_Graph.Options.iBorderStyle;
        if (*piBorderStyle == NULL_BORDERSTYLE) {
           *piBorderStyle = m_pObj->m_pCtrl->BorderStyle();
        }
    
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ForeColor (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_FgndColor(Color, FALSE);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ForeColor (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = S_OK;

    if (pColor == NULL) {
        return E_POINTER;
    }

    try {
        *pColor = m_pObj->m_Graph.Options.clrFore;
        if (*pColor == NULL_COLOR) {
            *pColor = m_pObj->m_pCtrl->clrFgnd();
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::putref_Font (
    IN IFontDisp *pFontDisp
    )
{
    LPFONT  pIFont = NULL;
    HRESULT hr = S_OK;

    if (pFontDisp == NULL) {
        return E_POINTER;
    }

    try {
        hr = pFontDisp->QueryInterface(IID_IFont, (PPVOID)&pIFont);
        if (SUCCEEDED(hr)) {
            hr = m_pObj->m_pCtrl->put_Font ( pIFont, FALSE );
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pIFont) {
        pIFont->Release();
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_Font (
    OUT IFontDisp **ppFont
)
{
    HRESULT hr = S_OK;

    if (ppFont == NULL) {
        return E_POINTER;
    }

    try {
        *ppFont = NULL;
        hr = m_pObj->m_pCtrl->m_OleFont.GetFontDisp(ppFont);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ShowVerticalGrid (
    IN VARIANT_BOOL bVisible
    )

/*++

Routine Description:

    Shows/hides the vertical grid.

Arguments:

    bVisible - Visibility  (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bVertGridChecked = bVisible;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_PLOT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowVerticalGrid (
    OUT VARIANT_BOOL *pbState
    )

/*++

Routine Description:

    Gets the vertical grid visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bVertGridChecked;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ShowHorizontalGrid(
    IN VARIANT_BOOL bVisible
    )

/*++

Routine Description:

    Shows/hides the horizontal grid.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bHorzGridChecked = bVisible;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_PLOT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowHorizontalGrid (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the horizontal grid visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bHorzGridChecked;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_Highlight(
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Sets the highlight state.  If true, the selected counter is 
    always highlighted in the graph.

Arguments:

    bState - Highlight (TRUE = highlight, FALSE = no highlight)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_pCtrl->put_Highlight(bState);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_Highlight (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the highlight state.

Arguments:

    pbState - pointer to returned state (TRUE = highlight, FALSE = no highlight)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bHighlight;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ShowLegend (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the graph legend.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bLegendChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowLegend (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the legend visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bLegendChecked;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ShowToolbar (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the graph toolbar

Arguments:

    bState = Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bToolbarChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ShowToolbar (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the legend visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bToolbarChecked;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ShowScaleLabels (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the vertical scale numbers.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bLabelsChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowScaleLabels (
    OUT VARIANT_BOOL *pbState
    )

/*++

Routine Description:

    Gets the visibility state of the vertical scale numbers.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bLabelsChecked;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ShowValueBar (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the graph statistics bar.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bValueBarChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowValueBar(
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the statistics bar visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bValueBarChecked;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_MaximumScale (
    IN INT iValue
    )

/*++

Routine Description:

    Sets the vertical scale maximum value.

Arguments:

    iValue - Maximum value

Return Value:

    HRESULT

--*/

{
    if ( ( iValue <= MAX_VERTICAL_SCALE ) && (iValue > m_pObj->m_Graph.Options.iVertMin ) ) {
        m_pObj->m_Graph.Options.iVertMax = iValue;
        m_pObj->m_Graph.Scale.SetMaxValue(iValue);
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_MaximumScale (
    OUT INT *piValue
    )

/*++

Routine Description:

    Gets the vertical scale's maximum value.

Arguments:

    piValue = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (piValue == NULL) {
        return E_POINTER;
    }

    try {
        *piValue =  m_pObj->m_Graph.Options.iVertMax;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_MinimumScale (
    IN INT iValue
    )

/*++

Routine Description:

    Sets the vertical scale minimum value.

Arguments:

    iValue - Minimum value

Return Value:

    None.

--*/

{
    if ( ( iValue >= MIN_VERTICAL_SCALE ) && (iValue < m_pObj->m_Graph.Options.iVertMax ) ) {
        m_pObj->m_Graph.Options.iVertMin = iValue;
        m_pObj->m_Graph.Scale.SetMinValue(iValue);
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_MinimumScale (
    OUT INT *piValue
    )
/*++

Routine Description:

    Gets the vertical scale's minimum value.

Arguments:

    piValue = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (piValue == NULL) {
        return E_POINTER;
    }

    try {
        *piValue =  m_pObj->m_Graph.Options.iVertMin;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_UpdateInterval (
    IN FLOAT fValue
    )

/*++

Routine Description:

    Sets the graph sample interval.

Arguments:

    fValue - Update interval in seconds (can be fraction)

Return Value:

    HRESULT

--*/

{
    if ( ( fValue >= MIN_UPDATE_INTERVAL ) && (fValue <= MAX_UPDATE_INTERVAL ) ) {
        m_pObj->m_Graph.Options.fUpdateInterval = fValue;
        m_pObj->m_pCtrl->SetIntervalTimer();
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}

STDMETHODIMP
CImpISystemMonitor::get_UpdateInterval (
    OUT FLOAT *pfValue
    )

/*++

Routine Description:

    Gets the graph's sample interval measured in seconds.

Arguments:

    pfValue = pointer to returned value

Return Value:

   HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (pfValue == NULL) {
        return E_POINTER;
    }

    try {
        *pfValue = m_pObj->m_Graph.Options.fUpdateInterval;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_DisplayFilter (
    IN INT iValue
    )

/*++

Routine Description:

    Sets the graph display filter - samples per display interval.

Arguments:

    iValue - Update interval in samples 

Return Value:

    HRESULT

--*/

{
    // TodoDisplayFilter:  Support for display filter > sample filter.

    if ( iValue != 1 )  {
        return E_INVALIDARG;
    }
    else {
        m_pObj->m_Graph.Options.iDisplayFilter = iValue;
//        m_pObj->m_pCtrl->SetIntervalTimer();
        return NOERROR;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_DisplayFilter (
    OUT INT *piValue
    )

/*++

Routine Description:

    Gets the graph's display interval measured in samples.

Arguments:

    piValue = pointer to returned value

Return Value:

   HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (piValue == NULL) {
        return E_POINTER;
    }

    try {
        *piValue = m_pObj->m_Graph.Options.iDisplayFilter;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_DisplayType (
    IN eDisplayTypeConstant eDisplayType
    )

/*++

Routine Description:

    Selects display type (1 = line plot, 2 = histogram, 3 = Report)

Arguments:

    eDisplayType - Display type

Return Value:

    HRESULT

--*/

{
    INT iUpdate;

    if (eDisplayType < LINE_GRAPH || eDisplayType > REPORT_GRAPH) {
        return E_INVALIDARG;
    }

    if (m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH || eDisplayType == REPORT_GRAPH) {
        iUpdate = UPDGRPH_VIEW;
    }
    else {
        iUpdate = UPDGRPH_PLOT;
    }

    m_pObj->m_Graph.Options.iDisplayType = eDisplayType;
    m_pObj->m_pCtrl->UpdateGraph(iUpdate);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_DisplayType (
    OUT eDisplayTypeConstant *peDisplayType
    )

/*++

Routine Description:

    Get graph display type (1 = line plot, 2 = histogram, 3 = Report)

Arguments:

    peDisplayType = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (peDisplayType == NULL) {
        return E_POINTER;
    }

    try {
        *peDisplayType = (eDisplayTypeConstant)m_pObj->m_Graph.Options.iDisplayType;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ManualUpdate (
    IN VARIANT_BOOL bMode
    )

/*++

Routine Description:

    Sets/clears manual update mode. Manual mode suspends periodic updates
    of the graph.

Arguments:

    bMode - Manual mode (TRUE = On, FALSE = Off)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_pCtrl->put_ManualUpdate ( bMode );
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ManualUpdate (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets manual update mode.

Arguments:

    pbState = pointer to returned state (TRUE = On, FALSE = Off)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bManualUpdate;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_GraphTitle (
    IN BSTR bstrTitle
    )

/*++

Routine Description:

    Sets the graph title.

Arguments:

    bstrTitle - Title string

Return Value:

    HRESULT

--*/

{
    LPWSTR  pszTitle = NULL;
    HRESULT hr = S_OK;
    BOOL    bClearTitle = FALSE;

    if (bstrTitle == NULL) {
        bClearTitle = TRUE;
    }
    else {
        try {
            if (bstrTitle[0] == L'\0') {
                bClearTitle = TRUE;
            }
            else {

                pszTitle = new WCHAR [MAX_TITLE_CHARS + 1];

                if (pszTitle) {
                    hr = StringCchCopy(pszTitle, MAX_TITLE_CHARS + 1, bstrTitle);
                    if (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {
                        hr = S_FALSE;
                    }
                    if (m_pObj->m_Graph.Options.pszGraphTitle) {
                        delete [] m_pObj->m_Graph.Options.pszGraphTitle;
                    }
                    m_pObj->m_Graph.Options.pszGraphTitle = pszTitle;
                }
                else {
                    hr = E_OUTOFMEMORY;
                }
            }
        } catch (...) {
            hr = E_INVALIDARG;
        }
    }
     
    if (SUCCEEDED(hr)) {
        if (bClearTitle && m_pObj->m_Graph.Options.pszGraphTitle) {
            delete [] m_pObj->m_Graph.Options.pszGraphTitle;
            m_pObj->m_Graph.Options.pszGraphTitle = NULL;
        }

        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    }
    else {
         if (pszTitle) {
             delete [] pszTitle;
         }
    }
   
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::get_GraphTitle (
    BSTR *pbsTitle
    )

/*++

Routine Description:

    Gets the graph title string. The caller is responsible for releasing the
    string memory.

Arguments:

    pbsTitle - pointer to returned title (BSTR)

Return Value:

    HResult

--*/

{
    HRESULT hr = S_OK;
    BSTR  pTmpTitle = NULL;

    if (pbsTitle == NULL) {
        return E_POINTER;
    }

    if (m_pObj->m_Graph.Options.pszGraphTitle != NULL) {
        pTmpTitle = SysAllocString(m_pObj->m_Graph.Options.pszGraphTitle);
        if (pTmpTitle == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    try {
        *pbsTitle = pTmpTitle;

    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pTmpTitle) {
        SysFreeString(pTmpTitle);
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_LogFileName (
    IN BSTR bstrLogFile
    )

/*++

Routine Description:

    Sets the log file name

Arguments:

    bstrLogFile - File name string

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;
    LPWSTR  pszLogFile = NULL;
    LONG    lCount;

    //
    // Ensure that the current log file count is 0 or 1
    //
    lCount = m_pObj->m_pCtrl->NumLogFiles();
    if (lCount != 0 && lCount != 1) {
        return E_FAIL;
    }

    //
    // Get the current data source type
    //

    // Reset the data source type to null data source while completing this operation.
    // TodoLogFiles:  Possible to keep the previous put_LogFileName semantics,
    // where new query is opened (successfully) before closing the previous query?
    hr = m_pObj->m_pCtrl->put_DataSourceType ( sysmonNullDataSource );

    if ( SUCCEEDED ( hr ) ) {
        // TodoLogFiles:  What if multiple files exist?  Probably return error re:  not supported.
        if ( 1 == lCount ) {
            hr = m_pObj->m_pCtrl->RemoveSingleLogFile ( m_pObj->m_pCtrl->FirstLogFile() );
        }

        if ( SUCCEEDED ( hr ) ) {
            try {
                if (bstrLogFile != NULL && bstrLogFile[0] != 0) {
                    //
                    // If non-null name
                    // Convert from BSTR to internal string, then add the item.
                    //
                    pszLogFile = bstrLogFile;
                    hr = m_pObj->m_pCtrl->AddSingleLogFile ( pszLogFile );

                    if ( SUCCEEDED ( hr ) ) {
                        //
                        // put_DataSourceType attempts to set the data source type to sysmonCurrentActivity
                        // if sysmonLogFiles fails.
                        //
                        hr = m_pObj->m_pCtrl->put_DataSourceType ( sysmonLogFiles );
                    }
                }
            } catch (...) {
                hr = E_INVALIDARG;
            }
        }
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::get_LogFileName (
    BSTR *pbsLogFile
    )

/*++

Routine Description:

    Gets the log file name. The caller is responsible for releasing the
    string memory.
    This is an obsolete method supported only for backward compatibility.
    It cannot be used when multiple log files are loaded.

Arguments:

    pbsLogFile - pointer to returned name (BSTR)

Return Value:

    HResult
 
    N.B. The code is duplicated with BuildFileList

--*/

{
    HRESULT        hr          = NOERROR;
    LPCWSTR        pszFileName = NULL;
    LPWSTR         pszLogFile  = NULL;
    ULONG          ulCchLogFileName = 0;
    CLogFileItem * pLogFile;
    LPWSTR         pszLogFileCurrent;

    if (pbsLogFile == NULL) {
        return E_POINTER;
    }

    try {
        *pbsLogFile = NULL;
    } catch (...) {
        return E_POINTER;
    }

    //
    // First calculate how big the buffer should be
    //
    pLogFile = m_pObj->m_pCtrl->FirstLogFile();
    while (pLogFile) {
        pszFileName  = pLogFile->GetPath();
        ulCchLogFileName += (lstrlen(pszFileName) + 1);
        pLogFile     = pLogFile->Next();
    }
    ulCchLogFileName ++; // for the final NULL character

    //
    // Allocate the buffer
    //
    pszLogFile = new WCHAR [ ulCchLogFileName ];

    if (pszLogFile) {
        pLogFile          = m_pObj->m_pCtrl->FirstLogFile();
        pszLogFileCurrent = pszLogFile;

        while (pLogFile) {
            pszFileName  = pLogFile->GetPath();
            //
            // We are sure we have enough space to hold the path
            //
            StringCchCopy(pszLogFileCurrent, lstrlen(pszFileName) + 1, pszFileName);
            pszLogFileCurrent  += lstrlen(pszFileName);
            * pszLogFileCurrent = L'\0';
            pszLogFileCurrent ++;

            pLogFile = pLogFile->Next();
        }

        * pszLogFileCurrent = L'\0';

        try {
            * pbsLogFile = SysAllocStringLen(pszLogFile, ulCchLogFileName);
 
            if (NULL == * pbsLogFile) {
                hr = E_OUTOFMEMORY;
            }
        } catch (...) {
            hr = E_POINTER;
        }

        delete [] pszLogFile;
    }
    else {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_DataSourceType (
    IN eDataSourceTypeConstant eDataSourceType
    )

/*++

Routine Description:

    Selects data source type (1 = current activity, 2 = log files)

Arguments:

    eDataSourceType - Data source type

Return Value:

    HRESULT

--*/

{
    if ( eDataSourceType != sysmonCurrentActivity  
        && eDataSourceType != sysmonLogFiles
        && sysmonNullDataSource != eDataSourceType
        && eDataSourceType !=  sysmonSqlLog) {
        return E_INVALIDARG;
    }

    return m_pObj->m_pCtrl->put_DataSourceType( eDataSourceType );
}

STDMETHODIMP
CImpISystemMonitor::get_DataSourceType (
    OUT eDataSourceTypeConstant *peDataSourceType
    )

/*++

Routine Description:

    Get data source type (1 = current activity, 2 = log files)

Arguments:

    peDataSourceType = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (peDataSourceType == NULL) {
        return E_POINTER;
    }

    try {
        *peDataSourceType = sysmonCurrentActivity;
   
        hr = m_pObj->m_pCtrl->get_DataSourceType ( *peDataSourceType );
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::get_LogFiles (
    ILogFiles **ppILogFiles
    )
{
    HRESULT hr = S_OK;

    if (ppILogFiles == NULL) {
        return E_POINTER;
    }

    try {
        *ppILogFiles = m_pObj->m_pImpILogFiles;
        if ( NULL != *ppILogFiles ) {
            (*ppILogFiles)->AddRef();
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_LogViewStart (
    IN DATE dateStart
    )
{
    LONGLONG llTestStart;

    if ( VariantDateToLLTime(dateStart, &llTestStart ) ) {

        // No error.  If start time is past current stop time, reset it to the current stop time.
        if ( llTestStart <= m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp ){
            if ( llTestStart >= m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime ) {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp = llTestStart;
            } else {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime;
            }
        } else {
            m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp;
        }

        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LOGVIEW);
        return NOERROR;
    
    } else {
        return E_FAIL;
    }
}

STDMETHODIMP
CImpISystemMonitor::get_LogViewStart (
    OUT DATE *pdateStart
    )
{
    HRESULT hr = S_OK;

    if (pdateStart == NULL) {
        return E_POINTER;
    }

    try {
        if ( ! LLTimeToVariantDate(m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp, pdateStart)) {
            hr = E_FAIL;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_LogViewStop (
    IN DATE dateStop
    )
{
    LONGLONG llTestStop;

    if ( VariantDateToLLTime(dateStop, &llTestStop ) ) {
        // No error.  If requested stop time is earlier than current start time, set it to 
        // the current start time.
        if ( llTestStop >= m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp ) {
            if ( llTestStop <= m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime ) {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp = llTestStop;
            } else {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime;
            }
        } else {
            m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp;
        }
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LOGVIEW);
        return NOERROR;
    } else {
        return E_FAIL;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_LogViewStop (
    OUT DATE *pdateStop )
{
    HRESULT hr = S_OK;

    if (pdateStop == NULL) {
        return E_POINTER;
    }

    try {
        if (!LLTimeToVariantDate(m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp, pdateStop)) {
            hr = E_FAIL;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_YAxisLabel (
    IN BSTR bstrLabel
    )

/*++

Routine Description:

    Sets the Y axis label string.

Arguments:

    bstrLabel - Label string

Return Value:

    HRESULT

--*/

{
    LPWSTR  pszTitle = NULL;
    HRESULT hr = S_OK;
    BOOL    bClearTitle = FALSE;

    if (bstrLabel == NULL) {
        bClearTitle = TRUE;
    }
    else {
        try {
            if (bstrLabel[0] == 0) {
                bClearTitle = TRUE;
            }
            else {
                pszTitle = new WCHAR [MAX_TITLE_CHARS + 1];
        
                if (pszTitle) {
                    hr = StringCchCopy(pszTitle, MAX_TITLE_CHARS + 1, bstrLabel);
                    if (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {
                        hr = S_FALSE;
                    }

                    if (m_pObj->m_Graph.Options.pszYaxisTitle) {
                        delete [] m_pObj->m_Graph.Options.pszYaxisTitle;
                    }
                    m_pObj->m_Graph.Options.pszYaxisTitle = pszTitle;
                }
                else {
                    hr = E_OUTOFMEMORY;
                }
            }
        } catch (...) {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr)) {
        if (bClearTitle && m_pObj->m_Graph.Options.pszYaxisTitle) {
            delete [] m_pObj->m_Graph.Options.pszYaxisTitle;
            m_pObj->m_Graph.Options.pszYaxisTitle = NULL;
        }

        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    }
    else {
         if (pszTitle) {
             delete [] pszTitle;
         }
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::get_YAxisLabel (
    BSTR *pbsTitle
    )
/*++

Routine Description:

    Gets the Y axis title string. The caller is responsible for releasing the
    string memory.

Arguments:

    pbsTitle -  pointer to returned title (BSTR)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;
    BSTR pTmpTitle = NULL;

    if (pbsTitle == NULL) {
        return E_POINTER;
    }

    if (m_pObj->m_Graph.Options.pszYaxisTitle != NULL) {

        pTmpTitle = SysAllocString(m_pObj->m_Graph.Options.pszYaxisTitle);
        if (pTmpTitle == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    try {
        *pbsTitle = pTmpTitle;

    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pTmpTitle) {
        SysFreeString(pTmpTitle);
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_Counters (
    ICounters **ppICounters
    )
{
    HRESULT hr = S_OK;

    if (ppICounters == NULL) {
        return E_POINTER;
    }
    try  {
        *ppICounters = m_pObj->m_pImpICounters;
        (*ppICounters)->AddRef();
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ReadOnly (
    IN VARIANT_BOOL bState 
    )
{
    BOOL bStateLocal = FALSE;

    if ( bState )  {
        bStateLocal = TRUE;
    }

    m_pObj->m_Graph.Options.bReadOnly = bStateLocal;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_VIEW);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ReadOnly (
    OUT VARIANT_BOOL *pbState 
    )
{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bReadOnly;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ReportValueType (
    IN eReportValueTypeConstant eReportValueType
    )

/*++

Routine Description:

    Selects report value type 
        0 = default value (current for live data, average for log file) 
        1 = current value  
        2 = average over the graph display interval 
        3 = minimum for the graph display interval
        4 = maximum for the graph display interval

Arguments:

    eReportValueType - Report valuex

Return Value:

    HRESULT

--*/

{
    if (eReportValueType < sysmonDefaultValue || eReportValueType > sysmonMaximum ) {
        return E_INVALIDARG;
    }

    m_pObj->m_Graph.Options.iReportValueType = eReportValueType;

    //
    // Update the graph for both report and histogram views.
    //
    if (m_pObj->m_Graph.Options.iDisplayType != LINE_GRAPH ) {
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_VIEW);
    }

    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ReportValueType (
    OUT eReportValueTypeConstant *peReportValueType
    )

/*++

Routine Description:

    Get report value type 
        0 = default value (current for live data, average for log file) 
        1 = current value  
        2 = average over the graph display interval 
        3 = minimum for the graph display interval
        4 = maximum for the graph display interval

Arguments:

    peReportValueType = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (peReportValueType == NULL) {
        return E_POINTER;
    }

    try {
        *peReportValueType = (eReportValueTypeConstant)m_pObj->m_Graph.Options.iReportValueType;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_MonitorDuplicateInstances(
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Allows/disallows monitoring of duplicate counter instances.

Arguments:

    bState -  TRUE = allow, FALSE = disallow)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bMonitorDuplicateInstances = bState;
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_MonitorDuplicateInstances (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the state of allowing monitoring of duplicate counter instances.

Arguments:

    pbState - pointer to returned state ( TRUE = allow, FALSE = disallow )

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pbState == NULL) {
        return E_POINTER;
    }

    try {
        *pbState = (short)m_pObj->m_Graph.Options.bMonitorDuplicateInstances;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_SqlDsnName (
    IN BSTR bstrSqlDsnName
    )

/*++

Routine Description:

    Sets the SQL logset DSN name.

Return Value:

    HRESULT

--*/

{
    HRESULT hr           = NOERROR;
    LPWSTR  szSqlDsnName = NULL;
    BOOL    bClearName   = FALSE; 

    if (bstrSqlDsnName == NULL) {
        bClearName = TRUE;
    }
    else {
        try {
            if (bstrSqlDsnName[0] == 0) {
                bClearName = TRUE;
            }
            else {
                szSqlDsnName = new WCHAR [SQL_MAX_DSN_LENGTH + 1];

                if (szSqlDsnName) {
                    hr = StringCchCopy(szSqlDsnName, SQL_MAX_DSN_LENGTH + 1, bstrSqlDsnName);
                    if (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {
                        hr = S_FALSE;
                    }
                    if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName) {
                        delete [] m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName;
                    }
                    m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName = szSqlDsnName;
                }
                else {
                    hr = E_OUTOFMEMORY;
                }
            }
        } catch (...) {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr)) {
        if (bClearName && m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName) {
            delete [] m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName;
            m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName = NULL;
        }
    }
    else {
        if (szSqlDsnName) {
            delete [] szSqlDsnName;
        }
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_SqlDsnName (
    BSTR * bstrSqlDsnName
    )
/*++

Routine Description:

    Gets SQL DSN name string. The caller is responsible for releasing the
    string memory.

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;
    BSTR pTmpName = NULL;

    if (bstrSqlDsnName == NULL) {
        return E_POINTER;
    }

    if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName != NULL) {
        pTmpName = SysAllocString(m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName);
        if (pTmpName == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    try {
        * bstrSqlDsnName = pTmpName;

    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pTmpName) {
        SysFreeString(pTmpName);
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_SqlLogSetName (
    IN BSTR bstrSqlLogSetName
    )

/*++

Routine Description:

    Sets the SQL logset DSN name.

Return Value:

    HRESULT

--*/

{
    HRESULT hr              = NOERROR;
    LPWSTR  szSqlLogSetName = NULL;
    BOOL    bClearName      = FALSE;


    if (bstrSqlLogSetName == NULL) {
        bClearName = TRUE;
    }
    else {
        try {
            if (bstrSqlLogSetName[0] == 0) {
                bClearName = TRUE;
            }
            else {
                szSqlLogSetName = new WCHAR [SLQ_MAX_LOG_SET_NAME_LEN + 1];

                if (szSqlLogSetName) {
                    hr = StringCchCopy(szSqlLogSetName, SLQ_MAX_LOG_SET_NAME_LEN + 1, bstrSqlLogSetName);
                    if (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {
                        hr = S_FALSE;
                    }
                    if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName) {
                        delete [] m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName;
                    }
                    m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName = szSqlLogSetName;
                }
                else {
                    hr = E_OUTOFMEMORY;
                }
            }
        } catch (...) {
            hr = E_INVALIDARG;
        }
    }
 
    if (SUCCEEDED(hr)) {
        if (bClearName && m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName) {
            delete [] m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName;
            m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName = NULL;
        }
    }
    else {
        if (szSqlLogSetName) {
            delete [] szSqlLogSetName;
        }
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_SqlLogSetName (
    BSTR * bsSqlLogSetName
    )
/*++

Routine Description:

    Gets SQL DSN name string. The caller is responsible for releasing the
    string memory.

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;
    BSTR pTmpName = NULL;

    if (bsSqlLogSetName == NULL) {
        return E_POINTER;
    }

    if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName != NULL) {
        pTmpName = SysAllocString(m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName);
        if (pTmpName == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    try {
        * bsSqlLogSetName = pTmpName;
    } catch (...) {
        hr = E_INVALIDARG;
    }

    if (FAILED(hr) && pTmpName) {
        SysFreeString(pTmpName);
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::Counter (
    IN INT iIndex,
    OUT ICounterItem **ppItem
    )

/*++

Routine Description:

    Gets the ICounterItem interface for an indexed counter.
    Index is one-based.

Arguments:

    iIndex - Index of counter (0-based)
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;
    CGraphItem *pGItem = NULL;
    INT i;

    //
    // Check for valid index
    //
    if (iIndex < 0 || iIndex >= m_pObj->m_Graph.CounterTree.NumCounters()) {
        return E_INVALIDARG;
    }
    if (ppItem == NULL) {
        return E_POINTER;
    }

    try {
        *ppItem = NULL;

        //
        // Traverse counter linked list to indexed item
        //
        pGItem = m_pObj->m_Graph.CounterTree.FirstCounter();
        i = 0;

        while (i++ < iIndex && pGItem != NULL) {
            pGItem = pGItem->Next();
        }

        if (pGItem == NULL) {
            hr = E_FAIL;
        }

        *ppItem = pGItem;
        pGItem->AddRef();
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::AddCounter (
    IN BSTR bstrPath,
    ICounterItem **ppItem
    )

/*++

Routine Description:

    Add counter specified by pathname to the control.
    This method supports wildcard paths.

Arguments:

    bstrPath - Pathname string
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (ppItem == NULL) {
        return E_POINTER;
    }

    try {
        *ppItem = NULL;
        //
        // Delegate to control object
        //
        hr = m_pObj->m_pCtrl->AddCounter(bstrPath, (CGraphItem**)ppItem);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::DeleteCounter (
    IN ICounterItem *pItem
    )
/*++

Routine Description:

    Deletes a counter from the control.

Arguments:

    pItem - Pointer to counter's ICounterItem interface

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (pItem == NULL) {
        return E_POINTER;
    }

    try {

        //
        // Delegate to control object
        //
        hr = m_pObj->m_pCtrl->DeleteCounter((PCGraphItem)pItem, TRUE);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::UpdateGraph (
    VOID
    )

/*++

Routine Description:

    Apply pending visual changes to control. This routine must be called after
    changing a counter's attributes.

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    // Delegate to control object
    m_pObj->m_pCtrl->UpdateGraph(0);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::CollectSample(
    VOID
    )
/*++

Routine Description:

    Take a sample of all the counters assigned to the control.

Arguments:

    None.

Return Value:

    HRESULT.

--*/
{
    // Request control to do a manual counter update
    if (m_pObj->m_pCtrl->UpdateCounterValues(TRUE) == 0) {
        return NOERROR;
    }
    else {
        return E_FAIL;
    }
}

STDMETHODIMP
CImpISystemMonitor::BrowseCounters(
    VOID
    )
/*++

Routine Description:

    Display the browse counter dialog to allow counters
    to be added.

Arguments:

    None.

Return Value:

    HRESULT.

--*/
{
    // Delegate to control
    return m_pObj->m_pCtrl->AddCounters();
}


STDMETHODIMP
CImpISystemMonitor::DisplayProperties(
    VOID
    )
/*++

Routine Description:

    Display the graph control property pages

Arguments:

    None.

Return Value:

    HRESULT.

--*/
{
    // Delegate to control
    return m_pObj->m_pCtrl->DisplayProperties();
}

STDMETHODIMP
CImpISystemMonitor::Paste ()
/*++

Routine Description:

    Pastes a list of counter paths from the clipboard to the control

Arguments:

    NULL

Return Value:

    HRESULT

--*/

{
    // Delegate to control object
    return m_pObj->m_pCtrl->Paste();
}

STDMETHODIMP
CImpISystemMonitor::Copy ()
/*++

Routine Description:

    Copies a list of counter paths from the control to the clipboard

Arguments:

    NULL

Return Value:

    HRESULT

--*/

{
    // Delegate to control object
    return m_pObj->m_pCtrl->Copy();
}

STDMETHODIMP
CImpISystemMonitor::Reset ()
/*++

Routine Description:

    deletes the current set of counters

Arguments:

    NULL

Return Value:

    HRESULT

--*/
{
    // Delegate to control object
    return m_pObj->m_pCtrl->Reset();
}

HRESULT
CImpISystemMonitor::SetLogFileRange (
    LONGLONG llBegin,
    LONGLONG llEnd
    )

/*++

Routine Description:

    Set the log file time range. This routine provides the Source
    property page a way to give range to the control, so that the control
    doesn't have to repeat the length PDH call to get it.


Arguments:

    llBegin     Begin time of the log (FILETIME format)
    llEnd       End time of log (FILETIME format)

Return Value:

    HRESULT.

--*/

{
    m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime = llBegin;
    m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime = llEnd;

    return S_OK;
}


HRESULT
CImpISystemMonitor::GetLogFileRange (
    OUT LONGLONG *pllBegin,
    OUT LONGLONG *pllEnd
    )

/*++

Routine Description:

    Get the log file time range. This routine provides the Source
    property page a way to get the range from the control, so it doesn't
    have to make the length PDH call to get it.


Arguments:

    pllBegin    ptr to returned begin time of the log (FILETIME format)
    pllEnd      ptr to returned end time of log (FILETIME format)

Return Value:

    HRESULT.

--*/

{
    HRESULT hr = S_OK;

    if (pllBegin == NULL || pllEnd == NULL) {
        return E_POINTER;
    }

    try {
        *pllBegin = m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime;
        *pllEnd = m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 *   The following methods, GetVisuals and SetVisuals, provide a means for the
 *  counter property page to save the user's color settings between invocations.
 */

HRESULT
CImpISystemMonitor::GetVisuals (
    OUT OLE_COLOR   *pColor,
    OUT INT         *piColorIndex,
    OUT INT         *piWidthIndex,
    OUT INT         *piStyleIndex
    )
{
    HRESULT hr = S_OK;

    if (pColor == NULL || piColorIndex == NULL || piWidthIndex == NULL || piStyleIndex == NULL) {
        return E_POINTER;
    }

    try {
        *pColor = m_pObj->m_pCtrl->m_clrCounter;
        *piColorIndex = m_pObj->m_pCtrl->m_iColorIndex;
        *piWidthIndex = m_pObj->m_pCtrl->m_iWidthIndex;
        *piStyleIndex = m_pObj->m_pCtrl->m_iStyleIndex;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT
CImpISystemMonitor::SetVisuals (
    IN OLE_COLOR    Color,
    IN INT          iColorIndex,
    IN INT          iWidthIndex,
    IN INT          iStyleIndex
    )
{
    OleTranslateColor( Color, NULL, &m_pObj->m_pCtrl->m_clrCounter );

    if (iColorIndex < 0 || iColorIndex > NumColorIndices() ||
        iWidthIndex < 0 || iWidthIndex > NumWidthIndices() ||
        iStyleIndex < 0 || iStyleIndex > NumStyleIndices()) {
        return E_INVALIDARG;
    }

    m_pObj->m_pCtrl->m_iColorIndex = iColorIndex;
    m_pObj->m_pCtrl->m_iWidthIndex = iWidthIndex;
    m_pObj->m_pCtrl->m_iStyleIndex = iStyleIndex;

    return S_OK;
}

HRESULT
CImpISystemMonitor::SetLogViewTempRange (
    LONGLONG llStart,
    LONGLONG llStop
    )

/*++

Routine Description:

    Set the log view temporary time range. This routine provides the Source
    property page a way to give range to the control, so that the control
    can draw temporary timeline guides on the line graph.


Arguments:

  llStart     Temporary log view start time (FILETIME format)
  llEnd       Temporary log view end time (FILETIME format)

Return Value:

    HRESULT.

--*/

{
    HRESULT hr;

    DATE        dateStart;
    DATE        dateStop;
    
    LONGLONG    llConvertedStart = MIN_TIME_VALUE;
    LONGLONG    llConvertedStop = MAX_TIME_VALUE;
    BOOL        bContinue = TRUE;

    // Convert times to and from Variant date to strip off milliseconds.
    // This will make them match the start and stop times processed by put_LogView*
    // Special case MAX_TIME_VALUE, because that is the signal to not draw the stop 
    // guide line.
    // Convert start time

    if ( LLTimeToVariantDate ( llStart, &dateStart ) ) {
        bContinue = VariantDateToLLTime (dateStart, &llConvertedStart );
    }
        
    // Convert stop time if not MAX_TIME_VALUE
    if ( bContinue ) {    
        if ( MAX_TIME_VALUE != llStop ) {
            if ( LLTimeToVariantDate ( llStop, &dateStop ) ) {
                bContinue = VariantDateToLLTime ( dateStop, &llConvertedStop );
            }
        } else {
            llConvertedStop = MAX_TIME_VALUE;
        }
    }

                    
    if ( bContinue ) {
        m_pObj->m_pCtrl->SetLogViewTempTimeRange ( llConvertedStart, llConvertedStop );
        hr = NOERROR;
    } else {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::LogFile (
    IN INT iIndex,
    OUT ILogFileItem **ppItem
    )

/*++

Routine Description:

    Gets the ILogFileItem interface for an indexed log file.
    Index is 0-based.

Arguments:

    iIndex - Index of counter (0-based)
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;
    CLogFileItem *pItem = NULL;
    INT i;
    
    //
    // Check for valid index
    //
    if (iIndex < 0 || iIndex >= m_pObj->m_pCtrl->NumLogFiles()) {
        return E_INVALIDARG;
    }
    if (ppItem == NULL) {
        return E_POINTER;
    }

    try {

        *ppItem = NULL;

        // Traverse counter linked list to indexed item
        pItem = m_pObj->m_pCtrl->FirstLogFile();
        
        i = 0;

        while (i++ < iIndex && pItem != NULL) {
            pItem = pItem->Next();
        }

        if (pItem != NULL) {
            *ppItem = pItem;
            pItem->AddRef();
        } else {
             hr = E_FAIL;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::AddLogFile (
    IN BSTR bstrPath,
    ILogFileItem **ppItem
    )

/*++

Routine Description:

    Add log file specified by pathname to the control.
    This method does not support wildcard paths.

Arguments:

    bstrPath - Pathname string
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (ppItem == NULL) {
        return E_POINTER;
    }

    try {
        *ppItem = NULL;

        hr = m_pObj->m_pCtrl->AddSingleLogFile(bstrPath, (CLogFileItem**)ppItem);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::DeleteLogFile (
    IN ILogFileItem *pItem
    )
/*++

Routine Description:

    Deletes a log file from the control.

Arguments:

    pItem - Pointer to log file's ILogFileItem interface

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;

    if (pItem == NULL) {
        return E_POINTER;
    }

    try {
        // Delegate to control object
        hr = m_pObj->m_pCtrl->RemoveSingleLogFile( (PCLogFileItem)pItem );
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

//IOleControl interface implementation

/*
 * CImpIOleControl::CImpIOleControl
 * CImpIOleControl::~CImpIOleControl
 *
 * Parameters (Constructor):
 *  pObj            PCPolyline of the object we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIOleControl::CImpIOleControl (
    IN PCPolyline pObj,
    IN LPUNKNOWN pUnkOuter
    )
{
    m_cRef = 0;
    m_pObj = pObj;
    m_pUnkOuter = pUnkOuter;

}

CImpIOleControl::~CImpIOleControl (
    VOID
    )
{
    return;
}


/*
 * CImpIOleControl::QueryInterface
 * CImpIOleControl::AddRef
 * CImpIOleControl::Release
 */

STDMETHODIMP
CImpIOleControl::QueryInterface(
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
   HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;
        hr = m_pUnkOuter->QueryInterface(riid, ppv);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_( ULONG )
CImpIOleControl::AddRef(
    VOID
    )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleControl::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



/*
 * CImpIOleControl::GetControlInfo
 *
 * Purpose:
 *  Fills a CONTROLINFO structure containing information about
 *  the controls mnemonics and other behavioral aspects.
 *
 * Parameters:
 *  pCI             LPCONTROLINFO to the structure to fill
 */

STDMETHODIMP 
CImpIOleControl::GetControlInfo ( LPCONTROLINFO pCI )
{ 
    HRESULT hr = S_OK;

    if (pCI == NULL) {
        return E_POINTER;
    }

    try {
        *pCI=m_pObj->m_ctrlInfo;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}




/*
 * CImpIOleControl::OnMnemonic
 *
 * Purpose:
 *  Notifies the control that a mnemonic was activated.
 *
 * Parameters:
 *  pMsg            LPMSG containing the message that matches one of
 *                  the control's mnemonics.  The control uses this
 *                  to distinguish which mnemonic was pressed.
 */

STDMETHODIMP CImpIOleControl::OnMnemonic ( LPMSG /* pMsg */ )
{
    //No mnemonics
    return NOERROR;
}





/*
 * CImpIOleControl::OnAmbientPropertyChange
 *
 * Purpose:
 *  Notifies the control that one or more of the container's ambient
 *  properties changed.
 *
 * Parameters:
 *  dispID          DISPID identifying the property, which can
 *                  be DISPID_UNKNOWN indicating that more than
 *                  one changed.
 */

STDMETHODIMP 
CImpIOleControl::OnAmbientPropertyChange(DISPID dispID)
{
    DWORD dwInitWhich;

    switch (dispID) {

        case DISPID_UNKNOWN:
        {
            dwInitWhich = INITAMBIENT_SHOWHATCHING | INITAMBIENT_UIDEAD
                        | INITAMBIENT_BACKCOLOR | INITAMBIENT_FORECOLOR
                        | INITAMBIENT_APPEARANCE | INITAMBIENT_USERMODE
                        | INITAMBIENT_FONT | INITAMBIENT_RTL;

            // Update system colors here until MMC passes on WM_SYSCOLORCHANGE
            m_pObj->m_pCtrl->UpdateNonAmbientSysColors();

            break;
        }

        case DISPID_AMBIENT_SHOWHATCHING:
            dwInitWhich = INITAMBIENT_SHOWHATCHING;
            break;

        case DISPID_AMBIENT_UIDEAD:
            dwInitWhich = INITAMBIENT_UIDEAD;
            break;

        case DISPID_AMBIENT_APPEARANCE:
            dwInitWhich = INITAMBIENT_APPEARANCE;
            break;

        case DISPID_AMBIENT_BACKCOLOR:
            dwInitWhich = INITAMBIENT_BACKCOLOR;
            break;

        case DISPID_AMBIENT_FORECOLOR:
            dwInitWhich = INITAMBIENT_FORECOLOR;
            break;

        case DISPID_AMBIENT_FONT:
            dwInitWhich = INITAMBIENT_FONT;
            break;

        case DISPID_AMBIENT_USERMODE:
            dwInitWhich = INITAMBIENT_USERMODE;
            break;

        case DISPID_AMBIENT_RIGHTTOLEFT:
            dwInitWhich = INITAMBIENT_RTL;
            break;

        default:
            return NOERROR;
    }

    m_pObj->AmbientsInitialize(dwInitWhich);

    return NOERROR;
}




/*
 * CImpIOleControl::FreezeEvents
 *
 * Purpose:
 *  Instructs the control to stop firing events or to continue
 *  firing them.
 *
 * Parameters:
 *  fFreeze         BOOL indicating to freeze (TRUE) or thaw (FALSE)
 *                  events from this control.
 */

STDMETHODIMP 
CImpIOleControl::FreezeEvents(BOOL fFreeze)
{
    m_pObj->m_fFreezeEvents = fFreeze;
    return NOERROR;
}

// Private methods

STDMETHODIMP
CImpISystemMonitor::GetSelectedCounter (
    ICounterItem** ppItem
    )

/*++

Routine Description:

    Gets the ICounterItem interface for the selected counter.

Arguments:

    ppItem - pointer to returned interface pointer

Return Value:

    HResult

--*/

{
    HRESULT hr = S_OK;

    if (ppItem == NULL) {
        return E_POINTER;
    }

    try {
        *ppItem = m_pObj->m_pCtrl->m_pSelectedItem;
        if ( NULL != *ppItem ) {
            m_pObj->m_pCtrl->m_pSelectedItem->AddRef();
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

HLOG
CImpISystemMonitor::GetDataSourceHandle ( void )
{
    return m_pObj->m_pCtrl->GetDataSourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\counters.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    counters.h

Abstract:

    Header file for the implementation of the ICounters object.

--*/

#ifndef _COUNTERS_H_
#define _COUNTERS_H_

class CPolyline;

class CImpICounters : public ICounters
{
  protected:
	ULONG		m_cRef;
	CPolyline	*m_pObj;
    LPUNKNOWN   m_pUnkOuter;
			
  public:

	CImpICounters(CPolyline*, LPUNKNOWN);
	~CImpICounters();

    /* IUnknown methods */
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)	(UINT *pctinfo);

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);

    STDMETHOD(GetIDsOfNames) (REFIID riid, OLECHAR **rgszNames,
     						  UINT cNames, LCID lcid, DISPID *rgdispid);

    STDMETHOD(Invoke) (DISPID dispidMember, REFIID riid, LCID lcid,WORD wFlags,
      				   DISPPARAMS *pdispparams, VARIANT *pvarResult,
      				   EXCEPINFO *pexcepinfo, UINT *puArgErr);

    /* Counters methods */
    STDMETHOD(get_Count) (long *pLong);
    STDMETHOD(get__NewEnum)	(IUnknown **ppIunk);
    STDMETHOD(get_Item) (VARIANT index, DICounterItem **ppI);
    STDMETHOD(Add) (BSTR bstrPath, DICounterItem **ppI);
    STDMETHOD(Remove) (VARIANT index);
};

typedef CImpICounters *PCImpICounters;


// Counter enumerator
class CImpIEnumCounter : public IEnumVARIANT
{
protected:
	DWORD		m_cRef;
	PCGraphItem *m_paGraphItem;
	ULONG		m_cItems;
	ULONG		m_uCurrent;
		
public:
	CImpIEnumCounter (VOID);
	HRESULT Init (PCGraphItem pGraphItem, INT cItems);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

	// Enum methods
	STDMETHOD(Next) (ULONG cItems, VARIANT *varItems, ULONG *pcReturned);
	STDMETHOD(Skip) (ULONG cSkip);
	STDMETHOD(Reset) (VOID);
	STDMETHOD(Clone) (IEnumVARIANT **pIEnum);
};

#endif //_COUNTERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ctrlwin.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ctrlwin.cpp

Abstract:

    Window procedure for the sysmon.ocx drawing window and support
    functions.
--*/

#include "polyline.h"

/*
 * CPolyline::Draw
 *
 * Purpose:
 *  Paints the current line in the polyline window.
 *
 * Parameters:
 *  hDC             HDC to draw on, a metafile or printer DC.
 *  fMetafile       BOOL indicating if hDC is a metafile or not,
 *                  so we can avoid operations that RIP.
 *  fEntire         BOOL indicating if we should draw the entire
 *                  figure or not.
 *  pRect           LPRECT defining the bounds in which to draw.
 *
 * Return Value:
 *  None
 */

void 
CPolyline::Draw(
    HDC hDC,
    HDC hAttribDC,
    BOOL fMetafile, 
    BOOL fEntire,
    LPRECT pRect)
{

    RECT            rc;

    if (!fMetafile && !RectVisible(hDC, pRect))
        return;

    SetMapMode(hDC, MM_ANISOTROPIC);

    //
    // Always set up the window extents to the natural window size
    // so the drawing routines can work in their normal dev coords
    //

    // Use client rect vs. extent rect for Zoom calculation.
    // Zoom factor = prcPos / Extent, so pRect/ClientRect.


    /********* Use the extent rect, not the window rect *********/
    // Using rectExt makes Word printing correct at all zoom levels.
    rc = m_RectExt;
    // GetClientRect(m_pCtrl->Window(), &rc);
    /************************************************************/

    SetWindowOrgEx(hDC, 0, 0, NULL);
    SetWindowExtEx(hDC, rc.right, rc.bottom, NULL);

    SetViewportOrgEx(hDC, pRect->left, pRect->top, NULL);
    SetViewportExtEx(hDC, pRect->right - pRect->left, 
                    pRect->bottom - pRect->top, NULL);

    m_pCtrl->InitView( g_hWndFoster);
    m_pCtrl->Render(hDC, hAttribDC, fMetafile, fEntire, &rc);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ctrprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ctrprop.cpp

Abstract:

    This file contains the CCounterPropPage class and other routines
    to implement the counter property page.

--*/

#include <assert.h>
#include <stdio.h>
#include <math.h>
#include <limits.h>
#include "polyline.h"
#include "ctrprop.h"
#include "utils.h"
#include "unihelpr.h"
#include "winhelpr.h"
#include "visuals.h"
#include "strids.h"
#include "winperf.h"
#include "pdhmsg.h"
#include "globals.h"
#include "browser.h"
#include "smonmsg.h"

#define OWNER_DRAWN_ITEM      2
#define OWNER_DRAW_FOCUS      1


VOID static
HandleSelectionState (
    IN LPDRAWITEMSTRUCT lpdis
    )
/*++

Routine Description:

    HandleSelectionState draws or erases a selection rectangle around an item
    in a combo box list.
    
Arguments:

    lpdis - Pointer to DRAWITEMSTRUCT

Return Value:

    None.

--*/
{
    HBRUSH  hbr ;

    if ( NULL != lpdis ) {

        if (lpdis->itemState & ODS_SELECTED)
            hbr = (HBRUSH)GetStockObject(BLACK_BRUSH) ;
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;

        if ( NULL != hbr ) {
            FrameRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hbr) ;
            DeleteObject (hbr) ;
        }
    }
}


//***************************************************************************
//                                                                          *
//  FUNCTION   : HandleFocusState(LPDRAWITEMSTRUCT)                         *
//                                                                          *
//  PURPOSE    : Handle a change in item focus state. If an item gains the  *
//               input focus, a gray rectangular frame is drawn around that *
//               item; if an item loses the input focus, the gray frame is  *
//               removed.                                                   *
//                                                                          *
//  COMMENT    : The gray focus frame is slightly smaller than the black    *
//               selection frame so they won't paint over each other.       *
//                                                                          *
//***************************************************************************
VOID static
HandleFocusState (
    IN LPDRAWITEMSTRUCT lpdis
    )
/*++

Routine Description:

    HandleFocusState draws or erases a focus rectangle around an item in
    the pulldown list of a combo box. The reactngle is indented to not
    interfere with the selection rectangle.

Arguments:

    lpdis - Pointer to DRAWITEMSTRUCT

Return Value:

    None.

--*/
{
    RECT    rc ;
    HBRUSH  hbr ;

    if ( NULL != lpdis ) {

        // Resize rectangle to place focus frame between the selection
        // frame and the item.
        CopyRect ((LPRECT)&rc, (LPRECT)&lpdis->rcItem) ;
        InflateRect ((LPRECT)&rc, -OWNER_DRAW_FOCUS, -OWNER_DRAW_FOCUS) ;

        // Gray if has focus, background color if not
        if (lpdis->itemState & ODS_FOCUS)
            hbr = (HBRUSH)GetStockObject(GRAY_BRUSH) ;
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;

        if ( NULL != hbr ) {
            FrameRect(lpdis->hDC, (LPRECT)&rc, hbr) ;
            DeleteObject (hbr) ;
        }
    }
}


CCounterPropPage::CCounterPropPage ( void )
:   m_pInfoSel ( NULL ),
    m_pInfoDeleted ( NULL ),
    m_dwMaxHorizListExtent ( 0 ),
    m_nLastSelCount( 0 ),
    m_bAreModSelectedVisuals ( FALSE ),
    m_fHashTableSetup ( FALSE )
/*++

Routine Description:

    Creation routine for counter property page. Initializes the instance
    variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    m_uIDDialog = IDD_CTR_PROPP_DLG;
    m_uIDTitle = IDS_CTR_PROPP_TITLE;
    return;
}

CCounterPropPage::~CCounterPropPage (
    VOID
    )
/*++

Routine Description:

    Destructor for counter property page.
Arguments:

    None.

Return Value:

    None.

--*/
{
    ClearCountersHashTable();
    return;
}

void
CCounterPropPage::DeinitControls ( void )
{
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    HWND    hwndList = NULL;
    INT     iIndex = 0;
    INT     iItemCnt = 0;
    PItemInfo pInfo = NULL;

    // Write the current visuals back to the control
    // Must be at least one control object and only the first is used
    if (m_cObjects != 0) {
        pObj = m_ppISysmon[0];
        if ( NULL != pObj ) {
            pPrivObj = (CImpISystemMonitor*)pObj;
        }
    }

    if ( NULL != pPrivObj ) {
        if ( AreModifiedSelectedVisuals() ) {
            IncrementLocalVisuals();
        }
        pPrivObj->SetVisuals(m_props.rgbColor, m_props.iColorIndex, m_props.iWidthIndex, m_props.iStyleIndex);
    } 

    hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
    if ( NULL != hwndList ) {
        iItemCnt = LBNumItems(hwndList);
        for (iIndex = 0; iIndex < iItemCnt; iIndex++ ) {
            pInfo = (PItemInfo)LBData(hwndList,iIndex);
            if ( NULL != pInfo ) {
                DeleteInfo(pInfo);
            }
        }
    }
    return;
}


INT
CCounterPropPage::SelectMatchingItem (
    INT iColorIndex,
    COLORREF rgbCustomColor,
    INT iWidthIndex,
    INT iStyleIndex)
/*++

Routine Description:

    GetMatchingIndex selects the first counter item that matches the
    specified visual characteristics.

Arguments:

    None.

Return Value:

    Returns the index of the selected item on match.  If none match, then
    returns -1.

--*/
{
    INT iReturn = -1;

    // Get number of items in list box
    HWND hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
    INT iItemCnt = LBNumItems(hwndList);
    INT i;
    bool bMatch = false;

    // For each item
    for (i=0; !bMatch && i<iItemCnt; i++){

        PItemInfo pInfo = (PItemInfo)LBData(hwndList,i);

        LoadItemProps ( pInfo );

        if ( pInfo->Props.iColorIndex == iColorIndex ) {
            if ( NumStandardColorIndices() > iColorIndex ) {
                bMatch = true;
            } else {
                if ( pInfo->Props.rgbColor == rgbCustomColor )
                    bMatch = true;
            }

            if ( bMatch ) {
                if ( ( iWidthIndex != pInfo->Props.iWidthIndex )
                    || ( iStyleIndex != pInfo->Props.iStyleIndex ) ){
                    bMatch = false;
                }
            }
        }
    }

    if ( bMatch ) {
        iReturn = i - 1;

        SelectItem ( iReturn );
    }

    return iReturn;
}


BOOL
CCounterPropPage::GetProperties (
    VOID
    )
/*++

Routine Description:

    GetProperties initializes the dialog box for the property page. It then
    fetches an ICounterItem interface for each counter of the control being
    edited. Each interface pointer is placed in an ItemInfo structure which is
    then added to the dialog list box.
    
    The counter properties are not fetched until they are needed for display.
    The first counter fetched is selected to display its properties in the
    dialog box.

Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    ICounterItem    *pItem;
    ICounterItem    *pSelectedItem = NULL;
    PItemInfo       pInfo;
    INT             nCtr;
    INT             nSelCtr = LB_ERR;
    INT             iIndex;
    INT             nChar;
    BOOL            bStat = TRUE;
    BSTR            bstrPath;
    HRESULT         dwResult;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;

    InitDialog();

    // Must be at least one control object and only the first is used
    if (m_cObjects == 0) {
        bStat = FALSE;
    } else {
        pObj = m_ppISysmon[0];
        if ( NULL != pObj ) {
            pPrivObj = (CImpISystemMonitor*)pObj;
        }
    }

    if ( bStat && NULL != pObj && NULL != pPrivObj ) {

        // Request each counter from the control, stopping on failure
        nCtr = 0;

        pPrivObj->GetSelectedCounter( &pSelectedItem );

        while (SUCCEEDED(pObj->Counter(nCtr, &pItem))) {
            // Create ItemInfo to hold the counter
            pInfo = new ItemInfo;

            if (pInfo == NULL) {
                bStat = FALSE;
                break;
            }
            
            ZeroMemory(pInfo, sizeof(ItemInfo));

            pInfo->pItem = pItem;
            pItem->get_Path( &bstrPath );
        
            if (bstrPath != NULL) {
                nChar = lstrlen(bstrPath) + 1;

                pInfo->pszPath = new WCHAR [nChar];

                if (pInfo->pszPath == NULL) {
                    delete pInfo;
                    pInfo = NULL;
                    SysFreeString(bstrPath);
                    bStat = FALSE;
                    break;
                }

                StringCchCopy(pInfo->pszPath, nChar, bstrPath);

                SysFreeString(bstrPath);
            }

            dwResult = InsertCounterToHashTable(pInfo->pszPath, &pCounter); 

            if (dwResult == ERROR_SUCCESS) {
                //
                // Add the counter to the list box
                //
                iIndex = AddItemToList(pInfo);

                if ( LB_ERR == iIndex ) {
                    RemoveCounterFromHashTable(pInfo->pszPath, pCounter);
                    bStat = FALSE;
                    DeleteInfo(pInfo);
                    pInfo = NULL;
                    break;
                } else {
                    pInfo->pCounter = pCounter;
                    if ( pSelectedItem == pItem ) {
                        nSelCtr = iIndex;
                    }
                }   
            }
            else {
                bStat = FALSE;
                DeleteInfo(pInfo);
                pInfo = NULL;
                break;
            }

            nCtr++;
        }

        if ( NULL != pSelectedItem ) {
            pSelectedItem->Release();
        }

        // Get the current visuals fron the control
        // and initialize the property dialog
        pPrivObj->GetVisuals(&m_props.rgbColor, &m_props.iColorIndex, &m_props.iWidthIndex, &m_props.iStyleIndex);

        // If a counter matches the selected counter, select that item.
        // Else if the visuals match an existing item, select that item.
        // Else if there is at least one counter in the control, select the first counter.
        // Otherwise, set the display properties to the first counter to be added.

        if ( LB_ERR != nSelCtr ) {
            SelectItem ( nSelCtr ); 
        } else {
            if ( LB_ERR == SelectMatchingItem (
                            m_props.iColorIndex,
                            m_props.rgbColor,
                            m_props.iWidthIndex,
                            m_props.iStyleIndex ) ) 
            {
                if ( 0 < nCtr ) {
                    SelectItem ( 0 );
                } else {
                    // Init the scale factor to the default
                    m_props.iScaleIndex = 0;

                    // If nothing selected, ensure that the color index is set to
                    // a standard color.
                    if ( m_props.iColorIndex == NumStandardColorIndices() ) {
                        m_props.iColorIndex -= 1;
                    }

                    CBSetSelection(DialogControl(m_hDlg, IDC_LINECOLOR), m_props.iColorIndex);
                    CBSetSelection(DialogControl(m_hDlg, IDC_LINEWIDTH), m_props.iWidthIndex);
                    CBSetSelection(DialogControl(m_hDlg, IDC_LINESTYLE), m_props.iStyleIndex);
                    CBSetSelection(DialogControl(m_hDlg, IDC_LINESCALE), m_props.iScaleIndex);
                    SetStyleComboEnable();
                }
            }
        }
    }
    return bStat;   
}

INT
CCounterPropPage::AddItemToList (
    IN PItemInfo pInfo
    )
/*++

Routine Description:

    AddItemToList adds a counter's path name to the dialog list box and
    attaches a pointer to the counter's ItemInfo structure as item data.
    It also adjusts the horizontal scroll of the list box.

Arguments:

    pInfo - Pointer to counter's ItemInfo structure

Return Value:

    List box index of added counter (LB_ERR on failure)

--*/
{
    INT     iIndex;
    HWND    hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
    DWORD   dwItemExtent = 0;
    HDC     hDC = NULL;

    iIndex = (INT)LBAdd(hwndList, pInfo->pszPath);

    if ( LB_ERR != iIndex && LB_ERRSPACE != iIndex ) {    
        LBSetData(hwndList, iIndex, pInfo);
    
        hDC = GetDC ( hwndList );
        if ( NULL != hDC ) {
            dwItemExtent = (DWORD)TextWidth ( hDC, pInfo->pszPath );
 
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
                LBSetHorzExtent ( hwndList, dwItemExtent ); 
            }
            ReleaseDC (hwndList, hDC) ;
        }
    } else {
        iIndex = LB_ERR ; 
    }
    return iIndex;
}

VOID
CCounterPropPage::LoadItemProps (
    IN PItemInfo pInfo
    )
/*++

Routine Description:

    LoadItemProps loads the properties of the selected counter through the
    counter's interface into the ItemInfo structure, if not already loaded.

Arguments:

    pInfo - pointer to item info

Return Value:

    None.

--*/
{
    // If properties not loaded for this item, get them now
    if (pInfo->pItem && !pInfo->fLoaded) {
        INT iScaleFactor;
        INT iStyle;
        INT iWidth;
        pInfo->pItem->get_Color ( &pInfo->Props.rgbColor );
        pInfo->pItem->get_ScaleFactor ( &iScaleFactor );
        pInfo->pItem->get_Width ( &iWidth );
        pInfo->pItem->get_LineStyle ( &iStyle );
        // Translate to combo box indices
        pInfo->Props.iColorIndex = ColorToIndex ( pInfo->Props.rgbColor );
        pInfo->Props.iStyleIndex = StyleToIndex ( iStyle );
        pInfo->Props.iWidthIndex = WidthToIndex ( iWidth );
        pInfo->Props.iScaleIndex = ScaleFactorToIndex ( iScaleFactor );

        pInfo->fLoaded = TRUE;
    }
    return;
}

VOID
CCounterPropPage::DisplayItemProps (
    IN PItemInfo pInfo
    )
/*++

Routine Description:

    DisplayItemProps displays the properties of the selected counter on the
    property page dialog. If the counter is being displayed for the first time
    the properties are obtained through the counter's interface and are loaded
    into the ItemInfo structure.

Arguments:

    pInfo - pointer to item info

Return Value:

    None.

--*/
{
    // Get number of items in color combo box
    HWND hWndColor = DialogControl(m_hDlg, IDC_LINECOLOR);
    INT iCurrentColorCnt = CBNumItems(hWndColor);

    // If properties not loaded for this item, get them now
    LoadItemProps ( pInfo );

    // Display the properties
    m_props = pInfo->Props;

    // Handle custom color
    if ( iCurrentColorCnt > NumStandardColorIndices() ) {
        // Delete the custom color item.  It is stored at
        // the end of the list.
        CBDelete(hWndColor, iCurrentColorCnt - 1);
    }

    // If new custom color, add it at the end of the list.
    if ( NumStandardColorIndices() == m_props.iColorIndex )
        CBAdd( hWndColor, (INT_PTR)m_props.iColorIndex );

    CBSetSelection(hWndColor, m_props.iColorIndex);
    CBSetSelection(DialogControl(m_hDlg, IDC_LINEWIDTH), m_props.iWidthIndex);
    CBSetSelection(DialogControl(m_hDlg, IDC_LINESTYLE), m_props.iStyleIndex);
    CBSetSelection(DialogControl(m_hDlg, IDC_LINESCALE), m_props.iScaleIndex);

    SetStyleComboEnable();
}

    
BOOL
CCounterPropPage::SetProperties (
    VOID
    )
/*++

Routine Description:

    SetProperties applies the counter changes the user has made. It calls the
    control's AddCounter and DeleteCounter to adjust the counter set. It calls
    the counter's property functions for all new and changed counters.

    The counters to be deleted are in the pInfoDeleted linked list. The other
    counters are obtained from the dialog list box.
    
Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    HWND    hwndList;
    INT     iItemCnt;
    INT     i;
    PItemInfo pInfo, pInfoNext;
    ISystemMonitor  *pObj;
    BSTR pBstr = NULL;

    // Apply changes to first control
    pObj = m_ppISysmon[0];

    if ( NULL != pObj ) {

        // For all items in the delete list
        pInfo = m_pInfoDeleted;
        while (pInfo) {

            // If this counter exists in the control
            if (pInfo->pItem != NULL) {

                // Tell control to remove it
                pObj->DeleteCounter(pInfo->pItem);
            }

            // Delete the Info structure and point to the next one
            pInfoNext = pInfo->pNextInfo;

            DeleteInfo(pInfo);

            pInfo = pInfoNext;
        }

        m_pInfoDeleted = NULL;

        // Get number of items in list box
        hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
        iItemCnt = LBNumItems(hwndList);

        //assert( IsWindowUnicode(hwndList) );

        // For each item
        for (i=0; i<iItemCnt; i++) {
            pInfo = (PItemInfo)LBData(hwndList,i);

            // If new item, create it now
            if (pInfo->pItem == NULL) {
#if UNICODE
                pBstr = SysAllocString(pInfo->pszPath);
                pObj->AddCounter(pBstr, &pInfo->pItem);
#else
                INT nChar = lstrlen(pInfo->pszPath);
                LPWSTR pszPathW = new WCHAR [nChar + 1];
                if (pszPathW) {
                    MultiByteToWideChar(CP_ACP, 0, pInfo->pszPath, nChar+1, pszPathW, nChar+1);
                    pBstr = SysAllocString(pInfo->pszPath);
                    pObj->AddCounter(pBstr, &pInfo->pItem);
                    delete [] pszPathW;
                }
#endif
                if (pBstr) {
                    SysFreeString(pBstr);
                }
            }

            // If item has changed, put the new properties
            if (pInfo->pItem != NULL && pInfo->fChanged) {
                // iColorIndex is used to determine standard colors.
                if ( pInfo->Props.iColorIndex < NumStandardColorIndices() ) {
                    pInfo->pItem->put_Color(IndexToStandardColor( pInfo->Props.iColorIndex) );
                } else {
                    pInfo->pItem->put_Color(pInfo->Props.rgbColor);
                }

                pInfo->pItem->put_Width(IndexToWidth(pInfo->Props.iWidthIndex));
                pInfo->pItem->put_LineStyle(IndexToStyle(pInfo->Props.iStyleIndex));
                pInfo->pItem->put_ScaleFactor(IndexToScaleFactor( pInfo->Props.iScaleIndex ) );

                pInfo->fChanged = FALSE;
             }
        }

        // Tell graph to redraw itself
        pObj->UpdateGraph();
    } // else report internal error
    return TRUE;    
}


VOID
CCounterPropPage::InitDialog (
    VOID
    )
/*++

Routine Description:

    InitDialog loads each attribute combo box with its list of choices and
    selects the default choice. The graphical attributes are owner drawn, so
    their list items are just set to numerical indices. The scale attribute
    list is filled with numeric strings representing scale factors plus a
    default selection.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HWND    hWndColors;
    HWND    hWndWidths;
    HWND    hWndStyles;
    HWND    hWndScales;
    INT     i ;
    double  ScaleFactor ;
    WCHAR   tempBuff[MAX_VALUE_LEN] ;


    if (m_hDlg == NULL)
        return;
    //assert( IsWindowUnicode( m_hDlg ) );

    // Load the colors combobox, select the default color.
    hWndColors = DialogControl (m_hDlg, IDC_LINECOLOR) ;
    for (i = 0 ; i < NumStandardColorIndices () ; i++)
        CBAdd (hWndColors, (INT_PTR)1);      // string pointer is unused.  Fill with
                                        // arbitrary value.

    CBSetSelection (hWndColors, 0) ;

    // Load the widths combo box, select the default width.
    hWndWidths = DialogControl (m_hDlg, IDC_LINEWIDTH) ;
    for (i = 0 ; i < NumWidthIndices () ; i++)
       CBAdd (hWndWidths, (INT_PTR)1) ;

    CBSetSelection (hWndWidths, 0) ;

    // Load the styles combo box, select the default style.
    hWndStyles = DialogControl (m_hDlg, IDC_LINESTYLE) ;
    for (i = 0 ; i < NumStyleIndices () ; i++)
       CBAdd (hWndStyles, (INT_PTR)1) ;

    CBSetSelection (hWndStyles, 0) ;

    // Init the scale combo box.
    hWndScales = DialogControl (m_hDlg, IDC_LINESCALE) ;

    CBAdd (hWndScales, ResourceString(IDS_DEFAULT)) ;

    // Generate power of 10 scale factors
    ScaleFactor = pow (10.0f, (double)PDH_MIN_SCALE);
    for (i = PDH_MIN_SCALE ; i <= PDH_MAX_SCALE ; i++)   {

        FormatNumber (
             ScaleFactor,
             tempBuff,
             MAX_VALUE_LEN,
             (i <= 0 ? (-1 * i) + 1 : i + 1),
             (i < 0 ? (-1 * i) : 1) );

       CBAdd (hWndScales, tempBuff) ;

       ScaleFactor *= (double) 10.0f ;
    }

    CBSetSelection (hWndScales, 0) ;
    ClearCountersHashTable();

    DialogEnable(m_hDlg, IDC_LINECOLOR, FALSE);
    DialogEnable(m_hDlg, IDC_LINEWIDTH, FALSE);
    DialogEnable(m_hDlg, IDC_LINESTYLE, FALSE);
    DialogEnable(m_hDlg, IDC_LINESCALE, FALSE);
}


void 
CCounterPropPage::IncrementLocalVisuals (
    void
    )
{
    // Increment the visual indices in color, width, style order
    if (++m_props.iColorIndex >= NumStandardColorIndices()) {
        m_props.iColorIndex = 0;

        if (++m_props.iWidthIndex >= NumWidthIndices()) {
            m_props.iWidthIndex = 0;

            if (++m_props.iStyleIndex < NumStyleIndices()) {
                m_props.iStyleIndex = 0;
            }
        }
    }
    SetModifiedSelectedVisuals ( FALSE );
    return;
}

HRESULT
CCounterPropPage::NewItem (
    IN LPWSTR pszPath,
    IN DWORD /* dwFlags */
    )
/*++

Routine Description:

    NewItem adds a new counter to the dialog's counter list box. It first
    creates a new ItemInfo structure and loads it with the counter pathname
    string. Then the ItemInfo is added to the dialog list box.

Arguments:
    
    pszPath - Pointer to counter pathname string
    fGenerated - TRUE if path was generated from a wildcard path

Return Value:

    Index of new item in counter list (-1 if failed to add)

--*/
{
    PItemInfo pInfo;
    HRESULT   dwResult;
    BOOL      bRet;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;

    dwResult = InsertCounterToHashTable(pszPath, &pCounter);
    
    if (dwResult != ERROR_SUCCESS) {
        return dwResult;
    }

    // Allocate ItemInfo structure
    pInfo = NULL;
    pInfo = new ItemInfo;
    if (pInfo == NULL) {
        bRet = RemoveCounterFromHashTable(pszPath, pCounter);

        assert(bRet);
        return E_OUTOFMEMORY;
    }

    // Mark as loaded to prevent requesting attributes from control
    // Mark as changed so sttribute will be written
    pInfo->fLoaded = TRUE;
    pInfo->fChanged = TRUE;

    // Actual counter doesn't exist yet
    pInfo->pItem = NULL;

    // If a counter is selected, we're showing its visuals
    // so increment them for the new counter
    if (m_pInfoSel != NULL) {
        IncrementLocalVisuals();
    }
    else {
        // Point to the new item so the visuals are incremented
        // for the next one
        m_pInfoSel = pInfo;
    }

    // Set default scaling
    m_props.iScaleIndex = 0;

    // Color is non-standard only if user is able to build a color.
    if( m_props.iColorIndex < NumStandardColorIndices() )
        m_props.rgbColor = IndexToStandardColor( m_props.iColorIndex );
    else
        m_props.rgbColor = pInfo->Props.rgbColor;

    // Copy properties to new counter
    pInfo->Props = m_props;

    // Make own copy of path name string
    pInfo->pszPath = new WCHAR [lstrlen(pszPath) + 1];

    if (pInfo->pszPath == NULL)
    {
        bRet = RemoveCounterFromHashTable(pszPath, pCounter);

        assert(bRet);

        delete pInfo;
        return E_OUTOFMEMORY;
    }
    
    StringCchCopy(pInfo->pszPath, lstrlen(pszPath) + 1, pszPath);

    // Add to dialog's counter list
    pInfo->pCounter = pCounter;
    m_iAddIndex = AddItemToList(pInfo);

    return S_OK;
}


VOID
CCounterPropPage::SelectItem (
    IN INT iItem
    )
/*++

Routine Description:

    SelectItem selects a specified counter item in the dialog counter list.
    It then displays the selected counter's properties and enables the
    "Delete Counter" button.

    SelectItem can be called with a -1 to deselect all counters and disable
    the delete button.

    The member variable, m_pInfoSel, is updated to point to the selected
    counter info.

Arguments:

    iItem - List index of counter item to select, or -1 to deselect all

Return Value:

    None.

--*/
{
    HWND    hWnd;

    hWnd = DialogControl(m_hDlg, IDC_CTRLIST);

    // Translate index into item pointer
    if (iItem == -1) {
        m_pInfoSel = NULL;
    }
    else {
        m_pInfoSel = (PItemInfo)LBData(hWnd, iItem);

         if ((INT_PTR)m_pInfoSel == LB_ERR)
            m_pInfoSel = NULL;
    }

    // Select the item, display properties, and enable delete button
    if (m_pInfoSel != NULL) {
        INT nSelCount;

        LBSetSel(hWnd, TRUE, iItem);
        nSelCount = LBSelectCount(hWnd);

        if (nSelCount == 1) {
            DialogEnable(m_hDlg, IDC_LINECOLOR, TRUE);
            DialogEnable(m_hDlg, IDC_LINEWIDTH, TRUE);
            DialogEnable(m_hDlg, IDC_LINESTYLE, TRUE);
            DialogEnable(m_hDlg, IDC_LINESCALE, TRUE);
        }
        else {
            DialogEnable(m_hDlg, IDC_LINECOLOR, FALSE);
            DialogEnable(m_hDlg, IDC_LINEWIDTH, FALSE);
            DialogEnable(m_hDlg, IDC_LINESTYLE, FALSE);
            DialogEnable(m_hDlg, IDC_LINESCALE, FALSE);
        }
        m_nLastSelCount = nSelCount;
        DisplayItemProps(m_pInfoSel);
        DialogEnable(m_hDlg,IDC_DELCTR,1);
    }
    else {
        LBSetSel(hWnd, FALSE, -1);
        DialogEnable(m_hDlg,IDC_DELCTR, 0);
        DialogEnable(m_hDlg, IDC_LINECOLOR, FALSE);
        DialogEnable(m_hDlg, IDC_LINEWIDTH, FALSE);
        DialogEnable(m_hDlg, IDC_LINESTYLE, FALSE);
        DialogEnable(m_hDlg, IDC_LINESCALE, FALSE);
        m_nLastSelCount =  0;
    }
}
            

VOID
CCounterPropPage::DeleteItem (
    VOID
    )
/*++

Routine Description:

    DeleteItem removes the currently selected counter from the dialog's counter
    listbox. It adds the item to the deletion list, so the actual counter can
    be deleted from the control when (and if) the changes are applied.

    The routine selects selects the next counter in the listbox if there is one.

Arguments:
    
    None.

Return Value:

    None.

--*/
{
    HWND    hWnd;
    INT     iIndex;
    PItemInfo   pInfo;
    DWORD   dwItemExtent = 0;
    HDC     hDC = NULL;
    INT     iStartIndex;
    INT     iEndIndex;
    INT     iSelectCount;
    INT     iItemCount;
    INT     iOrigCaret;

    // Get selected index
    hWnd = DialogControl(m_hDlg, IDC_CTRLIST);
    iSelectCount = LBSelectCount(hWnd);
    if (iSelectCount <= 0 ) {
        return;
    }
    else {
        iEndIndex = 0;
        iStartIndex = LBNumItems(hWnd) - 1;
    }

    //
    // We scan the whole list box to remove items
    // May use LB_GETSELITEMS (did not compare the performance)?
    //
    iOrigCaret = LBFocus(hWnd);
    for (iIndex = iStartIndex; iIndex >= iEndIndex; iIndex--) {
        if (!LBSelected(hWnd, iIndex)) {
            continue;
        }

        // Get selected item info
        pInfo = (PItemInfo)LBData(hWnd, iIndex);

        // Move it to the "Deleted" list.
        pInfo->pNextInfo = m_pInfoDeleted;
        m_pInfoDeleted = pInfo;

        // Remove the string from the list box.
        LBDelete(hWnd, iIndex);

        // Remove the counter from hash table
        RemoveCounterFromHashTable(pInfo->pszPath, pInfo->pCounter);
    }

    //
    // see how many entries are left and update the
    // caret position and the remove button state
    //
    iItemCount = LBNumItems(hWnd);
    if (iItemCount > 0) {
        // the update the caret
        if (iOrigCaret >= iItemCount) {
            iOrigCaret = iItemCount-1;
        } else {
            // caret should be within the list
        }
        SelectItem(iOrigCaret);
    } else {
        // the list is empty so remove caret, selection
        // disable the remove button and activate the
        // add button
        SelectItem(-1);
    }

    // Clear the max horizontal extent and recalculate
    m_dwMaxHorizListExtent = 0;
                        
    hDC = GetDC ( hWnd );
    if ( NULL != hDC ) {
        for ( iIndex = 0; iIndex < (INT)LBNumItems ( hWnd ); iIndex++ ) {
            pInfo = (PItemInfo)LBData(hWnd, iIndex);
            dwItemExtent = (DWORD)TextWidth ( hDC, pInfo->pszPath );
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
            }
        }
        ReleaseDC (hWnd, hDC) ;
    }
        
    LBSetHorzExtent ( hWnd, m_dwMaxHorizListExtent ); 

    // Set change flag to enable "Apply" button
    SetChange();
}


static HRESULT
AddCallback (
    LPWSTR  pszPathName,
    DWORD_PTR lpUserData,
    DWORD   dwFlags
    )
{
    CCounterPropPage* pObj = (CCounterPropPage*)lpUserData;

    return pObj->NewItem(pszPathName, dwFlags);
}
    

VOID
CCounterPropPage::AddCounters (
    VOID
    )
/*++

Routine Description:

    AddCounters invokes the counter browser to select new counters.
    The browser calls the AddCallback function for each new counter.
    AddCallback passes the counter path on to the NewItem method.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT         hr = NOERROR;
    HLOG            hDataSource;
    VARIANT_BOOL    bMonitorDuplicateInstances = FALSE;
    ISystemMonitor  *pObj = m_ppISysmon[0];
    CImpISystemMonitor *pPrivObj;
    eDataSourceTypeConstant eDataSource = sysmonNullDataSource;
    
    USES_CONVERSION

    pPrivObj = (CImpISystemMonitor*)pObj;

    m_iAddIndex = -1;

    // Browse counters (calling AddCallack for each selected counter)
    hr = pObj->get_MonitorDuplicateInstances(&bMonitorDuplicateInstances);

    if (SUCCEEDED(hr)) {
        hr = pObj->get_DataSourceType(& eDataSource);
    }

    if (SUCCEEDED(hr)) {
        // Cannot call pObj->BrowseCounter() because using callback method
        // private to this file.

        if ( sysmonLogFiles == eDataSource 
                || sysmonSqlLog == eDataSource ) {

            hDataSource = pPrivObj->GetDataSourceHandle();
            assert ( NULL != hDataSource );
        } else {
            hDataSource = H_REALTIME_DATASOURCE;
        }

        if (SUCCEEDED(hr)) {
            BrowseCounters(
                    hDataSource,
                    PERF_DETAIL_WIZARD, 
                    m_hDlg, 
                    AddCallback, 
                    (LPVOID) this, 
                    (BOOL) bMonitorDuplicateInstances);
        }
    } else {
        // Todo: Error message 
    }

    // if any items added, select the last one
    if (m_iAddIndex != -1) {

        SelectItem(-1);
        SelectItem(m_iAddIndex);
        m_iAddIndex = -1;

        // Set change to enable "Apply" button
        SetChange();
    }

    return;
}


VOID
CCounterPropPage::DialogItemChange (
    IN WORD wId,
    IN  WORD wMsg
    )
/*++

Routine Description:

    DialogItemChange processes window messages sent to any of the property
    page dialog controls. When the counter listbox selection changes, it
    selects the new counter item and displays its properties. When a change is
    made to a property combo box, it updates the property for the currently
    selected counter item. When the add or delete counter button is pressed,
    it calls the appropriate property page functions.

Arguments:

    wID - Dialog control ID
    wMsg - Notification code

Return Value:

    None.

--*/

{
    INT     iIndex;
    INT     iNewProp;
    HWND    hWnd;

    // Case on control ID
    switch (wId) {

        case IDC_CTRLIST:

            // If selection changed
            if (wMsg == LBN_SELCHANGE) {
                INT nSelCount;
                
                // Get selected index   
                hWnd = DialogControl(m_hDlg, IDC_CTRLIST);

                nSelCount = LBSelectCount(hWnd);

                if (nSelCount == 1) {
                    if (m_nLastSelCount != 1) {
                        DialogEnable(m_hDlg, IDC_LINECOLOR, TRUE);
                        DialogEnable(m_hDlg, IDC_LINEWIDTH, TRUE);
                        DialogEnable(m_hDlg, IDC_LINESTYLE, TRUE);
                        DialogEnable(m_hDlg, IDC_LINESCALE, TRUE);
                    }

                    if (LBGetSelItems(hWnd, 1, &iIndex) == 1) {
                        m_pInfoSel = (PItemInfo)LBData(hWnd, iIndex);
                        DisplayItemProps(m_pInfoSel);
                        DialogEnable(m_hDlg, IDC_DELCTR, 1);
                    }
                }
                else {
                    DialogEnable(m_hDlg, IDC_LINECOLOR, FALSE);
                    DialogEnable(m_hDlg, IDC_LINEWIDTH, FALSE);
                    DialogEnable(m_hDlg, IDC_LINESTYLE, FALSE);
                    DialogEnable(m_hDlg, IDC_LINESCALE, FALSE);
                }
                m_nLastSelCount = nSelCount;
            }
            break;
        
        case IDC_LINECOLOR:
        case IDC_LINEWIDTH:
        case IDC_LINESTYLE:
        case IDC_LINESCALE:

            // If selection changed and a counter is selected
            if (wMsg == CBN_SELCHANGE) {

                hWnd = DialogControl(m_hDlg, wId);
                iNewProp = (INT)CBSelection(hWnd);

                // Store the new property selection
                switch (wId) {

                    case IDC_LINECOLOR:
                         m_props.iColorIndex = iNewProp;
                         // If iColorIndex is for the custom color, the
                         // custom color is already set in the properties.
                         break;

                    case IDC_LINEWIDTH:
                        m_props.iWidthIndex = iNewProp;
                        SetStyleComboEnable();
                        break;

                    case IDC_LINESTYLE:
                        m_props.iStyleIndex = iNewProp;
                        break;

                    case IDC_LINESCALE:
                        m_props.iScaleIndex = iNewProp;
                        break;
                }

                // If counter is selected, update its properties
                if (m_pInfoSel != NULL) {

                    m_pInfoSel->Props = m_props;

                    // mark the counter as changed
                    m_pInfoSel->fChanged = TRUE;
                    SetChange();
                    SetModifiedSelectedVisuals( TRUE );
                }

            }
            break;

        case IDC_ADDCTR:
            // Invoke counter browser to add to counter
            AddCounters();
            break;

        case IDC_DELCTR:
            // Delete the currently selected counter
            DeleteItem();
            break;  
    }
}


VOID
CCounterPropPage::MeasureItem (
    OUT PMEASUREITEMSTRUCT pMI
    )
{
   pMI->CtlType    = ODT_COMBOBOX ;
   pMI->CtlID      = IDC_LINECOLOR ;
   pMI->itemData   = 0 ;
   pMI->itemWidth  = 0 ;
   pMI->itemHeight = 14 ;
}



VOID
CCounterPropPage::DrawItem (
    IN PDRAWITEMSTRUCT pDI
    )
/*++

Routine Description:

    DrawItem draws a specified item in one of the graphical property combo
    boxes. It is called to process WM_DRAWITEM messages.

Arguments:

    pDI - Pointer to DRAWITEMSTRUCT

Return Value:

    None.

--*/
{
    HDC            hDC ;
    PRECT          prect ;
    INT            itemID,
                  CtlID,
                  itemAction ;
    HPEN           hPen;
    COLORREF       rgbBk, rgbOldBk;

    if ( NULL != pDI ) {

        hDC        = pDI->hDC ;
        CtlID      = pDI->CtlID ;
        prect      = &pDI->rcItem ;
        itemID     = pDI->itemID ;
        itemAction = pDI->itemAction ;

        // Case on drawing request
        switch (itemAction) {

            case ODA_SELECT:

                // Draw/erase selection rect
                HandleSelectionState(pDI);
                break;

            case ODA_FOCUS:

                // Draw/erase focus rect
                HandleFocusState (pDI);
                break;

            case ODA_DRAWENTIRE:

                // Leave border space for focus rectangle
                InflateRect (prect, -OWNER_DRAWN_ITEM, -OWNER_DRAWN_ITEM) ;

                // Case on Control ID
                switch (CtlID)  {

                case IDC_LINECOLOR:

                    // Draw filled rect of item's color
                    if ( itemID < NumStandardColorIndices() )
                        Fill(hDC, IndexToStandardColor(itemID), prect);
                    else
                        // Custom color item only exists if the currently
                        // selected item has a custom color defined.
                        Fill(hDC, m_pInfoSel->Props.rgbColor, prect);
                    break ;

                case IDC_LINEWIDTH:
                case IDC_LINESTYLE:

                    // Clear the item's area
                    rgbBk = GetSysColor(COLOR_WINDOW);
                    
                    Fill(hDC, rgbBk, prect);

                    // Draw centered line showing item's width or style
                    if (CtlID == IDC_LINEWIDTH)
                       hPen = CreatePen (PS_SOLID, IndexToWidth(itemID), RGB (0,0,0));
                    else
                       hPen = CreatePen (IndexToStyle(itemID), 1, RGB (0,0,0));

                    if ( NULL != hPen ) {

                        // Set background to insure dashed lines show properly
                        rgbOldBk = SetBkColor (hDC, rgbBk) ;

                        if ( CLR_INVALID != rgbOldBk ) {

                            Line(hDC, (HPEN)hPen, prect->left + 8,
                                                  (prect->top + prect->bottom) / 2,
                                                  prect->right - 8,
                                                  (prect->top + prect->bottom) / 2);

                            SetBkColor (hDC, rgbOldBk) ;
                        }
                        DeleteObject (hPen) ;
                    }
                    break ;
            }

            // Restore original rect and draw focus/select rects
            InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ;
            HandleSelectionState (pDI) ;
            HandleFocusState (pDI) ;        
        }
    }
}

INT
CCounterPropPage::ScaleFactorToIndex (
    IN INT iScaleFactor
    )
/*++

Routine Description:

    ScaleFactorToIndex translates a CounterItem ScaleFactor value to
    the appropriate scale factor combo box index.

Arguments:

    iScaleFactor - CounterItem scale factor integer value.

Return Value:

    Scale factor combo box index.

--*/
{
    INT retValue;

    if ( INT_MAX == iScaleFactor ) {
        retValue = 0;
    } else {
        retValue = iScaleFactor - PDH_MIN_SCALE + 1;
    }

    return retValue;
}

INT
CCounterPropPage::IndexToScaleFactor (
    IN INT iScaleIndex
    )
/*++

Routine Description:

    ScaleFactorToIndex translates a CounterItem ScaleFactor value to
    the appropriate scale factor combo box index.

Arguments:

    iScaleIndex - Scale factor combo box index.

Return Value:

    CounterItem scale factor integer value.

--*/
{
    INT retValue;

    if ( 0 == iScaleIndex ) {
        retValue = INT_MAX;
    } else {
        retValue = iScaleIndex - 1 + PDH_MIN_SCALE;
    }

    return retValue;
}

void
CCounterPropPage::SetStyleComboEnable (
    )
/*++

Routine Description:

    SetStyleComboEnable enables the style combo box if the width is 1,
    disables it otherwise.

Arguments:

Return Value:

    void

--*/
{
    HWND hWnd;

    hWnd = DialogControl(m_hDlg, IDC_CTRLIST);

    DialogEnable (m_hDlg, IDC_LABEL_LINESTYLE, (0 == m_props.iWidthIndex) );
    if (LBSelectCount(hWnd) == 1) {
        DialogEnable (m_hDlg, IDC_LINESTYLE, (0 == m_props.iWidthIndex) );
    }
}

HRESULT 
CCounterPropPage::EditPropertyImpl( DISPID dispID )
{
    HRESULT hr = E_NOTIMPL;

    if ( DISPID_VALUE == dispID ) {
        m_dwEditControl = IDC_ADDCTR;
        hr = S_OK;
    }

    return hr;
}
ULONG 
CCounterPropPage::HashCounter(
    LPWSTR szCounterName
    )
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPWSTR szThisChar;
    WCHAR Char;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            Char = * szThisChar;
            if (_istupper(Char) ) {
                Char = _tolower(Char);
            }
            h = (a * h + ((ULONG) Char)) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % eHashTableSize);
}


//++
// Description:
//    Remove a counter path from hash table. One counter
//    path must exactly match the given one in order to be
//    removed, even it is one with wildcard
//
// Parameters:
//    pItemInfo - Pointer to item info to be removed
//
// Return:
//    Return TRUE if the counter path is removed, otherwis return FALSE
//--
BOOL
CCounterPropPage::RemoveCounterFromHashTable(
    LPWSTR pszPath,
    PPDH_COUNTER_PATH_ELEMENTS pCounter
    ) 
{
    ULONG lHashValue;
    PHASH_ENTRY pEntry = NULL;
    PHASH_ENTRY pPrev = NULL;
    BOOL bReturn = FALSE;
    LPWSTR pszFullPath = NULL;

    SetLastError(ERROR_SUCCESS);

    if (pszPath == NULL || pCounter == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto ErrorOut;
    }

    //
    // If the counter path does not have machine name,
    // add the machine name to compose a full path
    //
    if (*pszPath == L'\\' && (*(pszPath+1) == L'\\') ) {
        lHashValue = HashCounter(pszPath);
    }
    else {
        ULONG ulBufLen;

        if (pCounter->szMachineName == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto ErrorOut;
        }

        ulBufLen = lstrlen(pCounter->szMachineName) + lstrlen(pszPath) + 1;

        pszFullPath = new WCHAR [ ulBufLen];

        if (pszFullPath == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorOut;
        }
        StringCchCopy(pszFullPath, ulBufLen, pCounter->szMachineName);
        StringCchCat(pszFullPath, ulBufLen, pszPath);

        lHashValue = HashCounter(pszFullPath);
    }

    pEntry = m_HashTable[lHashValue];

    //
    // Check if there is a counter path which is exactly the same
    // as the given one
    //
    while (pEntry) {
        if (pEntry->pCounter == pCounter) 
            break;
        pPrev = pEntry;
        pEntry = pEntry->pNext;
    }

    //
    // If we found it, remove it
    //
    if (pEntry) {
        if (pPrev == NULL) {
            m_HashTable[lHashValue] = pEntry->pNext;
        }
        else {
            pPrev->pNext = pEntry->pNext;
        }
        assert (pEntry->pCounter);
        delete(pEntry->pCounter);
        delete(pEntry);

        bReturn = TRUE;
    }

ErrorOut:
    if (pszFullPath != NULL) {
        delete [] pszFullPath;
    }

    return bReturn;
}


//++
// Description:
//    Insert a counter path into hash table. 
//
// Parameters:
//    PItemInfo - Pointer to the counter item info
//
// Return:
//    Return the pointer to new inserted PDH_COUNTER_PATH_ELEMENTS structure
//--

DWORD
CCounterPropPage::InsertCounterToHashTable(
    LPWSTR pszPath,
    PPDH_COUNTER_PATH_ELEMENTS* ppCounter
    )
{
    ULONG       lHashValue;
    PHASH_ENTRY pEntry  = NULL;
    PHASH_ENTRY pPrev  = NULL;
    PDH_STATUS  pdhStatus;
    ULONG       ulBufSize = 0;
    PPDH_COUNTER_PATH_ELEMENTS pCounter = NULL;
    LPWSTR      pszFullPath = NULL;
    BOOL        bExisted = FALSE;
    DWORD       dwResult;

    dwResult = ERROR_SUCCESS;

    if (pszPath == NULL || ppCounter == NULL) {
        dwResult = ERROR_INVALID_PARAMETER;
        goto ErrorOut;
    }

    *ppCounter = NULL;

    //
    // Parse the counter path
    //
    pCounter = NULL;
    do {
        if (pCounter) {
            delete [] (char*)pCounter;
            pCounter = NULL;
        }
        else {
            ulBufSize = sizeof(PDH_COUNTER_PATH_ELEMENTS) + sizeof(WCHAR) * PDH_MAX_COUNTER_PATH;
        }

        pCounter = (PPDH_COUNTER_PATH_ELEMENTS) new char [ ulBufSize ];

        if (pCounter == NULL) {
            dwResult = ERROR_OUTOFMEMORY;
            goto ErrorOut;
        }

        pdhStatus = PdhParseCounterPath( pszPath, pCounter, & ulBufSize, 0);

    } while (pdhStatus == PDH_INSUFFICIENT_BUFFER || pdhStatus == PDH_MORE_DATA);

    if (pdhStatus != ERROR_SUCCESS) {
        dwResult = pdhStatus;
        goto ErrorOut;
    }

    //
    // If the counter path does not have machine name,
    // add the machine name to compose a full path
    //
    if (*pszPath == L'\\' && (*(pszPath+1) == L'\\') ) {
        lHashValue = HashCounter(pszPath);
    }
    else {
        ULONG ulBufLen;

        ulBufLen = lstrlen(pCounter->szMachineName) + lstrlen(pszPath) + 1;
        pszFullPath =  new WCHAR [ulBufLen];

        if (pszFullPath == NULL) {
            dwResult = ERROR_OUTOFMEMORY;
            goto ErrorOut;
        }
        StringCchCopy(pszFullPath, ulBufLen, pCounter->szMachineName);
        StringCchCat(pszFullPath, ulBufLen, pszPath);

        lHashValue = HashCounter(pszFullPath);
    }

    //
    // Check if there is a counter path which is exactly the same
    // as the given one
    //
    pEntry = m_HashTable[lHashValue];

    while (pEntry) {
        if ( AreSameCounterPath ( pEntry->pCounter, pCounter ) ) {
            dwResult = SMON_STATUS_DUPL_COUNTER_PATH;
            bExisted = TRUE;
            *ppCounter = pEntry->pCounter;
            break;
        }

        pPrev = pEntry;
        pEntry = pEntry->pNext;
    }

    //
    // Add the new counter path
    //
    if (bExisted == FALSE) {
        pEntry = (PHASH_ENTRY) new HASH_ENTRY;
        if (pEntry == NULL) {
            dwResult = ERROR_OUTOFMEMORY;
            goto ErrorOut;
        }

        pEntry->pCounter = pCounter;
        pEntry->pNext = m_HashTable[lHashValue];
        m_HashTable[lHashValue] = pEntry;
        *ppCounter = pCounter;
    }

    if (pszFullPath != NULL) {
        delete [] pszFullPath;
    }
    return dwResult;

ErrorOut:
    if (pszFullPath != NULL) {
        delete [] pszFullPath;
    }

    if (pCounter != NULL) {
        delete [] ((char*) pCounter);
    }

    return dwResult;
}



//++
// Description:
//    The function clears all the entries in hash table
//    and set hash-table-not-set-up flag
//
// Parameters:
//    None
//
// Return:
//    None
//--
void 
CCounterPropPage::ClearCountersHashTable( void )
{
    ULONG       i;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNext;

    if (m_fHashTableSetup) {
        for (i = 0; i < eHashTableSize; i ++) {
            pNext = m_HashTable[i];
            while (pNext != NULL) {
                pEntry = pNext;
                pNext  = pEntry->pNext;

                assert( pEntry->pCounter);

                delete pEntry->pCounter; 
                delete (pEntry);
            }
        }
    }
    else {
        memset(&m_HashTable, 0, sizeof(m_HashTable));
    }
    m_fHashTableSetup = FALSE;
}

void CCounterPropPage::DeleteInfo(PItemInfo pInfo)
{
    if (pInfo == NULL) {
        return;
    }

    if (pInfo->pszPath != NULL) {
        delete (pInfo->pszPath);
    }
    if ( pInfo->pItem != NULL ) {
        pInfo->pItem->Release();
    }

    delete pInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ctrldll.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ctrldll.cpp

Abstract:

    DLL methods, class factory.

--*/

#define INITGUIDS
#define DEFINE_GLOBALS

#include "polyline.h"
#include <servprov.h>
#include <exdisp.h>
#include <shlguid.h>
#include <urlmon.h>
#include "smonctrl.h"   // For version numbers
#include "genprop.h"
#include "ctrprop.h"
#include "grphprop.h"
#include "srcprop.h"
#include "appearprop.h"
#include "unihelpr.h"
#include "unkhlpr.h"
#include "appmema.h"
#include "globals.h"


ITypeLib *g_pITypeLib;
DWORD     g_dwScriptPolicy = URLPOLICY_ALLOW;

BOOL DLLAttach ( HINSTANCE );
VOID DLLDetach ( VOID );

extern HWND CreateFosterWnd( VOID );

BOOL WINAPI 
DllMain (
    IN HINSTANCE hInstance, 
    IN ULONG ulReason,
    IN LPVOID // pvReserved
    )
/*++

Routine Description:

    DllMain is the main entrypoint of the DLL. On a process attach, it calls
    the DLL initialization routine. On process detach, it calls the clean up
    routine.
     
Arguments:

    hInstance - DLL instance handle
    ulReason - Calling reason (DLL_PROCESS_ATTCH, DLL_PROCESS_DETACH, etc.)
    pvReserved - Not used

Return Value:

    Boolean result - TRUE = success, FALSE = failure 

--*/
{
    BOOL fReturn = TRUE;

    switch (ulReason) 
    {
        case DLL_PROCESS_ATTACH:
            fReturn = DLLAttach(hInstance);
            break;

        case DLL_PROCESS_DETACH:
            DLLDetach();
            break;

        default:
            break;
    } 

    return fReturn;
}



BOOL
DLLAttach (
    IN HINSTANCE hInst
    )
/*++

Routine Description:

    DLLAttach initializes global variables and objects, and loads the type library. 
    It saves the DLL instance handle in global variable, g_hInstance.

Arguments:
    
    hInst - DLL instance handle

Return Value:

    Boolean status - TRUE = success

--*/
{
    HRESULT hr = S_OK;

    g_hInstance = hInst;

    //
    // Initialize general purpose critical section
    //
    try {
        InitializeCriticalSection(&g_CriticalSection);
    } catch (...) {
        hr = E_OUTOFMEMORY;
    }

    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    //
    // Create foster window
    //
    g_hWndFoster = CreateFosterWnd();
    if (g_hWndFoster == NULL) {
        return FALSE;
    }

    //
    // Try loading type library from registry
    //
    hr = LoadRegTypeLib(LIBID_SystemMonitor, 
                        SMONCTRL_MAJ_VERSION, 
                        SMONCTRL_MIN_VERSION, 
                        LANG_NEUTRAL, 
                        &g_pITypeLib);

    //
    // If failed, try loading our typelib resource
    //
    if (FAILED(hr)) {
        LPWSTR szModule = NULL;
        UINT   iModuleLen;
        DWORD  dwReturn;
        int    iRetry = 4;

        //
        // The length initialized to iModuleLen must be longer
        // than the length of "%systemroot%\\system32\\sysmon.ocx"
        //
        iModuleLen = MAX_PATH + 1;

        do {
            szModule = (LPWSTR) malloc(iModuleLen * sizeof(WCHAR));
            if (szModule == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            //
            // Something wrong, break out
            //
            dwReturn = GetModuleFileName(g_hInstance, szModule, iModuleLen);
            if (dwReturn == 0) {
                hr = E_FAIL;
                break;
            }

            //
            // The buffer is not big enough, try to allocate a biggers one
            // and retry
            //
            if (dwReturn >= iModuleLen) {
                iModuleLen *= 2;
                free(szModule);
                szModule = NULL;
                hr = E_FAIL;
            }
            else {
                hr = S_OK;
                break;
            }

            iRetry --;

        } while (iRetry);

        if (SUCCEEDED(hr)) {
            hr = LoadTypeLib(szModule, &g_pITypeLib);
        }
        if (szModule) {
            free(szModule);
        }
    }
    
    if (FAILED(hr)) {
        return FALSE;
    }

    //
    // Initialize the perf counters
    //
    AppPerfOpen(hInst);

    return TRUE;
}


VOID 
DLLDetach ( 
    VOID
    )
/*++

Routine Description:

    This routine deletes global variables and objects and unregisters
    all of the window classes.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT i;

    //
    // Delete the foster window
    //
    if (g_hWndFoster) {
        DestroyWindow(g_hWndFoster);
    }

    //
    // Unregister all window classes
    // 
    for (i = 0; i < MAX_WINDOW_CLASSES; i++) {
        if (pstrRegisteredClasses[i] != NULL) {
            UnregisterClass(pstrRegisteredClasses[i], g_hInstance);
        }
    }

    //
    // Release the typelib 
    //
    if (g_pITypeLib != NULL) {
        g_pITypeLib->Release();
    }

    //
    // Delete general purpose critical section
    //
    DeleteCriticalSection(&g_CriticalSection);

    AppPerfClose ((HINSTANCE)NULL);
}


/*
 * DllGetClassObject
 *
 * Purpose:
 *  Provides an IClassFactory for a given CLSID that this DLL is
 *  registered to support.  This DLL is placed under the CLSID
 *  in the registration database as the InProcServer.
 *
 * Parameters:
 *  clsID           REFCLSID that identifies the class factory
 *                  desired.  Since this parameter is passed this
 *                  DLL can handle any number of objects simply
 *                  by returning different class factories here
 *                  for different CLSIDs.
 *
 *  riid            REFIID specifying the interface the caller wants
 *                  on the class object, usually IID_ClassFactory.
 *
 *  ppv             PPVOID in which to return the interface
 *                  pointer.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, otherwise an error code.
 */

HRESULT APIENTRY 
DllGetClassObject (
    IN  REFCLSID rclsid,
    IN  REFIID riid, 
    OUT PPVOID ppv
    )
/*++

Routine Description:

    DllGetClassObject creates a class factory for the specified object class.
    The routine handles the primary control and the property pages.

Arguments:

    rclsid - CLSID of object 
    riid - IID of requested interface (IID_IUNknown or IID_IClassFactory)
    ppv -  Pointer to returned interface pointer

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;

        //
        // Check for valid interface request
        //
        if (IID_IUnknown != riid && IID_IClassFactory != riid) {
            hr = E_NOINTERFACE;
        }

        if (SUCCEEDED(hr)) {
            //
            // Create class factory for request class
            //
            if (CLSID_SystemMonitor == rclsid)
                *ppv = new CPolylineClassFactory;
            else if (CLSID_GeneralPropPage == rclsid)
                *ppv = new CSysmonPropPageFactory(GENERAL_PROPPAGE);
            else if (CLSID_SourcePropPage == rclsid)
                *ppv = new CSysmonPropPageFactory(SOURCE_PROPPAGE);
            else if (CLSID_CounterPropPage == rclsid)
                *ppv = new CSysmonPropPageFactory(COUNTER_PROPPAGE);
            else if (CLSID_GraphPropPage == rclsid)
                *ppv = new CSysmonPropPageFactory(GRAPH_PROPPAGE);
            else if (CLSID_AppearPropPage == rclsid)
                *ppv = new CSysmonPropPageFactory(APPEAR_PROPPAGE);
            else 
                hr = E_NOINTERFACE;
             
            if (*ppv) {
                ((LPUNKNOWN)*ppv)->AddRef();
            }
            else {
                hr = E_OUTOFMEMORY;
            }
        }

    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDAPI 
DllCanUnloadNow (
    VOID
    )
/*++

Routine Description:

    DllCanUnload determines whether the DLL can be unloaded now. The DLL must
    remain active if any objects exist or any class factories are locked.  

Arguments:

    None.

Return Value:

    HRESULT - S_OK if OK to unload, S_FALSE if not

--*/
{
    //
    // OK to unload if no locks or objects
    //
    return (0L == g_cObj && 0L == g_cLock) ? S_OK : S_FALSE;
}


VOID 
ObjectDestroyed (
    VOID
    )
/*++

Routine Description:

    ObjectDestroyed decrements the global object count. It is called whenever
    an object is destroyed. The count controls the lifetme of the DLL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    InterlockedDecrement(&g_cObj);
}


//---------------------------------------------------------------------------
// Class factory constructor & destructor
//---------------------------------------------------------------------------

/*
 * CPolylineClassFactory::CPolylineClassFactory
 *
 * Purpose:
 *  Constructor for an object supporting an IClassFactory that
 *  instantiates Polyline objects.
 *
 * Parameters:
 *  None
 */

CPolylineClassFactory::CPolylineClassFactory (
    VOID
    )
{
    m_cRef = 0L;
}


/*
 * CPolylineClassFactory::~CPolylineClassFactory
 *
 * Purpose:
 *  Destructor for a CPolylineClassFactory object.  This will be
 *  called when we Release the object to a zero reference count.
 */

CPolylineClassFactory::~CPolylineClassFactory (
    VOID
    )
{
}


//---------------------------------------------------------------------------
// Standard IUnknown implementation for class factory
//---------------------------------------------------------------------------

STDMETHODIMP 
CPolylineClassFactory::QueryInterface (
    IN  REFIID riid,
    OUT PPVOID ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;
        if (IID_IUnknown == riid || IID_IClassFactory == riid) {
            *ppv = this;
            AddRef();
        } 
        else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG) 
CPolylineClassFactory::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) 
CPolylineClassFactory::Release (
    VOID
    )
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


STDMETHODIMP 
CPolylineClassFactory::CreateInstance (
    IN  LPUNKNOWN pUnkOuter, 
    IN  REFIID riid, 
    OUT PPVOID ppvObj
    )
/*++

Routine Description:

    CreateInstance creates an instance of the control object and returns
    the requested interface to it.

Arguments:

    pUnkOuter - IUnknown of outer controling object
    riid - IID of requested object interface
    ppvObj - Pointer to returned interface pointer

Return Value:

   HRESULT - NOERROR, E_NOINTERFACE, or E_OUTOFMEMORY

--*/
{
    PCPolyline  pObj;
    HRESULT     hr = S_OK;
    
    if (ppvObj == NULL) {
        return E_POINTER;
    }

    try {
        *ppvObj = NULL;

        //
        // We use do {} while(0) here to act like a switch statement
        //
        do {
            //
            // Verify that a controlling unknown asks for IUnknown
            //
            if (NULL != pUnkOuter && IID_IUnknown != riid) {
                hr = E_NOINTERFACE;
                break;
            }

            //
            // Create the object instance
            //
            pObj = new CPolyline(pUnkOuter, ObjectDestroyed);
            if (NULL == pObj) {
                hr = E_OUTOFMEMORY;
                break;
            }
    
            //
            // Initialize and get the requested interface
            //
            if (pObj->Init()) {
                hr = pObj->QueryInterface(riid, ppvObj);
            }
            else {
                hr = E_FAIL;
            }

            //
            // Delete object if initialization failed
            // Otherwise increment gloabl object count
            //
            if (FAILED(hr)) {
                delete pObj;
            }
            else {
                InterlockedIncrement(&g_cObj);
            }

        } while (0);

    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



STDMETHODIMP 
CPolylineClassFactory::LockServer (
    IN BOOL fLock
    )
/*++

Routine Description:

    LockServer increments or decrements the DLL lock count. A non-zero lock
    count prevents the DLL from unloading.

Arguments:

    fLock - Lock operation (TRUE = increment, FALSE = decrement)

Return Value:

    HRESULT - Always NOERROR

--*/
{
    if (fLock) {
        InterlockedIncrement(&g_cLock);
    }
    else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//
// CImpIObjectSafety interface implmentation
//
IMPLEMENT_CONTAINED_IUNKNOWN(CImpIObjectSafety);


CImpIObjectSafety::CImpIObjectSafety(PCPolyline pObj, LPUNKNOWN pUnkOuter)
    :
    m_cRef(0),
    m_pObj(pObj),
    m_pUnkOuter(pUnkOuter),
    m_fMessageDisplayed(FALSE)
{
}

CImpIObjectSafety::~CImpIObjectSafety()
{
}

STDMETHODIMP 
CImpIObjectSafety::GetInterfaceSafetyOptions(
    REFIID riid, 
    DWORD *pdwSupportedOptions, 
    DWORD *pdwEnabledOptions
    )
/*++

Routine Description:

    Retrieve the safety capability of object

Arguments:

    riid - Interface ID to retrieve

    pdwSupportedOptions - The options the object knows about(might not support)

    pdwEnabledOptions - The options the object supports

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL) {
        return E_POINTER;
    }

    if (riid == IID_IDispatch) {
        //
        // Safe for scripting
        //
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions   = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag || riid == IID_IPersistStreamInit) {
        //
        // Safety for initializing
        //
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions   = INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else {
        //
        // We don't support interfaces, fail out
        //
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions   = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


STDMETHODIMP 
CImpIObjectSafety::SetInterfaceSafetyOptions(
    REFIID riid, 
    DWORD dwOptionSetMask, 
    DWORD dwEnabledOptions
    )
/*++

Routine Description:

    The function is used for container to ask an object if it is safe
    for scripting or safe for initialization

Arguments:

    riid - Interface ID to query

    dwSupportedOptions - The options the object knows about(might not support)

    dwEnabledOptions - The options the object supports

Return Value:

    HRESULT

--*/
{   
    //
    // If we're being asked to set our safe for scripting or
    // safe for initialization options then oblige
    //
    if (0 == dwOptionSetMask && 0 == dwEnabledOptions)
    {
        //
        // the control certainly supports NO requests through the specified interface
        // so it's safe to return S_OK even if the interface isn't supported.
        //
        return S_OK;
    }

    SetupSecurityPolicy();

    if (riid == IID_IDispatch)
    {
        //
        // Client is asking if it is safe to call through IDispatch
        //
        if (INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwOptionSetMask && 
            INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwEnabledOptions)
        {
            return S_OK;
        }
    }
    else if (riid == IID_IPersistPropertyBag || riid == IID_IPersistStreamInit)
    {
        //
        // Client is asking if it's safe to call through IPersistXXX
        //
        if (INTERFACESAFE_FOR_UNTRUSTED_DATA == dwOptionSetMask && 
            INTERFACESAFE_FOR_UNTRUSTED_DATA == dwEnabledOptions)
        {
            return S_OK;
        }
    }

    return E_FAIL;
}


VOID
CImpIObjectSafety::SetupSecurityPolicy()
/*++

Routine Description:

    The function check if we are safe for scripting.

Arguments:

    None

Return Value:

    Return TRUE if we are safe for scripting, othewise return FALSE

--*/
{
    HRESULT hr;
    IServiceProvider* pSrvProvider = NULL;
    IWebBrowser2* pWebBrowser = NULL;
    IInternetSecurityManager* pISM = NULL;
    BSTR bstrURL;
    DWORD dwContext = 0;

    g_dwScriptPolicy = URLPOLICY_ALLOW;

    //
    // Get the service provider
    //
    hr = m_pObj->m_pIOleClientSite->QueryInterface(IID_IServiceProvider, (void **)&pSrvProvider);
    if (SUCCEEDED(hr)) {
        hr = pSrvProvider->QueryService(SID_SWebBrowserApp,
                                        IID_IWebBrowser2,
                                        (void **)&pWebBrowser);
    }

    if (SUCCEEDED(hr)) {
        hr = pSrvProvider->QueryService(SID_SInternetSecurityManager,
                                        IID_IInternetSecurityManager,
                                        (void**)&pISM);
    }

    if (SUCCEEDED(hr)) {
        hr = pWebBrowser->get_LocationURL(&bstrURL);
    }


    //
    // Querying safe for scripting 
    //
    if (SUCCEEDED(hr)) {
        hr = pISM->ProcessUrlAction(bstrURL,
                                URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY,
                                (BYTE*)&g_dwScriptPolicy,
                                sizeof(g_dwScriptPolicy),
                                (BYTE*)&dwContext, 
                                sizeof(dwContext),
                                PUAF_NOUI, 
                                0);
    }

    if (SUCCEEDED(hr)) {
        if (g_dwScriptPolicy == URLPOLICY_QUERY) {
            g_dwScriptPolicy = URLPOLICY_ALLOW;
        }

        if (g_dwScriptPolicy == URLPOLICY_DISALLOW) {
            if (!m_fMessageDisplayed) {
                m_fMessageDisplayed = TRUE;
                MessageBox(NULL, 
                          ResourceString(IDS_SCRIPT_NOT_ALLOWED),
                          ResourceString(IDS_APP_NAME), 
                          MB_OK);
            }
        }
    }
    
    if (pWebBrowser) {
        pWebBrowser->Release();
    }
    if (pSrvProvider) {
        pSrvProvider->Release();
    }
    if (pISM) {
        pISM->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ctrprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ctrprop.h

Abstract:

    Header file for the counter date property page

--*/

#ifndef _CTRPROP_H_
#define _CTRPROP_H_

#include "smonprop.h"
#include "visuals.h"


// Property Page Dialog IDs
#define IDD_CTR_PROPP_DLG           200
#define IDC_CTRLIST                 201
#define IDC_ADDCTR                  202
#define IDC_DELCTR                  203
#define IDC_ADDCTR_TEXT             204
#define IDC_LINECOLOR               205
#define IDC_LINESCALE               206
#define IDC_LINEWIDTH               207
#define IDC_LINESTYLE               208
#define IDC_LABEL_LINECOLOR         209
#define IDC_LABEL_LINESCALE         210
#define IDC_LABEL_LINEWIDTH         211
#define IDC_LABEL_LINESTYLE         212

typedef struct _ItemProps
{
    // Combo box indices
    INT         iColorIndex;
    INT         iStyleIndex;
    INT         iScaleIndex;
    INT         iWidthIndex;
    // Custom color
    COLORREF    rgbColor;
} ItemProps;

typedef struct _ItemInfo
{
    struct _ItemInfo * pNextInfo;
    ICounterItem *     pItem;
    LPWSTR             pszPath;
    BOOL               fLoaded:1,
                       fChanged:1,
                       fAdded:1;
    ItemProps          Props;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;
} ItemInfo, *PItemInfo;

class CCounterPropPage : public CSysmonPropPage
{
    friend static HRESULT AddCallback (
        LPWSTR  pszPathName,
        DWORD_PTR lpUserData,
        DWORD   dwFlags
    );

    public:
                CCounterPropPage(void);
        virtual ~CCounterPropPage(void);

    protected:
        virtual BOOL GetProperties(void);   //Read current options
        virtual BOOL SetProperties(void);   //Set new options
        virtual void DeinitControls(void);       // Deinitialize dialog controls

        virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual void MeasureItem(PMEASUREITEMSTRUCT); // Handle user measure req
        virtual void DrawItem(PDRAWITEMSTRUCT);  // Handle user draw req
        virtual HRESULT EditPropertyImpl( DISPID dispID);   // Set focus to control      
    
    private:

        void    DeleteInfo(PItemInfo pInfo);
        void    SetStyleComboEnable();      // Enable/disable based on current width value
        void    InitDialog(void);
        void    AddCounters(void);
        HRESULT NewItem(LPWSTR pszPath, DWORD dwFlags);
        INT     AddItemToList(PItemInfo pInfo);
        void    DeleteItem();
        void    LoadItemProps(PItemInfo pInfo);
        void    DisplayItemProps(PItemInfo pInfo);
        void    SelectItem(INT iItem);
        INT     SelectMatchingItem(INT iColor, COLORREF rgbCustomColor, INT iWidth, INT iStyle);

        INT     ScaleFactorToIndex ( INT iScaleFactor );
        INT     IndexToScaleFactor ( INT iScaleIndex );

		void	IncrementLocalVisuals ( void );
		void	SetModifiedSelectedVisuals ( BOOL bModified = TRUE ) { m_bAreModSelectedVisuals = bModified; };
		BOOL	AreModifiedSelectedVisuals ( void ){ return m_bAreModSelectedVisuals; };


    private:
        PItemInfo   m_pInfoSel;
        PItemInfo   m_pInfoDeleted;
        ItemProps   m_props;
        INT         m_iAddIndex;
        DWORD       m_dwMaxHorizListExtent;     
        BOOL        m_bAreModSelectedVisuals;

        PDH_BROWSE_DLG_CONFIG   m_BrowseInfo;

        enum eValueRange {
            eHashTableSize = 257
        };
        typedef struct _HASH_ENTRY {
            struct _HASH_ENTRY* pNext;
            PPDH_COUNTER_PATH_ELEMENTS pCounter;
        } HASH_ENTRY, *PHASH_ENTRY;

        PHASH_ENTRY  m_HashTable[257];
        BOOL  m_fHashTableSetup;
        INT   m_nLastSelCount;

        ULONG HashCounter ( LPWSTR szCounterName );
public:

    BOOL  RemoveCounterFromHashTable( LPWSTR pszPath, PPDH_COUNTER_PATH_ELEMENTS pCounter);
    void  InitializeHashTable( void );
    void  ClearCountersHashTable ( void );
    DWORD InsertCounterToHashTable ( LPWSTR pszPath, PPDH_COUNTER_PATH_ELEMENTS* ppCounter );

};
typedef CCounterPropPage *PCCounterPropPage;

DEFINE_GUID(CLSID_CounterPropPage,
            0xcf948561, 0xede8, 0x11ce, 0x94, 0x1e, 0x0, 0x80, 0x29, 0x0, 0x43, 0x47);

#endif //_CTRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\globals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    globals.h

Abstract:

    <abstract>

--*/

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#ifdef DEFINE_GLOBALS
  #define GLOBAL   
#else
  #define GLOBAL extern
#endif

GLOBAL  CRITICAL_SECTION	g_CriticalSection;
#define BEGIN_CRITICAL_SECTION	EnterCriticalSection(&g_CriticalSection);
#define END_CRITICAL_SECTION	LeaveCriticalSection(&g_CriticalSection);

GLOBAL  HINSTANCE   g_hInstance;
GLOBAL	LONG		g_cObj;
GLOBAL	LONG		g_cLock;
GLOBAL	 HWND		g_hWndFoster ;
	
enum {
	FOSTER_WNDCLASS = 0,
	HATCH_WNDCLASS,
	SYSMONCTRL_WNDCLASS,
	LEGEND_WNDCLASS,
    REPORT_WNDCLASS,
	INTRVBAR_WNDCLASS,
	TIMERANGE_WNDCLASS
};

#define MAX_WINDOW_CLASSES  7

GLOBAL	 LPWSTR	  pstrRegisteredClasses[MAX_WINDOW_CLASSES];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\dispatch.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    dispatch.cpp

Abstract:

    <abstract>

--*/

#include "polyline.h"
#include "unkhlpr.h"

extern ITypeLib    *g_pITypeLib;
extern DWORD        g_dwScriptPolicy;

//IDispatch interface implementation
IMPLEMENT_CONTAINED_INTERFACE(IUnknown, CImpIDispatch)

/*
 * CImpIDispatch::GetTypeInfoCount
 * CImpIDispatch::GetTypeInfo
 * CImpIDispatch::GetIDsOfNames
 *
 * The usual
 */

void CImpIDispatch::SetInterface(REFIID riid, LPUNKNOWN pIUnk)
{
    m_DIID = riid;
    m_pInterface = pIUnk;
}

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    HRESULT hr = S_OK;

    if (pctInfo == NULL) {
        return E_POINTER;
    }

    //
    //We implement GetTypeInfo so return 1
    //
    try {
        *pctInfo = 1;
    } catch (...) {
        hr = E_POINTER;
    }

    return S_OK;
}


STDMETHODIMP CImpIDispatch::GetTypeInfo(
    UINT itInfo, 
    LCID,/* lcid */ 
    ITypeInfo **ppITypeInfo
    )
{
    HRESULT hr = S_OK;

    if (0 != itInfo) {
        return TYPE_E_ELEMENTNOTFOUND;
    }
    if (NULL == ppITypeInfo) {
        return E_POINTER;
    }

    try {
        *ppITypeInfo=NULL;

        //
        //We ignore the LCID
        //
        hr = g_pITypeLib->GetTypeInfoOfGuid(m_DIID, ppITypeInfo);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP CImpIDispatch::GetIDsOfNames(
    REFIID riid, 
    OLECHAR **rgszNames, 
    UINT cNames, 
    LCID lcid, 
    DISPID *rgDispID
    )
{
    HRESULT     hr = S_OK;
    ITypeInfo  *pTI = NULL;

    if (IID_NULL != riid) {
        return DISP_E_UNKNOWNINTERFACE;
    }

    hr = GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        try {
            hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
        } catch (...) {
            hr = E_POINTER;
        }
    }

    if (pTI) {
        pTI->Release();
    }

    return hr;
}



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::Invoke(
    DISPID dispID, 
    REFIID riid, 
    LCID lcid, 
    unsigned short wFlags, 
    DISPPARAMS *pDispParams, 
    VARIANT *pVarResult, 
    EXCEPINFO *pExcepInfo, 
    UINT *puArgErr
    )
{
    HRESULT    hr = S_OK;
    ITypeInfo *pTI = NULL;

    //riid is supposed to be IID_NULL always
    if (IID_NULL != riid) {
        return DISP_E_UNKNOWNINTERFACE;
    }

    if (g_dwScriptPolicy == URLPOLICY_DISALLOW) {

        if (m_DIID == DIID_DISystemMonitor)
            return E_ACCESSDENIED;
    }

    // if dispatching to the graph control, use our internal interface
    // that is generated from the direct interface (see smonctrl.odl)
    if (m_DIID == DIID_DISystemMonitor) {
        hr = g_pITypeLib->GetTypeInfoOfGuid(DIID_DISystemMonitorInternal, &pTI);
    }
    else {
        hr = GetTypeInfo(0, lcid, &pTI);
    }

    if (SUCCEEDED(hr)) {
        try {
            hr = pTI->Invoke(m_pInterface, 
                            dispID, 
                            wFlags, 
                            pDispParams, 
                            pVarResult, 
                            pExcepInfo, 
                            puArgErr);
        } catch (...) {
            hr = E_POINTER;
        }

        if (pTI) {
            pTI->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\genprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    genprop.h

Abstract:

    Header file for the general property page.

--*/

#ifndef _GENPROP_H_
#define _GENPROP_H_

#include "smonprop.h"

// Dialog Controls
#define IDD_GEN_PROPP_DLG       100
#define IDC_LEGEND              101
#define IDC_VALUEBAR            102
#define IDC_GALLERY_GRAPH       103
#define IDC_GALLERY_HISTOGRAM   (IDC_GALLERY_GRAPH+1)
#define IDC_GALLERY_REPORT      (IDC_GALLERY_HISTOGRAM+1)
#define IDC_PERIODIC_UPDATE     106
#define IDC_UPDATE_INTERVAL     107
#define IDC_INTERVAL_LABEL      108
#define IDC_TOOLBAR             109
#define IDC_APPEARANCE          110
#define IDC_BORDERSTYLE         111
#define IDC_COMBOAPPEARANCE     112
#define IDC_COMBOBORDERSTYLE    113
#define IDC_GROUPUPDATE         114
#define IDC_DUPLICATE_INSTANCE  115
#define IDC_GROUPREPORTVALUE    116
#define IDC_DISPLAY_INTERVAL    117
#define IDC_DISPLAY_INT_LABEL1  118
#define IDC_DISPLAY_INT_LABEL2  119

#define IDC_RPT_VALUE_DEFAULT   120
#define IDC_RPT_VALUE_CURRENT   (IDC_RPT_VALUE_DEFAULT+1)
#define IDC_RPT_VALUE_AVERAGE   (IDC_RPT_VALUE_CURRENT+1)
#define IDC_RPT_VALUE_MINIMUM   (IDC_RPT_VALUE_AVERAGE+1)
#define IDC_RPT_VALUE_MAXIMUM   (IDC_RPT_VALUE_MINIMUM+1)

#define MAX_INTERVAL_DIGITS 7
// MAX_UPDATE_INTERVAL is 45 days (60*60*24*45)
#define MAX_UPDATE_INTERVAL 3888000 
#define MIN_UPDATE_INTERVAL 1

// General property page class
class CGeneralPropPage : public CSysmonPropPage
{
    public:
                CGeneralPropPage(void);
        virtual ~CGeneralPropPage(void);

    protected:

        virtual BOOL GetProperties(void);   //Read current properties
        virtual BOOL SetProperties(void);   //Set new properties
        virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual BOOL InitControls(void);   // Init dialog controls  

    private:

        // Properties
        VARIANT_BOOL            m_bLegend ;
        VARIANT_BOOL            m_bValueBar ;
        VARIANT_BOOL            m_bToolbar;
        VARIANT_BOOL            m_bManualUpdate;
        VARIANT_BOOL            m_bMonitorDuplicateInstances ;
        INT                     m_iDisplayInterval ;
        INT                     m_iAppearance;
        INT                     m_iBorderStyle;
        DisplayTypeConstants    m_eDisplayType ;
        ReportValueTypeConstants    m_eReportValueType ;
        FLOAT                   m_fSampleInterval ;

        // Property change flags
        BOOL    m_bLegendChg ;
        BOOL    m_bToolbarChg;
        BOOL    m_bValueBarChg ;
        BOOL    m_bManualUpdateChg;
        BOOL    m_bSampleIntervalChg ;
        BOOL    m_bDisplayIntervalChg ;
        BOOL    m_bDisplayTypeChg ;
        BOOL    m_bReportValueTypeChg ;
        BOOL    m_bAppearanceChg;
        BOOL    m_bBorderStyleChg;
        BOOL    m_bMonitorDuplicateInstancesChg;

        // Error flags
        INT     m_iErrSampleInterval;
        INT     m_iErrDisplayInterval;


};
typedef CGeneralPropPage *PCGeneralPropPage;

// {C3E5D3D2-1A03-11cf-942D-008029004347}
DEFINE_GUID(CLSID_GeneralPropPage, 
        0xc3e5d3d2, 0x1a03, 0x11cf, 0x94, 0x2d, 0x0, 0x80, 0x29, 0x0, 0x43, 0x47);

#endif //_GENPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\genprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    genprop.cpp

Abstract:

    <abstract>

--*/

#include "polyline.h"
#include <strsafe.h>
#include <assert.h>
#include "genprop.h"
#include "utils.h"
#include "strids.h"
#include "smonctrl.h"
#include "winhelpr.h"

CGeneralPropPage::CGeneralPropPage ( void )
/*++

Routine Description:

    Constructor for CGeneralPropPage class. Initializes the member variables.
     
Arguments:

    None.

Return Value:

    None.

--*/
{
    m_uIDDialog = IDD_GEN_PROPP_DLG;
    m_uIDTitle = IDS_GEN_PROPP_TITLE;
    return;
}

CGeneralPropPage::~CGeneralPropPage (
    VOID
    )
/*++

Routine Description:

    Destructor for CGeneralPropPage class. .
     
Arguments:

    None.

Return Value:

    None.

--*/
{
    return;
}

BOOL
CGeneralPropPage::InitControls(
    VOID
    )
{
    HWND    hWndItem = NULL;

    hWndItem = GetDlgItem(m_hDlg, IDC_UPDATE_INTERVAL);
    if ( NULL != hWndItem ) {
        EditSetLimit(hWndItem, MAX_INTERVAL_DIGITS);
        hWndItem = NULL;
    }
    hWndItem = DialogControl (m_hDlg, IDC_COMBOAPPEARANCE) ;
    if ( NULL != hWndItem ) {
        CBAdd (hWndItem, ResourceString(IDS_APPEARANCE_FLAT));
        CBSetData( hWndItem, 0, eAppearFlat );
        CBAdd (hWndItem, ResourceString(IDS_APPEARANCE_3D));
        CBSetData( hWndItem, 1, eAppear3D );
        hWndItem = NULL;
    }    
    hWndItem = DialogControl (m_hDlg, IDC_COMBOBORDERSTYLE) ;
    if ( NULL != hWndItem ) {
        CBAdd (hWndItem, ResourceString(IDS_BORDERSTYLE_NONE));
        CBSetData( hWndItem, 0, eBorderNone );
        CBAdd (hWndItem, ResourceString(IDS_BORDERSTYLE_SINGLE));
        CBSetData( hWndItem, 1, eBorderSingle );
        hWndItem = NULL;
    }

    return TRUE;
    //assert( IsWindowUnicode( m_hDlg ) );
    //assert( IsWindowUnicode( hWndItem ) );
}

BOOL 
CGeneralPropPage::GetProperties(
    VOID
    )
/*++

Routine Description:

    GetProperties fetches the selected graph's properties via the 
    ISystemMonitor interface and loads them into the property page dialog.
    It also clears all the propery change flags.

Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    WCHAR   szBuff[MAX_VALUE_LEN];
    ISystemMonitor  *pObj;
    INT iPrecision;
    HWND    hWndItem;

    // Make sure a control is selected
    if (m_cObjects == 0)
        return FALSE;
    
    // Use only the first one   
    pObj = m_ppISysmon[0];
    
    // Load each graph property
    pObj->get_DisplayType(&m_eDisplayType);
    CheckRadioButton(m_hDlg, IDC_GALLERY_GRAPH, IDC_GALLERY_REPORT,
                        IDC_GALLERY_GRAPH + m_eDisplayType - 1);

    pObj->get_ReportValueType(&m_eReportValueType);
    CheckRadioButton(m_hDlg, IDC_RPT_VALUE_DEFAULT, IDC_RPT_VALUE_MAXIMUM,
                        IDC_RPT_VALUE_DEFAULT + m_eReportValueType);

    pObj->get_ShowLegend(&m_bLegend) ;
    CheckDlgButton(m_hDlg, IDC_LEGEND, m_bLegend);
    
    pObj->get_ShowToolbar (&m_bToolbar);
    CheckDlgButton (m_hDlg, IDC_TOOLBAR, m_bToolbar);
    
    pObj->get_ShowValueBar(&m_bValueBar);
    CheckDlgButton(m_hDlg, IDC_VALUEBAR, m_bValueBar) ;

    pObj->get_MonitorDuplicateInstances(&m_bMonitorDuplicateInstances);
    CheckDlgButton(m_hDlg, IDC_DUPLICATE_INSTANCE, m_bMonitorDuplicateInstances) ;

    pObj->get_Appearance(&m_iAppearance);
    hWndItem = DialogControl (m_hDlg, IDC_COMBOAPPEARANCE) ;
    CBSetSelection (hWndItem, m_iAppearance) ;

    pObj->get_BorderStyle(&m_iBorderStyle);
    hWndItem = DialogControl (m_hDlg, IDC_COMBOBORDERSTYLE) ;
    CBSetSelection (hWndItem, m_iBorderStyle) ;

    pObj->get_UpdateInterval(&m_fSampleInterval);

    ((INT)(100 * m_fSampleInterval) != 100 * (INT)m_fSampleInterval) ? iPrecision = 2 : iPrecision = 0;

    FormatNumber ( m_fSampleInterval, szBuff, MAX_VALUE_LEN, 0, iPrecision );

    SetDlgItemText(m_hDlg, IDC_UPDATE_INTERVAL, szBuff) ;

    pObj->get_DisplayFilter(&m_iDisplayInterval);

    StringCchPrintf(szBuff, MAX_VALUE_LEN, L"%d", m_iDisplayInterval) ;
    SetDlgItemText(m_hDlg, IDC_DISPLAY_INTERVAL, szBuff) ;

    pObj->get_ManualUpdate(&m_bManualUpdate);
    CheckDlgButton (m_hDlg, IDC_PERIODIC_UPDATE, !m_bManualUpdate);

    // If manual update, disable sample (update) and display intervals 
    DialogEnable (m_hDlg, IDC_UPDATE_INTERVAL, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_INTERVAL_LABEL, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_DISPLAY_INTERVAL, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL1, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL2, !m_bManualUpdate) ;

    // Clear all change flags 
    m_bLegendChg = FALSE;
    m_bValueBarChg = FALSE;
    m_bToolbarChg = FALSE;
    m_bSampleIntervalChg = FALSE;
    m_bDisplayIntervalChg = FALSE;
    m_bDisplayTypeChg = FALSE;
    m_bReportValueTypeChg = FALSE;
    m_bManualUpdateChg = FALSE;
    m_bAppearanceChg = FALSE;
    m_bBorderStyleChg = FALSE;
    m_bMonitorDuplicateInstancesChg = FALSE;

    // Clear error flags
    m_iErrSampleInterval = 0;
    m_iErrDisplayInterval = 0;

    return TRUE;    
}


BOOL 
CGeneralPropPage::SetProperties (
    VOID
    )
/*++

Routine Description:

    SetProperties writes the changed graph properties to the selected control
    via the ISystemMonitor interface. It then resets all the change flags.
     
Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    ISystemMonitor  *pObj;
    
    // Make sure a control is selected
    if (m_cObjects == 0)
        return FALSE;

    // Use only the first control   
    pObj = m_ppISysmon[0];

    // Check for invalid data

    if ( !m_bManualUpdate ) {
        if ( m_iErrSampleInterval ) {
            MessageBox (m_hDlg, ResourceString(IDS_INTERVAL_ERR), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION) ;
            SetFocus ( GetDlgItem ( m_hDlg, IDC_UPDATE_INTERVAL ) );
            return FALSE;
        }
        if ( m_iErrDisplayInterval ) {
            MessageBox (m_hDlg, ResourceString(IDS_DISPLAY_INT_ERR), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION) ;
            SetFocus ( GetDlgItem ( m_hDlg, IDC_DISPLAY_INTERVAL ) );
            return FALSE;
        }
    }
    // Write each changed property to the control
    if (m_bLegendChg)
        pObj->put_ShowLegend(m_bLegend);

    if (m_bToolbarChg)
        pObj->put_ShowToolbar(m_bToolbar);

    if (m_bValueBarChg)
        pObj->put_ShowValueBar(m_bValueBar);

    if (m_bSampleIntervalChg)
        pObj->put_UpdateInterval(m_fSampleInterval);

    if (m_bDisplayIntervalChg) {
        pObj->put_DisplayFilter(m_iDisplayInterval);
    }

    if (m_bDisplayTypeChg)
        pObj->put_DisplayType(m_eDisplayType);

    if (m_bReportValueTypeChg)
        pObj->put_ReportValueType(m_eReportValueType);

    if (m_bManualUpdateChg)
        pObj->put_ManualUpdate(m_bManualUpdate);

    if (m_bAppearanceChg)
        pObj->put_Appearance(m_iAppearance);

    if (m_bBorderStyleChg)  
        pObj->put_BorderStyle(m_iBorderStyle);

    if (m_bMonitorDuplicateInstancesChg)
        pObj->put_MonitorDuplicateInstances(m_bMonitorDuplicateInstances);

    // Reset the change flags
    m_bLegendChg = FALSE;
    m_bValueBarChg = FALSE;
    m_bToolbarChg = FALSE;
    m_bSampleIntervalChg = FALSE;
    m_bDisplayIntervalChg = FALSE;
    m_bDisplayTypeChg = FALSE;
    m_bReportValueTypeChg = FALSE;
    m_bManualUpdateChg = FALSE;
    m_bAppearanceChg = FALSE;
    m_bBorderStyleChg = FALSE;
        
    return TRUE;    
}


VOID 
CGeneralPropPage::DialogItemChange (
    IN WORD wID, 
    IN WORD wMsg
    )
/*++

Routine Description:

    DialogItemChange handles changes to the property page dialog items. On
    each change it reads the new property value and set the property's change
    flag. On any change the SetChange routine is called to enable the "Apply"
    button.

Arguments:

    wID - Dialog item ID
    wMsg - Notification code

Return Value:

    None.

--*/
{
    BOOL fChange = FALSE;
    INT  iTemp;
    BOOL bStat = FALSE;
    HWND hWndItem;

    // Case on dialog item ID
    switch(wID) {

        case IDC_UPDATE_INTERVAL:

            // On change, set change flags
            // Wait until focus lost to read final value
            if (wMsg == EN_CHANGE) {

                fChange = TRUE;
                m_bSampleIntervalChg = TRUE;
            }
            else if (wMsg == EN_KILLFOCUS) {

                m_fSampleInterval = DialogFloat(m_hDlg, IDC_UPDATE_INTERVAL, &bStat) ;

                if (bStat && 
                     (m_fSampleInterval <= MAX_UPDATE_INTERVAL 
                        && m_fSampleInterval >= MIN_UPDATE_INTERVAL)) {
                    m_iErrSampleInterval = 0;
                } else {                
                    m_iErrSampleInterval = IDS_INTERVAL_ERR;
                }
            }
            break ;

        case IDC_DISPLAY_INTERVAL:

            // On change, set change flags
            // Wait until focus lost to read final value
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bDisplayIntervalChg = TRUE;
            } else if (wMsg == EN_KILLFOCUS) {
                m_iDisplayInterval = GetDlgItemInt(m_hDlg, IDC_DISPLAY_INTERVAL, &bStat, FALSE);
                // TodoDisplayFilter:  Support for display filter > sample filter.
                // TodoDisplayFilter:  Display filter units = seconds instead of samples

                if ( 1 != m_iDisplayInterval ) {
                    WCHAR   szBuff[MAX_VALUE_LEN];
                    MessageBox (
                        m_hDlg, 
                        L"Display filter > 1 sample not yet implemented.\nDisplay interval in seconds not yet implemented.", 
                        ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION) ;
                    m_iDisplayInterval = 1;
                    StringCchPrintf(szBuff,MAX_VALUE_LEN, L"%d", m_iDisplayInterval) ;
                    SetDlgItemText(m_hDlg, IDC_DISPLAY_INTERVAL, szBuff) ;
                } else {
                    if ( FALSE == bStat) {
                        m_iErrDisplayInterval = IDS_DISPLAY_INT_ERR;
                    } else {
                        m_iErrDisplayInterval = 0;
                    }
                }
            }
            break ;

        case IDC_PERIODIC_UPDATE:

            if (wMsg == BN_CLICKED) {

                m_bManualUpdate = !m_bManualUpdate;
                m_bManualUpdateChg = TRUE;
                fChange = TRUE;
            
                // Disable sample (update) and display intervals if necessary
                DialogEnable (m_hDlg, IDC_INTERVAL_LABEL, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_UPDATE_INTERVAL, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_DISPLAY_INTERVAL, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL1, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL2, !m_bManualUpdate) ;
            }

            break ;

        case IDC_VALUEBAR:

            // If checkbox toggled, set change flags
            if (wMsg == BN_CLICKED) {

                m_bValueBar = !m_bValueBar;
                m_bValueBarChg = TRUE;
                fChange = TRUE;
            }
            break ;

        case IDC_LEGEND:

            // If checkbox toggled, set change flags
            if (wMsg == BN_CLICKED) {

                m_bLegend = !m_bLegend;
                m_bLegendChg = TRUE;
                fChange = TRUE;
            }
            break ;

        case IDC_TOOLBAR:
            if (wMsg == BN_CLICKED) {
                m_bToolbar = !m_bToolbar;
                m_bToolbarChg = TRUE;
                fChange = TRUE;
            }
            break;

        case IDC_COMBOAPPEARANCE:
            if (wMsg == CBN_SELCHANGE) {
                hWndItem = DialogControl(m_hDlg, IDC_COMBOAPPEARANCE);
                iTemp = (INT)CBSelection(hWndItem);

                if ( m_iAppearance != iTemp ) {
                    m_bAppearanceChg = TRUE;
                    fChange = TRUE;
                }

                m_iAppearance = iTemp;
            }
            break ;

        case IDC_COMBOBORDERSTYLE:
            if (wMsg == CBN_SELCHANGE) {
                hWndItem = DialogControl(m_hDlg, IDC_COMBOBORDERSTYLE);
                iTemp = (INT)CBSelection(hWndItem);

                if ( m_iBorderStyle != iTemp ) {
                    m_bBorderStyleChg = TRUE;
                    fChange = TRUE;
                }

                m_iBorderStyle = iTemp;
            }
            break ;

        case IDC_DUPLICATE_INSTANCE:

            // If checkbox toggled, set change flags
            if (wMsg == BN_CLICKED) {

                m_bMonitorDuplicateInstances = !m_bMonitorDuplicateInstances;
                m_bMonitorDuplicateInstancesChg = TRUE;
                fChange = TRUE;
            }
            break ;

        case IDC_GALLERY_GRAPH:
        case IDC_GALLERY_HISTOGRAM:
        case IDC_GALLERY_REPORT: 
            // Check which button is involved
            iTemp = wID - IDC_GALLERY_GRAPH + 1; 

            // If state changed
            if (wMsg == BN_CLICKED && iTemp != m_eDisplayType) {

                // Set change flags and update dialog
                fChange = TRUE;
                m_bDisplayTypeChg = TRUE;
                m_eDisplayType = (DisplayTypeConstants)iTemp;

                CheckRadioButton(m_hDlg, IDC_GALLERY_GRAPH, 
                                    IDC_GALLERY_REPORT, wID);
            }   
            break ;

        case IDC_RPT_VALUE_DEFAULT:
        case IDC_RPT_VALUE_CURRENT:
        case IDC_RPT_VALUE_AVERAGE:
        case IDC_RPT_VALUE_MINIMUM:
        case IDC_RPT_VALUE_MAXIMUM:
            // Check which button is involved
            iTemp = wID - IDC_RPT_VALUE_DEFAULT; 

            // If state changed
            if (wMsg == BN_CLICKED && iTemp != m_eReportValueType) {

                // Set change flags and update dialog
                fChange = TRUE;
                m_bReportValueTypeChg = TRUE;
                m_eReportValueType = (ReportValueTypeConstants)iTemp;

                CheckRadioButton(m_hDlg, IDC_RPT_VALUE_DEFAULT, 
                                    IDC_RPT_VALUE_MAXIMUM, wID);
            }   
            break ;
    }

    // Enable "Apply" button on any change
    if (fChange)
        SetChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\graph.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    graph.h

Abstract:

    <abstract>

--*/


#ifndef _GRAPH_H_
#define _GRAPH_H_

#include <pdh.h>
#include "scale.h"
#include "stepper.h"
#include "cntrtree.h"

#define MAX_GRAPH_SAMPLES       100
#define MAX_GRAPH_ITEMS         8

#define LINE_GRAPH          ((DWORD)sysmonLineGraph) 
#define BAR_GRAPH           ((DWORD)sysmonHistogram)
#define REPORT_GRAPH        ((DWORD)sysmonReport)

#define NULL_COLOR          0xffffffff
#define NULL_APPEARANCE     0xffffffff
#define NULL_BORDERSTYLE    0xffffffff
#define NULL_FONT           0xffffffff

typedef struct _graph_options {
    LPWSTR  pszYaxisTitle ;
    LPWSTR  pszGraphTitle ;
    LPWSTR  pszLogFile ;
    INT     iVertMax ;
    INT     iVertMin ;
    INT     iDisplayFilter ;
    INT     iDisplayType ;
    INT     iAppearance;
    INT     iBorderStyle;
    INT     iReportValueType;
    INT     iDataSourceType;
    OLE_COLOR   clrBackCtl ;
    OLE_COLOR   clrFore ;
    OLE_COLOR   clrBackPlot ;
    OLE_COLOR   clrGrid ;
    OLE_COLOR   clrTimeBar ;
    FLOAT   fUpdateInterval ;
    BOOL    bLegendChecked ;
    BOOL    bToolbarChecked;
    BOOL    bLabelsChecked;
    BOOL    bVertGridChecked ;
    BOOL    bHorzGridChecked ;
    BOOL    bValueBarChecked ;
    BOOL    bManualUpdate;
    BOOL    bHighlight;
    BOOL    bReadOnly;
    BOOL    bMonitorDuplicateInstances;
    BOOL    bAmbientFont;
    } GRAPH_OPTIONS, *PGRAPH_OPTIONS;

typedef struct _hist_control {
    BOOL    bLogSource;
    INT     nMaxSamples;
    INT     nSamples;
    INT     iCurrent;
    INT     nBacklog;
    } HIST_CONTROL, *PHIST_CONTROL;

//All graph data
typedef struct _GRAPHDATA {
    GRAPH_OPTIONS   Options;
    HIST_CONTROL    History;
    CStepper        TimeStepper;
    CStepper        LogViewStartStepper;    // Set in smonctrl.cpp, read in grphdsp.cpp
    CStepper        LogViewStopStepper;     // Set in smonctrl.cpp, read in grphdsp.cpp
    LONGLONG        LogViewTempStart;       // MIN_TIME_VALUE means LogViewStartStepper invalid
    LONGLONG        LogViewTempStop;        // MAX_TIME_VALUE means LogViewStopStepper invalid
    CGraphScale     Scale;
    HQUERY          hQuery;
    class CCounterTree  CounterTree;
} GRAPHDATA, *PGRAPHDATA;


void UpdateGraphCounterValues(PGRAPHDATA, BOOL* );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\fostrwnd.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    fostrwnd.cpp

Abstract:

    <abstract>

--*/

#include "Polyline.h"

WCHAR   szFosterClassName[] = L"FosterWndClass";


LRESULT APIENTRY FosterWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc (hWnd, iMsg, wParam, lParam) ;
}



HWND CreateFosterWnd (
    VOID
    )
{

    WNDCLASS    wc ;
    HWND        hWnd;

    BEGIN_CRITICAL_SECTION

    if (pstrRegisteredClasses[FOSTER_WNDCLASS] == NULL) {
        wc.style         = 0;
        wc.lpfnWndProc   = FosterWndProc;
        wc.hInstance     = g_hInstance;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hIcon         = NULL ;
        wc.hCursor       = NULL ;
        wc.hbrBackground = NULL ;
        wc.lpszMenuName  = NULL ;
        wc.lpszClassName = szFosterClassName ;

        if (RegisterClass (&wc)) {
           pstrRegisteredClasses[FOSTER_WNDCLASS] = szFosterClassName;
        }
    }

    END_CRITICAL_SECTION

    hWnd = NULL;

    if (pstrRegisteredClasses[FOSTER_WNDCLASS] != NULL)
    {
        hWnd = CreateWindow (szFosterClassName,     // window class
                    NULL,                          // window caption
                    WS_DISABLED | WS_POPUP,        // window style
                    0, 0, 0, 0,                 // window size and pos
                    NULL,                           // parent window
                    NULL,                          // menu
                    g_hInstance,                    // program instance
                    NULL) ;                         // user-supplied data
    }

    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\grphdsp.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphdsp.cpp

Abstract:

    <abstract>

--*/

#include "polyline.h"
#include <limits.h>
#include "grphdsp.h"
#include "grphitem.h"
#include "winhelpr.h"

#define ThreeDPad   1
#define BORDER  ThreeDPad
#define TEXT_MARGIN (ThreeDPad + 2)

static HPEN hPenWhite;
static HPEN hPenBlack;

INT
CGraphDisp::RGBToLightness ( COLORREF clrValue )
{
    INT iLightness;
    INT iRed;
    INT iGreen;
    INT iBlue;
    INT iMax;
    INT iMin;

    // The complete algorithm for computing lightness is:
    // Lightness = (Max(R,G,B)+ Min(R,G,B))/2*225.
    // Only need to compute enought to determine whether to draw black or white highlight.

    iRed = GetRValue( clrValue );
    iGreen = GetGValue (clrValue );
    iBlue = GetBValue (clrValue );

    if ( iRed > iGreen ) {
        iMax = iRed;
        iMin = iGreen;
    } else {
        iMax = iGreen;
        iMin = iRed;
    }

    if ( iBlue > iMax ) {
        iMax = iBlue;
    } else if ( iBlue < iMin ) {
        iMin = iBlue;
    }

    iLightness = iMin + iMax;

    return iLightness;
}

CGraphDisp::CGraphDisp ( void )
:   m_pCtrl ( NULL ),
    m_pGraph ( NULL ),
    m_pHiliteItem ( NULL ),
    m_hFontVertical ( NULL ),
    m_bBarConfigChanged ( TRUE )
{
}

CGraphDisp::~CGraphDisp ( void )
{
    if (m_hFontVertical != NULL)
        DeleteObject(m_hFontVertical);

    if (m_hPenTimeBar != 0) {
        DeleteObject ( m_hPenTimeBar );
        m_hPenTimeBar = 0;
    }

    if (m_hPenGrid != 0) {
        DeleteObject ( m_hPenGrid );
        m_hPenGrid = 0;
    }
}

BOOL 
CGraphDisp::Init (
    CSysmonControl *pCtrl, 
    PGRAPHDATA pGraph  
    )
{
    BOOL bRetStatus = TRUE;

    m_pCtrl = pCtrl;
    m_pGraph = pGraph;

    m_clrCurrentGrid = m_pCtrl->clrGrid();
    m_clrCurrentTimeBar = m_pCtrl->clrTimeBar();

    // Create the highlight, timebar and grid pens.

    m_hPenTimeBar = CreatePen(PS_SOLID, 2, m_clrCurrentTimeBar );

    // if can't do it, use a stock object (this can't fail)
    if (m_hPenTimeBar == NULL)
        m_hPenTimeBar = (HPEN)GetStockObject(BLACK_PEN);

    m_hPenGrid = CreatePen(PS_SOLID, 1, m_clrCurrentGrid );

    // if can't do it, use a stock object (this can't fail)
    if (m_hPenGrid == NULL)
        m_hPenGrid = (HPEN)GetStockObject(BLACK_PEN);
    
    // Highlight pens are shared among all Sysmon instances.
    BEGIN_CRITICAL_SECTION

    if (hPenWhite == 0) { 
        hPenWhite = CreatePen(PS_SOLID, 3, RGB(255,255,255));   
        hPenBlack = CreatePen(PS_SOLID, 3, RGB(0,0,0));
    }

    END_CRITICAL_SECTION

    return bRetStatus;
}

void CGraphDisp::HiliteItem( PCGraphItem pItem )
{
    m_pHiliteItem = pItem;
}


VOID 
CGraphDisp::Draw( 
    HDC hDC,
    HDC hAttribDC,
    BOOL fMetafile, 
    BOOL fEntire,
    PRECT /* prcUpdate */ )
{
    
    RECT    rectFrame;
    RECT    rectTitle;
    CStepper    locStepper;
    DWORD   dwPrevLayout = 0;
    DWORD   dwNewLayout = 0;
 
    if ( ( m_rect.right > m_rect.left ) && ( m_rect.bottom > m_rect.top ) ) {

        if ( NULL != hDC ) {

            dwPrevLayout = GetLayout ( hDC );
            dwNewLayout = dwPrevLayout;

            if ( dwNewLayout & LAYOUT_RTL ) {
                dwNewLayout &= ~LAYOUT_RTL;
                SetLayout (hDC, dwNewLayout);
            }

            // Fill plot area
            Fill(hDC, m_pCtrl->clrBackPlot(), &m_rectPlot);

            rectFrame = m_rectPlot;
            // Draw 3D border around plot area
            if ( eAppear3D == m_pCtrl->Appearance() ) {
                InflateRect(&rectFrame,BORDER,BORDER);
                DrawEdge(hDC, &rectFrame, BDR_SUNKENOUTER, BF_RECT);
            }

            // Select colors for all text
            SetBkMode(hDC, TRANSPARENT);
            SetTextColor(hDC, m_pCtrl->clrFgnd());
    
            // Draw the scale
            if (m_pGraph->Options.bLabelsChecked) {
                SelectFont(hDC, m_pCtrl->Font()) ;
                m_pGraph->Scale.Draw(hDC);
            }

            // Draw the main title
            if (m_pGraph->Options.pszGraphTitle != NULL) {

                SelectFont(hDC, m_pCtrl->Font()) ;
                SetTextAlign(hDC, TA_TOP|TA_CENTER);
 
                rectTitle = rectFrame;
                rectTitle.top = m_rect.top;
                FitTextOut( 
                    hDC,
                    hAttribDC,
                    0,
                    &rectTitle,
                    m_pGraph->Options.pszGraphTitle, 
                    lstrlen(m_pGraph->Options.pszGraphTitle),
                    TA_CENTER,
                    FALSE );
            }

            // Draw the Y axis title
            if (m_pGraph->Options.pszYaxisTitle != NULL && m_hFontVertical != NULL) {
                SelectFont(hDC, m_hFontVertical) ;
                SetTextAlign(hDC, TA_TOP|TA_CENTER);

                rectTitle = rectFrame;
                rectTitle.left = m_rect.left;
                FitTextOut( 
                    hDC, 
                    hAttribDC, 
                    0,
                    &rectTitle,
                    m_pGraph->Options.pszYaxisTitle,
                    lstrlen(m_pGraph->Options.pszYaxisTitle),
                    TA_CENTER,
                    TRUE);
            }

            // setup stepper reset to start
            locStepper = m_pGraph->TimeStepper;
            locStepper.Reset();

            // Set clipping area.  Fill executed above, so bFill= FALSE.
            StartUpdate(hDC, fMetafile, fEntire, 0, (m_rectPlot.right - m_rectPlot.left), FALSE );

            // draw the grid lines
            DrawGrid(hDC, 0, m_rectPlot.right - m_rectPlot.left);

            m_pCtrl->LockCounterData();

            switch (m_pGraph->Options.iDisplayType) {

                case LINE_GRAPH: 

                    // Finish and restart update so that wide lines are cropped at the timeline.
                    FinishUpdate(hDC, fMetafile);

                    StartUpdate(
                        hDC, 
                        fMetafile, 
                        FALSE, 
                        0, 
                        m_pGraph->TimeStepper.Position(),
                        FALSE );
           
                    // Plot points from start of graph to time line 
                    PlotData(hDC, m_pGraph->TimeStepper.StepNum() + m_pGraph->History.nBacklog,
                             m_pGraph->TimeStepper.StepNum(), &locStepper);

                    FinishUpdate(hDC, fMetafile);

                    // Plot points from time line to end of graph
                    locStepper = m_pGraph->TimeStepper;

                    // Restart update. Left-hand ends and internal gaps of wide lines are not cropped.
                    StartUpdate(
                        hDC, 
                        fMetafile, 
                        FALSE, 
                        locStepper.Position(), 
                        m_rectPlot.right - m_rectPlot.left,
                        FALSE );

                    PlotData(hDC, m_pGraph->TimeStepper.StepCount() + m_pGraph->History.nBacklog,  
                             m_pGraph->TimeStepper.StepCount() - m_pGraph->TimeStepper.StepNum(),
                             &locStepper);

                    DrawTimeLine(hDC, m_pGraph->TimeStepper.Position());

                    if ( MIN_TIME_VALUE != m_pGraph->LogViewTempStart ) 
                        DrawStartStopLine(hDC, m_pGraph->LogViewStartStepper.Position());
                    if ( MAX_TIME_VALUE != m_pGraph->LogViewTempStop ) 
                        DrawStartStopLine(hDC, m_pGraph->LogViewStopStepper.Position());
                    break;

                case BAR_GRAPH:
                    PlotBarGraph(hDC, FALSE);
                    break;
            }

            FinishUpdate(hDC, fMetafile);

            if ( dwNewLayout != dwPrevLayout ) {
                SetLayout (hDC, dwPrevLayout);
            }

            m_pCtrl->UnlockCounterData();
        }
    }
}




VOID 
CGraphDisp::UpdateTimeBar( 
    HDC hDC,
    BOOL bPlotData )
{
    INT     nBacklog;
    INT     iUpdateCnt;
    INT     i;
    CStepper    locStepper;

    nBacklog = m_pGraph->History.nBacklog;

    // Work off backlogged sample intervals
    while ( nBacklog > 0) {

        // If we are going to wrap around, update in two steps
        if (nBacklog > m_pGraph->TimeStepper.StepCount() 
                            - m_pGraph->TimeStepper.StepNum()) {
            iUpdateCnt = m_pGraph->TimeStepper.StepCount() 
                            - m_pGraph->TimeStepper.StepNum();
        } else {
            iUpdateCnt = nBacklog;
        }

        // step to position of current data 
        locStepper = m_pGraph->TimeStepper;
        for (i=0; i<iUpdateCnt; i++) 
            m_pGraph->TimeStepper.NextPosition();

        if ( bPlotData ) {
            StartUpdate(
                hDC, 
                FALSE, 
                FALSE, 
                locStepper.Position(), 
                m_pGraph->TimeStepper.Position(),
                TRUE );

            DrawGrid(hDC, locStepper.Position(), m_pGraph->TimeStepper.Position());

            PlotData(hDC, nBacklog, iUpdateCnt, &locStepper);

            FinishUpdate ( hDC, FALSE );
        }

        if (m_pGraph->TimeStepper.StepNum() >= m_pGraph->TimeStepper.StepCount())
            m_pGraph->TimeStepper.Reset();

        nBacklog -= iUpdateCnt;
    }

    if ( bPlotData ) {
        DrawTimeLine(hDC, m_pGraph->TimeStepper.Position());    
    }
    
    m_pGraph->History.nBacklog = 0;
}

VOID 
CGraphDisp::Update( HDC hDC )
{
    DWORD   dwPrevLayout = 0;
    DWORD   dwNewLayout = 0;

    m_pCtrl->LockCounterData();

    if ( NULL != hDC ) {

        dwPrevLayout = GetLayout ( hDC );
        dwNewLayout = dwPrevLayout;

        if ( dwNewLayout & LAYOUT_RTL ) {
            dwNewLayout &= ~LAYOUT_RTL;
            SetLayout (hDC, dwNewLayout);
        }

        if ( ( m_rect.right > m_rect.left ) && ( m_rect.bottom > m_rect.top ) ) {

            switch (m_pGraph->Options.iDisplayType) {

                case LINE_GRAPH: 
                    // Update the line graph and time bar based on history 
                    // backlog.  Reset history backlog to 0, signalling collection
                    // thread to post another WM_GRAPH_UPDATE message.
                    UpdateTimeBar ( hDC, TRUE );
                    break;

                case BAR_GRAPH:
                    PlotBarGraph(hDC, TRUE);
                    break;
            }
        }

        // If updating histogram or report, update thetimebar step based on 
        // history backlog.  Reset history backlog to 0, signalling collection
        // thread to post another WM_GRAPH_UPDATE message.
        UpdateTimeBar ( hDC, FALSE );
        if ( dwNewLayout != dwPrevLayout ) {
            SetLayout (hDC, dwPrevLayout);
        }
    }
    m_pCtrl->UnlockCounterData();
}



void 
CGraphDisp::StartUpdate(     
    HDC  hDC, 
    BOOL fMetafile,
    BOOL fEntire,
    INT  xLeft, 
    INT  xRight,
    BOOL bFill )
{
    RECT    rect;

    // Preserve clipping region

    if ( FALSE == fMetafile ) {
        
        m_rgnClipSave = CreateRectRgn(0,0,0,0);
        
        if (m_rgnClipSave != NULL) {
            if (GetClipRgn(hDC, m_rgnClipSave) != 1) {
                DeleteObject(m_rgnClipSave);
                m_rgnClipSave = NULL;
            }
        }

        xLeft += m_rectPlot.left;
        xRight += m_rectPlot.left;
        IntersectClipRect (
            hDC, 
            max ( m_rectPlot.left, xLeft ), 
            m_rectPlot.top,
            min (m_rectPlot.right, xRight + 1), // Extra pixel for TimeBar
            m_rectPlot.bottom ) ;

    } else if( TRUE == fEntire ){
        m_rgnClipSave = NULL;
        IntersectClipRect (
            hDC, 
            m_rectPlot.left, 
            m_rectPlot.top,
            m_rectPlot.right, 
            m_rectPlot.bottom ) ;
    }


    // Fill performed before this method for metafiles and complete draw.
    if ( !fMetafile && bFill ) {
        SetRect(
            &rect, 
            max ( m_rectPlot.left, xLeft - 1 ), 
            m_rectPlot.top - 1, 
            min (m_rectPlot.right, xRight + 1), 
            m_rectPlot.bottom);

        Fill(hDC, m_pCtrl->clrBackPlot(), &rect);
    }
}


void CGraphDisp::FinishUpdate( HDC hDC, BOOL fMetafile )
{
    // Restore saved clip region
    if ( !fMetafile ) {

        SelectClipRgn(hDC, m_rgnClipSave);
        if (m_rgnClipSave != NULL) {
            DeleteObject(m_rgnClipSave);
            m_rgnClipSave = NULL;
        }
    }
}


void CGraphDisp::DrawGrid(HDC hDC, INT xLeft, INT xRight)
{
    INT xPos;
    INT nTics;
    INT *piScaleTic;
    INT i;


    if ( (m_pGraph->Options.bVertGridChecked)
        || (m_pGraph->Options.bHorzGridChecked) ) {

        if ( m_clrCurrentGrid != m_pCtrl->clrGrid() ) {

            m_clrCurrentGrid = m_pCtrl->clrGrid();

            DeleteObject ( m_hPenGrid );

            m_hPenGrid = CreatePen(PS_SOLID, 1, m_clrCurrentGrid );

            // if can't do it, use a stock object (this can't fail)
            if (m_hPenGrid == NULL)
                m_hPenGrid = (HPEN)GetStockObject(BLACK_PEN);
        }
    }

    if (m_pGraph->Options.bVertGridChecked) {

        SelectObject(hDC, m_hPenGrid);

        m_GridStepper.Reset();
        xPos = m_GridStepper.NextPosition();

        while (xPos < xLeft)
            xPos =m_GridStepper.NextPosition();

        while (xPos < xRight) {
            MoveToEx(hDC, xPos + m_rectPlot.left, m_rectPlot.bottom, NULL);
            LineTo(hDC, xPos + m_rectPlot.left, m_rectPlot.top - 1);
            xPos = m_GridStepper.NextPosition();
        }
    }

    if (m_pGraph->Options.bHorzGridChecked) {
        xLeft += m_rectPlot.left;
        xRight += m_rectPlot.left;

        SelectObject(hDC,m_hPenGrid);

        nTics = m_pGraph->Scale.GetTicPositions(&piScaleTic);

        for (i=1; i<nTics; i++) {
            MoveToEx(hDC, xLeft, m_rectPlot.top + piScaleTic[i], NULL);
            LineTo(hDC, xRight + 1, m_rectPlot.top + piScaleTic[i]);
        }
    }
}
    
BOOL 
CGraphDisp::CalcYPosition (
    PCGraphItem pItem, 
    INT iHistIndex,
    BOOL bLog, 
    INT y[3] )
{
    BOOL        bReturn;    // True = good, False = bad.
    PDH_STATUS  stat;   
    DWORD       dwCtrStat;
    double      dValue[3];
    double      dTemp;
    INT         iVal;
    INT         nVals = bLog ? 3 : 1;

    if (bLog)
        stat = pItem->GetLogEntry(iHistIndex, &dValue[1], &dValue[2], &dValue[0], &dwCtrStat);
    else
        stat = pItem->HistoryValue(iHistIndex, &dValue[0], &dwCtrStat);

    if (ERROR_SUCCESS == stat && IsSuccessSeverity(dwCtrStat)) {

        for (iVal = 0; iVal < nVals; iVal++) {

            dTemp = dValue[iVal] * pItem->Scale();

            if (dTemp > m_dMax)
                dTemp = m_dMax;
            else if (dTemp < m_dMin)
                dTemp = m_dMin;

            // Plot minimum value as 1 pixel above the bottom of the plot area, since
            // clipping and fill regions crop the bottom and right pixels.
            y[iVal] = m_rectPlot.bottom - (INT)((dTemp - m_dMin) * m_dPixelScale);
            if ( y[iVal] == m_rectPlot.bottom ) {
                y[iVal] = m_rectPlot.bottom - 1;
            }
        }
        bReturn = TRUE;
    } else {
        bReturn = FALSE;
    }

    return bReturn;
}

void CGraphDisp::PlotData(HDC hDC, INT iHistIndx, INT nSteps, CStepper *pStepper)
{
    INT         i;
    INT         x;
    INT         y[3];
    PCGraphItem pItem;
    CStepper    locStepper;
    BOOL        bSkip;
    BOOL        bPrevGood;
    BOOL        bLog;
    BOOL        bLogMultiVal;

    if (m_pGraph->Options.iVertMax <= m_pGraph->Options.iVertMin)
        return;

    bSkip = TRUE;

    bLog = m_pCtrl->IsLogSource();
    bLogMultiVal = bLog && !DisplaySingleLogSampleValue();

    // If possible, back up to redraw previous segment
    if (pStepper->StepNum() > 0) {
        iHistIndx++;
        nSteps++;
        pStepper->PrevPosition();
    }

    // Set background color, in case of dashed lines
    SetBkMode(hDC, TRANSPARENT);

    pItem = m_pCtrl->FirstCounter();
    while (pItem != NULL) {
        locStepper = *pStepper;

        // Skip hilited item the first time
        if (!(pItem == m_pHiliteItem && bSkip)) {
            INT     iPolyIndex = 0;
            POINT   arrptDataPoints[MAX_GRAPH_SAMPLES] ;

            if ( pItem == m_pHiliteItem) {
                // Arbitrary 450 (out of 510) chosen as cutoff for white vs. black
                if ( 450 > RGBToLightness( m_pCtrl->clrBackPlot() ) )
                    SelectObject(hDC, hPenWhite);
                else
                    SelectObject(hDC, hPenBlack);
            } else {
                SelectObject(hDC,pItem->Pen());
            }

            bPrevGood = FALSE;

            //  For each GOOD current value:
            //      If the previous value is good, draw line from previous value to current value.  
            //      If the previous value is bad, MoveTo the current value point.
            //
            //      For the first step, the previous value is false by definition, so the first operation
            //      is a MoveTo.

            //
            //  Polyline code:
            //  For each GOOD current value:
            //      Add the current (good) point to the polyline point array.
            //  For each BAD current value:
            //      If the polyline index is > 1 (2 points), draw the polyline and reset the polyline index to 0.
            //  After all values:
            //      If the polyline index is > 1 (2 points), draw the polyline.

            for (i = 0; i <= nSteps; i++) {

                // True = Good current value
                if ( CalcYPosition ( pItem, iHistIndx - i, bLog, y ) ) {

                    x = m_rectPlot.left + locStepper.Position();

                    // Add point to polyline, since the current value is good.
                    arrptDataPoints[iPolyIndex].x = x;
                    arrptDataPoints[iPolyIndex].y = y[0];
                    iPolyIndex++;

                    // No polyline optimization for extra Max and Min log points.
                    if (bLogMultiVal) {
                        MoveToEx(hDC, x, y[1], NULL);
                        LineTo(hDC, x, y[2]);
                        MoveToEx(hDC, x, y[0], NULL);
                    }

                    bPrevGood = TRUE;
                
                } else {
                    // Current value is not good.
                    bPrevGood = FALSE;

                    // Current value is not good, so don't add to polyline point array.
                    if ( iPolyIndex > 1 ) {
                        // Draw polyline for any existing good points.
                        Polyline(hDC, arrptDataPoints, iPolyIndex) ;
                    }
                    // Reset polyline point index to 0.
                    iPolyIndex = 0;
                }

                locStepper.NextPosition();
            }

            // Draw the final line.
            if ( iPolyIndex > 1 ) {
                // Draw polyline
                Polyline(hDC, arrptDataPoints, iPolyIndex) ;
            }

            // Exit loop after plotting hilited item
            if (pItem == m_pHiliteItem)
                break;
            }
  
        pItem = pItem->Next();

        // After last item, go back to highlighted item 
        if (pItem == NULL) {
            pItem = m_pHiliteItem;
            bSkip = FALSE;
        }
    }
}

void CGraphDisp::PlotBarGraph(HDC hDC, BOOL fUpdate)
{

    if ( (m_pGraph->CounterTree.NumCounters() > 0 ) 
        && (m_pGraph->Options.iVertMax > m_pGraph->Options.iVertMin) ) {

        CStepper    BarStepper;
        PCGraphItem pItem;
        RECT        rectBar;
        INT         iValue,iPrevValue;
        HRESULT     hr;
        LONG        lCtrStat;
        double      dValue = 0.0;
        double      dMax;
        double      dMin;
        double      dAvg;
        double      dTemp;
        HRGN        hrgnRedraw,hrgnTemp;
        eReportValueTypeConstant eValueType;            
        BOOL        bLog;
        INT         iNumCounters = m_pGraph->CounterTree.NumCounters();
        BOOL        bSkip = TRUE;
        INT         iHighlightStepNum = 0;
        BOOL        bLocalUpdate;
        HANDLE      hPenSave;

        bLocalUpdate = fUpdate;

        hrgnRedraw = NULL;

        eValueType = m_pCtrl->ReportValueType();
       
        // Todo:  Move DisplaySingleLogSampleValue() to CSystemMonitor.
        bLog = m_pCtrl->IsLogSource();

        // Force total redraw if the number of counters has changed in case 
        // Update is called immediately after. 
        if ( m_bBarConfigChanged ) {
            SetBarConfigChanged ( FALSE );
            if ( bLocalUpdate ) {
                bLocalUpdate = FALSE;
           }
           // Clear and fill the entire plot region.
           hrgnRedraw = CreateRectRgn(
                            m_rectPlot.left, 
                            m_rectPlot.top, 
                            m_rectPlot.right, 
                            m_rectPlot.bottom);

           if (hrgnRedraw) {
                SelectClipRgn(hDC, hrgnRedraw);
                Fill(hDC, m_pCtrl->clrBackPlot(), &m_rectPlot);
                DrawGrid(hDC, 0, (m_rectPlot.right - m_rectPlot.left));
                DeleteObject(hrgnRedraw);
                hrgnRedraw = NULL;
            }
        }

        // Intialize stepper for number of bars to plot
        BarStepper.Init ( ( m_rectPlot.right - m_rectPlot.left), iNumCounters );

        hPenSave = SelectPen ( hDC, GetStockObject(NULL_PEN) );

        // Do for all counters
        pItem = m_pGraph->CounterTree.FirstCounter();
        while ( NULL != pItem ) {

            hr = ERROR_SUCCESS;

            // Skip highlighted item the first time through

            if (!(pItem == m_pHiliteItem && bSkip)) {

                // Get display value
                if ( sysmonDefaultValue == eValueType  ) {
                    if (bLog) {
                        hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);
                        dValue = dAvg;
                    } 
                    else {
                        hr = pItem->GetValue(&dValue, &lCtrStat);
                    }
                } else {

                    if ( sysmonCurrentValue == eValueType  ) {
                        hr = pItem->GetValue(&dValue, &lCtrStat);
                    } 
                    else {

                        hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);

                        switch ( eValueType ) {
    
                            case sysmonAverage:
                                dValue = dAvg;
                                break;
        
                            case sysmonMinimum:
                                dValue = dMin;
                                break;
        
                            case sysmonMaximum:
                                dValue = dMax;
                                break;

                            default:
                                assert (FALSE);
                        }
                    }
                }

                // Erase bar if the counter value is invalid.
                if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {
                    // Convert value to pixel units
                    dTemp = dValue * pItem->Scale();

                    if (dTemp > m_dMax)
                        dTemp = m_dMax;
                    else if (dTemp < m_dMin)
                        dTemp = m_dMin;

                    iValue = m_rectPlot.bottom - (INT)((dTemp - m_dMin) * m_dPixelScale);
                    if ( iValue == m_rectPlot.bottom ) {
                        // Draw single pixel for screen visibility.
                        iValue--;
                    }
                } else {
                    // The current value is 0. Draw single pixel for screen visibility.
                    iValue = m_rectPlot.bottom - 1;
                }

                if ( !bSkip ) {
                    assert ( pItem == m_pHiliteItem );
                    BarStepper.StepTo ( iHighlightStepNum );
                }

                // Setup left and right edges of bar
                rectBar.left = m_rectPlot.left + BarStepper.Position();
                rectBar.right = m_rectPlot.left + BarStepper.NextPosition();

                // If doing an update (never called for log sources) and not drawing the highlighted item
                if ( bLocalUpdate && !( ( pItem == m_pHiliteItem ) && !bSkip) ) {

                    assert ( !m_bBarConfigChanged );

                    // Get previous plot value
                    iPrevValue = 0;
                    hr = pItem->HistoryValue(1, &dValue, (ULONG*)&lCtrStat);
                    if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {

                        // Convert value to pixel units
                        dTemp = dValue * pItem->Scale();

                        if (dTemp > m_dMax)
                            dTemp = m_dMax;
                        else if (dTemp < m_dMin)
                            dTemp = m_dMin;

                        iPrevValue = m_rectPlot.bottom - (INT)((dTemp - m_dMin) * m_dPixelScale);
                        if ( iPrevValue == m_rectPlot.bottom ) {
                            // Single pixel was drawn for screen visibility.
                            iPrevValue--;
                        }
                    } else {
                        // The previous value was 0. Single pixel was drawn for screen visibility.
                        iPrevValue = m_rectPlot.bottom - 1;
                    }

                    // If bar has grown (smaller y coord)
                    if (iPrevValue > iValue) {

                        // Draw the new part
                        rectBar.bottom = iPrevValue;
                        rectBar.top = iValue;

                        if ( pItem == m_pHiliteItem) {
                            // Arbitrary 450 (out of 510) chosen as cutoff for white vs. black
                            if ( 450 > RGBToLightness( m_pCtrl->clrBackPlot() ) )
                                SelectBrush(hDC, GetStockObject(WHITE_BRUSH));
                            else
                                SelectBrush(hDC, GetStockObject(BLACK_BRUSH));
                        } else {
                            SelectBrush(hDC, pItem->Brush());
                        }
                        // Bars are drawn with Null pen, so bottom and right are cropped by 1 pixel.
                        // Add 1 pixel to compensate.
                        Rectangle(hDC, rectBar.left, rectBar.top, rectBar.right + 1, rectBar.bottom + 1);
    
                    } else if (iPrevValue < iValue) {
        
                        // Else if bar has shrunk

                        // Add part to be erased to redraw region
                        // Erase to the top of the grid, to eliminate random pixels left over.
                        rectBar.bottom = iValue;
                        rectBar.top = m_rectPlot.top;  // set to stop of grid rather than to prevValue

                        hrgnTemp = CreateRectRgn(rectBar.left, rectBar.top, rectBar.right, rectBar.bottom);
                        if (hrgnRedraw && hrgnTemp) {
                            CombineRgn(hrgnRedraw,hrgnRedraw,hrgnTemp,RGN_OR);
                            DeleteObject(hrgnTemp);
                        } else {
                            hrgnRedraw = hrgnTemp;
                        }
                    }
                } else {
                    // Erase and redraw complete bar

                    // Erase top first
                    // Add part to be erased to redraw region
                    // Erase to the top of the grid, to eliminate random pixels left over.
                    if ( iValue != m_rectPlot.top ) {
                        rectBar.bottom = iValue;
                        rectBar.top = m_rectPlot.top;  // set to stop of grid rather than to prevValue

                        hrgnTemp = CreateRectRgn(rectBar.left, rectBar.top, rectBar.right, rectBar.bottom);
                        if (hrgnRedraw && hrgnTemp) {
                            CombineRgn(hrgnRedraw,hrgnRedraw,hrgnTemp,RGN_OR);
                            DeleteObject(hrgnTemp);
                        } else {
                            hrgnRedraw = hrgnTemp;
                        }
                    }

                    // Then draw the bar.
                    rectBar.bottom = m_rectPlot.bottom;
                    rectBar.top = iValue;

                    if ( pItem == m_pHiliteItem) {
                        // Arbitrary 450 (out of 510) chosen as cutoff for white vs. black
                        if ( 450 > RGBToLightness( m_pCtrl->clrBackPlot() ) )
                            SelectBrush(hDC, GetStockObject(WHITE_BRUSH));
                        else
                            SelectBrush(hDC, GetStockObject(BLACK_BRUSH));
                    } else {
                        SelectBrush(hDC, pItem->Brush());
                    }
                    // Bars are drawn with Null pen, so bottom and right are cropped by 1 pixel.
                    // Add 1 pixel to compensate.
                    Rectangle(hDC, rectBar.left, rectBar.top, rectBar.right + 1, rectBar.bottom + 1);
                } // Update

                // Exit loop after plotting highlighted item
                if (pItem == m_pHiliteItem) 
                    break;

            } else {
                if ( bSkip ) {
                    // Save position of highlighted item the first time through
                    iHighlightStepNum = BarStepper.StepNum();
                }
                BarStepper.NextPosition();
            }

            pItem = pItem->Next();
           
            // After last item, go back to highlighted item 
            if ( NULL == pItem && NULL != m_pHiliteItem ) {
                pItem = m_pHiliteItem;
                bSkip = FALSE;
            }            

        } // Do for all counters

        // If redraw region accumulated, erase and draw grid lines
        if (hrgnRedraw) {
            SelectClipRgn(hDC, hrgnRedraw);
            Fill(hDC, m_pCtrl->clrBackPlot(), &m_rectPlot);
            DrawGrid(hDC, 0, (m_rectPlot.right - m_rectPlot.left));
            DeleteObject(hrgnRedraw);
        }
        SelectObject(hDC, hPenSave);
    }
}

     
void CGraphDisp::SizeComponents(HDC hDC, PRECT pRect)
{
    INT iStepNum;
    INT iScaleWidth;
    INT iTitleHeight;
    INT iAxisTitleWidth;
    RECT rectScale;
    SIZE size;
    INT  iWidth;
    INT  i;

    static INT aiWidthTable[] = {20,50,100,150,300,500,1000000};
    static INT aiTicTable[] = {0,2,4,5,10,20,25};

    m_rect = *pRect;

    // if no space, return
    if (m_rect.right <= m_rect.left || m_rect.bottom - m_rect.top <= 0)
        return;

    // For now use the horizontal font height for both horizontal and vertical text
    // because the GetTextExtentPoint32 is returning the wrong height for vertical text
    SelectFont(hDC, m_pCtrl->Font());
    GetTextExtentPoint32(hDC, TEXT("Sample"), 6, &size);

    if (m_pGraph->Options.pszGraphTitle != NULL) {
        //SelectFont(hDC, m_pCtrl->Font()) ;
        //GetTextExtentPoint32(hDC, m_pGraph->Options.pszGraphTitle, 
        //              lstrlen(m_pGraph->Options.pszGraphTitle), &size);
        iTitleHeight = size.cy + TEXT_MARGIN;
    } else
        iTitleHeight = 0;

    if (m_pGraph->Options.pszYaxisTitle != NULL && m_hFontVertical != NULL) {
        //SelectFont(hDC, m_hFontVertical);
        //GetTextExtentPoint32(hDC, m_pGraph->Options.pszYaxisTitle,
        //                  lstrlen(m_pGraph->Options.pszYaxisTitle), &size);
                        
        iAxisTitleWidth = size.cy + TEXT_MARGIN;
    } else
        iAxisTitleWidth = 0;
             
    if (m_pGraph->Options.bLabelsChecked) {
        //SelectFont(hDC, m_pCtrl->Font());
        iScaleWidth = m_pGraph->Scale.GetWidth(hDC);
    } else
        iScaleWidth = 0;

    SetRect(&rectScale, pRect->left + iAxisTitleWidth, 
                        pRect->top + iTitleHeight, 
                        pRect->left + iAxisTitleWidth + iScaleWidth, 
                        pRect->bottom);

    m_pGraph->Scale.SetRect(&rectScale);        // Just to set grid line positions

    SetRect(&m_rectPlot, pRect->left + iScaleWidth + iAxisTitleWidth + BORDER,
                            pRect->top + iTitleHeight + BORDER,
                            pRect->right - BORDER, 
                            pRect->bottom - BORDER);

    // Reinitialize steppers for new width
    iWidth = m_rectPlot.right - m_rectPlot.left;

    iStepNum = m_pGraph->TimeStepper.StepNum();
    m_pGraph->TimeStepper.Init(iWidth, m_pGraph->History.nMaxSamples - 2);
    m_pGraph->TimeStepper.StepTo(iStepNum);

    iStepNum = m_pGraph->LogViewStartStepper.StepNum();
    m_pGraph->LogViewStartStepper.Init(iWidth, m_pGraph->History.nMaxSamples - 2);
    m_pGraph->LogViewStartStepper.StepTo(iStepNum);

    iStepNum = m_pGraph->LogViewStopStepper.StepNum();
    m_pGraph->LogViewStopStepper.Init(iWidth, m_pGraph->History.nMaxSamples - 2);
    m_pGraph->LogViewStopStepper.StepTo(iStepNum);

    // Find best grid count for this width
    for (i=0; iWidth > aiWidthTable[i]; i++) {};

    m_GridStepper.Init(iWidth, aiTicTable[i]); 

    // Compute conversion factors for plot, hit test.
    m_dMin = (double)m_pGraph->Options.iVertMin;
    m_dMax = (double)m_pGraph->Options.iVertMax;

    m_dPixelScale = (double)(m_rectPlot.bottom - m_rectPlot.top) / (m_dMax - m_dMin);

}


void CGraphDisp::DrawTimeLine(HDC hDC, INT x)
{
    HPEN hPenSave;

    // No time line for log playback
    if (m_pCtrl->IsLogSource())
        return;

    x += m_rectPlot.left + 1;

    if ( m_clrCurrentTimeBar != m_pCtrl->clrTimeBar() ) {
        LOGBRUSH lbrush;

        m_clrCurrentTimeBar = m_pCtrl->clrTimeBar();

        DeleteObject ( m_hPenTimeBar );
    
        // When called from Update(), DrawTimeLine is called after the clipping region 
        // is deactivated. Create a geometric pen in order to specify flat end cap style.
        // This eliminates any extra pixels drawn at the end. 

        lbrush.lbStyle = BS_SOLID;
        lbrush.lbColor = m_clrCurrentTimeBar;
        lbrush.lbHatch = 0;

        m_hPenTimeBar = ExtCreatePen ( 
                            PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_FLAT, 2, &lbrush, 0, NULL );

        // if can't do it, use a stock object (this can't fail)
        if (m_hPenTimeBar == NULL)
            m_hPenTimeBar = (HPEN)GetStockObject(BLACK_PEN);
    }

    hPenSave = SelectPen ( hDC, m_hPenTimeBar );
    MoveToEx ( hDC, x, m_rectPlot.top, NULL );

    // Specify 1 less pixel.  All fills and clip regions clip bottom and 
    // right pixels, so match their behavior.
    LineTo ( hDC, x, m_rectPlot.bottom - 1 );
    
    SelectObject(hDC, hPenSave);
}

void CGraphDisp::DrawStartStopLine(HDC hDC, INT x)
{
    HPEN hPenSave;

    // Log view start/stop lines only for log playback
    if (!m_pCtrl->IsLogSource())
        return;

    if ( x > 0 && x < ( m_rectPlot.right - m_rectPlot.left ) ) {
        x += m_rectPlot.left;

        if ( m_clrCurrentGrid != m_pCtrl->clrGrid() ) {

            m_clrCurrentGrid = m_pCtrl->clrGrid();

            DeleteObject ( m_hPenGrid );

            m_hPenGrid = CreatePen(PS_SOLID, 1, m_clrCurrentGrid );

            // if can't do it, use a stock object (this can't fail)
            if (m_hPenGrid == NULL)
                m_hPenGrid = (HPEN)GetStockObject(BLACK_PEN);
        }

        hPenSave = SelectPen(hDC, m_hPenGrid);
        MoveToEx(hDC, x, m_rectPlot.top, NULL);
        LineTo(hDC, x, m_rectPlot.bottom);
        
        SelectObject(hDC, hPenSave);
    }
}

void CGraphDisp::ChangeFont( HDC hDC )
{
    TEXTMETRIC  TextMetrics, newTextMetrics;
    LOGFONT     LogFont;
    HFONT       hFontOld;

    // Select the new font
    hFontOld = SelectFont(hDC, m_pCtrl->Font());

    // Get attributes
    GetTextMetrics(hDC, &TextMetrics);

    // Create LOGFONT for vertical font with same attributes
    LogFont.lfHeight = TextMetrics.tmHeight;
    LogFont.lfWidth = 0;
    LogFont.lfOrientation = LogFont.lfEscapement = 90*10;
    LogFont.lfWeight = TextMetrics.tmWeight;
    LogFont.lfStrikeOut = TextMetrics.tmStruckOut;
    LogFont.lfUnderline = TextMetrics.tmUnderlined;
    LogFont.lfItalic = TextMetrics.tmItalic;
    LogFont.lfCharSet = TextMetrics.tmCharSet;
    LogFont.lfPitchAndFamily = (BYTE)(TextMetrics.tmPitchAndFamily & 0xF0);

    GetTextFace(hDC, LF_FACESIZE, LogFont.lfFaceName);

    // Force a truetype font, because raster fonts can't rotate
    LogFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
    LogFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    LogFont.lfQuality = DEFAULT_QUALITY;

    // Release the current font
    if (m_hFontVertical != NULL)
        DeleteObject(m_hFontVertical);

    // Create the font and save handle locally
    m_hFontVertical = CreateFontIndirect(&LogFont);

    SelectFont(hDC, m_hFontVertical);
    GetTextMetrics(hDC, &newTextMetrics);

    SelectFont(hDC, hFontOld);
}

PCGraphItem 
CGraphDisp::GetItemInLineGraph ( SHORT xPos, SHORT yPos )
{
    PCGraphItem pItem = NULL;
    PCGraphItem pReturn = NULL;

    INT iPrevStepNum;
    POINT ptPrev;
    POINT ptNext;
    POINTS ptMouse;
    CStepper    locStepper;

    INT     iHistIndex;
    BOOL    bLog;
    BOOL    bLogMultiVal;
    BOOL    bFound = FALSE;

    INT yPosPrev[3];
    INT yPosNext[3];

    pItem = m_pCtrl->FirstCounter();
    bLog = m_pCtrl->IsLogSource();
    bLogMultiVal = bLog && !DisplaySingleLogSampleValue();

    // Items exist?
    if (pItem != NULL) {

        locStepper = m_pGraph->TimeStepper;
        locStepper.Reset();

        iPrevStepNum = locStepper.PrevStepNum(xPos - m_rectPlot.left);
        locStepper.StepTo(iPrevStepNum);

        ptPrev.x = m_rectPlot.left + locStepper.Position();
        ptNext.x = m_rectPlot.left + locStepper.NextPosition();                            

        ptMouse.x = xPos;
        ptMouse.y = yPos;

        // Item within rectangle?
        if ( iPrevStepNum > -1 ) {
            
            // Determine the history index of the preceding step.

            if ( iPrevStepNum <= m_pGraph->TimeStepper.StepNum() ) {
                iHistIndex = m_pGraph->TimeStepper.StepNum() - iPrevStepNum;
            } else {
                iHistIndex = m_pGraph->TimeStepper.StepNum() 
                                + (m_pGraph->TimeStepper.StepCount() - iPrevStepNum);
            }

            while ( (pItem != NULL) && !bFound ) {

                // Calculate y position of this value to compare against
                // y position of hit point.
                if ( CalcYPosition ( pItem, iHistIndex, bLog, yPosPrev ) ) {
                
                    if ( iPrevStepNum < locStepper.StepCount() ) {

                        if ( CalcYPosition ( pItem, iHistIndex - 1, bLog, yPosNext ) ) {
            
                            ptPrev.y = yPosPrev[0];
                            ptNext.y = yPosNext[0];
                        
                            bFound = HitTestLine( ptPrev, ptNext, ptMouse, eHitRegion );

                            // For log files, also check the vertical line from min to max
                            // for the closest step.
                            if ( !bFound && bLogMultiVal ) {
                                INT iTemp = ptNext.x - ptPrev.x;
                        
                                iTemp = iTemp / 2;

                                if ( ptMouse.x <= ( ptPrev.x + iTemp/2 ) ) {
                        
                                    bFound = (( yPosPrev[2] - eHitRegion < yPos ) 
                                                && ( yPos < yPosPrev[1] + eHitRegion ));
                                } else {

                                    bFound = (( yPosNext[2] - eHitRegion < yPos ) 
                                                && ( yPos < yPosNext[1] + eHitRegion ));
                                }
                            }
                        }
                    } else {

                        // At the end, so just check the final point.

                        if ( !bLogMultiVal ) {
                            bFound = (( yPosPrev[0] - eHitRegion < yPos ) 
                                    && ( yPos < yPosPrev[0] + eHitRegion ));
                        } else {
                            bFound = (( yPosPrev[2] - eHitRegion < yPos ) 
                                        && ( yPos < yPosPrev[1] + eHitRegion ));
                        }
                    }
                }

                if ( bFound ) 
                    pReturn = pItem;
                else
                    pItem = pItem->Next();
            }        
        }
    }
    
    return pReturn;
}

PCGraphItem 
CGraphDisp::GetItemInBarGraph ( SHORT xPos, SHORT /* yPos */ )
{
    PCGraphItem pItem = NULL;

    pItem = m_pCtrl->FirstCounter();

    // Items exist?
    if (pItem != NULL) {

        CStepper    BarStepper;
        INT         iNumCounters = m_pGraph->CounterTree.NumCounters();
        INT         iCount;
        INT         iHitStep;

        // Intialize stepper for number of bars in plot
        BarStepper.Init ( ( m_rectPlot.right - m_rectPlot.left), iNumCounters );
        iHitStep = BarStepper.PrevStepNum ( xPos - m_rectPlot.left );

        assert ( -1 != iHitStep );

        // Find the counter displayed in the hit step.        
        for ( iCount = 0;
            ( iCount < iHitStep ) && ( pItem != NULL );
            iCount++ ) {
            
            pItem = pItem->Next();        
        }
    }
    
    return pItem;
}

PCGraphItem 
CGraphDisp::GetItem( INT xPos, INT yPos )
{
    PCGraphItem pReturn = NULL;

    if ( ( m_pGraph->Options.iVertMax > m_pGraph->Options.iVertMin) 
        && ( yPos >= m_rectPlot.top ) && ( yPos <= m_rectPlot.bottom ) 
        && ( xPos >= m_rectPlot.left ) && ( xPos <= m_rectPlot.right ) ) {

        m_pCtrl->LockCounterData();
        
        if ( LINE_GRAPH == m_pGraph->Options.iDisplayType ) {
            assert ( SHRT_MAX >= xPos ); 
            assert ( SHRT_MAX >= yPos );
            
            pReturn = GetItemInLineGraph( (SHORT)xPos, (SHORT)yPos );
        } else if ( BAR_GRAPH == m_pGraph->Options.iDisplayType ) {
            assert ( SHRT_MAX >= xPos ); 
            assert ( SHRT_MAX >= yPos );
            
            pReturn = GetItemInBarGraph( (SHORT)xPos, (SHORT)yPos );
        }

        m_pCtrl->UnlockCounterData();

    }

    return pReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\grphdsp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphdsp.h

Abstract:

    Header file for the sysmon.ocx graph display.

--*/

#ifndef _GRPHDSP_H_
#define _GRPHDSP_H_


class CSysmonControl;

class CGraphDisp
{
//friend LRESULT APIENTRY GraphDispWndProc (HWND hWnd,
//                                     UINT uiMsg,
//                                     WPARAM wParam,
//                                     LPARAM lParam);

public:
    void ChangeFont     ( HDC );
    static BOOL RegisterWndClass (HINSTANCE hInst) ;
    CGraphDisp          ( void );
    ~CGraphDisp         ( void);
    BOOL Init           ( CSysmonControl *pCtrl, PGRAPHDATA pGraph ) ;

    void Update         ( HDC );
    void Draw           ( HDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, PRECT prcUpdate);
    void HiliteItem     ( PCGraphItem pItem );
    void SizeComponents ( HDC hDC, PRECT pRect );
    void GetPlotRect    ( PRECT pRect ) { *pRect = m_rectPlot; } 

    void SetBarConfigChanged ( BOOL bChanged = TRUE ) { m_bBarConfigChanged = bChanged; };

    PCGraphItem GetItem ( INT xPos, INT yPos ); 

private:

    enum eGraphDisplayConstant {
        eHitRegion = 4
    };

    void DrawTimeLine       ( HDC hDC, INT x);
    void DrawStartStopLine  ( HDC hDC, INT x);
    void StartUpdate        ( HDC hDC, BOOL fMetafile, BOOL fEntire, INT xLeft, INT xRight, BOOL bFill = TRUE );
    void FinishUpdate       ( HDC hDC, BOOL fMetafile );
    void DrawGrid           ( HDC hDC, INT iLeft, INT iRight);
    void PlotBarGraph       ( HDC hDC , BOOL fUpdate);
    void PlotData           ( HDC hDC, INT iHistIndx, INT nSteps, CStepper *pStepper );
    void UpdateTimeBar      ( HDC, BOOL bPlotData = TRUE );

    PCGraphItem GetItemInLineGraph  ( SHORT xPos, SHORT yPos ); 
    PCGraphItem GetItemInBarGraph  ( SHORT xPos, SHORT yPos ); 

    INT     RGBToLightness  ( COLORREF );
    BOOL    CalcYPosition  ( PCGraphItem pItem, INT iHistIndex, BOOL bLog, INT y[3] );
 

    PGRAPHDATA      m_pGraph;
    CSysmonControl  *m_pCtrl;
    RECT            m_rect;
    RECT            m_rectPlot;
    CStepper        m_GridStepper;
    HFONT           m_hFontVertical;
    PCGraphItem     m_pHiliteItem;
    HRGN            m_rgnClipSave;
    BOOL            m_bBarConfigChanged;

    // Min, Max and PixelScale are used for plot, hit test.
    double          m_dMin;
    double          m_dMax;
    double          m_dPixelScale;


    COLORREF        m_clrCurrentTimeBar;
    COLORREF        m_clrCurrentGrid;
    HPEN            m_hPenTimeBar;
    HPEN            m_hPenGrid;

};

typedef CGraphDisp *PGRAPHDISP;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\grphprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphprop.h

Abstract:

    Header file for the graph property page class.

--*/

#ifndef _GRPHPROP_H_
#define _GRPHPROP_H_

#include "smonprop.h"

// Dialog Controls
#define IDD_GRAPH_PROPP_DLG     300
#define IDC_VERTICAL_GRID       101
#define IDC_HORIZONTAL_GRID     102
#define IDC_VERTICAL_LABELS     103
#define IDC_VERTICAL_MAX        104
#define IDC_VERTICAL_MIN        105
#define IDC_YAXIS_TITLE         106             
#define IDC_GRAPH_TITLE         107

#define MAX_SCALE_DIGITS    9
#define MAX_VERTICAL_SCALE  999999999
#define MIN_VERTICAL_SCALE  0

#define MAX_TITLE_CHARS     128

// Graph property page class
class CGraphPropPage : public CSysmonPropPage
{
    public:
                CGraphPropPage(void);
        virtual ~CGraphPropPage(void);

    protected:

        virtual BOOL GetProperties(void);   //Read current properties
        virtual BOOL SetProperties(void);   //Set new properties
        virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual BOOL InitControls(void);   //Initialize dialog controls
    
    private:

        // Properties 
        VARIANT_BOOL    m_bLabels;
        VARIANT_BOOL    m_bVertGrid;
        VARIANT_BOOL    m_bHorzGrid;
        INT     m_iVertMax;
        INT     m_iVertMin;
        LPWSTR  m_pszYaxisTitle;
        LPWSTR  m_pszGraphTitle;

        // Property change flags
        BOOL  m_bLabelsChg;
        BOOL  m_bVertGridChg;
        BOOL  m_bHorzGridChg;
        BOOL  m_bVertMaxChg;
        BOOL  m_bVertMinChg;
        BOOL  m_bYaxisTitleChg;
        BOOL  m_bGraphTitleChg;

        // Error flags
        INT m_iErrVertMin;
        INT m_iErrVertMax;

};
typedef CGraphPropPage *PCGraphPropPage;

// {C3E5D3D3-1A03-11cf-942D-008029004347}
DEFINE_GUID(CLSID_GraphPropPage, 
        0xc3e5d3d3, 0x1a03, 0x11cf, 0x94, 0x2d, 0x0, 0x80, 0x29, 0x0, 0x43, 0x47);

#endif //_GRPHPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\grphitem.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphitem.h

Abstract:

    <abstract>

--*/

#ifndef _GRPHITEM_H_
#define _GRPHITEM_H_

class CSysmonControl;

//
// Persistant data structure
//

typedef struct
{
    COLORREF    m_rgbColor;
    INT32       m_iWidth;
    INT32       m_iStyle;       
    INT32       m_iScaleFactor;
    INT32       m_nPathLength;
} GRAPHITEM_DATA3;

typedef struct
{
    double      m_dMin;
    double      m_dMax;
    double      m_dAvg;
    FILETIME    m_LastTimeStamp;   
} LOG_ENTRY_DATA, *PLOG_ENTRY_DATA;

//
// Graphitem Class
// 
class CGraphItem : public ICounterItem
{
public:
    class  CCounterNode*    m_pCounter;
    class  CInstanceNode*   m_pInstance;
    class  CGraphItem*      m_pNextItem;
    PDH_COUNTER_INFO        m_CounterInfo;        
    HCOUNTER                m_hCounter;
    double                  m_dScale;
    PLOG_ENTRY_DATA         m_pLogData;
    BOOLEAN                 m_bUpdateLog;

public:
    BOOLEAN                 m_fLocalMachine;
    BOOLEAN                 m_fGenerated;

    CGraphItem(CSysmonControl *pCtrl);
    ~CGraphItem(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICounterItem methods
    STDMETHODIMP    put_Color(OLE_COLOR);
    STDMETHODIMP    get_Color(OLE_COLOR*);
    STDMETHODIMP    put_Width(INT);
    STDMETHODIMP    get_Width(INT*) ;
    STDMETHODIMP    put_LineStyle(INT) ;
    STDMETHODIMP    get_LineStyle(INT*) ;
    STDMETHODIMP    put_ScaleFactor(INT) ;
    STDMETHODIMP    get_ScaleFactor(INT*) ;
    STDMETHODIMP    get_Path(BSTR*) ;
    STDMETHODIMP    get_Value(double*) ;

    STDMETHODIMP GetValue(double *pdValue,  LONG *plStatus) ;
    STDMETHODIMP GetStatistics(double *pdMax, double *pdMin, double *pdAvg,
                            LONG *plStatus) ;

    // methods not exposed by ICounterItem interface
    static HRESULT NullItemToStream(LPSTREAM pIStream, INT iVersMaj, INT iVersMin);

    HPEN    Pen(void);
    HBRUSH  Brush(void);
    double  Scale(void) { return m_dScale; }
    HCOUNTER Handle(void) { return m_hCounter; }

    CInstanceNode *Instance(void) { return m_pInstance; }
    CCounterNode  *Counter(void) { return m_pCounter; }
    CObjectNode  *Object(void) { return m_pInstance->m_pObject; }
    CMachineNode *Machine(void) { return m_pInstance->m_pObject->m_pMachine; }
    CCounterTree *Tree(void) { return m_pInstance->m_pObject->m_pMachine->m_pCounterTree; }
    CGraphItem *Next(void);
    
    void    Delete(BOOL bPropagateUp);

    BOOL    CalcRequiresMultipleSamples ( void );

    HRESULT LoadFromPropertyBag ( 
                IPropertyBag*,
                IErrorLog*,
                INT iIndex,
                INT iVersMaj, 
                INT iVersMin,
                INT iSampleCount );
    
    HRESULT SaveToPropertyBag ( 
                IPropertyBag*,
                INT iIndex,
                BOOL bUserMode,
                INT iVersMaj, 
                INT iVersMin );

    HRESULT SaveToStream(LPSTREAM pIStream, BOOL fWildCard, INT iVersMaj, INT iVersMin);

    HRESULT AddToQuery(HQUERY hQuery);
    HRESULT RemoveFromQuery();

    void        ClearHistory( void );

    void        UpdateHistory(BOOL bValidSample);
    PDH_STATUS  HistoryValue(INT iIndex, double *pdValue, DWORD *pdwStatus);
    PDH_STATUS  GetLogEntry( const INT iIndex, double *dMin, double *dMax, double *dAvg, 
                            DWORD *pdwStatus);
    PDH_STATUS  GetLogEntryTimeStamp (
                            const INT iIndex, 
                            LONGLONG& rLastTimeStamp,
                            DWORD *pdwStatus);

    void  SetLogEntry( 
            const INT iIndex, 
            const double dMin, 
            const double dMax, 
            const double dAvg);

    void  SetLogEntryTimeStamp( const INT iIndex, const FILETIME& rLastTimeStamp );

    void  SetLogStats(double dMin, double dMax, double dAvg, LONG lStatus )
                { m_dLogMin = dMin; m_dLogMax = dMax; m_dLogAvg = dAvg; m_lLogStatsStatus = lStatus; }


private:
    CSysmonControl  *m_pCtrl;
    void    InvalidatePen(void);
    void    InvalidateBrush(void);
    LPWSTR  FormPath(BOOL fWildCard);

    // Used by LoadFromPropertyBag
    void    SetStatistics ( double dMax, double dMin, double dAvg, LONG lStatus );
    void    SetHistoryValue ( INT iIndex, double dValue );
  
    HRESULT GetNextValue ( WCHAR*& pszNext, double& dValue );
    
    ULONG   m_cRef;
    HPEN    m_hPen;
    HBRUSH  m_hBrush;

    COLORREF    m_rgbColor;
    INT         m_iWidth;
    INT         m_iStyle;       // No change in implementation
    INT         m_iScaleFactor;

    double  m_dLogMin;
    double  m_dLogMax;
    double  m_dLogAvg;
    LONG    m_lLogStatsStatus;

    PCImpIDispatch  m_pImpIDispatch;
    PPDH_RAW_COUNTER      m_pRawCtr;

    // Used by LoadFromPropertyBag
    double* m_pFmtCtr;
    double  m_dFmtMin;
    double  m_dFmtMax;
    double  m_dFmtAvg;
    long    m_lFmtStatus;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\grphitem.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphitem.cpp

Abstract:

    <abstract>

--*/


#ifndef _LOG_INCLUDE_DATA 
#define _LOG_INCLUDE_DATA 0
#endif

#include "polyline.h"
#include <strsafe.h>
#include <math.h>
#include <limits.h>     // for INT_MAX 
#include <pdhp.h>
#include "visuals.h"
#include "grphitem.h"
#include "unihelpr.h"
#include "utils.h"
#include "pdhmsg.h"

#define MAX_DOUBLE_TEXT_SIZE (64)

// From Pdh calc functions
#define PERF_DOUBLE_RAW  (PERF_SIZE_DWORD | 0x00002000 | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL)

// Construction/Destruction
CGraphItem::CGraphItem (
    CSysmonControl  *pCtrl )
:   m_cRef ( 0 ),
    m_pCtrl ( pCtrl ),
    m_hCounter ( NULL ),
    m_hPen ( NULL ),
    m_hBrush ( NULL ),
    m_pCounter ( NULL ),
    m_pInstance ( NULL),
    m_pRawCtr ( NULL ),
    m_pFmtCtr ( NULL ),
    m_dFmtMax ( 0 ),
    m_dFmtMin ( 0 ),
    m_dFmtAvg ( 0 ),
    m_lFmtStatus ( 0 ),

    m_dLogMin ( 0 ),
    m_dLogMax ( 0 ),
    m_dLogAvg ( 0 ),
    m_lLogStatsStatus ( PDH_CSTATUS_INVALID_DATA ),

    m_pLogData ( NULL ),
    m_pImpIDispatch ( NULL ),

    m_rgbColor ( RGB(0,0,0) ),
    m_iWidth ( 1 ),
    m_iStyle ( 0 ),      
    m_iScaleFactor ( INT_MAX ),
    m_dScale ( (double)1.0 ),

    m_pNextItem ( NULL ),
    m_bUpdateLog ( TRUE ),
    m_fGenerated ( FALSE )
/*++

Routine Description:

    Constructor for the CGraphItem class. It initializes the member variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ZeroMemory ( &m_CounterInfo, sizeof (m_CounterInfo ) );
    m_CounterInfo.CStatus = PDH_CSTATUS_INVALID_DATA;
}


CGraphItem::~CGraphItem (
    VOID
    )
/*++

Routine Description:

    Destructor for the CGraphItem class. It frees any objects, storage, and
    interfaces that were created. If the item is part of a query it is removed
    from the query.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (m_hCounter != NULL)
        RemoveFromQuery();

    if (m_hPen != NULL)
        DeleteObject(m_hPen);

    if (m_hBrush != NULL)
        DeleteObject(m_hBrush);

    if (m_pImpIDispatch != NULL)
        delete m_pImpIDispatch;
}

HRESULT
CGraphItem::SaveToStream (
    IN LPSTREAM pIStream,
    IN BOOL fWildCard,
    IN INT iVersMaj, 
    IN INT // iVersMin 
    )
/*++

Routine Description:

    This function writes the properties of the graph item into the provided stream.

Arguments:

    pIStream - Pointer to stream interface
    fWildCard - 
    iVersMaj - Major version 

Return Value:

    HRESULT - S_OK or stream error

--*/
{
    LPWSTR  szPath = NULL;
    LPWSTR  szBuf = NULL;
    DWORD   cchBufLen;
    LPWSTR  pszTranslatedPath;
    HRESULT hr = S_OK;
    PDH_STATUS pdhStatus; 
    
    //
    // Get the full path of the counter. (machine\object\instance\counter format)
    //
    szPath = FormPath( fWildCard );
    if (szPath == NULL) {
        return E_OUTOFMEMORY;
    }

    pszTranslatedPath = szPath;

    //
    // Preallocate a buffer for locale path
    //
    cchBufLen = PDH_MAX_COUNTER_PATH + 1;
    szBuf = new WCHAR [ cchBufLen ];
    if (szBuf != NULL) {
        //
        // Translate counter name from Localization into English
        //
        pdhStatus = PdhTranslate009Counter(
                        szPath,
                        szBuf,
                        &cchBufLen);

        if (pdhStatus == PDH_MORE_DATA) {
            delete [] szBuf;
            szBuf = new WCHAR [ cchBufLen ];
            if (szBuf != NULL) {

                pdhStatus = PdhTranslate009Counter(
                                szPath,
                                szBuf,
                                &cchBufLen);
            }
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pszTranslatedPath = szBuf;
        }
    }

    if ( SMONCTRL_MAJ_VERSION == iVersMaj ) {
        GRAPHITEM_DATA3 ItemData;

        // Move properties to storage structure
        ItemData.m_rgbColor = m_rgbColor;
        ItemData.m_iWidth = m_iWidth;
        ItemData.m_iStyle = m_iStyle;
        ItemData.m_iScaleFactor = m_iScaleFactor;
 
        assert( 0 < lstrlen(pszTranslatedPath ) );
        
        ItemData.m_nPathLength = lstrlen(pszTranslatedPath);
        
        // Write structure to stream
        hr = pIStream->Write(&ItemData, sizeof(ItemData), NULL);
        if (FAILED(hr)) {
            goto ErrorOut;
        }

        // Write path name to stream
        hr = pIStream->Write(pszTranslatedPath, ItemData.m_nPathLength*sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            goto ErrorOut;
        }
    }

ErrorOut:
    if (szBuf != NULL) {
        delete [] szBuf;
    }

    if (szPath != NULL) {
        delete [] szPath;
    }

    return hr;
}

HRESULT
CGraphItem::NullItemToStream (
    IN LPSTREAM pIStream,
    IN INT,// iVersMaj, 
    IN INT // iVersMin
    )
/*++

Routine Description:

    NulItemToStream writes a graph item structiure with a null path name
    to the stream. This is used to marked the end of the counter data in
    the control's saved state.

Arguments:

    pIStream - Pointer to stream interface

Return Value:

    HRESULT - S_OK or stream error

--*/
{
    GRAPHITEM_DATA3 ItemData;

    // Zero path length, other fields needn't be initialized
    ItemData.m_nPathLength = 0;

    // Write structure to stream
    return pIStream->Write(&ItemData, sizeof(ItemData), NULL);
}

HRESULT
CGraphItem::SaveToPropertyBag (
    IN IPropertyBag* pIPropBag,
    IN INT iIndex,
    IN BOOL bUserMode,
    IN INT, // iVersMaj, 
    IN INT // iVersMin 
    )
/*++

Routine Description:

    SaveToPropertyBag writes the graph item's properties to the provided property bag
    interface.  The history data is saved as part of the properties.

Arguments:

    pIPropBag - Pointer to property bag interface
    fWildCard
    iVersMaj
    iVersMin

Return Value:

    HRESULT - S_OK or property bag error

--*/
{
    HRESULT hr = S_OK;

    LPWSTR  szPath = NULL;
    PHIST_CONTROL pHistCtrl;
    VARIANT vValue;
    WCHAR   szCounterName[16];
    WCHAR   szPropertyName[16+16];
    DWORD   dwCounterNameLength;
    DWORD   dwRemainingLen;
    LPWSTR  pszNext = NULL;
    LPWSTR  szBuf = NULL;
    DWORD   cchBufLen;
    LPWSTR  pszTranslatedPath;
    PDH_STATUS pdhStatus;

    //
    // Get the full path of the counter. (machine\object\instance\counter format)
    //
    szPath = FormPath( FALSE );
    if (szPath == NULL) {
        return E_OUTOFMEMORY;
    }

    pszTranslatedPath = szPath;

    //
    // Preallocate a buffer for locale path
    //
    cchBufLen = PDH_MAX_COUNTER_PATH + 1;
    szBuf = new WCHAR [ cchBufLen ];
    if (szBuf != NULL) {
        //
        // Translate counter name from Localization into English
        //
        pdhStatus = PdhTranslate009Counter(
                        szPath,
                        szBuf,
                        &cchBufLen);

        if (pdhStatus == PDH_MORE_DATA) {
            delete [] szBuf;
            szBuf = new WCHAR [ cchBufLen ];
            if (szBuf != NULL) {

                pdhStatus = PdhTranslate009Counter(
                                szPath,
                                szBuf,
                                &cchBufLen);
            }
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pszTranslatedPath = szBuf;
        }
    }

    //
    // Write properties
    //

    StringCchPrintf( szCounterName, 16, L"%s%05d.", L"Counter", iIndex );
    dwCounterNameLength = lstrlen (szCounterName);

    //
    // Save the counter path into property bag
    //
    StringCchCopy(szPropertyName, 32, szCounterName);
    pszNext = szPropertyName + dwCounterNameLength;
    dwRemainingLen = 32 - dwCounterNameLength;
    StringCchCopy(pszNext, dwRemainingLen, L"Path" );
    
    hr = StringToPropertyBag (
            pIPropBag,
            szPropertyName,
            pszTranslatedPath );


    //
    // Free the temporary buffer never to be used any more.
    //
    if (szBuf != NULL) {
        delete [] szBuf;
    }

    if (szPath != NULL) {
        delete [] szPath;
    }

    //
    // Write visual properties
    //
    if ( SUCCEEDED( hr ) ) {
        StringCchCopy(pszNext, dwRemainingLen, L"Color" );
        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, m_rgbColor );
    }

    if ( SUCCEEDED( hr ) ) {
        StringCchCopy(pszNext, dwRemainingLen, L"Width" );

        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, m_iWidth );
    }

    if ( SUCCEEDED( hr ) ) {
        StringCchCopy(pszNext, dwRemainingLen, L"LineStyle" );

        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, m_iStyle );
    }

    if ( SUCCEEDED( hr ) ) {
        INT iLocalFactor = m_iScaleFactor;
        
        StringCchCopy(pszNext, dwRemainingLen, L"ScaleFactor" );
        
        if ( INT_MAX == iLocalFactor ) {
            // Save actual scale factor in case the counter cannot be 
            // validated when the property bag file is opened.
            // lDefaultScale is 0 if never initialized.
            iLocalFactor = m_CounterInfo.lDefaultScale;
        }
                    
        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, iLocalFactor );
    }

    //
    // Write history data only if live display, data exists and not in design mode.  
    // Log data is rebuilt from the log file.  
    //
    pHistCtrl = m_pCtrl->HistoryControl();

    if ( ( pHistCtrl->nSamples > 0) 
#if !_LOG_INCLUDE_DATA 
        && ( !pHistCtrl->bLogSource )
#endif
        && bUserMode ) {

        LPWSTR pszData = NULL;
        DWORD dwMaxStrLen;
        
        // Add 1 for null.
        dwMaxStrLen = (pHistCtrl->nMaxSamples * MAX_DOUBLE_TEXT_SIZE) + 1;
        
        pszData = new WCHAR[ dwMaxStrLen ];      
        
        if  ( NULL == pszData ) {
            hr = E_OUTOFMEMORY;
        }

        // Write the current statistics.
        if ( SUCCEEDED(hr) ) {

            double dMin;
            double dMax;
            double dAvg;
            LONG lStatus;

            hr = GetStatistics ( &dMax, &dMin, &dAvg, &lStatus );

            if (SUCCEEDED(hr) && IsSuccessSeverity(lStatus)) {
                StringCchCopy(pszNext, dwRemainingLen, L"Minimum" );

                hr = DoubleToPropertyBag ( pIPropBag, szPropertyName, dMin );

                if ( SUCCEEDED(hr) ) {
                    StringCchCopy(pszNext, dwRemainingLen, L"Maximum" );

                    hr = DoubleToPropertyBag ( pIPropBag, szPropertyName, dMax );
                }
                if ( SUCCEEDED(hr) ) {
                    StringCchCopy(pszNext, dwRemainingLen, L"Average" );

                    hr = DoubleToPropertyBag ( pIPropBag, szPropertyName, dAvg );
                }
                if ( SUCCEEDED(hr) ) {
                    StringCchCopy(pszNext, dwRemainingLen, L"StatisticStatus" );

                    hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, lStatus );
                }
            }
        }
        
        if ( SUCCEEDED(hr) ) {

            INT i;
            HRESULT hrConvert = S_OK;
            double  dblValue;
            DWORD   dwTmpStat;
            DWORD   dwCurrentStrLength;
            DWORD   dwDataLength;
            LPWSTR  pszDataNext;

            pszData[0] = L'\0';
            dwCurrentStrLength = 0;
            pszDataNext = pszData;

            for ( i = 0; 
                  ( S_OK == hrConvert ) && ( i < pHistCtrl->nSamples ); 
                  i++ ) {
                
                if ( ERROR_SUCCESS != HistoryValue(i, &dblValue, &dwTmpStat) ) {
                    dblValue = -1.0;
                } else if (!IsSuccessSeverity(dwTmpStat)) {
                    dblValue = -1.0;
                }


                VariantInit( &vValue );
                vValue.vt = VT_R8;
                vValue.dblVal = dblValue;

                hrConvert = VariantChangeTypeEx( &vValue, 
                                                 &vValue, 
                                                 LCID_SCRIPT, 
                                                 VARIANT_NOUSEROVERRIDE, 
                                                 VT_BSTR );
                dwDataLength = SysStringLen(vValue.bstrVal);
    
                //
                // If we dont have enough memory, reallocate it
                //
                // Extra WCHAR for NULL terminator
                if ( dwDataLength + dwCurrentStrLength + 1> dwMaxStrLen ) {
                    WCHAR* pszNewData;
                    
                    dwMaxStrLen *= 2;

                    pszNewData = new WCHAR[ dwMaxStrLen ];      
        
                    if  ( NULL != pszNewData ) {
                        memcpy ( pszNewData, pszData, dwCurrentStrLength * sizeof (WCHAR) );
                        delete [] pszData;
                        pszData = pszNewData;
                        pszDataNext = pszData;
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if ( SUCCEEDED(hr)) {
                    if ( i > 0 ) {
                        *pszDataNext = L'\t';
                        dwCurrentStrLength += 1;       // char count for L"\t";
                        pszDataNext ++;
                    }

                    StringCchCopy(pszDataNext, dwMaxStrLen - dwCurrentStrLength, vValue.bstrVal);
                    dwCurrentStrLength += dwDataLength;
                    pszDataNext += dwDataLength;
                }

                VariantClear( &vValue );
            }
        }

        StringCchCopy(pszNext, 32 - dwCounterNameLength, L"Data" );

        hr = StringToPropertyBag ( pIPropBag, szPropertyName, pszData );
                    
        if ( NULL != pszData ) {
            delete [] pszData;
        }
    }

    return hr;
}

HRESULT
CGraphItem::LoadFromPropertyBag (
    IN IPropertyBag* pIPropBag,
    IN IErrorLog*   pIErrorLog,
    IN INT iIndex,
    IN INT, // iVersMaj, 
    IN INT, // iVersMin 
    IN INT  iSampleCount
    )
/*++

Routine Description:

    LoadFromPropertyBag loads the graph item's properties from the provided property bag
    interface.  
Arguments:

    pIPropBag - Pointer to property bag interface
    iVersMaj
    iVersMin

Return Value:

    HRESULT - S_OK or property bag error

--*/
{
    HRESULT hr = S_OK;

    WCHAR   szCounterName[16];
    WCHAR   szPropertyName[16+16];
    OLE_COLOR clrValue;
    INT     iValue;
    LPWSTR  pszData = NULL;
    int     iBufSizeCurrent = 0;
    int     iBufSize;
    LPWSTR  pszNext;
    DWORD   dwCounterNameLength;


    StringCchPrintf( szCounterName, 16, L"%s%05d.", L"Counter", iIndex );
    dwCounterNameLength = lstrlen (szCounterName);

    // Read visual properties

    assert( 32 > dwCounterNameLength);

    StringCchCopy(szPropertyName, 32, szCounterName );
    pszNext = szPropertyName + dwCounterNameLength;

    StringCchCopy(pszNext, 32 - dwCounterNameLength, L"Color" );
    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, clrValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_Color ( clrValue );
    }

    StringCchCopy(pszNext, 32 - dwCounterNameLength, L"Width" );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, iValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_Width ( iValue );
    }

    StringCchCopy(pszNext, 32 - dwCounterNameLength, L"LineStyle" );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, iValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_LineStyle ( iValue );
    }
    
    StringCchCopy(pszNext, 32 - dwCounterNameLength, L"ScaleFactor" );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, iValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_ScaleFactor ( iValue );
    }

    if ( 0 < iSampleCount ) {
                
        if ( NULL != m_pFmtCtr ) {
            delete [] m_pFmtCtr;
        }

        m_pFmtCtr = new double[MAX_GRAPH_SAMPLES];      
    
        if ( NULL == m_pFmtCtr ) {
            hr = E_OUTOFMEMORY;
        } else {
            INT iFmtIndex;

            for (iFmtIndex = 0; iFmtIndex < MAX_GRAPH_SAMPLES; iFmtIndex++ ) {
                m_pFmtCtr[iFmtIndex] = -1.0;
            }
        }

        if ( SUCCEEDED(hr) ) {
            StringCchCopy(pszNext, 32 - dwCounterNameLength, L"Data" );

            iBufSize = iBufSizeCurrent;

            hr = StringFromPropertyBag (
                    pIPropBag,
                    pIErrorLog,
                    szPropertyName,
                    pszData,
                    iBufSize );

            //
            // StringFromPropertyBag return SUCCESS status even if the buffer is too small
            // Design defect??
            //
            if ( SUCCEEDED(hr) && iBufSize > iBufSizeCurrent ) {
                if ( NULL != pszData ) {
                    delete [] pszData;
                }
                pszData = new WCHAR[ iBufSize ]; 

                if ( NULL == pszData ) {
                    hr = E_OUTOFMEMORY;
                } else {
                    pszData[0] = L'\0';
                    
                    iBufSizeCurrent = iBufSize;

                    hr = StringFromPropertyBag (
                            pIPropBag,
                            pIErrorLog,
                            szPropertyName,
                            pszData,
                            iBufSize );
                }
            }
        }        

        // Read the samples in buffer order.
        if ( NULL != pszData && SUCCEEDED ( hr ) ) {
            INT    iDataIndex;
            double dValue = 0;
            WCHAR* pNextData;
            WCHAR* pDataEnd;
            
            pNextData = pszData;
            pDataEnd = pszData + lstrlen(pszData);

            for ( iDataIndex = 0; iDataIndex < iSampleCount; iDataIndex++ ) {
                if ( pNextData < pDataEnd ) {
                    hr = GetNextValue ( pNextData, dValue );
                } else {
                    hr = E_FAIL;
                }

                if ( SUCCEEDED(hr) ) {
                    SetHistoryValue ( iDataIndex, dValue );                    
                } else {
                    SetHistoryValue ( iDataIndex, -1.0 );                    
                    // iSampleCount = 0;
                    // Control loaded fine, just no data.
                    hr = NOERROR;
                }
            }        
        }
        
        if ( NULL != pszData ) {
            delete [] pszData;
        }
        
        // Read the current statistics.
        StringCchCopy(pszNext, 32 - dwCounterNameLength, L"Maximum" );
        hr = DoubleFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, m_dFmtMax );

        StringCchCopy(pszNext, 32 - dwCounterNameLength, L"Minimum" );
        hr = DoubleFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, m_dFmtMin );

        StringCchCopy(pszNext, 32 - dwCounterNameLength, L"Average" );
        hr = DoubleFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, m_dFmtAvg );

        StringCchCopy(pszNext, 32 - dwCounterNameLength, L"StatisticStatus" );
        hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, (INT&)m_lFmtStatus );
    }

    return hr;
}

HRESULT
CGraphItem::AddToQuery (
    IN HQUERY hQuery
    )
/*++

Routine Description:

    AddToQuery adds a counter to the provided query based on the item's
    pathname. It also allocates an array of raw counter value structures for
    holding the counter's sample history.

Arguments:

    hQuery - Handle to query

Return Value:

    Boolean status - TRUE = success

--*/
{
    HCOUNTER    hCounter;
    INT         i;
    HRESULT     hr = NO_ERROR;
    LPWSTR      szPath = NULL;
    DWORD       size;
    PDH_COUNTER_INFO  ci;

    PHIST_CONTROL pHistCtrl = m_pCtrl->HistoryControl();

    // Can't add if already in query
    if (m_hCounter != NULL)
        return E_FAIL;

    //
    // Generate the full path of the counter
    //
    szPath = FormPath( FALSE);
    if (szPath == NULL) {
        return E_FAIL;
    }

    //
    // We use do {} while (0) here to act like a switch statement
    //
    do {
        // Allocate memory for maximum sample count
        if (pHistCtrl->nMaxSamples > 0) {

            // if log data
            if (pHistCtrl->bLogSource) {
    
                // allocate space for formatted values
                m_pLogData =  new LOG_ENTRY_DATA[pHistCtrl->nMaxSamples];
                if (m_pLogData == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                // Clear the statistics
                m_dLogMax = 0.0;
                m_dLogMin = 0.0;
                m_dLogAvg = 0.0;
                m_lLogStatsStatus = PDH_CSTATUS_INVALID_DATA;
            }
            else {
                // else allocate raw value space
                m_pRawCtr = new PDH_RAW_COUNTER[pHistCtrl->nMaxSamples];
                if ( NULL == m_pRawCtr ) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
    
                // Clear all status flags
                for (i=0; i < pHistCtrl->nMaxSamples; i++)
                    m_pRawCtr[i].CStatus = PDH_CSTATUS_INVALID_DATA;
            }
        }

        // Create the counter object

        hr = PdhAddCounter(hQuery, szPath, 0, &hCounter);
        if (IsErrorSeverity(hr)) {
            if (pHistCtrl->bLogSource) {
                delete [] m_pLogData;
                m_pLogData = NULL;
            }
            else {
                delete [] m_pRawCtr;
                m_pRawCtr = NULL;
            }
            break;
        }

        size = sizeof(ci);
        hr = PdhGetCounterInfo (hCounter, FALSE, &size, &ci);

        if (hr == ERROR_SUCCESS)  {
            m_CounterInfo = ci;
            if ( INT_MAX == m_iScaleFactor ) {
                m_dScale = pow ((double)10.0f, (double)ci.lDefaultScale);
            }
        }

        m_hCounter = hCounter;
    } while (0);

    delete [] szPath;
    return hr;
}


HRESULT
CGraphItem::RemoveFromQuery (
    VOID
    )
/*++

Routine Description:

    RemoveFromQuery deletes the item's counter and releases its history array.

Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    // If no counter handle, not attached to query
    if (m_hCounter == NULL)
        return S_FALSE;

    // Delete the counter
    PdhRemoveCounter(m_hCounter);
    m_hCounter = NULL;

    // Free the buffers
    if (m_pLogData) {
        delete [] m_pLogData;
        m_pLogData = NULL;
    }

    if (m_pRawCtr) {
        delete [] m_pRawCtr;
        m_pRawCtr = NULL;
    }

    if (m_pFmtCtr) {
        delete [] m_pFmtCtr;
        m_pFmtCtr = NULL;
    }

    return NOERROR;
}

void
CGraphItem::ClearHistory ( void )
/*++

Routine Description:

    ClearHistory resets the raw counter buffer values to Invalid.

Arguments:
    None.

Return Value:
    None.
--*/
{
    INT i;

    // Clear all status flags
    if ( NULL != m_pRawCtr ) {
        for (i=0; i < m_pCtrl->HistoryControl()->nMaxSamples; i++) {
            m_pRawCtr[i].CStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
}

VOID
CGraphItem::UpdateHistory (
    IN BOOL bValidSample
    )
/*++

Routine Description:

    UpdateHistory reads the raw value for the counter and stores it in the
    history slot specified by the history control.

Arguments:

    bValidSample - True if raw value is available, False if missed sample

Return Value:

    None.

--*/
{
    DWORD   dwCtrType;

    // Make sure there is a counter handle
    if (m_hCounter == NULL)
        return;

    if (bValidSample) {
        // Read the raw value
        if ( NULL != m_pRawCtr ) {
            PdhGetRawCounterValue(m_hCounter, &dwCtrType,
                                &m_pRawCtr[m_pCtrl->HistoryControl()->iCurrent]);
        }
    } else {
        // Mark value failed
        if ( NULL != m_pRawCtr ) {
            m_pRawCtr[m_pCtrl->HistoryControl()->iCurrent].CStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
}

PDH_STATUS
CGraphItem::HistoryValue (
    IN  INT iIndex,
    OUT double *pdValue,
    OUT DWORD *pdwStatus
    )
/*++

Routine Description:

    HistoryValue computes a formated sample value from the selected raw history
    sample. The calculation is actually based on the the specified sample plus
    the preceding sample.

Arguments:
    iIndex - Index of desired sample (0 = current, 1 = previous, ...)
    pdValue - Pointer to return value
    pdwStatus - Pointer to return counter status (PDH_CSTATUS_...)

Return Value:

    Error status

--*/
{
    PDH_STATUS  stat = ERROR_INVALID_PARAMETER;
    INT     iPrevIndex;
    INT     iCurrIndex;
    PDH_FMT_COUNTERVALUE    FmtValue;
    PHIST_CONTROL   pHistCtrl = m_pCtrl->HistoryControl();


    // Check for negative index
    if ( iIndex >= 0 ) {
        // If sample not available from cache or data, return invalid data status
        if ( NULL == m_pFmtCtr 
                && ( m_hCounter == NULL || iIndex + 1 >= pHistCtrl->nSamples ) )
        {
            *pdwStatus = PDH_CSTATUS_INVALID_DATA;
            *pdValue = 0.0;
            stat = ERROR_SUCCESS;
        } else {
        
            // if log source, index back from last valid sample
            if (m_pCtrl->IsLogSource()) {
                *pdValue = m_pLogData[pHistCtrl->nSamples - iIndex].m_dAvg;
                *pdwStatus = (*pdValue >= 0.0) ? PDH_CSTATUS_VALID_DATA : PDH_CSTATUS_INVALID_DATA;
                stat = ERROR_SUCCESS;
            } else {
                // Determine history array index of sample
                iCurrIndex = pHistCtrl->iCurrent - iIndex;
                if (iCurrIndex < 0)
                    iCurrIndex += pHistCtrl->nMaxSamples;

                // Check to determine if loading from property bag
                if ( NULL == m_pFmtCtr ) {
                    // Need previous sample as well
                    if (iCurrIndex > 0)
                        iPrevIndex = iCurrIndex - 1;
                    else
                        iPrevIndex = pHistCtrl->nMaxSamples - 1;

                    // Compute the formatted value
                    if ( NULL != m_pRawCtr ) {
                        stat = PdhCalculateCounterFromRawValue(m_hCounter, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                                &m_pRawCtr[iCurrIndex], &m_pRawCtr[iPrevIndex],
                                                &FmtValue);
                        // Return value and status
                        *pdValue = FmtValue.doubleValue;
                        *pdwStatus = FmtValue.CStatus;
                    } else {
                        stat = ERROR_GEN_FAILURE;       // Todo:  More specific error
                    }
                } else {
                    // Loading from property bag
                    *pdValue = m_pFmtCtr[iCurrIndex];
                    if ( 0 <= m_pFmtCtr[iCurrIndex] ) {
                        *pdwStatus = ERROR_SUCCESS;
                    } else {
                        *pdwStatus = PDH_CSTATUS_INVALID_DATA;
                    }
                    stat = ERROR_SUCCESS;
                }
            }
        }
    }
    return stat;
}

void
CGraphItem::SetHistoryValue (
    IN  INT iIndex,
    OUT double dValue
    )
/*++

Routine Description:

    SetHistoryValue loads a formated sample value for the specified sample index.
    This method is used when loading the control from a property bag.

Arguments:
    iIndex - Index of desired sample (0 = current, 1 = previous, ...)
    dValue - Value

Return Value:

    Error status

--*/
{
    PHIST_CONTROL   pHistCtrl = m_pCtrl->HistoryControl();
    INT iRealIndex;

    // Check for negative index
    if ( (iIndex < 0) || ( iIndex >= pHistCtrl->nMaxSamples) ) {
        return;
    }

    if ( NULL == m_pFmtCtr ) {
        return;
    }
 
    // if log source, index back from last sample
    if (m_pCtrl->IsLogSource()) {
        return;
    } else {
        // Determine history array index of sample
        iRealIndex = pHistCtrl->iCurrent - iIndex;
        if (iRealIndex < 0)
            iRealIndex += pHistCtrl->nSamples;

        m_pFmtCtr[iRealIndex] = dValue;
    }

    return;
}

PDH_STATUS
CGraphItem::GetLogEntry(
    const INT iIndex,
    double *dMin,
    double *dMax,
    double *dAvg,
    DWORD   *pdwStatus
    )
{
    INT iLocIndex = iIndex;

    *dMin = -1.0;
    *dMax = -1.0;
    *dAvg = -1.0;
    *pdwStatus = PDH_CSTATUS_INVALID_DATA;

    if (m_pLogData == NULL)
        return PDH_NO_DATA;

    if (iLocIndex < 0 || iLocIndex >= m_pCtrl->HistoryControl()->nMaxSamples)
        return PDH_INVALID_ARGUMENT;

    // Subtract 1 because array is zero-based
    // Subtract another 1 because ??
    iLocIndex = ( m_pCtrl->HistoryControl()->nMaxSamples - 2 ) - iIndex;

    if (m_pLogData[iLocIndex].m_dMax < 0.0) {
        *pdwStatus = PDH_CSTATUS_INVALID_DATA;
    } else {
        *dMin = m_pLogData[iLocIndex].m_dMin;
        *dMax = m_pLogData[iLocIndex].m_dMax;
        *dAvg = m_pLogData[iLocIndex].m_dAvg;
        *pdwStatus = PDH_CSTATUS_VALID_DATA;
    }

    return ERROR_SUCCESS;
}

PDH_STATUS
CGraphItem::GetLogEntryTimeStamp(
    const INT   iIndex,
    LONGLONG&   rLastTimeStamp,
    DWORD       *pdwStatus
    )
{
    INT iLocIndex = iIndex;

    rLastTimeStamp = 0;
    *pdwStatus = PDH_CSTATUS_INVALID_DATA;

    if (m_pLogData == NULL)
        return PDH_NO_DATA;

    if (iIndex < 0 || iIndex >= m_pCtrl->HistoryControl()->nMaxSamples)
        return PDH_INVALID_ARGUMENT;

    if ( ( MIN_TIME_VALUE == *((LONGLONG*)&m_pLogData[iLocIndex].m_LastTimeStamp) )
            || ( 0 > *((LONGLONG*)&m_pLogData[iLocIndex].m_dMax) ) ) {
        *pdwStatus = PDH_CSTATUS_INVALID_DATA;
    } else {            
        *pdwStatus = PDH_CSTATUS_VALID_DATA;
    }

    rLastTimeStamp = *((LONGLONG*)&m_pLogData[iLocIndex].m_LastTimeStamp);

    return ERROR_SUCCESS;
}

void
CGraphItem::SetLogEntry(
    const INT iIndex,
    const double dMin,
    const double dMax,
    const double dAvg )
{  
    if (m_pLogData) {
        m_pLogData[iIndex].m_dMin = dMin;
        m_pLogData[iIndex].m_dMax = dMax;                         
        m_pLogData[iIndex].m_dAvg = dAvg;
    }
}

void
CGraphItem::SetLogEntryTimeStamp (
    const INT iIndex,
    const FILETIME& rLastTimeStamp )
{  
    if (m_pLogData) {
        m_pLogData[iIndex].m_LastTimeStamp.dwLowDateTime = rLastTimeStamp.dwLowDateTime;
        m_pLogData[iIndex].m_LastTimeStamp.dwHighDateTime = rLastTimeStamp.dwHighDateTime;
    }
}


HRESULT
CGraphItem::GetValue(
    OUT double *pdValue,
    OUT long *plStat
    )
/*++

Routine Description:

    get_Value returns the most recent sample value for the counter.

Arguments:
    pdValue - Pointer to returned value
    dlStatus - Pointer to returned counter status (PDH_CSTATUS_...)

Return Value:

    HRESULT

--*/
{
    DWORD   dwTmpStat;

    // Convert PDH status to HRESULT
    if (HistoryValue(0, pdValue, &dwTmpStat) != 0)
        return E_FAIL;

    *plStat = dwTmpStat;
    return NOERROR;
}


HRESULT
CGraphItem::GetStatistics (
    OUT double *pdMax,
    OUT double *pdMin,
    OUT double *pdAvg,
    OUT LONG  *plStatus
    )
/*++

Routine Description:

    GetStatistics computes the max, min, and average values for the sample
    history.

Arguments:

    pdMax - Pointer to returned max value
    pdMax - Pointer to returned min value
    pdMax - Pointer to returned average value
    plStatus - Pointer to return counter status (PDH_CSTATUS_...)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    PDH_STATUS  stat = ERROR_SUCCESS;
    PDH_STATISTICS  StatData;
    INT     iFirst;
    PHIST_CONTROL pHistCtrl;

    // If no data collected, return invalid data status
    if ( NULL == m_hCounter ) {
        *plStatus = PDH_CSTATUS_INVALID_DATA;
    } else {
        if (m_pCtrl->IsLogSource()) {

            if (m_pLogData && PDH_CSTATUS_VALID_DATA == m_lLogStatsStatus ) {
                *pdMax = m_dLogMax;
                *pdMin = m_dLogMin;
                *pdAvg = m_dLogAvg;
            } else {
                *pdMax = 0.0;
                *pdMin = 0.0;
                *pdAvg = 0.0;
            }
            *plStatus = m_lLogStatsStatus;
        } else {

            if ( NULL == m_pFmtCtr ) {
                pHistCtrl = m_pCtrl->HistoryControl();

                ZeroMemory ( &StatData, sizeof ( PDH_STATISTICS ) );

                // Determine index of oldest sample
                if (pHistCtrl->iCurrent < pHistCtrl->nSamples - 1) {
                    iFirst = pHistCtrl->iCurrent + 1;
                } else {
                    iFirst = 0;
                }

                // Compute statistics over all samples
                //  Note that max sample count is passed (i.e., buffer length)
                //  not the number of actual samples
                if ( NULL != m_pRawCtr ) {
                    stat = PdhComputeCounterStatistics (m_hCounter, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                            iFirst, pHistCtrl->nMaxSamples, m_pRawCtr, &StatData );
                    if ( 0 != stat )
                        hr = E_FAIL;
                } else {
                    hr = E_FAIL;
                }
                
                if ( SUCCEEDED ( hr ) ) {
                    *plStatus = StatData.mean.CStatus;
                    *pdMin = StatData.min.doubleValue;
                    *pdMax = StatData.max.doubleValue;
                    *pdAvg = StatData.mean.doubleValue;
                }
            } else {
                // Data is cached from property bag.
                *pdMax = m_dFmtMax;
                *pdMin = m_dFmtMin;
                *pdAvg = m_dFmtAvg;
                *plStatus = m_lFmtStatus;
            }
        }
    }

    return hr;
}

void
CGraphItem::SetStatistics (
    IN double dMax,
    IN double dMin,
    IN double dAvg,
    IN LONG   lStatus
    )
/*++

Routine Description:

    SetStatistics sets the max, min, and average values for the sample
    history.  It is used by LoadFromPropertyBag only.

Arguments:

    dMax - max value
    dMin - min value
    dAvg - average value
    lStatus - counter status (PDH_CSTATUS_...)

Return Value:

    HRESULT

--*/
{
    if (!m_pCtrl->IsLogSource()) {
        m_dFmtMax = dMax;
        m_dFmtMin = dMin;
        m_dFmtAvg = dAvg;
        m_lFmtStatus = lStatus;
    }
}


/*
 * CGraphItem::QueryInterface
 * CGraphItem::AddRef
 * CGraphItem::Release
 */

STDMETHODIMP CGraphItem::QueryInterface(
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    try {
        *ppv = NULL;

        if (riid == IID_ICounterItem || riid == IID_IUnknown) {
            *ppv = this;
        } 
        else if (riid == DIID_DICounterItem) {
            if (m_pImpIDispatch == NULL) {
                m_pImpIDispatch = new CImpIDispatch(this, this);
                if (m_pImpIDispatch == NULL) {
                    hr = E_OUTOFMEMORY;
                }
                else {
                    m_pImpIDispatch->SetInterface(DIID_DICounterItem, this);
                    *ppv = m_pImpIDispatch;
                }

            } else {
                *ppv = m_pImpIDispatch;
            }
        } else {
            hr = E_NOINTERFACE;
        }

        //
        // So far everything is OK, add reference and return it.
        //
        if (*ppv != NULL) {
            ((LPUNKNOWN)*ppv)->AddRef();
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG) CGraphItem::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CGraphItem::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// Get/Put Color
STDMETHODIMP CGraphItem::put_Color (
    IN OLE_COLOR Color
    )
{
    COLORREF rgbColor;
    HRESULT  hr;

    hr = OleTranslateColor(Color, NULL, &rgbColor);    

    if ( S_OK == hr ) {
        m_rgbColor = rgbColor;

        InvalidatePen();
        InvalidateBrush();
    }

    return hr;
}

STDMETHODIMP CGraphItem::get_Color (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = S_OK;

    try {
         *pColor = m_rgbColor;
    } catch (...) {
         hr = E_POINTER;
    }

    return hr;
}

// Get/Put Width
STDMETHODIMP CGraphItem::put_Width (
    IN INT iWidthInPixels)
{
    HRESULT hr = S_OK;

    if ( ( iWidthInPixels > 0 ) && (iWidthInPixels <= NumWidthIndices() ) ) {
        m_iWidth = iWidthInPixels;
        
        InvalidatePen();
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CGraphItem::get_Width (
    OUT INT* piWidthInPixels
    )
{
    HRESULT hr = S_OK;

    try {
        *piWidthInPixels = m_iWidth;
    } catch (...) {
         hr = E_POINTER;
    }

    return hr;
}

// Get/Put Line Style
STDMETHODIMP CGraphItem::put_LineStyle (
    IN INT iLineStyle
    )
{
    HRESULT hr = S_OK;

    if ( ( iLineStyle >= 0 ) && (iLineStyle < NumStyleIndices() ) ) {
        m_iStyle = iLineStyle;
        InvalidatePen();
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CGraphItem::get_LineStyle (
    OUT INT* piLineStyle
    )
{
    HRESULT hr = S_OK;

    try {
        *piLineStyle = m_iStyle;
    } catch (...) {
         hr = E_POINTER;
    }

    return hr;
}

// Get/Put Scale
STDMETHODIMP CGraphItem::put_ScaleFactor (
    IN INT iScaleFactor
    )
{
    HRESULT hr = NOERROR;

    if ( ( INT_MAX == iScaleFactor ) 
        || ( ( iScaleFactor >= PDH_MIN_SCALE ) && (iScaleFactor <= PDH_MAX_SCALE) ) ) {

        PDH_COUNTER_INFO ci;
        DWORD size;

        m_iScaleFactor = iScaleFactor;

        if ( INT_MAX == iScaleFactor ) {
            if ( NULL != Handle() ) {
                size = sizeof(ci);
                hr = PdhGetCounterInfo ( Handle(), FALSE, &size, &ci);

                if (hr == ERROR_SUCCESS)  {
                    m_dScale = pow ((double)10.0f, (double)ci.lDefaultScale);
                    m_CounterInfo = ci;
    
                }
            } else {
                // m_dScale remains at previous value (default=1)
                hr = PDH_INVALID_HANDLE;
            }
        }
        else {
            m_dScale = pow ((double)10.0, (double)iScaleFactor);
            hr = NOERROR;
        }
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CGraphItem::get_ScaleFactor (
    OUT INT* piScaleFactor
    )
{
    HRESULT hr = S_OK;

    try {
        *piScaleFactor = m_iScaleFactor;
    } catch (...) {
         hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP CGraphItem::get_Path (
    OUT BSTR* pstrPath
    )
{
    LPWSTR  szPath = NULL;
    BSTR  pTmpPath = NULL;
    HRESULT hr = S_OK;

    szPath = FormPath(FALSE);
    if (szPath == NULL) {
        hr = E_OUTOFMEMORY;
    }
    else {
        pTmpPath = SysAllocString(szPath);

        if ( NULL == pTmpPath) {
            hr = E_OUTOFMEMORY;
        }
    }

    try {
        *pstrPath = pTmpPath;
   
    } catch (...) {
        hr = E_POINTER;
    }

    if (szPath) {
        delete [] szPath;
    }
    if (FAILED(hr) && pTmpPath) {
        SysFreeString(pTmpPath);
    }

    return hr;
}

STDMETHODIMP CGraphItem::get_Value (
    OUT double* pdValue
    )
{
    DWORD   dwTmpStat;
    double  dValue;
    HRESULT hr = S_OK;

    try {
        *pdValue = 0;

        // Convert PDH status to HRESULT
        if (HistoryValue(0, &dValue, &dwTmpStat) != 0) {
            dValue = -1.0;
        }
        else {
            if (!IsSuccessSeverity(dwTmpStat)) {
                dValue = -1.0;
            }
        }

        *pdValue = dValue;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


HPEN CGraphItem::Pen(void)
{
    // if pen not valid
    if (m_hPen == NULL) {
        // create a new one based on current attributes
        m_hPen = CreatePen(m_iStyle, m_iWidth, m_rgbColor);

        // if can't do it, use a stock object (this can't fail)
        if (m_hPen == NULL)
            m_hPen = (HPEN)GetStockObject(BLACK_PEN);
    }

    return m_hPen;
}

HBRUSH CGraphItem::Brush(void)
{
    // if brush is not valid
    if (m_hBrush == NULL)
    {
        m_hBrush = CreateSolidBrush(m_rgbColor);

        if (m_hBrush == NULL)
            m_hBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);
    }

    return m_hBrush;
}

void CGraphItem::InvalidatePen(void)
{
    if (m_hPen != NULL)
    {
        DeleteObject(m_hPen);
        m_hPen = NULL;
    }
}

void CGraphItem::InvalidateBrush(void)
{
    if (m_hBrush != NULL)
    {
        DeleteObject(m_hBrush);
        m_hBrush = NULL;
    }
}


CGraphItem*
CGraphItem::Next (
    void
    )
{
    PCInstanceNode pInstance;
    PCObjectNode   pObject;
    PCMachineNode  pMachine;

    if (m_pNextItem)
        return m_pNextItem;
    else if ( NULL != m_pInstance->Next()) {
        pInstance = m_pInstance->Next();
        return pInstance->FirstItem();
    } else if ( NULL != m_pInstance->m_pObject->Next()) {
        pObject = m_pInstance->m_pObject->Next();
        return pObject->FirstInstance()->FirstItem();
    } else if ( NULL != m_pInstance->m_pObject->m_pMachine->Next()) {
        pMachine = m_pInstance->m_pObject->m_pMachine->Next();
        return pMachine->FirstObject()->FirstInstance()->FirstItem();
    } else {
        return NULL;
    }
}


LPWSTR 
CGraphItem::FormPath(
    BOOL fWildCard
    )
/*++

Routine Description:

    The function generate the full path of a counter item. 

Arguments:
    fWildCard - Indicates whether includeing wild card in counter path

Return Value:

    Return the generated counter path, the caller must free it when 
    finished using it.

--*/
{
    ULONG ulCchBuf;
    LPWSTR szBuf = NULL;
    PDH_STATUS pdhStatus;
    PDH_COUNTER_PATH_ELEMENTS CounterPathElements;

    do {
        if ( szBuf ) {
            delete [] szBuf;
            szBuf = NULL;
        }
        else {
            ulCchBuf = PDH_MAX_COUNTER_PATH + 1;
        }

        szBuf = new WCHAR [ulCchBuf];

        if (szBuf == NULL) {
            return NULL;
        }

        CounterPathElements.szMachineName = (LPWSTR)Machine()->Name();
        CounterPathElements.szObjectName = (LPWSTR)Object()->Name();
        if (fWildCard) {
            CounterPathElements.szInstanceName = L"*";
            CounterPathElements.szParentInstance = NULL;
        }
        else {
            LPWSTR szInstName;
            LPWSTR szParentName;

            szInstName = Instance()->GetInstanceName();
            if ( szInstName[0] ) {
                CounterPathElements.szInstanceName = szInstName;
                szParentName = Instance()->GetParentName();
                if (szParentName[0]) {
                    CounterPathElements.szParentInstance = szParentName;
                }
                else {
                    CounterPathElements.szParentInstance = NULL;
                }
            }
            else {
                CounterPathElements.szInstanceName = NULL;
                CounterPathElements.szParentInstance = NULL;
            }
        }
        CounterPathElements.dwInstanceIndex = (DWORD)-1;
        CounterPathElements.szCounterName = (LPWSTR)Counter()->Name();

        pdhStatus = PdhMakeCounterPath( &CounterPathElements, szBuf, &ulCchBuf, 0);
    } while (pdhStatus == PDH_MORE_DATA || pdhStatus == PDH_INSUFFICIENT_BUFFER);

    if (pdhStatus != ERROR_SUCCESS) {
        delete [] szBuf;
        return NULL;
    }

    //
    // Strip off the machine name.
    //
    if (m_fLocalMachine && szBuf[0] == L'\\' && szBuf[1] == L'\\') {
        LPWSTR szNewBuf = NULL;
        LPWSTR p;
        INT iNewLen = 0;
 
        p = &szBuf[2];
        while (*p && *p != L'\\') {
            p++;
        }

        iNewLen = lstrlen(p) + 1;
        szNewBuf = new WCHAR [iNewLen];

        if ( NULL != szNewBuf ) {

            StringCchCopy ( szNewBuf, iNewLen, p );
            delete [] szBuf;
            szBuf = szNewBuf;
        } else {
            delete [] szBuf;
            szBuf = NULL;
        }
    }

    return szBuf;
}


void
CGraphItem::Delete (
    BOOL bPropogateUp
    )
//
// This method just provides a convenient access to the DeleteCounter method
// of the control when you only have a pointer to the graph item.
//
{
    m_pCtrl->DeleteCounter(this, bPropogateUp);
}



HRESULT
CGraphItem::GetNextValue (
    WCHAR*& pszNext,
    double& rdValue 
    )
{
    HRESULT hr = S_OK;
    WCHAR   szValue[MAX_DOUBLE_TEXT_SIZE + 1];
    INT     iLen;

    VARIANT vValue;
    
    rdValue = -1.0;

    iLen = wcscspn (pszNext, L"\t");

    //
    // Change tab character to null.
    //
    pszNext[iLen] = L'\0';

    hr = StringCchCopy ( szValue, MAX_DOUBLE_TEXT_SIZE + 1, pszNext );
    
    if ( SUCCEEDED ( hr ) ) {

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;

        vValue.bstrVal = SysAllocString ( szValue );
        hr = VariantChangeTypeEx( &vValue, &vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_R8 );

        if ( SUCCEEDED(hr) ) {
            rdValue = vValue.dblVal;
        }

        VariantClear( &vValue );
    } 
    pszNext += iLen + 1 ;

    return hr;
}


BOOL
CGraphItem::CalcRequiresMultipleSamples ( void )
{

    BOOL bReturn = TRUE;

    //
    // Todo:  This code is a duplicate of PdhiCounterNeedLastValue.
    // When that method is added to pdhicalc.h, then use it instead of thie
    // duplicate code.
    //

    switch (m_CounterInfo.dwType) {
        case PERF_DOUBLE_RAW:
        case PERF_ELAPSED_TIME:
        case PERF_RAW_FRACTION:
        case PERF_LARGE_RAW_FRACTION:
        case PERF_COUNTER_RAWCOUNT:
        case PERF_COUNTER_LARGE_RAWCOUNT:
        case PERF_COUNTER_RAWCOUNT_HEX:
        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
        case PERF_COUNTER_TEXT:
        case PERF_SAMPLE_BASE:
        case PERF_AVERAGE_BASE:
        case PERF_COUNTER_MULTI_BASE:
        case PERF_RAW_BASE:
        //case PERF_LARGE_RAW_BASE:
        case PERF_COUNTER_HISTOGRAM_TYPE:
        case PERF_COUNTER_NODATA:
        case PERF_PRECISION_TIMESTAMP:
            bReturn = FALSE;
            break;

        case PERF_AVERAGE_TIMER:
        case PERF_COUNTER_COUNTER:
        case PERF_COUNTER_BULK_COUNT:
        case PERF_SAMPLE_COUNTER:
        case PERF_AVERAGE_BULK:
        case PERF_COUNTER_TIMER:
        case PERF_100NSEC_TIMER:
        case PERF_OBJ_TIME_TIMER:
        case PERF_COUNTER_QUEUELEN_TYPE:
        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
        case PERF_SAMPLE_FRACTION:
        case PERF_COUNTER_MULTI_TIMER:
        case PERF_100NSEC_MULTI_TIMER:
        case PERF_PRECISION_SYSTEM_TIMER:
        case PERF_PRECISION_100NS_TIMER:
        case PERF_PRECISION_OBJECT_TIMER:
        case PERF_COUNTER_TIMER_INV:
        case PERF_100NSEC_TIMER_INV:
        case PERF_COUNTER_MULTI_TIMER_INV:
        case PERF_100NSEC_MULTI_TIMER_INV:
        case PERF_COUNTER_DELTA:
        case PERF_COUNTER_LARGE_DELTA:

        default:
            bReturn = TRUE;
            break;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\hatchwnd.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    hatchwnd.h

Abstract:

    Implementation of the CHatchWin class.  CHatchWin when used 
    as a parent window creates a thin hatch border around 
    the child window.

--*/
#include <windows.h>
#include <oleidl.h>
#include "hatchwnd.h"
#include "resource.h"
#include "globals.h"

// Hit codes for computing handle code (Y_CODE + 3 * X_CODE)
#define Y_TOP       0
#define Y_MIDDLE    1
#define Y_BOTTOM    2
#define X_LEFT      0
#define X_MIDDLE    1
#define X_RIGHT     2
#define NO_HIT     -1

// Sizing flags
#define SIZING_TOP       0x0001
#define SIZING_BOTTOM    0x0002
#define SIZING_LEFT      0x0004
#define SIZING_RIGHT     0x0008
#define SIZING_ALL       0x0010

// Sizing flags lookup (indexed by handle code)
static UINT uSizingTable[9] = {
    SIZING_LEFT | SIZING_TOP,    SIZING_TOP,    SIZING_RIGHT | SIZING_TOP,
    SIZING_LEFT,                 SIZING_ALL,    SIZING_RIGHT,
    SIZING_LEFT | SIZING_BOTTOM, SIZING_BOTTOM, SIZING_BOTTOM | SIZING_RIGHT };

// Cursor ID lookup (indexed by handle code)
static UINT uCursIDTable[9] = {
    IDC_CURS_NWSE, IDC_CURS_NS,     IDC_CURS_NESW,
    IDC_CURS_WE,   IDC_CURS_MOVE,   IDC_CURS_WE,
    IDC_CURS_NESW, IDC_CURS_NS,     IDC_CURS_NWSE 
};

// Cursors (indexed by cursor ID)
static HCURSOR hCursTable[IDC_CURS_MAX - IDC_CURS_MIN + 1];

#define IDTIMER_DEBOUNCE 1
#define MIN_SIZE 8
        
// Brush patterns
static WORD wHatchBmp[]={0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
static WORD wGrayBmp[]={0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};

static HBRUSH   hBrHatch;
static HBRUSH   hBrGray;

// System parameters
static INT iBorder;
static INT iDragMinDist;
static INT iDragDelay;

static INT fLocalInit = FALSE;

// Forward refs
void DrawShading(HDC, LPRECT);
void DrawHandles (HDC, LPRECT);
void DrawDragRgn (HWND, HRGN);
HRGN CreateDragRgn(LPRECT);

WCHAR   szHatchWinClassName[] = L"Hatchwin" ;

/*
 * CHatchWin:CHatchWin
 * CHatchWin::~CHatchWin
 *
 * Constructor Parameters:
 *  hInst           HINSTANCE of the application we're in.
 */

CHatchWin::CHatchWin(
    VOID
    )
{
    m_hWnd = NULL;
    m_hWndParent = NULL;
    m_hWndKid = NULL;
    m_hWndAssociate = NULL;
    m_hRgnDrag = NULL;

    m_iBorder = 0;
    m_uID = 0;
    m_uDragMode = DRAG_IDLE;
    m_bResizeInProgress = FALSE;
    SetRect(&m_rcPos, 0, 0, 0, 0);
    SetRect(&m_rcClip, 0, 0, 0, 0);

    return;
    }


CHatchWin::~CHatchWin(void)
    {

    if (NULL != m_hWnd)
        DestroyWindow(m_hWnd);

    return;
    }

/*
 * CHatchWin::Init
 *
 * Purpose:
 *  Instantiates a hatch window within a given parent with a
 *  default rectangle.  This is not initially visible.
 *
 * Parameters:
 *  hWndParent      HWND of the parent of this window
 *  uID             UINT identifier for this window (send in
 *                  notifications to associate window).
 *  hWndAssoc       HWND of the initial associate.
 *
 * Return Value:
 *  BOOL            TRUE if the function succeeded, FALSE otherwise.
 */

BOOL CHatchWin::Init(HWND hWndParent, UINT uID, HWND hWndAssoc)
    {
    INT i;
    HBITMAP     hBM;
    WNDCLASS    wc;
    LONG_PTR    lptrID = 0;

    BEGIN_CRITICAL_SECTION

    // If first time through
    if (pstrRegisteredClasses[HATCH_WNDCLASS] == NULL) {

        // Register the hatch window class
        wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
        wc.hInstance     = g_hInstance;
        wc.cbClsExtra    = 0;
        wc.lpfnWndProc   = HatchWndProc;
        wc.cbWndExtra    = CBHATCHWNDEXTRA;
        wc.hIcon         = NULL;
        wc.hCursor       = NULL;
        wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = szHatchWinClassName;

        if (RegisterClass(&wc)) {

            // Save class name for later unregistering
            pstrRegisteredClasses[HATCH_WNDCLASS] = szHatchWinClassName;

            // Get system metrics
            iBorder = GetProfileInt(TEXT("windows"),
                                    TEXT("OleInPlaceBorderWidth"), 4);
            iDragMinDist = GetProfileInt(TEXT("windows"),
                                        TEXT("DragMinDist"), DD_DEFDRAGMINDIST);
            iDragDelay = GetProfileInt(TEXT("windows"),
                                        TEXT("DragDelay"), DD_DEFDRAGDELAY);

            // Load the arrow cursors
            for (i = IDC_CURS_MIN; i <= IDC_CURS_MAX; i++) {
                hCursTable[i - IDC_CURS_MIN] = LoadCursor(g_hInstance, MAKEINTRESOURCE(i));
            }

            // Create brushes for hatching and drag region
            hBM = CreateBitmap(8, 8, 1, 1, wHatchBmp);
            if ( NULL != hBM ) {
                hBrHatch = CreatePatternBrush(hBM);
                DeleteObject(hBM);
            }

            hBM = CreateBitmap(8, 8, 1, 1, wGrayBmp);
            if ( NULL != hBM ) {
                hBrGray = CreatePatternBrush(hBM);
                DeleteObject(hBM);
            }
        }
    }
    
    END_CRITICAL_SECTION

    if (pstrRegisteredClasses[HATCH_WNDCLASS] == NULL)
        return FALSE;

    lptrID = uID;

    m_hWnd = CreateWindowEx(
                WS_EX_NOPARENTNOTIFY, 
                szHatchWinClassName,
                szHatchWinClassName, 
                WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
                0, 
                0, 
                100, 
                100, 
                hWndParent, 
                (HMENU)lptrID, 
                g_hInstance, 
                this);

    m_uID = uID;
    m_hWndAssociate = hWndAssoc;
    m_hWndParent = hWndParent;


    return (NULL != m_hWnd);
}

/*
 * CHatchWin::HwndAssociateSet
 * CHatchWin::HwndAssociateGet
 *
 * Purpose:
 *  Sets (Set) or retrieves (Get) the associate window of the
 *  hatch window.
 *
 * Parameters: (Set only)
 *  hWndAssoc       HWND to set as the associate.
 *
 * Return Value:
 *  HWND            Previous (Set) or current (Get) associate
 *                  window.
 */

HWND CHatchWin::HwndAssociateSet(HWND hWndAssoc)
    {
    HWND hWndT = m_hWndAssociate;

    m_hWndAssociate = hWndAssoc;
    return hWndT;
    }

HWND CHatchWin::HwndAssociateGet(void)
    {
    return m_hWndAssociate;
    }


/*
 * CHatchWin::RectsSet
 *
 * Purpose:
 *  Changes the size and position of the hatch window and the child
 *  window within it using a position rectangle for the child and
 *  a clipping rectangle for the hatch window and child.  The hatch
 *  window occupies prcPos expanded by the hatch border and clipped
 *  by prcClip.  The child window is fit to prcPos to give the
 *  proper scaling, but it clipped to the hatch window which
 *  therefore clips it to prcClip without affecting the scaling.
 *
 * Parameters:
 *  prcPos          LPRECT providing the position rectangle.
 *  prcClip         LPRECT providing the clipping rectangle.
 *
 * Return Value:
 *  None
 */

void CHatchWin::RectsSet(LPRECT prcPos, LPRECT prcClip)
    {
    RECT    rc;
    RECT    rcPos;
    UINT    uPosFlags = SWP_NOZORDER | SWP_NOACTIVATE;
    BOOL    bChanged = TRUE;

    // If new rectangles, save them
    if (prcPos != NULL) {

        bChanged = !EqualRect ( prcPos, &m_rcPos );

        m_rcPos = *prcPos;

        // If clipping rect supplied, use it
        // else just use the position rect again
        if (prcClip != NULL) {
            if ( !bChanged ) 
                bChanged = !EqualRect ( prcClip, &m_rcClip );
            m_rcClip = *prcClip;
        } else {
            m_rcClip = m_rcPos;
        }
    }

    if ( bChanged ) {

        // Expand position rect to include hatch border
        rcPos = m_rcPos;
        InflateRect(&rcPos, m_iBorder, m_iBorder);                             

        // Clip with clipping rect to get actual window rect
        IntersectRect(&rc, &rcPos, &m_rcClip);

        // Save hatch wnd origin relative to clipped window
        m_ptHatchOrg.x = rcPos.left - rc.left;
        m_ptHatchOrg.y = rcPos.top - rc.top;

        // Set flag to avoid reentrant call from window proc
        m_bResizeInProgress = TRUE;

        // Offset child window from hatch rect by border width
        // (maintaining its original size)
        SetWindowPos(m_hWndKid, NULL, m_ptHatchOrg.x + m_iBorder, m_ptHatchOrg.y + m_iBorder, 
                     m_rcPos.right - m_rcPos.left, m_rcPos.bottom - m_rcPos.top, uPosFlags);

        // Position the hatch window
        SetWindowPos(m_hWnd, NULL, rc.left, rc.top, rc.right - rc.left,
                     rc.bottom - rc.top,  uPosFlags);

        m_bResizeInProgress = FALSE;
    }

    // This is here to ensure that the control background gets redrawn
    // On a UI deactivate, the VC test container erases the control window
    // between the WM_ERASEBKGND and WM_PAINT, so the background ends up
    // the container color instead of the control color
    if (m_iBorder == 0)
        InvalidateRect(m_hWndKid, NULL, TRUE);

    return;
    }



/*
 * CHatchWin::ChildSet
 *
 * Purpose:
 *  Assigns a child window to this hatch window.
 *
 * Parameters:
 *  hWndKid         HWND of the child window.
 *
 * Return Value:
 *  None
 */

void CHatchWin::ChildSet(HWND hWndKid)
    {
    m_hWndKid = hWndKid;

    if (NULL != hWndKid)
        {
        SetParent(hWndKid, m_hWnd);

        //Insure this is visible when the hatch window becomes visible.
        ShowWindow(hWndKid, SW_SHOW);
        }

    return;
    }


void CHatchWin::OnLeftDown(INT x, INT y)
{
    m_ptDown.x = x;
    m_ptDown.y = y;

    SetCapture(m_hWnd);

    m_uDragMode = DRAG_PENDING;

    SetTimer(m_hWnd, IDTIMER_DEBOUNCE, iDragDelay, NULL);
}


void CHatchWin::OnLeftUp(void)
{
    switch (m_uDragMode) {

    case DRAG_PENDING:

        KillTimer(m_hWnd, IDTIMER_DEBOUNCE);
        ReleaseCapture();
        break;

    case DRAG_ACTIVE:

        // Erase and release drag region
        if ( NULL != m_hRgnDrag ) {
            DrawDragRgn(m_hWndParent, m_hRgnDrag);
            DeleteObject(m_hRgnDrag);
            m_hRgnDrag = NULL;
        }

        ReleaseCapture();

        // Inform associated window of change
        if ( !EqualRect(&m_rectNew, &m_rcPos) ) {
            SendMessage(m_hWndAssociate, WM_COMMAND, 
                        MAKEWPARAM(m_uID, HWN_RESIZEREQUESTED),
                        (LPARAM)&m_rectNew);
        }
        break;
    }

    m_uDragMode = DRAG_IDLE; 
}


void CHatchWin::OnMouseMove(INT x, INT y)
{
    INT     dx, dy;
    HRGN    hRgnNew, hRgnDiff;
    UINT    uResizeFlags;
    
    INT     iWidth, iHeight;
    INT     xHit, yHit;

    static INT  xPrev, yPrev;


    if (x == xPrev && y == yPrev)
        return;

    xPrev = x;
    yPrev = y;

    switch (m_uDragMode)
    {

    case DRAG_IDLE:

        // Adjust to hatch window coordinates
        x -= m_ptHatchOrg.x;
        y -= m_ptHatchOrg.y;

        iWidth = m_rcPos.right - m_rcPos.left + 2 * m_iBorder;
        iHeight = m_rcPos.bottom - m_rcPos.top + 2 * m_iBorder;

        // Determine if x is within a handle
        if (x <= m_iBorder)
            xHit = X_LEFT;
        else if (x >= iWidth - m_iBorder)
            xHit = X_RIGHT;
        else if (x >= (iWidth - m_iBorder)/2 && x <= (iWidth + m_iBorder)/2)
            xHit = X_MIDDLE;
        else 
            xHit = NO_HIT;

        // Determine is y within a handle
        if (y <= m_iBorder)
            yHit = Y_TOP;
        else if (y >= iHeight - m_iBorder)
            yHit = Y_BOTTOM;
        else if (y > (iHeight - m_iBorder)/2 && y < (iHeight + m_iBorder)/2)
            yHit = Y_MIDDLE;
        else
            yHit = NO_HIT;

        // Compute handle code
        // if no handle hit, set to 4 (drag full object)
        if (xHit != NO_HIT && yHit != NO_HIT)
            m_uHdlCode = xHit + 3 * yHit;
        else
            m_uHdlCode = 4;

        // Set cursor to match handle
        SetCursor(hCursTable[uCursIDTable[m_uHdlCode] - IDC_CURS_MIN]);
        break;

    case DRAG_PENDING:
     
        // Start resize if movement threshold exceeded
        dx = (x >= m_ptDown.x) ? (x - m_ptDown.x) : (m_ptDown.x - x);
        dy = (y >= m_ptDown.y) ? (y - m_ptDown.y) : (m_ptDown.y - y);

        if (dx > iDragMinDist || dy > iDragMinDist) {
            KillTimer(m_hWnd, IDTIMER_DEBOUNCE);

            // Create and display initial drag region
            m_hRgnDrag = CreateDragRgn(&m_rcPos);

            if ( NULL != m_hRgnDrag ) {
                DrawDragRgn(m_hWndParent, m_hRgnDrag);

                // Initialize new rect
                m_rectNew = m_rcPos;

                m_uDragMode = DRAG_ACTIVE;
            }
        }
        break;

    case DRAG_ACTIVE:
        
        dx = x - m_ptDown.x;
        dy = y - m_ptDown.y;

        // Compute new rect by applying deltas to selected edges
        // of original position rect 
        uResizeFlags = uSizingTable[m_uHdlCode];

        if (uResizeFlags & SIZING_ALL) {
            m_rectNew.left = m_rcPos.left + dx;
            m_rectNew.top = m_rcPos.top + dy;
            m_rectNew.right = m_rcPos.right + dx;
            m_rectNew.bottom = m_rcPos.bottom + dy;
        } else {
            if (uResizeFlags & SIZING_TOP) {
                m_rectNew.top = m_rcPos.top + dy;

                if (m_rectNew.bottom - m_rectNew.top < MIN_SIZE)
                    m_rectNew.top = m_rectNew.bottom - MIN_SIZE;
            }

            if (uResizeFlags & SIZING_BOTTOM) {
                m_rectNew.bottom = m_rcPos.bottom + dy;

                if (m_rectNew.bottom - m_rectNew.top < MIN_SIZE)
                    m_rectNew.bottom = m_rectNew.top + MIN_SIZE;
            }
                
            if (uResizeFlags & SIZING_LEFT) {
                m_rectNew.left = m_rcPos.left + dx;

                if (m_rectNew.right - m_rectNew.left < MIN_SIZE)
                    m_rectNew.left = m_rectNew.right - MIN_SIZE;
            }
        
            if (uResizeFlags & SIZING_RIGHT) {
                m_rectNew.right = m_rcPos.right + dx;

                if (m_rectNew.right - m_rectNew.left < MIN_SIZE)
                    m_rectNew.right = m_rectNew.left + MIN_SIZE;
            }
        }
        
        // Compute new drag region
        hRgnNew = CreateDragRgn(&m_rectNew);

        if ( NULL != hRgnNew ) {
            // Repaint difference between old and new regions (No Flicker!)
            hRgnDiff = CreateRectRgn(0,0,0,0);
            if ( NULL != m_hRgnDrag 
                    && NULL != hRgnDiff ) {
                CombineRgn(hRgnDiff, m_hRgnDrag, hRgnNew, RGN_XOR);
                DrawDragRgn(m_hWndParent, hRgnDiff);
            } else {
                DrawDragRgn(m_hWndParent, hRgnNew);
            }

            if ( NULL != hRgnDiff ) {
                DeleteObject ( hRgnDiff );
            }
            // Update current region
            if ( NULL != m_hRgnDrag ) {
                DeleteObject(m_hRgnDrag);
            }
            m_hRgnDrag = hRgnNew;
        }
    }

}

void CHatchWin::OnTimer()
{
    if ( DRAG_PENDING == m_uDragMode ) {
        KillTimer(m_hWnd, IDTIMER_DEBOUNCE); 
        // Create and display initial drag region
        m_hRgnDrag = CreateDragRgn(&m_rcPos);

        if ( NULL != m_hRgnDrag ) {
            DrawDragRgn(m_hWndParent, m_hRgnDrag);
            // Initialize new rect
            m_rectNew = m_rcPos;

            m_uDragMode = DRAG_ACTIVE;

        }
    }
}

void CHatchWin::OnPaint()
{
    HDC     hDC;
    RECT    rc;
    PAINTSTRUCT ps;
    INT     iWidth, iHeight;

    hDC = BeginPaint(m_hWnd, &ps);

    // setup hatch rect in window's coord system
    iWidth = m_rcPos.right - m_rcPos.left + 2 * m_iBorder;
    iHeight = m_rcPos.bottom - m_rcPos.top + 2 * m_iBorder;

    SetRect(&rc, m_ptHatchOrg.x, m_ptHatchOrg.y,
                 m_ptHatchOrg.x + iWidth,
                 m_ptHatchOrg.y + iHeight);

    DrawShading(hDC, &rc);
    DrawHandles(hDC, &rc);

    EndPaint(m_hWnd, &ps);
}
    
/*
 * CHatchWin::ShowHatch
 *
 * Purpose:
 *  Turns hatching on and off; turning the hatching off changes
 *  the size of the window to be exactly that of the child, leaving
 *  everything else the same.  The result is that we don't have
 *  to turn off drawing because our own WM_PAINT will never be
 *  called.
 *
 * Parameters:
 *  fHatch          BOOL indicating to show (TRUE) or hide (FALSE)
                    the hatching.
 *
 * Return Value:
 *  None
 */

void CHatchWin::ShowHatch(BOOL fHatch)
{
    /*
     * All we have to do is set the border to zero and
     * call SetRects again with the last rectangles the
     * child sent to us.
    */

    m_iBorder = fHatch ? iBorder : 0;
    RectsSet(NULL, NULL);

    return;
}


/*
 * CHatchWin::Window
 *
 * Purpose:
 *  Returns the window handle associated with this object.
 *
 * Return Value:
 *  HWND            Window handle for this object
 */

HWND CHatchWin::Window(void)
    {
    return m_hWnd;
    }

/*
 * HatchWndProc
 *
 * Purpose:
 *  Standard window procedure for the Hatch Window
 */

LRESULT APIENTRY HatchWndProc(HWND hWnd, UINT iMsg
    , WPARAM wParam, LPARAM lParam)
    {
    PCHatchWin  phw;
    
    phw = (PCHatchWin)GetWindowLongPtr(hWnd, HWWL_STRUCTURE);

    switch (iMsg)
        {
        case WM_CREATE:
            phw = (PCHatchWin)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd, HWWL_STRUCTURE, (INT_PTR)phw);
            break;

        case WM_DESTROY:
            phw->m_hWnd = NULL;
            break;

        case WM_PAINT:
            phw->OnPaint();
            break;

        case WM_SIZE:
            // If this resize is not due to RectsSet then forward it
            // to adjust our internal control window
            if (!phw->m_bResizeInProgress)
            {
                RECT rc;
                POINT pt;

                // Get new rect in container coords
                GetWindowRect(hWnd, &rc);

                // Convert to parent client coords
                pt.x = pt.y = 0;
                ClientToScreen(GetParent(hWnd), &pt);
                OffsetRect(&rc,-pt.x, -pt.y);

                // Resize control
                phw->RectsSet(&rc, NULL);
            }
            break;

        case WM_MOUSEMOVE:
            phw->OnMouseMove((short)LOWORD(lParam),(short)HIWORD(lParam));
            break;

        case WM_LBUTTONDOWN:
            phw->OnLeftDown((short)LOWORD(lParam),(short)HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            phw->OnLeftUp();
            break;

        case WM_TIMER:
            phw->OnTimer();
            break;

        case WM_SETFOCUS:
            //We need this since the container will SetFocus to us.
            if (NULL != phw->m_hWndKid)
                SetFocus(phw->m_hWndKid);
            break;

        case WM_LBUTTONDBLCLK:
            /*
             * If the double click was within m_dBorder of an
             * edge, send the HWN_BORDERDOUBLECLICKED notification.
             *
             * Because we're always sized just larger than our child
             * window by the border width, we can only *get* this
             * message when the mouse is on the border.  So we can
             * just send the notification.
             */

            if (NULL!=phw->m_hWndAssociate)
                {
                SendMessage(phw->m_hWndAssociate, WM_COMMAND, 
                            MAKEWPARAM(phw->m_uID,HWN_BORDERDOUBLECLICKED),
                            (LPARAM)hWnd);
                }

            break;

        default:
            return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }
    
    return 0L;
    }


HRGN CreateDragRgn(LPRECT pRect)
{
    HRGN    hRgnIn;
    HRGN    hRgnOut;
    HRGN    hRgnRet = NULL;

    if ( NULL != pRect ) {
  
        hRgnRet = CreateRectRgn(0,0,0,0);

        hRgnIn = CreateRectRgn(pRect->left, pRect->top,pRect->right, pRect->bottom);
        hRgnOut = CreateRectRgn(pRect->left - iBorder, pRect->top - iBorder,
                                pRect->right + iBorder, pRect->bottom + iBorder);

        if ( NULL != hRgnOut 
                && NULL != hRgnIn
                && NULL != hRgnRet ) {
            CombineRgn(hRgnRet, hRgnOut, hRgnIn, RGN_DIFF);
        }
        if ( NULL != hRgnIn ) {
            DeleteObject(hRgnIn);
        }
        if ( NULL != hRgnOut ) {
            DeleteObject(hRgnOut);
        }
    }
    return hRgnRet;
}


void DrawDragRgn(HWND hWnd, HRGN hRgn)
{
    LONG    lWndStyle;
    INT     iMapMode;
    HDC     hDC;
    RECT    rc;
    HBRUSH  hBr;
    COLORREF    crText;

    // Turn off clipping by children
    lWndStyle = GetWindowLong(hWnd, GWL_STYLE);
    SetWindowLong(hWnd, GWL_STYLE, lWndStyle & ~WS_CLIPCHILDREN);

    // Prepare DC
    hDC = GetDC(hWnd);

    if ( NULL != hDC ) {
        iMapMode = SetMapMode(hDC, MM_TEXT);
        hBr = (HBRUSH)SelectObject(hDC, hBrGray);
        crText = SetTextColor(hDC, RGB(255, 255, 255));

        SelectClipRgn(hDC, hRgn);
        GetClipBox(hDC, &rc);

        PatBlt(hDC, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATINVERT);

        // Restore DC
        SelectObject(hDC, hBr);
        SetTextColor(hDC, crText);
        SetMapMode(hDC, iMapMode);
        SelectClipRgn(hDC, NULL);
        ReleaseDC(hWnd, hDC);
    }

    SetWindowLong(hWnd, GWL_STYLE, lWndStyle);
}


/*
 * DrawShading
 *
 * Purpose:
 *  Draw a hatch border ourside the rectable given.
 *
 * Parameters:
 *  prc             LPRECT containing the rectangle.
 *  hDC             HDC on which to draw.
 *  cWidth          UINT width of the border to draw.  Ignored
 *                  if dwFlags has UI_SHADE_FULLRECT.
 *
 * Return Value:
 *  None
 */

void DrawShading(HDC hDC, LPRECT prc)
{
    HBRUSH      hBROld;
    RECT        rc;
    UINT        cx, cy;
    COLORREF    crText;
    COLORREF    crBk;
    const DWORD dwROP = 0x00A000C9L;  //DPa

    if (NULL==prc || NULL==hDC)
        return;

    hBROld = (HBRUSH)SelectObject(hDC, hBrHatch);

    rc = *prc;
    cx = rc.right - rc.left;
    cy = rc.bottom - rc.top;

    crText = SetTextColor(hDC, RGB(255, 255, 255));
    crBk = SetBkColor(hDC, RGB(0, 0, 0));

    PatBlt(hDC, rc.left, rc.top, cx, iBorder, dwROP);
    PatBlt(hDC, rc.left, rc.top, iBorder, cy, dwROP);
    PatBlt(hDC, rc.right-iBorder, rc.top, iBorder, cy, dwROP);
    PatBlt(hDC, rc.left, rc.bottom-iBorder, cx, iBorder, dwROP);

    SetTextColor(hDC, crText);
    SetBkColor(hDC, crBk);
    SelectObject(hDC, hBROld);

    return;
}

void DrawHandles (HDC hDC, LPRECT prc)
{
    HPEN    hPenOld;
    HBRUSH  hBROld;
    INT     left,right,top,bottom;

#define DrawHandle(x,y) Rectangle(hDC, x, y, (x) + iBorder + 1, (y) + iBorder + 1)

    hPenOld = (HPEN)SelectObject(hDC, (HPEN)GetStockObject(BLACK_PEN));
    hBROld = (HBRUSH)SelectObject(hDC, (HBRUSH)GetStockObject(BLACK_BRUSH));

    left = prc->left;
    right = prc->right - iBorder;
    top = prc->top;
    bottom = prc->bottom - iBorder;
     
    DrawHandle(left, top);
    DrawHandle(left, (top + bottom)/2);
    DrawHandle(left, bottom);

    DrawHandle(right, top);
    DrawHandle(right, (top + bottom)/2);
    DrawHandle(right, bottom);

    DrawHandle((left + right)/2, top);
    DrawHandle((left + right)/2, bottom);

    SelectObject(hDC, hPenOld);
    SelectObject(hDC, hBROld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\grphprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphprop.cpp

Abstract:

    Implementation of the graph property page class.

--*/


#include "polyline.h"
#include <strsafe.h>
#include <assert.h>
#include "grphprop.h"
#include "utils.h"
#include "strids.h"
#include "unihelpr.h"
#include "winhelpr.h"

CGraphPropPage::CGraphPropPage()
{

    m_uIDDialog = IDD_GRAPH_PROPP_DLG;
    m_uIDTitle = IDS_GRAPH_PROPP_TITLE;

    m_pszYaxisTitle = NULL;
    m_pszGraphTitle = NULL;

}

CGraphPropPage::~CGraphPropPage()
{
     delete [] m_pszYaxisTitle;
     delete [] m_pszGraphTitle;
}

BOOL CGraphPropPage::InitControls()
{
    HWND  hwndItem = NULL;

    hwndItem = GetDlgItem(m_hDlg, IDC_VERTICAL_MAX);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_SCALE_DIGITS);
        hwndItem = NULL;
    }
    hwndItem = GetDlgItem(m_hDlg, IDC_VERTICAL_MIN);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_SCALE_DIGITS);
        hwndItem = NULL;
    }
    hwndItem = GetDlgItem(m_hDlg, IDC_GRAPH_TITLE);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_TITLE_CHARS);
        hwndItem = NULL;
    }
    hwndItem = GetDlgItem(m_hDlg, IDC_YAXIS_TITLE);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_TITLE_CHARS);
        hwndItem = NULL;
    }
    return TRUE;
}

/*
 * CGraphPropPage::GetProperties
 * 
 */

BOOL CGraphPropPage::GetProperties(void)
{
    WCHAR   szBuff[MAX_SCALE_DIGITS+1];
    ISystemMonitor  *pObj;
    BSTR    bstrTemp;
    LPWSTR  pszTemp;

    if (m_cObjects == 0)
        return FALSE;
        
    pObj = m_ppISysmon[0];
        
    pObj->get_ShowScaleLabels(&m_bLabels);      
    CheckDlgButton(m_hDlg, IDC_VERTICAL_LABELS, m_bLabels) ;

    pObj->get_ShowVerticalGrid(&m_bVertGrid);
    CheckDlgButton(m_hDlg, IDC_VERTICAL_GRID, m_bVertGrid) ;

    pObj->get_ShowHorizontalGrid(&m_bHorzGrid);
    CheckDlgButton(m_hDlg, IDC_HORIZONTAL_GRID, m_bHorzGrid) ;

    pObj->get_MaximumScale(&m_iVertMax);
    StringCchPrintf(szBuff, MAX_SCALE_DIGITS+1, L"%d", m_iVertMax) ;
    SetDlgItemText(m_hDlg, IDC_VERTICAL_MAX, szBuff) ;

    pObj->get_MinimumScale(&m_iVertMin);
    StringCchPrintf(szBuff, MAX_SCALE_DIGITS+1, L"%d", m_iVertMin) ;
    SetDlgItemText(m_hDlg, IDC_VERTICAL_MIN, szBuff) ;

    pObj->get_YAxisLabel(&bstrTemp);
    if (bstrTemp != NULL) {
        pszTemp = bstrTemp;
        m_pszYaxisTitle = new WCHAR[lstrlen(pszTemp)+1];
        if (m_pszYaxisTitle) {
            StringCchCopy(m_pszYaxisTitle, lstrlen(pszTemp)+1, pszTemp);
            SetDlgItemText(m_hDlg, IDC_YAXIS_TITLE, m_pszYaxisTitle);
        }
        SysFreeString(bstrTemp);
    }
        
    pObj->get_GraphTitle(&bstrTemp);
    if (bstrTemp != NULL) {
        pszTemp = bstrTemp;
        m_pszGraphTitle = new WCHAR[lstrlen(pszTemp)+1];
        if (m_pszGraphTitle) {
            StringCchCopy(m_pszGraphTitle, lstrlen(pszTemp)+1, pszTemp);
            SetDlgItemText(m_hDlg, IDC_GRAPH_TITLE, m_pszGraphTitle);
        }
        SysFreeString(bstrTemp);
    }

    // Clear change flags
    m_bLabelsChg = FALSE;
    m_bVertGridChg = FALSE;
    m_bHorzGridChg = FALSE;
    m_bVertMinChg = FALSE;
    m_bYaxisTitleChg = FALSE;
    m_bGraphTitleChg = FALSE;

    // Clear error flags
    m_iErrVertMax = 0;
    m_iErrVertMin = 0;


    return TRUE;          
}


/*
 * CGraphPropPage::SetProperties
 * 
 */

BOOL CGraphPropPage::SetProperties(void)
{
    ISystemMonitor  *pObj;
    INT  iMsgId = 0;
    BSTR pTitle;

    USES_CONVERSION

    // Get first object
    if (m_cObjects == 0)
        return FALSE;
        
    pObj = m_ppISysmon[0];

    // Check for invalid data
    if (m_iErrVertMax) {
        SetFocus(GetDlgItem(m_hDlg, IDC_VERTICAL_MAX));
        iMsgId = m_iErrVertMax;
    } else if (m_iErrVertMin) {
        SetFocus(GetDlgItem(m_hDlg, IDC_VERTICAL_MIN));
        iMsgId = m_iErrVertMin;
    } else if (m_iVertMax <= m_iVertMin) {
        SetFocus(GetDlgItem(m_hDlg, IDC_VERTICAL_MAX));
        iMsgId = IDS_SCALE_ERR;
    }

    // on error, alert user and exit
    if (iMsgId) {
        MessageBox(m_hDlg, ResourceString(iMsgId), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    // Set all changed properties
    if (m_bLabelsChg)
        pObj->put_ShowScaleLabels(m_bLabels);

    if (m_bVertGridChg)
        pObj->put_ShowVerticalGrid(m_bVertGrid);

    if (m_bHorzGridChg)
        pObj->put_ShowHorizontalGrid(m_bHorzGrid);

    if (m_bVertMaxChg)
        pObj->put_MaximumScale(m_iVertMax);

    if (m_bVertMinChg)
        pObj->put_MinimumScale(m_iVertMin);

    if (m_bYaxisTitleChg) {
        pTitle = SysAllocString(m_pszYaxisTitle);
        pObj->put_YAxisLabel(pTitle);
        if (pTitle) {
            SysFreeString(pTitle);
        }
    }

    if (m_bGraphTitleChg) {
        pTitle = SysAllocString(m_pszGraphTitle);
        pObj->put_GraphTitle(pTitle);
        if (pTitle) {
            SysFreeString(pTitle);
        }
    }

    // Clear change flags
    m_bLabelsChg = FALSE;
    m_bVertGridChg = FALSE;
    m_bHorzGridChg = FALSE;
    m_bVertMinChg = FALSE;
    m_bYaxisTitleChg = FALSE;
    m_bGraphTitleChg = FALSE;

    return TRUE;    
}



void CGraphPropPage::DialogItemChange(WORD wID, WORD wMsg)
{

    WCHAR   szTitleBuf[MAX_TITLE_CHARS+1];
    INT     iTitleLen;
    LPWSTR  pszTemp;
    BOOL fChange = FALSE;
    BOOL    fResult;

    switch(wID) {
        case IDC_VERTICAL_MAX:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bVertMaxChg = TRUE;
            } else if ((wMsg == EN_KILLFOCUS) && m_bVertMaxChg) {
                m_iVertMax = GetDlgItemInt(m_hDlg, IDC_VERTICAL_MAX, &fResult, FALSE);
                if (!fResult) {
                    m_iErrVertMax = IDS_VERTMAX_ERR;
                } else {
                    m_iErrVertMax = 0;
                }
            }
            break ;

        case IDC_VERTICAL_MIN:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bVertMinChg = TRUE;
            } else if ((wMsg == EN_KILLFOCUS) && m_bVertMinChg) {
                m_iVertMin =  GetDlgItemInt(m_hDlg, IDC_VERTICAL_MIN, &fResult, FALSE);
                if (!fResult) {
                    m_iErrVertMin = IDS_VERTMIN_ERR;
                } else {
                    m_iErrVertMin = 0;
                }
            }
            break ;

        case IDC_VERTICAL_LABELS:
            if (wMsg == BN_CLICKED)
                {
                m_bLabels = !m_bLabels;
                m_bLabelsChg = TRUE;
                fChange = TRUE;
                }
            break ;

        case IDC_VERTICAL_GRID:
            if (wMsg == BN_CLICKED)
                {
                m_bVertGrid = !m_bVertGrid;
                m_bVertGridChg = TRUE;
                fChange = TRUE;
                }
            break ;

        case IDC_HORIZONTAL_GRID:
            if (wMsg == BN_CLICKED)
                {
                m_bHorzGrid = !m_bHorzGrid;
                m_bHorzGridChg = TRUE;
                fChange = TRUE;
                }
           break ;

        case IDC_YAXIS_TITLE:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bYaxisTitleChg = TRUE;
            }
            else if ((wMsg == EN_KILLFOCUS) && m_bYaxisTitleChg) {

                iTitleLen = DialogText(m_hDlg, IDC_YAXIS_TITLE, szTitleBuf);

                if (iTitleLen == 0) {
                    delete [] m_pszYaxisTitle;
                    m_pszYaxisTitle = NULL;
                }
                else {
                    pszTemp = new WCHAR[iTitleLen+1];
                    if (pszTemp) {
                        delete [] m_pszYaxisTitle;
                        m_pszYaxisTitle = pszTemp;
                        StringCchCopy(m_pszYaxisTitle, iTitleLen+1, szTitleBuf);
                    }
                }
            }                   
            break ;

        case IDC_GRAPH_TITLE:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bGraphTitleChg = TRUE;
            }
            else if ((wMsg == EN_KILLFOCUS) && m_bGraphTitleChg) {

                iTitleLen = DialogText(m_hDlg, IDC_GRAPH_TITLE, szTitleBuf);

                if (iTitleLen == 0) {
                    delete [] m_pszGraphTitle;
                    m_pszGraphTitle = NULL;
                }
                else {
                    pszTemp = new WCHAR[iTitleLen+1];
                    if (pszTemp) {
                        delete [] m_pszGraphTitle;
                        m_pszGraphTitle = pszTemp;
                        StringCchCopy(m_pszGraphTitle, iTitleLen+1, szTitleBuf);
                    }
                }                   
            }                   
            break ;
        }

    if (fChange)
        SetChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iconnpt.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iconnpt.cpp

Abstract:

    Implementation of CImpIConnectionPoint for the Polyline object
    as well as CConnectionPoint.

--*/

#include "polyline.h"
#include "iconnpt.h"
#include "unkhlpr.h"


static const IID *apIIDConnectPt [CONNECTION_POINT_CNT] = {
                &IID_ISystemMonitorEvents,  
                &DIID_DISystemMonitorEvents
                };

//
// CImpIConnPt interface implementation
//
IMPLEMENT_CONTAINED_IUNKNOWN(CImpIConnPtCont)

/*
 * CImpIConnPtCont::CImpIConnPtCont
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CImpIConnPtCont::CImpIConnPtCont ( PCPolyline pObj, LPUNKNOWN pUnkOuter)
    :   m_cRef(0),
        m_pObj(pObj),
        m_pUnkOuter(pUnkOuter)
{
    return; 
}

/*
 * CImpIConnPtCont::~CImpIConnPtCont
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CImpIConnPtCont::~CImpIConnPtCont( void ) 
{   
    return; 
}

/*
 * CImpIConnPtCont::EnumConnectionPoints
 *
 * Purpose:
 *  Not implemented.
 *
 * Return Value:
 *  HRESULT         Error code or S_OK
 */

STDMETHODIMP 
CImpIConnPtCont::EnumConnectionPoints (
    OUT LPENUMCONNECTIONPOINTS *ppIEnum
    )
{
    CImpIEnumConnPt *pEnum;
    HRESULT hr = S_OK;

    if (ppIEnum == NULL) {
        return E_POINTER;
    }

    pEnum = new CImpIEnumConnPt(this, apIIDConnectPt, CONNECTION_POINT_CNT);
    if (pEnum == NULL) {
        hr = E_OUTOFMEMORY;
    }
    else {
        try {
            *ppIEnum = NULL;
            hr = pEnum->QueryInterface(IID_IEnumConnectionPoints, (PPVOID)ppIEnum);   
        } catch (...) {
            hr = E_POINTER;
        }
    }

    if (FAILED(hr) && pEnum) {
        delete pEnum;
    }

    return hr;
}



/*
 * CImpIConnPtCont::FindConnectionPoint
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPoint for a given
 *  outgoing IID.
 *
 * Parameters:
 *  riid            REFIID of the outgoing interface for which
 *                  a connection point is desired.
 *  ppCP            IConnectionPoint ** in which to return
 *                  the pointer after calling AddRef.
 *
 * Return Value:
 *  HRESULT         NOERROR if the connection point is found,
 *                  E_NOINTERFACE if it's not supported.
 */

STDMETHODIMP 
CImpIConnPtCont::FindConnectionPoint (
    IN  REFIID riid,
    OUT IConnectionPoint **ppCP
    )
{
    HRESULT hr = S_OK;
    PCImpIConnectionPoint pConnPt = NULL;
    
    if (ppCP == NULL) {
        return E_POINTER;
    }

    //
    // if request matches one of our connection IDs
    //
    if (IID_ISystemMonitorEvents == riid)
        pConnPt = &m_pObj->m_ConnectionPoint[eConnectionPointDirect];
    else if (DIID_DISystemMonitorEvents == riid)
        pConnPt = &m_pObj->m_ConnectionPoint[eConnectionPointDispatch];
    else {
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr)) {
        try {
            *ppCP=NULL;
            //
            // Return the IConnectionPoint interface
            //
            hr = pConnPt->QueryInterface(IID_IConnectionPoint, (PPVOID)ppCP); 
        } catch (...) {
            hr = E_POINTER;
        }
    }

    return hr;
}


/*
 * CImpIConnectionPoint constructor
 */
CImpIConnectionPoint::CImpIConnectionPoint ( 
    void 
    )
    :   m_cRef(0),
        m_pObj(NULL),
        m_pUnkOuter(NULL),
        m_hEventEventSink(NULL),
        m_lSendEventRefCount(0),
        m_lUnadviseRefCount(0)
{
    m_Connection.pIDirect = NULL;
    m_Connection.pIDispatch = NULL;
}


/*
 * CImpIConnectionPoint destructor
 */
CImpIConnectionPoint::~CImpIConnectionPoint (
    void
    )
{
    DeinitEventSinkLock();
}

/*
 * CImpIConnectionPoint::QueryInterface
 * CImpIConnectionPoint::AddRef
 * CCImpIonnectionPoint::Release
 *
 */

STDMETHODIMP 
CImpIConnectionPoint::QueryInterface ( 
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
    HRESULT hr = S_OK;
    
    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;

        if (IID_IUnknown==riid || IID_IConnectionPoint==riid) {
            *ppv = (PVOID)this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG) 
CImpIConnectionPoint::AddRef(
    void
    )
{   
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}



STDMETHODIMP_(ULONG) 
CImpIConnectionPoint::Release (
    void
    )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



/*
 * CImpIConnectionPoint::Init
 *
 * Purpose:
 * Set back-pointers and connection type.
 *
 * Paramters:
 *  pObj            Containing Object
 *  pUnkOuter       Controlling Object
 *  iConnectType    Connection point type
 */
BOOL
CImpIConnectionPoint::Init (
    IN PCPolyline   pObj,
    IN LPUNKNOWN    pUnkOuter,
    IN INT          iConnPtType
    )
{
    DWORD dwStat = 0;

    m_pObj = pObj;
    m_pUnkOuter = pUnkOuter;
    m_iConnPtType = iConnPtType;

    dwStat = InitEventSinkLock();
    if (dwStat != ERROR_SUCCESS) {
        return FALSE;
    } 

    return TRUE;
}


/*
 * CImpIConnectionPoint::GetConnectionInterface
 *
 * Purpose:
 *  Returns the IID of the outgoing interface supported through
 *  this connection point.
 *
 * Parameters:
 *  pIID            IID * in which to store the IID.
 */

STDMETHODIMP 
CImpIConnectionPoint::GetConnectionInterface (
    OUT IID *pIID
    )
{
    HRESULT hr = S_OK;

    if (pIID == NULL) {
        return E_POINTER;
    }

    try {
        *pIID = *apIIDConnectPt[m_iConnPtType];
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



/*
 * CImpIConnectionPoint::GetConnectionPointContainer
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPointContainer that
 *  is manageing this connection point.
 *
 * Parameters:
 *  ppCPC           IConnectionPointContainer ** in which to return
 *                  the pointer after calling AddRef.
 */

STDMETHODIMP 
CImpIConnectionPoint::GetConnectionPointContainer (
    OUT IConnectionPointContainer **ppCPC
    )
{
    HRESULT hr = S_OK;

    if (ppCPC == NULL) {
        return E_POINTER;
    }

    try {
        *ppCPC = NULL;
        m_pObj->QueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



/*
 * CImpIConnectionPoint::Advise
 *
 * Purpose:
 *  Provides this connection point with a notification sink to
 *  call whenever the appropriate outgoing function/event occurs.
 *
 * Parameters:
 *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection
 *                  point must QueryInterface on this pointer to obtain
 *                  the proper interface to call.  The connection
 *                  point must also insure that any pointer held has
 *                  a reference count (QueryInterface will do it).
 *  pdwCookie       DWORD * in which to store the connection key for
 *                  later calls to Unadvise.
 */

STDMETHODIMP 
CImpIConnectionPoint::Advise (
    IN  LPUNKNOWN pUnkSink,
    OUT DWORD *pdwCookie
    )
{
    HRESULT hr = S_OK;

    if (pUnkSink == NULL || pdwCookie == NULL) {
        return E_POINTER;
    }

    //
    // Can only support one connection
    //
    if (NULL != m_Connection.pIDirect) {
        hr = CONNECT_E_ADVISELIMIT;
    } 
    else {
        try {
            *pdwCookie = 0;

            //
            // Get interface from sink
            //
            hr = pUnkSink->QueryInterface(*apIIDConnectPt[m_iConnPtType], (PPVOID)&m_Connection);
            if (SUCCEEDED(hr)) {
                //
                // Return our cookie
                //
                *pdwCookie = eAdviseKey;
            }
        } catch (...) {
            hr = E_POINTER;
        }
    }
    
    return hr;
}



/*
 * CImpIConnectionPoint::SendEvent
 *
 * Purpose:
 *  Sends an event to the attached event sink
 *
 * Parameters:
 *  uEventType     Event code
 *  dwParam        Parameter to send with event
 *
 */
void
CImpIConnectionPoint::SendEvent (
    IN UINT uEventType,
    IN DWORD dwParam
    )
{
    // If not connected, just return.

    if ( EnterSendEvent() ) {
        if (m_Connection.pIDirect != NULL) {

            // For direct connection, call the method
            if (m_iConnPtType == eConnectionPointDirect) {

                switch (uEventType) {

                case eEventOnCounterSelected:
                    m_Connection.pIDirect->OnCounterSelected((INT)dwParam);
                    break;

                case eEventOnCounterAdded:
                    m_Connection.pIDirect->OnCounterAdded((INT)dwParam);
                    break;

                case eEventOnCounterDeleted:
                    m_Connection.pIDirect->OnCounterDeleted((INT)dwParam);
                    break;

                case eEventOnSampleCollected:
                    m_Connection.pIDirect->OnSampleCollected();
                    break;

                case eEventOnDblClick:
                    m_Connection.pIDirect->OnDblClick((INT)dwParam);
                    break;
                }
            }
            // for dispatch connection, call Invoke
            else if ( m_iConnPtType == eConnectionPointDispatch ) {
                if ( NULL != m_Connection.pIDispatch ) {

                    DISPPARAMS  dp;
                    VARIANT     vaRet;
                    VARIANTARG  varg;

                    VariantInit(&vaRet);

                    if ( uEventType == eEventOnSampleCollected ) {
                        SETNOPARAMS(dp)
                    } else { 
                        VariantInit(&varg);
                        V_VT(&varg) = VT_I4;
                        V_I4(&varg) = (INT)dwParam;
                    
                        SETDISPPARAMS(dp, 1, &varg, 0, NULL)
                    }

                    m_Connection.pIDispatch->Invoke(uEventType, 
                                                    IID_NULL, 
                                                    LOCALE_USER_DEFAULT, 
                                                    DISPATCH_METHOD, 
                                                    &dp , 
                                                    &vaRet, 
                                                    NULL, 
                                                    NULL);
                }
            }
        }
    }

    ExitSendEvent();
    
    return;
}

/*
 * CImpIConnectionPoint::Unadvise
 *
 * Purpose:
 *  Terminates the connection to the notification sink identified
 *  with dwCookie (that was returned from Advise).  The connection
 *  point has to Release any held pointers for that sink.
 *
 * Parameters:
 *  dwCookie        DWORD connection key from Advise.
 */

STDMETHODIMP 
CImpIConnectionPoint::Unadvise ( 
    IN  DWORD dwCookie 
    )
{
    if (eAdviseKey != dwCookie)
        return CONNECT_E_NOCONNECTION;

    EnterUnadvise();

    m_Connection.pIDirect = NULL;

    ExitUnadvise();

    return S_OK;
}



/*
 * CImpIConnectionPoint::EnumConnections
 *
 * Purpose:
 *  Not implemented because only one conection is allowed
 */

STDMETHODIMP 
CImpIConnectionPoint::EnumConnections ( 
    OUT LPENUMCONNECTIONS *ppEnum
    )
{
    HRESULT hr = E_NOTIMPL;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        *ppEnum = NULL;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 *  Locks for the event sink.
 */

DWORD 
CImpIConnectionPoint::InitEventSinkLock ( void )
{
    DWORD dwStat = 0;
    
    m_lUnadviseRefCount = 0;
    m_lSendEventRefCount = 0;

    if ( NULL == ( m_hEventEventSink = CreateEvent ( NULL, TRUE, TRUE, NULL ) ) )
        dwStat = GetLastError();

    return dwStat;
}

void 
CImpIConnectionPoint::DeinitEventSinkLock ( void )
{
    // Release the event sink lock
    if ( NULL != m_hEventEventSink ) {
        CloseHandle ( m_hEventEventSink );
        m_hEventEventSink = NULL;
    }
    m_lSendEventRefCount = 0;
    m_lUnadviseRefCount = 0;

}

BOOL
CImpIConnectionPoint::EnterSendEvent ( void )
{
    // Return value indicates whether lock is granted.
    // If lock is not granted, must still call ExitSendEvent.

    // Increment the SendEvent reference count when SendEvent is active.
    InterlockedIncrement( &m_lSendEventRefCount );

    // Grant the lock unless the event sink pointer is being modified in Unadvise. 
    return ( 0 == m_lUnadviseRefCount );
}

void
CImpIConnectionPoint::ExitSendEvent ( void )
{
    LONG lTemp;

    // Decrement the SendEvent reference count. 
    lTemp = InterlockedDecrement( &m_lSendEventRefCount );

    // Signal the event sink if SendEvent count decremented to 0.
    // lTemp is the value previous to decrement.
    if ( 0 == lTemp )
        SetEvent( m_hEventEventSink );
}


void
CImpIConnectionPoint::EnterUnadvise ( void )
{
    BOOL bStatus;

    bStatus = ResetEvent( m_hEventEventSink );

    // Increment the Unadvise reference count whenever Unadvise is active.
    // Whenever this is > 0, events are not fired.
    InterlockedIncrement( &m_lUnadviseRefCount );

    // Wait until SendEvent is no longer active.
    while ( m_lSendEventRefCount > 0 ) {
        WaitForSingleObject( m_hEventEventSink, eEventSinkWaitInterval );
        bStatus = ResetEvent( m_hEventEventSink );
    }
}

void
CImpIConnectionPoint::ExitUnadvise ( void )
{
    // Decrement the Unadvise reference count. 
    InterlockedDecrement( &m_lUnadviseRefCount );
}


CImpIEnumConnPt::CImpIEnumConnPt (
    IN  CImpIConnPtCont  *pConnPtCont,
    IN  const IID **ppIID,
    IN  ULONG cItems
    )
{
    m_pConnPtCont = pConnPtCont;
    m_apIID = ppIID;
    m_cItems = cItems;

    m_uCurrent = 0;
    m_cRef = 0;
}


STDMETHODIMP
CImpIEnumConnPt::QueryInterface (
    IN  REFIID riid, 
    OUT PVOID *ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;

        if ((riid == IID_IUnknown) || (riid == IID_IEnumConnectionPoints)) {
            *ppv = this;
            AddRef();
        } else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG)
CImpIEnumConnPt::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CImpIEnumConnPt::Release(
    VOID
    )
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CImpIEnumConnPt::Next(
    IN  ULONG cItems,
    OUT IConnectionPoint **apConnPt,
    OUT ULONG *pcReturned)
{
    ULONG i;
    ULONG cRet;
    HRESULT hr = S_OK;

    if (apConnPt == NULL) {
        return E_POINTER;
    }

    try {
        //
        // Clear the return values
        //
        for (i = 0; i < cItems; i++) {
            apConnPt[i] = NULL;
        }

        // Try to fill the caller's array
        for (cRet = 0; cRet < cItems; cRet++) {

            // No more, return success with false
            if (m_uCurrent == m_cItems) {
                hr = S_FALSE;
                break;
            }

            // Ask connection point container for next connection point
            hr = m_pConnPtCont->FindConnectionPoint(*m_apIID[m_uCurrent], &apConnPt[cRet]);

            if (FAILED(hr))
                break;

            m_uCurrent++;
        }

        //
        // If failed, free the accumulated interfaces
        //
        if (FAILED(hr)) {
            for (i = 0; i < cRet; i++) {
                ReleaseInterface(apConnPt[i]);
            }
            cRet = 0;
        }

        if (pcReturned) {
            *pcReturned = cRet;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/***
*HRESULT CImpIEnumConnPt::Skip(unsigned long)
*Purpose:
*  Attempt to skip over the next 'celt' elements in the enumeration
*  sequence.
*
*Entry:
*  celt = the count of elements to skip
*
*Exit:
*  return value = HRESULT
*    S_OK
*    S_FALSE -  the end of the sequence was reached
*
***********************************************************************/
STDMETHODIMP
CImpIEnumConnPt::Skip(
    IN  ULONG   cItems
    )
{
    m_uCurrent += cItems;

    if (m_uCurrent > m_cItems) {
        m_uCurrent = m_cItems;
        return S_FALSE;
    }

    return S_OK;
}


/***
*HRESULT CImpIEnumConnPt::Reset(void)
*Purpose:
*  Reset the enumeration sequence back to the beginning.
*
*Entry:
*  None
*
*Exit:
*  return value = SHRESULT CODE
*    S_OK
*
***********************************************************************/
STDMETHODIMP
CImpIEnumConnPt::Reset(
    VOID
    )
{
    m_uCurrent = 0;

    return S_OK; 
}


/***
*HRESULT CImpIEnumConnPt::Clone(IEnumVARIANT**)
*Purpose:
*  Retrun a CPoint enumerator with exactly the same state as the
*  current one.
*
*Entry:
*  None
*
*Exit:
*  return value = HRESULT
*    S_OK
*    E_OUTOFMEMORY
*
***********************************************************************/
STDMETHODIMP
CImpIEnumConnPt::Clone (
    OUT IEnumConnectionPoints **ppEnum
    )
{
    CImpIEnumConnPt *pNewEnum = NULL;
    HRESULT hr = S_OK;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        *ppEnum = NULL;

        // Create new enumerator
        pNewEnum = new CImpIEnumConnPt(m_pConnPtCont, m_apIID, m_cItems);
        if (pNewEnum != NULL) {
            // Copy current position
            pNewEnum->m_uCurrent = m_uCurrent;
            *ppEnum = pNewEnum;
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pNewEnum) {
        delete pNewEnum;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\hatchwnd.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    hatchwnd.h

Abstract:

    Header file for the CHatchWin class.  CHatchWin when used 
    as a parent window creates a thin hatch border around 
    the child window.

--*/

#ifndef _HATCHWND_H_
#define _HATCHWND_H_

//Window extra bytes and offsets
#define CBHATCHWNDEXTRA                 (sizeof(LONG_PTR))
#define HWWL_STRUCTURE                  0

//Notification codes for WM_COMMAND messages
#define HWN_BORDERDOUBLECLICKED         1
#define HWN_RESIZEREQUESTED             2


// Drag modes
#define DRAG_IDLE       0
#define DRAG_PENDING    1
#define DRAG_ACTIVE     2

class CHatchWin
    {
    friend LRESULT APIENTRY HatchWndProc(HWND, UINT, WPARAM, LPARAM);

    protected:
        HWND        m_hWnd;
        HWND        m_hWndParent;       //Parent's window
        UINT        m_uDragMode;
        UINT        m_uHdlCode;
        RECT        m_rectNew;
        POINT       m_ptDown;
        POINT       m_ptHatchOrg;
        HRGN        m_hRgnDrag;
        BOOLEAN     m_bResizeInProgress;

    private:
        void        OnMouseMove(INT x, INT y);
        void        OnLeftDown(INT x, INT y);
        void        OnLeftUp(void);
        void        StartTracking(void);
        void        OnTimer(void);
        void        OnPaint(void);

    public:
        INT         m_iBorder;
        UINT        m_uID;
        HWND        m_hWndKid;
        HWND        m_hWndAssociate;
        RECT        m_rcPos;
        RECT        m_rcClip;

    public:

        CHatchWin(void);
        ~CHatchWin(void);

        BOOL        Init(HWND, UINT, HWND);

        HWND        Window(void);

        HWND        HwndAssociateSet(HWND);
        HWND        HwndAssociateGet(void);

        void        RectsSet(LPRECT, LPRECT);
        void        ChildSet(HWND);
        void        ShowHatch(BOOL);
    };

typedef CHatchWin *PCHatchWin;

#endif //_HATCHWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iconnpt.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iconnpt.h

Abstract:

    Header file for connection points.

--*/

#ifndef _ICONNPT_H_
#define _ICONNPT_H_


// Event types
// These values match the ID's in smonctrl.odl
enum {
    eEventOnCounterSelected=1,
    eEventOnCounterAdded=2,
    eEventOnCounterDeleted=3,
    eEventOnSampleCollected=4,
    eEventOnDblClick=5
};

// Connection Point Types
enum {
    eConnectionPointDirect=0,
    eConnectionPointDispatch=1
    };
#define CONNECTION_POINT_CNT 2


// Connection Point Class
class CImpIConnectionPoint : public IConnectionPoint {

    public:
        CImpIConnectionPoint(void);
        ~CImpIConnectionPoint(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IConnectionPoint members
        STDMETHODIMP GetConnectionInterface(IID *);
        STDMETHODIMP GetConnectionPointContainer (IConnectionPointContainer **);
        STDMETHODIMP Advise(LPUNKNOWN, DWORD *);
        STDMETHODIMP Unadvise(DWORD);
        STDMETHODIMP EnumConnections(IEnumConnections **);

        //Members not exposed by IConnectionPoint
        BOOL Init(PCPolyline pObj, LPUNKNOWN PUnkOuter, INT iConnPtType);
        void SendEvent(UINT uEventType, DWORD dwParam); // Send event to sink 

    private:

        enum IConnPtConstant {
            eAdviseKey = 1234,
            eEventSinkWaitInterval = 2000
        };

        DWORD   InitEventSinkLock ( void );
        void    DeinitEventSinkLock ( void );
        BOOL    EnterSendEvent ( void );
        void    ExitSendEvent ( void );
        void    EnterUnadvise ( void );
        void    ExitUnadvise ( void );

        ULONG           m_cRef;        //Object reference count
        LPUNKNOWN       m_pUnkOuter;   //Controlling unknown
        PCPolyline      m_pObj;        //Containing object
        INT             m_iConnPtType; // Direct or dispatch connection 
        HANDLE          m_hEventEventSink;
        LONG            m_lUnadviseRefCount;
        LONG            m_lSendEventRefCount;

        union {
            IDispatch               *pIDispatch; // Outgoing interface
            ISystemMonitorEvents    *pIDirect;
        } m_Connection;

};

typedef CImpIConnectionPoint *PCImpIConnectionPoint;



// Connection Point Container Class
class CImpIConnPtCont : public IConnectionPointContainer
    {
    public:
        CImpIConnPtCont(PCPolyline, LPUNKNOWN);
        ~CImpIConnPtCont(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(DWORD) AddRef(void);
        STDMETHODIMP_(DWORD) Release(void);

        //IConnectionPointContainer members
        STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **);
        STDMETHODIMP FindConnectionPoint(REFIID, IConnectionPoint **);

    private:

        ULONG               m_cRef;      //Interface ref count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    };

typedef CImpIConnPtCont *PCImpIConnPtCont;


// Connection Point Enumerator Class
class CImpIEnumConnPt : public IEnumConnectionPoints
{
protected:
    CImpIConnPtCont *m_pConnPtCont;
    DWORD       m_cRef;
    ULONG       m_cItems;
    ULONG       m_uCurrent;
    const IID   **m_apIID;
    
public:

    CImpIEnumConnPt (CImpIConnPtCont *pConnPtCont, const IID **apIID, ULONG cItems);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    // Enum methods
    STDMETHOD(Next) (ULONG cItems, IConnectionPoint **apConnPt, ULONG *pcReturned);
    STDMETHOD(Skip) (ULONG cSkip);
    STDMETHOD(Reset) (VOID);
    STDMETHOD(Clone) (IEnumConnectionPoints **pIEnum);
};


#endif //_ICONNPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\idataobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    idataobj.cpp

Abstract:

    Implementation of the IDataObject interface.

--*/

#include "polyline.h"
#include "unkhlpr.h"

// CImpIDataObject interface implmentation
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIDataObject)


/*
 * CImpIDataObject::GetData
 *
 * Purpose:
 *  Retrieves data described by a specific FormatEtc into a StgMedium
 *  allocated by this function.  Used like GetClipboardData.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the desired data.
 *  pSTM            LPSTGMEDIUM in which to return the data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIDataObject::GetData(
    IN  LPFORMATETC pFE, 
    OUT LPSTGMEDIUM pSTM
    )
{
    CLIPFORMAT  cf;
    IStream     *pIStream = NULL;
    HDC         hDevDC = NULL;
    HRESULT     hr = DATA_E_FORMATETC;

    if (pFE == NULL || pSTM == NULL) {
        return E_POINTER;
    }

    try {
        cf = pFE->cfFormat;

        //
        // Use do{}while(0) to act like a switch statement
        //
        do {
            //
            //Check the aspects we support.
            //
            if (!(DVASPECT_CONTENT & pFE->dwAspect)) {
                hr = DATA_E_FORMATETC;
                break;
            }

            pSTM->pUnkForRelease = NULL;

            //
            //Run creates the window to use as a basis for extents
            //
            m_pObj->m_pImpIRunnableObject->Run(NULL);

            //
            // Go render the appropriate data for the format.
            //
            switch (cf)
            {
                case CF_METAFILEPICT:
                    pSTM->tymed=TYMED_MFPICT;
                    hDevDC = CreateTargetDC (NULL, pFE->ptd );
                    if (hDevDC) {
                        hr = m_pObj->RenderMetafilePict(&pSTM->hGlobal, hDevDC);
                    }
                    else {
                        hr = E_FAIL;
                    }
                    break;

                case CF_BITMAP:
                    pSTM->tymed=TYMED_GDI;
                    hDevDC = CreateTargetDC (NULL, pFE->ptd );
                    if (hDevDC) {
                        hr = m_pObj->RenderBitmap((HBITMAP *)&pSTM->hGlobal, hDevDC);
                    }
                    else {
                        hr = E_FAIL;
                    }
                    break;
    
                default:
                    if (cf == m_pObj->m_cf)
                    {
                        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
                        if (SUCCEEDED(hr)) {
                            hr = m_pObj->m_pCtrl->SaveToStream(pIStream);
                            if (FAILED(hr)) {
                                pIStream->Release();
                            }
                        }
                        else {
                            hr = E_OUTOFMEMORY;
                        }

                        if (SUCCEEDED(hr)) {
                            pSTM->tymed = TYMED_ISTREAM;
                            pSTM->pstm = pIStream;
                        }
                    }
    
                    break;
            }
        } while (0);

    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr)) {
        if (hDevDC) {
            ::DeleteDC(hDevDC);
        }
    }

    return hr;
}




/*
 * CImpIDataObject::GetDataHere
 *
 * Purpose:
 *  Renders the specific FormatEtc into caller-allocated medium
 *  provided in pSTM.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the desired data.
 *  pSTM            LPSTGMEDIUM providing the medium into which
 *                  wer render the data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIDataObject::GetDataHere(
    IN LPFORMATETC pFE, 
    IN OUT LPSTGMEDIUM pSTM
    )
{
    CLIPFORMAT  cf;
    HRESULT     hr = S_OK;

    if (pFE == NULL || pSTM == NULL) {
        return E_POINTER;
    }

    /*
     * The only reasonable time this is called is for
     * CFSTR_EMBEDSOURCE and TYMED_ISTORAGE (and later for
     * CFSTR_LINKSOURCE).  This means the same as
     * IPersistStorage::Save.
     */

    cf = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_EMBEDSOURCE);

    try {
        //Aspect is not important to us here, as is lindex and ptd.
        if (cf == pFE->cfFormat && (TYMED_ISTORAGE & pFE->tymed))
        {
            //We have an IStorage we can write into.
            pSTM->tymed=TYMED_ISTORAGE;
            pSTM->pUnkForRelease=NULL;
    
            hr = m_pObj->m_pImpIPersistStorage->Save(pSTM->pstg, FALSE);
            m_pObj->m_pImpIPersistStorage->SaveCompleted(NULL);
        }
        else {
            hr = DATA_E_FORMATETC;
        }
    } catch (...) {
        hr = E_POINTER;
    }


    return hr;
}



/*
 * CImpIDataObject::QueryGetData
 *
 * Purpose:
 *  Tests if a call to GetData with this FormatEtc will provide
 *  any rendering; used like IsClipboardFormatAvailable.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the desired data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIDataObject::QueryGetData(
    IN LPFORMATETC pFE
    ) 
{
    CLIPFORMAT cf;
    BOOL fRet = FALSE;
    HRESULT hr = S_OK;

    if (pFE == NULL) {
        return E_POINTER;
    }

    try {
        cf = pFE->cfFormat;

        //
        //Check the aspects we support.
        //
        if (!(DVASPECT_CONTENT & pFE->dwAspect)) {
            hr = DATA_E_FORMATETC;
        }
        else {
            switch (cf) {

                case CF_METAFILEPICT:
                    fRet = (BOOL)(pFE->tymed & TYMED_MFPICT);
                    break;
    
                case CF_BITMAP:
                    fRet = (BOOL)(pFE->tymed & TYMED_GDI);
                    break;

                default:
                    //Check our own format.
                    fRet = ((cf==m_pObj->m_cf) && (BOOL)(pFE->tymed & (TYMED_ISTREAM) ));
                    break;
            }
            if (fRet == FALSE) {
                hr = DATA_E_FORMATETC;
            }
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/*
 * CImpIDataObject::GetCanonicalFormatEtc
 *
 * Purpose:
 *  Provides the caller with an equivalent FormatEtc to the one
 *  provided when different FormatEtcs will produce exactly the
 *  same renderings.
 *
 * Parameters:
 *  pFEIn            LPFORMATETC of the first description.
 *  pFEOut           LPFORMATETC of the equal description.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIDataObject::GetCanonicalFormatEtc(
    LPFORMATETC /* pFEIn */, 
    LPFORMATETC pFEOut
    )
{
    if (NULL == pFEOut) {
        return E_POINTER;
    }

    try {
        pFEOut->ptd = NULL;
    } catch (...) {
        return E_POINTER;
    }

    return DATA_S_SAMEFORMATETC;
}



/*
 * CImpIDataObject::SetData
 *
 * Purpose:
 *  Places data described by a FormatEtc and living in a StgMedium
 *  into the object.  The object may be responsible to clean up the
 *  StgMedium before exiting.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the data to set.
 *  pSTM            LPSTGMEDIUM containing the data.
 *  fRelease        BOOL indicating if this function is responsible
 *                  for freeing the data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIDataObject::SetData(
    LPFORMATETC pFE , 
    LPSTGMEDIUM pSTM, 
    BOOL fRelease
    )
{
    CLIPFORMAT cf;
    HRESULT  hr = S_OK;

    if (pFE == NULL || pSTM == NULL) {
        return E_POINTER;
    }

    try {
        cf = pFE->cfFormat;

        do {
            //
            //Check for our own clipboard format and DVASPECT_CONTENT
            //
            if ((cf != m_pObj->m_cf) || !(DVASPECT_CONTENT & pFE->dwAspect)) {
                hr = DATA_E_FORMATETC;
                break;
            }
